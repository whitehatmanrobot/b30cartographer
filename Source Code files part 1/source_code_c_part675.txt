         InfoSize,
    IN      PVOID                   Info,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
    IN      PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateIPXInfoEntry (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      ULONG                   InfoType,
    IN      ULONG                   InfoSize,
    IN      PVOID                   OldInfo    OPTIONAL,
    IN      PVOID                   NewInfo,
    IN      PINFO_CMP_PROC          InfoEqualCB OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateRipFilter (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      BOOLEAN                 Output, 
    IN      PRIP_ROUTE_FILTER_INFO  pOldFilter OPTIONAL,
    IN      PRIP_ROUTE_FILTER_INFO  pNewFilter OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );

DWORD
UpdateSapFilter (
    IN      PIPX_INFO_BLOCK_HEADER  pOldBlock,
    IN      BOOLEAN                 Output, 
    IN      PSAP_SERVICE_FILTER_INFO pOldFilter OPTIONAL,
    IN      PSAP_SERVICE_FILTER_INFO pNewFilter OPTIONAL,
    OUT     PIPX_INFO_BLOCK_HEADER *pNewBlock
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\context.h ===
/*
    Copyright (c) 1999 Microsoft Corporation

    File:   context.h

    Definitions for mechanisms to process contexts relevant to 
    rasmontr.

    3/02/99
*/

DWORD 
RasContextInstallSubContexts(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ipx\protocols\utils.c ===
#include "precomp.h"
#pragma hdrstop


TOKEN_VALUE InterfaceTypes[ 5 ] =
{
    { VAL_CLIENT,       ROUTER_IF_TYPE_CLIENT },
    { VAL_HOMEROUTER,   ROUTER_IF_TYPE_HOME_ROUTER },
    { VAL_WANROUTER,    ROUTER_IF_TYPE_FULL_ROUTER },
    { VAL_DEDICATED,    ROUTER_IF_TYPE_DEDICATED },
    { VAL_INTERNAL,     ROUTER_IF_TYPE_INTERNAL }
};

TOKEN_VALUE InterfaceStates[ 3 ] = 
{
    { VAL_DOWN,         ROUTER_IF_STATE_DISCONNECTED },
    { VAL_DOWN,         ROUTER_IF_STATE_CONNECTING },
    { VAL_UP,           ROUTER_IF_STATE_CONNECTED }
};

TOKEN_VALUE InterfaceEnableStatus[ 2 ] =
{
    { VAL_ENABLED,      FALSE },
    { VAL_DISABLED,     TRUE }
};


TOKEN_VALUE AdminStates[ 2 ] = 
{
    { VAL_DISABLED,     ADMIN_STATE_DISABLED },
    { VAL_ENABLED,      ADMIN_STATE_ENABLED }
};

TOKEN_VALUE OperStates[ 3 ] =
{
    { VAL_DOWN,         OPER_STATE_DOWN },
    { VAL_UP,           OPER_STATE_UP     },
    { VAL_SLEEPING,     OPER_STATE_SLEEPING }
};

TOKEN_VALUE IpxInterfaceTypes[ 8 ] = 
{
    { VAL_OTHER,        IF_TYPE_OTHER },
    { VAL_DEDICATED,    IF_TYPE_LAN },
    { VAL_WANROUTER,    IF_TYPE_WAN_ROUTER },
    { VAL_CLIENT,       IF_TYPE_WAN_WORKSTATION },
    { VAL_INTERNAL,     IF_TYPE_INTERNAL },
    { VAL_HOMEROUTER,   IF_TYPE_PERSONAL_WAN_ROUTER },
    { VAL_DIALOUT,      IF_TYPE_ROUTER_WORKSTATION_DIALOUT },
    { VAL_DIALOUT,      IF_TYPE_STANDALONE_WORKSTATION_DIALOUT }
};

TOKEN_VALUE RouterInterfaceTypes[ 5 ] =
{
    { VAL_CLIENT,       ROUTER_IF_TYPE_CLIENT },
    { VAL_HOMEROUTER,   ROUTER_IF_TYPE_HOME_ROUTER },
    { VAL_WANROUTER,    ROUTER_IF_TYPE_FULL_ROUTER },
    { VAL_DEDICATED,    ROUTER_IF_TYPE_DEDICATED },
    { VAL_INTERNAL,     ROUTER_IF_TYPE_INTERNAL }
};

TOKEN_VALUE NbDeliverStates[ 4 ] =
{
    { VAL_DISABLED,     ADMIN_STATE_DISABLED },
    { VAL_ENABLED,      ADMIN_STATE_ENABLED },
    { VAL_STATICONLY,   ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING },
    { VAL_ONLYWHENUP,   ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP}
};


TOKEN_VALUE UpdateModes[ 3 ] =
{
    { VAL_STANDARD,     IPX_STANDARD_UPDATE },
    { VAL_NONE,         IPX_NO_UPDATE },
    { VAL_AUTOSTATIC,   IPX_AUTO_STATIC_UPDATE }
};

TOKEN_VALUE IpxProtocols[ 4 ] =
{
    { VAL_LOCAL,        IPX_PROTOCOL_LOCAL },
    { VAL_STATIC,       IPX_PROTOCOL_STATIC },
    { VAL_RIP,          IPX_PROTOCOL_RIP },
    { VAL_SAP,          IPX_PROTOCOL_SAP }
};  

TOKEN_VALUE TfFilterActions[ 2 ] = 
{
    { VAL_PERMIT,       IPX_TRAFFIC_FILTER_ACTION_PERMIT },
    { VAL_DENY,         IPX_TRAFFIC_FILTER_ACTION_DENY }
};

TOKEN_VALUE RipFilterActions[ 2 ] = 
{
    { VAL_PERMIT,       IPX_ROUTE_FILTER_PERMIT },
    { VAL_DENY,         IPX_ROUTE_FILTER_DENY }
};


TOKEN_VALUE SapFilterActions[ 2 ] =
{
    { VAL_PERMIT,       IPX_SERVICE_FILTER_PERMIT },
    { VAL_DENY,         IPX_SERVICE_FILTER_DENY }
};


TOKEN_VALUE FilterModes[ 2 ] = 
{
    { VAL_INPUT,        INPUT_FILTER },
    { VAL_OUTPUT,       OUTPUT_FILTER }
};

TOKEN_VALUE LogLevels[ 4 ] = 
{
    { VAL_NONE ,        0 },
    { VAL_ERRORS_ONLY , EVENTLOG_ERROR_TYPE },
    { VAL_ERRORS_AND_WARNINGS,  EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE },
    { VAL_MAXINFO, 
        EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE }
};


DWORD
GetIpxInterfaceIndex(
    IN      MIB_SERVER_HANDLE   hRouterMIB,
    IN      LPCWSTR             InterfaceName,
    OUT     ULONG              *InterfaceIndex
    )
/*++

Routine Description :

    This routine retrives the index of an interface given its name.

Arguments :

    hRouterMIB - Handle to the router service

    InterfaceName - Name of interface for which index is required

    InterfaceIndex - On return contains the interface of the interface
                     if found.

Return values :

    
--*/
{

    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    DWORD                   IfSize = sizeof(IPX_INTERFACE);
    PIPX_INTERFACE          Ifp;
    DWORD                   rc;
    UCHAR                   InterfaceNameA[ MAX_INTERFACE_NAME_LEN + 1 ];

    
    //
    // Convert interface name to Ansi
    //

    wcstombs( InterfaceNameA, InterfaceName, MAX_INTERFACE_NAME_LEN );

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;

    //
    // Begin enumerating interfaces
    //
    
    rc = MprAdminMIBEntryGetFirst(
            hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
            sizeof( IPX_MIB_GET_INPUT_DATA ), (LPVOID *) &Ifp,
            &IfSize
            );

    //
    // until a match is found or there are no more interfaces
    //
    
    while ( rc == NO_ERROR )
    {
        //
        // Is this the interface
        //
        
        if ( _stricmp( (LPSTR)InterfaceNameA, (LPSTR) Ifp->InterfaceName) == 0 )
        {
            *InterfaceIndex = Ifp->InterfaceIndex;
            
            MprAdminMIBBufferFree (Ifp);
            
            break;
        }
        else 
        {
            MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 
                Ifp->InterfaceIndex;
                
            MprAdminMIBBufferFree (Ifp);
        }
        
        rc = MprAdminMIBEntryGetNext(
                hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&Ifp, &IfSize
                );
    }

    if ( rc == ERROR_NO_MORE_ITEMS )
    {
        rc = ERROR_NO_SUCH_INTERFACE;
    }
    
    return rc;
}

DWORD
GetIpxInterfaceName (
    IN      MIB_SERVER_HANDLE   hRouterMIB,
    IN      ULONG               InterfaceIndex,
    OUT     LPWSTR              InterfaceName
    ) 
/*++

Routine Description :

    This routine retrives the index of an interface given its name.

Arguments :

    hRouterMIB - Handle to the router service

    InterfaceName - Name of interface for which index is required

    InterfaceIndex - On return contains the interface of the interface
                     if found.

Return values :

    
--*/
{
    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    DWORD                   IfSize = sizeof( IPX_INTERFACE );
    PIPX_INTERFACE          Ifp;
    DWORD                   rc;


    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    
    MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex = 
        InterfaceIndex;
    
    rc = MprAdminMIBEntryGet(
            hRouterMIB, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
            sizeof(IPX_MIB_GET_INPUT_DATA), (LPVOID *)&Ifp, &IfSize
            );
            
    if ( rc == NO_ERROR )
    {
        mbstowcs( 
            InterfaceName, (LPSTR)Ifp->InterfaceName,
            IPX_INTERFACE_ANSI_NAME_LEN
            );

        MprAdminMIBBufferFree( Ifp );
    }
    
    else if ( rc == ERROR_NO_MORE_ITEMS )
    {
        rc = ERROR_NO_SUCH_INTERFACE;
    }
    
    return rc;
}



/*++
*******************************************************************
        G e t I P X T o c E n t r y

Routine Description:
    Returns pointer to entry in Router Table Of Context
Arguments:
    pInterfaceInfo    - pointer to table of content
    InfoEntryType    - type of entry to look for
Return Value:
    Pointer to entry in table of content
    NULL if there is no such entry in the table
Remarks:
*******************************************************************
--*/
PIPX_TOC_ENTRY
GetIPXTocEntry(
    IN PIPX_INFO_BLOCK_HEADER   pInterfaceInfo,
    IN ULONG                    InfoEntryType
    ) 
{
    UINT            i;
    PIPX_TOC_ENTRY  pTocEntry;

    if (pInterfaceInfo)
    {
        for ( i = 0, pTocEntry = pInterfaceInfo->TocEntry;
              i < pInterfaceInfo->TocEntriesCount;
              i++, pTocEntry++) 
        {
            if (pTocEntry->InfoType == InfoEntryType) 
            {
                return pTocEntry;
            }
        }
    }        

    SetLastError( ERROR_FILE_NOT_FOUND );
    
    return NULL;
}


DWORD
AddIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER       pOldBlock,
    IN ULONG                        InfoType,
    IN ULONG                        InfoSize,
    IN PVOID                        Info,
    IN PINFO_CMP_PROC               InfoEqualCB OPTIONAL,
    OUT PIPX_INFO_BLOCK_HEADER     *pNewBlock
) 
{
    ULONG                    i, entriesCount = 1;
    PIPX_TOC_ENTRY           pTocEntry;
    PIPX_INFO_BLOCK_HEADER   pBlock;
    ULONG                    newBlockSize = 
                                InfoSize + sizeof( IPX_INFO_BLOCK_HEADER );
    BOOLEAN                  done = FALSE;
    DWORD                    rc;


    if ( pOldBlock != NULL ) 
    {
        ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);
        
        for ( i=0, pTocEntry = pOldBlock->TocEntry;
              i < pOldBlock->TocEntriesCount;
              i++, pTocEntry++) 
        {
            newBlockSize += pTocEntry->InfoSize*pTocEntry->Count;
            
            if (pTocEntry->InfoType == InfoType) 
            {
                ULONG    j;
                LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;

                ASSERT (pTocEntry->InfoSize == InfoSize);
                
                for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
                {
                    BOOL    found;
                    
                    if (InfoEqualCB!=NULL)
                    {
                        found = (*InfoEqualCB) (pInfo, Info);
                    }
                    else
                    {
                        found = memcmp (pInfo, Info, InfoSize)==0;
                    }
                    
                    if (found)
                    {
                        return ERROR_ALREADY_EXISTS;
                    }
                }
            }
            
            else 
            {
                entriesCount += 1;
                newBlockSize += sizeof (IPX_TOC_ENTRY);
            }
        }
    }
    
    pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
    
    if ( pBlock != NULL ) 
    {
        ULONG   dstOffset = 
                    FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
                    
        PIPX_TOC_ENTRY    dstToc = pBlock->TocEntry;


        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->Size = newBlockSize;
        pBlock->TocEntriesCount = entriesCount;
        
        if (pOldBlock!=NULL) 
        {
            for (i=0, pTocEntry = pOldBlock->TocEntry; 
                 i<pOldBlock->TocEntriesCount; i++, pTocEntry++) 
            {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;

                memcpy ((PUCHAR)pBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);

                dstOffset += dstToc->InfoSize*dstToc->Count;

                if (dstToc->InfoType==InfoType) 
                {
                    memcpy ((PUCHAR)pBlock+dstOffset, Info, InfoSize);
                    dstToc->Count += 1;
                    dstOffset += InfoSize;
                    done = TRUE;
                }
                dstToc += 1;
            }
        }

        if (!done) 
        {
            dstToc->InfoType = InfoType;
            dstToc->InfoSize = InfoSize;
            dstToc->Count = 1;
            dstToc->Offset = dstOffset;
            memcpy ((PUCHAR)pBlock+dstOffset, Info, InfoSize);
        }
        
        *pNewBlock = pBlock;
        rc = NO_ERROR;
    }
    else
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return rc;
}

DWORD
DeleteIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER   pOldBlock,
    IN ULONG                    InfoType,
    IN ULONG                    InfoSize,
    IN PVOID                    Info,
    IN PINFO_CMP_PROC           InfoEqualCB OPTIONAL,
    IN PIPX_INFO_BLOCK_HEADER  *pNewBlock
)
{
    ULONG           i, entriesCount = 1, j;
    PIPX_TOC_ENTRY  pTocEntry, dstToc;
    ULONG           newBlockSize = sizeof (IPX_INFO_BLOCK_HEADER)-InfoSize;
    ULONG           dstOffset;
    BOOLEAN         found = FALSE;
    

    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i<pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        newBlockSize += pTocEntry->InfoSize*pTocEntry->Count;
        
        if (pTocEntry->InfoType == InfoType) 
        {
            LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;

            ASSERT (pTocEntry->InfoSize == InfoSize);
            
            for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
            {
                if ( InfoEqualCB != NULL )
                {
                    found = (BOOLEAN) (*InfoEqualCB) (pInfo, Info);
                }
                else
                {
                    found = memcmp (pInfo, Info, InfoSize)==0;
                }
                
                if (found) 
                {
                    if (pTocEntry->Count==1) 
                    {
                        entriesCount -= 1;
                        newBlockSize -= sizeof (IPX_TOC_ENTRY);
                    }
                    break;
                }
            }

            if (!found)
            {
                return ERROR_FILE_NOT_FOUND;
            }
        }

        else 
        {
            entriesCount += 1;
            newBlockSize += sizeof (IPX_TOC_ENTRY);
        }
    }

    if (!found)
    {
        return ERROR_FILE_NOT_FOUND;
    }

    for ( i=0, dstToc = pTocEntry = pOldBlock->TocEntry; 
          i < pOldBlock->TocEntriesCount; i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType==InfoType) 
        {
            if (pTocEntry->Count>1) 
            {
                pTocEntry->Count -= 1;
                dstToc += 1;
            }
        }
        else
        {
            if (dstToc!=pTocEntry) 
            {
                ASSERT (dstToc<pTocEntry);
                *dstToc = *pTocEntry;
            }
            dstToc += 1;
        }
    }

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
    
    for (i=0, pTocEntry = pOldBlock->TocEntry; 
         i<entriesCount; i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType==InfoType) 
        {
            ULONG    newInfoSize = InfoSize*j;

            if ( j > 0 )
            {
                if (dstOffset!=pTocEntry->Offset) 
                {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((PUCHAR)pOldBlock+dstOffset,
                            (PUCHAR)pOldBlock+pTocEntry->Offset,
                            newInfoSize);
                }
            }

            if ( j < pTocEntry->Count )
            {
                memmove ((PUCHAR)pOldBlock+dstOffset+newInfoSize,
                        (PUCHAR)pOldBlock+pTocEntry->Offset+newInfoSize+InfoSize,
                        InfoSize*(pTocEntry->Count-j));
                newInfoSize += InfoSize*(pTocEntry->Count-j);
            }
            
            pTocEntry->Offset = dstOffset;
            dstOffset += newInfoSize;
        }
        else
        {
            if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pOldBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pOldBlock->Size = newBlockSize;
    pOldBlock->TocEntriesCount = entriesCount;

    *pNewBlock = pOldBlock;
    return NO_ERROR;
}
    
DWORD
UpdateIPXInfoEntry (
    IN PIPX_INFO_BLOCK_HEADER   pOldBlock,
    IN ULONG                    InfoType,
    IN ULONG                    InfoSize,
    IN PVOID                    OldInfo     OPTIONAL,
    IN PVOID                    NewInfo,
    IN PINFO_CMP_PROC           InfoEqualCB OPTIONAL,
    OUT PIPX_INFO_BLOCK_HEADER *pNewBlock
    ) 
{
    ULONG                    i, j, entriesCount = 1;
    PIPX_TOC_ENTRY           pTocEntry;
    PIPX_INFO_BLOCK_HEADER   pBlock;
    ULONG                    newBlockSize = 
                                InfoSize+sizeof (IPX_INFO_BLOCK_HEADER);
    BOOLEAN                  done = FALSE;
    DWORD                    rc;



    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i < pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType == InfoType) 
        {
            LPBYTE    pInfo = (LPBYTE)pOldBlock+pTocEntry->Offset;
            
            if (OldInfo!=NULL) 
            {
                ASSERT (pTocEntry->InfoSize == InfoSize);
                
                for (j=0; j<pTocEntry->Count; j++, pInfo+=InfoSize) 
                {
                    BOOLEAN    found;

                    if (InfoEqualCB!=NULL)
                    {
                        found = (BOOLEAN) (*InfoEqualCB) (pInfo, OldInfo);
                    }
                    else
                    {
                        found = memcmp (pInfo, OldInfo, InfoSize)==0;
                    }

                    if (found) 
                    {
                        memcpy (pInfo, NewInfo, InfoSize);
                        *pNewBlock = pOldBlock;
                        return NO_ERROR;
                    }
                }
            }
            
            else
            {
                ASSERT (pTocEntry->Count==1);

                if (pTocEntry->InfoSize==InfoSize) 
                {
                    memcpy (pInfo, NewInfo, InfoSize);
                    *pNewBlock = pOldBlock;
                    return NO_ERROR;
                }    

                newBlockSize -= pTocEntry->InfoSize+sizeof (IPX_INFO_BLOCK_HEADER);
            }
        }
        else 
        {
            entriesCount += 1;
            newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    
    pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);

    if ( pBlock != NULL ) 
    {
        ULONG    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER,TocEntry[entriesCount]);
        PIPX_TOC_ENTRY    dstToc = pBlock->TocEntry;

        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->Size = newBlockSize;
        pBlock->TocEntriesCount = entriesCount;
        
        for (i=0, pTocEntry = pOldBlock->TocEntry; 
             i<pOldBlock->TocEntriesCount; i++, pTocEntry++) 
        {
            *dstToc = *pTocEntry;
            dstToc->Offset = dstOffset;

            if (dstToc->InfoType==InfoType) 
            {
                if (pTocEntry->InfoSize==InfoSize) 
                {
                    memcpy ((PUCHAR)pBlock+dstOffset,
                        (PUCHAR)pOldBlock+pTocEntry->Offset,
                        pTocEntry->InfoSize*pTocEntry->Count);

                    dstOffset += dstToc->InfoSize*dstToc->Count;

                    memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);

                    dstOffset += InfoSize;
                    dstToc->Count += 1;
                }
                else
                {
                    memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);
                    dstToc->InfoSize = InfoSize;
                    dstOffset += InfoSize;
                }
                
                done = TRUE;
            }
            else
            {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);

                dstOffset += dstToc->InfoSize*dstToc->Count;
            }
            
            dstToc += 1;
        }

        if (!done) 
        {
            dstToc->InfoType = InfoType;
            dstToc->InfoSize = InfoSize;
            dstToc->Count = 1;
            dstToc->Offset = dstOffset;
            memcpy ((PUCHAR)pBlock+dstOffset, NewInfo, InfoSize);
        }
        
        *pNewBlock = pBlock;
        rc = NO_ERROR;
    }
    
    else
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return rc;
}



DWORD
UpdateRipFilter (
    IN    PIPX_INFO_BLOCK_HEADER    pOldBlock,
    IN    BOOLEAN                   Output, 
    IN    PRIP_ROUTE_FILTER_INFO    pOldFilter OPTIONAL,
    IN    PRIP_ROUTE_FILTER_INFO    pNewFilter OPTIONAL,
    OUT   PIPX_INFO_BLOCK_HEADER   *pNewBlock
    )
{
    ULONG                   i,j;
    PIPX_TOC_ENTRY          pTocEntry, dstToc;
    PIPX_INFO_BLOCK_HEADER  pBlock;
    ULONG                   newBlockSize = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry);
    BOOLEAN                 found = FALSE;
    PRIP_ROUTE_FILTER_INFO  pRfInfo;
    ULONG                   supplyCount, listenCount, count, newCount;
    PRIP_IF_CONFIG          pRipCfg;
    ULONG                   dstOffset;

    if (pOldBlock == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);


    for ( i = 0, pTocEntry = pOldBlock->TocEntry;
          i < pOldBlock->TocEntriesCount;
          i++, pTocEntry++ ) 
    {
        if ( pTocEntry->InfoType == IPX_PROTOCOL_RIP )
        {
            found = TRUE;
            pRipCfg = (PRIP_IF_CONFIG)((LPBYTE)pOldBlock+pTocEntry->Offset);
            
            supplyCount = pRipCfg->RipIfFilters.SupplyFilterCount;
            listenCount = pRipCfg->RipIfFilters.ListenFilterCount;

            if (Output) 
            {
                pRfInfo = &pRipCfg->RipIfFilters.RouteFilter[0];
                count = supplyCount;
            }
            else
            {
                pRfInfo = &pRipCfg->RipIfFilters.RouteFilter[
                                pRipCfg->RipIfFilters.SupplyFilterCount];
                count = listenCount;
            }
            
            newCount = count;

            if (ARGUMENT_PRESENT (pNewFilter)) 
            {
                for (j=0; j<count; j++) 
                {
                    if (memcmp (&pRfInfo[j],pNewFilter,sizeof (*pNewFilter))==0)
                    {
                        return ERROR_ALREADY_EXISTS;
                    }
                }
                
                newBlockSize += sizeof (*pNewFilter);
                newCount += 1;
            }

            if (ARGUMENT_PRESENT (pOldFilter)) 
            {
                for (j=0; j<count; j++) 
                {
                    if (memcmp (&pRfInfo[j],pOldFilter,sizeof (*pOldFilter))==0)
                    {
                        break;
                    }
                }
                
                if (j>=count)
                {
                    return ERROR_FILE_NOT_FOUND;
                }
                
                newBlockSize -= sizeof (*pNewFilter);
                newCount -= 1;
            }
            
            else
            {
                j = count;
            }
        }

        newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
    }
    

    if (!found)
    {
        return ERROR_FILE_NOT_FOUND;
    }


    if ( (newBlockSize>pOldBlock->Size) || 
         !ARGUMENT_PRESENT (pOldFilter)) 
    {
        pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
        
        if (pBlock==NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->TocEntriesCount = pOldBlock->TocEntriesCount;
        dstToc = pBlock->TocEntry;
    }
    
    else
    {
        pBlock = pOldBlock;
    }

    dstOffset = FIELD_OFFSET(
                    IPX_INFO_BLOCK_HEADER, TocEntry[pBlock->TocEntriesCount]
                    );
                    
    for (i=0, pTocEntry = pOldBlock->TocEntry;
         i<pOldBlock->TocEntriesCount;
         i++, pTocEntry++, dstToc++) 
    {
        if (pTocEntry->InfoType == IPX_PROTOCOL_RIP) 
        {
            ULONG    curOffset = 
                        FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter);
                        
            if (pBlock!=pOldBlock) 
            {
                memcpy ((LPBYTE)pBlock+dstOffset,
                        pRipCfg,
                        curOffset);
            }
            
            else if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((LPBYTE)pBlock+dstOffset,
                        pRipCfg,
                        curOffset);
            }


            if (Output) 
            {
                if (j>0) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    else if (dstOffset!=pTocEntry->Offset) 
                    {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    
                    curOffset += j*sizeof (pRfInfo[0]);
                }
                
                if (ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                {
                    j += 1;
                }


                if (j<count) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    
                    else if ( (dstOffset!=pTocEntry->Offset) ||
                              !ARGUMENT_PRESENT (pNewFilter)) 
                    {
                        ASSERT (dstOffset<= pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    
                    curOffset += (count-j)*sizeof (pRfInfo[0]);
                }

                
                if (pBlock!=pOldBlock) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[supplyCount],
                            listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }

                else if ( (dstOffset!=pTocEntry->Offset) ||
                          !ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[supplyCount],
                            listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                
                curOffset += listenCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]);
                
                ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.SupplyFilterCount = newCount;
                
                if ((newCount==1) && (count==0))
                {
                    ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.SupplyFilterAction = IPX_ROUTE_FILTER_DENY;
                }
            }
            
            else 
            {
                if (pBlock!=pOldBlock) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[0],
                            supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                
                else if (dstOffset!=pTocEntry->Offset) 
                {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pRipCfg->RipIfFilters.RouteFilter[0],
                            supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]));
                }
                
                curOffset += supplyCount*sizeof (pRipCfg->RipIfFilters.RouteFilter[0]);
                
                if (j>0) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }

                    else if (dstOffset!=pTocEntry->Offset) 
                    {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                            pRfInfo, j*sizeof (pRfInfo[0]));
                    }
                    
                    curOffset += j*sizeof (pRfInfo[0]);
                }
                

                if (ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }


                if (ARGUMENT_PRESENT (pOldFilter))
                {
                    j += 1;
                }

                if (j<count) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    
                    else if ( (dstOffset!=pTocEntry->Offset) || 
                              !ARGUMENT_PRESENT (pNewFilter)) 
                    {
                        ASSERT (dstOffset<=pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pRfInfo[j], (count-j)*sizeof (pRfInfo[0]));
                    }
                    
                    curOffset += (count-j)*sizeof (pRfInfo[0]);
                }
                
                ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.ListenFilterCount = newCount;
                
                if ((newCount==1) && (count==0))
                {
                    ((PRIP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->RipIfFilters.ListenFilterAction = IPX_ROUTE_FILTER_DENY;
                }
            }

            if (pBlock!=pOldBlock) 
            {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
                dstToc->InfoSize = curOffset;
            }
            
            else 
            {
                pTocEntry->Offset = dstOffset;
                pTocEntry->InfoSize = curOffset;
            }

            dstOffset += curOffset;
        }
        else
        {
            if (pBlock!=pOldBlock) 
            {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
            }
            
            else if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pBlock->Size = newBlockSize;
    *pNewBlock = pBlock;
    return NO_ERROR;
}



DWORD
UpdateSapFilter (
    IN    PIPX_INFO_BLOCK_HEADER    pOldBlock,
    IN    BOOLEAN                   Output, 
    IN    PSAP_SERVICE_FILTER_INFO  pOldFilter OPTIONAL,
    IN    PSAP_SERVICE_FILTER_INFO  pNewFilter OPTIONAL,
    OUT   PIPX_INFO_BLOCK_HEADER   *pNewBlock
    ) 
{
    ULONG                           i,j;
    PIPX_TOC_ENTRY                  pTocEntry, dstToc;
    PIPX_INFO_BLOCK_HEADER          pBlock;
    ULONG                           newBlockSize = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry);
    BOOLEAN                         found = FALSE;
    PSAP_SERVICE_FILTER_INFO        pSfInfo;
    ULONG                           supplyCount, listenCount, count, newCount;
    PSAP_IF_CONFIG                  pSapCfg;
    ULONG                           dstOffset;

    if (pOldBlock == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT (pOldBlock->Version==IPX_ROUTER_VERSION_1);
    

    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i<pOldBlock->TocEntriesCount;
          i++, pTocEntry++) 
    {
        if (pTocEntry->InfoType == IPX_PROTOCOL_SAP)
        {
            found = TRUE;
            pSapCfg = (PSAP_IF_CONFIG)((LPBYTE)pOldBlock+pTocEntry->Offset);
            
            supplyCount = pSapCfg->SapIfFilters.SupplyFilterCount;
            listenCount = pSapCfg->SapIfFilters.ListenFilterCount;

            if (Output) 
            {
                pSfInfo = &pSapCfg->SapIfFilters.ServiceFilter[0];
                count = supplyCount;
            }
            else 
            {
                pSfInfo = &pSapCfg->SapIfFilters.ServiceFilter[
                                pSapCfg->SapIfFilters.SupplyFilterCount];
                count = listenCount;
            }
            
            newCount = count;

            if (ARGUMENT_PRESENT (pNewFilter)) 
            {
                for (j=0; j<count; j++) 
                {
                    if ((pSfInfo[j].ServiceType==pNewFilter->ServiceType)
                            && (strncmp ((LPSTR)pSfInfo[j].ServiceName, 
                                    (LPSTR)pNewFilter->ServiceName,
                                    sizeof (pNewFilter->ServiceName))==0))
                        break;
                }
                
                if (j<count)
                {
                    return ERROR_CAN_NOT_COMPLETE;
                }
                
                newBlockSize += sizeof (*pNewFilter);
                newCount += 1;
            }

            if (ARGUMENT_PRESENT (pOldFilter)) 
            {
                for (j=0; j<count; j++) 
                {
                    if ((pSfInfo[j].ServiceType==pOldFilter->ServiceType)
                            && (strncmp ((LPSTR)pSfInfo[j].ServiceName, 
                                    (LPSTR)pOldFilter->ServiceName,
                                    sizeof (pOldFilter->ServiceName))==0))
                        break;
                }
                
                if (j>=count)
                {
                    return ERROR_CAN_NOT_COMPLETE;
                }
                
                newBlockSize -= sizeof (*pNewFilter);
                newCount -= 1;
            }
            
            else
            {
                j = count;
            }
        }

        newBlockSize += sizeof (IPX_TOC_ENTRY)+pTocEntry->InfoSize*pTocEntry->Count;
    }
    

    if (!found)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }


    if ((newBlockSize>pOldBlock->Size) || !ARGUMENT_PRESENT (pOldFilter)) 
    {
        pBlock = (PIPX_INFO_BLOCK_HEADER)GlobalAlloc (GPTR, newBlockSize);
        
        if (pBlock==NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pBlock->Version = IPX_ROUTER_VERSION_1;
        pBlock->TocEntriesCount = pOldBlock->TocEntriesCount;
        dstToc = pBlock->TocEntry;
    }
    
    else
    {
        pBlock = pOldBlock;
    }

    dstOffset = FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry[pBlock->TocEntriesCount]);
    
    for ( i=0, pTocEntry = pOldBlock->TocEntry;
          i < pOldBlock->TocEntriesCount;
          i++, pTocEntry++, dstToc++) 
    {
        if (pTocEntry->InfoType == IPX_PROTOCOL_SAP) 
        {
            ULONG    curOffset = FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter);
            
            if (pBlock!=pOldBlock) 
            {
                memcpy ((LPBYTE)pBlock+dstOffset,
                        pSapCfg,
                        curOffset);
            }
            else if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((LPBYTE)pBlock+dstOffset,
                        pSapCfg,
                        curOffset);
            }


            if (Output) 
            {
                if (j>0) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    
                    else if (dstOffset!=pTocEntry->Offset) 
                    {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    
                    curOffset += j*sizeof (pSfInfo[0]);
                }
                
                if (ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                {
                    j += 1;
                }


                if (j<count) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    
                    else if ((dstOffset!=pTocEntry->Offset) || !ARGUMENT_PRESENT (pNewFilter)) 
                    {
                        ASSERT (dstOffset<=pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    
                    curOffset += (count-j)*sizeof (pSfInfo[0]);
                }
                
                if (pBlock!=pOldBlock) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[supplyCount],
                            listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                
                else if ((dstOffset!=pTocEntry->Offset) || !ARGUMENT_PRESENT (pNewFilter)) 
                {
                    ASSERT (dstOffset<=pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[supplyCount],
                            listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                
                curOffset += listenCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]);
                ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.SupplyFilterCount = newCount;
                
                if ((newCount==1) && (count==0))
                {
                    ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.SupplyFilterAction = IPX_SERVICE_FILTER_DENY;
                }
            }
            
            else 
            {
                if (pBlock!=pOldBlock) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[0],
                            supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                
                else if (dstOffset!=pTocEntry->Offset) 
                {
                    ASSERT (dstOffset<pTocEntry->Offset);
                    memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                            &pSapCfg->SapIfFilters.ServiceFilter[0],
                            supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]));
                }
                
                curOffset += supplyCount*sizeof (pSapCfg->SapIfFilters.ServiceFilter[0]);
                
                if (j>0)
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    
                    else if (dstOffset!=pTocEntry->Offset) 
                    {
                        ASSERT (dstOffset<pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                        pSfInfo, j*sizeof (pSfInfo[0]));
                    }
                    
                    curOffset += j*sizeof (pSfInfo[0]);
                }

                if (ARGUMENT_PRESENT (pNewFilter)) 
                {
                    memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                            pNewFilter,
                            sizeof (*pNewFilter));
                    curOffset += sizeof (*pNewFilter);
                }

                if (ARGUMENT_PRESENT (pOldFilter))
                {
                    j += 1;
                }

                if (j<count) 
                {
                    if (pBlock!=pOldBlock) 
                    {
                        memcpy ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    
                    else if ( (dstOffset!=pTocEntry->Offset) || 
                              !ARGUMENT_PRESENT (pNewFilter)) 
                    {
                        ASSERT (dstOffset<=pTocEntry->Offset);
                        memmove ((LPBYTE)pBlock+dstOffset+curOffset,
                                    &pSfInfo[j], (count-j)*sizeof (pSfInfo[0]));
                    }
                    
                    curOffset += (count-j)*sizeof (pSfInfo[0]);
                }
                
                ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.ListenFilterCount = newCount;
                
                if ((newCount==1) && (count==0))
                {
                    ((PSAP_IF_CONFIG)((LPBYTE)pBlock+dstOffset))->SapIfFilters.ListenFilterAction = IPX_SERVICE_FILTER_DENY;
                }
            }

            if (pBlock!=pOldBlock) 
            {
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
                dstToc->InfoSize = curOffset;
            }

            else 
            {
                pTocEntry->Offset = dstOffset;
                pTocEntry->InfoSize = curOffset;
            }

            dstOffset += curOffset;
        }
        
        else 
        {
            if (pBlock!=pOldBlock) 
            {
                memcpy ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                *dstToc = *pTocEntry;
                dstToc->Offset = dstOffset;
            }
            
            else if (dstOffset!=pTocEntry->Offset) 
            {
                ASSERT (dstOffset<pTocEntry->Offset);
                memmove ((PUCHAR)pBlock+dstOffset,
                    (PUCHAR)pOldBlock+pTocEntry->Offset,
                    pTocEntry->InfoSize*pTocEntry->Count);
                pTocEntry->Offset = dstOffset;
            }
            
            dstOffset += pTocEntry->InfoSize*pTocEntry->Count;
        }
    }

    pBlock->Size = newBlockSize;
    *pNewBlock = pBlock;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\context.c ===
/*
    File:   context.h

    Mechanisms to process contexts relevant to 
    rasmontr.

    3/02/99
*/

#include "precomp.h"

// Includes for the sub contexts
//
#include "rasip.h"
#include "rasipx.h"
#include "rasnbf.h"
#include "rasat.h"
#include "rasaaaa.h"
#include "rasdiag.h"

NS_HELPER_ATTRIBUTES g_pSubContexts[] =
{
    // Ip subcontext
    //
    {
        { RASIP_VERSION, 0 }, RASIP_GUID, RasIpStartHelper, NULL
    },

    // Ipx subcontext
    //
    {
        { RASIPX_VERSION, 0 }, RASIPX_GUID, RasIpxStartHelper, NULL
    },

    // Nbf subcontext
    //
    {
        { RASNBF_VERSION, 0 }, RASNBF_GUID, RasNbfStartHelper, NULL
    },

    // At (appletalk) subcontext
    //
    {
        { RASAT_VERSION, 0 }, RASAT_GUID, RasAtStartHelper, NULL
    },

    // Aaaa subcontext
    //
    {
        { RASAAAA_VERSION, 0 }, RASAAAA_GUID, RasAaaaStartHelper, NULL
    },

    // Diag subcontext
    //
    {
        { RASDIAG_VERSION, 0 }, RASDIAG_GUID, RasDiagStartHelper, NULL
    }

};

#define g_dwSubContextCount \
            (sizeof(g_pSubContexts) / sizeof(*g_pSubContexts))

//
// Installs all of the sub contexts provided
// in this .dll (for example, "ras ip", "ras client", etc.)
//
DWORD 
RasContextInstallSubContexts()
{
    DWORD dwErr = NO_ERROR, i;
    PNS_HELPER_ATTRIBUTES pCtx = NULL;

    for (i = 0, pCtx = g_pSubContexts; i < g_dwSubContextCount; i++, pCtx++)
    {
        // Initialize helper attributes
        //
        RegisterHelper( &g_RasmontrGuid, pCtx );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\client.c ===
/*
    File:   client.c

    Support for netsh commands that manipulate ras clients.

*/

#include "precomp.h"
#pragma hdrstop

//
// Callback function for enumerating clients
//
typedef
DWORD
(*CLIENT_ENUM_CB_FUNC)(
    IN DWORD dwLevel,
    IN LPBYTE pbClient,
    IN HANDLE hData);

//
// Client enumerate callback that displays the connection
//
DWORD
ClientShow(
    IN DWORD dwLevel,
    IN LPBYTE pbClient,
    IN HANDLE hData)
{
    RAS_CONNECTION_0 * pClient = (RAS_CONNECTION_0*)pbClient;
    DWORD dwDays, dwHours, dwMins, dwSecs, dwTime, dwTemp;

    dwTime  = pClient->dwConnectDuration;
    dwDays  = dwTime / (24*60*60);
    dwTemp  = dwTime - (dwDays * 24*60*60); // temp is # of secs in cur day
    dwHours = dwTemp / (60*60);
    dwTemp  = dwTemp - (dwHours * 60*60);   // temp is # of secs in cur min
    dwMins  = dwTemp / 60;
    dwSecs  = dwTemp % 60;

    DisplayMessage(
        g_hModule,
        MSG_CLIENT_SHOW,
        pClient->wszUserName,
        pClient->wszLogonDomain,
        pClient->wszRemoteComputer,
        dwDays,
        dwHours,
        dwMins,
        dwSecs);

    return NO_ERROR;
}

//
// Enumerates the client connections
//
DWORD 
ClientEnum(
    IN CLIENT_ENUM_CB_FUNC pEnum,
    IN DWORD dwLevel,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hAdmin = NULL;
    LPBYTE pbBuffer = NULL;
    DWORD dwRead, dwTot, dwResume = 0, i;
    RAS_CONNECTION_0 * pCur;
    BOOL bContinue = FALSE;

    do
    {
        // Connection to mpr api server
        //
        dwErr = MprAdminServerConnect(
                    g_pServerInfo->pszServer,
                    &hAdmin);
        BREAK_ON_DWERR(dwErr);

        do
        {
            // Enumerate
            //
            dwErr = MprAdminConnectionEnum(
                        hAdmin,
                        dwLevel,
                        &pbBuffer,
                        4096,
                        &dwRead,
                        &dwTot,
                        &dwResume);
            if (dwErr == ERROR_MORE_DATA)
            {
                dwErr = NO_ERROR;
                bContinue = TRUE;
            }
            else
            {
                bContinue = FALSE;
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Call the callback for each connection as long
            // as we're instructed to keep going
            //
            pCur = (RAS_CONNECTION_0*)pbBuffer;
            for (i = 0; (i < dwRead) && (dwErr == NO_ERROR); i++)
            {
                if (pCur->dwInterfaceType == ROUTER_IF_TYPE_CLIENT)
                {
                    dwErr = (*pEnum)(
                                dwLevel,
                                (LPBYTE)pCur,
                                hData);
                }
                pCur++;
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }
            
            // Free up the interface list buffer
            //
            if (pbBuffer)
            {
                MprAdminBufferFree(pbBuffer);
                pbBuffer = NULL;
            }

            // Keep this loop going until there are 
            // no more connections
            //

        } while (bContinue);

    } while (FALSE);

    // Cleanup
    {
        if (hAdmin)
        {
            MprAdminServerDisconnect(hAdmin);
        }
    }

    return dwErr;
}

//
// Shows whether HandleRasflagSet has been called on the
// given domain.
//
DWORD
HandleClientShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;

    // Make sure no arguments were passed in
    //
    if (dwArgCount - dwCurrentIndex != 0)
    {
        return ERROR_INVALID_SYNTAX;
    }

    dwErr = ClientEnum(ClientShow, 0, NULL);
    if (RPC_S_UNKNOWN_IF == dwErr)
    {
        DisplayMessage(
            g_hModule,
            EMSG_UNABLE_TO_ENUM_CLIENTS);

        dwErr = NO_ERROR;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\defs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\if\defs.h

Abstract:

    global definitions

Revision History:

    AmritanR

--*/


#define is      ==
#define isnot   !=
#define and     &&
#define or      ||

#define RASMON_ERROR_BASE 0xFEFF0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\domhndl.h ===
FN_HANDLE_CMD    HandleDomainRegister;
FN_HANDLE_CMD    HandleDomainUnregister;

FN_HANDLE_CMD    HandleDomainSetAccess;

FN_HANDLE_CMD    HandleDomainEnable;

FN_HANDLE_CMD    HandleDomainShowRegistration;
FN_HANDLE_CMD    HandleDomainShowAccess;

DWORD
DomainDumpConfig(
    IN  HANDLE hFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\domhndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    domhndl.c

Abstract:

    Handlers for ras commands

Revision History:

    pmay

--*/

#include "precomp.h"
#pragma hdrstop

// 
// Common data to all domain api's
//
typedef struct _DOMAIN_API_DATA
{
    PWCHAR pszDomain;
    PWCHAR pszServer;
    DWORD dwLevel;
    
} DOMAIN_API_DATA;

VOID
DomainFreeApiData(
    IN DOMAIN_API_DATA* pData)
{
    if (pData)
    {
        if (pData->pszDomain)
        {
            RutlFree(pData->pszDomain);
        }
        if (pData->pszServer)
        {
            RutlFree(pData->pszServer);
        }

        RutlFree(pData);
    }
}

// 
// Generates an equivalent set of domain api data suitable for 
// display
//
DWORD
DomainGeneratePrintableData(
    IN  DOMAIN_API_DATA*  pSrc,
    OUT DOMAIN_API_DATA** ppDst)
{
    DOMAIN_API_DATA* pDst = NULL;
    DOMAIN_CONTROLLER_INFO* pDomInfo = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        *ppDst = NULL;
        
        pDst = (DOMAIN_API_DATA*) RutlAlloc(sizeof(DOMAIN_API_DATA), TRUE);
        if (pDst is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (pSrc->pszDomain is NULL)
        {
            // Get the default domain
            //
            dwErr = DsGetDcName(NULL, NULL, NULL, NULL, 0, &pDomInfo);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }

            pDst->pszDomain = RutlStrDup(pDomInfo->DomainName);
        }
        else
        {
            pDst->pszDomain = RutlStrDup(pSrc->pszDomain);
        }
        
        if (pSrc->pszServer is NULL)
        {
            DWORD dwSize = 0;
            
            // Find out the computer name length
            //
            GetComputerName(NULL, &dwSize);
            dwErr = GetLastError();
            dwSize = (dwSize + 1) * sizeof(WCHAR);

            if ( (dwErr isnot NO_ERROR) && (dwErr isnot ERROR_BUFFER_OVERFLOW) )
            {
                break;
            }
            dwErr = NO_ERROR;

            pDst->pszServer = (PWCHAR) RutlAlloc(dwSize, TRUE);
            if (pDst->pszServer is NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            GetComputerName(pDst->pszServer, &dwSize);
        }
        else
        {
            pDst->pszServer = RutlStrDup(pSrc->pszServer);
        }

        if (pDst->pszDomain is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (pDst->pszServer is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        
        *ppDst = pDst;                                     
    
    } while (FALSE);

    // Cleanup
    {
        if (dwErr isnot NO_ERROR)
        {
            DomainFreeApiData(pDst);
        }
        if (pDomInfo)
        {
            NetApiBufferFree(pDomInfo);
        }
    }

    return dwErr;
}

//
// Dumps domain related configuration
//
DWORD
DomainDumpConfig(
    IN  HANDLE hFile
    )
{
    DWORD dwErr = NO_ERROR;
    BOOL bRegistered = FALSE;

    //
    // Record the registration of the server
    //
    dwErr = MprDomainQueryRasServer (NULL, NULL, &bRegistered);
    if (dwErr is NO_ERROR)
    {
        DisplayMessageT(
            (bRegistered) ? DMP_DOMAIN_REGISTER 
                          : DMP_DOMAIN_UNREGISTER);
                          
        DisplayMessageT(MSG_NEWLINE);
    }
    
    return dwErr;
}

DWORD
DomainRegister(
    IN  DOMAIN_API_DATA*     pApiData,
    IN  DOMAIN_API_DATA*     pPrintData)
{
    DWORD dwErr = NO_ERROR;

    dwErr = MprDomainRegisterRasServer (
                pApiData->pszDomain,
                pApiData->pszServer,
                TRUE);
                
    if (dwErr is NO_ERROR)
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_REGISTER_SUCCESS,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }
    else
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_REGISTER_FAIL,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }

    return dwErr;
}

DWORD
DomainUnregister(
    IN  DOMAIN_API_DATA*     pApiData,
    IN  DOMAIN_API_DATA*     pPrintData)
{
    DWORD dwErr = NO_ERROR;

    dwErr = MprDomainRegisterRasServer (
                pApiData->pszDomain,
                pApiData->pszServer,
                FALSE);
                
    if (dwErr is NO_ERROR)
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_UNREGISTER_SUCCESS,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }
    else
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_UNREGISTER_FAIL,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }

    return dwErr;
}

DWORD
DomainShowRegistration(
    IN  DOMAIN_API_DATA*     pApiData,
    IN  DOMAIN_API_DATA*     pPrintData)
{
    DWORD dwErr = NO_ERROR;
    BOOL bYes = FALSE;

    dwErr = MprDomainQueryRasServer (
                pApiData->pszDomain,
                pApiData->pszServer,
                &bYes);
                
    if (dwErr is NO_ERROR)
    {
        DisplayMessage(
                g_hModule, 
                (bYes) ? MSG_DOMAIN_SHOW_REGISTERED 
                       : MSG_DOMAIN_SHOW_UNREGISTERED,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }
    else
    {
        DisplayMessage(
                g_hModule, 
                MSG_DOMAIN_SHOW_REGISTER_FAIL,
                pPrintData->pszServer,
                pPrintData->pszDomain);
    }

    return dwErr;
}

//
// Registers/unregisters an W2K machine as a ras server in the 
// active directory of the given domain.
//
DWORD
HandleDomainRegistration(
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      BOOL    *pbDone,
    IN      DWORD   dwMode    // 0 = register, 1 = unregister, 2 = show
    )
{
    DWORD           dwErr = NO_ERROR;
    DOMAIN_API_DATA *pData = NULL, *pPrint = NULL;
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_DOMAIN,   FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_SERVER,  FALSE,  FALSE}, 
            NULL,
            0,
            NULL
        }
    };        

    do 
    {
        // Allocate data structure
        //
        pData = (DOMAIN_API_DATA*) RutlAlloc(sizeof(DOMAIN_API_DATA), TRUE);
        if (pData == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the arguments
        //
        pData->pszDomain = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        pData->pszServer = RASMON_CMD_ARG_GetPsz(&pArgs[1]);

        // 
        // Generate printable data
        //
        dwErr = DomainGeneratePrintableData(
                    pData,
                    &pPrint);
        BREAK_ON_DWERR(dwErr);                    

        // Register
        //
        if (dwMode == 0)
        {
            dwErr = DomainRegister(
                        pData,
                        pPrint);
        }
        else if (dwMode == 1)
        {
            dwErr = DomainUnregister(
                        pData,
                        pPrint);
        }
        else
        {
            dwErr = DomainShowRegistration(
                        pData, 
                        pPrint);
        }
        BREAK_ON_DWERR(dwErr);                    
                    
    } while (FALSE);

    // Cleanup
    {
        DomainFreeApiData(pData);
        DomainFreeApiData(pPrint);
    }

    return dwErr;
}

//
// Registers a W2K server as ras server in active directory
// of the given domain.
//
DWORD
HandleDomainRegister(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleDomainRegistration(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                0);
}

//
// Unregisters a W2K server as ras server in active directory
// of the given domain.
//
DWORD
HandleDomainUnregister(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleDomainRegistration(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                1);
}

//
// Shows whether the given computer is registered 
// in the given domain
//
DWORD
HandleDomainShowRegistration(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleDomainRegistration(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\diagrprt.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    diagrprt.h

Abstract:

    This file contains all defines for the RAS Diag Report.

Author:

    Jeff Sigman (JeffSi) September 13, 2001

Environment:

    User Mode

Revision History:

    JeffSi      09/13/01        Created

--*/

#ifndef _DIAGRPRT_H_
#define _DIAGRPRT_H_

#define ALL_USERS_PROF 0x00000001
#define CURRENT_USER   0x00000002
#define GET_FOR_CM     0x00000004
#define GET_FOR_RAS    0x00000008
#define GET_FOR_MSINFO 0x00000010

#define SHOW_LOGS      0x00000001
#define SHOW_INSTALL   0x00000002
#define SHOW_CONFIG    0x00000004
#define SHOW_ALL       0x0000ffff

#define TIMESIZE         8

#define TIMEDATESTR      80

#define MAX_MSG_LENGTH   5120

#define BUF_WRITE_SIZE   4096

#define TITLE_SIZE       128

#define RPRT_ITM         14
#define RPRT_ITM_VERBOSE 1
//
// Macro to determine the percentage complete
//
#define ADD_PERCENT_DONE(x) \
        ((DWORD)(100 / (x ? (RPRT_ITM + RPRT_ITM_VERBOSE) : RPRT_ITM)))

typedef
LPBYTE
(*RAS_PRINTFILE_FUNC_CB)(
    IN LPBYTE pBuff,
    IN DWORD dwSize,
    IN DWORD dwHours);

typedef struct _BUFFER_WRITE_FILE
{
    DWORD dwPosition;
    HANDLE hFile;
    LPBYTE lpBuff;

} BUFFER_WRITE_FILE;

typedef struct _REPORT_INFO
{
    BOOL fDisplay;
    BOOL fVerbose;
    DWORD dwHours;
    BUFFER_WRITE_FILE* pBuff;
    DiagGetReportCb pCallback;
    GET_REPORT_STRING_CB* pCbInfo;

} REPORT_INFO;

typedef struct _CMD_LINE_UTILS
{
    PWCHAR pwszCmdLine;
    PWCHAR pwszAnchor;

} CMD_LINE_UTILS;

//
// task list structure
//
typedef struct _TASK_LIST
{
    DWORD dwProcessId;
    HANDLE hwnd;
    LPTSTR lpszWinSta;
    LPTSTR lpszDesk;
    WCHAR szWindowTitle[TITLE_SIZE];

} TASK_LIST, *PTASK_LIST;

typedef struct _TASK_LIST_ENUM
{
    PTASK_LIST tlist;
    DWORD dwNumTasks;
    LPTSTR lpszWinSta;
    LPTSTR lpszDesk;
    BOOL bFirstLoop;

} TASK_LIST_ENUM, *PTASK_LIST_ENUM;

extern CONST WCHAR g_pwszLBracket;
extern CONST WCHAR g_pwszRBracket;
extern CONST WCHAR g_pwszBackSlash;
extern CONST WCHAR g_pwszNull;

extern CONST WCHAR g_pwszEmpty[];
extern CONST WCHAR g_pwszSpace[];
extern CONST WCHAR g_pwszLogSrchStr[];
extern CONST WCHAR g_pwszLogging[];
extern CONST WCHAR g_pwszDispNewLine[];

extern CONST WCHAR g_pwszNewLineHtml[];
extern CONST WCHAR g_pwszPreStart[];
extern CONST WCHAR g_pwszPreEnd[];
extern CONST WCHAR g_pwszAnNameStart[];
extern CONST WCHAR g_pwszAnNameMiddle[];
extern CONST WCHAR g_pwszAnNameEnd[];
extern CONST WCHAR g_pwszAnStart[];
extern CONST WCHAR g_pwszAnMiddle[];
extern CONST WCHAR g_pwszAnEnd[];
extern CONST WCHAR g_pwszLiStart[];
extern CONST WCHAR g_pwszLiEnd[];

extern CONST WCHAR g_pwszTableOfContents[];
extern CONST WCHAR g_pwszTraceCollectTracingLogs[];
extern CONST WCHAR g_pwszTraceCollectCmLogs[];
extern CONST WCHAR g_pwszTraceCollectModemLogs[];
extern CONST WCHAR g_pwszTraceCollectIpsecLogs[];
extern CONST WCHAR g_pwszPrintRasEventLogs[];
extern CONST WCHAR g_pwszPrintSecurityEventLogs[];
extern CONST WCHAR g_pwszPrintRasInfData[];
extern CONST WCHAR g_pwszHrValidateRas[];
extern CONST WCHAR g_pwszHrShowNetComponentsAll[];
extern CONST WCHAR g_pwszCheckRasRegistryKeys[];
extern CONST WCHAR g_pwszPrintRasEnumDevices[];
extern CONST WCHAR g_pwszPrintProcessInfo[];
extern CONST WCHAR g_pwszPrintConsoleUtils[];
extern CONST WCHAR g_pwszPrintWinMsdReport[];
extern CONST WCHAR g_pwszPrintAllRasPbks[];

VOID
WriteLinkBackToToc(
    IN BUFFER_WRITE_FILE* pBuff);

VOID
WriteHtmlSection(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszAnchor,
    IN DWORD dwMsgId);

VOID
WriteHeaderSep(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszTitle);

DWORD
BufferWriteFileStrW(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszString);

DWORD
PrintFile(
    IN REPORT_INFO* pInfo,
    IN LPCWSTR pwszFile,
    IN BOOL fWritePath,
    IN RAS_PRINTFILE_FUNC_CB pCallback);

PWCHAR
GetTracingDir();

BOOL
GetCMLoggingSearchPath(
    IN HANDLE hKey,
    IN LPCWSTR pwszName,
    IN LPCWSTR* ppwszLogPath,
    IN LPCWSTR* ppwszSeach);

PWCHAR
FormatMessageFromMod(
    IN HANDLE hModule,
    IN DWORD dwId);

VOID
FreeFormatMessageFromMod(
    IN LPCWSTR pwszMessage);

PWCHAR
LoadStringFromHinst(
    IN HINSTANCE hInst,
    IN DWORD dwId);

VOID
FreeStringFromHinst(
    IN LPCWSTR pwszMessage);

DWORD
CopyAndCallCB(
    IN REPORT_INFO* pInfo,
    IN DWORD dwId);

PWCHAR
CreateErrorString(
    IN WORD wNumStrs,
    IN LPCWSTR pswzStrings,
    IN LPCWSTR pswzErrorMsg);

VOID
WriteEventLogEntry(
    IN BUFFER_WRITE_FILE* pBuff,
    IN PEVENTLOGRECORD pevlr,
    IN LPCWSTR pwszDescr,
    IN LPCWSTR pwszCategory);

DWORD
BufferWriteMessage(
    IN BUFFER_WRITE_FILE* pBuff,
    IN HANDLE hModule,
    IN DWORD dwMsgId,
    ...);

DWORD
WriteNewLine(
    IN BUFFER_WRITE_FILE* pBuff);

DWORD
BufferWriteFileCharW(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST WCHAR wszChar);

DWORD
DiagGetReport(
    IN DWORD dwFlags,
    IN OUT LPCWSTR pwszString,
    IN OPTIONAL DiagGetReportCb pCallback,
    IN OPTIONAL PVOID pContext);

VOID
PrintTableOfContents(
    IN REPORT_INFO* pInfo,
    IN DWORD dwFlag);

DWORD
RasDiagShowAll(
    IN REPORT_INFO* pInfo);

DWORD
RasDiagShowInstallation(
    IN REPORT_INFO* pInfo);

DWORD
RasDiagShowConfiguration(
    IN REPORT_INFO* pInfo);

DWORD
CopyTempFileName(
    OUT LPCWSTR pwszTempFileName);

PWCHAR
CreateHtmFileName(
    IN LPCWSTR pwszFile);

DWORD
CreateReportFile(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszReport);

VOID
CloseReportFile(
    IN BUFFER_WRITE_FILE* pBuff);

VOID
PrintHtmlHeader(
    IN BUFFER_WRITE_FILE* pBuff);

VOID
PrintHtmlFooter(
    IN BUFFER_WRITE_FILE* pBuff);

PWCHAR
CabCompressFile(
    IN LPCWSTR pwszFile);

DWORD
MapiSendMail(
    IN LPCWSTR pwszEmailAdr,
    IN LPCWSTR pwszTempFile);

LPBYTE
ParseRasLogForTime(
    IN LPBYTE pBuff,
    IN DWORD dwSize,
    IN DWORD dwHours);

LPBYTE
ParseModemLogForTime(
    IN LPBYTE pBuff,
    IN DWORD dwSize,
    IN DWORD dwHours);

LPBYTE
ParseCmLogForTime(
    IN LPBYTE pBuff,
    IN DWORD dwSize,
    IN DWORD dwHours);

LPBYTE
ParseIpsecLogForTime(
    IN LPBYTE pBuff,
    IN DWORD dwSize,
    IN DWORD dwHours);

#endif // _DIAGRPRT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\logging.h ===
#ifndef _LOGGING_H_
#define _LOGGING_H_

#define MAX_NUMBER_OF_LOGS 10

// d58c126e-b309-11d1-969e-0000f875a5bc
#define RASL2TP_GUID \
{0xd58c126e, 0xb309, 0x11d1, {0x96, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa5, 0xbc}}

// d58c126f-b309-11d1-969e-0000f875a5bc
#define RASPPTP_GUID \
{0xd58c126f, 0xb309, 0x11d1, {0x96, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa5, 0xbc}}

// 6537b295-83c9-4811-b7fe-e7dbf2f22cec
#define IPSEC_GUID \
{0x6537b295, 0x83c9, 0x4811, {0xb7, 0xfe, 0xe7, 0xdb, 0xf2, 0xf2, 0x2c, 0xec}}

FN_HANDLE_CMD HandleTraceSet;
FN_HANDLE_CMD HandleTraceShow;

typedef struct _TRACING_DATA
{
    BOOL fOneOk;
    BOOL fData;
    HKEY hKey;
    REPORT_INFO* pInfo;

} TRACING_DATA;

typedef struct _WPP_LOG_INFO
{
    DWORD dwActive;
    DWORD dwEnableFlag;
    DWORD dwEnableLevel;
    GUID ControlGuid;
    PEVENT_TRACE_PROPERTIES pProperties;
    WCHAR wszLogFileName[MAX_PATH + 1];
    WCHAR wszSessionName[MAX_PATH + 1];

} WPP_LOG_INFO;

VOID
DiagInitWppTracing();

DWORD
DiagClearAll(
    IN BOOL fDisplay);

BOOL
DiagGetState();

DWORD
DiagSetAll(
    IN BOOL fEnable,
    IN BOOL fDisplay);

DWORD
DiagSetAllRas(
    IN BOOL fEnable);

BOOL
WriteTracingLogsToc(
    IN REPORT_INFO* pInfo);

DWORD
TraceCollectAll(
    IN REPORT_INFO* pInfo);

DWORD
TraceDumpConfig();

DWORD
TraceDumpModem();

DWORD
TraceDumpCm();

DWORD
TraceDumpAuditing();

VOID
TraceShowAll();

BOOL
TraceEnableDisableModem(
    IN BOOL fEnable);

BOOL
TraceShowModem();

BOOL
TraceEnableDisableCm(
    IN BOOL fEnable);

BOOL
TraceShowCm();

BOOL
TraceEnableDisableAuditing(
    IN BOOL fShowOnly,
    IN BOOL fEnable);

BOOL
InitWppData(
    IN WPP_LOG_INFO* pWppLog);

VOID
CleanupWppData(
    IN WPP_LOG_INFO* pWppLog);

BOOL
StopWppTracing(
    IN WPP_LOG_INFO* pWppLog);

DWORD
EnumWppTracing(
    IN RAS_REGKEY_ENUM_FUNC_CB pCallback,
    IN HANDLE hData);

BOOL
TraceEnableDisableAllWpp(
    IN BOOL fEnable);

#endif // _LOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasaaaa.h ===
/*
    File:   rasaaaa.h
    
    Definitions for the 'ras aaaa' sub context

    3/2/99
*/

#ifndef __RASAAAA_H
#define __RASAAAA_H

#define RASAAAA_VERSION 1

// 42e3cc21-098c-11d3-8c4d-00104bca495b 
#define RASAAAA_GUID \
{0x42e3cc21, 0x098c, 0x11d3, {0x8c, 0x4d, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b}}
  
NS_HELPER_START_FN RasAaaaStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasAaaaDump;

FN_HANDLE_CMD   RasAaaaHandleAddAuthServ;
FN_HANDLE_CMD   RasAaaaHandleAddAcctServ;

FN_HANDLE_CMD   RasAaaaHandleDelAuthServ;
FN_HANDLE_CMD   RasAaaaHandleDelAcctServ;

FN_HANDLE_CMD   RasAaaaHandleSetAuth;
FN_HANDLE_CMD   RasAaaaHandleSetAcct;
FN_HANDLE_CMD   RasAaaaHandleSetAuthServ;
FN_HANDLE_CMD   RasAaaaHandleSetAcctServ;

FN_HANDLE_CMD   RasAaaaHandleShowAuth;
FN_HANDLE_CMD   RasAaaaHandleShowAcct;
FN_HANDLE_CMD   RasAaaaHandleShowAuthServ;
FN_HANDLE_CMD   RasAaaaHandleShowAcctServ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\logging.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    logging.c

Abstract:

    Commands to control how logging information is performed.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

static CONST WCHAR g_pszRegValTracingFile[] = L"EnableFileTracing";
static CONST WCHAR g_pszRegKeyTracing[]     = L"SOFTWARE\\Microsoft\\Tracing";
static CONST WCHAR g_pwszAll[]              = L"*";
static CONST WCHAR g_pwszLogPath[]          = L"LoggingPath";
static CONST WCHAR g_pwszEnableLog[]        = L"EnableLogging";
static CONST WCHAR g_pwszSecurity[]         = L"Security";
static CONST WCHAR g_pwszOakleyPath[]       = L"\\debug\\oakley.log";
static CONST WCHAR g_pwszWppActive[]        = L"Active";
static CONST WCHAR g_pwszWppControlFlags[]  = L"ControlFlags";
static CONST WCHAR g_pwszWppControlLevel[]  = L"ControlLevel";
static CONST WCHAR g_pwszWppGuid[]          = L"Guid";
static CONST WCHAR g_pwszWppLogFileName[]   = L"LogFileName";
static CONST WCHAR g_pwszWppPath[] =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing\\Microsoft\\RemoteAccess\\";
static CONST WCHAR g_pwszModemSubkey[] =
    L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}";
static CONST WCHAR g_pwszCmLogAllKey[] =
    L"Software\\Microsoft\\Connection Manager\\UserInfo";
static CONST WCHAR g_pwszCmLogCurKey[] =
    L"Software\\Microsoft\\Connection Manager\\SingleUserInfo";

DWORD
TraceOpenRoot(
    OUT PHKEY phKey);

DWORD
TraceOpenKey(
    IN HKEY hkRoot,
    IN LPCWSTR pszKey,
    OUT PHKEY phKey);

DWORD
TraceCloseKey(
    IN HKEY hKey);

DWORD
TraceWrite(
    IN HKEY hkComp,
    IN DWORD dwEnable);

DWORD
TraceRead(
    IN HKEY hkComp,
    IN LPDWORD lpdwEnable);

DWORD
TraceShow(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

DWORD
TraceDumpComponent(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

DWORD
TraceEnableDisable(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

DWORD
TraceClearTracingCb(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData);

BOOL
TraceClearTracing();

DWORD
TraceCollectTracingLogsCb(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData);

BOOL
TraceCollectTracingLogs(
    IN REPORT_INFO* pInfo,
    IN BOOL fEnable);

DWORD
WriteTracingLogsTocCb(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData);

BOOL
TraceEnableDisableTracing(
    IN BOOL fEnable);

BOOL
TraceShowTracing();

DWORD
TraceClearModemCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

BOOL
TraceClearModem(
    IN BOOL fEnable);

DWORD
TraceCollectModemLogsCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

BOOL
TraceCollectModemLogs(
    IN REPORT_INFO* pInfo,
    IN BOOL fEnable);

DWORD
TraceEnableDisableModemCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

DWORD
TraceShowModemCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

DWORD
TraceClearCmCb(
    IN LPCWSTR pwszName,
    IN HKEY hKey,
    IN HANDLE hData);

BOOL
TraceClearCm(
    IN BOOL fEnable);

DWORD
TraceCollectCmLogsEnumCb(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData);

DWORD
TraceCollectCmLogsCb(
    IN LPCWSTR pwszName,
    IN HKEY hKey,
    IN HANDLE hData);

BOOL
TraceCollectCmLogs(
    IN REPORT_INFO* pInfo,
    IN BOOL fEnable);

DWORD
TraceEnableDisableCmCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

DWORD
TraceShowCmCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

BOOL
TraceClearIpsecLogs(
    IN BOOL fEnable);

BOOL
TraceCollectIpsecLogs(
    IN REPORT_INFO* pInfo);

BOOL
TraceEnableDisableIpsec(
    IN BOOL fEnable);

BOOL
TraceClearAuditing(
    IN BOOL fEnable);

BOOL
WriteWppTracingState(
    IN WPP_LOG_INFO* pWppLog);

BOOL
ReadWppTracingState(
    IN WPP_LOG_INFO* pWppLog);

BOOL
StartWppTracing(
    IN WPP_LOG_INFO* pWppLog);

BOOL
TraceEnableDisableRasL2tp(
    IN BOOL fEnable);

BOOL
TraceEnableDisableRasPptp(
    IN BOOL fEnable);

BOOL
PrintRasEventLogsCb(
    IN PEVENTLOGRECORD pevlr,
    IN HANDLE hModule,
    IN HANDLE hData);

VOID
PrintRasEventLogs(
    IN REPORT_INFO* pInfo);

BOOL
PrintSecurityEventLogsCb(
    IN PEVENTLOGRECORD pevlr,
    IN HANDLE hModule,
    IN HANDLE hData);

VOID
PrintSecurityEventLogs(
    IN REPORT_INFO* pInfo);

DWORD
DiagGetStateCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData);

//
// Opens the root tracing registry key
//
DWORD
TraceOpenRoot(
    OUT PHKEY phKey)
{
    DWORD dwErr = NO_ERROR;

    dwErr = RegOpenKeyExW(
                g_pServerInfo->hkMachine,
                g_pszRegKeyTracing,
                0,
                KEY_ALL_ACCESS,
                phKey);

    return dwErr;
}

DWORD
TraceOpenKey(
    IN HKEY hkRoot,
    IN LPCWSTR pszKey,
    OUT PHKEY phKey)
{
    return RegOpenKeyExW(
                hkRoot,
                pszKey,
                0,
                KEY_ALL_ACCESS,
                phKey);
}

DWORD
TraceCloseKey(
    IN HKEY hKey)
{
    return RegCloseKey(hKey);
}

DWORD
TraceWrite(
    IN HKEY hkComp,
    IN DWORD dwEnable)
{
    return RutlRegWriteDword(
                hkComp,
                (PWCHAR)g_pszRegValTracingFile,
                dwEnable);
}

DWORD
TraceRead(
    IN HKEY hkComp,
    IN LPDWORD lpdwEnable)
{
    return RutlRegReadDword(
                hkComp,
                (PWCHAR)g_pszRegValTracingFile,
                lpdwEnable);
}

DWORD
TraceShow(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, dwEnabled = 0;

    do
    {
        // Get the enabling of the current component
        //
        dwErr = TraceRead(hKey, &dwEnabled);
        BREAK_ON_DWERR(dwErr);

        // Display the status
        //
        DisplayMessage(
            g_hModule,
            MSG_TRACE_SHOW,
            pszName,
            (dwEnabled) ? TOKEN_ENABLED : TOKEN_DISABLED);

    } while (FALSE);

    return dwErr;
}

DWORD
TraceDumpComponent(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    PWCHAR pszComp = NULL, pszEnable = NULL, pszQuote = NULL;
    DWORD dwErr = NO_ERROR, dwEnabled = 0;
    DWORD* pdwShowDisable = (DWORD*)hData;

    do
    {
        dwErr = TraceRead(hKey, &dwEnabled);
        BREAK_ON_DWERR(dwErr);

        pszQuote = MakeQuotedString(pszName);

        pszComp = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_COMPONENT,
                    pszQuote);
        pszEnable = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_STATE,
                        (dwEnabled) ? TOKEN_ENABLED : TOKEN_DISABLED);
        if (pszQuote == NULL || pszComp == NULL || pszEnable == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (dwEnabled || (pdwShowDisable && *pdwShowDisable))
        {
            DisplayMessage(
                g_hModule,
                MSG_TRACE_DUMP,
                DMP_TRACE_SET,
                pszComp,
                pszEnable);
        }

    } while (FALSE);
    //
    // Cleanup
    //
    {
        RutlFree(pszComp);
        RutlFree(pszEnable);
        RutlFree(pszQuote);
    }

    return dwErr;
}

//
// Dumps configuration
//
DWORD
TraceDumpConfig()
{
    PWCHAR pszComp = NULL, pszEnable = NULL;
    DWORD dwErr = NO_ERROR;
    HKEY hkRoot = NULL;

    do
    {
        pszComp = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_COMPONENT,
                    g_pwszAll);
        pszEnable = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_STATE,
                        TOKEN_DISABLED);
        if (pszComp == NULL || pszEnable == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_TRACE_DUMP,
            DMP_TRACE_SET,
            pszComp,
            pszEnable);

        dwErr = TraceOpenRoot(&hkRoot);
        BREAK_ON_DWERR(dwErr);

        dwErr = RutlRegEnumKeys(
                    hkRoot,
                    TraceDumpComponent,
                    NULL);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);
    //
    // Cleanup
    //
    {
        RutlFree(pszComp);
        RutlFree(pszEnable);
        if (hkRoot)
        {
            RegCloseKey(hkRoot);
        }
    }

    return NO_ERROR;
}

DWORD
TraceEnableDisable(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, dwEnabled = 0;
    PDWORD pdwEnable = (PDWORD)hData;

    do
    {
        if (!pdwEnable)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        //
        // Get the enabling of the current component
        //
        dwErr = TraceWrite(hKey, *pdwEnable);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    return dwErr;
}

DWORD
HandleTraceSet(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR, dwEnable;
    PWCHAR pszComponent = NULL;
    HKEY hkRoot = NULL, hkComp = NULL;
    TOKEN_VALUE rgEnumState[] =
    {
        {TOKEN_ENABLED,  1},
        {TOKEN_DISABLED, 0}
    };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_COMPONENT, TRUE, FALSE},
            NULL,
            0,
            NULL
        },
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_STATE, TRUE, FALSE},
            rgEnumState,
            sizeof(rgEnumState)/sizeof(*rgEnumState),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        pszComponent = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        if (!pszComponent)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        dwEnable = RASMON_CMD_ARG_GetDword(&pArgs[1]);

        dwErr = TraceOpenRoot(&hkRoot);
        BREAK_ON_DWERR(dwErr);

        if (wcscmp(pszComponent, g_pwszAll) == 0)
        {
            dwErr = RutlRegEnumKeys(
                        hkRoot,
                        TraceEnableDisable,
                        (HANDLE)&dwEnable);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            dwErr = TraceOpenKey(hkRoot, pszComponent, &hkComp);
            if (dwErr)
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }

            TraceWrite(hkComp, dwEnable);
            BREAK_ON_DWERR(dwErr);
        }

    } while (FALSE);
    //
    // Cleanup
    //
    {
        RutlFree(pszComponent);
        if (hkRoot)
        {
            RegCloseKey(hkRoot);
        }
        if (hkComp)
        {
            RegCloseKey(hkComp);
        }
    }

    return dwErr;
}

DWORD
HandleTraceShow(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR;
    PWCHAR pszComponent = NULL;
    HKEY hkRoot = NULL, hkComp = NULL;
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_COMPONENT,   FALSE, FALSE},
            NULL,
            0,
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        pszComponent = RASMON_CMD_ARG_GetPsz(&pArgs[0]);

        dwErr = TraceOpenRoot(&hkRoot);
        BREAK_ON_DWERR(dwErr);

        if (pszComponent)
        {
            dwErr = TraceOpenKey(hkRoot, pszComponent, &hkComp);
            if (dwErr)
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }

            TraceShow(pszComponent, hkComp, NULL);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            dwErr = RutlRegEnumKeys(
                        hkRoot,
                        TraceShow,
                        NULL);
            BREAK_ON_DWERR(dwErr);
        }

    } while (FALSE);
    //
    // Cleanup
    //
    {
        RutlFree(pszComponent);
        
        if (hkRoot)
        {
            RegCloseKey(hkRoot);
        }
        if (hkComp)
        {
            RegCloseKey(hkComp);
        }
    }

    return dwErr;
}

DWORD
TraceClearTracingCb(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        UINT ulTry = 0;

        while (ulTry++ < 10)
        {
            if (DeleteFile(pwszFQFileName))
            {
                pTrace->fOneOk = TRUE;
                break;
            }
            else if (GetLastError() == ERROR_SHARING_VIOLATION)
            {
                //
                // Wait a little for logging to get disabled
                //
                Sleep(10);
            }
        }
    }

    return NO_ERROR;
}

BOOL
TraceClearTracing(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    PWCHAR pwszTracingPath = NULL;
    TRACING_DATA Trace;

    do
    {
        //
        // Disable tracing
        //
        TraceEnableDisableTracing(FALSE);

        pwszTracingPath = GetTracingDir();
        if (!pwszTracingPath)
        {
            break;
        }

        Trace.fOneOk = FALSE;

        RutlEnumFiles(
            pwszTracingPath,
            (PWCHAR)g_pwszLogSrchStr,
            TraceClearTracingCb,
            &Trace);

        fRet = Trace.fOneOk;
        //
        // Enable tracing
        //
        if (fEnable)
        {
            TraceEnableDisableTracing(TRUE);
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszTracingPath);

    return fRet;
}

DWORD
TraceCollectTracingLogsCb(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        REPORT_INFO* pInfo = pTrace->pInfo;

        if (pInfo)
        {
            UINT ulTry = 0;
            DWORD dwErr = NO_ERROR;

            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnNameStart);
            BufferWriteFileStrW(pInfo->pBuff, pwszFileName);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnNameMiddle);
            BufferWriteFileStrW(pInfo->pBuff, pwszFileName);
            WriteLinkBackToToc(pInfo->pBuff);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnNameEnd);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);

            while (ulTry++ < 10)
            {
                dwErr = PrintFile(
                            pInfo,
                            pwszFQFileName,
                            TRUE,
                            ParseRasLogForTime);
                if (!dwErr)
                {
                    pTrace->fOneOk = TRUE;
                    break;
                }
                else if (ERROR_SHARING_VIOLATION == dwErr)
                {
                    //
                    // Wait a little for logging to get disabled
                    //
                    Sleep(10);
                }
            }

            BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        }
    }

    return NO_ERROR;
}

BOOL
TraceCollectTracingLogs(
    IN REPORT_INFO* pInfo,
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    PWCHAR pwszTracingPath = NULL;
    TRACING_DATA Trace;

    do
    {
        //
        // Disable tracing
        //
        TraceEnableDisableTracing(FALSE);

        pwszTracingPath = GetTracingDir();
        if (!pwszTracingPath)
        {
            break;
        }

        Trace.fOneOk = FALSE;
        Trace.pInfo = pInfo;

        RutlEnumFiles(
            pwszTracingPath,
            (PWCHAR)g_pwszLogSrchStr,
            TraceCollectTracingLogsCb,
            &Trace);

        fRet = Trace.fOneOk;
        //
        // Enable tracing
        //
        if (fEnable)
        {
            TraceEnableDisableTracing(TRUE);
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszTracingPath);

    return fRet;
}

DWORD
WriteTracingLogsTocCb(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        REPORT_INFO* pInfo = pTrace->pInfo;

        if (pInfo)
        {
            BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
            BufferWriteFileStrW(pInfo->pBuff, pwszFileName);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
            BufferWriteFileStrW(pInfo->pBuff, pwszFileName);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

            pTrace->fOneOk = TRUE;
        }
    }

    return NO_ERROR;
}

BOOL
WriteTracingLogsToc(
    IN REPORT_INFO* pInfo)
{
    BOOL fRet = FALSE;
    PWCHAR pwszTracingPath = NULL;
    TRACING_DATA Trace;

    do
    {
        pwszTracingPath = GetTracingDir();
        if (!pwszTracingPath)
        {
            break;
        }

        Trace.fOneOk = FALSE;
        Trace.pInfo = pInfo;

        RutlEnumFiles(
            pwszTracingPath,
            (PWCHAR)g_pwszLogSrchStr,
            WriteTracingLogsTocCb,
            &Trace);

        fRet = Trace.fOneOk;

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszTracingPath);

    return fRet;
}

BOOL
TraceEnableDisableTracing(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    HKEY hkRoot = NULL;
    DWORD dwEnable = fEnable ? 1 : 0;

    if (!TraceOpenRoot(&hkRoot) &&
        !RutlRegEnumKeys(hkRoot, TraceEnableDisable, &dwEnable)
       )
    {
        fRet = TRUE;
    }
    //
    // Clean up
    //
    if (hkRoot)
    {
        RegCloseKey(hkRoot);
    }

    return fRet;
}

BOOL
TraceShowTracing()
{
    BOOL fRet = FALSE;
    HKEY hkRoot = NULL;

    if (!TraceOpenRoot(&hkRoot) &&
        !RutlRegEnumKeys(hkRoot, TraceShow, NULL))
    {
        fRet = TRUE;
    }
    //
    // Clean up
    //
    if (hkRoot)
    {
        RegCloseKey(hkRoot);
    }

    return fRet;
}

DWORD
TraceClearModemCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        PWCHAR pwszPath = NULL;

        if (!RutlRegReadString(hKey, g_pwszLogPath, &pwszPath) &&
            DeleteFile(pwszPath))
        {
            pTrace->fOneOk = TRUE;
        }

        RutlFree(pwszPath);
    }

    return NO_ERROR;
}

BOOL
TraceClearModem(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    HKEY hKey = NULL;
    TRACING_DATA Trace;

    do
    {
        if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    g_pwszModemSubkey,
                    0,
                    KEY_READ,
                    &hKey)
           )
        {
            break;
        }
        //
        // Disable all modem logging
        //
        TraceEnableDisableModem(FALSE);

        Trace.fOneOk = FALSE;

        RutlRegEnumKeys(hKey, TraceClearModemCb, &Trace);

        fRet = Trace.fOneOk;
        //
        // Enable all modem logging
        //
        if (fEnable)
        {
            TraceEnableDisableModem(TRUE);
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return fRet;
}

DWORD
TraceCollectModemLogsCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        REPORT_INFO* pInfo = pTrace->pInfo;

        if (pInfo)
        {
            PWCHAR pwszPath = NULL;

            if (!RutlRegReadString(hKey, g_pwszLogPath, &pwszPath) &&
                !PrintFile(pInfo, pwszPath, TRUE, ParseModemLogForTime))
            {
                pTrace->fOneOk = TRUE;
            }

            RutlFree(pwszPath);
        }
    }

    return NO_ERROR;
}

BOOL
TraceCollectModemLogs(
    IN REPORT_INFO* pInfo,
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    HKEY hKey = NULL;
    TRACING_DATA Trace;

    do
    {
        if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    g_pwszModemSubkey,
                    0,
                    KEY_READ,
                    &hKey)
           )
        {
            break;
        }
        //
        // Disable all modem logging
        //
        TraceEnableDisableModem(FALSE);

        Trace.fOneOk = FALSE;
        Trace.pInfo = pInfo;

        RutlRegEnumKeys(hKey, TraceCollectModemLogsCb, &Trace);

        fRet = Trace.fOneOk;
        //
        // Enable all modem logging
        //
        if (fEnable)
        {
            TraceEnableDisableModem(TRUE);
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return fRet;
}

DWORD
TraceEnableDisableModemCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        DWORD dwEnable = pTrace->fData ? 1 : 0;

        if (!RegSetValueEx(
                hKey,
                g_pwszLogging,
                0,
                REG_BINARY,
                (LPBYTE)&dwEnable,
                1)
           )
        {
            pTrace->fOneOk = TRUE;
        }
    }

    return NO_ERROR;
}

BOOL
TraceEnableDisableModem(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    HKEY hKey = NULL;
    TRACING_DATA Trace;

    do
    {
        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                g_pwszModemSubkey,
                0,
                KEY_READ | KEY_WRITE,
                &hKey)
           )
        {
            break;
        }

        Trace.fOneOk = FALSE;
        Trace.fData = fEnable;

        RutlRegEnumKeys(hKey, TraceEnableDisableModemCb, &Trace);

        fRet = Trace.fOneOk;

    } while (FALSE);
    //
    // Clean up
    //
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return fRet;
}

DWORD
TraceShowModemCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        DWORD dwEnabled = 0;

        if (!RutlRegReadDword(
                hKey,
                g_pwszLogging,
                &dwEnabled) && dwEnabled
           )
        {
            pTrace->fOneOk = TRUE;
        }
    }

    return NO_ERROR;
}

BOOL
TraceShowModem()
{
    BOOL fRet = FALSE;
    HKEY hKey = NULL;
    TRACING_DATA Trace;

    do
    {
        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                g_pwszModemSubkey,
                0,
                KEY_READ,
                &hKey)
           )
        {
            break;
        }

        Trace.fOneOk = FALSE;

        RutlRegEnumKeys(hKey, TraceShowModemCb, &Trace);

        fRet = Trace.fOneOk;

    } while (FALSE);
    //
    // Clean up
    //
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return fRet;
}

DWORD
TraceDumpModem()
{
    BOOL fEnabled;
    DWORD dwErr = NO_ERROR;
    PWCHAR pwszEnable = NULL;

    do
    {
        fEnabled = TraceShowModem();

        pwszEnable = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_STATE,
                        (fEnabled) ? TOKEN_ENABLED : TOKEN_DISABLED);
        if (!pwszEnable)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_TRACE_DUMP2,
            DMP_RASDIAG_SET_MODEMTRACE,
            pwszEnable);

    } while (FALSE);
    //
    // Cleanup
    //
    RutlFree(pwszEnable);

    return dwErr;
}

DWORD
TraceClearCmCb(
    IN LPCWSTR pwszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    PWCHAR pwszSearch = NULL, pwszLoggingPath = NULL;
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    do
    {
        if (!pTrace)
        {
            break;
        }

        if (GetCMLoggingSearchPath(
                pTrace->hKey,
                pwszName,
                &pwszLoggingPath,
                &pwszSearch))
        {
            RutlEnumFiles(
                pwszLoggingPath,
                pwszSearch,
                TraceClearTracingCb,
                pTrace);
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszSearch);
    RutlFree(pwszLoggingPath);

    return NO_ERROR;
}

BOOL
TraceClearCm(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    HKEY hKey = NULL;
    TRACING_DATA Trace;

    do
    {
        //
        // Disable CM logging
        //
        TraceEnableDisableCm(FALSE);
        //
        // Open for ALLUSERS
        //
        Trace.hKey = HKEY_LOCAL_MACHINE;
        Trace.fOneOk = FALSE;

        if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                g_pwszCmLogAllKey,
                0,
                KEY_READ,
                &hKey) ||
            RutlRegEnumKeys(
                hKey,
                TraceClearCmCb,
                &Trace)
           )
        {
            break;
        }

        fRet = Trace.fOneOk;

        RegCloseKey(hKey);
        hKey = NULL;
        //
        // Open for CurrentUser
        //
        Trace.hKey = HKEY_CURRENT_USER;

        if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                g_pwszCmLogCurKey,
                0,
                KEY_READ,
                &hKey) ||
            RutlRegEnumKeys(
                hKey,
                TraceClearCmCb,
                &Trace)
           )
        {
            break;
        }

        fRet = Trace.fOneOk;
        //
        // Enable CM logging
        //
        if (fEnable)
        {
            TraceEnableDisableCm(TRUE);
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return fRet;
}

DWORD
TraceCollectCmLogsEnumCb(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        REPORT_INFO* pInfo = pTrace->pInfo;

        if (pInfo)
        {
            if (!PrintFile(pInfo, pwszFQFileName, TRUE, ParseCmLogForTime))
            {
                pTrace->fOneOk = TRUE;
            }
        }
    }

    return NO_ERROR;
}

DWORD
TraceCollectCmLogsCb(
    IN LPCWSTR pwszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    PWCHAR pwszSearch = NULL, pwszLoggingPath = NULL;
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace &&
        GetCMLoggingSearchPath(
            pTrace->hKey,
            pwszName,
            &pwszLoggingPath,
            &pwszSearch))
    {
        RutlEnumFiles(
            pwszLoggingPath,
            pwszSearch,
            TraceCollectCmLogsEnumCb,
            pTrace);
    }
    //
    // Clean up
    //
    RutlFree(pwszSearch);
    RutlFree(pwszLoggingPath);

    return NO_ERROR;
}

BOOL
TraceCollectCmLogs(
    IN REPORT_INFO* pInfo,
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    HKEY hKey = NULL;
    TRACING_DATA Trace;

    do
    {
        //
        // Disable CM logging
        //
        TraceEnableDisableCm(FALSE);

        Trace.fOneOk = FALSE;
        Trace.hKey = HKEY_LOCAL_MACHINE;
        Trace.pInfo = pInfo;
        //
        // Open for ALLUSERS
        //
        if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                g_pwszCmLogAllKey,
                0,
                KEY_READ,
                &hKey) ||
            RutlRegEnumKeys(
                hKey,
                TraceCollectCmLogsCb,
                &Trace)
           )
        {
            break;
        }

        fRet = Trace.fOneOk;

        RegCloseKey(hKey);
        hKey = NULL;
        //
        // Open for CurrentUser
        //
        Trace.hKey = HKEY_CURRENT_USER;

        if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                g_pwszCmLogCurKey,
                0,
                KEY_READ,
                &hKey) ||
            RutlRegEnumKeys(
                hKey,
                TraceCollectCmLogsCb,
                &Trace)
           )
        {
            break;
        }

        fRet = Trace.fOneOk;
        //
        // Enable CM logging
        //
        if (fEnable)
        {
            TraceEnableDisableCm(TRUE);
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return fRet;
}

DWORD
TraceEnableDisableCmCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        DWORD dwEnable = pTrace->fData ? 1 : 0;

        if (!RutlRegWriteDword(
                hKey,
                g_pwszEnableLog,
                dwEnable))
        {
            pTrace->fOneOk = TRUE;
        }
    }

    return NO_ERROR;
}

BOOL
TraceEnableDisableCm(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    HKEY hKey = NULL;
    TRACING_DATA Trace;

    do
    {
        Trace.fOneOk = FALSE;
        Trace.fData = fEnable;

        if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                g_pwszCmLogAllKey,
                0,
                KEY_READ | KEY_WRITE,
                &hKey) ||
            RutlRegEnumKeys(
                hKey,
                TraceEnableDisableCmCb,
                &Trace)
           )
        {
            break;
        }

        fRet = Trace.fOneOk;

        RegCloseKey(hKey);
        hKey = NULL;

        if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                g_pwszCmLogCurKey,
                0,
                KEY_READ | KEY_WRITE,
                &hKey) ||
            RutlRegEnumKeys(
                hKey,
                TraceEnableDisableCmCb,
                &Trace)
           )
        {
            break;
        }

        fRet = Trace.fOneOk;

    } while (FALSE);
    //
    // Clean up
    //
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return fRet;
}

//
// 
//
DWORD
TraceShowCmCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    DWORD dwValueData = 0;
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace &&
        !RutlRegReadDword(
            hKey,
            g_pwszEnableLog,
            &dwValueData) &&
        dwValueData
       )
    {
        //
        // Success
        //
        pTrace->fOneOk = TRUE;
    }

    return NO_ERROR;
}

//
// 
//
BOOL
TraceShowCm()
{
    BOOL fRet = FALSE;
    HKEY hKey = NULL;
    TRACING_DATA Trace;

    do
    {
        Trace.fOneOk = FALSE;

        if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                g_pwszCmLogAllKey,
                0,
                KEY_READ,
                &hKey) ||
            RutlRegEnumKeys(
                hKey,
                TraceShowCmCb,
                &Trace)
           )
        {
            break;
        }

        fRet = Trace.fOneOk;

        RegCloseKey(hKey);
        hKey = NULL;

        if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                g_pwszCmLogCurKey,
                0,
                KEY_READ,
                &hKey) ||
            RutlRegEnumKeys(
                hKey,
                TraceShowCmCb,
                &Trace)
           )
        {
            break;
        }

        fRet = Trace.fOneOk;

    } while (FALSE);
    //
    // Clean up
    //
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return fRet;
}

//
// 
//
DWORD
TraceDumpCm()
{
    BOOL fEnabled;
    DWORD dwErr = NO_ERROR;
    PWCHAR pwszEnable = NULL;

    do
    {
        fEnabled = TraceShowCm();

        pwszEnable = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_STATE,
                        (fEnabled) ? TOKEN_ENABLED : TOKEN_DISABLED);
        if (!pwszEnable)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_TRACE_DUMP2,
            DMP_RASDIAG_SET_CMTRACE,
            pwszEnable);

    } while (FALSE);
    //
    // Cleanup
    //
    RutlFree(pwszEnable);

    return dwErr;
}

//
// Clear the IPSec logs of any data
//
// .Net bug# 509365 No option to delete Oakley Log via RAS Diagnostics U.I.
//
BOOL
TraceClearIpsecLogs(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    WCHAR wszWindir[MAX_PATH + 1] = L"\0", wszPath[MAX_PATH + 1] = L"\0";

    do
    {
        //
        // Disable IPSec logging
        //
        TraceEnableDisableIpsec(FALSE);

        if (!GetSystemWindowsDirectory(wszWindir, MAX_PATH))
        {
            break;
        }

        _snwprintf(wszPath, MAX_PATH, L"%s%s", wszWindir, g_pwszOakleyPath);

        {
            UINT ulTry = 0;

            while (ulTry++ < 10)
            {
                if (DeleteFile(wszPath))
                {
                    fRet = TRUE;
                    break;
                }
                else if (GetLastError() == ERROR_SHARING_VIOLATION)
                {
                    //
                    // Wait a little for logging to get disabled
                    //
                    Sleep(10);
                }
            }
        }

    } while (FALSE);

    if (fEnable)
    {
        //
        // Re-enable IPSec logging
        //
        TraceEnableDisableIpsec(TRUE);
    }

    return fRet;
}

//
// 
//
BOOL
TraceCollectIpsecLogs(
    IN REPORT_INFO* pInfo)
{
    BOOL fRet = FALSE;
    DWORD dwWindir = 0, dwIpsec = 0;
    WCHAR wszWindir[MAX_PATH + 1] = L"\0";
    PWCHAR pwszIpsecLog = NULL;

    do
    {
        //
        // Whistler .NET BUG: 492081
        //
        if (!GetSystemWindowsDirectory(wszWindir, MAX_PATH))
        {
            break;
        }

        dwWindir = lstrlen(wszWindir);
        if (!dwWindir)
        {
            break;
        }

        dwIpsec = lstrlen(g_pwszOakleyPath);

        pwszIpsecLog = RutlAlloc(
                            (dwWindir + dwIpsec + 1) * sizeof(WCHAR),
                            FALSE);
        if (!pwszIpsecLog)
        {
            break;
        }

        lstrcpyn(pwszIpsecLog, wszWindir, dwWindir + 1);
        wcsncat(pwszIpsecLog, g_pwszOakleyPath, dwIpsec + 1);

        if (!PrintFile(pInfo, pwszIpsecLog, TRUE, ParseIpsecLogForTime))
        {
            fRet = TRUE;
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszIpsecLog);

    return fRet;
}

//
// 
//
BOOL
TraceEnableDisableIpsec(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    IKE_CONFIG IKEConfig;
    WPP_LOG_INFO WppLog;

    static GUID c_RasIpsecGuid = IPSEC_GUID;
    static CONST WCHAR c_pwszIpsecPath[] = L"\\TRACING\\IPSEC.BIN";
    static CONST WCHAR c_pwszIpsecSession[] = L"IPSEC";

    do
    {
        //
        // .Net bug# 515191 RAS Diag clears all oakley regkeys when
        // enabling/disabling IPSec Logging
        //
        if (!GetConfigurationVariables(NULL, &IKEConfig))
        {
            IKEConfig.dwEnableLogging = fEnable ? 1 : 0;

            if (!SetConfigurationVariables(NULL, IKEConfig))
            {
                fRet = TRUE;
            }
        }
        //
        // Enable or disable IPSEC WPP tracing
        //
        ZeroMemory(&WppLog, sizeof(WPP_LOG_INFO));
        WppLog.dwEnableFlag = 0x2ff;
        WppLog.dwEnableLevel = 2;
        WppLog.ControlGuid = c_RasIpsecGuid;

        lstrcpyn(WppLog.wszLogFileName, c_pwszIpsecPath, MAX_PATH + 1);
        lstrcpyn(WppLog.wszSessionName, c_pwszIpsecSession, MAX_PATH + 1);

        if (!InitWppData(&WppLog))
        {
            break;
        }

        if (fEnable)
        {
            if (!StartWppTracing(&WppLog))
            {
                break;
            }
        }
        else
        {
            if (!StopWppTracing(&WppLog))
            {
                break;
            }
        }

        fRet = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    CleanupWppData(&WppLog);

    return fRet;
}

//
// 
//
BOOL
TraceClearAuditing(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    HANDLE hLog = NULL;

    do
    {
        hLog = OpenEventLog(NULL, g_pwszSecurity);
        if (!hLog)
        {
            break;
        }

        if (ClearEventLog(hLog, NULL))
        {
            fRet = TRUE;
        }
        //
        // Enable auditing with no feedback
        //
        if (fEnable)
        {
            TraceEnableDisableAuditing(FALSE, fEnable);
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (hLog)
    {
        CloseEventLog(hLog);
    }

    return fRet;
}

//
// 
//
BOOL
TraceEnableDisableAuditing(
    IN BOOL fShowOnly,
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    UINT i;
    NTSTATUS ntstatus;
    LSA_HANDLE policy_handle = NULL;
    OBJECT_ATTRIBUTES obj_attr;
    PPOLICY_AUDIT_EVENTS_INFO info = NULL;
    SECURITY_QUALITY_OF_SERVICE sqos;

    do
    {
        InitializeObjectAttributes(&obj_attr, NULL, 0L, 0L, NULL);

        sqos.Length = sizeof(sqos);
        sqos.ImpersonationLevel = SecurityIdentification;
        sqos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
        sqos.EffectiveOnly = FALSE;

        obj_attr.SecurityQualityOfService = &sqos;

        ntstatus = LsaOpenPolicy(
                        NULL,
                        &obj_attr,
                        POLICY_VIEW_AUDIT_INFORMATION |
                            POLICY_SET_AUDIT_REQUIREMENTS |
                            POLICY_AUDIT_LOG_ADMIN,
                        &policy_handle);
        if (!NT_SUCCESS(ntstatus))
        {
            break;
        }

        ntstatus = LsaQueryInformationPolicy(
                        policy_handle,
                        PolicyAuditEventsInformation,
                        (PVOID*)&info);
        if (!NT_SUCCESS(ntstatus) || (!info))
        {
            break;
        }

        for (i = 0; i < info->MaximumAuditEventCount; i++)
        {
            if(i == AuditCategoryAccountLogon ||
               i == AuditCategoryLogon)
            {
                if (fShowOnly)
                {
                    if(i == AuditCategoryAccountLogon ||
                       i == AuditCategoryLogon)
                    {
                        if ((info->EventAuditingOptions[i] &
                                POLICY_AUDIT_EVENT_FAILURE) &&
                            (info->EventAuditingOptions[i] &
                                POLICY_AUDIT_EVENT_SUCCESS)
                           )
                        {
                            fRet = TRUE;
                        }
                    }
                }
                else
                {
                    if(fEnable)
                    {
                        info->EventAuditingOptions[i] = POLICY_AUDIT_EVENT_FAILURE|
                                                        POLICY_AUDIT_EVENT_SUCCESS;
                    } else
                    {
                        info->EventAuditingOptions[i] = POLICY_AUDIT_EVENT_NONE;
                    }
                }
            }
        }
        //
        // See if we are only trying to detect what is enabled
        //
        if (fShowOnly)
        {
            break;
        }

        ntstatus = LsaSetInformationPolicy(
                        policy_handle,
                        PolicyAuditEventsInformation,
                        (PVOID)info);
        if (NT_SUCCESS(ntstatus))
        {
            fRet = TRUE;
        }
        else
        {
            fRet = FALSE;
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (info)
    {
        LsaFreeMemory(info);
    }
    if (policy_handle)
    {
        LsaClose(policy_handle);
    }

    return fRet;
}

//
// 
//
DWORD
TraceDumpAuditing()
{
    BOOL fEnabled;
    DWORD dwErr = NO_ERROR;
    PWCHAR pwszEnable = NULL;

    do
    {
        fEnabled = TraceEnableDisableAuditing(TRUE, FALSE);

        pwszEnable = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_STATE,
                        (fEnabled) ? TOKEN_ENABLED : TOKEN_DISABLED);
        if (!pwszEnable)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_TRACE_DUMP2,
            DMP_RASDIAG_SET_AUDITING,
            pwszEnable);

    } while (FALSE);
    //
    // Cleanup
    //
    RutlFree(pwszEnable);

    return dwErr;
}

//
// .Net bug# 522035 RAS Diag: include new WPP tracing logs from RASL2TP and
// RASPPTP
//
// Init the EVENT_TRACE_PROPERTIES struct
//
BOOL
InitWppData(
    IN WPP_LOG_INFO* pWppLog)
{
    BOOL fRet = FALSE;
    ULONG ulSize = sizeof(EVENT_TRACE_PROPERTIES) +
                        ((MAX_PATH + 1) * 2 * sizeof(WCHAR));

    do
    {
        if (!pWppLog)
        {
            break;
        }

        //
        // Allocate and init the WPP structure
        //
        pWppLog->pProperties = RutlAlloc(ulSize, TRUE);
        if (!pWppLog->pProperties)
        {
            break;
        }

        pWppLog->pProperties->Wnode.BufferSize = ulSize;
        pWppLog->pProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
        pWppLog->pProperties->MaximumFileSize = 5;
        pWppLog->pProperties->LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
        pWppLog->pProperties->LogFileNameOffset =
            sizeof(EVENT_TRACE_PROPERTIES);
        pWppLog->pProperties->LoggerNameOffset =
            sizeof(EVENT_TRACE_PROPERTIES) + ((MAX_PATH + 1) * sizeof(WCHAR));

        lstrcpyn(
            (PWCHAR )((PBYTE )pWppLog->pProperties +
                  pWppLog->pProperties->LoggerNameOffset),
            pWppLog->wszSessionName,
            MAX_PATH + 1);

        if ((pWppLog->wszLogFileName)[0] != L'\0')
        {
            WCHAR wszWindir[MAX_PATH + 1] = L"\0", wszPath[MAX_PATH + 1] = L"\0";
            //
            // Get the name of the tracing directory
            //
            if (!GetSystemWindowsDirectory(wszWindir, MAX_PATH))
            {
                break;
            }

            _snwprintf(
                wszPath,
                MAX_PATH,
                L"%s%s",
                wszWindir,
                pWppLog->wszLogFileName);

            lstrcpyn(
                (PWCHAR )((PBYTE )pWppLog->pProperties +
                    pWppLog->pProperties->LogFileNameOffset),
                wszPath,
                MAX_PATH + 1);
        }
        //
        // Attempt to read in any existing settings from the registry, this
        // could overwrite some of the defaults above.
        //
        ReadWppTracingState(pWppLog);

        fRet = TRUE;

    } while (FALSE);

    return fRet;
}

//
// Free the Wpp data struct
//
VOID
CleanupWppData(
    IN WPP_LOG_INFO* pWppLog)
{
    if (pWppLog)
    {
        RutlFree(pWppLog->pProperties);
        ZeroMemory(pWppLog, sizeof(WPP_LOG_INFO));
    }

    return;
}

DWORD
ClearWppTracingCb(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData)
{
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        UINT ulTry = 0;

        while (ulTry++ < 10)
        {
            if (DeleteFile(pwszFQFileName))
            {
                pTrace->fOneOk = TRUE;
                break;
            }
            else if (GetLastError() == ERROR_SHARING_VIOLATION)
            {
                //
                // Wait a little for logging to get disabled
                //
                Sleep(10);
            }
        }
    }

    return NO_ERROR;
}

BOOL
ClearWppTracing(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    PWCHAR pwszTracingPath = NULL;
    TRACING_DATA Trace;

    static CONST WCHAR pwszWppExt[] = L".BIN";

    do
    {
        //
        // Disable tracing
        //
        TraceEnableDisableAllWpp(FALSE);

        pwszTracingPath = GetTracingDir();
        if (!pwszTracingPath)
        {
            break;
        }

        Trace.fOneOk = FALSE;

        RutlEnumFiles(
            pwszTracingPath,
            (PWCHAR)pwszWppExt,
            ClearWppTracingCb,
            &Trace);

        fRet = Trace.fOneOk;
        //
        // Enable tracing
        //
        if (fEnable)
        {
            TraceEnableDisableAllWpp(TRUE);
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszTracingPath);

    return fRet;
}

//
// Wpp does not currently (01/26/02) persist tracing state across a reboot.
// When a machine comes back up, even if it was enabled before the reboot,
// it returns to a disabled state. Thus we must track the state ourselves in
// the registry.
//
BOOL
WriteWppTracingState(
    IN WPP_LOG_INFO* pWppLog)
{
    BOOL fRet = FALSE;
    HKEY hkKey = NULL;
    WCHAR wszPath[MAX_PATH + 1] = L"\0", wszGuid[MAX_PATH + 1] = L"\0";

    do
    {
        if ((!pWppLog) || (!pWppLog->pProperties))
        {
            break;
        }

        _snwprintf(
            wszPath,
            MAX_PATH,
            L"%s%s",
            g_pwszWppPath,
            pWppLog->wszSessionName);
        //
        // Create the new key if need be
        //
        if (RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                wszPath,
                0,
                NULL,
                0,
                KEY_WRITE,
                NULL,
                &hkKey,
                NULL)
           )
        {
            break;
        }
        //
        // Write out the tracing data
        //
        RutlRegWriteDword(hkKey, g_pwszWppActive, pWppLog->dwActive);
        RutlRegWriteDword(hkKey, g_pwszWppControlFlags, pWppLog->dwEnableFlag);
        RutlRegWriteDword(hkKey, g_pwszWppControlLevel, pWppLog->dwEnableLevel);

        RutlConvertGuidToString(&(pWppLog->ControlGuid), wszGuid);
        RutlRegWriteString(hkKey, g_pwszWppGuid, wszGuid);

        RutlRegWriteString(
            hkKey,
            g_pwszWppLogFileName,
            (PWCHAR )((PBYTE )pWppLog->pProperties +
                pWppLog->pProperties->LogFileNameOffset));

        fRet = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    if (hkKey)
    {
        RegCloseKey(hkKey);
    }

    return fRet;
}

//
// Open the WPP registry location and read out any config values
//
BOOL
ReadWppTracingState(
    IN WPP_LOG_INFO* pWppLog)
{
    BOOL fRet = FALSE;
    HKEY hkKey = NULL;
    WCHAR wszPath[MAX_PATH + 1] = L"\0";
    PWCHAR pwszGuid = NULL, pwszLogFileName = NULL;

    do
    {
        if ((!pWppLog) || (!pWppLog->pProperties))
        {
            break;
        }

        _snwprintf(
            wszPath,
            MAX_PATH,
            L"%s%s",
            g_pwszWppPath,
            pWppLog->wszSessionName);
        //
        // Open the key
        //
        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                wszPath,
                0,
                KEY_READ,
                &hkKey)
           )
        {
            break;
        }
        //
        // Read in the tracing data
        //
        RutlRegReadDword(hkKey, g_pwszWppActive, &(pWppLog->dwActive));
        RutlRegReadDword(
            hkKey,
            g_pwszWppControlFlags,
            &(pWppLog->dwEnableFlag));
        RutlRegReadDword(
            hkKey,
            g_pwszWppControlLevel,
            &(pWppLog->dwEnableLevel));

        if (!RutlRegReadString(hkKey, g_pwszWppGuid, &pwszGuid))
        {
            RutlConvertStringToGuid(
                pwszGuid,
                lstrlen(pwszGuid) * sizeof(WCHAR),
                &(pWppLog->ControlGuid));
        }

        if (!RutlRegReadString(hkKey, g_pwszWppLogFileName, &pwszLogFileName))
        {
            lstrcpyn(
                (PWCHAR )((PBYTE )pWppLog->pProperties +
                    pWppLog->pProperties->LogFileNameOffset),
                pwszLogFileName,
                MAX_PATH + 1);
        }

        fRet = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszLogFileName);
    RutlFree(pwszGuid);
    if (hkKey)
    {
        RegCloseKey(hkKey);
    }

    return fRet;
}

//
// Start a Wpp tracing session
//
BOOL
StartWppTracing(
    IN WPP_LOG_INFO* pWppLog)
{
    DWORD dwErr;
    TRACEHANDLE hSession = 0;

    if ((!pWppLog) || (!pWppLog->pProperties))
    {
        return FALSE;
    }
    //
    // Start a tracing session
    //
    if (StartTrace(&hSession, pWppLog->wszSessionName, pWppLog->pProperties))
    {
        return FALSE;
    }
    //
    // Enable a tracing session
    //
    if (EnableTrace(
            TRUE,
            pWppLog->dwEnableFlag,
            pWppLog->dwEnableLevel,
            &(pWppLog->ControlGuid),
            hSession)
       )
    {
        return FALSE;
    }
    //
    // Save off the state in the registry
    //
    pWppLog->dwActive = 1;
    if (!WriteWppTracingState(pWppLog))
    {
        return FALSE;
    }

    return TRUE;
}

//
// Stop a Wpp tracing session
//
BOOL
StopWppTracing(
    IN WPP_LOG_INFO* pWppLog)
{
    TRACEHANDLE hSession = 0;

    if ((!pWppLog) || (!pWppLog->pProperties))
    {
        return FALSE;
    }
    //
    // Query WPP to see if a tracing session is active
    //
    if (ControlTrace(
            hSession,
            pWppLog->wszSessionName,
            pWppLog->pProperties,
            EVENT_TRACE_CONTROL_QUERY)
       )
    {
        return FALSE;
    }
    //
    // One is active, get it's handle
    //
    hSession = pWppLog->pProperties->Wnode.HistoricalContext;
    //
    // Disable the session
    //
    if (EnableTrace(FALSE, 0, 0, &(pWppLog->ControlGuid), hSession))
    {
        return FALSE;
    }
    //
    // Stop the tracing
    //
    if (ControlTrace(
            hSession,
            pWppLog->wszSessionName,
            pWppLog->pProperties,
            EVENT_TRACE_CONTROL_STOP)
       )
    {
        return FALSE;
    }
    //
    // Save off the state in the registry
    //
    pWppLog->dwActive = 0;
    if (!WriteWppTracingState(pWppLog))
    {
        return FALSE;
    }

    return TRUE;
}

//
// Enum any existing RAS WPP registry entries
//
DWORD
EnumWppTracing(
    IN RAS_REGKEY_ENUM_FUNC_CB pCallback,
    IN HANDLE hData)
{
    HKEY hKey = NULL;
    DWORD dwErr = NO_ERROR;

    if (!pCallback)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                g_pwszWppPath,
                0,
                KEY_READ,
                &hKey);
    if (!dwErr)
    {
        dwErr = RutlRegEnumKeys(hKey, pCallback, hData);
        RegCloseKey(hKey);
    }

    return dwErr;
}

//
// Enable or disable RASL2TP WPP tracing
//
BOOL
TraceEnableDisableRasL2tp(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    WPP_LOG_INFO WppLog;

    static GUID c_RasL2tpGuid = RASL2TP_GUID;
    static CONST WCHAR c_pwszL2tpPath[] = L"\\TRACING\\RASL2TP.BIN";
    static CONST WCHAR c_pwszL2tpSession[] = L"RASL2TP";

    do
    {
        ZeroMemory(&WppLog, sizeof(WPP_LOG_INFO));
        WppLog.dwEnableFlag = 0x2ff;
        WppLog.dwEnableLevel = 2;
        WppLog.ControlGuid = c_RasL2tpGuid;

        lstrcpyn(WppLog.wszLogFileName, c_pwszL2tpPath, MAX_PATH + 1);
        lstrcpyn(WppLog.wszSessionName, c_pwszL2tpSession, MAX_PATH + 1);

        if (!InitWppData(&WppLog))
        {
            break;
        }

        if (fEnable)
        {
            if (!StartWppTracing(&WppLog))
            {
                break;
            }
        }
        else
        {
            if (!StopWppTracing(&WppLog))
            {
                break;
            }
        }

        fRet = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    CleanupWppData(&WppLog);

    return fRet;
}

//
// Enable or disable RASPPTP WPP tracing
//
BOOL
TraceEnableDisableRasPptp(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;
    WPP_LOG_INFO WppLog;

    static GUID c_RasPptpGuid = RASPPTP_GUID;
    static CONST WCHAR c_pwszPptpPath[] = L"\\TRACING\\RASPPTP.BIN";
    static CONST WCHAR c_pwszPptpSession[] = L"RASPPTP";

    do
    {
        ZeroMemory(&WppLog, sizeof(WPP_LOG_INFO));
        WppLog.dwEnableFlag = 0x2ff;
        WppLog.dwEnableLevel = 2;
        WppLog.ControlGuid = c_RasPptpGuid;

        lstrcpyn(WppLog.wszLogFileName, c_pwszPptpPath, MAX_PATH + 1);
        lstrcpyn(WppLog.wszSessionName, c_pwszPptpSession, MAX_PATH + 1);

        if (!InitWppData(&WppLog))
        {
            break;
        }

        if (fEnable)
        {
            if (!StartWppTracing(&WppLog))
            {
                break;
            }
        }
        else
        {
            if (!StopWppTracing(&WppLog))
            {
                break;
            }
        }

        fRet = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    CleanupWppData(&WppLog);

    return fRet;
}

//
// Enable or disable All WPP tracing
//
BOOL
TraceEnableDisableAllWpp(
    IN BOOL fEnable)
{
    BOOL fRet = FALSE;

    if (TraceEnableDisableRasL2tp(fEnable))
    {
        fRet = TRUE;
    }
    if (TraceEnableDisableRasPptp(fEnable))
    {
        fRet = TRUE;
    }
    if (TraceEnableDisableIpsec(fEnable))
    {
        fRet = TRUE;
    }

    return fRet;
}

//
// Enable any WPP tracing sessions that were disabled because of reboot
//
DWORD
DiagInitWppTracingCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    WPP_LOG_INFO WppLog;

    ZeroMemory(&WppLog, sizeof(WPP_LOG_INFO));
    WppLog.dwEnableFlag = 0x2ff;
    WppLog.dwEnableLevel = 2;

    lstrcpyn(WppLog.wszSessionName, pszName, MAX_PATH + 1);

    if ((InitWppData(&WppLog)) &&
        (WppLog.dwActive)
       )
    {
        StartWppTracing(&WppLog);
    }
    //
    // Clean up
    //
    CleanupWppData(&WppLog);

    return NO_ERROR;
}

//
// NON-NETSH function - allow someone to turn on all of our WPP tracing based
// on our saved state in the registry
//
VOID
DiagInitWppTracing()
{
    EnumWppTracing(DiagInitWppTracingCb, NULL);

    return;
}

//
// 
//
BOOL
PrintRasEventLogsCb(
    IN PEVENTLOGRECORD pevlr,
    IN HANDLE hModule,
    IN HANDLE hData)
{
    BOOL fRet = FALSE;
    DWORD dwId = pevlr->EventID;
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        REPORT_INFO* pInfo = pTrace->pInfo;

        if (pInfo && (((dwId >= RASBASE ) && (dwId <= RASBASEEND)) ||
                      ((dwId >= ROUTEBASE ) && ( dwId <= ROUTEBASEEND)) ||
                      ((dwId >= ROUTER_LOG_BASE) && (dwId <= ROUTER_LOG_BASEEND)))
           )
        {
            PWCHAR pwszErrorMsg = NULL;

            pwszErrorMsg = FormatMessageFromMod(hModule, dwId);
            if (pwszErrorMsg)
            {
                PWCHAR pwszCategory = NULL, pwszExpanded = NULL;

                pwszExpanded = CreateErrorString(
                                    pevlr->NumStrings,
                                    (PWCHAR)((LPBYTE)pevlr + pevlr->StringOffset),
                                    pwszErrorMsg);
                if (pwszExpanded)
                {
                    WriteEventLogEntry(pInfo->pBuff, pevlr, pwszExpanded, NULL);
                    RutlFree(pwszExpanded);
                    pTrace->fOneOk = TRUE;
                }

                FreeFormatMessageFromMod(pwszErrorMsg);
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

//
// 
//
VOID
PrintRasEventLogs(
    IN REPORT_INFO* pInfo)
{
    TRACING_DATA Trace;
    static CONST WCHAR pwszSystem[] = L"System";
    static CONST WCHAR pwszMsgDll[] = L"mprmsg.dll";

    Trace.fOneOk = FALSE;
    Trace.pInfo = pInfo;

    RutlEnumEventLogs(
        pwszSystem,
        pwszMsgDll,
        MAX_NUMBER_OF_LOGS,
        PrintRasEventLogsCb,
        &Trace);

    if (!Trace.fOneOk)
    {
        BufferWriteMessage(
            pInfo->pBuff,
            g_hModule,
            EMSG_RASDIAG_SHOW_CONFIG_EVENTLOG);
    }

    return;
}

//
// 
//
BOOL
PrintSecurityEventLogsCb(
    IN PEVENTLOGRECORD pevlr,
    IN HANDLE hModule,
    IN HANDLE hData)
{
    BOOL fRet = FALSE;
    PWCHAR pwszErrorMsg = NULL, pwszCategory = NULL, pwszExpanded = NULL;
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    if (pTrace)
    {
        REPORT_INFO* pInfo = pTrace->pInfo;

        pwszErrorMsg = FormatMessageFromMod(hModule, pevlr->EventID);
        if (pInfo && pwszErrorMsg)
        {
            if (pevlr->EventCategory)
            {
                pwszCategory = FormatMessageFromMod(
                                    hModule,
                                    (DWORD)pevlr->EventCategory);
            }

            pwszExpanded = CreateErrorString(
                                pevlr->NumStrings,
                                (PWCHAR)((LPBYTE)pevlr + pevlr->StringOffset),
                                pwszErrorMsg);
            if (pwszExpanded)
            {
                WriteEventLogEntry(
                    pInfo->pBuff,
                    pevlr,
                    pwszExpanded,
                    pwszCategory);
                RutlFree(pwszExpanded);
                pTrace->fOneOk = TRUE;
            }

            FreeFormatMessageFromMod(pwszCategory);
            fRet = TRUE;
        }

        FreeFormatMessageFromMod(pwszErrorMsg);
    }

    return fRet;
}

//
// 
//
VOID
PrintSecurityEventLogs(
    IN REPORT_INFO* pInfo)
{
    TRACING_DATA Trace;

    static CONST WCHAR pwszMsgDll[] = L"msaudite.dll";

    Trace.fOneOk = FALSE;
    Trace.pInfo = pInfo;

    RutlEnumEventLogs(
        g_pwszSecurity,
        pwszMsgDll,
        MAX_NUMBER_OF_LOGS,
        PrintSecurityEventLogsCb,
        &Trace);

    if (!Trace.fOneOk)
    {
        BufferWriteMessage(
            pInfo->pBuff,
            g_hModule,
            EMSG_RASDIAG_SHOW_CONFIG_SECEVENTLOG);
    }

    return;
}

//
// 
//
DWORD
TraceCollectAll(
    IN REPORT_INFO* pInfo)
{
    BOOL fEnabled;
    DWORD dwErr = NO_ERROR;

    do
    {
        fEnabled = DiagGetState();
        //
        // Collect RAS tracing logs into report
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszTraceCollectTracingLogs,
            MSG_RASDIAG_REPORT_TRACE);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_TRACE);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_TRACE);
            BREAK_ON_DWERR(dwErr);
        }

        if (!TraceCollectTracingLogs(pInfo, fEnabled))
        {
            BufferWriteMessage(
                pInfo->pBuff,
                g_hModule,
                EMSG_RASDIAG_SHOW_TRACE_LOGS_FAIL);
        }
        //
        // Collect modem tracing logs into report
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszTraceCollectModemLogs,
            MSG_RASDIAG_REPORT_TRACE_MODEM);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_TRACE_MODEM);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_TRACE_MODEM);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);

        if (!TraceCollectModemLogs(pInfo, fEnabled))
        {
            BufferWriteMessage(
                pInfo->pBuff,
                g_hModule,
                EMSG_RASDIAG_SHOW_MODEMTRACE_LOGS_FAIL);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // Collect CM tracing logs into report
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszTraceCollectCmLogs,
            MSG_RASDIAG_REPORT_TRACE_CM);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_TRACE_CM);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_TRACE_CM);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);

        if (!TraceCollectCmLogs(pInfo, fEnabled))
        {
            BufferWriteMessage(
                pInfo->pBuff,
                g_hModule,
                EMSG_RASDIAG_SHOW_CM_LOGS_FAIL);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // Collect IPSec tracing logs into report
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszTraceCollectIpsecLogs,
            MSG_RASDIAG_REPORT_TRACE_IPSEC);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_TRACE_IPSEC);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_TRACE_IPSEC);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);

        if (!TraceCollectIpsecLogs(pInfo))
        {
            BufferWriteMessage(
                pInfo->pBuff,
                g_hModule,
                EMSG_RASDIAG_SHOW_IPSEC_LOGS_FAIL);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // Collect RAS Events into report
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszPrintRasEventLogs,
            MSG_RASDIAG_REPORT_RASEVENT);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_RASEVENT);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_RASEVENT);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
        PrintRasEventLogs(pInfo);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // Collect Security Events into report
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszPrintSecurityEventLogs,
            MSG_RASDIAG_REPORT_SECEVENT);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_SECEVENT);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_SECEVENT);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
        PrintSecurityEventLogs(pInfo);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);

    } while (FALSE);

    return dwErr;
}

//
// 
//
VOID
TraceShowAll()
{
    if (!TraceShowTracing())
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_TRACEALL_RAS_FAIL);
    }

    if (TraceShowModem())
    {
        DisplayMessage(g_hModule, MSG_RASDIAG_SHOW_MODEMTRACE_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_SHOW_MODEMTRACE_DISABLED);
    }

    if (TraceShowCm())
    {
        DisplayMessage(g_hModule, MSG_RASDIAG_SHOW_CMTRACE_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_SHOW_CMTRACE_DISABLED);
    }

    if (TraceEnableDisableAuditing(TRUE, FALSE))
    {
        DisplayMessage(g_hModule, MSG_RASDIAG_SHOW_AUDITING_ENABLED);
    }
    else
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_SHOW_AUDITING_DISABLED);
    }

    return;
}

//
// Clear all tracing files. All tracing must be disabled before the files can
// be 'cleared'. The state of tracing is read before the clear so it can be
// restored (only in the disabled case).
//
DWORD
DiagClearAll(
    IN BOOL fDisplay)
{
    BOOL fEnabled;
    DWORD dwErr = ERROR_OPEN_FAILED;

    fEnabled = DiagGetState();

    if (TraceClearTracing(fEnabled))
    {
        dwErr = NO_ERROR;
        if (fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_CLEAR_TRACE_OK);
        }
    }
    else if (fDisplay)
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_CLEAR_TRACE_FAIL);
    }

    if (TraceClearModem(fEnabled))
    {
        dwErr = NO_ERROR;
        if (fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_CLEAR_MODEMTRACE);
        }
    }
    else if (fDisplay)
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_CLEAR_MODEMTRACE_FAIL);
    }

    if (TraceClearCm(fEnabled))
    {
        dwErr = NO_ERROR;
        if (fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_CLEAR_CMTRACE);
        }
    }
    else if (fDisplay)
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_CLEAR_CMTRACE_FAIL);
    }

    if (TraceClearAuditing(fEnabled))
    {
        dwErr = NO_ERROR;
        if (fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_CLEAR_AUDITING);
        }
    }
    else if (fDisplay)
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_CLEAR_AUDITING_FAIL);
    }
    //
    // .Net bug# 509365 No option to delete Oakley Log via RAS Diagnostics U.I.
    //
    TraceClearIpsecLogs(fEnabled);
    //
    // .Net bug# 522035 RAS Diag: include new WPP tracing logs from RASL2TP and
    // RASPPTP
    //
    ClearWppTracing(fEnabled);

    return dwErr;
}

//
// Callback for DiagGetState to detect if any tracing is turned off
//
DWORD
DiagGetStateCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    DWORD dwEnabled = 0;
    TRACING_DATA* pTrace = (TRACING_DATA*)hData;

    //
    // Get the enabling of the current component
    //
    TraceRead(hKey, &dwEnabled);
    //
    // If any of the keys are turned off, report failure
    //
    if (!dwEnabled && pTrace)
    {
        pTrace->fOneOk = FALSE;
    }

    return NO_ERROR;
}

//
// NON-NETSH function to detect whether *only* ras tracing is enabled/disabled.
// This is only used by people who loadlib on RASMONTR.
//
BOOL
DiagGetState()
{
    BOOL fRet = FALSE;
    HKEY hkRoot = NULL;
    TRACING_DATA Trace;

    Trace.fOneOk = TRUE;

    if (!TraceOpenRoot(&hkRoot) &&
        !RutlRegEnumKeys(hkRoot, DiagGetStateCb, &Trace)
       )
    {
        fRet = Trace.fOneOk;
    }
    //
    // Clean up
    //
    if (hkRoot)
    {
        RegCloseKey(hkRoot);
    }

    return fRet;
}

//
// enable/disable all tracing.
//
DWORD
DiagSetAll(
    IN BOOL fEnable,
    IN BOOL fDisplay)
{
    DWORD dwErr = ERROR_OPEN_FAILED;

    if (TraceEnableDisableTracing(fEnable))
    {
        dwErr = NO_ERROR;
        if (fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_TRACEALL_RAS_OK);
        }
    }
    else if (fDisplay)
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_TRACEALL_RAS_FAIL);
    }

    if (TraceEnableDisableModem(fEnable))
    {
        dwErr = NO_ERROR;
        if (fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SET_MODEMTRACE_OK);
        }
    }
    else if (fDisplay)
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_SET_MODEMTRACE_FAIL);
    }

    if (TraceEnableDisableCm(fEnable))
    {
        dwErr = NO_ERROR;
        if (fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SET_CMTRACE_OK);
        }
    }
    else if (fDisplay)
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_SET_CMTRACE_FAIL);
    }

    if (TraceEnableDisableAuditing(FALSE, fEnable))
    {
        dwErr = NO_ERROR;
        if (fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SET_AUDITING_OK);
        }
    }
    else if (fDisplay)
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_SET_AUDITING_FAIL);
    }

    if (TraceEnableDisableIpsec(fEnable))
    {
        dwErr = NO_ERROR;
        if (fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SET_IPSEC_OK);
        }
    }
    else if (fDisplay)
    {
        DisplayMessage(g_hModule, EMSG_RASDIAG_SET_IPSEC_FAIL);
    }
    //
    // .Net bug# 522035 RAS Diag: include new WPP tracing logs from RASL2TP and
    // RASPPTP
    //
    TraceEnableDisableAllWpp(fEnable);

    return dwErr;
}

//
// NON-NETSH function to enable/disable *only* ras tracing.
// This is only used by people who loadlib on RASMONTR.
//
DWORD
DiagSetAllRas(
    IN BOOL fEnable)
{
    //
    // .Net bug# 522035 RAS Diag: include new WPP tracing logs from RASL2TP and
    // RASPPTP
    //
    if (TraceEnableDisableTracing(fEnable) &&
        TraceEnableDisableAllWpp(fEnable))
    {
        return NO_ERROR;
    }
    else
    {
        return ERROR_OPEN_FAILED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\precomp.h ===
#define MAX_DLL_NAME 48
#define SECURITY_WIN32

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>

#include <rtutils.h>
#include <mprerror.h>
#include <ras.h>
#include <rasman.h>
#include <raserror.h>
#include <mprapi.h>
#include <mprapip.h>
#include <rasppp.h>
#include <dsgetdc.h>
#include <mapi.h>
#include <mprlog.h>
#include <security.h>
#include <ntsecapi.h>
#include <shlobj.h>
#include <devguid.h>

#include <netsh.h>
#include <netshp.h>
#include <rasdiagp.h>
#include <rasmontr.h>
#include <winipsec.h>
#include <wmistr.h>
#include <evntrace.h>

#include "strdefs.h"
#include "rmstring.h"
#include "defs.h"
#include "rasmon.h"
#include "context.h"
#include "rashndl.h"
#include "user.h"
#include "userhndl.h"
#include "domhndl.h"
#include "rasflag.h"
#include "utils.h"
#include "client.h"
#include "diagrprt.h"
#include "logging.h"
#include "rasdiag.h"
#include "regprint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\diagrprt.c ===
/*
    File: diagrprt.c

    'ras diag' sub context

    09/13/01
*/

#include "precomp.h"

static CONST WCHAR g_wchUnicodeMarker = 0xFEFF;
static CONST WCHAR g_pwszNewLine[]    = L"\r\n";
static CONST WCHAR g_pwszHeaderSep[]  =
    L"-------------------------------------------------------------------------------\r\n";

static CONST WCHAR g_pwszCmMappings[]   =
    L"Software\\Microsoft\\Connection Manager\\Mappings";

CONST WCHAR g_pwszLBracket       = L'[';
CONST WCHAR g_pwszRBracket       = L']';
CONST WCHAR g_pwszSpace[]        = L" ";
CONST WCHAR g_pwszBackSlash      = L'\\';
CONST WCHAR g_pwszNull           = L'\0';

CONST WCHAR g_pwszLogSrchStr[]   = L"*.LOG";
CONST WCHAR g_pwszLogging[]      = L"Logging";
CONST WCHAR g_pwszDispNewLine[]  = L"\n";
CONST WCHAR g_pwszEmpty[]        = L"";

CONST WCHAR g_pwszNewLineHtml[]  = L"<p/>";
CONST WCHAR g_pwszPreStart[]     = L"<pre>";
CONST WCHAR g_pwszPreEnd[]       = L"</pre>";
CONST WCHAR g_pwszAnNameStart[]  = L"<A NAME=\"";
CONST WCHAR g_pwszAnNameMiddle[] = L"\"><h4> ";
CONST WCHAR g_pwszAnNameEnd[]    = L" </h4></A>";
CONST WCHAR g_pwszAnStart[]      = L" <A HREF=\"#";
CONST WCHAR g_pwszAnMiddle[]     = L"\">";
CONST WCHAR g_pwszAnEnd[]        = L"</A> ";
CONST WCHAR g_pwszLiStart[]      = L"<li>";
CONST WCHAR g_pwszLiEnd[]        = L"</li>";

static CONST WCHAR g_wszQuoteHtm[]      = L"&#34;";
static CONST WCHAR g_wszAmpHtm[]        = L"&#38;";
static CONST WCHAR g_wszLeftHtm[]       = L"&#60;";
static CONST WCHAR g_wszRightHtm[]      = L"&#62;";

static CONST WCHAR g_pwszPER[]          = L"PER";
static CONST WCHAR g_pwszPRO[]          = L"PRO";
static CONST WCHAR g_pwszDTC[]          = L"DTC";
static CONST WCHAR g_pwszADS[]          = L"ADS";
static CONST WCHAR g_pwszSRV[]          = L"SRV";

static CONST WCHAR g_pwszx86[]          = L"x86";
static CONST WCHAR g_pwszIA64[]         = L"IA64";
static CONST WCHAR g_pwszIA32[]         = L"IA32";
static CONST WCHAR g_pwszAMD64[]        = L"AMD64";

static CONST WCHAR g_pwszRasUser[]      = L"\\Microsoft\\Network\\Connections\\Pbk\\";
static CONST WCHAR g_pwszCmUser[]       = L"\\Microsoft\\Network\\Connections\\Cm\\";
static CONST WCHAR g_pwszMsinfo[]       = L"\\Common Files\\Microsoft Shared\\MSInfo\\";

CONST WCHAR g_pwszTableOfContents[]         = L"TableOfContents";
CONST WCHAR g_pwszTraceCollectTracingLogs[] = L"TraceCollectTracingLogs";
CONST WCHAR g_pwszTraceCollectCmLogs[]      = L"TraceCollectCmLogs";
CONST WCHAR g_pwszTraceCollectModemLogs[]   = L"g_pwszTraceCollectModemLogs";
CONST WCHAR g_pwszTraceCollectIpsecLogs[]   = L"g_pwszTraceCollectIpsecLogs";
CONST WCHAR g_pwszPrintRasEventLogs[]       = L"PrintRasEventLogs";
CONST WCHAR g_pwszPrintSecurityEventLogs[]  = L"PrintSecurityEventLogs";
CONST WCHAR g_pwszPrintRasInfData[]         = L"PrintRasInfData";
CONST WCHAR g_pwszHrValidateRas[]           = L"HrValidateRas";
CONST WCHAR g_pwszHrShowNetComponentsAll[]  = L"HrShowNetComponentsAll";
CONST WCHAR g_pwszCheckRasRegistryKeys[]    = L"CheckRasRegistryKeys";
CONST WCHAR g_pwszPrintRasEnumDevices[]     = L"PrintRasEnumDevices";
CONST WCHAR g_pwszPrintProcessInfo[]        = L"PrintProcessInfo";
CONST WCHAR g_pwszPrintConsoleUtils[]       = L"PrintConsoleUtils";
CONST WCHAR g_pwszPrintWinMsdReport[]       = L"PrintWinMsdReport";
CONST WCHAR g_pwszPrintAllRasPbks[]         = L"PrintAllRasPbks";

static CONST CMD_LINE_UTILS g_CmdLineUtils[] =
{
    {L"arp.exe -a",               L"arp.exe"},
    {L"ipconfig.exe /all",        L"ipconfig.exe1"},
    {L"ipconfig.exe /displaydns", L"ipconfig.exe2"},
    {L"route.exe print",          L"route.exe"},
    {L"net.exe start",            L"net.exe"},
    {L"netstat.exe -e",           L"netstat.exe1"},
    {L"netstat.exe -o",           L"netstat.exe2"},
    {L"netstat.exe -s",           L"netstat.exe3"},
    {L"netstat.exe -n",           L"netstat.exe4"},
    {L"nbtstat.exe -c",           L"nbtstat.exe1"},
    {L"nbtstat.exe -n",           L"nbtstat.exe2"},
    {L"nbtstat.exe -r",           L"nbtstat.exe3"},
    {L"nbtstat.exe -S",           L"nbtstat.exe4"},
    {L"netsh.exe dump",           L"netsh.exe"},
};

static CONST UINT g_ulNumCmdLines = sizeof(g_CmdLineUtils) / sizeof(CMD_LINE_UTILS);

//
// Declarations from rasnetcfg
//
VOID
HrValidateRas(
    IN BUFFER_WRITE_FILE* pBuff);

VOID
HrShowNetComponentsAll(
    IN BUFFER_WRITE_FILE* pBuff);

//
// Local declarations
//
DWORD
WriteUnicodeMarker(
    IN BUFFER_WRITE_FILE* pBuff);

DWORD
AllocBufferWriteFile(
    IN BUFFER_WRITE_FILE* pBuff);

VOID
FreeBufferWriteFile(
    IN BUFFER_WRITE_FILE* pBuff);

DWORD
BufferWriteFile(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST LPBYTE lpBuff,
    IN DWORD dwSize);

DWORD
BufferWriteToHtml(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST LPBYTE lpBuff,
    IN DWORD dwSize);

DWORD
BufferWriteToHtmlA(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST LPBYTE lpBuff,
    IN DWORD dwSize);

DWORD
BufferWriteMessageVA(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszFormat,
    IN va_list* parglist);

PWCHAR
FindLastCmLogHeader(
    IN LPCWSTR pStart,
    IN LPCWSTR pEnd,
    IN LPCWSTR pCurrent);

PWCHAR
GetCMLoggingPath(
    IN LPCWSTR pwcszCMPFile);

PWCHAR
GetSystemInfoString();

PWCHAR
GetVersionExString(
    OUT PDWORD pdwBuild);

VOID
PrintConsoleUtilsToc(
    IN BUFFER_WRITE_FILE* pBuff);

BOOL
GetCommonFolderPath(
    IN DWORD dwMode,
    OUT TCHAR* pszPathBuf);

LONG
ProcessTimeString(
    IN PCHAR pszTime,
    IN DWORD dwHours);

BOOL
CALLBACK
EnumWindowsProc(
    HWND hwnd,
    LPARAM lParam);

BOOL
EnumMessageWindows(
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam);

BOOL
CALLBACK
EnumDesktopProc(
    LPTSTR lpszDesktop,
    LPARAM lParam);

BOOL
CALLBACK
EnumWindowStationProc(
    LPTSTR lpszWindowStation,
    LPARAM lParam);

VOID
GetWindowTitles(
    PTASK_LIST_ENUM te);

VOID
PrintRasInfData(
    IN BUFFER_WRITE_FILE* pBuff);

VOID
PrintRasEnumDevices(
    IN BUFFER_WRITE_FILE* pBuff);

VOID
PrintProcessInfo(
    IN BUFFER_WRITE_FILE* pBuff);

VOID
PrintConsoleUtils(
    IN REPORT_INFO* pInfo);

VOID
PrintWinMsdReport(
    IN REPORT_INFO* pInfo);

BOOL
PrintRasPbk(
    IN REPORT_INFO* pInfo,
    IN DWORD dwType);

VOID
PrintAllRasPbks(
    IN REPORT_INFO* pInfo);

PUCHAR
GetSystemProcessInfo();

VOID
FreeSystemProcessInfo(
    IN PUCHAR pProcessInfo);

DWORD
DiagGetReport(
    IN DWORD dwFlags,
    IN OUT LPCWSTR pwszString,
    IN OPTIONAL DiagGetReportCb pCallback,
    IN OPTIONAL PVOID pContext)
{
    DWORD dwErr = NO_ERROR;
    PWCHAR pwszTempFile = NULL;
    REPORT_INFO ReportInfo;
    BUFFER_WRITE_FILE Buff;
    GET_REPORT_STRING_CB CbInfo;

    do
    {
        ZeroMemory(&ReportInfo, sizeof(REPORT_INFO));
        ZeroMemory(&Buff, sizeof(BUFFER_WRITE_FILE));
        ZeroMemory(&CbInfo, sizeof(GET_REPORT_STRING_CB));

        if (!pwszString)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        if ((dwFlags & RAS_DIAG_EXPORT_TO_EMAIL) ||
            (dwFlags & RAS_DIAG_DISPLAY_FILE)
           )
        {
            WCHAR wszTempFileName[MAX_PATH + 1];

            dwErr = CopyTempFileName(wszTempFileName);
            BREAK_ON_DWERR(dwErr);

            pwszTempFile = CreateHtmFileName(wszTempFileName);
            if (!pwszTempFile)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        else if (dwFlags & RAS_DIAG_EXPORT_TO_FILE)
        {
            pwszTempFile = CreateHtmFileName(pwszString);
            if (!pwszTempFile)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        //
        // Init the Report Information structure
        //
        ReportInfo.fVerbose = !!(dwFlags & RAS_DIAG_VERBOSE_REPORT);
        ReportInfo.pBuff = &Buff;
        //
        // Create the report file
        //
        dwErr = CreateReportFile(ReportInfo.pBuff, pwszTempFile);
        BREAK_ON_DWERR(dwErr);
        //
        // Print header and table of contents to report
        //
        PrintHtmlHeader(ReportInfo.pBuff);
        PrintTableOfContents(&ReportInfo, SHOW_ALL);
        //
        // Init callback data
        //
        if (pCallback)
        {
            CbInfo.pContext = pContext;
            CbInfo.pwszState = RutlAlloc(
                                (MAX_MSG_LENGTH + 1) * sizeof(WCHAR),
                                FALSE);

            ReportInfo.pCbInfo = &CbInfo;
            ReportInfo.pCallback = pCallback;
        }

        dwErr = RasDiagShowAll(&ReportInfo);

        PrintHtmlFooter(ReportInfo.pBuff);
        CloseReportFile(ReportInfo.pBuff);
        //
        // If report gathering was cancelled via the UI, dwErr will =
        // ERROR_CANCELLED. We do not want to continue in this case.
        //
        if (dwErr)
        {
            DeleteFile(pwszTempFile);
            break;
        }

        if (dwFlags & RAS_DIAG_EXPORT_TO_EMAIL)
        {
            PWCHAR pwszCabFile = NULL;

            pwszCabFile = CabCompressFile(pwszTempFile);
            if (!pwszCabFile)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwErr = MapiSendMail(pwszString, pwszCabFile);
            DeleteFile(pwszCabFile);
            DeleteFile(pwszTempFile);
            RutlFree(pwszCabFile);
        }
        else
        {
            lstrcpyn((PWCHAR)pwszString, pwszTempFile, MAX_PATH);
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(CbInfo.pwszState);
    RutlFree(pwszTempFile);

    return dwErr;
}

VOID
WriteLinkBackToToc(
    IN BUFFER_WRITE_FILE* pBuff)
{
    BufferWriteFileStrW(pBuff, g_pwszSpace);
    BufferWriteFileCharW(pBuff, g_pwszLBracket);
    BufferWriteFileStrW(pBuff, g_pwszAnStart);
    BufferWriteFileStrW(pBuff, g_pwszTableOfContents);
    BufferWriteFileStrW(pBuff, g_pwszAnMiddle);
    BufferWriteMessage(pBuff, g_hModule, MSG_RASDIAG_REPORT_TOC);
    BufferWriteFileStrW(pBuff, g_pwszAnEnd);
    BufferWriteFileCharW(pBuff, g_pwszRBracket);

    return;
}

VOID
WriteHtmlSection(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszAnchor,
    IN DWORD dwMsgId)
{
    BufferWriteFileStrW(pBuff, g_pwszAnNameStart);
    BufferWriteFileStrW(pBuff, pwszAnchor);
    BufferWriteFileStrW(pBuff, g_pwszAnNameMiddle);
    BufferWriteMessage(pBuff, g_hModule, dwMsgId);
    WriteLinkBackToToc(pBuff);
    BufferWriteFileStrW(pBuff, g_pwszAnNameEnd);
}

DWORD
WriteUnicodeMarker(
    IN BUFFER_WRITE_FILE* pBuff)
{
    return BufferWriteFile(
                pBuff,
                (LPBYTE)&g_wchUnicodeMarker,
                sizeof(g_wchUnicodeMarker));
}

DWORD
WriteNewLine(
    IN BUFFER_WRITE_FILE* pBuff)
{
    return BufferWriteFileStrW(pBuff, g_pwszNewLine);
}

VOID
WriteHeaderSep(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszTitle)
{
    BufferWriteFileStrW(pBuff, g_pwszHeaderSep);
    BufferWriteFileStrW(pBuff, pwszTitle);
    WriteNewLine(pBuff);
    BufferWriteFileStrW(pBuff, g_pwszHeaderSep);
}

VOID
WriteEventLogEntry(
    IN BUFFER_WRITE_FILE* pBuff,
    IN PEVENTLOGRECORD pevlr,
    IN LPCWSTR pwszDescr,
    IN LPCWSTR pwszCategory)
{
    PSID psid;
    DWORD dwName = MAX_USERNAME_SIZE, dwDomain = MAX_DOMAIN_SIZE, dwArg;
    WCHAR wszName[MAX_USERNAME_SIZE + 1], wszDomain[MAX_DOMAIN_SIZE + 1],
          wszDate[TIMEDATESTR], wszTime[TIMEDATESTR];
    PWCHAR pwszSource, pwszComputer, pwszType = NULL, pwszTemp,
           pwszCat = NULL, pwszName = NULL;
    SID_NAME_USE snu;

    switch (pevlr->EventType)
    {
        case EVENTLOG_SUCCESS:
            dwArg = MSG_RASDIAG_SHOW_EVENT_SUCCESS;
            break;
        case EVENTLOG_ERROR_TYPE:
            dwArg = MSG_RASDIAG_SHOW_EVENT_ERROR;
            break;
        case EVENTLOG_WARNING_TYPE:
            dwArg = MSG_RASDIAG_SHOW_EVENT_WARNING;
            break;
        case EVENTLOG_INFORMATION_TYPE:
            dwArg = MSG_RASDIAG_SHOW_EVENT_INFO;
            break;
        case EVENTLOG_AUDIT_SUCCESS:
            dwArg = MSG_RASDIAG_SHOW_EVENT_SAUDIT;
            break;
        case EVENTLOG_AUDIT_FAILURE:
            dwArg = MSG_RASDIAG_SHOW_EVENT_FAUDIT;
            break;
        default:
            dwArg = 0;
            break;
    }

    if (dwArg)
    {
        pwszType = LoadStringFromHinst(g_hModule, dwArg);
    }

    pwszSource = (PWCHAR)((LPBYTE) pevlr + sizeof(EVENTLOGRECORD));

    if (!pwszCategory)
    {
        pwszCat = LoadStringFromHinst(g_hModule, MSG_RASDIAG_SHOW_EVENT_NONE);
    }

    RutlGetDateStr(
        pevlr->TimeGenerated,
        wszDate,
        TIMEDATESTR);
    RutlGetTimeStr(
        pevlr->TimeGenerated,
        wszTime,
        TIMEDATESTR);

    psid = (PSID) (((PBYTE) pevlr) + pevlr->UserSidOffset);
    if (!LookupAccountSid(
            NULL,
            psid,
            wszName,
            &dwName,
            wszDomain,
            &dwDomain,
            &snu)
       )
    {
        wszName[0] = g_pwszNull;
        wszDomain[0] = g_pwszNull;
        pwszName = LoadStringFromHinst(g_hModule, MSG_RASDIAG_SHOW_EVENT_NA);
    }

    pwszTemp = pwszSource;
    while(*pwszTemp++ != g_pwszNull);
    pwszComputer = pwszTemp;

    if (wszDomain[0] != g_pwszNull)
    {
        BufferWriteMessage(
            pBuff,
            g_hModule,
            MSG_RASDIAG_SHOW_EVENT_LOG_USERDOM,
            pwszType ? pwszType : g_pwszEmpty,
            pwszSource,
            (pwszCat ? pwszCat :
                (pwszCategory ? pwszCategory : g_pwszEmpty)),
            pevlr->EventID,
            wszDate,
            wszTime,
            wszDomain,
            pwszName ? pwszName : wszName,
            pwszComputer,
            pwszDescr);
    }
    else
    {
        BufferWriteMessage(
            pBuff,
            g_hModule,
            MSG_RASDIAG_SHOW_EVENT_LOG_USER,
            pwszType ? pwszType : g_pwszEmpty,
            pwszSource,
            (pwszCat ? pwszCat :
                (pwszCategory ? pwszCategory : g_pwszEmpty)),
            pevlr->EventID,
            wszDate,
            wszTime,
            pwszName ? pwszName : wszName,
            pwszComputer,
            pwszDescr);
    }
    //
    // Clean up
    //
    FreeStringFromHinst(pwszName);
    FreeStringFromHinst(pwszCat);
    FreeStringFromHinst(pwszType);

    return;
}

DWORD
AllocBufferWriteFile(
    IN BUFFER_WRITE_FILE* pBuff)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        if (!pBuff || !pBuff->hFile ||
            pBuff->hFile == INVALID_HANDLE_VALUE)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        pBuff->lpBuff = RutlAlloc(BUF_WRITE_SIZE, FALSE);
        if (!pBuff->lpBuff)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pBuff->dwPosition = 0;

    } while (FALSE);

    return dwErr;
}

VOID
FreeBufferWriteFile(
    IN BUFFER_WRITE_FILE* pBuff)
{
    //
    // Whistler .NET BUG: 492078
    //
    if (pBuff->dwPosition && pBuff->lpBuff)
    {
        DWORD dwTemp;

        WriteFile(
            pBuff->hFile,
            pBuff->lpBuff,
            pBuff->dwPosition,
            &dwTemp,
            NULL);

        pBuff->dwPosition = 0;
        RutlFree(pBuff->lpBuff);
        pBuff->lpBuff = NULL;
    }

    return;
}

DWORD
BufferWriteFile(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST LPBYTE lpBuff,
    IN DWORD dwSize)
{
    DWORD dwErr = NO_ERROR, dwCurSize, dwCopy, dwTemp;
    LPBYTE lpEnd, lpCurrent;

    do
    {
        if (!pBuff || !lpBuff || !dwSize)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        lpEnd = lpBuff + dwSize;
        lpCurrent = lpBuff;
        dwCurSize = dwSize;

        for (;;)
        {
            dwCopy = min(dwCurSize, BUF_WRITE_SIZE - pBuff->dwPosition);
            CopyMemory(pBuff->lpBuff + pBuff->dwPosition, lpCurrent, dwCopy);
            pBuff->dwPosition += dwCopy;

            if (pBuff->dwPosition == BUF_WRITE_SIZE)
            {
                if (!WriteFile(
                        pBuff->hFile,
                        pBuff->lpBuff,
                        BUF_WRITE_SIZE,
                        &dwTemp,
                        NULL))
                {
                    dwErr = GetLastError();
                    break;
                }
                pBuff->dwPosition = 0;
            }

            lpCurrent += dwCopy;

            if (lpCurrent == lpEnd)
            {
                break;
            }

            dwCurSize = (DWORD)(lpEnd - lpCurrent);
        }

    } while (FALSE);

    return dwErr;
}

//
// Remove HTML escape characters from buffer
//
DWORD
BufferWriteToHtml(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST LPBYTE lpBuff,
    IN DWORD dwSize)
{
    DWORD i, dwTemp = 0, dwErr = NO_ERROR;
    LPBYTE lpTemp = NULL, lpCurrent;
    PWCHAR pwszReplace;
    //For .Net  506188
    PWCHAR pwCheck = NULL;
	

    lpCurrent = lpBuff;

    for (i = 0; i < dwSize; i += sizeof(WCHAR))
    {
	//For .Net  506188
	pwCheck = (WCHAR *) (lpCurrent+i);
       
        switch ( *(pwCheck) )

        {
            case L'\"':
                pwszReplace = (PWCHAR)g_wszQuoteHtm;
                break;
            case L'@':
                pwszReplace = (PWCHAR)g_wszAmpHtm;
                break;
            case L'<':
                pwszReplace = (PWCHAR)g_wszLeftHtm;
                break;
            case L'>':
                pwszReplace = (PWCHAR)g_wszRightHtm;
                break;
            default:
                pwszReplace = NULL;
                break;
        }

        if (pwszReplace)
        {
            //
            // Flush out stuff we are not going to replace
            //
            if (lpTemp && dwTemp)
            {
                dwErr = BufferWriteFile(
                            pBuff,
                            lpTemp,
                            dwTemp * sizeof(WCHAR));
                lpTemp = NULL;
                dwTemp = 0;
                BREAK_ON_DWERR(dwErr);
            }
            //
            // Write out the converted escape seq
            //
            dwErr = BufferWriteFile(
                        pBuff,
                        (LPBYTE)pwszReplace,
                        lstrlen(pwszReplace) * sizeof(WCHAR));
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            //
            // Not an escape seq, continue
            //
            if (!lpTemp)
            {
                lpTemp = lpCurrent + i;
            }

            dwTemp++;
        }
    }
    //
    // Make sure we didn't leave any around to write out
    //
    if (lpTemp && dwTemp)
    {
        dwErr = BufferWriteFile(
                    pBuff,
                    lpTemp,
                    dwTemp * sizeof(WCHAR));
    }

    return dwErr;
}

DWORD
BufferWriteToHtmlA(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST LPBYTE lpBuff,
    IN DWORD dwSize)
{
    UINT i;
    DWORD dwErr = NO_ERROR;
    LPWSTR pTempBuff = NULL;
    DWORD dwNewSize = 0;

    do
    {
        if (!dwSize)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        //
        // First call MultiByteToWideChar to get how large of a Unicode string
        // will result from conversion.
        //
        dwNewSize = MultiByteToWideChar(CP_ACP, 0, lpBuff, dwSize, NULL, 0);
        if (0 == dwNewSize)
        {
            dwErr = GetLastError();
            break;
        }
        //
        // Okay, now allocate enough memory for the new string
        //
        pTempBuff = RutlAlloc((dwNewSize * sizeof(WCHAR)), FALSE);
        if (!pTempBuff)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        //
        // Now do the conversion by calling MultiByteToWideChar again
        //
        if (0 == MultiByteToWideChar(CP_ACP, 0, lpBuff, dwSize, pTempBuff, dwNewSize))
        {
            dwErr = GetLastError();
            break;
        }
        //
        // Finally, write out the buffer to the html file
        //
        dwErr = BufferWriteToHtml(
                    pBuff,
                    (LPBYTE)pTempBuff,
                    dwNewSize * sizeof(WCHAR));

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pTempBuff);

    return dwErr;
}

DWORD
BufferWriteFileStrWtoA(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszString)
{
    PCHAR pszString = NULL;
    DWORD dwErr = NO_ERROR;

    if (!pwszString)
    {
        return ERROR_INVALID_PARAMETER;
    }

    pszString = RutlStrDupAFromW(pwszString);
    if (!pszString)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = BufferWriteFile(
                pBuff,
                (LPBYTE)pszString,
                lstrlenA(pszString));

    RutlFree(pszString);

    return dwErr;
}

DWORD
BufferWriteFileStrW(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszString)
{
    if (!pwszString)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return BufferWriteFile(
                pBuff,
                (LPBYTE)pwszString,
                lstrlen(pwszString) * sizeof(WCHAR));
}

DWORD
BufferWriteFileCharW(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST WCHAR wszChar)
{
    return BufferWriteFile(pBuff, (LPBYTE)&wszChar, sizeof(WCHAR));
}

DWORD
BufferWriteMessageVA(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszFormat,
    IN va_list* parglist)
{
    DWORD dwErr = NO_ERROR, dwMsgLen = 0;
    LPWSTR pwszOutput = NULL;

    do
    {
        dwMsgLen = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_STRING,
                        pwszFormat,
                        0,
                        0L,
                        (LPWSTR)&pwszOutput,
                        0,
                        parglist);
        if(!dwMsgLen)
        {
            dwErr = GetLastError();
            break;
        }

        dwErr = BufferWriteFile(
                    pBuff,
                    (LPBYTE)pwszOutput,
                    dwMsgLen * sizeof(WCHAR));

    } while (FALSE);

    if (pwszOutput)
    {
        LocalFree(pwszOutput);
    }

    return dwErr;
}

DWORD
BufferWriteMessage(
    IN BUFFER_WRITE_FILE* pBuff,
    IN HANDLE hModule,
    IN DWORD dwMsgId,
    ...)
{
    WCHAR rgwcInput[MAX_MSG_LENGTH + 1];
    va_list arglist;

    if (!LoadString(hModule, dwMsgId, rgwcInput, MAX_MSG_LENGTH))
    {
        return GetLastError();
    }

    va_start(arglist, dwMsgId);

    return BufferWriteMessageVA(pBuff, rgwcInput, &arglist);
}

LPBYTE
ParseRasLogForTime(
    IN LPBYTE pBuff,
    IN DWORD dwSize,
    IN DWORD dwHours)
{
    CHAR szTime[TIMESIZE + 1];
    LPBYTE pCurrent, pEnd, pStart, pTemp, pLast = NULL, pReturn = NULL;

    CONST PCHAR c_pszRasLogString = "\r\n[";
    CONST UINT c_ulRasLogStringSize = strlen(c_pszRasLogString);

    pStart = pBuff;
    pCurrent = pEnd = pBuff + dwSize;

    do
    {
        if (pCurrent + TIMESIZE + 4 > pEnd)
        {
            pCurrent -= TIMESIZE + 4;
            continue;
        }

        if (!strncmp(pCurrent, c_pszRasLogString, c_ulRasLogStringSize))
        {
            pTemp = pCurrent + c_ulRasLogStringSize;
            //
            // Find the space before the time
            //
            while ((*pTemp++ != ' ') &&
                   (*pTemp != g_pwszNull)
                  );
            //
            // Check for colons then the period before mil sec
            //
            if ((pTemp + TIMESIZE + 1 > pEnd) ||
                (*(pTemp + 2) != ':') ||
                (*(pTemp + 5) != ':') ||
                (*(pTemp + TIMESIZE ) != ':')
               )
            {
                continue;
            }

            strncpy(szTime, pTemp, TIMESIZE);
            szTime[TIMESIZE] = '\0';

            if (ProcessTimeString(szTime, dwHours) == -1)
            {
                pReturn = pLast;
                break;
            }
            else
            {
                pLast = pCurrent + 2;
                continue;
            }
        }

    } while (--pCurrent >= pStart);
    //
    // Since we parsed the whole file, display the whole file
    //
    if (pCurrent < pStart)
    {
        pReturn = pStart;
    }

    return pReturn;
}

LPBYTE
ParseModemLogForTime(
    IN LPBYTE pBuff,
    IN DWORD dwSize,
    IN DWORD dwHours)
{
    PCHAR pszTimeA = NULL;
    WCHAR wszTime[TIMESIZE + 1];
    PWCHAR pCurrent, pEnd, pStart, pTemp, pLast = NULL, pReturn = NULL;

    pStart = (PWCHAR)pBuff;
    pCurrent = pEnd = (PWCHAR)((LPBYTE)pBuff + dwSize);

    do
    {
        if (pCurrent + TIMESIZE + 4 > pEnd)
        {
            pCurrent -= TIMESIZE + 4;
            continue;
        }

        if ((*pCurrent == '\r') &&
            (*(pCurrent + 1) == '\n') &&
            (*(pCurrent + 4) == '-') &&
            (*(pCurrent + 7) == '-')
           )
        {
            pTemp = pCurrent;
            //
            // Find the space
            //
            while ((*pTemp++ != ' ') &&
                   (*pTemp != g_pwszNull)
                  );
            //
            // Check for colons then the period before mil sec
            //
            if ((pTemp + TIMESIZE > pEnd) ||
                (*(pTemp + 2) != ':') ||
                (*(pTemp + 5) != ':') ||
                (*(pTemp + TIMESIZE ) != '.')
               )
            {
                continue;
            }
            //
            // it seems that lstrcpyn subtracts 1 from the size for the NULL on
            // your behalf then appends a NULL to the end
            //
            lstrcpyn(wszTime, pTemp, TIMESIZE + 1);

            pszTimeA = RutlStrDupAFromWAnsi(wszTime);
            if (!pszTimeA)
            {
                continue;
            }

            if (ProcessTimeString(pszTimeA, dwHours) == -1)
            {
                RutlFree(pszTimeA);
                pszTimeA = NULL;

                pReturn = pLast;
                break;
            }
            else
            {
                RutlFree(pszTimeA);
                pszTimeA = NULL;

                pLast = pCurrent + 2;
                continue;
            }
        }

    } while (--pCurrent >= pStart);
    //
    // Since we parsed the whole file, display the whole file
    // Also, This is a unicode file so we need to chop off the garbage in front
    //
    if (pCurrent < pStart)
    {
        pReturn = pStart + 1;
    }
    //
    // Clean up
    //
    RutlFree(pszTimeA);

    return (LPBYTE)pReturn;
}

PWCHAR
FindLastCmLogHeader(
    IN LPCWSTR pStart,
    IN LPCWSTR pEnd,
    IN LPCWSTR pCurrent)
{
    PWCHAR pCurrentCopy, pReturn = NULL;

    CONST PWCHAR c_pwszCmLogString = L"\r\n*";
    CONST UINT c_ulCmLogStringSize = lstrlen(c_pwszCmLogString);

    pCurrentCopy = (PWCHAR)pCurrent;

    do
    {
        if (!RutlStrNCmp(pCurrentCopy, c_pwszCmLogString, c_ulCmLogStringSize))
        {
            pReturn = pCurrentCopy + 2;
            break;
        }

    } while (--pCurrentCopy >= pStart);

    return pReturn;
}

LPBYTE
ParseCmLogForTime(
    IN LPBYTE pBuff,
    IN DWORD dwSize,
    IN DWORD dwHours)
{
    PCHAR pszTimeA = NULL;
    WCHAR wszTime[TIMESIZE + 1];
    PWCHAR pCurrent, pEnd, pStart, pTemp, pLast = NULL, pReturn = NULL;

    CONST PWCHAR c_pwszCmLogString = L"\r\n\tStart Date/Time       : ";
    CONST UINT c_ulCmLogStringSize = lstrlen(c_pwszCmLogString);

    pStart = (PWCHAR)pBuff;
    pCurrent = pEnd = (PWCHAR)((LPBYTE)pBuff + dwSize);

    do
    {
        if (pCurrent + TIMESIZE + 35 > pEnd)
        {
            pCurrent -= TIMESIZE + 35;
            continue;
        }

        if (!RutlStrNCmp(pCurrent, c_pwszCmLogString, c_ulCmLogStringSize))
        {
            pTemp = pCurrent + c_ulCmLogStringSize;
            //
            // Find the space
            //
            while ((*pTemp++ != ' ') &&
                   (*pTemp != g_pwszNull)
                  );
            //
            // Check for colons then the period before mil sec
            //
            if ((pTemp + TIMESIZE > pEnd) ||
                (*(pTemp + 2) != ':') ||
                (*(pTemp + 5) != ':') ||
                (*(pTemp + TIMESIZE ) != '\r')
               )
            {
                continue;
            }
            //
            // it seems that lstrcpyn subtracts 1 from the size for the NULL on
            // your behalf then appends a NULL to the end
            //
            lstrcpyn(wszTime, pTemp, TIMESIZE + 1);

            pszTimeA = RutlStrDupAFromWAnsi(wszTime);
            if (!pszTimeA)
            {
                continue;
            }

            if (ProcessTimeString(pszTimeA, dwHours) == -1)
            {
                RutlFree(pszTimeA);
                pszTimeA = NULL;

                pReturn = pLast;
                break;
            }
            else
            {
                RutlFree(pszTimeA);
                pszTimeA = NULL;

                pLast = FindLastCmLogHeader(pStart, pEnd, pCurrent - 1);
                //
                // If we are unable to find a CM log header above, we assume we
                // have hit the start of the log. we add one because of unicode
                // garbabe at front of file
                //
                if (!pLast)
                {
                    pReturn = pStart + 1;
                    break;
                }

                continue;
            }
        }

    } while (--pCurrent >= pStart);
    //
    // Clean up
    //
    RutlFree(pszTimeA);

    return (LPBYTE)pReturn;
}

LPBYTE
ParseIpsecLogForTime(
    IN LPBYTE pBuff,
    IN DWORD dwSize,
    IN DWORD dwHours)
{
    CHAR szTime[TIMESIZE + 1];
    LPBYTE pCurrent, pEnd, pStart, pTemp, pLast = NULL, pReturn = NULL;

    CONST PCHAR c_pszIpsecLogString = "\r\n ";
    CONST UINT c_ulIpsecLogStringSize = strlen(c_pszIpsecLogString);

    pStart = pBuff;
    pCurrent = pEnd = pBuff + dwSize;

    do
    {
        if (pCurrent + TIMESIZE + 4 > pEnd)
        {
            pCurrent -= TIMESIZE + 4;
            continue;
        }

        if (!strncmp(pCurrent, c_pszIpsecLogString, c_ulIpsecLogStringSize))
        {
            pTemp = pCurrent + c_ulIpsecLogStringSize;
            //
            // Find the space before the time
            //
            while ((*pTemp++ != ' ') &&
                   (*pTemp != g_pwszNull)
                  );
            //
            // Check for colons then the period before mil sec
            //
            if ((pTemp + TIMESIZE + 1 > pEnd) ||
                (*(pTemp + 2) != ':') ||
                (*(pTemp + 5) != ':') ||
                (*(pTemp + TIMESIZE ) != ':')
               )
            {
                continue;
            }

            strncpy(szTime, pTemp, TIMESIZE);
            szTime[TIMESIZE] = '\0';

            if (ProcessTimeString(szTime, dwHours) == -1)
            {
                pReturn = pLast;
                break;
            }
            else
            {
                pLast = pCurrent + 2;
                continue;
            }
        }

    } while (--pCurrent >= pStart);
    //
    // Since we parsed the whole file, display the whole file
    //
    if (pCurrent < pStart)
    {
        pReturn = pStart;
    }

    return pReturn;
}

DWORD
PrintFile(
    IN REPORT_INFO* pInfo,
    IN LPCWSTR pwszFile,
    IN BOOL fWritePath,
    IN RAS_PRINTFILE_FUNC_CB pCallback)
{
    BOOL bIsWide = FALSE;
    DWORD dwErr = NO_ERROR, dwFileSize = 0, dwBytesRead;
    HANDLE hFile = NULL;
    LPBYTE lpBuff = NULL, pFound = NULL;

    do
    {
        if (!pInfo || !pwszFile)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        hFile = CreateFile(
                    pwszFile,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
        if(INVALID_HANDLE_VALUE == hFile)
        {
            dwErr = GetLastError();
            break;
        }

        dwFileSize = GetFileSize(hFile, NULL);
        if ((dwFileSize < sizeof(g_wchUnicodeMarker)) ||
            (INVALID_FILE_SIZE == dwFileSize)
           )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        lpBuff = RutlAlloc(dwFileSize, FALSE);
        if (!lpBuff)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if((!ReadFile(hFile, lpBuff, dwFileSize, &dwBytesRead, NULL)) ||
           (dwBytesRead != dwFileSize)
          )
        {
            dwErr = GetLastError();
            break;
        }
        //
        // If we got this far it is safe to go ahead and print the path
        //
        if (fWritePath)
        {
            WriteHeaderSep(pInfo->pBuff, pwszFile);
        }
        //
        // check to see if the file is unicode
        //
        if (!memcmp(&g_wchUnicodeMarker, lpBuff, sizeof(g_wchUnicodeMarker)))
        {
            bIsWide = TRUE;
        }

        if (!pCallback || !pInfo->dwHours)
        {
            if (bIsWide)
            {
                //
                // Unicode file has 2 bytes of leading stuff
                //
                pFound = lpBuff + sizeof(g_wchUnicodeMarker);
            }
            else
            {
                pFound = lpBuff;
            }
        }
        else
        {
            //
            // Call the callback
            //
            pFound = pCallback(lpBuff, dwFileSize, pInfo->dwHours);
            if (!pFound)
            {
                dwErr = ERROR_FILE_NOT_FOUND;
                break;
            }
        }

        if (bIsWide)
        {
            dwErr = BufferWriteToHtml(
                        pInfo->pBuff,
                        pFound,
                        (DWORD)((lpBuff + dwFileSize) - pFound));
        }
        else
        {
            dwErr = BufferWriteToHtmlA(
                        pInfo->pBuff,
                        pFound,
                        (DWORD)((lpBuff + dwFileSize) - pFound));
        }

        WriteNewLine(pInfo->pBuff);

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(lpBuff);
    if (hFile)
    {
        CloseHandle(hFile);
    }

    return dwErr;
}

PWCHAR
GetCMLoggingPath(
    IN LPCWSTR pwcszCMPFile)
{
    DWORD dwSize;
    WCHAR wszTemp[MAX_PATH + 1], wszFile[MAX_PATH + 1];
    PWCHAR pwszCMSPath = NULL, pwszReturn = NULL;

    CONST PWCHAR pwszCM = L"Connection Manager";
    CONST PWCHAR pwszCMS = L"CMSFile";
    CONST PWCHAR pwszFileDir = L"FileDirectory";
    CONST PWCHAR pwszTempDir = L"%TEMP%\\";

    do
    {
        if (!pwcszCMPFile ||
            !ExpandEnvironmentStrings(
                pwcszCMPFile,
                wszTemp,
                MAX_PATH)
           )
        {
            break;
        }

        if (!GetPrivateProfileString(
                pwszCM,
                pwszCMS,
                g_pwszEmpty,
                wszFile,
                MAX_PATH,
                wszTemp)
           )
        {
            break;
        }

        if (!GetCommonFolderPath(ALL_USERS_PROF | GET_FOR_CM, wszTemp))
        {
            break;
        }

        dwSize = lstrlen(wszFile) + lstrlen(wszTemp) + 1;
        if (dwSize < 2)
        {
            break;
        }

        pwszCMSPath = RutlAlloc(dwSize * sizeof(WCHAR), TRUE);
        if (!pwszCMSPath)
        {
            break;
        }

        lstrcpy(pwszCMSPath, wszTemp);
        lstrcat(pwszCMSPath, wszFile);

        if (!GetPrivateProfileString(
                g_pwszLogging,
                pwszFileDir,
                pwszTempDir,
                wszFile,
                MAX_PATH,
                pwszCMSPath)
           )
        {
            break;
        }

        if (!ExpandEnvironmentStrings(
                wszFile,
                wszTemp,
                MAX_PATH))
        {
            break;
        }
        //
        // Must guarentee string ends with '\'
        //
        dwSize = lstrlen(wszTemp);

        if (g_pwszBackSlash != wszTemp[dwSize - 1])
        {
            if (dwSize + 1 <= MAX_PATH)
            {
                wszTemp[dwSize - 1] = g_pwszBackSlash;
                wszTemp[dwSize] = g_pwszNull;
            }
            else
            {
                break;
            }
        }

        pwszReturn = RutlStrDup(wszTemp);

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszCMSPath);

    return pwszReturn;
}

BOOL
GetCMLoggingSearchPath(
    IN HANDLE hKey,
    IN LPCWSTR pwszName,
    IN LPCWSTR* ppwszLogPath,
    IN LPCWSTR* ppwszSeach)
{
    HKEY hMappings = NULL;
    BOOL fRet = FALSE;
    DWORD dwSize;
    PWCHAR pwszCMPFile = NULL;

    do
    {
        if (!ppwszLogPath || !ppwszSeach)
        {
            break;
        }

        *ppwszLogPath = NULL;
        *ppwszSeach = NULL;

        if (RegOpenKeyEx(
                hKey,
                g_pwszCmMappings,
                0,
                KEY_READ,
                &hMappings) ||
            RutlRegReadString(
                hMappings,
                pwszName,
                &pwszCMPFile)
           )
        {
            break;
        }

        *ppwszLogPath = GetCMLoggingPath(pwszCMPFile);
        if (!(*ppwszLogPath))
        {
            break;
        }

        dwSize = lstrlen(pwszName) + lstrlen(g_pwszLogSrchStr) + 1;
        if (dwSize < 2)
        {
            break;
        }

        *ppwszSeach = RutlAlloc(dwSize * sizeof(WCHAR), FALSE);
        if (!(*ppwszSeach))
        {
            break;
        }

        lstrcpy((PWCHAR)(*ppwszSeach), pwszName);
        lstrcat((PWCHAR)(*ppwszSeach), g_pwszLogSrchStr);

        fRet = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszCMPFile);

    return fRet;
}

PWCHAR
GetTracingDir()
{
    DWORD dwSize = 0;
    WCHAR wszWindir[MAX_PATH + 1];
    PWCHAR pwszReturn = NULL;

    CONST WCHAR c_pwszTracingPath[] = L"\\tracing\\";

    do
    {
        dwSize = GetSystemWindowsDirectory(wszWindir, MAX_PATH);
        if (!dwSize)
        {
            break;
        }

        dwSize += lstrlen(c_pwszTracingPath) + 1;

        pwszReturn = RutlAlloc(dwSize * sizeof(WCHAR), TRUE);
        if (!pwszReturn)
        {
            break;
        }

        lstrcpy(pwszReturn, wszWindir);
        lstrcat(pwszReturn, c_pwszTracingPath);

    } while (FALSE);

    return pwszReturn;
}

PWCHAR
CreateErrorString(
    IN WORD wNumStrs,
    IN LPCWSTR pswzStrings,
    IN LPCWSTR pswzErrorMsg)
{
    UINT i, ulSize = 0, ulStrCount = 0;
    PWCHAR pwszReturn = NULL, pwszCurrent, pwszEnd;
    PWCHAR pswzStrs = (PWCHAR)pswzStrings, pswzError = (PWCHAR)pswzErrorMsg;
    PWCHAR* ppwszStrArray = NULL;

    do
    {
        //
        // only handle between 1 - 99 strings
        //
        if ((wNumStrs < 1) ||
            (wNumStrs > 99) ||
            (!pswzStrs || !pswzError)
           )
        {
            break;
        }

        ppwszStrArray = RutlAlloc(wNumStrs * sizeof(PWCHAR), TRUE);
        if (!ppwszStrArray)
        {
            break;
        }

        for (i = 0; i < wNumStrs; i++)
        {
            ppwszStrArray[i] = pswzStrs;
            ulSize += lstrlen(pswzStrs);
            while(*pswzStrs++ != g_pwszNull);
        }

        ulSize += lstrlen(pswzError) + 1;

        pwszReturn = RutlAlloc(ulSize * sizeof(WCHAR), TRUE);
        if (!pwszReturn)
        {
            break;
        }
        //
        // Walk through the string and replacing any inserts with proper string
        //
        pwszCurrent = pswzError;
        pwszEnd = pswzError + lstrlen(pswzError);

        while((*pwszCurrent != g_pwszNull) &&
              (pwszCurrent + 1 <= pwszEnd) &&
              (ulStrCount < wNumStrs)
             )
        {
            if ((*pwszCurrent == L'%') &&
                (*(pwszCurrent + 1) >= L'0') &&
                (*(pwszCurrent + 1) <= L'9')
               )
            {
                *pwszCurrent = g_pwszNull;

                if ((pwszCurrent + 2 <= pwszEnd) &&
                    (*(pwszCurrent + 2) >= L'0') &&
                    (*(pwszCurrent + 2) <= L'9')
                   )
                {
                    pwszCurrent += 3;
                }
                else
                {
                    pwszCurrent += 2;
                }

                lstrcat(pwszReturn, pswzError);
                lstrcat(pwszReturn, ppwszStrArray[ulStrCount++]);
                pswzError = pwszCurrent;
            }
            else
            {
                pwszCurrent++;
            }
        }

        if (pwszEnd > pswzError)
        {
            lstrcat(pwszReturn, pswzError);
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(ppwszStrArray);

    return pwszReturn;
}

PWCHAR
FormatMessageFromMod(
    IN HANDLE hModule,
    IN DWORD dwId)
{
    PWCHAR pwszReturn = NULL;

    FormatMessage(
        FORMAT_MESSAGE_IGNORE_INSERTS |
            FORMAT_MESSAGE_MAX_WIDTH_MASK |
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_HMODULE,
        hModule,
        dwId,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR)&pwszReturn,
        0,
        NULL);

    return pwszReturn;
}

VOID
FreeFormatMessageFromMod(
    IN LPCWSTR pwszMessage)
{
    if (pwszMessage)
    {
        LocalFree((PWCHAR)pwszMessage);
    }
}

PWCHAR
LoadStringFromHinst(
    IN HINSTANCE hInst,
    IN DWORD dwId)
{
    WCHAR rgwcInput[MAX_MSG_LENGTH + 1];
    PWCHAR pwszReturn = NULL;

    if (LoadString(hInst, dwId, rgwcInput, MAX_MSG_LENGTH))
    {
        pwszReturn = RutlStrDup(rgwcInput);
    }

    return pwszReturn;
}

VOID
FreeStringFromHinst(
    IN LPCWSTR pwszMessage)
{
    RutlFree((PWCHAR)pwszMessage);
}

DWORD
CopyAndCallCB(
    IN REPORT_INFO* pInfo,
    IN DWORD dwId)
{
    DWORD dwErr = NO_ERROR;
    PWCHAR pwszTemp = NULL;
    GET_REPORT_STRING_CB* pCbInfo = pInfo->pCbInfo;

    if (pCbInfo->pwszState)
    {
        pwszTemp = LoadStringFromHinst(g_hModule, dwId);
        if (pwszTemp)
        {
            lstrcpyn(pCbInfo->pwszState, pwszTemp, MAX_MSG_LENGTH);
            FreeStringFromHinst(pwszTemp);
        }
        else
        {
            pCbInfo->pwszState[0] = g_pwszNull;
        }
    }

    pCbInfo->dwPercent += ADD_PERCENT_DONE(pInfo->fVerbose);
    //
    // Call the callback
    //
    dwErr = pInfo->pCallback(pCbInfo);
    //
    // Ignore all errors except ERROR_CANCELLED
    //
    if (dwErr && dwErr != ERROR_CANCELLED)
    {
        dwErr = NO_ERROR;
    }

    return dwErr;
}

//
// Get a temp filename of at most MAX_PATH
//
DWORD
CopyTempFileName(
    OUT LPCWSTR pwszTempFileName)
{
    WCHAR wszTempBuffer[MAX_PATH + 1];

    if (!GetTempPath(MAX_PATH, wszTempBuffer) ||
        !GetTempFileName(wszTempBuffer, L"RAS", 0, (PWCHAR)pwszTempFileName)
       )
    {
        return GetLastError();
    }
    else
    {
        //
        // Delete the temp file that was created by GetTempFileName
        //
        DeleteFile(pwszTempFileName);
        return NO_ERROR;
    }
}

PWCHAR
CreateHtmFileName(
    IN LPCWSTR pwszFile)
{
    DWORD dwSize = 0;
    WCHAR wszTemp[MAX_PATH] = L"\0";
    PWCHAR pwszSearch, pwszReturn = NULL;

    static CONST WCHAR c_pwszHtmExt[] = L".htm";
    static CONST WCHAR c_pwszHtmlExt[] = L".html";

    do
    {
        dwSize = lstrlen(pwszFile);
        if (!dwSize)
        {
            break;
        }
        //
        // .Net bug# 523850 SECURITY: Specifying the diagnostics report file
        // with more than 255 characters causes a buffer overrun
        //
        // CreateFile fails if you have more than 258 characters in the path
        //
        if (!ExpandEnvironmentStrings(
            pwszFile,
            wszTemp,
            (sizeof(wszTemp) / sizeof(WCHAR)) - lstrlen(c_pwszHtmExt) - 1)
           )
        {
            break;
        }
        //
        // If string already has .htm, get outta here
        //
        pwszSearch = (PWCHAR)(pwszFile + dwSize - lstrlen(c_pwszHtmExt));
        if (lstrcmpi(pwszSearch, c_pwszHtmExt) == 0)
        {
            pwszReturn = RutlStrDup(pwszFile);
            break;
        }
        //
        // If string already has .html, get outta here
        //
        pwszSearch = (PWCHAR)(pwszFile + dwSize - lstrlen(c_pwszHtmlExt));
        if (lstrcmpi(pwszSearch, c_pwszHtmlExt) == 0)
        {
            pwszReturn = RutlStrDup(pwszFile);
            break;
        }

        lstrcat(wszTemp, c_pwszHtmExt);
        pwszReturn = RutlStrDup(wszTemp);

    } while (FALSE);

    return pwszReturn;
}

DWORD
CreateReportFile(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszReport)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        if (!pBuff || !pwszReport)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        pBuff->hFile = CreateFile(
                        pwszReport,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
        if(pBuff->hFile == INVALID_HANDLE_VALUE)
        {
            dwErr = GetLastError();
            pBuff->hFile = NULL;
            break;
        }
        //
        // .Net bug# 523037 SECURITY: Specifying the diagnostics report file as
        // the Printer Port (LPT1) will cause netsh to hang
        //
        else if (GetFileType(pBuff->hFile) != FILE_TYPE_DISK)
        {
            dwErr = ERROR_FILE_NOT_FOUND;
            break;
        }

        dwErr = AllocBufferWriteFile(pBuff);
        BREAK_ON_DWERR(dwErr);

        dwErr = WriteUnicodeMarker(pBuff);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    if (dwErr)
    {
        CloseReportFile(pBuff);
    }

    return dwErr;
}

VOID
CloseReportFile(
    IN BUFFER_WRITE_FILE* pBuff)
{
    //
    // Whistler .NET BUG: 492078
    //
    if (pBuff && pBuff->hFile)
    {
        FreeBufferWriteFile(pBuff);
        CloseHandle(pBuff->hFile);
        pBuff->hFile = NULL;
    }
}

DWORD
RasDiagShowAll(
    IN REPORT_INFO* pInfo)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        dwErr = TraceCollectAll(pInfo);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasDiagShowInstallation(pInfo);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasDiagShowConfiguration(pInfo);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    return dwErr;
}

VOID
PrintHtmlHeader(
    IN BUFFER_WRITE_FILE* pBuff)
{
    static CONST WCHAR c_pwszHtmlStart[] = L"<html><head><title> ";
    static CONST WCHAR c_pwszBodyStart[] =
        L" </title></head><body bgcolor=\"#FFFFE8\" text=\"#000088\"><h1>";
    static CONST WCHAR c_pwszBodyEnd[] = L"</body></html>";
    static CONST WCHAR c_pwszH1End[] = L"</h1>";

    BufferWriteFileStrW(pBuff, c_pwszHtmlStart);
    BufferWriteMessage(pBuff, g_hModule, MSG_RASDIAG_REPORT_TITLE);
    BufferWriteFileStrW(pBuff, c_pwszBodyStart);
    BufferWriteMessage(pBuff, g_hModule, MSG_RASDIAG_REPORT_TITLE);
    BufferWriteFileStrW(pBuff, c_pwszH1End);

    return;
}

VOID
PrintHtmlFooter(
    IN BUFFER_WRITE_FILE* pBuff)
{
    static CONST WCHAR c_pwszBodyEnd[] = L"</body></html>";

    BufferWriteFileStrW(pBuff, c_pwszBodyEnd);

    return;
}

PWCHAR
GetSystemInfoString()
{
    PWCHAR Return = NULL;
    SYSTEM_INFO siSysInfo;

    ZeroMemory(&siSysInfo, sizeof(SYSTEM_INFO));
    GetSystemInfo(&siSysInfo);

    switch (siSysInfo.wProcessorArchitecture)
    {
        case PROCESSOR_ARCHITECTURE_INTEL:
            Return = (PWCHAR)g_pwszx86;
            break;
        case PROCESSOR_ARCHITECTURE_IA64:
            Return = (PWCHAR)g_pwszIA64;
            break;
        case PROCESSOR_ARCHITECTURE_IA32_ON_WIN64:
            Return = (PWCHAR)g_pwszIA32;
            break;
        case PROCESSOR_ARCHITECTURE_AMD64:
            Return = (PWCHAR)g_pwszAMD64;
            break;
        default:
            Return = (PWCHAR)g_pwszEmpty;
            break;
    }

    return Return;
}

PWCHAR
GetVersionExString(
    OUT PDWORD pdwBuild)
{
    PWCHAR Return = NULL;
    OSVERSIONINFOEX osvi;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((OSVERSIONINFO*)&osvi);

    switch (osvi.wProductType)
    {
        case VER_NT_WORKSTATION:
             if(osvi.wSuiteMask & VER_SUITE_PERSONAL)
             {
                 Return = (PWCHAR)g_pwszPER;
             }
             else
             {
                 Return = (PWCHAR)g_pwszPRO;
             }
             break;
        case VER_NT_SERVER:
            if(osvi.wSuiteMask & VER_SUITE_DATACENTER)
            {
                Return = (PWCHAR)g_pwszDTC;
            }
            else if(osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
            {
                Return = (PWCHAR)g_pwszADS;
            }
            else
            {
                Return = (PWCHAR)g_pwszSRV;
            }
            break;
        default:
            Return = (PWCHAR)g_pwszEmpty;
            break;
    }

    if (pdwBuild)
    {
        *pdwBuild = osvi.dwBuildNumber;
    }

    return Return;
}

VOID
PrintTableOfContents(
    IN REPORT_INFO* pInfo,
    IN DWORD dwFlag)
{
    WCHAR wszTime[TIMEDATESTR], wszDate[TIMEDATESTR], wszUsername[UNLEN + 1],
          wszComputer[MAX_COMPUTERNAME_LENGTH + 1], wszWindir[MAX_PATH + 1];
    DWORD dwBuild = 0;
    PWCHAR pwszSuite = NULL, pwszProc = NULL;

    static CONST WCHAR c_pwszTableStart[]  = L"<table border=\"0\">";
    static CONST WCHAR c_pwszTableEnd[]    = L"</table>";
    static CONST WCHAR c_pwszFieldStart[]  = L"<fieldset>";
    static CONST WCHAR c_pwszFieldEnd[]    = L"</fieldset>";
    static CONST WCHAR c_pwszH3Start[]     = L"<h3> ";
    static CONST WCHAR c_pwszH3End[]       = L" </h3>";
    static CONST WCHAR c_pwszUlStart[]     = L"<ul>";
    static CONST WCHAR c_pwszUlEnd[]       = L"</ul>";

    {
        SYSTEMTIME st;

        GetLocalTime(&st);

        if (!GetDateFormat(LOCALE_USER_DEFAULT,
                            DATE_SHORTDATE,
                            &st,
                            NULL,
                            wszDate,
                            TIMEDATESTR))
        {
            wszDate[0] = g_pwszNull;
        }

        if (!GetTimeFormat(LOCALE_USER_DEFAULT,
                            0,
                            &st,
                            NULL,
                            wszTime,
                            TIMEDATESTR))
        {
            wszTime[0] = g_pwszNull;
        }
    }
    {
        DWORD dwSize = UNLEN;

        if (!GetUserNameEx(NameSamCompatible, wszUsername, &dwSize))
        {
            wszUsername[0] = g_pwszNull;
        }

        dwSize = MAX_COMPUTERNAME_LENGTH;

        if (!GetComputerName(wszComputer, &dwSize))
        {
            wszComputer[0] = g_pwszNull;
        }

        if (!GetSystemWindowsDirectory(wszWindir, MAX_PATH))
        {
            wszWindir[0] = g_pwszNull;
        }
    }

    pwszSuite = GetVersionExString(&dwBuild);
    pwszProc = GetSystemInfoString();

    BufferWriteFileStrW(pInfo->pBuff, c_pwszTableStart);
    BufferWriteMessage(
        pInfo->pBuff,
        g_hModule,
        MSG_RASDIAG_REPORT_HTMLTOC,
        RASDIAG_VERSION,
        wszDate,
        wszTime,
        wszUsername,
        wszComputer,
        wszWindir,
        dwBuild,
        pwszSuite,
        pwszProc);
    BufferWriteFileStrW(pInfo->pBuff, c_pwszTableEnd);
    BufferWriteFileStrW(pInfo->pBuff, g_pwszNewLineHtml);

    BufferWriteFileStrW(pInfo->pBuff, c_pwszFieldStart);

    BufferWriteFileStrW(pInfo->pBuff, c_pwszH3Start);
    BufferWriteFileStrW(pInfo->pBuff, g_pwszAnNameStart);
    BufferWriteFileStrW(pInfo->pBuff, g_pwszTableOfContents);
    BufferWriteFileStrW(pInfo->pBuff, g_pwszAnNameMiddle);
    BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_TOC);
    BufferWriteFileStrW(pInfo->pBuff, g_pwszAnNameEnd);
    BufferWriteFileStrW(pInfo->pBuff, c_pwszH3End);
    //
    // show logs
    //
    if (dwFlag & SHOW_LOGS)
    {
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_TRACEEVENT);

        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlStart);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszTraceCollectTracingLogs);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_TRACE);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlStart);

        WriteTracingLogsToc(pInfo);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszTraceCollectModemLogs);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_TRACE_MODEM);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszTraceCollectCmLogs);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_TRACE_CM);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszTraceCollectIpsecLogs);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_TRACE_IPSEC);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPrintRasEventLogs);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_RASEVENT);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPrintSecurityEventLogs);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_SECEVENT);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlEnd);
    }
    //
    // show installation
    //
    if (dwFlag & SHOW_INSTALL)
    {
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_INSTALL);

        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlStart);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPrintRasInfData);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_RASINF);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszHrValidateRas);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_RASCHK);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszHrShowNetComponentsAll);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_NETINST);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszCheckRasRegistryKeys);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_RASREG);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlEnd);
    }
    //
    // show configuration
    //
    if (dwFlag & SHOW_CONFIG)
    {
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_CONFIG);

        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlStart);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPrintRasEnumDevices);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_RASENUM);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPrintProcessInfo);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_TLIST);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPrintConsoleUtils);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_CONSOLE);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlStart);
        PrintConsoleUtilsToc(pInfo->pBuff);
        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlEnd);

        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPrintAllRasPbks);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
        BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_RASPBK);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);

        if (pInfo->fVerbose)
        {
            BufferWriteFileStrW(pInfo->pBuff, g_pwszLiStart);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnStart);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszPrintWinMsdReport);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnMiddle);
            BufferWriteMessage(pInfo->pBuff, g_hModule, MSG_RASDIAG_REPORT_WINMSD);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnEnd);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszLiEnd);
        }

        BufferWriteFileStrW(pInfo->pBuff, c_pwszUlEnd);
    }

    BufferWriteFileStrW(pInfo->pBuff, c_pwszFieldEnd);

    return;
}

//
// 
//
VOID
PrintConsoleUtilsToc(
    IN BUFFER_WRITE_FILE* pBuff)
{
    UINT i;

    for (i = 0; i < g_ulNumCmdLines; i++)
    {
        BufferWriteFileStrW(pBuff, g_pwszLiStart);
        BufferWriteFileStrW(pBuff, g_pwszAnStart);
        BufferWriteFileStrW(pBuff, g_CmdLineUtils[i].pwszAnchor);
        BufferWriteFileStrW(pBuff, g_pwszAnMiddle);
        BufferWriteFileStrW(pBuff, g_CmdLineUtils[i].pwszCmdLine);
        BufferWriteFileStrW(pBuff, g_pwszAnEnd);
        BufferWriteFileStrW(pBuff, g_pwszLiEnd);
    }

    return;
}

//
// 
//
DWORD
RasDiagShowInstallation(
    IN REPORT_INFO* pInfo)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        //
        // RAS Inf files
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszPrintRasInfData,
            MSG_RASDIAG_REPORT_RASINF);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_RASINF);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_RASINF);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
        PrintRasInfData(pInfo->pBuff);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // Inetcfg Ras Verify
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszHrValidateRas,
            MSG_RASDIAG_REPORT_RASCHK);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_RASCHK);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_RASCHK);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
        HrValidateRas(pInfo->pBuff);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // Installed networking components
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszHrShowNetComponentsAll,
            MSG_RASDIAG_REPORT_NETINST);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_NETINST);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_NETINST);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
        HrShowNetComponentsAll(pInfo->pBuff);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // RAS Registry Keys
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszCheckRasRegistryKeys,
            MSG_RASDIAG_REPORT_RASREG);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_RASREG);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_RASREG);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
        PrintRasRegistryKeys(pInfo->pBuff);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);

    } while (FALSE);

    return dwErr;
}

//
// 
//
DWORD
RasDiagShowConfiguration(
    IN REPORT_INFO* pInfo)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        //
        // RAS Enum Devices
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszPrintRasEnumDevices,
            MSG_RASDIAG_REPORT_RASENUM);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_RASENUM);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_RASENUM);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
        PrintRasEnumDevices(pInfo->pBuff);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // Process information
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszPrintProcessInfo,
            MSG_RASDIAG_REPORT_TLIST);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_TLIST);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_TLIST);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
        PrintProcessInfo(pInfo->pBuff);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // Console utilities
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszPrintConsoleUtils,
            MSG_RASDIAG_REPORT_CONSOLE);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_CONSOLE);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_CONSOLE);
            BREAK_ON_DWERR(dwErr);
        }

        PrintConsoleUtils(pInfo);
        //
        // PBK Files
        //
        WriteHtmlSection(
            pInfo->pBuff,
            g_pwszPrintAllRasPbks,
            MSG_RASDIAG_REPORT_RASPBK);

        if (pInfo->fDisplay)
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_RASPBK);
            PrintMessage(g_pwszDispNewLine);
        }
        else if (pInfo->pCallback)
        {
            dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_RASPBK);
            BREAK_ON_DWERR(dwErr);
        }

        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
        PrintAllRasPbks(pInfo);
        BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        //
        // MS Info32 report
        //
        if (pInfo->fVerbose)
        {
            WriteHtmlSection(
                pInfo->pBuff,
                g_pwszPrintWinMsdReport,
                MSG_RASDIAG_REPORT_WINMSD);

            if (pInfo->fDisplay)
            {
                DisplayMessage(g_hModule, MSG_RASDIAG_REPORT_WINMSD);
                PrintMessage(g_pwszDispNewLine);
            }
            else if (pInfo->pCallback)
            {
                dwErr = CopyAndCallCB(pInfo, MSG_RASDIAG_REPORT_WINMSD);
                BREAK_ON_DWERR(dwErr);
            }

            BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
            PrintWinMsdReport(pInfo);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);
        }

    } while (FALSE);

    return dwErr;
}

//
// Write any existing WPP filenames out to the makecab ddf
//
CabCompressWppFileCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    PWCHAR pwszFile;
    WPP_LOG_INFO WppLog;
    BUFFER_WRITE_FILE* pBuff = (BUFFER_WRITE_FILE*)hData;

    do
    {
        if (!pBuff)
        {
            break;
        }

        ZeroMemory(&WppLog, sizeof(WPP_LOG_INFO));
        lstrcpyn(WppLog.wszSessionName, pszName, MAX_PATH + 1);

        if (!InitWppData(&WppLog))
        {
            break;
        }

        pwszFile = (PWCHAR )((PBYTE )WppLog.pProperties +
                        WppLog.pProperties->LogFileNameOffset);

        if (pwszFile[0] != L'\0')
        {
            BufferWriteFileStrWtoA(pBuff, pwszFile);
            BufferWriteFileStrWtoA(pBuff, g_pwszNewLine);
        }

    } while (FALSE);
    //
    // Clean up
    //
    CleanupWppData(&WppLog);

    return NO_ERROR;
}

//
// We want to CAB up the HTML report as well as any WPP tracing logs (which are
// not human readable in their native state). This can be done from the cmdline
// or from the UI (which gets attached to an email)
//
PWCHAR
CabCompressFile(
    IN LPCWSTR pwszFile)
{
    BOOL fEnabled = FALSE;
    DWORD dwRet, dwSize;
    WCHAR wszTemp[MAX_PATH + 1] = L"\0", wszCabFile[MAX_PATH + 1] = L"\0",
          wszDdf[MAX_PATH + 1] = L"\0";
    PWCHAR pwszReturn = NULL;
    BUFFER_WRITE_FILE Buff;

    static CONST WCHAR pwszCabExt[] = L".cab";

    do
    {
        if (!pwszFile || pwszFile[0] == L'\0')
        {
            break;
        }

        dwSize = (sizeof(wszTemp) / sizeof(WCHAR)) - lstrlen(pwszCabExt);

        dwRet = GetFullPathName(
                    pwszFile,
                    dwSize,
                    wszTemp,
                    NULL);
        if (!dwRet || dwRet > dwSize)
        {
            break;
        }
        //
        // Get the cab file's name
        //
        _snwprintf(
            wszCabFile,
            MAX_PATH,
            L"%s%s",
            wszTemp,
            pwszCabExt);
        //
        // Get a temp file to serve as our makecab DDF
        //
        if (CopyTempFileName(wszDdf))
        {
            break;
        }
        ZeroMemory(&Buff, sizeof(BUFFER_WRITE_FILE));
        //
        // Create the DDF file
        //
        Buff.hFile = CreateFile(
                        wszDdf,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
        if(Buff.hFile == INVALID_HANDLE_VALUE)
        {
            Buff.hFile = NULL;
            break;
        }
        else if (GetFileType(Buff.hFile) != FILE_TYPE_DISK)
        {
            break;
        }
        //
        // Wrap the file with a buffer write wrapper to make life easier
        //
        if (AllocBufferWriteFile(&Buff))
        {
            break;
        }
        //
        // Write out some stuff we know to the DDF file
        //
        {
            PWCHAR pwszCabFile = NULL, pEnd, pStart;

            pwszCabFile = RutlStrDup(wszCabFile);
            if (!pwszCabFile)
            {
                break;
            }

            pStart = pwszCabFile;
            pEnd = pStart + lstrlen(pStart);
            //
            // Rewind to the start of the filename
            //
            while(*pEnd != L'\\' && pEnd-- > pStart)
                ;
            //
            // Something went wrong on our file path to the cab file
            //
            if (pEnd <= pStart)
            {
                break;
            }

            *pEnd = L'\0';
            pEnd++;

            _snwprintf(
                wszTemp,
                MAX_PATH,
                L".set CabinetNameTemplate=%s",
                pEnd);

            BufferWriteFileStrWtoA(&Buff, wszTemp);
            BufferWriteFileStrWtoA(&Buff, g_pwszNewLine);

            _snwprintf(
                wszTemp,
                MAX_PATH,
                L".set DiskDirectoryTemplate=%s",
                pStart);

            BufferWriteFileStrWtoA(&Buff, wszTemp);
            BufferWriteFileStrWtoA(&Buff, g_pwszNewLine);

            BufferWriteFileStrWtoA(&Buff, L".set RptFileName=NUL");
            BufferWriteFileStrWtoA(&Buff, g_pwszNewLine);

            BufferWriteFileStrWtoA(&Buff, L".set InfFileName=NUL");
            BufferWriteFileStrWtoA(&Buff, g_pwszNewLine);

            RutlFree(pwszCabFile);
        }
        //
        // Before we move forward we need to know if tracing is enabled, based
        // on this we will re-enable it or not
        //
        fEnabled = DiagGetState();
        //
        // Disable all wpp tracing
        //
        TraceEnableDisableAllWpp(FALSE);
        //
        // Now we need to add the list of filenames to the DDF
        //
        BufferWriteFileStrWtoA(&Buff, pwszFile);
        BufferWriteFileStrWtoA(&Buff, g_pwszNewLine);

        EnumWppTracing(CabCompressWppFileCb, &Buff);
        //
        // Done writing to the file
        //
        FreeBufferWriteFile(&Buff);
        CloseHandle(Buff.hFile);
        Buff.hFile = NULL;
        //
        // Ok, the DDF file is cool, we now need to launch makecab
        //
        {
            DWORD dwErr;
            WCHAR wszCmdLine[MAX_PATH + 1] = L"\0";
            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            //
            // Create the create process cmdline
            //
            _snwprintf(
                wszCmdLine,
                MAX_PATH,
                L"makecab.exe /f %s",
                wszDdf);
            //
            // Init the create process stuff
            //
            ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
            ZeroMemory(&si, sizeof(STARTUPINFO));
            si.cb = sizeof(STARTUPINFO);
            si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
            si.wShowWindow = SW_HIDE;
            //
            // Compress baby
            //
            if (!CreateProcess(
                    NULL,
                    wszCmdLine,
                    NULL,
                    NULL,
                    TRUE,
                    0,
                    NULL,
                    NULL,
                    &si,
                    &pi)
               )
            {
                break;
            }
            //
            // Wait until the cows come home
            //
            WaitForSingleObject(pi.hProcess, INFINITE);
            GetExitCodeProcess(pi.hProcess, &dwErr);
            //
            // Clean up
            //
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            //
            // Whack the ddf
            //
            DeleteFile(wszDdf);
            //
            // Figure out if we have reached the success nirvana state
            //
            if (!dwErr)
            {
                //
                // Makecab returned success, create a copy of the cab file name
                //
                pwszReturn = RutlStrDup(wszCabFile);
            }
            else
            {
                //
                // If cab was somehow written, kill it
                //
                DeleteFile(wszCabFile);
                break;
            }
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (Buff.hFile)
    {
        FreeBufferWriteFile(&Buff);
        CloseHandle(Buff.hFile);
    }
    if (fEnabled)
    {
        //
        // We need to re-enable wpp tracing
        //
        TraceEnableDisableAllWpp(TRUE);
    }

    return pwszReturn;
}

DWORD
MapiSendMail(
    IN LPCWSTR pwszEmailAdr,
    IN LPCWSTR pwszTempFile)
{
    DWORD dwErr = NO_ERROR;
    PCHAR pszEmailAdr = NULL, pszTempFile = NULL, pszTitle = NULL;
    PWCHAR pwszTitle = NULL;
    HINSTANCE hInst = NULL;
    LPMAPISENDMAIL pSend = NULL;

    static CONST WCHAR pwszMAPI[] = L"mapi32.dll";
    static CONST CHAR pszSndMail[] = "MAPISendMail";

    MapiFileDesc attachment =
    {
        0,                  // ulReserved, must be 0
        0,                  // no flags; this is a data file
        (ULONG)-1,          // position not specified
        NULL,
        NULL,
        NULL                // MapiFileTagExt unused
    };

    MapiRecipDesc recips =
    {
        0,                   // reserved
        MAPI_TO,             // class
        NULL,
        NULL,
        0,                   // entry id size
        NULL                 // entry id
    };

    MapiMessage note =
    {
        0,          // reserved, must be 0
        NULL,       // subject
        NULL,       // Body
        NULL,       // NULL = interpersonal message
        NULL,       // no date; MAPISendMail ignores it
        NULL,       // no conversation ID
        0L,         // no flags, MAPISendMail ignores it
        NULL,       // no originator, this is ignored too
        1,          // 1 recipients
        &recips,    // recipient array
        1,          // one attachment
        &attachment // the attachment
    };

    do
    {
        if (!pwszEmailAdr || !pwszTempFile)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        pszTempFile = RutlStrDupAFromWAnsi(pwszTempFile);
        if (!pszTempFile)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        attachment.lpszPathName = pszTempFile;

        pszEmailAdr = RutlStrDupAFromWAnsi(pwszEmailAdr);
        if (!pszEmailAdr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        recips.lpszName = pszEmailAdr;

        pwszTitle = LoadStringFromHinst(g_hModule, MSG_RASDIAG_REPORT_TITLE);
        if (!pwszTitle)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pszTitle = RutlStrDupAFromWAnsi(pwszTitle);
        if (!pszTitle)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        note.lpszSubject = pszTitle;
        note.lpszNoteText = pszTitle;

        hInst = LoadLibrary(pwszMAPI);
        if (!hInst)
        {
            dwErr = GetLastError();
            break;
        }

        pSend = (LPMAPISENDMAIL) GetProcAddress(hInst, pszSndMail);
        if (!pSend)
        {
            dwErr = GetLastError();
            break;
        }

        dwErr = pSend(
                    0L,    // use implicit session.
                    0L,    // ulUIParam; 0 is always valid
                    &note, // the message being sent
                    0,     // allow the user to edit the message
                    0L);   // reserved; must be 0

    } while (FALSE);
    //
    // Clean up
    //
    if (hInst)
    {
        FreeLibrary(hInst);
    }
    RutlFree(pszTitle);
    FreeStringFromHinst(pwszTitle);
    RutlFree(pszTempFile);
    RutlFree(pszEmailAdr);

    return dwErr;
}

//
// 
//
BOOL
GetCommonFolderPath(
    IN DWORD dwMode,
    OUT TCHAR* pszPathBuf)
{
    BOOL bSuccess = FALSE;
    UINT cch;
    HANDLE hToken = NULL;

    if ((OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY | TOKEN_IMPERSONATE,
            TRUE,
            &hToken) ||
         OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_IMPERSONATE,
            &hToken)))
    {
        HRESULT hr;
        INT csidl = CSIDL_APPDATA;

        if (dwMode & ALL_USERS_PROF)
        {
            csidl = CSIDL_COMMON_APPDATA;
        }
        else if (dwMode & GET_FOR_MSINFO)
        {
            csidl = CSIDL_PROGRAM_FILES;
        }

        hr = SHGetFolderPath(NULL, csidl, hToken, 0, pszPathBuf);
        if (SUCCEEDED(hr))
        {
            if (dwMode & GET_FOR_RAS)
            {
                if(lstrlen(pszPathBuf) <= (MAX_PATH - lstrlen(g_pwszRasUser)))
                {
                    lstrcat(pszPathBuf, g_pwszRasUser);
                    bSuccess = TRUE;
                }
            }
            else if (dwMode & GET_FOR_CM)
            {
                if(lstrlen(pszPathBuf) <= (MAX_PATH - lstrlen(g_pwszCmUser)))
                {
                    lstrcat(pszPathBuf, g_pwszCmUser);
                    bSuccess = TRUE;
                }
            }
            else if (dwMode & GET_FOR_MSINFO)
            {
                if(lstrlen(pszPathBuf) <= (MAX_PATH - lstrlen(g_pwszMsinfo)))
                {
                    lstrcat(pszPathBuf, g_pwszMsinfo);
                    bSuccess = TRUE;
                }
            }
        }

        CloseHandle(hToken);
    }

    return bSuccess;
}

//
// String must appear as 00:00:00\0
//
LONG
ProcessTimeString(
    IN PCHAR pszTime,
    IN DWORD dwHours)
{
    UINT ulFound = 0, ulLoop = 0;
    PCHAR pszStart, pszCurrent;
    WORD wHours = (WORD)dwHours;
    FILETIME ft1, ft2;
    SYSTEMTIME st1, st2;

    GetLocalTime(&st1);
    CopyMemory(&st2, &st1, sizeof(SYSTEMTIME));

    pszStart = pszCurrent = pszTime;

    while (ulLoop++ <= 8)
    {
        if (*pszCurrent == g_pwszNull)
        {
            st1.wSecond = (WORD)atoi(pszStart);
            break;
        }
        else if (*pszCurrent == ':')
        {
            *pszCurrent = '\0';

            if (ulFound++ == 0)
            {
                st1.wHour = (WORD)atoi(pszStart);
            }
            else
            {
                st1.wMinute = (WORD)atoi(pszStart);
            }

            pszStart = ++pszCurrent;
            continue;
        }

        pszCurrent++;
    }

    SystemTimeToFileTime(&st1, &ft1);
    //
    // Get the time from the past
    //
    if (st1.wHour > st2.wHour)
    {
        if ((st2.wHour - wHours) >= 0)
        {
            st2.wHour -= wHours;
            SystemTimeToFileTime(&st2, &ft2);
            return CompareFileTime(&ft2,&ft1);
        }
        else
        {
            st2.wHour = 24 + (st2.wHour - wHours);
            SystemTimeToFileTime(&st2, &ft2);
            return CompareFileTime(&ft1, &ft2);
        }
    }
    else
    {
        if ((st2.wHour - wHours) >= 0)
        {
            st2.wHour -= wHours;
            SystemTimeToFileTime(&st2, &ft2);
            return CompareFileTime(&ft1, &ft2);
        }
        else
        {
            st2.wHour = 24 + (st2.wHour - wHours);
            SystemTimeToFileTime(&st2, &ft2);
            return CompareFileTime(&ft2,&ft1);
        }
    }
}

BOOL
CALLBACK
EnumWindowsProc(
    HWND hwnd,
    LPARAM lParam)
{
    DWORD dwPid = 0, i, dwNumTasks;
    WCHAR szBuf[TITLE_SIZE + 1];
    PTASK_LIST_ENUM te = (PTASK_LIST_ENUM)lParam;
    PTASK_LIST tlist = te->tlist;

    dwNumTasks = te->dwNumTasks;
    //
    // Use try/except block when enumerating windows,
    // as a window may be destroyed by another thread
    // when being enumerated.
    //
    try {
        //
        // get the processid for this window
        //
        if (!GetWindowThreadProcessId(hwnd, &dwPid))
        {
            return TRUE;
        }

        if ((GetWindow(hwnd, GW_OWNER)) ||
            (!(GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE)) && te->bFirstLoop)
        {
            //
            // not a top level window
            //
            return TRUE;
        }
        //
        // look for the task in the task list for this window
        // If this is the second time let invisible windows through if we don't
        // have a window already
        //
        for (i = 0; i < dwNumTasks; i++)
        {
            if ((tlist[i].dwProcessId == dwPid) &&
                (te->bFirstLoop || (tlist[i].hwnd == 0))
               )
            {
                tlist[i].hwnd = hwnd;
                tlist[i].lpszWinSta = te->lpszWinSta;
                tlist[i].lpszDesk = te->lpszDesk;
                //
                // we found the task now lets try to get the window text
                //
                if (GetWindowText(tlist[i].hwnd, szBuf, TITLE_SIZE))
                {
                    //
                    // got it, so lets save it
                    //
                    lstrcpy(tlist[i].szWindowTitle, szBuf);
                }

                break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER){}
    //
    // continue the enumeration
    //
    return TRUE;
}

BOOL
EnumMessageWindows(
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam)
{
    HWND hwnd = NULL;

    do
    {
        hwnd = FindWindowEx(HWND_MESSAGE, hwnd, NULL, NULL);
        if (hwnd)
        {
            if (!(*lpEnumFunc)(hwnd, lParam))
            {
                break;
            }
        }

    } while (hwnd);

    return TRUE;
}

BOOL
CALLBACK
EnumDesktopProc(
    LPTSTR lpszDesktop,
    LPARAM lParam)
{
    BOOL bRetValue = FALSE;
    HDESK hDesk = NULL, hDeskSave = NULL;
    PTASK_LIST_ENUM te = (PTASK_LIST_ENUM)lParam;

    do
    {
        //
        // open the desktop
        //
        hDesk = OpenDesktop(lpszDesktop, 0, FALSE, MAXIMUM_ALLOWED);
        if (!hDesk)
        {
            break;
        }
        //
        // save the current desktop
        //
        hDeskSave = GetThreadDesktop(GetCurrentThreadId());
        //
        // change the context to the new desktop
        //
        SetThreadDesktop(hDesk);

        te->lpszDesk = RutlStrDup(lpszDesktop);
        if (!(te->lpszDesk))
        {
            break;
        }
        //
        // enumerate all windows in the new desktop
        //
        te->bFirstLoop = TRUE;
        EnumWindows((WNDENUMPROC)EnumWindowsProc, lParam);
        EnumMessageWindows((WNDENUMPROC)EnumWindowsProc, lParam);

        te->bFirstLoop = FALSE;
        EnumWindows((WNDENUMPROC)EnumWindowsProc, lParam);
        EnumMessageWindows((WNDENUMPROC)EnumWindowsProc, lParam);
        //
        // restore the previous desktop
        //
        if (hDesk != hDeskSave)
        {
            SetThreadDesktop(hDeskSave);
            CloseDesktop(hDesk);
            hDesk = NULL;
        }

        bRetValue = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    if (hDesk)
    {
        CloseDesktop(hDesk);
    }

    return bRetValue;
}

BOOL
CALLBACK
EnumWindowStationProc(
    LPTSTR lpszWindowStation,
    LPARAM lParam)
{
    BOOL bRetValue = FALSE;
    HWINSTA hWinSta = NULL, hWinStaSave = NULL;
    PTASK_LIST_ENUM te = (PTASK_LIST_ENUM)lParam;

    do
    {
        //
        // open the windowstation
        //
        hWinSta = OpenWindowStation(lpszWindowStation, FALSE, MAXIMUM_ALLOWED);
        if (!hWinSta)
        {
            break;
        }
        //
        // save the current windowstation
        //
        hWinStaSave = GetProcessWindowStation();
        //
        // change the context to the new windowstation
        //
        SetProcessWindowStation(hWinSta);

        te->lpszWinSta = RutlStrDup(lpszWindowStation);
        if (!(te->lpszWinSta))
        {
            break;
        }
        //
        // enumerate all the desktops for this windowstation
        //
        EnumDesktops(hWinSta, EnumDesktopProc, lParam);
        //
        // restore the context to the previous windowstation
        //
        if (hWinSta != hWinStaSave)
        {
            SetProcessWindowStation(hWinStaSave);
            CloseWindowStation(hWinSta);
            hWinSta = NULL;
        }
        //
        // continue the enumeration
        //
        bRetValue = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    if (hWinSta)
    {
        CloseWindowStation(hWinSta);
    }

    return bRetValue;
}

VOID
GetWindowTitles(
    PTASK_LIST_ENUM te)
{
    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    EnumWindowStations(EnumWindowStationProc, (LPARAM)te);
}

VOID
PrintRasInfData(
    IN BUFFER_WRITE_FILE* pBuff)
{
    BOOL fOk = FALSE;
    UINT i, uiWindirLen;
    WCHAR wszWindir[MAX_PATH + 1];

    static CONST PWCHAR c_pwszRasInfs[] =
    {
        L"\\inf\\netrasa.inf",
        L"\\inf\\netrass.inf",
        L"\\inf\\netrast.inf"
    };

    static CONST UINT c_ulNumRasInfs = sizeof(c_pwszRasInfs) / sizeof(PWCHAR);

    do
    {
        if (!GetSystemWindowsDirectory(wszWindir, MAX_PATH))
        {
            break;
        }

        uiWindirLen = lstrlen(wszWindir);
        if (!uiWindirLen)
        {
            break;
        }

        for (i = 0; i < c_ulNumRasInfs; i++)
        {
            UINT uiInfLen = lstrlen(c_pwszRasInfs[i]);
            WCHAR wszInfPath[MAX_PATH + 1];
            FILETIME ftLastWrite, ftCreation;
            SYSTEMTIME stLastWrite, stCreation;
            WIN32_FILE_ATTRIBUTE_DATA attr;

            if ((!uiInfLen) || ((uiWindirLen + uiInfLen) > MAX_PATH))
            {
                break;
            }

            lstrcpy(wszInfPath, wszWindir);
            lstrcat(wszInfPath, c_pwszRasInfs[i]);

            ZeroMemory(&attr, sizeof(attr));
            if (!GetFileAttributesEx(wszInfPath, GetFileExInfoStandard, &attr)
               || !FileTimeToLocalFileTime(&attr.ftLastWriteTime, &ftLastWrite)
               || !FileTimeToSystemTime(&ftLastWrite, &stLastWrite)
               || !FileTimeToLocalFileTime(&attr.ftCreationTime, &ftCreation)
               || !FileTimeToSystemTime(&ftCreation, &stCreation))
            {
                break;
            }

            BufferWriteMessage(
                pBuff,
                g_hModule,
                MSG_RASDIAG_SHOW_RASCHK_FILE,
                wszInfPath,
                stLastWrite.wMonth,
                stLastWrite.wDay,
                stLastWrite.wYear,
                stLastWrite.wHour,
                stLastWrite.wMinute,
                stCreation.wMonth,
                stCreation.wDay,
                stCreation.wYear,
                stCreation.wHour,
                stCreation.wMinute,
                attr.nFileSizeLow);

            fOk = TRUE;
        }

    } while (FALSE);

    if (!fOk)
    {
        BufferWriteMessage(pBuff, g_hModule, EMSG_RASDIAG_SHOW_RASCHK_FILE);
    }

    return;
}

VOID
PrintRasEnumDevices(
    IN BUFFER_WRITE_FILE* pBuff)
{
    BOOL fOk = FALSE;
    DWORD dwErr = NO_ERROR, dwBytes, dwDevices, i;
    LPRASDEVINFO pRdi = NULL;

    do
    {
        dwErr = RasEnumDevices(pRdi, &dwBytes, &dwDevices);
        if ((dwErr != ERROR_BUFFER_TOO_SMALL) ||
            (dwBytes < 1))
        {
            break;
        }

        pRdi = RutlAlloc(dwBytes, TRUE);
        if (!pRdi)
        {
            break;
        }

        pRdi->dwSize = sizeof(RASDEVINFO);

        dwErr = RasEnumDevices(pRdi, &dwBytes, &dwDevices);
        if (dwErr || !dwDevices)
        {
            break;
        }

        for(i = 0; i < dwDevices; i++)
        {
            BufferWriteMessage(
                pBuff,
                g_hModule,
                MSG_RASDIAG_SHOW_CONFIG_RASENUM,
                i+ 1,
                pRdi[i].szDeviceName,
                pRdi[i].szDeviceType);
        }

        fOk = TRUE;

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pRdi);

    if (!fOk)
    {
        BufferWriteMessage(pBuff, g_hModule, EMSG_RASDIAG_SHOW_CONFIG_RASENUM);
    }

    return;
}

VOID
PrintProcessInfo(
    IN BUFFER_WRITE_FILE* pBuff)
{
    BOOL fOk = FALSE;
    DWORD dwErr = NO_ERROR, dwNumServices, dwResume = 0;
    UINT ulAttempts = 0, ulNumSysProc, i;
    ULONG uBuffSize = 2 * 1024, TotalOffset;
    PBYTE lpByte = NULL;
    SC_HANDLE hScm = NULL;
    PTASK_LIST pt = NULL;
    TASK_LIST_ENUM te;
    PSYSTEM_PROCESS_INFORMATION pFirst, pCurrent;
    LPENUM_SERVICE_STATUS_PROCESS pInfo = NULL;

    CONST PWCHAR c_pwszSystem = L"System Process";
    CONST PWCHAR c_pwszService = L"Svcs";
    CONST PWCHAR c_pwszTitle = L"Title";

    do
    {
        hScm = OpenSCManager(
                    NULL,
                    NULL,
                    SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
        if (!hScm)
        {
            break;
        }

        do
        {
            RutlFree(pInfo);
            pInfo = NULL;

            pInfo = RutlAlloc(uBuffSize, TRUE);
            if (!pInfo)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwErr = NO_ERROR;
            if (!EnumServicesStatusEx(
                    hScm,
                    SC_ENUM_PROCESS_INFO,
                    SERVICE_WIN32,
                    SERVICE_ACTIVE,
                    (LPBYTE)pInfo,
                    uBuffSize,
                    &uBuffSize,
                    &dwNumServices,
                    &dwResume,
                    NULL))
            {
                dwErr = GetLastError();
            }

        } while ((ERROR_MORE_DATA == dwErr) && (++ulAttempts < 2));

        if (dwErr || dwNumServices < 1)
        {
            break;
        }

        lpByte = GetSystemProcessInfo();
        if (!lpByte)
        {
            break;
        }
        //
        // Count the number of System Proccesses
        //
        pFirst = pCurrent = (PSYSTEM_PROCESS_INFORMATION)&lpByte[0];

        for (ulNumSysProc = TotalOffset = 0; pCurrent->NextEntryOffset;
             TotalOffset += pCurrent->NextEntryOffset)
        {
            pCurrent = (PSYSTEM_PROCESS_INFORMATION)&lpByte[TotalOffset];
            ulNumSysProc++;
        }

        pt = RutlAlloc(ulNumSysProc * sizeof(TASK_LIST), TRUE);
        if (!pt)
        {
            break;
        }
        //
        // Init TASK_LIST
        //
        pFirst = pCurrent = (PSYSTEM_PROCESS_INFORMATION)&lpByte[0];

        for (i = TotalOffset = 0; pCurrent->NextEntryOffset;
             TotalOffset += pCurrent->NextEntryOffset)
        {
            pCurrent = (PSYSTEM_PROCESS_INFORMATION)&lpByte[TotalOffset];
            pt[i++].dwProcessId = PtrToUlong(pCurrent->UniqueProcessId);
        }

        te.tlist = pt;
        te.dwNumTasks = ulNumSysProc;
        GetWindowTitles(&te);

        pFirst = pCurrent = (PSYSTEM_PROCESS_INFORMATION)&lpByte[0];

        for (TotalOffset = 0; pCurrent->NextEntryOffset;
             TotalOffset += pCurrent->NextEntryOffset)
        {
            BOOL bPrinted = FALSE;
            DWORD dwCurrentPid;

            fOk = TRUE;
            pCurrent = (PSYSTEM_PROCESS_INFORMATION)&lpByte[TotalOffset];
            dwCurrentPid = PtrToUlong(pCurrent->UniqueProcessId);

            BufferWriteMessage(
                pBuff,
                g_hModule,
                MSG_RASDIAG_SHOW_PROCESS,
                dwCurrentPid,
                pCurrent->ImageName.Buffer ?
                    pCurrent->ImageName.Buffer : c_pwszSystem);

            for (i = 0; i < dwNumServices; i++)
            {
                if(pInfo[i].ServiceStatusProcess.dwProcessId == dwCurrentPid)
                {
                    if (!bPrinted)
                    {
                        BufferWriteMessage(
                            pBuff,
                            g_hModule,
                            MSG_RASDIAG_SHOW_PROCESS_TITLE,
                            c_pwszService,
                            pInfo[i].lpServiceName);
                        bPrinted = TRUE;
                    }
                    else
                    {
                        BufferWriteMessage(
                            pBuff,
                            g_hModule,
                            MSG_RASDIAG_SHOW_PROCESS_SVCNAME,
                            pInfo[i].lpServiceName);
                    }
                }
            }

            if (bPrinted)
            {
                WriteNewLine(pBuff);
                continue;
            }

            for (i = 0; i < te.dwNumTasks; i++)
            {
                if(((te.tlist)[i].dwProcessId == dwCurrentPid)
                    && (te.tlist)[i].hwnd)
                {
                    BufferWriteMessage(
                        pBuff,
                        g_hModule,
                        MSG_RASDIAG_SHOW_PROCESS_TITLE,
                        c_pwszTitle,
                        (te.tlist)[i].szWindowTitle);
                    WriteNewLine(pBuff);
                    bPrinted = TRUE;
                }
            }

            if (!bPrinted)
            {
                WriteNewLine(pBuff);
            }
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pt);
    RutlFree(te.lpszWinSta);
    RutlFree(te.lpszDesk);
    FreeSystemProcessInfo(lpByte);
    RutlFree(pInfo);

    if (hScm)
    {
        CloseServiceHandle(hScm);
    }
    if (!fOk)
    {
        BufferWriteMessage(pBuff, g_hModule, EMSG_RASDIAG_SHOW_CONFIG_PROC);
    }

    return;
}

VOID
PrintConsoleUtils(
    IN REPORT_INFO* pInfo)
{
    UINT i;
    DWORD dwWritten;
    WCHAR wszTempBuffer[MAX_PATH + 1], wszTempFileName[MAX_PATH + 1];
    HANDLE hFile = NULL;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    do
    {
        ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
        ZeroMemory(&si, sizeof(STARTUPINFO));
        si.cb = sizeof(STARTUPINFO);
        si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
        si.wShowWindow = SW_HIDE;

        if (CopyTempFileName(wszTempFileName))
        {
            break;
        }

        hFile = CreateFile(
                    wszTempFileName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_TEMPORARY,
                    NULL);
        if(hFile == INVALID_HANDLE_VALUE)
        {
            break;
        }

        if (!DuplicateHandle(
                GetCurrentProcess(),
                hFile,
                GetCurrentProcess(),
                &si.hStdOutput,
                0,
                TRUE,
                DUPLICATE_SAME_ACCESS) ||
            (!(si.hStdOutput)) || (si.hStdOutput == INVALID_HANDLE_VALUE)
           )
        {
            break;
        }

        for (i = 0; i < g_ulNumCmdLines; i++)
        {
            lstrcpyn(wszTempBuffer, g_CmdLineUtils[i].pwszCmdLine, MAX_PATH);

            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnNameStart);
            BufferWriteFileStrW(pInfo->pBuff, g_CmdLineUtils[i].pwszAnchor);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnNameMiddle);
            BufferWriteFileStrW(pInfo->pBuff, wszTempBuffer);
            WriteLinkBackToToc(pInfo->pBuff);
            BufferWriteFileStrW(pInfo->pBuff, g_pwszAnNameEnd);

            if (!CreateProcess(
                    NULL,
                    wszTempBuffer,
                    NULL,
                    NULL,
                    TRUE,
                    0,
                    NULL,
                    NULL,
                    &si,
                    &pi)
               )
            {
                continue;
            }

            BufferWriteFileStrW(pInfo->pBuff, g_pwszPreStart);
            //
            // let the util work for up to 1 min, then kill it
            //
            if (WAIT_TIMEOUT == WaitForSingleObject(pi.hProcess, 60 * 1000L))
            {
                TerminateProcess(pi.hProcess, 0);
                BufferWriteMessage(
                    pInfo->pBuff,
                    g_hModule,
                    EMSG_RASDIAG_SHOW_CONFIG_CONSOLE_TIMOUT);
            }
            else if (PrintFile(pInfo, wszTempFileName, FALSE, NULL))
            {
                BufferWriteMessage(
                    pInfo->pBuff,
                    g_hModule,
                    EMSG_RASDIAG_SHOW_CONFIG_CONSOLE);
            }

            BufferWriteFileStrW(pInfo->pBuff, g_pwszPreEnd);

            SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
            SetEndOfFile(hFile);

            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }

        CloseHandle(si.hStdOutput);
        CloseHandle(hFile);
        si.hStdOutput = hFile = NULL;
        //
        // Delete the temp file
        //
        DeleteFile(wszTempFileName);

    } while (FALSE);
    //
    // Clean up
    //
    if (si.hStdOutput)
    {
        CloseHandle(si.hStdOutput);
    }
    if (hFile)
    {
        CloseHandle(hFile);
    }

    return;
}

VOID
PrintWinMsdReport(
    IN REPORT_INFO* pInfo)
{
    BOOL fOk = FALSE;
    DWORD dwSize = 0;
    WCHAR wszInfoPath[MAX_PATH + 1], wszTempFileName[MAX_PATH + 1];
    PWCHAR pwszCmdLine = NULL;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    static CONST PWCHAR c_pwszWinMsd = L"msinfo32.exe /report ";

    do
    {
        if (!GetCommonFolderPath(GET_FOR_MSINFO, wszInfoPath))
        {
            break;
        }

        if (CopyTempFileName(wszTempFileName))
        {
            break;
        }

        dwSize = lstrlen(wszInfoPath) + lstrlen(c_pwszWinMsd) +
                 lstrlen(wszTempFileName) + 1;

        pwszCmdLine = RutlAlloc(dwSize * sizeof(WCHAR), TRUE);
        if (!pwszCmdLine)
        {
            break;
        }

        lstrcpy(pwszCmdLine, wszInfoPath);
        lstrcat(pwszCmdLine, c_pwszWinMsd);
        lstrcat(pwszCmdLine, wszTempFileName);

        ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
        ZeroMemory(&si, sizeof(STARTUPINFO));
        si.cb = sizeof(STARTUPINFO);
        si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
        si.wShowWindow = SW_HIDE;

        if (!CreateProcess(
                NULL,
                pwszCmdLine,
                NULL,
                NULL,
                TRUE,
                0,
                NULL,
                NULL,
                &si,
                &pi)
           )
        {
            break;
        }
        //
        // let the util work for up to 3 min, then kill it
        //
        if (WAIT_TIMEOUT == WaitForSingleObject(pi.hProcess, 180 * 1000L))
        {
            TerminateProcess(pi.hProcess, 0);
        }

        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);

        if (!PrintFile(pInfo, wszTempFileName, FALSE, NULL))
        {
            fOk = TRUE;
        }

        DeleteFile(wszTempFileName);

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszCmdLine);

    if (!fOk)
    {
        BufferWriteMessage(
            pInfo->pBuff,
            g_hModule,
            EMSG_RASDIAG_SHOW_CONFIG_WINMSD);
    }

    return;
}

BOOL
PrintRasPbk(
    IN REPORT_INFO* pInfo,
    IN DWORD dwType)
{
    BOOL fOk = FALSE;
    DWORD dwSize = 0;
    WCHAR wszTemp[MAX_PATH + 1];
    PWCHAR pwszFilePath = NULL;

    static CONST PWCHAR c_pwszRasphone = L"rasphone.pbk";

    do
    {
        if (!GetCommonFolderPath(dwType | GET_FOR_RAS, wszTemp))
        {
            break;
        }

        dwSize = lstrlen(wszTemp) + lstrlen(c_pwszRasphone) + 1;

        pwszFilePath = RutlAlloc(dwSize * sizeof(WCHAR), TRUE);
        if (!pwszFilePath)
        {
            break;
        }

        lstrcpy(pwszFilePath, wszTemp);
        lstrcat(pwszFilePath, c_pwszRasphone);

        if (!PrintFile(pInfo, pwszFilePath, TRUE, NULL))
        {
            fOk = TRUE;
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszFilePath);

    return fOk;
}

VOID
PrintAllRasPbks(
    IN REPORT_INFO* pInfo)
{
    BOOL fOk = FALSE;

    if (PrintRasPbk(pInfo, ALL_USERS_PROF))
    {
        fOk = TRUE;
    }

    if (PrintRasPbk(pInfo, CURRENT_USER))
    {
        fOk = TRUE;
    }

    if (!fOk)
    {
        BufferWriteMessage(
            pInfo->pBuff,
            g_hModule,
            EMSG_RASDIAG_SHOW_CONFIG_ALLPBK);
    }

    return;
}
//
// Return a block containing information about all processes
// currently running in the system.
//
PUCHAR
GetSystemProcessInfo()
{
    ULONG ulcbLargeBuffer = 64 * 1024;
    PUCHAR pLargeBuffer;
    NTSTATUS status;

    //
    // Get the process list.
    //
    for (;;)
    {
        pLargeBuffer = VirtualAlloc(
                         NULL,
                         ulcbLargeBuffer, MEM_COMMIT, PAGE_READWRITE);
        if (pLargeBuffer == NULL)
        {
            return NULL;
        }

        status = NtQuerySystemInformation(
                   SystemProcessInformation,
                   pLargeBuffer,
                   ulcbLargeBuffer,
                   NULL);
        if (status == STATUS_SUCCESS)
        {
            break;
        }
        if (status == STATUS_INFO_LENGTH_MISMATCH)
        {
            VirtualFree(pLargeBuffer, 0, MEM_RELEASE);
            ulcbLargeBuffer += 8192;
        }
    }

    return pLargeBuffer;
}

VOID
FreeSystemProcessInfo(
    IN PUCHAR pProcessInfo)
{
    if (pProcessInfo)
    {
        VirtualFree(pProcessInfo, 0, MEM_RELEASE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasaaaa.c ===
/*
    File:   rasaaaa.h
    
    The 'remoteaccess aaaa' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasaaaa.h"
#include <winsock2.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// The guid for this context
//
GUID g_RasAaaaGuid = RASAAAA_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// Stolen from snapin code
//
#define CCHRADIUSSERVER		13 
#define	PSZRADIUSSERVER		L"RADIUSServer."


// The commands supported in this context
//
CMD_ENTRY  g_RasAaaaAddCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAAAA_ADD_AUTHSERV, RasAaaaHandleAddAuthServ),
    CREATE_CMD_ENTRY(RASAAAA_ADD_ACCTSERV, RasAaaaHandleAddAcctServ),
};

CMD_ENTRY  g_RasAaaaDelCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAAAA_DEL_AUTHSERV, RasAaaaHandleDelAuthServ),
    CREATE_CMD_ENTRY(RASAAAA_DEL_ACCTSERV, RasAaaaHandleDelAcctServ),
};

CMD_ENTRY  g_RasAaaaSetCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAAAA_SET_AUTH, RasAaaaHandleSetAuth),
    CREATE_CMD_ENTRY(RASAAAA_SET_ACCT, RasAaaaHandleSetAcct),
    CREATE_CMD_ENTRY(RASAAAA_SET_AUTHSERV, RasAaaaHandleSetAuthServ),
    CREATE_CMD_ENTRY(RASAAAA_SET_ACCTSERV, RasAaaaHandleSetAcctServ),
};

CMD_ENTRY  g_RasAaaaShowCmdTable[] = 
{
    CREATE_CMD_ENTRY(RASAAAA_SHOW_AUTH,     RasAaaaHandleShowAuth),
    CREATE_CMD_ENTRY(RASAAAA_SHOW_ACCT,     RasAaaaHandleShowAcct),
    CREATE_CMD_ENTRY(RASAAAA_SHOW_AUTHSERV, RasAaaaHandleShowAuthServ),
    CREATE_CMD_ENTRY(RASAAAA_SHOW_ACCTSERV, RasAaaaHandleShowAcctServ),
};

CMD_GROUP_ENTRY g_RasAaaaCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,     g_RasAaaaSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,    g_RasAaaaShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,     g_RasAaaaAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DEL,     g_RasAaaaDelCmdTable),
};

ULONG g_ulRasAaaaNumGroups = sizeof(g_RasAaaaCmdGroups)/sizeof(CMD_GROUP_ENTRY);

// 
// Registry strings
//
WCHAR pszRegKeyAuth[] = 
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\Providers";
WCHAR pszRegKeyAcct[] = 
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Accounting\\Providers";

WCHAR pszGuidWinAuth[] = L"{1AA7F841-C7F5-11D0-A376-00C04FC9DA04}";
WCHAR pszGuidRadAuth[] = L"{1AA7F83F-C7F5-11D0-A376-00C04FC9DA04}";

WCHAR pszGuidWinAcct[] = L"{1AA7F846-C7F5-11D0-A376-00C04FC9DA04}";   
WCHAR pszGuidRadAcct[] = L"{1AA7F840-C7F5-11D0-A376-00C04FC9DA04}";

WCHAR pszRegValActiveProvider[] = L"ActiveProvider";
WCHAR pszRegKeyServers[]        = L"Servers";

WCHAR pszRegValAuthPort[]       = L"AuthPort";
WCHAR pszRegValAcctPort[]       = L"AcctPort";
WCHAR pszRegValMessage[]        = L"EnableAccountingOnOff";
WCHAR pszRegValScore[]          = L"Score";
WCHAR pszRegValTimeout[]        = L"Timeout";
WCHAR pszRegValSignature[]      = L"SendSignature";

//
// Local definitions
//
#define RASAAAA_Auth        0x1
#define RASAAAA_Acct        0x2
#define RASAAAA_Windows     0x10
#define RASAAAA_Radius      0x20
#define RASAAAA_None        0x40

#define RASAAAA_F_Provider  0x1
#define RASAAAA_F_Create    0x2

//
// Structures representing auth/acct servers
//
typedef struct _AAAA_AUTH_SERVER
{
    PWCHAR pszName;
    PWCHAR pszSecret;
    DWORD dwScore;
    DWORD dwPort;
    DWORD dwTimeout;
    DWORD dwSignature;
    
} RASAAAA_AUTH_SERVER;

typedef struct _AAAA_ACCT_SERVER
{
    PWCHAR pszName;
    PWCHAR pszSecret;
    DWORD dwScore;
    DWORD dwPort;
    DWORD dwTimeout;
    DWORD dwMessages;
    
} RASAAAA_ACCT_SERVER;

typedef
DWORD
(* RASAAAA_SERVER_ENUM_CB)(
    IN PVOID pvServer,
    IN HANDLE hData);

typedef struct _AAAA_ENUM_DATA
{
    DWORD dwType;
    HANDLE hData;
    RASAAAA_SERVER_ENUM_CB pEnum;
    
} RASAAAA_ENUM_DATA;


TOKEN_VALUE g_rgEnumEnableDisable[] = 
{ 
    {TOKEN_ENABLED,     1}, 
    {TOKEN_DISABLED,    0} 
};
RASMON_CMD_ARG  g_pArgsAuth[] = 
{
    { 
        RASMONTR_CMD_TYPE_STRING, 
        {TOKEN_NAME,    TRUE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_STRING, 
        {TOKEN_SECRET,  FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_INITSCORE, FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_PORT,   FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_TIMEOUT, FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_ENUM, 
        {TOKEN_SIGNATURE,    FALSE, FALSE},
        g_rgEnumEnableDisable, 
        sizeof(g_rgEnumEnableDisable)/sizeof(*g_rgEnumEnableDisable), 
        NULL 
    }
};        

RASMON_CMD_ARG  g_pArgsAcct[] = 
{
    { 
        RASMONTR_CMD_TYPE_STRING, 
        {TOKEN_NAME,    TRUE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_STRING, 
        {TOKEN_SECRET,  FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_INITSCORE, FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_PORT,   FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_DWORD, 
        {TOKEN_TIMEOUT, FALSE, FALSE},
        NULL, 
        0, 
        NULL 
    },

    { 
        RASMONTR_CMD_TYPE_ENUM, 
        {TOKEN_MESSAGES,    FALSE, FALSE},
        g_rgEnumEnableDisable, 
        sizeof(g_rgEnumEnableDisable)/sizeof(*g_rgEnumEnableDisable), 
        NULL 
    }
};        

#define g_dwArgsAuthCount (sizeof(g_pArgsAuth) / sizeof(*g_pArgsAuth))
#define g_dwArgsAcctCount (sizeof(g_pArgsAcct) / sizeof(*g_pArgsAcct))

//
// Local prototypes
//
DWORD
RasAaaaServerInit(
    IN  DWORD dwType, 
    OUT LPVOID lpvServer);

DWORD
RasAaaaServerCleanup(
    IN  DWORD dwType,
    IN  PVOID pvServer);
    
DWORD
RasAaaaServerAdd(
    IN  DWORD dwType,
    IN  PVOID pvServer);

DWORD
RasAaaaServerDelete(
    IN  DWORD dwType,
    IN  PVOID pvServer);
    
DWORD 
RasAaaaServerRead(
    IN  DWORD dwType,
    IN  PVOID pvServer,
    IN  HKEY hkServer  OPTIONAL);

DWORD 
RasAaaaServerWrite(
    IN  DWORD dwType,
    IN  PVOID pvServer,
    IN  HKEY hkServer  OPTIONAL,
    IN  BOOL bInitSecret);

DWORD 
RasAaaaServerEnum(
    IN  DWORD dwType,
    IN  RASAAAA_SERVER_ENUM_CB pEnum,
    IN  HANDLE hData);

DWORD 
RasAaaaServerKeyOpen(
    IN   DWORD dwType,
    IN   DWORD dwFlags,
    OUT  PHKEY phKey);

DWORD
RasAaaaServerSecretWrite(
    IN LPCWSTR pszServer,
    IN LPCWSTR pszSecret);

//
// Discovers the current provider
//
DWORD 
RasAaaaProviderRead(
    IN  DWORD dwType,
    OUT LPDWORD lpdwProvider)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkProviders = NULL;
    PWCHAR pszGuid = NULL;

    do
    {
        // Show the authentication provider
        //
        dwErr = RasAaaaServerKeyOpen(
                    dwType,
                    RASAAAA_F_Provider,
                    &hkProviders);
        BREAK_ON_DWERR(dwErr);

        dwErr = RutlRegReadString(
                    hkProviders,
                    pszRegValActiveProvider,
                    &pszGuid);
        BREAK_ON_DWERR(dwErr);                    
        if (pszGuid == NULL)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        if (dwType == RASAAAA_Auth)
        {
            if (lstrcmpi(pszGuid, pszGuidRadAuth) == 0)
            {
                *lpdwProvider = RASAAAA_Radius;
            }
            else
            {
                *lpdwProvider = RASAAAA_Windows;
            }
        }            
        else 
        {
            if (lstrcmpi(pszGuid, pszGuidRadAcct) == 0)
            {
                *lpdwProvider = RASAAAA_Radius;
            }
            else if (lstrcmpi(pszGuid, pszGuidWinAcct) == 0)
            {
                *lpdwProvider = RASAAAA_Windows;
            }
            else
            {
                *lpdwProvider = RASAAAA_None;
            }
        }            
        
    } while (FALSE);

    // Cleanup
    //
    {
        if (hkProviders)
        {
            RegCloseKey(hkProviders);
        }

        RutlFree(pszGuid);
    }

    return dwErr;
}

// 
// Looks up the address of a server
//
DWORD
RasAaaaServerLookupAddress(
    IN  LPCWSTR pszServer,
    OUT LPWSTR* ppszAddress)
{
    DWORD dwErr = NO_ERROR, dwCount = 0, dwAddr;
    struct hostent* pHost;
    CHAR pszNameA[512];
    WCHAR pszName[512];
    
    do
    {
        // Convert the host name to ansi
        //
        dwCount = WideCharToMultiByte(
                    GetConsoleOutputCP(),
                    0,
                    pszServer,
                    -1,
                    pszNameA,
                    sizeof(pszNameA),
                    NULL,
                    NULL);
        if (dwCount == 0)
        {
            dwErr = GetLastError();
            break;
        }

        // Lookup the host
        //
        pHost = gethostbyname(pszNameA);
        if (pHost == NULL)
        {
            *ppszAddress = RutlStrDup(pszServer);
            if (*ppszAddress == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
        }

        // Convert the discovered address to unicode
        //
        dwAddr = *(PDWORD)(pHost->h_addr_list[0]);
        dwCount = MultiByteToWideChar(
                    GetConsoleOutputCP(),
                    0,
                    inet_ntoa(*(PIN_ADDR)&dwAddr),
                    -1,
                    pszName,
                    sizeof(pszName) / sizeof(WCHAR));
        if (dwCount == 0)
        {
            dwErr = GetLastError();
            break;
        }


        *ppszAddress = RutlStrDup(pszName);
        if (*ppszAddress == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}
    
//
// Populates a server cb with defaults
//
DWORD
RasAaaaServerInit(
    IN  DWORD dwType, 
    OUT PVOID pvServer)
{
    if (dwType == RASAAAA_Auth)
    {
        RASAAAA_AUTH_SERVER* pInfo = (RASAAAA_AUTH_SERVER*)pvServer;
        
        pInfo->pszName = NULL;
        pInfo->pszSecret = NULL;
        pInfo->dwScore = 30;
        pInfo->dwPort = 1812;
        pInfo->dwTimeout = 5; 
        pInfo->dwSignature = 0;
    }
    else
    {
        RASAAAA_ACCT_SERVER* pInfo = (RASAAAA_ACCT_SERVER*)pvServer;

        pInfo->pszName = NULL;
        pInfo->pszSecret = NULL;
        pInfo->dwScore = 30;
        pInfo->dwPort = 1813;
        pInfo->dwTimeout = 5; 
        pInfo->dwMessages = 0;
    }

    return NO_ERROR;
}

//
// Cleans up a server cb
//
DWORD
RasAaaaServerCleanup(
    IN  DWORD dwType,
    IN  PVOID pvServer)
{
    if (dwType == RASAAAA_Auth)
    {
        RASAAAA_AUTH_SERVER* pInfo = (RASAAAA_AUTH_SERVER*)pvServer;
        
        RutlFree(pInfo->pszName);
        RutlFree(pInfo->pszSecret);
    }
    else
    {
        RASAAAA_ACCT_SERVER* pInfo = (RASAAAA_ACCT_SERVER*)pvServer;

        RutlFree(pInfo->pszName);
        RutlFree(pInfo->pszSecret);
    }

    return NO_ERROR;
}

//
// Adds a server
//
DWORD
RasAaaaServerAdd(
    IN  DWORD dwType,
    IN  PVOID pvServer)
{
    DWORD dwErr = NO_ERROR, dwDisposition;
    HKEY hkServers = NULL, hkKey = NULL;

    do
    {
        dwErr = RasAaaaServerKeyOpen(
                    dwType,
                    RASAAAA_F_Create,
                    &hkServers);
        BREAK_ON_DWERR(dwErr);                    

        // Create the new key
        //
        dwErr = RegCreateKeyExW(
                    hkServers,
                    *((PWCHAR*)pvServer),
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hkKey,
                    &dwDisposition);
        BREAK_ON_DWERR(dwErr);

        if (dwDisposition == REG_OPENED_EXISTING_KEY)
        {
            dwErr = ERROR_ALREADY_EXISTS;
            break;
        }

        dwErr = RasAaaaServerWrite(dwType, pvServer, hkKey, TRUE);
        BREAK_ON_DWERR(dwErr);
        
    } while (FALSE);

    // Cleanup
    //
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
        if (hkKey)
        {
            RegCloseKey(hkKey);
        }
    }
    
    return dwErr;
}

DWORD
RasAaaaServerDelete(
    IN  DWORD dwType,
    IN  PVOID pvServer)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkServers = NULL;

    do
    {
        dwErr = RasAaaaServerKeyOpen(
                    dwType,
                    0,
                    &hkServers);
        BREAK_ON_DWERR(dwErr);                    

        dwErr = RegDeleteKey(hkServers, *(PWCHAR*)pvServer);
        BREAK_ON_DWERR(dwErr);

        // Cleanup the shared secret
        //
        RasAaaaServerSecretWrite(*(PWCHAR*)pvServer, NULL);
        
    } while (FALSE);

    // Cleanup
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
    }

    return dwErr;
}

// 
// Callback to an enumeration function that deletes the given
// authentication server
//
DWORD
RasAaaaServerDeleteAuthCb(
    IN PVOID pvServer,
    IN HANDLE hData)
{
    return RasAaaaServerDelete(RASAAAA_Auth, pvServer);
}

// 
// Callback to an enumeration function that deletes the given
// accounting server
//
DWORD
RasAaaaServerDeleteAcctCb(
    IN PVOID pvServer,
    IN HANDLE hData)
{
    return RasAaaaServerDelete(RASAAAA_Acct, pvServer);
}

//
// Read server info
// 
DWORD 
RasAaaaServerRead(
    IN  DWORD dwType,
    IN  PVOID pvServer,
    IN  HKEY hkServer  OPTIONAL)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkServers = NULL, hkKey = NULL;

    do
    {
        if (hkServer == NULL)
        {
            dwErr = RasAaaaServerKeyOpen(
                        dwType,
                        0,
                        &hkServers);
            BREAK_ON_DWERR(dwErr);                    

            dwErr = RegOpenKeyEx(
                        hkServers,
                        *(PWCHAR*)pvServer,
                        0,
                        KEY_ALL_ACCESS,
                        &hkKey);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            hkKey = hkServer;
        }

        if (dwType == RASAAAA_Auth)
        {
            RASAAAA_AUTH_SERVER* pInfo = (RASAAAA_AUTH_SERVER*)pvServer;

            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValScore, 
                        &pInfo->dwScore);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValAuthPort, 
                        &pInfo->dwPort);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValTimeout, 
                        &pInfo->dwTimeout);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValSignature, 
                        &pInfo->dwSignature);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            RASAAAA_ACCT_SERVER* pInfo = (RASAAAA_ACCT_SERVER*)pvServer;

            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValScore, 
                        &pInfo->dwScore);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValAcctPort, 
                        &pInfo->dwPort);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValTimeout, 
                        &pInfo->dwTimeout);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegReadDword(
                        hkKey, 
                        pszRegValMessage, 
                        &pInfo->dwMessages);
            BREAK_ON_DWERR(dwErr);
        }
        
    } while (FALSE);

    // Cleanup
    //
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
        if (hkKey && hkServer == NULL)
        {
            RegCloseKey(hkKey);
        }
    }
    
    return dwErr;
}

//
// Write server info
// 
DWORD 
RasAaaaServerWrite(
    IN  DWORD dwType,
    IN  PVOID pvServer,
    IN  HKEY hkServer,  OPTIONAL
    IN  BOOL bInitSecret)
{    
    DWORD dwErr = NO_ERROR;
    HKEY hkServers = NULL, hkKey = NULL;

    do
    {
        if (hkServer == NULL)
        {
            dwErr = RasAaaaServerKeyOpen(
                        dwType,
                        0,
                        &hkServers);
            BREAK_ON_DWERR(dwErr);                    

            dwErr = RegOpenKeyEx(
                        hkServers,
                        *(PWCHAR*)pvServer,
                        0,
                        KEY_ALL_ACCESS,
                        &hkKey);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            hkKey = hkServer;
        }

        if (dwType == RASAAAA_Auth)
        {
            RASAAAA_AUTH_SERVER* pInfo = (RASAAAA_AUTH_SERVER*)pvServer;

            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValScore, 
                        pInfo->dwScore);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValAuthPort, 
                        pInfo->dwPort);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValTimeout, 
                        pInfo->dwTimeout);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValSignature, 
                        pInfo->dwSignature);
            BREAK_ON_DWERR(dwErr);

            if (pInfo->pszSecret)
            {
                dwErr = RasAaaaServerSecretWrite(
                            pInfo->pszName,
                            pInfo->pszSecret);
                BREAK_ON_DWERR(dwErr);                            
            }
            else if (bInitSecret)
            {
                dwErr = RasAaaaServerSecretWrite(
                            pInfo->pszName,
                            L"");
                BREAK_ON_DWERR(dwErr);                            
            }
        }
        else
        {
            RASAAAA_ACCT_SERVER* pInfo = (RASAAAA_ACCT_SERVER*)pvServer;

            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValScore, 
                        pInfo->dwScore);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValAcctPort, 
                        pInfo->dwPort);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValTimeout, 
                        pInfo->dwTimeout);
            BREAK_ON_DWERR(dwErr);
            
            dwErr = RutlRegWriteDword(
                        hkKey, 
                        pszRegValMessage, 
                        pInfo->dwMessages);
            BREAK_ON_DWERR(dwErr);
            
            if (pInfo->pszSecret)
            {
                dwErr = RasAaaaServerSecretWrite(
                            pInfo->pszName,
                            pInfo->pszSecret);
                BREAK_ON_DWERR(dwErr);                            
            }
            else if (bInitSecret)
            {
                dwErr = RasAaaaServerSecretWrite(
                            pInfo->pszName,
                            L"");
                BREAK_ON_DWERR(dwErr);                            
            }
        }
    } while (FALSE);

    // Cleanup
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
        if (hkKey && hkServer == NULL)
        {
            RegCloseKey(hkKey);
        }
    }

    return dwErr;
}    

//
// Callback function for registry enumerator
//
DWORD
RasAaaaServerEnumCb(
    IN LPCWSTR pszName,
    IN HKEY hKey,
    IN HANDLE hData)
{
    RASAAAA_ENUM_DATA* pData = (RASAAAA_ENUM_DATA*)hData;
    RASAAAA_AUTH_SERVER AuthServer;
    RASAAAA_ACCT_SERVER AcctServer;
    DWORD dwErr = NO_ERROR;

    ZeroMemory(&AuthServer, sizeof(AuthServer));
    ZeroMemory(&AcctServer, sizeof(AcctServer));
    
    do
    {
        if (pData->dwType == RASAAAA_Auth)
        {
            AuthServer.pszName = RutlStrDup(pszName);

            dwErr = RasAaaaServerRead(
                        pData->dwType,
                        (PVOID)&AuthServer,
                        hKey);
            BREAK_ON_DWERR(dwErr);

            dwErr = pData->pEnum((PVOID)&AuthServer, pData->hData);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            AcctServer.pszName = RutlStrDup(pszName);

            dwErr = RasAaaaServerRead(
                        pData->dwType,
                        (PVOID)&AcctServer,
                        hKey);
            BREAK_ON_DWERR(dwErr);

            dwErr = pData->pEnum((PVOID)&AcctServer, pData->hData);
            BREAK_ON_DWERR(dwErr);
        }
        
    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(
            pData->dwType,
            (pData->dwType == RASAAAA_Auth) ?
                (PVOID)&AuthServer          :
                (PVOID)&AcctServer);
    }

    return dwErr;
}

// 
// Enumerates the servers
//
DWORD 
RasAaaaServerEnum(
    IN  DWORD dwType,
    IN  RASAAAA_SERVER_ENUM_CB pEnum,
    IN  HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkServers = NULL;
    RASAAAA_ENUM_DATA EnumData;

    do
    {
        ZeroMemory(&EnumData, sizeof(EnumData));
        
        dwErr = RasAaaaServerKeyOpen(
                    dwType,
                    0,
                    &hkServers);
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            dwErr = NO_ERROR;
            break;
        }
        BREAK_ON_DWERR(dwErr);  

        EnumData.dwType = dwType;
        EnumData.pEnum = pEnum;
        EnumData.hData = hData;
                    
        dwErr =  RutlRegEnumKeys(
                    hkServers,
                    RasAaaaServerEnumCb,
                    (HANDLE)&EnumData);
        BREAK_ON_DWERR(dwErr);                    

    } while (FALSE);

    // Cleanup
    //
    {
        if (hkServers)
        {
            RegCloseKey(hkServers);
        }
    }

    return dwErr;
}

//
// Opens the appropriate registry key
//
DWORD 
RasAaaaServerKeyOpen(
    IN   DWORD dwType,
    IN   DWORD dwFlags,
    OUT  PHKEY phKey)
{
    HKEY hkRoot = NULL, hkProvider = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    (dwType == RASAAAA_Auth) ? pszRegKeyAuth : pszRegKeyAcct,
                    0,
                    KEY_ALL_ACCESS,
                    &hkRoot);
        BREAK_ON_DWERR(dwErr);

        if (dwFlags & RASAAAA_F_Provider)
        {
            *phKey = hkRoot;
            break;
        }

        dwErr = RegOpenKeyEx(
                    hkRoot,
                    (dwType == RASAAAA_Auth) ? pszGuidRadAuth : pszGuidRadAcct,
                    0,
                    KEY_ALL_ACCESS,
                    &hkProvider);
        BREAK_ON_DWERR(dwErr);

        if (dwFlags & RASAAAA_F_Create)
        {
            DWORD dwDisposition;
            
            dwErr = RegCreateKeyExW(
                        hkProvider,
                        pszRegKeyServers,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        phKey,
                        &dwDisposition);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            dwErr = RegOpenKeyExW(
                        hkProvider,
                        pszRegKeyServers,
                        0,
                        KEY_ALL_ACCESS,
                        phKey);
            BREAK_ON_DWERR(dwErr);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkRoot && !(dwFlags & RASAAAA_F_Provider))
        {
            RegCloseKey(hkRoot);
        }
        if (hkProvider)
        {
            RegCloseKey(hkProvider);
        }
        if (dwErr != NO_ERROR)
        {
            if (*phKey)
            {
                RegCloseKey(*phKey);
            }
            *phKey = NULL;
        }
    }

    return dwErr;
}

// 
// Saves a shared secret
//
DWORD
RasAaaaServerSecretWrite(
    IN LPCWSTR pszRadiusServerName,
    IN LPCWSTR pszSecret)
{
	LSA_HANDLE            hLSA = NULL;
    NTSTATUS              ntStatus;
    LSA_OBJECT_ATTRIBUTES objectAttributes;
	LSA_UNICODE_STRING	  LSAPrivData, LSAPrivDataDesc;
    TCHAR				  tszPrivData[MAX_PATH+1],
						  tszPrivDataDesc[MAX_PATH+CCHRADIUSSERVER+1];
	TCHAR *				  ptszTemp;
	PUNICODE_STRING		  pSystem;
	UNICODE_STRING		  uszSystemName;

	pSystem = NULL;
		
    InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);

    ntStatus = LsaOpenPolicy(
                    pSystem, 
                    &objectAttributes, 
                    POLICY_ALL_ACCESS, 
                    &hLSA);

    if ( !NT_SUCCESS( ntStatus) ) 
    {
        return( RtlNtStatusToDosError( ntStatus ) );
    }

	ZeroMemory(tszPrivDataDesc, sizeof(tszPrivDataDesc));
    lstrcpy(tszPrivDataDesc, PSZRADIUSSERVER);
	lstrcpyn(tszPrivDataDesc + CCHRADIUSSERVER, pszRadiusServerName, MAX_PATH);
		
    LSAPrivDataDesc.Length = (USHORT)((lstrlen(tszPrivDataDesc) + 1) * sizeof(TCHAR));
    LSAPrivDataDesc.MaximumLength = sizeof(tszPrivDataDesc);
    LSAPrivDataDesc.Buffer = tszPrivDataDesc;

	ZeroMemory(tszPrivData, sizeof(tszPrivData));
	if (pszSecret)
	{
    	lstrcpyn(tszPrivData, pszSecret, MAX_PATH);
        LSAPrivData.Length = (USHORT)(lstrlen(tszPrivData) * sizeof(TCHAR));
        LSAPrivData.MaximumLength = sizeof(tszPrivData);
        LSAPrivData.Buffer = tszPrivData;
    }
    else
    {
        LSAPrivData.Length = 0;
        LSAPrivData.MaximumLength = 0;
        LSAPrivData.Buffer = NULL;
    }
		
    ntStatus = LsaStorePrivateData(hLSA, &LSAPrivDataDesc, &LSAPrivData);

    ZeroMemory( tszPrivData, sizeof( tszPrivData ) );

    LsaClose(hLSA);

	return( RtlNtStatusToDosError( ntStatus ) );
} 

//
// Displays the given server
//
DWORD
RasAaaaServerAuthShow(
    IN PVOID pvServer,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_AUTH_SERVER* pServer = (RASAAAA_AUTH_SERVER*)pvServer;
    PWCHAR pszAddress = NULL;
    BOOL* pDumpFmt = (BOOL*)hData;
    PWCHAR pszPort = NULL, pszScore = NULL, pszTimeout = NULL, 
           pszName = NULL, pszSig = NULL;

    do
    {   
        if (!pDumpFmt || *pDumpFmt == FALSE)
        {
            // Lookup the address
            //
            dwErr = RasAaaaServerLookupAddress(pServer->pszName, &pszAddress);
            BREAK_ON_DWERR(dwErr);
        
            DisplayMessage(
                g_hModule,
                MSG_RASAAAA_SHOW_AUTHSERV,
                pServer->pszName,
                pszAddress,
                pServer->dwPort,
                pServer->dwScore,
                pServer->dwTimeout,
                (pServer->dwSignature) ? TOKEN_ENABLED : TOKEN_DISABLED);
        }
        else
        {
            // Make assignment strings
            //
            pszPort = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_PORT,
                        pServer->dwPort,
                        10);
                        
            pszScore = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_INITSCORE,
                        pServer->dwScore,
                        10);
                        
            pszTimeout = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_TIMEOUT,
                        pServer->dwTimeout,
                        10);
                        
            pszName = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_NAME,
                        pServer->pszName);
                        
            pszSig = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_SIGNATURE,
                        (pServer->dwSignature) ? 
                            TOKEN_ENABLED      : 
                            TOKEN_DISABLED);
            if (!pszPort || !pszScore || !pszTimeout || !pszName || !pszSig)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        
            // Display the command
            //
            DisplayMessage(
                g_hModule,
                MSG_RASAAAA_CMD5,
                DMP_RASAAAA_ADD_AUTHSERV,
                pszName,
                pszPort,
                pszScore,
                pszTimeout,
                pszSig);
        }
            
    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszAddress);
        RutlFree(pszName);
        RutlFree(pszPort);
        RutlFree(pszScore);
        RutlFree(pszTimeout);
        RutlFree(pszSig);
    }

    return dwErr;
}

//
// Displays the given server
//
DWORD
RasAaaaServerAcctShow(
    IN PVOID pvServer,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_ACCT_SERVER* pServer = (RASAAAA_ACCT_SERVER*)pvServer;
    PWCHAR pszAddress = NULL;
    PWCHAR pszPort = NULL, pszScore = NULL, pszTimeout = NULL, 
           pszName = NULL, pszMsg = NULL;
    BOOL* pDumpFmt = (BOOL*)hData;
    
    do
    {   
        if (!pDumpFmt || *pDumpFmt == FALSE)
        {
            // Lookup the address
            //
            dwErr = RasAaaaServerLookupAddress(pServer->pszName, &pszAddress);
            BREAK_ON_DWERR(dwErr);
        
            DisplayMessage(
                g_hModule,
                MSG_RASAAAA_SHOW_AUTHSERV,
                pServer->pszName,
                pszAddress,
                pServer->dwPort,
                pServer->dwScore,
                pServer->dwTimeout,
                (pServer->dwMessages) ? TOKEN_ENABLED : TOKEN_DISABLED);
        }                
        else
        {
            // Make assignment strings
            //
            pszPort = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_PORT,
                        pServer->dwPort,
                        10);
                        
            pszScore = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_INITSCORE,
                        pServer->dwScore,
                        10);
                        
            pszTimeout = RutlAssignmentFromTokenAndDword(
                        g_hModule,
                        TOKEN_TIMEOUT,
                        pServer->dwTimeout,
                        10);
                        
            pszName = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_NAME,
                        pServer->pszName);
                        
            pszMsg = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_MESSAGES,
                        (pServer->dwMessages) ? 
                            TOKEN_ENABLED      : 
                            TOKEN_DISABLED);
            if (!pszPort || !pszScore || !pszTimeout || !pszName || !pszMsg)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        
            // Display the command
            //
            DisplayMessage(
                g_hModule,
                MSG_RASAAAA_CMD5,
                DMP_RASAAAA_ADD_ACCTSERV,
                pszName,
                pszPort,
                pszScore,
                pszTimeout,
                pszMsg);
        }
    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszAddress);
        RutlFree(pszName);
        RutlFree(pszPort);
        RutlFree(pszScore);
        RutlFree(pszTimeout);
        RutlFree(pszMsg);
    }

    return dwErr;
}

//
// Entry called by rasmontr to register this context
//
DWORD 
WINAPI
RasAaaaStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"aaaa";
    attMyAttributes.guidHelper  = g_RasAaaaGuid;
    attMyAttributes.dwVersion   = RASAAAA_VERSION;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulRasAaaaNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_RasAaaaCmdGroups;
    attMyAttributes.pfnDumpFn   = RasAaaaDump;

    dwErr = RegisterContext( &attMyAttributes );
                
    return dwErr;
}

DWORD
WINAPI
RasAaaaDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    DWORD dwErr = NO_ERROR, dwProvider;
    PWCHAR pszCmd = NULL, pszToken = NULL;
    BOOL bDumpFmt;

    // Dump the header
    //
    DisplayMessage(g_hModule, MSG_RASAAAA_SCRIPTHEADER);
    DisplayMessageT(DMP_RASAAAA_PUSHD);
    
    do
    {
        // Dump the commands to set the correct authentication and
        // accounting providers
        //
        dwErr = RasAaaaProviderRead(RASAAAA_Auth, &dwProvider);
        BREAK_ON_DWERR(dwErr);

        pszCmd = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_PROVIDER,
                    (dwProvider == RASAAAA_Windows) ? 
                        TOKEN_WINDOWS               :
                        TOKEN_RADIUS);
        if (pszCmd == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_CMD1,
            DMP_RASAAAA_SET_AUTH,
            pszCmd);

        RutlFree(pszCmd);
        
        dwErr = RasAaaaProviderRead(RASAAAA_Acct, &dwProvider);
        BREAK_ON_DWERR(dwErr);

        if (dwProvider == RASAAAA_Windows)
        {
            pszToken = (PWCHAR)TOKEN_WINDOWS;
        }
        else if (dwProvider == RASAAAA_Radius)
        {
            pszToken = (PWCHAR)TOKEN_RADIUS;
        }
        else
        {
            pszToken = (PWCHAR)TOKEN_NONE;
        }
        pszCmd = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_PROVIDER,
                    pszToken);
        if (pszCmd == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_CMD1,
            DMP_RASAAAA_SET_ACCT,
            pszCmd);

        RutlFree(pszCmd);

        DisplayMessageT(MSG_NEWLINE);

        // Dump the commands to delete all of the current servers
        //
        pszCmd = RutlAssignmentFromTokens(
                    g_hModule,
                    TOKEN_NAME,
                    TOKEN_RASAAAA_ALLSERVERS);
        if (pszCmd == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_CMD1,
            DMP_RASAAAA_DEL_AUTHSERV,
            pszCmd);

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_CMD1,
            DMP_RASAAAA_DEL_ACCTSERV,
            pszCmd);

        RutlFree(pszCmd);

        DisplayMessageT(MSG_NEWLINE);

        // Dump commands to add all of the current auth servers
        //
        bDumpFmt = TRUE;
        dwErr = RasAaaaServerEnum(
                    RASAAAA_Auth,
                    RasAaaaServerAuthShow,
                    (HANDLE)&bDumpFmt);
        BREAK_ON_DWERR(dwErr);

        DisplayMessageT(MSG_NEWLINE);

        // Dump commands to add all of the accouting servers
        //
        dwErr = RasAaaaServerEnum(
                    RASAAAA_Acct,
                    RasAaaaServerAcctShow,
                    (HANDLE)&bDumpFmt);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Dump the footer
    DisplayMessageT(DMP_RASAAAA_POPD);
    DisplayMessage(g_hModule, MSG_RASAAAA_SCRIPTFOOTER);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasAaaaHandleAddAuthServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_AUTH_SERVER Server;
    RASMON_CMD_ARG pArgs[g_dwArgsAuthCount];
    
    // Initialize
    CopyMemory(pArgs, g_pArgsAuth, sizeof(g_pArgsAuth));

    do
    {
        dwErr = RasAaaaServerInit(RASAAAA_Auth, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);                
        
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);
        Server.pszSecret = RASMON_CMD_ARG_GetPsz(pArgs + 1);

        if (RASMON_CMD_ARG_Present(pArgs + 2))
        {
            Server.dwScore = RASMON_CMD_ARG_GetDword(pArgs + 2);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 3))
        {
            Server.dwPort = RASMON_CMD_ARG_GetDword(pArgs + 3);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 4))
        {
            Server.dwTimeout = RASMON_CMD_ARG_GetDword(pArgs + 4);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 5))
        {
            Server.dwSignature = RASMON_CMD_ARG_GetDword(pArgs + 5);
        }

        dwErr = RasAaaaServerAdd(RASAAAA_Auth, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);

        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(RASAAAA_Auth, (PVOID)&Server);
    }
    
    return dwErr;
}

DWORD
RasAaaaHandleAddAcctServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_ACCT_SERVER Server;
    RASMON_CMD_ARG pArgs[g_dwArgsAcctCount];
    
    // Initialize
    CopyMemory(pArgs, g_pArgsAcct, sizeof(g_pArgsAcct));

    do
    {
        dwErr = RasAaaaServerInit(RASAAAA_Acct, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);                
        
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);
        Server.pszSecret = RASMON_CMD_ARG_GetPsz(pArgs + 1);

        if (RASMON_CMD_ARG_Present(pArgs + 2))
        {
            Server.dwScore = RASMON_CMD_ARG_GetDword(pArgs + 2);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 3))
        {
            Server.dwPort = RASMON_CMD_ARG_GetDword(pArgs + 3);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 4))
        {
            Server.dwTimeout = RASMON_CMD_ARG_GetDword(pArgs + 4);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 5))
        {
            Server.dwMessages = RASMON_CMD_ARG_GetDword(pArgs + 5);
        }

        dwErr = RasAaaaServerAdd(RASAAAA_Acct, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);

        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(RASAAAA_Acct, (PVOID)&Server);
    }
    
    return dwErr;
}

DWORD
RasAaaaHandleDelAuthServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwType = RASAAAA_Auth;
    RASAAAA_AUTH_SERVER Server;
    PVOID pvServer = (PVOID)&Server;
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    TRUE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        

    ZeroMemory(&Server, sizeof(Server));

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(&pArgs[0]);

        if (wcscmp(Server.pszName, TOKEN_RASAAAA_ALLSERVERS) == 0)
        {
            dwErr = RasAaaaServerEnum(
                        RASAAAA_Auth, 
                        RasAaaaServerDeleteAuthCb,
                        NULL);
        }
        else 
        {
            dwErr = RasAaaaServerDelete(dwType, pvServer);
        }
        BREAK_ON_DWERR( dwErr );
        
        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(dwType, pvServer);
    }

    return dwErr;
}

DWORD
RasAaaaHandleDelAcctServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwType = RASAAAA_Acct;
    RASAAAA_ACCT_SERVER Server;
    PVOID pvServer = (PVOID)&Server;
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    TRUE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        

    ZeroMemory(&Server, sizeof(Server));

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(&pArgs[0]);

        if (wcscmp(Server.pszName, TOKEN_RASAAAA_ALLSERVERS) == 0)
        {
            dwErr = RasAaaaServerEnum(
                        RASAAAA_Acct, 
                        RasAaaaServerDeleteAcctCb,
                        NULL);
        }
        else 
        {
            dwErr = RasAaaaServerDelete(dwType, pvServer);
        }            
        BREAK_ON_DWERR( dwErr );
        
        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(dwType, pvServer);
    }

    return dwErr;
}

DWORD
RasAaaaHandleSetAuth(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue;
    HKEY hkProviders = NULL;
    TOKEN_VALUE rgEnum[] = 
    { 
        {TOKEN_WINDOWS,     1}, 
        {TOKEN_RADIUS,      0} 
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_PROVIDER,    TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum) / sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        dwErr = RasAaaaServerKeyOpen(
                    RASAAAA_Auth,
                    RASAAAA_F_Provider,
                    &hkProviders);
        BREAK_ON_DWERR(dwErr);

        dwErr = RutlRegWriteString(
                    hkProviders,
                    pszRegValActiveProvider,
                    (dwValue) ? pszGuidWinAuth : pszGuidRadAuth);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    //
    {
        if (hkProviders)
        {
            RegCloseKey(hkProviders);
        }
    }

    return dwErr;
}

DWORD
RasAaaaHandleSetAcct(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue;
    HKEY hkProviders = NULL;
    PWCHAR pszProvider = NULL;
    TOKEN_VALUE rgEnum[] = 
    { 
        {TOKEN_WINDOWS,     1}, 
        {TOKEN_RADIUS,      0},
        {TOKEN_NONE,        2}
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_PROVIDER,    TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum) / sizeof(*rgEnum), 
            NULL 
        }
    };        

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        dwErr = RasAaaaServerKeyOpen(
                    RASAAAA_Acct,
                    RASAAAA_F_Provider,
                    &hkProviders);
        BREAK_ON_DWERR(dwErr);

        if (dwValue == 0)
        {
            pszProvider = pszGuidRadAcct;
        }
        else if (dwValue == 1)
        {
            pszProvider = pszGuidWinAcct;
        }
        else
        {
            pszProvider = L"";
        }
        dwErr = RutlRegWriteString(
                    hkProviders,
                    pszRegValActiveProvider,
                    pszProvider);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    //
    {
        if (hkProviders)
        {
            RegCloseKey(hkProviders);
        }
    }

    return dwErr;
}

DWORD
RasAaaaHandleSetAuthServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_AUTH_SERVER Server;
    RASMON_CMD_ARG pArgs[g_dwArgsAuthCount];
    
    // Initialize
    CopyMemory(pArgs, g_pArgsAuth, sizeof(g_pArgsAuth));

    do
    {
        dwErr = RasAaaaServerInit(RASAAAA_Auth, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);                
        
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);
        Server.pszSecret = RASMON_CMD_ARG_GetPsz(pArgs + 1);

        dwErr = RasAaaaServerRead(RASAAAA_Auth, (PVOID)&Server, NULL);
        BREAK_ON_DWERR(dwErr);

        if (RASMON_CMD_ARG_Present(pArgs + 2))
        {
            Server.dwScore = RASMON_CMD_ARG_GetDword(pArgs + 2);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 3))
        {
            Server.dwPort = RASMON_CMD_ARG_GetDword(pArgs + 3);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 4))
        {
            Server.dwTimeout = RASMON_CMD_ARG_GetDword(pArgs + 4);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 5))
        {
            Server.dwSignature = RASMON_CMD_ARG_GetDword(pArgs + 5);
        }

        dwErr = RasAaaaServerWrite(RASAAAA_Auth, (PVOID)&Server, NULL, FALSE);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(RASAAAA_Auth, (PVOID)&Server);
    }
    
    return dwErr;
}

DWORD
RasAaaaHandleSetAcctServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_ACCT_SERVER Server;
    RASMON_CMD_ARG pArgs[g_dwArgsAcctCount];
    
    // Initialize
    CopyMemory(pArgs, g_pArgsAcct, sizeof(g_pArgsAcct));

    do
    {
        dwErr = RasAaaaServerInit(RASAAAA_Acct, (PVOID)&Server);
        BREAK_ON_DWERR(dwErr);                
        
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);
        Server.pszSecret = RASMON_CMD_ARG_GetPsz(pArgs + 1);

        dwErr = RasAaaaServerRead(RASAAAA_Acct, (PVOID)&Server, NULL);
        BREAK_ON_DWERR(dwErr);

        if (RASMON_CMD_ARG_Present(pArgs + 2))
        {
            Server.dwScore = RASMON_CMD_ARG_GetDword(pArgs + 2);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 3))
        {
            Server.dwPort = RASMON_CMD_ARG_GetDword(pArgs + 3);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 4))
        {
            Server.dwTimeout = RASMON_CMD_ARG_GetDword(pArgs + 4);
        }
        if (RASMON_CMD_ARG_Present(pArgs + 5))
        {
            Server.dwMessages = RASMON_CMD_ARG_GetDword(pArgs + 5);
        }

        dwErr = RasAaaaServerWrite(RASAAAA_Acct, (PVOID)&Server, NULL, FALSE);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    //
    {
        RasAaaaServerCleanup(RASAAAA_Acct, (PVOID)&Server);
    }
    
    return dwErr;
}

DWORD
RasAaaaHandleShowAuth(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwProvider;
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;
    PWCHAR pszProvider = (PWCHAR)TOKEN_WINDOWS;

    do
    {
        // Make sure no arguments were passed
        //
        if (dwNumArgs > 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        dwErr = RasAaaaProviderRead(RASAAAA_Auth, &dwProvider);
        BREAK_ON_DWERR(dwErr);

        if (dwProvider == RASAAAA_Radius) 
        {
            pszProvider = (PWCHAR)TOKEN_RADIUS;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_SHOW_AUTH,
            pszProvider);
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasAaaaHandleShowAcct(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwProvider;
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;
    PWCHAR pszProvider = NULL;

    do
    {
        // Make sure no arguments were passed
        //
        if (dwNumArgs > 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        // Show the authentication provider
        //
        dwErr = RasAaaaProviderRead(RASAAAA_Acct, &dwProvider);
        BREAK_ON_DWERR(dwErr);

        if (dwProvider == RASAAAA_Radius) 
        {
            pszProvider = (PWCHAR)TOKEN_RADIUS;
        }
        else if (dwProvider == RASAAAA_Windows)
        {
            pszProvider = (PWCHAR)TOKEN_WINDOWS;
        }
        else
        {
            pszProvider = (PWCHAR)TOKEN_NONE;
        }

        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_SHOW_ACCT,
            pszProvider);
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasAaaaHandleShowAuthServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_AUTH_SERVER Server;
    RASMON_CMD_ARG pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    FALSE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        

    do
    {
        ZeroMemory(&Server, sizeof(Server));
    
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);

        // Display the header
        //
        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_SHOW_AUTHSERV_HDR);

        if (Server.pszName)
        {
            dwErr = RasAaaaServerRead(
                        RASAAAA_Auth, 
                        (PVOID)&Server, 
                        NULL);
            BREAK_ON_DWERR(dwErr);

            dwErr = RasAaaaServerAuthShow(
                        (PVOID)&Server,
                        NULL);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            // Show all the servers
            //
            dwErr = RasAaaaServerEnum(
                        RASAAAA_Auth,
                        RasAaaaServerAuthShow,
                        NULL);
            BREAK_ON_DWERR(dwErr);                    
        }            
    
    } while (FALSE);

    // Cleanup
    {
        RasAaaaServerCleanup(RASAAAA_Auth, (PVOID)&Server);
    }

    return dwErr;
}

DWORD
RasAaaaHandleShowAcctServ(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    RASAAAA_ACCT_SERVER Server;
    RASMON_CMD_ARG pArgs[] = 
    {
        { 
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    FALSE, FALSE},
            NULL, 
            0, 
            NULL 
        }
    };        

    do
    {
        ZeroMemory(&Server, sizeof(Server));
    
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        Server.pszName = RASMON_CMD_ARG_GetPsz(pArgs + 0);

        // Display the header
        //
        DisplayMessage(
            g_hModule,
            MSG_RASAAAA_SHOW_ACCTSERV_HDR);

        if (Server.pszName)
        {
            dwErr = RasAaaaServerRead(
                        RASAAAA_Acct, 
                        (PVOID)&Server, 
                        NULL);
            BREAK_ON_DWERR(dwErr);

            dwErr = RasAaaaServerAcctShow(
                        (PVOID)&Server,
                        NULL);
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            // Show all the servers
            //
            dwErr = RasAaaaServerEnum(
                        RASAAAA_Acct,
                        RasAaaaServerAcctShow,
                        NULL);
            BREAK_ON_DWERR(dwErr);                    
        }            
    
    
    } while (FALSE);

    // Cleanup
    {
        RasAaaaServerCleanup(RASAAAA_Auth, (PVOID)&Server);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasadmon.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rasadmon.c

Abstract:

    RAS Advertisement monitoring module

Revision History:

    dthaler

--*/

#include "precomp.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include <time.h>
#include <mswsock.h>

#define RASADV_PORT    9753
#define RASADV_GROUP   "239.255.2.2"

typedef DWORD IPV4_ADDRESS;

HANDLE g_hCtrlC = NULL;

BOOL
HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    )
{
    switch (dwCtrlType)
    {
        case CTRL_C_EVENT:

        case CTRL_CLOSE_EVENT:

        case CTRL_BREAK_EVENT:

        case CTRL_LOGOFF_EVENT:

        case CTRL_SHUTDOWN_EVENT:

        default:
            SetEvent(g_hCtrlC);
    }

    return TRUE;
};

char *            // OUT: string version of IP address
AddrToString(
    u_long addr,  // IN : address to convert
    char  *ptr    // OUT: buffer, or NULL
    )
{
    char *str;
    struct in_addr in;
    in.s_addr = addr;
    str = inet_ntoa(in);
    if (ptr && str) {
       strcpy(ptr, str);
       return ptr;
    }
    return str;
}

//
// Convert an address to a name
//
char *
AddrToHostname(
    long addr,
    BOOL bNumeric_flag
    )
{
    if (!addr)
        return "local";
    if (!bNumeric_flag) {
        struct hostent * host_ptr = NULL;
        host_ptr = gethostbyaddr ((char *) &addr, sizeof(addr), AF_INET);
        if (host_ptr)
            return host_ptr->h_name;
    }

    return AddrToString(addr, NULL);
}


DWORD
HandleRasShowServers(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Monitors RAS Server advertisements.

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL bCleanWSA = TRUE, bCleanCtrl = TRUE;
    DWORD dwErr = NO_ERROR;
    SOCKET s = INVALID_SOCKET;
    WSABUF wsaBuf;
    WSADATA wsaData;
    WSAEVENT WaitEvts[2];
    SOCKADDR_IN sinFrom;
    LPFN_WSARECVMSG WSARecvMsgFuncPtr = NULL;

    do
    {
        ZeroMemory(&wsaBuf, sizeof(WSABUF));

        dwErr = WSAStartup( MAKEWORD(2,0), &wsaData );
        if (dwErr)
        {
            bCleanWSA = FALSE;
            break;
        }
        //
        // create socket
        //
        s = WSASocket(
                AF_INET,    // address family
                SOCK_DGRAM, // type
                0,          // protocol
                NULL,
                0,
                WSA_FLAG_OVERLAPPED);
        if(INVALID_SOCKET == s)
        {
            dwErr = WSAGetLastError();
            break;
        }

        {
            BOOL bOption = TRUE;

            if (setsockopt(
                    s,
                    SOL_SOCKET,
                    SO_REUSEADDR,
                    (const char FAR*)&bOption,
                    sizeof(BOOL))
               )
            {
                dwErr = WSAGetLastError();
                break;
            }
        }
        //
        // Bind to the specified port
        //
        {
            SOCKADDR_IN sinAddr;

            sinAddr.sin_family      = AF_INET;
            sinAddr.sin_port        = htons(RASADV_PORT);
            sinAddr.sin_addr.s_addr = INADDR_ANY;

            if (bind(s, (struct sockaddr*)&sinAddr, sizeof(sinAddr)))
            {
                dwErr = WSAGetLastError();
                break;
            }
        }
        //
        // Join group
        //
        {
            struct ip_mreq imOption;

            imOption.imr_multiaddr.s_addr = inet_addr(RASADV_GROUP);
            imOption.imr_interface.s_addr = INADDR_ANY;

            if (setsockopt(
                    s,
                    IPPROTO_IP,
                    IP_ADD_MEMBERSHIP,
                    (PBYTE)&imOption,
                    sizeof(imOption))
               )
            {
                dwErr = WSAGetLastError();
                break;
            }
        }
        //
        // Get WSARecvMsg function pointer
        //
        {
            GUID WSARecvGuid = WSAID_WSARECVMSG;
            DWORD dwReturned = 0;

            if (WSAIoctl(
                    s,
                    SIO_GET_EXTENSION_FUNCTION_POINTER,
                    (void*)&WSARecvGuid,
                    sizeof(GUID),
                    (void*)&WSARecvMsgFuncPtr,
                    sizeof(LPFN_WSARECVMSG),
                    &dwReturned,
                    NULL,
                    NULL)
               )
            {
                dwErr = WSAGetLastError();
                break;
            }
        }
        //
        // Get a name buffer for the recv socket
        //
        wsaBuf.buf = RutlAlloc(MAX_PATH + 1, TRUE);
        if (!wsaBuf.buf)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wsaBuf.len = MAX_PATH;
        //
        // Create wsa wait event for the recv socket
        //
        WaitEvts[0] = WSACreateEvent();
        if (WSA_INVALID_EVENT == WaitEvts[0])
        {
            dwErr = WSAGetLastError();
            break;
        }

        if (WSAEventSelect(s, WaitEvts[0], FD_READ))
        {
            dwErr = WSAGetLastError();
            break;
        }
        //
        // Create Ctrl-C wait event
        //
        g_hCtrlC = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!g_hCtrlC)
        {
            dwErr = GetLastError();
            break;
        }
        //
        // Intercept CTRL-C
        //
        if (!SetConsoleCtrlHandler(HandlerRoutine, TRUE))
        {
            dwErr = GetLastError();
            bCleanCtrl = FALSE;
            break;
        }

        WaitEvts[1] = g_hCtrlC;

        DisplayMessage( g_hModule, MSG_RAS_SHOW_SERVERS_HEADER );

        for (;;)
        {
            CHAR szTimeStamp[30], *p, *q;
            DWORD dwBytesRcvd, dwStatus, dwReturn;
            WSAMSG wsaMsg;
            time_t t;

            dwReturn = WSAWaitForMultipleEvents(
                            2,
                            WaitEvts,
                            FALSE,
                            WSA_INFINITE,
                            FALSE);
            if (WSA_WAIT_EVENT_0 == dwReturn)
            {
                if (!WSAResetEvent(WaitEvts[0]))
                {
                    dwErr = WSAGetLastError();
                    break;
                }
            }
            else if (WSA_WAIT_EVENT_0 + 1 == dwReturn)
            {
                dwErr = NO_ERROR;
                break;
            }
            else
            {
                dwErr = WSAGetLastError();
                break;
            }
            //
            // .Net bug# 510712 Buffer overflow in HandleRasShowServers
            //
            // Init wsaMsg struct
            //
            ZeroMemory(&wsaMsg, sizeof(WSAMSG));
            wsaMsg.dwBufferCount = 1;
            wsaMsg.lpBuffers = &wsaBuf;
            wsaMsg.name = (struct sockaddr *)&sinFrom;
            wsaMsg.namelen = sizeof(sinFrom);

            dwStatus = WSARecvMsgFuncPtr(
                            s,
                            &wsaMsg,
                            &dwBytesRcvd,
                            NULL,
                            NULL);
            if (SOCKET_ERROR == dwStatus)
            {
                dwErr = WSAGetLastError();

                if (WSAEMSGSIZE == dwErr)
                {
                    dwBytesRcvd = MAX_PATH;
                }
                else
                {
                    break;
                }
            }
            //
            // Only process multicast packets, skip all others
            //
            else if (!(wsaMsg.dwFlags & MSG_MCAST))
            {
                continue;
            }
            //
            // Get timestamp
            //
            time(&t);
            strcpy(szTimeStamp, ctime(&t));
            szTimeStamp[24] = '\0';
            //
            // Print info on sender
            //
            printf( "%s  %s (%s)\n",
                szTimeStamp,
                AddrToString(sinFrom.sin_addr.s_addr, NULL),
                AddrToHostname(sinFrom.sin_addr.s_addr, FALSE) );

            wsaMsg.lpBuffers->buf[dwBytesRcvd] = '\0';

            for (p=wsaMsg.lpBuffers->buf; p && *p; p=q)
            {
                q = strchr(p, '\n');
                if (q)
                {
                    *q++ = 0;
                }
                printf("   %s\n", p);
            }
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(wsaBuf.buf);

    if (g_hCtrlC)
    {
        CloseHandle(g_hCtrlC);
    }
    if (WaitEvts[0])
    {
        WSACloseEvent(WaitEvts[0]);
    }
    if (INVALID_SOCKET != s)
    {
        closesocket(s);
    }
    if (bCleanWSA)
    {
        WSACleanup();
    }
    if (bCleanCtrl)
    {
        SetConsoleCtrlHandler(HandlerRoutine, FALSE);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasat.h ===
/*
    File:   rasat.h
    
    Definitions for the 'ras at' sub context

    3/2/99
*/

#ifndef __RASAT_H
#define __RASAT_H

#define RASAT_VERSION 1

// e0c5d007-d34c-11d2-9b76-00104bca495b
#define RASAT_GUID \
{ 0xe0c5d007, 0xd34c, 0x11d2, {0x9b, 0x76, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b} }

NS_HELPER_START_FN RasAtStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasAtDump;

FN_HANDLE_CMD   RasAtHandleShow;
FN_HANDLE_CMD   RasAtHandleSetNegotiation;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasdiag.c ===
/*
    File:   rasdiag.c

    'ras diag' sub context

    07/26/01
*/

#include "precomp.h"

//
// The guid for this context
//
GUID g_RasDiagGuid = RASDIAG_GUID;
//
// The commands supported in this context
//
CMD_ENTRY g_RasDiagSetCmdTable[] =
{
    CREATE_CMD_ENTRY(RASDIAG_SET_RASTRACE, HandleTraceSet),
    CREATE_CMD_ENTRY(RASDIAG_SET_TRACEALL, RasDiagHandleSetTraceAll),
    CREATE_CMD_ENTRY(RASDIAG_SET_MODEMTRACE, RasDiagHandleSetModemTrace),
    CREATE_CMD_ENTRY(RASDIAG_SET_CMTRACE, RasDiagHandleSetCmTrace),
    CREATE_CMD_ENTRY(RASDIAG_SET_AUDITING, RasDiagHandleSetAuditing),
};

CMD_ENTRY g_RasDiagShowCmdTable[] =
{
    CREATE_CMD_ENTRY(RASDIAG_SHOW_RASTRACE, HandleTraceShow),
    CREATE_CMD_ENTRY(RASDIAG_SHOW_TRACEALL, RasDiagHandleShowTraceAll),
    CREATE_CMD_ENTRY(RASDIAG_SHOW_MODEMTRACE, RasDiagHandleShowModemTrace),
    CREATE_CMD_ENTRY(RASDIAG_SHOW_CMTRACE, RasDiagHandleShowCmTrace),
    CREATE_CMD_ENTRY(RASDIAG_SHOW_AUDITING, RasDiagHandleShowAuditing),
    CREATE_CMD_ENTRY(RASDIAG_SHOW_LOGS, RasDiagHandleShowLogs),
    CREATE_CMD_ENTRY(RASDIAG_SHOW_ALL, RasDiagHandleShowAll),
    CREATE_CMD_ENTRY(RASDIAG_SHOW_RASCHK, RasDiagHandleShowInstallation),
    CREATE_CMD_ENTRY(RASDIAG_SHOW_CONFIG, RasDiagHandleShowConfiguration),
};

CMD_GROUP_ENTRY g_RasDiagCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,  g_RasDiagSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_RasDiagShowCmdTable),
};

static CONST ULONG g_ulRasDiagNumGroups = sizeof(g_RasDiagCmdGroups) /
                                            sizeof(CMD_GROUP_ENTRY);

//
// This command was never approved or properly tested, disabling but not
// removing (for future consideration).
//
/*CMD_ENTRY g_TopCmds[] =
{
    CREATE_CMD_ENTRY_EX(RASDIAG_REPAIR, RasDiagHandleRepairRas, CMD_FLAG_HIDDEN),
};

static CONST ULONG g_ulNumOfTopCmds = sizeof(g_TopCmds) / sizeof(CMD_ENTRY);*/

//
// Declarations from rasnetcfg
//
HRESULT
HrInstallRas(
    IN CONST PWCHAR pszFilePath);

HRESULT
HrUninstallRas();

PWCHAR
RasDiagVerifyAnswerFile(
    IN CONST PWCHAR pwszFilePath);

//
// Local declarations
//
DWORD
RasDiagHandleReport(
    IN RASDIAG_HANDLE_REPORT_FUNC_CB pCallback,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    OUT BOOL* pbDone);

//
// Entry called by rasmontr to register this context
//
DWORD
WINAPI
RasDiagStartHelper(
    IN CONST GUID* pguidParent,
    IN DWORD dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    //
    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.dwVersion    = RASDIAG_VERSION;
    attMyAttributes.pwszContext  = L"diagnostics";
    attMyAttributes.guidHelper   = g_RasDiagGuid;
    attMyAttributes.dwFlags      = CMD_FLAG_LOCAL | CMD_FLAG_ONLINE;
//    attMyAttributes.ulNumTopCmds = g_ulNumOfTopCmds;
//    attMyAttributes.pTopCmds     = (CMD_ENTRY (*)[])&g_TopCmds;
    attMyAttributes.ulNumGroups  = g_ulRasDiagNumGroups;
    attMyAttributes.pCmdGroups   = (CMD_GROUP_ENTRY (*)[])&g_RasDiagCmdGroups;
    attMyAttributes.pfnDumpFn    = RasDiagDump;

    dwErr = RegisterContext(&attMyAttributes);

    return dwErr;
}

DWORD
RasDiagDumpScriptHeader()
{
    DisplayMessage(g_hModule, MSG_RASDIAG_SCRIPTHEADER);
    DisplayMessageT(DMP_RASDIAG_PUSHD);

    return NO_ERROR;
}

DWORD
RasDiagDumpScriptFooter()
{
    DisplayMessageT(DMP_RAS_POPD);
    DisplayMessage(g_hModule, MSG_RASDIAG_SCRIPTFOOTER);

    return NO_ERROR;
}

DWORD
WINAPI
RasDiagDump(
    IN LPCWSTR pwszRouter,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwArgCount,
    IN LPCVOID pvData)
{
    RasDiagDumpScriptHeader();

    TraceDumpConfig();
    DisplayMessageT(MSG_NEWLINE);
    TraceDumpModem();
    DisplayMessageT(MSG_NEWLINE);
    TraceDumpCm();
    DisplayMessageT(MSG_NEWLINE);
    TraceDumpAuditing();
    DisplayMessageT(MSG_NEWLINE);

    RasDiagDumpScriptFooter();

    return NO_ERROR;
}

DWORD
RasDiagHandleSetTraceAll(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR, dwEnable;
    TOKEN_VALUE rgEnumState[] =
    {
        {TOKEN_DISABLED, 0},
        {TOKEN_ENABLED,  1},
        {TOKEN_CLEARED,  2}
    };
    RASMON_CMD_ARG pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_STATE, TRUE, FALSE},
            rgEnumState,
            sizeof(rgEnumState) / sizeof(*rgEnumState),
            NULL
        }
    };

    do
    {
        //
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        //
        // Get EnumState
        //
        dwEnable = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        if (dwEnable != 2)
        {
            DiagSetAll(dwEnable ? TRUE : FALSE, TRUE);
        }
        else
        {
            DiagClearAll(TRUE);
        }

    } while (FALSE);

    return dwErr;
}

DWORD
RasDiagHandleShowTraceAll(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        //
        // Verify zero args
        //
        if ((dwArgCount - dwCurrentIndex) > 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        TraceShowAll();

    } while (FALSE);

    return dwErr;
}

DWORD
RasDiagHandleSetModemTrace(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR, dwEnable;
    TOKEN_VALUE rgEnumState[] =
    {
        {TOKEN_DISABLED, 0},
        {TOKEN_ENABLED,  1},
    };
    RASMON_CMD_ARG pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_STATE, TRUE, FALSE},
            rgEnumState,
            sizeof(rgEnumState) / sizeof(*rgEnumState),
            NULL
        }
    };

    do
    {
        //
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        //
        // Get EnumState
        //
        dwEnable = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        if (TraceEnableDisableModem(dwEnable ? TRUE : FALSE))
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SET_MODEMTRACE_OK);
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_RASDIAG_SET_MODEMTRACE_FAIL);
        }

    } while (FALSE);

    return dwErr;
}

DWORD
RasDiagHandleShowModemTrace(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        //
        // Verify zero args
        //
        if ((dwArgCount - dwCurrentIndex) > 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (TraceShowModem())
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SHOW_MODEMTRACE_ENABLED);
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_RASDIAG_SHOW_MODEMTRACE_DISABLED);
        }

    } while (FALSE);

    return dwErr;
}

DWORD
RasDiagHandleSetCmTrace(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR, dwEnable;
    TOKEN_VALUE rgEnumState[] =
    {
        {TOKEN_DISABLED, 0},
        {TOKEN_ENABLED,  1},
    };
    RASMON_CMD_ARG pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_STATE, TRUE, FALSE},
            rgEnumState,
            sizeof(rgEnumState) / sizeof(*rgEnumState),
            NULL
        }
    };

    do
    {
        //
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        //
        // Get EnumState
        //
        dwEnable = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        if (TraceEnableDisableCm(dwEnable ? TRUE : FALSE))
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SET_CMTRACE_OK);
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_RASDIAG_SET_CMTRACE_FAIL);
        }

    } while (FALSE);

    return dwErr;
}

DWORD
RasDiagHandleShowCmTrace(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        //
        // Verify zero args
        //
        if ((dwArgCount - dwCurrentIndex) > 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (TraceShowCm())
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SHOW_CMTRACE_ENABLED);
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_RASDIAG_SHOW_CMTRACE_DISABLED);
        }

    } while (FALSE);

    return dwErr;
}

DWORD
RasDiagHandleSetAuditing(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR, dwEnable;
    TOKEN_VALUE rgEnumState[] =
    {
        {TOKEN_DISABLED, 0},
        {TOKEN_ENABLED,  1},
    };
    RASMON_CMD_ARG pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_STATE, TRUE, FALSE},
            rgEnumState,
            sizeof(rgEnumState) / sizeof(*rgEnumState),
            NULL
        }
    };

    do
    {
        //
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        //
        // Get EnumState
        //
        dwEnable = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        if (TraceEnableDisableAuditing(FALSE, dwEnable ? TRUE : FALSE))
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SET_AUDITING_OK);
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_RASDIAG_SET_AUDITING_FAIL);
        }

    } while (FALSE);

    return dwErr;
}

DWORD
RasDiagHandleShowAuditing(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR;

    do
    {
        //
        // Verify zero args
        //
        if ((dwArgCount - dwCurrentIndex) > 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (TraceEnableDisableAuditing(TRUE, FALSE))
        {
            DisplayMessage(g_hModule, MSG_RASDIAG_SHOW_AUDITING_ENABLED);
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_RASDIAG_SHOW_AUDITING_DISABLED);
        }

    } while (FALSE);

    return dwErr;
}

VOID
RasDiagHandleShowLogsCb(
    IN REPORT_INFO* pInfo)
{
    PrintTableOfContents(pInfo, SHOW_LOGS);
    TraceCollectAll(pInfo);

    return;
}

DWORD
RasDiagHandleShowLogs(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    return RasDiagHandleReport(
                RasDiagHandleShowLogsCb,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

VOID
RasDiagHandleShowAllCb(
    IN REPORT_INFO* pInfo)
{
    PrintTableOfContents(pInfo, SHOW_ALL);
    RasDiagShowAll(pInfo);

    return;
}

DWORD
RasDiagHandleShowAll(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    return RasDiagHandleReport(
                RasDiagHandleShowAllCb,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

VOID
RasDiagHandleShowInstallationCb(
    IN REPORT_INFO* pInfo)
{
    PrintTableOfContents(pInfo, SHOW_INSTALL);
    RasDiagShowInstallation(pInfo);

    return;
}

DWORD
RasDiagHandleShowInstallation(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    return RasDiagHandleReport(
                RasDiagHandleShowInstallationCb,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

VOID
RasDiagHandleShowConfigurationCb(
    IN REPORT_INFO* pInfo)
{
    PrintTableOfContents(pInfo, SHOW_CONFIG);
    RasDiagShowConfiguration(pInfo);

    return;
}

DWORD
RasDiagHandleShowConfiguration(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    return RasDiagHandleReport(
                RasDiagHandleShowConfigurationCb,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
RasDiagHandleRepairRas(
    IN LPCWSTR pwszMachine,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    IN DWORD dwFlags,
    IN LPCVOID pvData,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR;
    PWCHAR pszFilePath = NULL;
    HRESULT hr = S_OK;
    RASMON_CMD_ARG pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_ANSWERFILE, FALSE, FALSE},
            NULL,
            0,
            NULL
        }
    };

    do
    {
        //
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        //
        // Check for answer file
        //
        if (RASMON_CMD_ARG_Present(&pArgs[0]))
        {
            pszFilePath = RasDiagVerifyAnswerFile(
                            RASMON_CMD_ARG_GetPsz(&pArgs[0]));
            if (!pszFilePath)
            {
                DisplayMessage(g_hModule, EMSG_RASDIAG_BAD_ANSWERFILE);
                break;
            }
        }

        hr = HrUninstallRas();
        if (SUCCEEDED(hr))
        {
            hr = HrInstallRas(pszFilePath);
            if (SUCCEEDED(hr))
            {
                DisplayMessage(g_hModule, MSG_RASDIAG_REPAIR_SUCCESS_REBOOT);
            }
            else
            {
                DisplayMessage(g_hModule, EMSG_RASDIAG_REPAIR_FAIL);
            }
        }
        else
        {
            DisplayMessage(g_hModule, EMSG_RASDIAG_REPAIR_FAIL);
        }

    } while (FALSE);
    //
    // Cleanup
    //
    RutlFree(pszFilePath);

    return dwErr;
}

DWORD
RasDiagHandleReport(
    IN RASDIAG_HANDLE_REPORT_FUNC_CB pCallback,
    IN OUT LPWSTR* ppwcArguments,
    IN DWORD dwCurrentIndex,
    IN DWORD dwArgCount,
    OUT BOOL* pbDone)
{
    DWORD dwErr = NO_ERROR, dwCompress = 0, dwDest;
    WCHAR wszTempFileName[MAX_PATH + 1];
    PWCHAR pwszDest = NULL, pwszCabFile = NULL, pwszTempFile = NULL;
    REPORT_INFO ReportInfo;
    BUFFER_WRITE_FILE Buff;

    TOKEN_VALUE rgEnumDest[] =
    {
        {TOKEN_FILE,  0},
        {TOKEN_EMAIL, 1},
    };

    TOKEN_VALUE rgEnumCompress[] =
    {
        {TOKEN_DISABLED, 0},
        {TOKEN_ENABLED,  1},
    };

    TOKEN_VALUE rgEnumVerbose[] =
    {
        {TOKEN_DISABLED, 0},
        {TOKEN_ENABLED,  1},
    };

    RASMON_CMD_ARG pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_TYPE, TRUE, FALSE},
            rgEnumDest,
            sizeof(rgEnumDest) / sizeof(*rgEnumDest),
            NULL
        },
        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_DESTINATION, TRUE, FALSE},
            NULL,
            0,
            NULL
        },
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_COMPRESSION, FALSE, FALSE},
            rgEnumCompress,
            sizeof(rgEnumCompress) / sizeof(*rgEnumCompress),
            NULL
        },
        {
            RASMONTR_CMD_TYPE_DWORD,
            {TOKEN_HOURS, FALSE, FALSE},
            NULL,
            0,
            NULL
        },
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_VERBOSE, FALSE, FALSE},
            rgEnumVerbose,
            sizeof(rgEnumVerbose) / sizeof(*rgEnumVerbose),
            NULL
        },
    };

    do
    {
        if (!pCallback)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        //
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        //
        // Init the Report Information structure
        //
        ZeroMemory(&ReportInfo, sizeof(REPORT_INFO));
        ZeroMemory(&Buff, sizeof(BUFFER_WRITE_FILE));
        ReportInfo.fDisplay = TRUE;
        ReportInfo.pBuff = &Buff;

        dwDest = RASMON_CMD_ARG_GetEnum(&pArgs[0]);

        pwszDest = RASMON_CMD_ARG_GetPsz(&pArgs[1]);
        if (!pwszDest)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (RASMON_CMD_ARG_Present(&pArgs[2]))
        {
            dwCompress = RASMON_CMD_ARG_GetEnum(&pArgs[2]);
        }
        else if (dwDest)
        {
            //
            // def is to compress for email
            //
            dwCompress = 1;
        }

        if (RASMON_CMD_ARG_Present(&pArgs[3]))
        {
            ReportInfo.dwHours = RASMON_CMD_ARG_GetDword(&pArgs[3]);
            if (ReportInfo.dwHours < 1 ||
                ReportInfo.dwHours > 24)
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }

        if (RASMON_CMD_ARG_Present(&pArgs[4]) &&
            RASMON_CMD_ARG_GetDword(&pArgs[4]))
        {
            ReportInfo.fVerbose = TRUE;
        }
        //
        // email or display
        //
        if (dwDest)
        {
            dwErr = CopyTempFileName(wszTempFileName);
            BREAK_ON_DWERR(dwErr);

            pwszTempFile = CreateHtmFileName(wszTempFileName);
            if (!pwszTempFile)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        else
        {
            pwszTempFile = CreateHtmFileName(pwszDest);
            if (!pwszTempFile)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        if (CreateReportFile(ReportInfo.pBuff, pwszTempFile))
        {
            DisplayMessage(
                g_hModule,
                EMSG_RASDIAG_REPORT_FAIL,
                pwszTempFile);
            break;
        }

        PrintHtmlHeader(ReportInfo.pBuff);
        //
        // Call the callback
        //
        pCallback(&ReportInfo);

        PrintHtmlFooter(ReportInfo.pBuff);
        CloseReportFile(ReportInfo.pBuff);

        if (dwCompress)
        {
            pwszCabFile = CabCompressFile(pwszTempFile);
            if (!pwszCabFile)
            {
                DisplayMessage(
                    g_hModule,
                    EMSG_RASDIAG_REPORT_CAB_FAIL,
                    pwszTempFile);
                break;
            }
        }

        if (dwDest)
        {
            if (!MapiSendMail(
                    pwszDest,
                    pwszCabFile ? pwszCabFile : pwszTempFile))
            {
                DisplayMessage(
                    g_hModule,
                    MSG_RASDIAG_REPORT_EMAIL_OK,
                    pwszDest);
            }
            else
            {
                DisplayMessage(
                    g_hModule,
                    EMSG_RASDIAG_REPORT_EMAIL_FAIL,
                    pwszDest);
            }

            if (pwszCabFile)
            {
                DeleteFile(pwszCabFile);
            }
            DeleteFile(pwszTempFile);
        }
        else
        {
            DisplayMessage(
                g_hModule,
                MSG_RASDIAG_REPORT_OK,
                pwszCabFile ? pwszCabFile : pwszTempFile);
            if (pwszCabFile)
            {
                DeleteFile(pwszTempFile);
            }
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszCabFile);
    RutlFree(pwszTempFile);
    RutlFree(pwszDest);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasdiag.h ===
/*
    File:   rasdiag.h

    Definitions for the 'ras diag' sub context

    07/26/01
*/

#ifndef __RASDIAG_H
#define __RASDIAG_H

#define RASDIAG_VERSION 1
//
// 90fe6cfc-b6a2-463b-aa12-25e615ec3c66
//
#define RASDIAG_GUID \
{0x90fe6cfc, 0xb6a2, 0x463b, {0xaa, 0x12, 0x25, 0xe6, 0x15, 0xec, 0x3c, 0x66}}

typedef
VOID
(*RASDIAG_HANDLE_REPORT_FUNC_CB)(
    IN REPORT_INFO* pInfo);

//
// Command handlers
//
NS_HELPER_START_FN RasDiagStartHelper;
NS_CONTEXT_DUMP_FN RasDiagDump;

FN_HANDLE_CMD RasDiagHandleSetTraceAll;
FN_HANDLE_CMD RasDiagHandleSetModemTrace;
FN_HANDLE_CMD RasDiagHandleSetCmTrace;
FN_HANDLE_CMD RasDiagHandleSetAuditing;
FN_HANDLE_CMD RasDiagHandleShowTraceAll;
FN_HANDLE_CMD RasDiagHandleShowModemTrace;
FN_HANDLE_CMD RasDiagHandleShowCmTrace;
FN_HANDLE_CMD RasDiagHandleShowAuditing;
FN_HANDLE_CMD RasDiagHandleShowLogs;
FN_HANDLE_CMD RasDiagHandleShowAll;
FN_HANDLE_CMD RasDiagHandleShowInstallation;
FN_HANDLE_CMD RasDiagHandleShowConfiguration;
FN_HANDLE_CMD RasDiagHandleRepairRas;

#endif //__RASDIAG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasat.c ===
/*
    File:   rasat.h
    
    The 'remoteaccess at' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasat.h"

// The guid for this context
//
GUID g_RasAtGuid = RASAT_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// The commands supported in this context
//
CMD_ENTRY  g_RasAtSetCmdTable[] =
{
    CREATE_CMD_ENTRY(RASAT_SET_NEGOTIATION,RasAtHandleSetNegotiation),
};

CMD_ENTRY  g_RasAtShowCmdTable[] =
{
    CREATE_CMD_ENTRY(RASAT_SHOW_CONFIG,    RasAtHandleShow),
};

CMD_GROUP_ENTRY g_RasAtCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_RasAtSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_RasAtShowCmdTable),
};

ULONG g_ulRasAtNumGroups = sizeof(g_RasAtCmdGroups)/sizeof(CMD_GROUP_ENTRY);

//
// Flags that control how/what info is read/written
// in the RASAT_CB structure
//
#define RASAT_F_EnableIn    0x1

//
// Control block for remoteaccess at configuration
//
typedef struct _RASAT_CB
{
    DWORD dwFlags;      // See RASAT_F_* values
    BOOL bEnableIn;

} RASAT_CB;

//
// At specific registry parameters
//
WCHAR pszAtParams[]                = L"AppleTalk";

//
// Prototypes of functions that manipulate the 
// RASAT_CB structures
//
DWORD
RasAtCbCleanup(
    IN RASAT_CB* pConfig);

DWORD
RasAtCbCreateDefault(
    OUT RASAT_CB** ppConfig);

DWORD
RasAtCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey);

DWORD
RasAtCbRead(
    IN  LPCWSTR pszServer,
    OUT RASAT_CB* pConfig);

DWORD
RasAtCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASAT_CB* pConfig);

//
// Entry called by rasmontr to register this context
//
DWORD
WINAPI
RasAtStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"appletalk";
    attMyAttributes.guidHelper  = g_RasAtGuid;
    attMyAttributes.dwVersion   = RASAT_VERSION;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulRasAtNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_RasAtCmdGroups;
    attMyAttributes.pfnDumpFn   = RasAtDump;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
RasAtDisplayConfig(
    IN  BOOL bReport)
{
    DWORD dwErr = NO_ERROR;
    RASAT_CB* pConfig = NULL;
    PWCHAR pszEnabled = NULL;

    do
    {
        // Get a default config blob
        //
        dwErr = RasAtCbCreateDefault(&pConfig);
        BREAK_ON_DWERR( dwErr );

        // Read in all of the values
        //
        pConfig->dwFlags = RASAT_F_EnableIn;
        dwErr = RasAtCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR( dwErr );

        if (bReport)
        {
            pszEnabled =
                RutlStrDup(pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);

            DisplayMessage(
                g_hModule,
                MSG_RASAT_SERVERCONFIG,
                g_pszServer,
                pszEnabled);
        }
        else
        {
            pszEnabled = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);

            DisplayMessage(
                g_hModule,
                MSG_RASAT_SCRIPTHEADER);

            DisplayMessageT(DMP_RASAT_PUSHD);

            DisplayMessage(
                g_hModule,
                MSG_RASAT_SET_CMD,
                DMP_RASAT_SET_NEGOTIATION,
                pszEnabled);

            DisplayMessageT(DMP_RASAT_POPD);

            DisplayMessage(
                g_hModule,
                MSG_RASAT_SCRIPTFOOTER);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pConfig)
        {
            RasAtCbCleanup(pConfig);
        }
        if (pszEnabled)
        {
            RutlFree(pszEnabled);
        }
    }

    return dwErr;
}

DWORD
WINAPI
RasAtDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    return RasAtDisplayConfig(FALSE);
}

DWORD
RasAtHandleSetNegotiation(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASAT_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALLOW, TRUE}, {TOKEN_DENY, FALSE} };
    RASMON_CMD_ARG  pArgs[] =
    {
        { 
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL 
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);
        
        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASAT_F_EnableIn;
        Config.bEnableIn = dwValue;
        dwErr = RasAtCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasAtHandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule,
            HLP_RASAT_SHOW_CONFIG_EX,
            DMP_RASAT_SHOW_CONFIG);

        return NO_ERROR;
    }

    return RasAtDisplayConfig(TRUE);
}

// 
// Cleans up a config control block
//
DWORD 
RasAtCbCleanup(
    IN RASAT_CB* pConfig)
{
    if (pConfig)
    {
        RutlFree(pConfig);
    }

    return NO_ERROR;
}

//
// Creates a default config control block
//
DWORD 
RasAtCbCreateDefault(
    OUT RASAT_CB** ppConfig)
{
    RASAT_CB* pConfig = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        pConfig = (RASAT_CB*) RutlAlloc(sizeof(RASAT_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pConfig->bEnableIn = TRUE;
        *ppConfig = pConfig;

    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasAtCbCleanup(pConfig);
        }
    }

    return dwErr;
}

//
// Helper function opens the remoteaccess at config registry key
//
DWORD 
RasAtCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszKey[MAX_PATH];

    do
    {
        // Generate the parameters key name
        //
        wsprintfW(
            pszKey,
            L"%s%s",
            pszRemoteAccessParamStub,
            pszAtParams);

        // Open the parameters keys
        //
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    pszKey,
                    0,
                    KEY_READ | KEY_WRITE,
                    phKey);
        BREAK_ON_DWERR( dwErr );

    } while (FALSE);

    return dwErr;
}

//
// Functions that manipulate RASAT_CB's
//
DWORD 
RasAtCbRead(
    IN  LPCWSTR pszServer,
    OUT RASAT_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasAtCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );

        // Load the params from the registry 
        //
        if (pConfig->dwFlags & RASAT_F_EnableIn)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszEnableIn,
                        &pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

DWORD 
RasAtCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASAT_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasAtCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );

        // Write out the params to the registry 
        //
        if (pConfig->dwFlags & RASAT_F_EnableIn)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszEnableIn,
                        pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasflag.h ===
FN_HANDLE_CMD    HandleRasflagSet;
FN_HANDLE_CMD    HandleRasflagShow;

FN_HANDLE_CMD    HandleRasflagAuthmodeSet;
FN_HANDLE_CMD    HandleRasflagAuthmodeShow;

FN_HANDLE_CMD    HandleRasflagAuthtypeAdd;
FN_HANDLE_CMD    HandleRasflagAuthtypeDel;
FN_HANDLE_CMD    HandleRasflagAuthtypeShow;

FN_HANDLE_CMD    HandleRasflagLinkAdd;
FN_HANDLE_CMD    HandleRasflagLinkDel;
FN_HANDLE_CMD    HandleRasflagLinkShow;

FN_HANDLE_CMD    HandleRasflagMlinkAdd;
FN_HANDLE_CMD    HandleRasflagMlinkDel;
FN_HANDLE_CMD    HandleRasflagMlinkShow;

DWORD
RasflagDumpConfig(
    IN  HANDLE hFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasflag.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    rasflag.c

Abstract:

    Handlers for ras commands

Revision History:

    pmay

--*/

#include "precomp.h"
#pragma hdrstop

static const WCHAR g_pszRegValServerFlags[]   = L"ServerFlags";
static const WCHAR g_pszRegKeyServerFlags[]   = 
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters";

//
// Defines data that all server flag commands deal with
//
typedef struct _RASFLAG_DATA
{  
    HKEY hkFlags;
    DWORD dwServerFlags;
    
} RASFLAG_DATA;

DWORD
RasflagOpen(
    OUT PHANDLE phRasFlag);
    
DWORD
RasflagClose(
    IN HANDLE hRasFlag);
    
DWORD
RasflagRead(
    IN  HANDLE hRasFlag,
    OUT LPDWORD lpdwFlags);

DWORD
RasflagWrite(
    IN HANDLE hRasFlag,
    IN DWORD dwFlags);

DWORD
RasflagAuthtypeDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd);
    
DWORD
RasflagLinkDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd);
    
DWORD
RasflagMlinkDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd);
    
DWORD
RasflagOpen(
    OUT PHANDLE phRasFlag)
{
    RASFLAG_DATA* pData = NULL;
    DWORD dwErr = NO_ERROR, dwType, dwSize;

    do
    {
        // Alloc the return value
        //
        pData = (RASFLAG_DATA*) RutlAlloc(sizeof(RASFLAG_DATA), TRUE);
        if (pData == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        dwErr = RegOpenKeyExW(
                    g_pServerInfo->hkMachine,
                    (PWCHAR) g_pszRegKeyServerFlags,
                    0,
                    KEY_READ | KEY_SET_VALUE,
                    &(pData->hkFlags));
        BREAK_ON_DWERR(dwErr);                    
                    
        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);
        dwErr = RegQueryValueExW(
                    pData->hkFlags,
                    (PWCHAR) g_pszRegValServerFlags,
                    NULL,
                    &dwType,
                    (LPBYTE)&(pData->dwServerFlags),
                    &dwSize);
        BREAK_ON_DWERR(dwErr);                    

        // Assign the return value
        //
        *phRasFlag = (HANDLE)pData;        
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasflagClose(pData);
        }
    }

    return dwErr;
}

DWORD
RasflagClose(
    IN HANDLE hRasFlag)
{
    RASFLAG_DATA* pData = (RASFLAG_DATA*)hRasFlag;
    
    if (pData)
    {
        if (pData->hkFlags)
        {
            RegCloseKey(pData->hkFlags);
        }
        RutlFree(pData);
    }

    return NO_ERROR;
}

DWORD
RasflagRead(
    IN  HANDLE hRasFlag,
    OUT LPDWORD lpdwFlags)
{
    RASFLAG_DATA* pData = (RASFLAG_DATA*)hRasFlag;

    *lpdwFlags = pData->dwServerFlags;

    return NO_ERROR;
}

DWORD
RasflagWrite(
    IN HANDLE hRasFlag,
    IN DWORD dwFlags)
{
    RASFLAG_DATA* pData = (RASFLAG_DATA*)hRasFlag;
    DWORD dwErr;

    dwErr = RegSetValueEx(
                pData->hkFlags,
                (PWCHAR) g_pszRegValServerFlags,
                0,
                REG_DWORD,
                (CONST BYTE*)&dwFlags,
                sizeof(DWORD));
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    pData->dwServerFlags = dwFlags;

    return NO_ERROR;
}

//
// Dumps domain related configuration
//
DWORD
RasflagDumpConfig(
    IN  HANDLE hFile
    )
{
    DWORD dwErr = NO_ERROR, dwServerFlags = 0, i;
    HANDLE hRasflag = NULL;
    PWCHAR pszFlag = NULL, pszEnable = NULL, pszCmd = NULL;
    BOOL bEnabled;

    do 
    {
        // Get the server flags info
        //
        dwErr = RasflagOpen( &hRasflag);
        BREAK_ON_DWERR(dwErr);                    

        // Read in the current flags
        //
        dwErr = RasflagRead(hRasflag, &dwServerFlags);
        BREAK_ON_DWERR(dwErr);

        // Dump the command to set the authentication mode
        //
        {
            PWCHAR pszToken;
            
            if (dwServerFlags & PPPCFG_AllowNoAuthentication)
            {
                pszToken = TOKEN_BYPASS;
            }
            else if (dwServerFlags & PPPCFG_AllowNoAuthOnDCPorts)
            {
                pszToken = TOKEN_NODCC;
            }
            else
            {
                pszToken = TOKEN_STANDARD;
            }

            pszCmd = RutlAssignmentFromTokens(
                        g_hModule, 
                        TOKEN_MODE,
                        pszToken);
            if (pszCmd == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            DisplayMessage(    
                g_hModule, 
                MSG_RASFLAG_DUMP2, 
                DMP_RASFLAG_AUTHMODE_SET,
                pszCmd);

            RutlFree(pszCmd);
        }
        
        // Dump the commands to set the authentication type
        //
        {
            RasflagAuthtypeDump(TOKEN_PAP, FALSE);
            RasflagAuthtypeDump(TOKEN_SPAP, FALSE);
            RasflagAuthtypeDump(TOKEN_MD5CHAP, FALSE);
            RasflagAuthtypeDump(TOKEN_MSCHAP, FALSE);
            RasflagAuthtypeDump(TOKEN_MSCHAP2, FALSE);
            RasflagAuthtypeDump(TOKEN_EAP, FALSE);

            if (dwServerFlags & PPPCFG_NegotiatePAP)
            {
                RasflagAuthtypeDump(TOKEN_PAP, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateSPAP)
            {
                RasflagAuthtypeDump(TOKEN_SPAP, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateMD5CHAP)
            {
                RasflagAuthtypeDump(TOKEN_MD5CHAP, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateMSCHAP)
            {
                RasflagAuthtypeDump(TOKEN_MSCHAP, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateStrongMSCHAP)
            {
                RasflagAuthtypeDump(TOKEN_MSCHAP2, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateEAP)
            {
                RasflagAuthtypeDump(TOKEN_EAP, TRUE);
            }
        }            
        
        // Dump the commands to set the link options
        //
        {
            RasflagLinkDump(TOKEN_SWC, FALSE);
            RasflagLinkDump(TOKEN_LCP, FALSE);

            if (dwServerFlags & PPPCFG_UseSwCompression)
            {
                RasflagLinkDump(TOKEN_SWC, TRUE);
            }
            if (dwServerFlags & PPPCFG_UseLcpExtensions)
            {
                RasflagLinkDump(TOKEN_LCP, TRUE);
            }
        }            
        
        // Dump the commands to set the multilink options
        //
        {
            RasflagMlinkDump(TOKEN_MULTI, FALSE);
            RasflagMlinkDump(TOKEN_BACP, FALSE);

            if (dwServerFlags & PPPCFG_NegotiateMultilink)
            {
                RasflagMlinkDump(TOKEN_MULTI, TRUE);
            }
            if (dwServerFlags & PPPCFG_NegotiateBacp)
            {
                RasflagMlinkDump(TOKEN_BACP, TRUE);
            }
        }            
        
    } while (FALSE);        

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
HandleRasflagAuthmodeSet(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD           dwErr = NO_ERROR, dwFlag, dwServerFlags;
    HANDLE          hRasflag = NULL;
    TOKEN_VALUE     rgEnum[] = 
    {
        {TOKEN_STANDARD, 0},
        {TOKEN_NODCC,    PPPCFG_AllowNoAuthOnDCPorts},
        {TOKEN_BYPASS,   PPPCFG_AllowNoAuthentication}
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_MODE,   TRUE,   FALSE}, 
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };        

    do 
    {
        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        
        // Get arguments
        //
        dwFlag = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwServerFlags);
        BREAK_ON_DWERR(dwErr);                    

        // Modify the server flags accordingly
        //
        switch (dwFlag)
        {
            case 0:
                dwServerFlags &= ~PPPCFG_AllowNoAuthOnDCPorts;
                dwServerFlags &= ~PPPCFG_AllowNoAuthentication;
                break;
                
            case PPPCFG_AllowNoAuthOnDCPorts:
                dwServerFlags |=  PPPCFG_AllowNoAuthOnDCPorts;
                dwServerFlags &= ~PPPCFG_AllowNoAuthentication;
                break;
                
            case PPPCFG_AllowNoAuthentication:
                dwServerFlags &= ~PPPCFG_AllowNoAuthOnDCPorts;
                dwServerFlags |=  PPPCFG_AllowNoAuthentication;
                break;
        }

        dwErr = RasflagWrite(hRasflag, dwServerFlags);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);        

    // Cleanup
    //
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }

    return dwErr;
}
    
DWORD
HandleRasflagAuthmodeShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwRasFlags, dwMessage;
    HANDLE hRasflag = NULL;

    do
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwRasFlags);
        BREAK_ON_DWERR(dwErr);

        // Determine the message to print
        //
        if (dwRasFlags & PPPCFG_AllowNoAuthentication)
        {
            dwMessage = MSG_RASFLAG_AUTHMODE_BYPASS;
        }
        else if (dwRasFlags & PPPCFG_AllowNoAuthOnDCPorts)
        {
            dwMessage = MSG_RASFLAG_AUTHMODE_NODCC;
        }
        else
        {
            dwMessage = MSG_RASFLAG_AUTHMODE_STANDARD;
        }

        DisplayMessage(g_hModule, dwMessage);
        
    } while (FALSE);

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
HandleRasflagAuthtypeAddDel(
    IN OUT  LPWSTR *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      BOOL    *pbDone,
    IN      BOOL    bAdd
    )
{
    DWORD           dwErr = NO_ERROR, dwFlag, dwServerFlags;
    HANDLE          hRasflag = NULL;
    TOKEN_VALUE     rgEnum[] = 
    {
        {TOKEN_PAP,       PPPCFG_NegotiatePAP},
        {TOKEN_SPAP,      PPPCFG_NegotiateSPAP},
        {TOKEN_MD5CHAP,   PPPCFG_NegotiateMD5CHAP},
        {TOKEN_MSCHAP,    PPPCFG_NegotiateMSCHAP},
        {TOKEN_MSCHAP2,   PPPCFG_NegotiateStrongMSCHAP},
        {TOKEN_EAP,       PPPCFG_NegotiateEAP},
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_TYPE,   TRUE,   FALSE}, 
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };        

    do 
    {
        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        
        // Get arguments
        //
        dwFlag = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwServerFlags);
        BREAK_ON_DWERR(dwErr);                    

        // Modify the server flags accordingly
        //
        if (bAdd)
        {
            dwServerFlags |= dwFlag;
        }
        else
        {
            dwServerFlags &= ~dwFlag;
        }

        dwErr = RasflagWrite(hRasflag, dwServerFlags);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);        

    // Cleanup
    //
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }

    return dwErr;
}

DWORD
HandleRasflagAuthtypeAdd(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagAuthtypeAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TRUE);
}


DWORD
HandleRasflagAuthtypeDel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagAuthtypeAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                FALSE);
}

DWORD
HandleRasflagAuthtypeShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwRasFlags, dwMessage;
    HANDLE hRasflag = NULL;

    do
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwRasFlags);
        BREAK_ON_DWERR(dwErr);

        // Display the header
        //
        DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_HEADER);

        // Determine the types to print out
        //
        if (dwRasFlags & PPPCFG_NegotiatePAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_PAP);
        }
        if (dwRasFlags & PPPCFG_NegotiateSPAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_SPAP);
        }
        if (dwRasFlags & PPPCFG_NegotiateMD5CHAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_MD5CHAP);
        }
        if (dwRasFlags & PPPCFG_NegotiateMSCHAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_MSCHAP);
        }
        if (dwRasFlags & PPPCFG_NegotiateStrongMSCHAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_MSCHAP2);
        }
        if (dwRasFlags & PPPCFG_NegotiateEAP)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_AUTHTYPE_EAP);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
HandleRasflagLinkAddDel(
    IN OUT LPWSTR *ppwcArguments,
    IN     DWORD   dwCurrentIndex,
    IN     DWORD   dwArgCount,
    IN     BOOL    *pbDone,
    IN     BOOL    bAdd
    )
{
    DWORD           dwErr = NO_ERROR, dwFlag, dwServerFlags;
    HANDLE          hRasflag = NULL;
    TOKEN_VALUE     rgEnum[] = 
    {
        {TOKEN_SWC,       PPPCFG_UseSwCompression},
        {TOKEN_LCP,       PPPCFG_UseLcpExtensions},
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_TYPE,   TRUE,   FALSE}, 
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };        

    do 
    {
        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        
        // Get arguments
        //
        dwFlag = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwServerFlags);
        BREAK_ON_DWERR(dwErr);                    

        // Modify the server flags accordingly
        //
        if (bAdd)
        {
            dwServerFlags |= dwFlag;
        }
        else
        {
            dwServerFlags &= ~dwFlag;
        }

        dwErr = RasflagWrite(hRasflag, dwServerFlags);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);        

    // Cleanup
    //
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }

    return dwErr;
}

DWORD
HandleRasflagLinkAdd(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagLinkAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TRUE);
}


DWORD
HandleRasflagLinkDel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagLinkAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                FALSE);
}

DWORD
HandleRasflagLinkShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwRasFlags, dwMessage;
    HANDLE hRasflag = NULL;

    do
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwRasFlags);
        BREAK_ON_DWERR(dwErr);

        // Display the header
        //
        DisplayMessage(g_hModule, MSG_RASFLAG_LINK_HEADER);

        // Determine the types to print out
        //
        if (dwRasFlags & PPPCFG_UseSwCompression)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_LINK_SWC);
        }
        if (dwRasFlags & PPPCFG_UseLcpExtensions)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_LINK_LCP);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
HandleRasflagMlinkAddDel(
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      BOOL    *pbDone,
    IN      BOOL    bAdd
    )
{
    DWORD           dwErr = NO_ERROR, dwFlag, dwServerFlags;
    HANDLE          hRasflag = NULL;
    TOKEN_VALUE     rgEnum[] = 
    {
        {TOKEN_MULTI,       PPPCFG_NegotiateMultilink},
        {TOKEN_BACP,        PPPCFG_NegotiateBacp},
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_ENUM, 
            {TOKEN_TYPE,   TRUE,   FALSE}, 
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };        

    do 
    {
        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);
        
        // Get arguments
        //
        dwFlag = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwServerFlags);
        BREAK_ON_DWERR(dwErr);                    

        // Modify the server flags accordingly
        //
        if (bAdd)
        {
            dwServerFlags |= dwFlag;
        }
        else
        {
            dwServerFlags &= ~dwFlag;
        }

        dwErr = RasflagWrite(hRasflag, dwServerFlags);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);        

    // Cleanup
    //
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }

    return dwErr;
}

DWORD
HandleRasflagMlinkAdd(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagMlinkAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TRUE);
}


DWORD
HandleRasflagMlinkDel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleRasflagMlinkAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                FALSE);
}

DWORD
HandleRasflagMlinkShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwRasFlags, dwMessage;
    HANDLE hRasflag = NULL;

    do
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        // Read in the ras flags
        //
        dwErr = RasflagOpen(&hRasflag);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasflagRead(
                    hRasflag,
                    &dwRasFlags);
        BREAK_ON_DWERR(dwErr);

        // Display the header
        //
        DisplayMessage(g_hModule, MSG_RASFLAG_MLINK_HEADER);

        // Determine the types to print out
        //
        if (dwRasFlags & PPPCFG_NegotiateMultilink)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_MLINK_MULTI);
        }
        if (dwRasFlags & PPPCFG_NegotiateBacp)
        {
            DisplayMessage(g_hModule, MSG_RASFLAG_MLINK_BACP);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hRasflag)
        {
            RasflagClose(hRasflag);
        }
    }
    
    return dwErr;
}

DWORD
RasflagAuthtypeDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd)
{
    PWCHAR pszCmd = NULL;

    pszCmd = RutlAssignmentFromTokens(
                g_hModule, 
                TOKEN_TYPE,
                pszToken);
    if (pszCmd == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DisplayMessage(    
        g_hModule, 
        MSG_RASFLAG_DUMP2, 
        (bAdd) ? DMP_RASFLAG_AUTHTYPE_ADD : DMP_RASFLAG_AUTHTYPE_DEL,
        pszCmd);

    RutlFree(pszCmd);

    return NO_ERROR;
}

DWORD
RasflagLinkDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd)
{
    PWCHAR pszCmd = NULL;

    pszCmd = RutlAssignmentFromTokens(
                g_hModule, 
                TOKEN_TYPE,
                pszToken);
    if (pszCmd == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DisplayMessage(    
        g_hModule, 
        MSG_RASFLAG_DUMP2, 
        (bAdd) ? DMP_RASFLAG_LINK_ADD : DMP_RASFLAG_LINK_DEL,
        pszCmd);

    RutlFree(pszCmd);

    return NO_ERROR;
}

DWORD
RasflagMlinkDump(
    IN LPCWSTR pszToken, 
    IN BOOL bAdd)
{
    PWCHAR pszCmd = NULL;

    pszCmd = RutlAssignmentFromTokens(
                g_hModule, 
                TOKEN_TYPE,
                pszToken);
    if (pszCmd == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DisplayMessage(    
        g_hModule, 
        MSG_RASFLAG_DUMP2, 
        (bAdd) ? DMP_RASFLAG_MLINK_ADD : DMP_RASFLAG_MLINK_DEL,
        pszCmd);

    RutlFree(pszCmd);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rashndl.h ===
FN_HANDLE_CMD    HandleRasShowServers;

NS_CONTEXT_DUMP_FN RasDump;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rashndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    rashndl.c

Abstract:

    Handlers for ras commands

Revision History:

    pmay

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
RasDumpScriptHeader(
    IN HANDLE hFile)

/*++

Routine Description:

    Dumps the header of a script to the given file or to the 
    screen if the file is NULL.

--*/

{
    DisplayMessage(g_hModule,
                   MSG_RAS_SCRIPTHEADER);

    DisplayMessageT(DMP_RAS_PUSHD);

    return NO_ERROR;
}

DWORD
RasDumpScriptFooter(
    IN HANDLE hFile)

/*++

Routine Description:

    Dumps the header of a script to the given file or to the 
    screen if the file is NULL.

--*/

{
    DisplayMessageT(DMP_RAS_POPD);

    DisplayMessage(g_hModule,
                   MSG_RAS_SCRIPTFOOTER);

    return NO_ERROR;
}

DWORD
WINAPI
RasDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    // Now that we're all parsed, dump all the config
    //
    RasDumpScriptHeader( NULL );
    RasflagDumpConfig( NULL );
    DisplayMessageT(MSG_NEWLINE);
    UserDumpConfig( NULL );
    DisplayMessageT(MSG_NEWLINE);
    RasDumpScriptFooter( NULL );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasip.c ===
/*
    File:   rasip.h
    
    The 'remoteaccess ip' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasip.h"
#include <winsock2.h>

#define MMAKEIPADDRESS(b1,b2,b3,b4) \
(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4)))

#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)

// The guid for this context
//
GUID g_RasIpGuid = RASIP_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// The commands supported in this context
//
CMD_ENTRY  g_RasIpSetCmdTable[] =
{
    CREATE_CMD_ENTRY(RASIP_SET_NEGOTIATION,RasIpHandleSetNegotiation),
    CREATE_CMD_ENTRY(RASIP_SET_ACCESS,     RasIpHandleSetAccess),
    CREATE_CMD_ENTRY(RASIP_SET_ASSIGNMENT, RasIpHandleSetAssignment),
    CREATE_CMD_ENTRY(RASIP_SET_CALLERSPEC, RasIpHandleSetCallerSpec),
    CREATE_CMD_ENTRY(RASIP_SET_NETBTBCAST, RasIpHandleSetNetbtBcast),
};

CMD_ENTRY  g_RasIpShowCmdTable[] =
{
    CREATE_CMD_ENTRY(RASIP_SHOW_CONFIG,    RasIpHandleShow),
};

CMD_ENTRY  g_RasIpAddCmdTable[] =
{
    CREATE_CMD_ENTRY(RASIP_ADD_RANGE,    RasIpHandleAddRange),
};

CMD_ENTRY  g_RasIpDelCmdTable[] =
{
    CREATE_CMD_ENTRY(RASIP_DEL_RANGE,    RasIpHandleDelRange),
    CREATE_CMD_ENTRY(RASIP_DEL_POOL,     RasIpHandleDelPool),
};

CMD_GROUP_ENTRY g_RasIpCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_RasIpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_RasIpShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,   g_RasIpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DEL,   g_RasIpDelCmdTable),
};

ULONG g_ulRasIpNumGroups = sizeof(g_RasIpCmdGroups)/sizeof(CMD_GROUP_ENTRY);

//
// Flags that control how/what info is read/written
// in the RASIP_CB structure
//
#define RASIP_F_EnableIn    0x1
#define RASIP_F_Access      0x2
#define RASIP_F_Auto        0x4
#define RASIP_F_Pool        0x8
#define RASIP_F_Mask        0x10
#define RASIP_F_CallerSpec  0x20
#define RASIP_F_All         0xFFFF

//
// Reasons for the ras ip pool to be invalid
//
#define RASIP_REASON_BadAddress   0x1
#define RASIP_REASON_BadRange     0x3
#define RASIP_REASON_127          0x4

// 
// RAS pool definition
//
typedef struct _RAS_IPRANGE_NODE
{
    DWORD dwFrom;
    DWORD dwTo;
    struct _RAS_IPRANGE_NODE* pNext;
    
} RAS_IPRANGE_NODE;

typedef struct _RAS_IPPOOL
{
    DWORD dwCount;
    RAS_IPRANGE_NODE* pHead;
    RAS_IPRANGE_NODE* pTail;
    
} RAS_IPPOOL;

//
// Control block for ras ip configuration
//
typedef struct _RASIP_CB
{
    DWORD dwFlags;      // See RASIP_F_* values

    BOOL bEnableIn;
    BOOL bAccess;
    BOOL bAuto;
    RAS_IPPOOL* pPool;
    BOOL bCallerSpec;
    
} RASIP_CB;

//
// Ip specific registry parameters
//
WCHAR pszIpParams[]                = L"Ip";
WCHAR pszIpAddress[]               = L"IpAddress";
WCHAR pszIpMask[]                  = L"IpMask";
WCHAR pszIpClientSpec[]            = L"AllowClientIpAddresses";
WCHAR pszIpUseDhcp[]               = L"UseDhcpAddressing";
WCHAR pszIpFrom[]                  = L"From";
WCHAR pszIpTo[]                    = L"To";
WCHAR pszIpPoolSubKey[]            = L"StaticAddressPool";

//
// Prototypes of functions that manipulate the 
// RASIP_CB structures
//
DWORD
RasIpCbCleanup(
    IN RASIP_CB* pConfig);

DWORD
RasIpCbCreateDefault(
    OUT RASIP_CB** ppConfig);

DWORD
RasIpCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey);

DWORD
RasIpCbRead(
    IN  LPCWSTR pszServer,
    OUT RASIP_CB* pConfig);

DWORD
RasIpCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASIP_CB* pConfig);

DWORD
RasIpPoolReset(
    IN  HKEY hkParams);

DWORD
RasIpPoolRead(
    IN  HKEY hkParams,
    OUT RAS_IPPOOL** ppRanges);

DWORD
RasIpPoolWrite(
    IN  HKEY hkParams,
    IN RAS_IPPOOL* pPool);

DWORD
RasIpPoolAdd(
    IN OUT RAS_IPPOOL* pPool,
    IN     DWORD dwFrom,
    IN     DWORD dwTo);

DWORD
RasIpPoolDel(
    IN OUT RAS_IPPOOL* pPool,
    IN     DWORD dwFrom,
    IN     DWORD dwTo);

DWORD
RasIpPoolCleanup(
    IN RAS_IPPOOL* pPool);

DWORD
RasIpSetNetbtBcast(
    DWORD   dwEnable
    );

BOOL
RasIpShowNetbtBcast(
    VOID
    );

//
// Entry called by rasmontr to register this context
//
DWORD 
WINAPI
RasIpStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext   = L"ip";
    attMyAttributes.guidHelper    = g_RasIpGuid;
    attMyAttributes.dwVersion     = RASIP_VERSION;
    attMyAttributes.dwFlags       = 0;
    attMyAttributes.ulNumTopCmds  = 0;
    attMyAttributes.pTopCmds      = NULL;
    attMyAttributes.ulNumGroups   = g_ulRasIpNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_RasIpCmdGroups;
    attMyAttributes.pfnDumpFn     = RasIpDump;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
RasIpDisplayInvalidPool(
    IN DWORD dwReason
    )
{
    DWORD dwArg = 0;
    PWCHAR pszArg = NULL;
    
    switch (dwReason)
    {
        case RASIP_REASON_BadAddress:
            dwArg = EMSG_RASIP_BAD_ADDRESS;
            break;

        case RASIP_REASON_BadRange:
            dwArg = EMSG_RASIP_BAD_RANGE;
            break;

        case RASIP_REASON_127:
            dwArg = EMSG_RASIP_NETID_127;
            break;

        default:
            dwArg = EMSG_RASIP_BAD_POOL_GENERIC;
            break;
    }

    // Make the argument string
    //
    pszArg = MakeString(g_hModule, dwArg);
    if (pszArg == NULL)
    {
        DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Display the error
    //
    DisplayMessage(
        g_hModule, 
        EMSG_RASIP_INVALID_POOL,
        pszArg);

    // Cleanup
    //
    FreeString(pszArg);

    return NO_ERROR;
}

DWORD 
RasIpDisplayPool(
    IN RASIP_CB* pConfig,
    IN BOOL bReport)
{
    DWORD dwErr = NO_ERROR, i;
    RAS_IPPOOL* pPool = pConfig->pPool;
    RAS_IPRANGE_NODE* pNode = NULL;
    PWCHAR pszFrom = NULL, pszTo = NULL;
    WCHAR pszFromBuf[128], pszToBuf[128];

    if (!pPool)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    do
    {
        pNode = pPool->pHead;
        for (i = 0; i < pPool->dwCount; i++, pNode = pNode->pNext)
        {
            wsprintfW(
                pszFromBuf, 
                L"%d.%d.%d.%d",
                FIRST_IPADDRESS(pNode->dwFrom),
                SECOND_IPADDRESS(pNode->dwFrom),
                THIRD_IPADDRESS(pNode->dwFrom),
                FOURTH_IPADDRESS(pNode->dwFrom));

            wsprintfW(
                pszToBuf, 
                L"%d.%d.%d.%d",
                FIRST_IPADDRESS(pNode->dwTo),
                SECOND_IPADDRESS(pNode->dwTo),
                THIRD_IPADDRESS(pNode->dwTo),
                FOURTH_IPADDRESS(pNode->dwTo));

            if (bReport)
            {
                DisplayMessage(
                    g_hModule,
                    MSG_RASIP_SHOW_POOL,
                    pszFromBuf,
                    pszToBuf);
            }
            else
            {
                pszFrom = RutlAssignmentFromTokens(g_hModule, TOKEN_FROM, pszFromBuf);
                pszTo = RutlAssignmentFromTokens(g_hModule, TOKEN_TO, pszToBuf);
                if (pszFrom == NULL || pszTo == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                DisplayMessage(
                    g_hModule, 
                    MSG_RASIP_ADD_RANGE_CMD, 
                    DMP_RASIP_ADD_RANGE,
                    pszFrom,
                    pszTo);
            }
        }

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszFrom);
        RutlFree(pszTo);
    }

    return dwErr;
}

DWORD
RasIpDisplayConfig(
    IN  BOOL bReport)
{
    DWORD dwErr = NO_ERROR, dwReason;
    RASIP_CB* pConfig = NULL;
    PWCHAR pszPool = NULL, pszAccess = NULL, pszAuto = NULL, pszMask = NULL;
    PWCHAR pszEnabled = NULL, pszCaller = NULL, pszNetbtBcast = NULL;
    do
    {
        // Get a default config blob
        //
        dwErr = RasIpCbCreateDefault(&pConfig);
        BREAK_ON_DWERR( dwErr );

        // Read in all of the values
        //
        pConfig->dwFlags = RASIP_F_All;
        dwErr = RasIpCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR( dwErr );

        if (bReport)
        {
            pszEnabled =
                RutlStrDup(pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess =
                RutlStrDup(pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);
            pszAuto =
                RutlStrDup(pConfig->bAuto ? TOKEN_AUTO : TOKEN_POOL);
            pszCaller =
                RutlStrDup(pConfig->bCallerSpec ? TOKEN_ALLOW : TOKEN_DENY);

            // Whistler bug: 359847 Netsh: move broadcastnameresolution from
            // routing ip to ras ip
            //
            pszNetbtBcast =
                RutlStrDup(RasIpShowNetbtBcast() ? TOKEN_ENABLED :
                    TOKEN_DISABLED);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SERVERCONFIG,
                g_pszServer,
                pszEnabled,
                pszAccess,
                pszAuto,
                pszCaller,
                pszNetbtBcast);

            RasIpDisplayPool(pConfig, bReport);
        }
        else
        {
            pszEnabled = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);
            pszAuto = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_METHOD,
                            pConfig->bAuto ? TOKEN_AUTO : TOKEN_POOL);
            pszCaller = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bCallerSpec ? TOKEN_ALLOW : TOKEN_DENY);

            // Whistler bug: 359847 Netsh: move broadcastnameresolution from
            // routing ip to ras ip
            //
            pszNetbtBcast = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            RasIpShowNetbtBcast() ? TOKEN_ENABLED :
                                TOKEN_DISABLED);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SCRIPTHEADER);

            DisplayMessageT(DMP_RASIP_PUSHD);

            DisplayMessageT(
                DMP_RASIP_DEL_POOL);

            DisplayMessageT(MSG_NEWLINE);
            DisplayMessageT(MSG_NEWLINE);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_NEGOTIATION,
                pszEnabled);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_ACCESS,
                pszAccess);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_CALLERSPEC,
                pszCaller);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_NETBTBCAST,
                pszNetbtBcast);

            if (! pConfig->bAuto)
            {
                RasIpDisplayPool(pConfig, bReport);
            }

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SET_CMD,
                DMP_RASIP_SET_ASSIGNMENT,
                pszAuto);

            DisplayMessageT(DMP_RASIP_POPD);

            DisplayMessage(
                g_hModule,
                MSG_RASIP_SCRIPTFOOTER);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pConfig)
        {
            RasIpCbCleanup(pConfig);
        }
        if (pszEnabled)
        {
            RutlFree(pszEnabled);
        }
        if (pszAccess)
        {
            RutlFree(pszAccess);
        }
        if (pszAuto)
        {
            RutlFree(pszAuto);
        }
        if (pszCaller)
        {
            RutlFree(pszCaller);
        }
        if (pszNetbtBcast)
        {
            RutlFree(pszNetbtBcast);
        }
        if (pszPool)
        {
            RutlFree(pszPool);
        }
        if (pszMask)
        {
            RutlFree(pszMask);
        }
    }

    return dwErr;
}

DWORD
WINAPI
RasIpDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    return RasIpDisplayConfig(FALSE);
}

// 
// Returns NO_ERROR if the given address is a valid IP pool.
// The offending component is returned in lpdwErrReason.  
// See RASIP_F_* values
//
DWORD
RasIpValidateRange(
    IN  DWORD dwFrom,
    IN  DWORD dwTo,
    OUT LPDWORD lpdwErrReason
    )
{
    DWORD dwLowIp, dwHighIp;

    // Initialize
    //
    *lpdwErrReason = 0;
    dwLowIp = MMAKEIPADDRESS(1,0,0,0);
    dwHighIp = MMAKEIPADDRESS(224,0,0,0);

    // Make sure that the netId is a valid class 
    //
    if ((dwFrom < dwLowIp)               ||
        (dwFrom >= dwHighIp)             ||
        (dwTo < dwLowIp)                 ||
        (dwTo >= dwHighIp))
    {
        *lpdwErrReason = RASIP_REASON_BadAddress;
        return ERROR_BAD_FORMAT;
    }

    if ((FIRST_IPADDRESS(dwFrom) == 127) ||
        (FIRST_IPADDRESS(dwTo) == 127))
    {
        *lpdwErrReason = RASIP_REASON_127;
        return ERROR_BAD_FORMAT;
    }

    if (!(dwFrom <= dwTo))
    {
        *lpdwErrReason = RASIP_REASON_BadRange;
        return ERROR_BAD_FORMAT;
    }

    return NO_ERROR;
}

DWORD 
RasIpConvertRangePszToDword(
    IN  LPCWSTR pszFrom,
    IN  LPCWSTR pszTo,
    OUT LPDWORD lpdwFrom,
    OUT LPDWORD lpdwTo)
{
    DWORD dwFrom = 0, dwTo = 0;
    CHAR pszFromA[64], pszToA[64];

    // Whistler bug 259799 PREFIX
    //
    if (NULL == pszFrom || NULL == pszTo)
    {
        return ERROR_INVALID_PARAMETER;
    }

    wcstombs(pszFromA, pszFrom, sizeof(pszFromA));
    dwFrom = inet_addr(pszFromA);
    if (dwFrom == INADDR_NONE)
    {
        return ERROR_BAD_FORMAT;
    }

    wcstombs(pszToA, pszTo, sizeof(pszToA));
    dwTo = inet_addr(pszToA);
    if (dwTo == INADDR_NONE)
    {
        return ERROR_BAD_FORMAT;
    }

    // Convert for x86
    //
    *lpdwFrom = ntohl(dwFrom);
    *lpdwTo = ntohl(dwTo);

    return NO_ERROR;
}

DWORD
RasIpHandleSetAccess(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIP_CB Config;
    TOKEN_VALUE rgEnumMode[] =
    {
        {TOKEN_ALL,         TRUE},
        {TOKEN_SERVERONLY,  FALSE}
    };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE,    TRUE, FALSE},
            rgEnumMode,
            sizeof(rgEnumMode)/sizeof(*rgEnumMode),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIP_F_Access;
        Config.bAccess = dwValue;
        dwErr = RasIpCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpHandleSetAssignment(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0, dwReason = 0;
    RASIP_CB* pConfig = NULL;
    TOKEN_VALUE rgEnum[] =
    {
        {TOKEN_AUTO, TRUE},
        {TOKEN_POOL, FALSE}
    };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_METHOD,    TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    // Initialize
    RasIpCbCreateDefault(&pConfig);

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If this is an attempt to switch to pool mode,
        // make sure there is a valid pool.
        //
        if (dwValue == FALSE)
        {
            pConfig->dwFlags = RASIP_F_Pool | RASIP_F_Mask;
            dwErr = RasIpCbRead(g_pszServer, pConfig);
            BREAK_ON_DWERR( dwErr );
            if (pConfig->pPool->dwCount == 0)
            {
                DisplayMessage(
                    g_hModule, 
                   EMSG_RASIP_NEED_VALID_POOL,
                   DMP_RASIP_ADD_RANGE);
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }

        // If successful, go ahead and set the info
        //
        pConfig->dwFlags = RASIP_F_Auto;
        pConfig->bAuto = dwValue;
        dwErr = RasIpCbWrite(g_pszServer, pConfig);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        RasIpCbCleanup(pConfig);
    }

    return dwErr;
}

DWORD
RasIpHandleSetCallerSpec(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIP_CB Config;
    TOKEN_VALUE rgEnum[] =
    {
        {TOKEN_ALLOW, TRUE},
        {TOKEN_DENY, FALSE}
    };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE,    TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIP_F_CallerSpec;
        Config.bCallerSpec = dwValue;
        dwErr = RasIpCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpHandleSetNegotiation(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIP_CB Config;
    TOKEN_VALUE rgEnum[] =
    {
        {TOKEN_ALLOW, TRUE},
        {TOKEN_DENY,  FALSE}
    };
    RASMON_CMD_ARG pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE,    TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIP_F_EnableIn;
        Config.bEnableIn = dwValue;
        dwErr = RasIpCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Get options to set NETBT broadcast enable/disable
//   ppwcArguments   - Argument array
//   dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
//   dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
//
// Whistler bug: 359847 Netsh: move broadcastnameresolution from routing ip to
// ras ip
//
DWORD
RasIpHandleSetNetbtBcast(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    TOKEN_VALUE rgEnum[] =
    {
        {TOKEN_ENABLED, TRUE},
        {TOKEN_DISABLED, FALSE}
    };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE,    TRUE, FALSE},
            rgEnum, 
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        dwErr = RasIpSetNetbtBcast(dwValue);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpHandleAddDelRange(
    IN OUT  LPWSTR *ppwcArguments,
    IN      DWORD   dwCurrentIndex,
    IN      DWORD   dwArgCount,
    IN      BOOL    *pbDone,
    IN      BOOL    bAdd
    )
{
    PWCHAR pszFrom = NULL, pszTo = NULL;
    DWORD dwFrom = 0, dwTo = 0, dwErr = NO_ERROR, dwReason;
    RASIP_CB * pConfig = NULL;
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_FROM,    TRUE,  FALSE},
            NULL,
            0,
            NULL
        },
        
        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_TO,    TRUE,  FALSE},
            NULL,
            0,
            NULL
        }
    };
    PWCHAR pszAddr = NULL, pszMask = NULL;

    do
    {
        pConfig = (RASIP_CB*) RutlAlloc(sizeof(RASIP_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        pszFrom = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        pszTo = RASMON_CMD_ARG_GetPsz(&pArgs[1]);

        dwErr = RasIpConvertRangePszToDword(
                    pszFrom,
                    pszTo,
                    &dwFrom,
                    &dwTo);
        BREAK_ON_DWERR(dwErr);

        // Validate the values entered
        //
        dwErr = RasIpValidateRange(dwFrom, dwTo, &dwReason);
        if (dwErr != NO_ERROR)
        {
            RasIpDisplayInvalidPool(dwReason);
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Read in the old config
        pConfig->dwFlags = RASIP_F_Pool;
        dwErr = RasIpCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR(dwErr);

        if (bAdd)
        {
            // Add the range
            //
            dwErr = RasIpPoolAdd(
                        pConfig->pPool,
                        dwFrom,
                        dwTo);
            if (dwErr == ERROR_CAN_NOT_COMPLETE)
            {
                DisplayMessage(
                    g_hModule,
                    EMSG_RASIP_OVERLAPPING_RANGE);
            }
            BREAK_ON_DWERR(dwErr);
        }
        else
        {
            // Delete the range
            //
            dwErr = RasIpPoolDel(
                        pConfig->pPool,
                        dwFrom,
                        dwTo);
            BREAK_ON_DWERR(dwErr);
        }

        // Commit the change
        //
        dwErr = RasIpCbWrite(
                    g_pszServer,
                    pConfig);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszFrom);
        RutlFree(pszTo);
        RasIpCbCleanup(pConfig);
    }

    return dwErr;
}

DWORD 
RasIpHandleAddRange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return RasIpHandleAddDelRange(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TRUE);
}

DWORD 
RasIpHandleDelRange(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return RasIpHandleAddDelRange(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                FALSE);
}

DWORD
RasIpHandleDelPool(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;
    RASIP_CB Config;
    RAS_IPPOOL* pPool = NULL;
    DWORD dwErr = NO_ERROR;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule,
            HLP_RASIP_DEL_POOL_EX,
            DMP_RASIP_DEL_POOL);

        return NO_ERROR;
    }

    do
    {
        // Initialize an empty pool
        //
        pPool = RutlAlloc(sizeof(RAS_IPPOOL), TRUE);
        if (pPool == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIP_F_Pool;
        Config.pPool = pPool;

        dwErr = RasIpCbWrite(g_pszServer, &Config);
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    {
        if (pPool)
        {
            RasIpPoolCleanup(pPool);
        }
    }

    return dwErr;
}

DWORD
RasIpHandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule, 
            HLP_RASIP_SHOW_CONFIG_EX,
            DMP_RASIP_SHOW_CONFIG);
            
        return NO_ERROR;
    }

    return RasIpDisplayConfig(TRUE);
}

//
// Opens the registry keys associated with the ras ip address pool
//
DWORD
RasIpPoolOpenKeys(
    IN  HKEY hkParams,
    IN  BOOL bCreate,
    OUT HKEY* phNew)
{
    DWORD dwErr = NO_ERROR, dwDisposition;

    do
    {
        *phNew = NULL;

        if (bCreate)
        {
            dwErr = RegCreateKeyEx(
                        hkParams,
                        pszIpPoolSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        phNew,
                        &dwDisposition);
        }
        else
        {
            dwErr = RegOpenKeyEx(
                        hkParams,
                        pszIpPoolSubKey,
                        0,
                        KEY_ALL_ACCESS,
                        phNew);
        }
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Find a given range in the IP address pool.  
//   If bExact is TRUE, it searches for an exact match to the range
//   If bExact is FALSE, it searches for any overlapping range.
//
DWORD
RasIpPoolFind(
    IN RAS_IPPOOL* pPool,
    IN DWORD dwFrom,
    IN DWORD dwTo,
    IN BOOL bExact,
    OUT RAS_IPRANGE_NODE** ppNode OPTIONAL)
{
    RAS_IPRANGE_NODE* pNode = pPool->pHead;

    if (bExact)
    {
        for (; pNode; pNode = pNode->pNext)
        {
            if ((pNode->dwFrom == dwFrom) && (pNode->dwTo == pNode->dwTo))
            {
                break;
            }
        }
    }
    else
    {
        for (; pNode; pNode = pNode->pNext)
        {
            if (
                // Overlap case 1: The lower end falls within an existing range
                //
                ((dwFrom >= pNode->dwFrom) && (dwFrom <= pNode->dwTo)) ||

                // Overlap case 2: The upper end falls within an existing range
                //
                ((dwTo >= pNode->dwFrom) && (dwTo <= pNode->dwTo))     ||

                // Overlap case 3: The range is a superset of an existing range
                //
                ((dwFrom < pNode->dwFrom) && (dwTo > pNode->dwTo))
               )
            {
                break;
            }
        }
    }

    if (pNode)
    {
        if (ppNode)
        {
            *ppNode = pNode;
        }
        return NO_ERROR;
    }

    return ERROR_NOT_FOUND;
}

// 
// Callback function populates a pool of addresses
//
DWORD
RasIpPoolReadNode(
    IN LPCWSTR pszName,          // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData)
{
    RAS_IPPOOL* pPool = (RAS_IPPOOL*)hData;
    DWORD dwErr = NO_ERROR;
    DWORD dwFrom = 0, dwTo = 0;

    dwErr = RutlRegReadDword(hKey, pszIpFrom, &dwFrom);
    if (dwErr != NO_ERROR)
    {
        return NO_ERROR;
    }

    dwErr = RutlRegReadDword(hKey, pszIpTo, &dwTo);
    if (dwErr != NO_ERROR)
    {
        return NO_ERROR;
    }
    
    dwErr = RasIpPoolAdd(pPool, dwFrom, dwTo);

    return dwErr;
}

//
// Resets the ras pool on the given server
//
DWORD
RasIpPoolReset(
    IN  HKEY hkParams)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkPool = NULL;
    
    do
    {
        dwErr = RasIpPoolOpenKeys(
                    hkParams,
                    TRUE,
                    &hkPool);
        BREAK_ON_DWERR(dwErr);

        {
            DWORD i; 
            WCHAR pszBuf[16];
            HKEY hkRange = NULL;

            for (i = 0; ;i++)
            {
                _itow(i, pszBuf, 10);

                dwErr = RegOpenKeyEx(
                            hkPool,
                            pszBuf,
                            0,
                            KEY_ALL_ACCESS,
                            &hkRange);
                if (dwErr != ERROR_SUCCESS)
                {
                    dwErr = NO_ERROR;
                    break;
                }
                RegCloseKey(hkRange);
                RegDeleteKey(hkPool, pszBuf);
            }
            BREAK_ON_DWERR(dwErr);
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkPool)
        {
            RegCloseKey(hkPool);
        }
    }

    return dwErr;
}

//
// Reads the ras ip pool from the given server
//
DWORD
RasIpPoolRead(
    IN  HKEY hkParams,
    OUT RAS_IPPOOL** ppPool)
{
    DWORD dwErr = NO_ERROR;
    RAS_IPPOOL* pPool = NULL;
    HKEY hkPool = NULL;
    PWCHAR pszAddress = NULL, pszMask = NULL;

    do
    {
        // Allocate the new pool
        //
        pPool = (RAS_IPPOOL*) RutlAlloc(sizeof(RAS_IPPOOL), TRUE);
        if (pPool == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Attempt to open the new location
        //
        dwErr = RasIpPoolOpenKeys(
                    hkParams,
                    FALSE,
                    &hkPool);

        // The new location exists -- load in the
        // pool
        if (dwErr == NO_ERROR)
        {
            DWORD i; 
            WCHAR pszBuf[16];
            HKEY hkRange = NULL;

            for (i = 0; ;i++)
            {
                _itow(i, pszBuf, 10);

                dwErr = RegOpenKeyEx(
                            hkPool,
                            pszBuf,
                            0,
                            KEY_ALL_ACCESS,
                            &hkRange);
                if (dwErr != ERROR_SUCCESS)
                {
                    dwErr = NO_ERROR;
                    break;
                }

                dwErr = RasIpPoolReadNode(
                            pszBuf,
                            hkRange,
                            (HANDLE)pPool);

                if (hkRange)
                {
                    (VOID)RegCloseKey(hkRange);
                    hkRange = NULL;
                }

                BREAK_ON_DWERR(dwErr);
            }
            BREAK_ON_DWERR(dwErr);

            *ppPool = pPool;
        }

        // The new location does not exist -- use legacy 
        // values
        //
        else if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            DWORD dwAddress = 0, dwMask = 0;
           
            dwErr = RutlRegReadString(hkParams, pszIpAddress, &pszAddress);
            BREAK_ON_DWERR(dwErr);

            dwErr = RutlRegReadString(hkParams, pszIpMask, &pszMask);
            BREAK_ON_DWERR(dwErr);

            dwErr = RasIpConvertRangePszToDword(
                        pszAddress,
                        pszMask,
                        &dwAddress,
                        &dwMask);
            BREAK_ON_DWERR(dwErr);

            if (dwAddress != 0)
            {
                dwErr = RasIpPoolAdd(
                            pPool,
                            dwAddress + 2,
                            (dwAddress + ~dwMask) - 1);
                BREAK_ON_DWERR(dwErr);
            }

            *ppPool = pPool;
        }
        

    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            if (pPool)
            {
                RasIpPoolCleanup(pPool);
            }
        }
        if (hkPool)
        {
            RegCloseKey(hkPool);
        }
        RutlFree(pszAddress);
        RutlFree(pszMask);
    }

    return dwErr;
}

//
// Writes the given ras ip pool to the given server
//
DWORD
RasIpPoolWrite(
    IN HKEY hkParams,
    IN RAS_IPPOOL* pPool)
{
    DWORD dwErr = NO_ERROR;
    HKEY hkPool = NULL, hkNode = NULL;
    DWORD i, dwDisposition;
    WCHAR pszName[16];
    RAS_IPRANGE_NODE* pNode = pPool->pHead;

    do
    {
        dwErr = RasIpPoolReset(hkParams);
        BREAK_ON_DWERR(dwErr);

        dwErr = RasIpPoolOpenKeys(
                    hkParams,
                    TRUE,
                    &hkPool);
        BREAK_ON_DWERR(dwErr);

        for (i = 0; i < pPool->dwCount; i++, pNode = pNode->pNext)
        {
            _itow(i, pszName, 10);

            dwErr = RegCreateKeyEx(
                        hkPool,
                        pszName,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkNode,
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            RegSetValueEx(
                hkNode, 
                pszIpFrom,
                0,
                REG_DWORD,
                (CONST BYTE*)&pNode->dwFrom,
                sizeof(DWORD));

            RegSetValueEx(
                hkNode, 
                pszIpTo,
                0,
                REG_DWORD,
                (CONST BYTE*)&pNode->dwTo,
                sizeof(DWORD));
            
            if (hkNode)
            {
                RegCloseKey(hkNode);
            }
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkPool)
        {
            RegCloseKey(hkPool);
        }
    }

    return dwErr;
}

//
// Adds a range to a ras ip pool
//
DWORD 
RasIpPoolAdd(
    IN OUT RAS_IPPOOL* pPool,
    IN     DWORD dwFrom,
    IN     DWORD dwTo)
{
    RAS_IPRANGE_NODE* pNode = NULL;
    DWORD dwErr;

    // Make sure the pool does not overlap
    //
    dwErr = RasIpPoolFind(pPool, dwFrom, dwTo, FALSE, NULL);
    if (dwErr == NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Allocate the new node
    //
    pNode = (RAS_IPRANGE_NODE*) RutlAlloc(sizeof(RAS_IPRANGE_NODE), TRUE);
    if (pNode == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pNode->dwFrom = dwFrom;
    pNode->dwTo = dwTo;

    // Add it to the list
    //
    if (pPool->pTail)
    {
        pPool->pTail->pNext = pNode;
        pPool->pTail = pNode;
    }
    else
    {
        pPool->pHead = pPool->pTail = pNode;
    }
    pPool->dwCount++;

    return NO_ERROR;
}

//
// Deletes a range from a ras ip pool
//
DWORD
RasIpPoolDel(
    IN OUT RAS_IPPOOL* pPool,
    IN     DWORD dwFrom,
    IN     DWORD dwTo)
{
    RAS_IPRANGE_NODE* pCur = NULL, *pPrev = NULL;

    if (pPool->dwCount == 0)
    {
        return ERROR_NOT_FOUND;
    }

    pCur = pPrev = pPool->pHead;

    if ((pCur->dwFrom == dwFrom) && (pCur->dwTo == dwTo))
    {
        pPool->pHead = pCur->pNext;
        if (pCur == pPool->pTail)
        {
            pPool->pTail = NULL;
        }
        RutlFree(pCur);
        pPool->dwCount--;
        
        return NO_ERROR;
    }

    for (pCur = pCur->pNext; pCur; pCur = pCur->pNext, pPrev = pPrev->pNext)
    {
        if ((pCur->dwFrom == dwFrom) && (pCur->dwTo == dwTo))
        {
            pPrev->pNext = pCur->pNext;
            if (pCur == pPool->pTail)
            {
                pPool->pTail = pPrev;
            }
            RutlFree(pCur);
            pPool->dwCount--;

            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

// 
// Cleans up a config control block
//
DWORD 
RasIpCbCleanup(
    IN RASIP_CB* pConfig)
{
    if (pConfig)
    {
        if (pConfig->pPool)
        {
            RasIpPoolCleanup(pConfig->pPool);
        }
        RutlFree(pConfig);
    }

    return NO_ERROR;
}

DWORD
RasIpPoolCleanup(
    IN RAS_IPPOOL* pPool)
{
    RAS_IPRANGE_NODE* pNode = NULL;

    if (pPool)
    {
        while (pPool->pHead)
        {
            pNode = pPool->pHead->pNext;
            RutlFree(pPool->pHead);
            pPool->pHead = pNode;
        }

        RutlFree(pPool);
    }

    return NO_ERROR;
}

//
// Creates a default config control block
//
DWORD 
RasIpCbCreateDefault(
    OUT RASIP_CB** ppConfig)
{
    RASIP_CB* pConfig = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        pConfig = (RASIP_CB*) RutlAlloc(sizeof(RASIP_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pConfig->bEnableIn   = TRUE;
        pConfig->bAccess     = TRUE;
        pConfig->bAuto       = TRUE;
        pConfig->pPool       = NULL;
        pConfig->bCallerSpec = TRUE;

        *ppConfig = pConfig;

    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasIpCbCleanup(pConfig);
        }
    }

    return dwErr;
}

//
// Helper function opens the ras ip config registry key
//
DWORD 
RasIpCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszKey[MAX_PATH];

    do
    {
        // Generate the parameters key name
        //
        wsprintfW(
            pszKey,
            L"%s%s",
            pszRemoteAccessParamStub,
            pszIpParams);

        // Open the parameters keys
        //
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    pszKey,
                    0,
                    KEY_READ | KEY_WRITE,
                    phKey);
        BREAK_ON_DWERR( dwErr );

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Functions that manipulate RASIP_CB's
//
DWORD 
RasIpCbRead(
    IN  LPCWSTR pszServer,
    OUT RASIP_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;
    PWCHAR pszTemp = NULL;

    do
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasIpCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );

        // Load the params from the registry 
        //
        if (pConfig->dwFlags & RASIP_F_EnableIn)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszEnableIn,
                        &pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIP_F_Access)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        &pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIP_F_Auto)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpUseDhcp,
                        &pConfig->bAuto);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIP_F_CallerSpec)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpClientSpec,
                        &pConfig->bCallerSpec);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIP_F_Pool)
        {
            dwErr = RasIpPoolRead(
                        hkParams,
                        &pConfig->pPool);
            BREAK_ON_DWERR( dwErr );
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

DWORD
RasIpCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASIP_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasIpCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );

        // Write out the params to the registry 
        //
        if (pConfig->dwFlags & RASIP_F_EnableIn)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszEnableIn,
                        pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIP_F_Access)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIP_F_Auto)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpUseDhcp,
                        pConfig->bAuto);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIP_F_CallerSpec)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpClientSpec,
                        pConfig->bCallerSpec);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIP_F_Pool)
        {
            dwErr = RasIpPoolWrite(
                        hkParams,
                        pConfig->pPool);
            BREAK_ON_DWERR( dwErr );
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

//
// Set NETBT broadcast based name resolution reg. value
//   dwArgCount      - Value to set the registry value to
//   returns NO_ERROR        - Success
//           Other           - System error code
//
// Whistler bug: 359847 Netsh: move broadcastnameresolution from routing ip to
// ras ip
//
DWORD
RasIpSetNetbtBcast(
    DWORD   dwEnable
    )
{
    DWORD dwResult, dwEnableOld = -1, dwSize = sizeof(DWORD);
    HKEY  hkIpcpParam;

    do
    {
        dwResult = RegOpenKeyExW(
                    g_pServerInfo->hkMachine,
                    L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ip",
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkIpcpParam
                    );

        if(dwResult isnot NO_ERROR)
        {
            break;
        }

        dwResult = RegQueryValueExW(
                    hkIpcpParam,
                    L"EnableNetbtBcastFwd",
                    NULL,
                    NULL,
                    (PBYTE)&dwEnableOld,
                    &dwSize
                    );

        if((dwResult is NO_ERROR) and (dwEnable == dwEnableOld))
        {
            break;
        }

        dwResult = RegSetValueExW(
                    hkIpcpParam,
                    L"EnableNetbtBcastFwd",
                    0,
                    REG_DWORD,
                    (PBYTE) &dwEnable,
                    sizeof( DWORD )
                    );

    } while(FALSE);

    if(dwResult is NO_ERROR)
    {
        DisplayMessage(g_hModule, MSG_RASAAAA_MUST_RESTART_SERVICES);
    }

    return dwResult;
}

//
// Whistler bug: 359847 Netsh: move broadcastnameresolution from routing ip to
// ras ip
//
BOOL
RasIpShowNetbtBcast(
    VOID
    )
{
    HKEY   hkIpcpParam = NULL;
    BOOL   bReturn = FALSE;
    DWORD  dwResult, dwEnable = -1, dwSize = sizeof(DWORD);

    do
    {

        dwResult = RegOpenKeyExW(
                    g_pServerInfo->hkMachine,
                    L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Ip",
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkIpcpParam
                    );

        if(dwResult isnot NO_ERROR)
        {
            break;
        }

        dwResult = RegQueryValueExW(
                    hkIpcpParam,
                    L"EnableNetbtBcastFwd",
                    NULL,
                    NULL,
                    (PBYTE)&dwEnable,
                    &dwSize
                    );

        if(dwResult isnot NO_ERROR)
        {
            break;
        }

        if (dwEnable isnot 0)
        {
            bReturn = TRUE;
        }

    } while(FALSE);

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasip.h ===
/*
    File:   rasip.h
    
    Definitions for the 'ras ip' sub context

    3/2/99
*/

#ifndef __RASIP_H
#define __RASIP_H

#define RASIP_VERSION 1

// 13d12a78-d0fb-11d2-9b76-00104bca495b 
#define RASIP_GUID \
{ 0x13d12a78, 0xd0fb, 0x11d2, {0x9b, 0x76, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b} }

NS_HELPER_START_FN RasIpStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasIpDump;

FN_HANDLE_CMD   RasIpHandleSetAccess;
FN_HANDLE_CMD   RasIpHandleSetAssignment;
FN_HANDLE_CMD   RasIpHandleSetCallerSpec;
FN_HANDLE_CMD   RasIpHandleSetNegotiation;
FN_HANDLE_CMD   RasIpHandleSetNetbtBcast;
FN_HANDLE_CMD   RasIpHandleShow;
FN_HANDLE_CMD   RasIpHandleAddRange;
FN_HANDLE_CMD   RasIpHandleDelRange;
FN_HANDLE_CMD   RasIpHandleDelPool;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasmon.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\showmib.h   

Abstract:

     Prototype for fns called in ipmon.c

Author:

     Anand Mahalingam    7/10/98

--*/

extern GUID g_RasmontrGuid;
extern RASMON_SERVERINFO * g_pServerInfo;
extern HANDLE   g_hModule;
extern BOOL     g_bCommit;
extern DWORD    g_dwNumTableEntries;
extern BOOL     g_bRasDirty;

extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumGroups;

extern CMD_GROUP_ENTRY      g_RasCmdGroups[];
extern CMD_ENTRY            g_RasCmds[];

DWORD
WINAPI
RasCommit(
    IN  DWORD   dwAction
    );

BOOL
WINAPI
UserDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    );

DWORD
WINAPI
RasUnInit(
    IN  DWORD   dwReserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasipx.h ===
/*
    File:   rasipx.h
    
    Definitions for the 'ras ipx' sub context

    3/2/99
*/

#ifndef __RASIPX_H
#define __RASIPX_H

#define RASIPX_VERSION 1

// 6fb90155-d324-11d2-9b76-00104bca495b
#define RASIPX_GUID \
{ 0x6fb90155, 0xd324, 0x11d2, {0x9b, 0x76, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b} }
  
NS_HELPER_START_FN RasIpxStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasIpxDump;

FN_HANDLE_CMD   RasIpxHandleSetAssignment;
FN_HANDLE_CMD   RasIpxHandleSetPool;
FN_HANDLE_CMD   RasIpxHandleSetCallerSpec;
FN_HANDLE_CMD   RasIpxHandleSetAccess;
FN_HANDLE_CMD   RasIpxHandleShow;
FN_HANDLE_CMD   RasIpxHandleSetNegotiation;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasipx.c ===
/*
    File:   rasipx.h
    
    The 'remoteaccess ipx' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasipx.h"

//
// Local prototypes
//
BOOL
WINAPI
RasIpxCheckVersion(
    IN  UINT     CIMOSType,
    IN  UINT     CIMOSProductSuite,
    IN  LPCWSTR  CIMOSVersion,
    IN  LPCWSTR  CIMOSBuildNumber,
    IN  LPCWSTR  CIMServicePackMajorVersion,
    IN  LPCWSTR  CIMServicePackMinorVersion,
    IN  UINT     CIMProcessorArchitecture,
    IN  DWORD    dwReserved
    );

// The guid for this context
//
GUID g_RasIpxGuid = RASIPX_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// The commands supported in this context
//
CMD_ENTRY  g_RasIpxSetCmdTable[] = 
{
    // Whistler bug 249293, changes for architecture version checking
    //
    CREATE_CMD_ENTRY(RASIPX_SET_NEGOTIATION,RasIpxHandleSetNegotiation),
    CREATE_CMD_ENTRY(RASIPX_SET_ACCESS,     RasIpxHandleSetAccess),
    CREATE_CMD_ENTRY(RASIPX_SET_ASSIGNMENT, RasIpxHandleSetAssignment),
    CREATE_CMD_ENTRY(RASIPX_SET_CALLERSPEC, RasIpxHandleSetCallerSpec),
    CREATE_CMD_ENTRY(RASIPX_SET_POOL,       RasIpxHandleSetPool),
};

CMD_ENTRY  g_RasIpxShowCmdTable[] = 
{
    // Whistler bug 249293, changes for architecture version checking
    //
    CREATE_CMD_ENTRY(RASIPX_SHOW_CONFIG,    RasIpxHandleShow),
};

CMD_GROUP_ENTRY g_RasIpxCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_RasIpxSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_RasIpxShowCmdTable),
};

ULONG g_ulRasIpxNumGroups = sizeof(g_RasIpxCmdGroups)/sizeof(CMD_GROUP_ENTRY);

//
// Flags that control how/what info is read/written
// in the RASIPX_CB structure
//
#define RASIPX_F_EnableIn    0x1
#define RASIPX_F_Access      0x2
#define RASIPX_F_Auto        0x4
#define RASIPX_F_Global      0x8
#define RASIPX_F_FirstNet    0x10
#define RASIPX_F_PoolSize    0x20
#define RASIPX_F_CallerSpec  0x40
#define RASIPX_F_All         0xFFFF

//
// Control block for ras ipx configuration
//
typedef struct _RASIPX_CB
{
    DWORD dwFlags;      // See RASIPX_F_* values

    BOOL bEnableIn;
    BOOL bAccess;
    BOOL bAuto;
    BOOL bGlobal;
    BOOL bCallerSpec;
    DWORD dwFirstNet;
    DWORD dwPoolSize;

} RASIPX_CB;

//
// Ipx specific registry parameters
//
WCHAR pszIpxParams[]                = L"Ipx";
WCHAR pszIpxFirstNet[]              = L"FirstWanNet";
WCHAR pszIpxPoolSize[]              = L"WanNetPoolSize";
WCHAR pszIpxClientSpec[]            = L"AcceptRemoteNodeNumber";
WCHAR pszIpxAutoAssign[]            = L"AutoWanNetAllocation";
WCHAR pszIpxGlobalWanNet[]          = L"GlobalWanNet";

//
// Prototypes of functions that manipulate the 
// RASIPX_CB structures
//
DWORD 
RasIpxCbCleanup(
    IN RASIPX_CB* pConfig);

DWORD 
RasIpxCbCreateDefault(
    OUT RASIPX_CB** ppConfig);

DWORD
RasIpxCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey);
    
DWORD 
RasIpxCbRead(
    IN  LPCWSTR pszServer,
    OUT RASIPX_CB* pConfig);

DWORD 
RasIpxCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASIPX_CB* pConfig);

PWCHAR
RasIpxuStrFromDword(
    IN DWORD dwVal,
    IN DWORD dwRadix);

DWORD 
RasIpxuDwordFromString(
    IN LPCWSTR pszVal,
    IN DWORD dwRadix);

// 
// Callback determines if a command is valid on a given architecture
//
BOOL
WINAPI 
RasIpxCheckVersion(
    IN  UINT     CIMOSType,
    IN  UINT     CIMOSProductSuite,
    IN  LPCWSTR  CIMOSVersion,
    IN  LPCWSTR  CIMOSBuildNumber,
    IN  LPCWSTR  CIMServicePackMajorVersion,
    IN  LPCWSTR  CIMServicePackMinorVersion,
    IN  UINT     CIMProcessorArchitecture,
    IN  DWORD    dwReserved
    )
{
    // Only available on x86 platforms
    //
    // Whistler bug 249293, changes for architecture version checking
    //
    if (CIMProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
    {
        return TRUE;
    }

    return FALSE;
}

//
// Entry called by rasmontr to register this context
//
DWORD 
WINAPI
RasIpxStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    // Whistler bug 249293, changes for architecture version checking
    //
    attMyAttributes.pfnOsVersionCheck= RasIpxCheckVersion;
    attMyAttributes.pwszContext      = L"ipx";
    attMyAttributes.guidHelper       = g_RasIpxGuid;
    attMyAttributes.dwVersion        = RASIPX_VERSION;
    attMyAttributes.dwFlags          = 0;
    attMyAttributes.ulNumTopCmds     = 0;
    attMyAttributes.pTopCmds         = NULL;
    attMyAttributes.ulNumGroups      = g_ulRasIpxNumGroups;
    attMyAttributes.pCmdGroups       = (CMD_GROUP_ENTRY (*)[])&g_RasIpxCmdGroups;
    attMyAttributes.pfnDumpFn        = RasIpxDump;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
RasIpxDisplayConfig(
    IN  BOOL bReport)
{
    DWORD dwErr = NO_ERROR;
    RASIPX_CB* pConfig = NULL;
    PWCHAR pszEnabled = NULL, pszAccess = NULL, pszAssign = NULL, pszCaller = NULL;
    PWCHAR pszFirstNet = NULL, pszSize = NULL, pszTemp = NULL;
    PWCHAR pszTknAuto = NULL;
    
    do
    {
        // Get a default config blob
        //
        dwErr = RasIpxCbCreateDefault(&pConfig);
        BREAK_ON_DWERR( dwErr );

        // Read in all of the values
        //
        pConfig->dwFlags = RASIPX_F_All;
        dwErr = RasIpxCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR( dwErr );

        // Calculate the "auto" token
        //
        if (pConfig->bAuto)
        {
            pszTknAuto = (pConfig->bGlobal) ? TOKEN_AUTOSAME : TOKEN_AUTO;
        }
        else
        {
            pszTknAuto = (pConfig->bGlobal) ? TOKEN_POOLSAME : TOKEN_POOL;
        }

        if (bReport)
        {
            pszEnabled =
                RutlStrDup(pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess =
                RutlStrDup(pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);
            pszAssign =
                RutlStrDup(pszTknAuto);
            pszCaller =
                RutlStrDup(pConfig->bCallerSpec ? TOKEN_ALLOW : TOKEN_DENY);
            pszFirstNet =
                RasIpxuStrFromDword(pConfig->dwFirstNet, 16);

            if (pConfig->dwPoolSize == 0)
            {
                pszSize =
                    RutlStrDup(TOKEN_DYNAMIC);
            }
            else
            {
                pszSize =
                    RasIpxuStrFromDword(pConfig->dwPoolSize, 10);
            }

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SERVERCONFIG,
                g_pszServer,
                pszEnabled,
                pszAccess,
                pszAssign,
                pszCaller,
                pszFirstNet,
                pszSize);
        }
        else
        {
            pszEnabled = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);
            pszAssign = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_METHOD,
                            pszTknAuto);
            pszCaller = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bCallerSpec ? TOKEN_ALLOW : TOKEN_DENY);

            pszTemp = RasIpxuStrFromDword(pConfig->dwFirstNet, 16);
            pszFirstNet = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_FIRSTNET,
                            pszTemp);
            RutlFree(pszTemp);

            // Whistler bug 27366 NETSH RAS - ipx set pool will not accept hex
            // values, yet ipx dump outputs them as hex
            //
            pszTemp = RasIpxuStrFromDword(pConfig->dwPoolSize, 10);
            pszSize = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_SIZE,
                            pszTemp);
            RutlFree(pszTemp);

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SCRIPTHEADER);

            DisplayMessageT(DMP_RASIPX_PUSHD);

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SET_CMD,
                DMP_RASIPX_SET_NEGOTIATION,
                pszEnabled);

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SET_CMD,
                DMP_RASIPX_SET_ACCESS,
                pszAccess);

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SET_CMD,
                DMP_RASIPX_SET_CALLERSPEC,
                pszCaller);

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SET_CMD,
                DMP_RASIPX_SET_ASSIGNMENT,
                pszAssign);

            if (! pConfig->bAuto)
            {
                DisplayMessage(
                    g_hModule,
                    MSG_RASIPX_SET_POOL_CMD,
                    DMP_RASIPX_SET_POOL,
                    pszFirstNet,
                    pszSize);
            }

            DisplayMessageT(DMP_RASIPX_POPD);

            DisplayMessage(
                g_hModule,
                MSG_RASIPX_SCRIPTFOOTER);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pConfig)
        {
            RasIpxCbCleanup(pConfig);
        }
        if (pszEnabled)
        {
            RutlFree(pszEnabled);
        }
        if (pszAccess)
        {
            RutlFree(pszAccess);
        }
        if (pszAssign)
        {
            RutlFree(pszAssign);
        }
        if (pszCaller)
        {
            RutlFree(pszCaller);
        }
        if (pszFirstNet)
        {
            RutlFree(pszFirstNet);
        }
        if (pszSize)
        {
            RutlFree(pszSize);
        }
    }

    return dwErr;
}

DWORD
WINAPI
RasIpxDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    return RasIpxDisplayConfig(FALSE);
}

DWORD
RasIpxHandleSetAccess(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIPX_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALL, TRUE}, {TOKEN_SERVERONLY, FALSE} };
    RASMON_CMD_ARG  pArgs[] =
    {
        { 
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE,    TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL 
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIPX_F_Access;
        Config.bAccess = dwValue;
        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpxHandleSetAssignment(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIPX_CB Config;
    TOKEN_VALUE rgEnum[] =
    { 
        {TOKEN_AUTO, 0},
        {TOKEN_POOL, 1},
        {TOKEN_AUTOSAME, 2},
        {TOKEN_POOLSAME, 3}
    };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_METHOD, TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIPX_F_Auto | RASIPX_F_Global;
        switch (dwValue)
        {
            case 0:
                Config.bAuto = TRUE;
                Config.bGlobal = FALSE;
                break;
                
            case 1:
                Config.bAuto = FALSE;
                Config.bGlobal = FALSE;
                break;
                
            case 2:
                Config.bAuto = TRUE;
                Config.bGlobal = TRUE;
                break;
                
            case 3:
                Config.bAuto = FALSE;
                Config.bGlobal = TRUE;
                break;
        }

        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpxHandleSetCallerSpec(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIPX_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALLOW, TRUE}, {TOKEN_DENY, FALSE} };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIPX_F_CallerSpec;
        Config.bCallerSpec = dwValue;
        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpxHandleSetNegotiation(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASIPX_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALLOW, TRUE}, {TOKEN_DENY, FALSE} };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASIPX_F_EnableIn;
        Config.bEnableIn = dwValue;
        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasIpxHandleSetPool(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, i;
    RASIPX_CB Config;
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_FIRSTNET, TRUE, FALSE},
            NULL,
            0,
            NULL
        },

        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_SIZE, TRUE, FALSE},
            NULL,
            0,
            NULL
        }
    };
    PWCHAR pszPool = NULL, pszSize = NULL;

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        pszPool = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        pszSize = RASMON_CMD_ARG_GetPsz(&pArgs[1]);

        // Initialize
        //
        ZeroMemory(&Config, sizeof(Config));

        // The address 
        //
        if (pszPool)
        {
            Config.dwFlags |= RASIPX_F_FirstNet;
            Config.dwFirstNet = RasIpxuDwordFromString(pszPool, 16);

            if ((Config.dwFirstNet == 0) || 
                (Config.dwFirstNet == 1) || 
                (Config.dwFirstNet == 0xffffffff))
            {
                DisplayMessage(g_hModule, EMSG_RASIPX_BAD_IPX);
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }

        // The size
        //
        if (pszSize)
        {
            Config.dwFlags |= RASIPX_F_PoolSize;
            Config.dwPoolSize = RasIpxuDwordFromString(pszSize, 10);
            if (Config.dwPoolSize > 64000)
            {
                DisplayMessage(g_hModule, EMSG_RASIPX_BAD_POOLSIZE);
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }

        // Commit the change to the pool
        //
        dwErr = RasIpxCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszPool);
        RutlFree(pszSize);
    }

    return dwErr;
}

DWORD
RasIpxHandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule,
            HLP_RASIPX_SHOW_CONFIG_EX,
            DMP_RASIPX_SHOW_CONFIG);

        return NO_ERROR;
    }

    return RasIpxDisplayConfig(TRUE);
}

// 
// Cleans up a config control block
//
DWORD 
RasIpxCbCleanup(
    IN RASIPX_CB* pConfig)
{
    if (pConfig)
    {
        RutlFree(pConfig);
    }

    return NO_ERROR;
}

//
// Creates a default config control block
//
DWORD 
RasIpxCbCreateDefault(
    OUT RASIPX_CB** ppConfig)
{
    RASIPX_CB* pConfig = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        pConfig = (RASIPX_CB*) RutlAlloc(sizeof(RASIPX_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pConfig->bEnableIn   = TRUE;
        pConfig->bAccess     = TRUE;
        pConfig->bAuto       = TRUE;
        pConfig->dwFirstNet  = 0;
        pConfig->dwPoolSize  = 0;
        pConfig->bGlobal     = TRUE;
        pConfig->bCallerSpec = TRUE;

        *ppConfig = pConfig;

    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasIpxCbCleanup(pConfig);
        }
    }

    return dwErr;
}

//
// Helper function opens the ras ipx config registry key
//
DWORD 
RasIpxCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszKey[MAX_PATH];
    
    do
    {
        // Generate the parameters key name
        //
        wsprintfW(
            pszKey,
            L"%s%s",
            pszRemoteAccessParamStub,
            pszIpxParams);

        // Open the parameters keys
        //
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    pszKey,
                    0,
                    KEY_READ | KEY_WRITE,
                    phKey);
        BREAK_ON_DWERR( dwErr );
        
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Functions that manipulate RASIPX_CB's
//
DWORD 
RasIpxCbRead(
    IN  LPCWSTR pszServer,
    OUT RASIPX_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasIpxCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );

        // Load the params from the registry 
        //
        if (pConfig->dwFlags & RASIPX_F_EnableIn)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszEnableIn,
                        &pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_Access)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        &pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_Auto)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxAutoAssign,
                        &pConfig->bAuto);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_Global)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxGlobalWanNet,
                        &pConfig->bGlobal);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_CallerSpec)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxClientSpec,
                        &pConfig->bCallerSpec);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_FirstNet)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxFirstNet,
                        &pConfig->dwFirstNet);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_PoolSize)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszIpxPoolSize,
                        &pConfig->dwPoolSize);
            BREAK_ON_DWERR( dwErr );
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

DWORD 
RasIpxCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASIPX_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do 
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasIpxCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );

        // Write out the params to the registry 
        //
        if (pConfig->dwFlags & RASIPX_F_EnableIn)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszEnableIn,
                        pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_Access)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_Auto)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxAutoAssign,
                        pConfig->bAuto);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_Global)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxGlobalWanNet,
                        pConfig->bGlobal);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_CallerSpec)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxClientSpec,
                        pConfig->bCallerSpec);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_FirstNet)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxFirstNet,
                        pConfig->dwFirstNet);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASIPX_F_PoolSize)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszIpxPoolSize,
                        pConfig->dwPoolSize);
            BREAK_ON_DWERR( dwErr );
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

PWCHAR
RasIpxuStrFromDword(
    IN DWORD dwVal,
    IN DWORD dwRadix)
{
    WCHAR pszBuf[64];

    pszBuf[0] = 0;
    _itow(dwVal, pszBuf, dwRadix);

    return RutlStrDup(pszBuf);
}

DWORD 
RasIpxuDwordFromString(
    IN LPCWSTR pszVal,
    IN DWORD dwRadix)
{
    return wcstoul(pszVal, NULL, dwRadix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasmontr.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    rasmontr.h

Abstract:
    This file contains definitions which are needed by RASMONTR.DLL
    and all NetSh helper DLLs which register under it.

--*/


#ifndef _RASMONTR_H_
#define _RASMONTR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// {0705ECA2-7AAC-11d2-89DC-006008B0E5B9}
#define RASMONTR_GUID \
{ 0x705eca2, 0x7aac, 0x11d2, { 0x89, 0xdc, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } }

#define RASMONTR_VERSION_50     0x0005000
#define RASMONTR_OS_BUILD_NT40  1381

//
// Enumerations for types of arguments (see RASMON_CMD_ARG)
//
#define RASMONTR_CMD_TYPE_STRING 0x1
#define RASMONTR_CMD_TYPE_ENUM   0x2
#define RASMONTR_CMD_TYPE_DWORD  0x3

// 
// Macros to operate on RASMON_CMD_ARG's
//
#define RASMON_CMD_ARG_Present(pArg)    \
    ((pArg)->rgTag.bPresent) 
    
#define RASMON_CMD_ARG_GetPsz(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.pszValue : NULL)

#define RASMON_CMD_ARG_GetEnum(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.dwValue : 0)

#define RASMON_CMD_ARG_GetDword(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.dwValue : 0)

// 
// Structure defining a command line argument
//
typedef struct _RASMON_CMD_ARG
{
    IN  DWORD dwType;           // RASMONTR_CMD_TYPE_*
    IN  TAG_TYPE rgTag;         // The tag for this command
    IN  TOKEN_VALUE* rgEnums;   // The enumerations for this arg
    IN  DWORD dwEnumCount;      // Count of enums
    union
    {
        OUT PWCHAR pszValue;        // Valid only for RASMONTR_CMD_TYPE_STRING
        OUT DWORD dwValue;          // Valid only for RASMONTR_CMD_TYPE_ENUM
    } Val;        
    
} RASMON_CMD_ARG, *PRASMON_CMD_ARG;

//
// Api's that rasmontr requires of its helpers
//
typedef
DWORD
(WINAPI RAS_CONTEXT_ENTRY_FN)(
    IN      LPCWSTR              pszServer,
    IN      DWORD                dwBuild,
    IN OUT  LPWSTR               *pptcArguments,
    IN      DWORD                dwArgCount,
    IN      DWORD                dwFlags,
    OUT     PWCHAR               pwcNewContext
    );
typedef RAS_CONTEXT_ENTRY_FN *PRAS_CONTEXT_ENTRY_FN;

// Defines information that describes a server
//
typedef struct _RASMON_SERVERINFO
{
    // Common to all
    //
    PWCHAR pszServer;
    DWORD  dwBuild;

    // Used by user commands
    HANDLE hServer;
    ULONG ulUserInitStarted;
    ULONG ulUserInitCompleted;

    HKEY hkMachine;

} RASMON_SERVERINFO;

//
// Api's that rasmontr exposes to its helpers
//

PVOID WINAPI
RutlAlloc(
    IN DWORD dwBytes,
    IN BOOL bZero
    );

VOID WINAPI
RutlFree(
    IN PVOID pvData
    );

PWCHAR WINAPI
RutlStrDup(
    IN LPCWSTR pwszSrc
    );

LPDWORD WINAPI
RutlDwordDup(
    IN DWORD dwSrc
    );

DWORD WINAPI
RutlCreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
    );

VOID WINAPI
RutlCloseDumpFile(
    HANDLE  hFile
    );

DWORD WINAPI
RutlGetOsVersion(
    IN OUT  RASMON_SERVERINFO *pServerInfo
    );
    
DWORD WINAPI
RutlGetTagToken(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN      PTAG_TYPE   pttTagToken,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    );

DWORD WINAPI
RutlParse(
    IN OUT  LPWSTR         *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      BOOL*           pbDone,
    OUT     RASMON_CMD_ARG* pRasArgs,
    IN      DWORD           dwRasArgCount);

BOOL WINAPI
RutlIsHelpToken(
    PWCHAR  pwszToken
    );

PWCHAR WINAPI
RutlAssignmentFromTokens(
    IN HINSTANCE hModule,
    IN LPCWSTR pwszTokenTkn,
    IN LPCWSTR pwszTokenCmd);

PWCHAR WINAPI
RutlAssignmentFromTokenAndDword(
    IN HINSTANCE hModule,
    IN LPCWSTR pwszToken,
    IN DWORD dwDword,
    IN DWORD dwRadius);
    
#ifdef __cplusplus
}
#endif

#endif // _RASMONTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    rasmon.c

Abstract:

    Main rasmon file.

Revision History:

    pmay

--*/

#include "precomp.h"

#define RAS_HELPER_VERSION 1

CMD_ENTRY  g_RasAddCmdTable[] =
{
    CREATE_CMD_ENTRY(RASFLAG_AUTHTYPE_ADD, HandleRasflagAuthtypeAdd),
    CREATE_CMD_ENTRY(RASFLAG_LINK_ADD,     HandleRasflagLinkAdd),
    CREATE_CMD_ENTRY(RASFLAG_MLINK_ADD,    HandleRasflagMlinkAdd),
    CREATE_CMD_ENTRY(DOMAIN_REGISTER,      HandleDomainRegister),
};

CMD_ENTRY  g_RasDelCmdTable[] =
{
    CREATE_CMD_ENTRY(RASFLAG_AUTHTYPE_DEL, HandleRasflagAuthtypeDel),
    CREATE_CMD_ENTRY(RASFLAG_LINK_DEL,     HandleRasflagLinkDel),
    CREATE_CMD_ENTRY(RASFLAG_MLINK_DEL,    HandleRasflagMlinkDel),
    CREATE_CMD_ENTRY(DOMAIN_UNREGISTER,    HandleDomainUnregister),
};

CMD_ENTRY  g_RasSetCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(TRACE_SET,         HandleTraceSet, CMD_FLAG_HIDDEN),
    CREATE_CMD_ENTRY(RASUSER_SET,          HandleUserSet),
    CREATE_CMD_ENTRY(RASFLAG_AUTHMODE_SET, HandleRasflagAuthmodeSet),
};

CMD_ENTRY g_RasShowCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(TRACE_SHOW,         HandleTraceShow, CMD_FLAG_HIDDEN),
    CREATE_CMD_ENTRY(RASUSER_SHOW,          HandleUserShow),
    CREATE_CMD_ENTRY(RASFLAG_AUTHMODE_SHOW, HandleRasflagAuthmodeShow),
    CREATE_CMD_ENTRY(RASFLAG_AUTHTYPE_SHOW, HandleRasflagAuthtypeShow),
    CREATE_CMD_ENTRY(RASFLAG_LINK_SHOW,     HandleRasflagLinkShow),
    CREATE_CMD_ENTRY(RASFLAG_MLINK_SHOW,    HandleRasflagMlinkShow),
    CREATE_CMD_ENTRY(DOMAIN_SHOWREG,        HandleDomainShowRegistration),
    CREATE_CMD_ENTRY(SHOW_SERVERS,          HandleRasShowServers),
    CREATE_CMD_ENTRY(SHOW_CLIENT,           HandleClientShow),
};

CMD_GROUP_ENTRY g_RasCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,       g_RasAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DEL,       g_RasDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,       g_RasSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,      g_RasShowCmdTable),
};

ULONG g_ulNumGroups = sizeof(g_RasCmdGroups) / sizeof(CMD_GROUP_ENTRY);

BOOL g_bCommit, g_bRasDirty = FALSE;
GUID g_RasmontrGuid = RASMONTR_GUID, g_NetshGuid = NETSH_ROOT_GUID;
DWORD g_dwNumTableEntries, g_dwParentVersion;
ULONG g_ulInitCount;
HANDLE g_hModule;
RASMON_SERVERINFO g_ServerInfo, *g_pServerInfo = NULL;
NS_CONTEXT_CONNECT_FN RasConnect;

DWORD
Connect(
    IN LPCWSTR pwszServer);

DWORD
WINAPI
RasCommit(
    IN DWORD dwAction)
{
    BOOL bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. If current state is commit, then
            // nothing to be done.
            //
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }
    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //
    return NO_ERROR;
}

DWORD
WINAPI
RasStartHelper(
    IN CONST GUID* pguidParent,
    IN DWORD dwVersion)
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    g_dwParentVersion = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext  = L"ras";
    attMyAttributes.guidHelper   = g_RasmontrGuid;
    attMyAttributes.dwVersion    = 1;
    attMyAttributes.dwFlags      = 0;
    attMyAttributes.ulNumTopCmds = 0;
    attMyAttributes.pTopCmds     = NULL;
    attMyAttributes.ulNumGroups  = g_ulNumGroups;
    attMyAttributes.pCmdGroups   = (CMD_GROUP_ENTRY (*)[])&g_RasCmdGroups;
    attMyAttributes.pfnCommitFn  = RasCommit;
    attMyAttributes.pfnDumpFn    = RasDump;
    attMyAttributes.pfnConnectFn = RasConnect;

    dwErr = RegisterContext(&attMyAttributes);

    return dwErr;
}

VOID
Disconnect()
{
    if (g_pServerInfo->hkMachine)
    {
        RegCloseKey(g_pServerInfo->hkMachine);
    }
    //
    // Clear out any server handles
    //
    UserServerInfoUninit(g_pServerInfo);
    //
    // Free up the server name if needed
    //
    if (g_pServerInfo->pszServer)
    {
        RutlFree(g_pServerInfo->pszServer);
        g_pServerInfo->pszServer = NULL;
    }
}

DWORD
WINAPI
RasUnInit(
    IN DWORD dwReserved)
{
    if(InterlockedDecrement(&g_ulInitCount) != 0)
    {
        return NO_ERROR;
    }

    Disconnect();

    return NO_ERROR;
}

BOOL
WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD
WINAPI
InitHelperDll(
    IN DWORD dwNetshVersion,
    OUT PVOID pReserved)
{
    DWORD  dwSize = 0, dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //
    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }

    g_bCommit = TRUE;
    //
    // Initialize the global server info
    //
    g_pServerInfo = &g_ServerInfo;
    ZeroMemory(g_pServerInfo, sizeof(RASMON_SERVERINFO));
    Connect(NULL);
    //
    // Register this module as a helper to the netsh root
    // context.
    //
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.dwVersion          = RAS_HELPER_VERSION;
    attMyAttributes.guidHelper         = g_RasmontrGuid;
    attMyAttributes.pfnStart           = RasStartHelper;
    attMyAttributes.pfnStop            = NULL;

    RegisterHelper( &g_NetshGuid, &attMyAttributes );
    //
    // Register any sub contexts implemented in this dll
    //
    dwErr = RasContextInstallSubContexts();
    if (dwErr != NO_ERROR)
    {
        RasUnInit(0);
        return dwErr;
    }

    return NO_ERROR;
}

DWORD
Connect(
    IN LPCWSTR pwszServer)
{
    DWORD dwErr, dwSize;

    do
    {
        //
        // Try to connect to the new router
        //
        ZeroMemory(g_pServerInfo, sizeof(RASMON_SERVERINFO));

        if (pwszServer)
        {
            //
            // Calculate the size to initialize the server name
            //
            dwSize = (wcslen(pwszServer) + 1) * sizeof(WCHAR);
            if (*pwszServer != g_pwszBackSlash)
            {
                dwSize += 2 * sizeof(WCHAR);
            }
            //
            // Allocate the server name
            //
            g_pServerInfo->pszServer = RutlAlloc(dwSize, FALSE);
            if(g_pServerInfo->pszServer == NULL)
            {
                dwErr = GetLastError();
                break;
            }

            if (*pwszServer != g_pwszBackSlash)
            {
                wcscpy(g_pServerInfo->pszServer, L"\\\\");
                wcscpy(g_pServerInfo->pszServer + 2, pwszServer);
            }
            else
            {
                wcscpy(g_pServerInfo->pszServer, pwszServer);
            }
        }
        //
        // Initialize the build number for the server
        //
        dwErr = RutlGetOsVersion(g_pServerInfo);
        if (dwErr)
        {
            break;
        }
        //
        // As soon as this doesn't cause a hang (bug in netcfg), readd it here.
        //
        // dwErr = UserServerInfoInit( g_pServerInfo );
        //

    } while (FALSE);

    return dwErr;
}

DWORD
RasConnectToServer(
    IN LPCWSTR pwszServer)
{
    DWORD dwErr = NO_ERROR, dwSize;

    do
    {
        if ((g_pServerInfo->pszServer != pwszServer) &&
               (!pwszServer || !g_pServerInfo->pszServer ||
                wcscmp(pwszServer, g_pServerInfo->pszServer))
           )
        {
            //
            // Disconnect from the old router
            //
            Disconnect();

            dwErr = Connect(pwszServer);
        }

    } while (FALSE);

    return dwErr;
}

DWORD
WINAPI
RasConnect(
    IN LPCWSTR pwszMachineName)
{
    //
    // If context info is dirty, reregister it
    //
    if (g_bRasDirty)
    {
        RasStartHelper(NULL, g_dwParentVersion);
    }

    return RasConnectToServer(pwszMachineName);
}

DWORD
Init()
{
    //
    // Initialize the global server info
    //
    if (!g_pServerInfo)
    {
        g_pServerInfo = &g_ServerInfo;
        Connect(NULL);
    }

    return NO_ERROR;
}

DWORD
UnInit()
{
    if (g_pServerInfo)
    {
        Disconnect();
        g_pServerInfo = NULL;
    }

    return NO_ERROR;
}

DWORD
ClearAll()
{
    return DiagClearAll(FALSE);
}

DWORD
GetReport(
    IN DWORD dwFlags,
    IN OUT LPCWSTR pwszString,
    IN OPTIONAL DiagGetReportCb pCallback,
    IN OPTIONAL PVOID pContext)
{
    return DiagGetReport(dwFlags, pwszString, pCallback, pContext);
}

BOOL
GetState()
{
    return DiagGetState();
}

DWORD
SetAll(
    IN BOOL fEnable)
{
    return DiagSetAll(fEnable, FALSE);
}

DWORD
SetAllRas(
    IN BOOL fEnable)
{
    return DiagSetAllRas(fEnable);
}

DWORD
WppTrace()
{
    DiagInitWppTracing();

    return NO_ERROR;
}

DWORD
GetDiagnosticFunctions(
    OUT RAS_DIAGNOSTIC_FUNCTIONS* pFunctions)
{
    if (!pFunctions)
    {
        return ERROR_INVALID_PARAMETER;
    }

    pFunctions->Init  = Init;
    pFunctions->UnInit  = UnInit;

    pFunctions->ClearAll  = ClearAll;
    pFunctions->GetReport = GetReport;
    pFunctions->GetState  = GetState;
    pFunctions->SetAll    = SetAll;
    pFunctions->SetAllRas = SetAllRas;
    pFunctions->WppTrace  = WppTrace;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasnbf.h ===
/*
    File:   rasnbf.h
    
    Definitions for the 'ras nbf' sub context

    3/2/99
*/

#ifndef __RASNBF_H
#define __RASNBF_H

#define RASNBF_VERSION 1

// 69f21bc3-d349-11d2-9b76-00104bca495b
#define RASNBF_GUID \
{ 0x69f21bc3, 0xd349, 0x11d2, {0x9b, 0x76, 0x00, 0x10, 0x4b, 0xca, 0x49, 0x5b} }

NS_HELPER_START_FN RasNbfStartHelper;

// 
// Command handlers
//
NS_CONTEXT_DUMP_FN RasNbfDump;

FN_HANDLE_CMD   RasNbfHandleShow;
FN_HANDLE_CMD   RasNbfHandleSetNegotiation;
FN_HANDLE_CMD   RasNbfHandleSetAccess;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasnbf.c ===
/*
    File:   rasnbf.h
    
    The 'remoteaccess nbf' sub context

    3/2/99
*/

#include "precomp.h"
#include "rasnbf.h"

//
// Local prototypes
//
BOOL
WINAPI
RasNbfCheckVersion(
    IN  UINT     CIMOSType,
    IN  UINT     CIMOSProductSuite,
    IN  LPCWSTR  CIMOSVersion,
    IN  LPCWSTR  CIMOSBuildNumber,
    IN  LPCWSTR  CIMServicePackMajorVersion,
    IN  LPCWSTR  CIMServicePackMinorVersion,
    IN  UINT     CIMProcessorArchitecture,
    IN  DWORD    dwReserved
    );

// The guid for this context
//
GUID g_RasNbfGuid = RASNBF_GUID;
static PWCHAR g_pszServer = NULL;
static DWORD g_dwBuild = 0;

// The commands supported in this context
//
CMD_ENTRY  g_RasNbfSetCmdTable[] = 
{
    // Whistler bug 249293, changes for architecture version checking
    //
    CREATE_CMD_ENTRY(RASNBF_SET_NEGOTIATION,RasNbfHandleSetNegotiation),
    CREATE_CMD_ENTRY(RASNBF_SET_ACCESS,     RasNbfHandleSetAccess),
};

CMD_ENTRY  g_RasNbfShowCmdTable[] = 
{
    // Whistler bug 249293, changes for architecture version checking
    //
    CREATE_CMD_ENTRY(RASNBF_SHOW_CONFIG,    RasNbfHandleShow),
};

CMD_GROUP_ENTRY g_RasNbfCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_RasNbfSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_RasNbfShowCmdTable),
};

ULONG g_ulRasNbfNumGroups = sizeof(g_RasNbfCmdGroups)/sizeof(CMD_GROUP_ENTRY);

//
// Flags that control how/what info is read/written
// in the RASNBF_CB structure
//
#define RASNBF_F_EnableIn    0x1
#define RASNBF_F_Access      0x2
#define RASNBF_F_All         0xFFFF

//
// Control block for ras nbf configuration
//
typedef struct _RASNBF_CB
{
    DWORD dwFlags;      // See RASNBF_F_* values

    BOOL bEnableIn;
    BOOL bAccess;

} RASNBF_CB;

//
// Nbf specific registry parameters
//
WCHAR pszNbfParams[]                = L"Nbf";

//
// Prototypes of functions that manipulate the 
// RASNBF_CB structures
//
DWORD 
RasNbfCbCleanup(
    IN RASNBF_CB* pConfig);

DWORD 
RasNbfCbCreateDefault(
    OUT RASNBF_CB** ppConfig);

DWORD
RasNbfCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey);
    
DWORD 
RasNbfCbRead(
    IN  LPCWSTR pszServer,
    OUT RASNBF_CB* pConfig);

DWORD 
RasNbfCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASNBF_CB* pConfig);

// 
// Callback determines if a command is valid on a given architecture
//
BOOL
WINAPI
RasNbfCheckVersion(
    IN  UINT     CIMOSType,
    IN  UINT     CIMOSProductSuite,
    IN  LPCWSTR  CIMOSVersion,
    IN  LPCWSTR  CIMOSBuildNumber,
    IN  LPCWSTR  CIMServicePackMajorVersion,
    IN  LPCWSTR  CIMServicePackMinorVersion,
    IN  UINT     CIMProcessorArchitecture,
    IN  DWORD    dwReserved
    )
{
    INT iBuild = _wtoi(CIMOSBuildNumber);

    // Only available pre-whistler
    return ((iBuild != 0) && (iBuild <= 2195));
}


//
// Entry called by rasmontr to register this context
//
DWORD 
WINAPI
RasNbfStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    // Whistler bug 249293, changes for architecture version checking
    //
    attMyAttributes.pfnOsVersionCheck= RasNbfCheckVersion;
    attMyAttributes.pwszContext      = L"netbeui";
    attMyAttributes.guidHelper       = g_RasNbfGuid;
    attMyAttributes.dwVersion        = RASNBF_VERSION;
    attMyAttributes.dwFlags          = 0;
    attMyAttributes.ulNumTopCmds     = 0;
    attMyAttributes.pTopCmds         = NULL;
    attMyAttributes.ulNumGroups      = g_ulRasNbfNumGroups;
    attMyAttributes.pCmdGroups       = (CMD_GROUP_ENTRY (*)[])&g_RasNbfCmdGroups;
    attMyAttributes.pfnDumpFn        = RasNbfDump;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
RasNbfDisplayConfig(
    IN  BOOL bReport)
{
    DWORD dwErr = NO_ERROR;
    RASNBF_CB* pConfig = NULL;
    PWCHAR pszEnabled = NULL, pszAccess = NULL;
    
    do
    {
        // Get a default config blob
        //
        dwErr = RasNbfCbCreateDefault(&pConfig);
        BREAK_ON_DWERR( dwErr );

        // Read in all of the values
        //
        pConfig->dwFlags = RASNBF_F_All;
        dwErr = RasNbfCbRead(g_pszServer, pConfig);
        BREAK_ON_DWERR( dwErr );

        if (bReport)
        {
            pszEnabled = 
                RutlStrDup(pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = 
                RutlStrDup(pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);

            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SERVERCONFIG,
                g_pszServer,
                pszEnabled,
                pszAccess);
        }
        else
        {
            pszEnabled = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bEnableIn ? TOKEN_ALLOW : TOKEN_DENY);
            pszAccess = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_MODE,
                            pConfig->bAccess ? TOKEN_ALL : TOKEN_SERVERONLY);

            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SCRIPTHEADER);

            DisplayMessageT(DMP_RASNBF_PUSHD);

            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SET_CMD,
                DMP_RASNBF_SET_NEGOTIATION,
                pszEnabled);

            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SET_CMD,
                DMP_RASNBF_SET_ACCESS,
                pszAccess);

            DisplayMessageT(DMP_RASNBF_POPD);

            DisplayMessage(
                g_hModule,
                MSG_RASNBF_SCRIPTFOOTER);
        }

    } while (FALSE);

    // Cleanup
    {
        if (pConfig)
        {
            RasNbfCbCleanup(pConfig);
        }
        if (pszEnabled)
        {
            RutlFree(pszEnabled);
        }
        if (pszAccess)
        {
            RutlFree(pszAccess);
        }
    }

    return dwErr;
}

DWORD
WINAPI
RasNbfDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    return RasNbfDisplayConfig(FALSE);
}

DWORD
RasNbfHandleSetAccess(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASNBF_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALL, TRUE}, {TOKEN_SERVERONLY, FALSE} };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASNBF_F_Access;
        Config.bAccess = dwValue;
        dwErr = RasNbfCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasNbfHandleSetNegotiation(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR, dwValue = 0;
    RASNBF_CB Config;
    TOKEN_VALUE rgEnum[] = { {TOKEN_ALLOW, TRUE}, {TOKEN_DENY, FALSE} };
    RASMON_CMD_ARG  pArgs[] =
    {
        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE, TRUE, FALSE},
            rgEnum,
            sizeof(rgEnum)/sizeof(*rgEnum),
            NULL
        }
    };

    do
    {
        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    pbDone,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR( dwErr );

        dwValue = RASMON_CMD_ARG_GetDword(&pArgs[0]);

        // If successful, go ahead and set the info
        //
        ZeroMemory(&Config, sizeof(Config));
        Config.dwFlags = RASNBF_F_EnableIn;
        Config.bEnableIn = dwValue;
        dwErr = RasNbfCbWrite(g_pszServer, &Config);
        if (dwErr != NO_ERROR)
        {
            DisplayError(NULL, dwErr);
            break;
        }
    
    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RasNbfHandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwNumArgs = dwArgCount - dwCurrentIndex;

    // Check that the number of arguments is correct
    //
    if (dwNumArgs > 0)
    {
        DisplayMessage(
            g_hModule,
            HLP_RASNBF_SHOW_CONFIG_EX,
            DMP_RASNBF_SHOW_CONFIG);

        return NO_ERROR;
    }

    return RasNbfDisplayConfig(TRUE);
}

// 
// Cleans up a config control block
//
DWORD 
RasNbfCbCleanup(
    IN RASNBF_CB* pConfig)
{
    if (pConfig)
    {
        RutlFree(pConfig);
    }

    return NO_ERROR;
}

//
// Creates a default config control block
//
DWORD 
RasNbfCbCreateDefault(
    OUT RASNBF_CB** ppConfig)
{
    RASNBF_CB* pConfig = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        pConfig = (RASNBF_CB*) RutlAlloc(sizeof(RASNBF_CB), TRUE);
        if (pConfig == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pConfig->bEnableIn   = TRUE;
        pConfig->bAccess     = TRUE;

        *ppConfig = pConfig;

    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            RasNbfCbCleanup(pConfig);
        }
    }

    return dwErr;
}

//
// Helper function opens the ras nbf config registry key
//
DWORD 
RasNbfCbOpenRegKeys(
    IN  LPCWSTR pszServer,
    OUT HKEY* phKey)
{
    DWORD dwErr = NO_ERROR;
    WCHAR pszKey[MAX_PATH];

    do
    {
        // Generate the parameters key name
        //
        wsprintfW(
            pszKey, 
            L"%s%s", 
            pszRemoteAccessParamStub, 
            pszNbfParams);

        // Open the parameters keys
        //
        dwErr = RegOpenKeyEx(
                    g_pServerInfo->hkMachine,
                    pszKey,
                    0,
                    KEY_READ | KEY_WRITE,
                    phKey);
        BREAK_ON_DWERR( dwErr );

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

//
// Functions that manipulate RASNBF_CB's
//
DWORD 
RasNbfCbRead(
    IN  LPCWSTR pszServer,
    OUT RASNBF_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasNbfCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );

        // Load the params from the registry 
        //
        if (pConfig->dwFlags & RASNBF_F_EnableIn)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszEnableIn,
                        &pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASNBF_F_Access)
        {
            dwErr = RutlRegReadDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        &pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}

DWORD 
RasNbfCbWrite(
    IN  LPCWSTR pszServer,
    IN  RASNBF_CB* pConfig)
{
    HKEY hkParams = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        // Get a handle to the server's registry config
        //
        dwErr = RasNbfCbOpenRegKeys(
                    pszServer,
                    &hkParams);
        BREAK_ON_DWERR( dwErr );
        
        // Write out the params to the registry 
        //
        if (pConfig->dwFlags & RASNBF_F_EnableIn)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszEnableIn,
                        pConfig->bEnableIn);
            BREAK_ON_DWERR( dwErr );
        }

        if (pConfig->dwFlags & RASNBF_F_Access)
        {
            dwErr = RutlRegWriteDword(
                        hkParams,
                        pszAllowNetworkAccess,
                        pConfig->bAccess);
            BREAK_ON_DWERR( dwErr );
        }

    } while (FALSE);

    // Cleanup
    {
        if (hkParams)
        {
            RegCloseKey(hkParams);
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\regprint.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    regprint.h

Abstract:

    

Author:

    Jeff Sigman (JeffSi) September 14, 2001

Environment:

    User Mode

Revision History:

    JeffSi      09/14/01        Created

--*/

#ifndef _REGPRINT_H_
#define _REGPRINT_H_

#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))
#define IsRegStringType(x) (((x) == REG_SZ) || ((x) == REG_EXPAND_SZ) || ((x) == REG_MULTI_SZ))
#define ExtraAllocLen(Type) (IsRegStringType((Type)) ? sizeof(WCHAR) : 0)
#define HKEY_ROOT ((HKEY) 0X7FFFFFFF)

#define RASREGCHK01 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\AppleTalk\\Parameters\\Adapters\\NdisWanAtalk"
#define RASREGCHK02 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\AsyncMac"
#define RASREGCHK03 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\IpFilterDriver"
#define RASREGCHK04 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\IpInIp"
#define RASREGCHK05 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\IpNat"
#define RASREGCHK06 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\NdisTapi"
#define RASREGCHK07 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\NdisWan"
#define RASREGCHK08 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\NwlnkFlt"
#define RASREGCHK09 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\NwlnkFwd"
#define RASREGCHK10 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\NwlnkIpx\\Parameters\\Adapters\\NdisWanIpx"
#define RASREGCHK11 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\PptpMiniport"
#define RASREGCHK12 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Ptilink"
#define RASREGCHK13 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\RasAcd"
#define RASREGCHK14 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\RasAuto"
#define RASREGCHK15 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Rasirda"
#define RASREGCHK16 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Rasl2tp"
#define RASREGCHK17 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\RasMan"
#define RASREGCHK18 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\RasPppoe"
#define RASREGCHK19 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Raspti"
#define RASREGCHK20 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\RemoteAccess"
#define RASREGCHK21 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters\\NdisWanIp"
#define RASREGCHK22 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Wanarp"
#define RASREGCHK23 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002bE10318}"
#define RASREGCHK24 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\DeviceClasses\\{ad498944-762f-11d0-8dcb-00c04fc3358c}"
#define RASREGCHK25 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}"
#define RASREGCHK26 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E974-E325-11CE-BFC1-08002BE10318}"
#define RASREGCHK27 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E975-E325-11CE-BFC1-08002BE10318}"
#define RASREGCHK28 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\LEGACY_NDISTAPI"
#define RASREGCHK29 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\LEGACY_RASACD"
#define RASREGCHK30 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\LEGACY_RASMAN"
#define RASREGCHK31 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\LEGACY_WANARP"
#define RASREGCHK32 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_IRDAMINIPORT"
#define RASREGCHK33 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_IRMODEMMINIPORT"
#define RASREGCHK34 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_L2TPMINIPORT"
#define RASREGCHK35 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_NDISWANATALK"
#define RASREGCHK36 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_NDISWANBH"
#define RASREGCHK37 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_NDISWANIP"
#define RASREGCHK38 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_NDISWANIPX"
#define RASREGCHK39 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_PPPOEMINIPORT"
#define RASREGCHK40 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_PPTPMINIPORT"
#define RASREGCHK41 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\MS_PTIMINIPORT"
#define RASREGCHK42 \
    L"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Enum\\ROOT\\SW&{EEAB7790-C514-11D1-B42B-00805FC1270E}"
#define RASREGCHK43 \
    L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Ras"
#define RASREGCHK44 \
    L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Router"
#define RASREGCHK45 \
    L"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Connection Manager"
#define RASREGCHK46 \
    L"HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Connection Manager"

typedef struct
{
    PWCHAR RootText;
    UINT TextLength;
    HKEY RootKey;

} REGISTRYROOT, *PREGISTRYROOT;

VOID
PrintRasRegistryKeys(
    IN BUFFER_WRITE_FILE* pBuff);

#endif // _REGPRINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rmstring.h ===
#define MSG_HELP_START                        L"%1!-14s! - "
#define MSG_NEWLINE                           L"\n"

#define CMD_GROUP_ADD                         L"add"
#define CMD_GROUP_DEL                         L"delete"
#define CMD_GROUP_SHOW                        L"show"
#define CMD_GROUP_SET                         L"set"
#define CMD_GROUP_ENABLE                      L"enable"
#define CMD_GROUP_DISABLE                     L"disable"
#define CMD_GROUP_REGISTER                    L"register"
#define CMD_GROUP_UNREGISTER                  L"unregister"

#define CMD_RAS_HELP1                         L"help"
#define CMD_RAS_HELP2                         L"?"
#define CMD_RAS_DUMP                          L"dump" 

#define CMD_RASFLAG_SET                       L"rasflag"
#define CMD_RASFLAG_SHOW                      L"rasflag"
#define CMD_RASFLAG_AUTHMODE_SET              L"authmode"
#define CMD_RASFLAG_AUTHMODE_SHOW             L"authmode"
#define CMD_RASFLAG_AUTHTYPE_ADD              L"authtype"
#define CMD_RASFLAG_AUTHTYPE_DEL              L"authtype"
#define CMD_RASFLAG_AUTHTYPE_SHOW             L"authtype"
#define CMD_RASFLAG_LINK_ADD                  L"link"
#define CMD_RASFLAG_LINK_DEL                  L"link"
#define CMD_RASFLAG_LINK_SHOW                 L"link"
#define CMD_RASFLAG_MLINK_ADD                 L"multilink"
#define CMD_RASFLAG_MLINK_DEL                 L"multilink"
#define CMD_RASFLAG_MLINK_SHOW                L"multilink"

#define CMD_RASUSER_SHOW                      L"user"
#define CMD_RASUSER_SET                       L"user"

#define CMD_DOMAIN_REGISTER                   L"registeredserver"
#define CMD_DOMAIN_UNREGISTER                 L"registeredserver"
#define CMD_DOMAIN_SHOWREG                    L"registeredserver"

#define CMD_SHOW_SERVERS                      L"activeservers"

#define CMD_SHOW_CLIENT                       L"client"

#define DMP_RASFLAG_SET                       L"set rasflag"
#define DMP_RASFLAG_SHOW                      L"show rasflag"
#define DMP_RASFLAG_AUTHMODE_SET              L"set authmode"
#define DMP_RASFLAG_AUTHMODE_SHOW             L"show authmode"
#define DMP_RASFLAG_AUTHTYPE_ADD              L"add authtype"
#define DMP_RASFLAG_AUTHTYPE_DEL              L"delete authtype"
#define DMP_RASFLAG_AUTHTYPE_SHOW             L"show authtype"
#define DMP_RASFLAG_LINK_ADD                  L"add link"
#define DMP_RASFLAG_LINK_DEL                  L"delete link"
#define DMP_RASFLAG_LINK_SHOW                 L"show link"
#define DMP_RASFLAG_MLINK_ADD                 L"add multilink"
#define DMP_RASFLAG_MLINK_DEL                 L"delete multilink"
#define DMP_RASFLAG_MLINK_SHOW                L"show multilink"
#define DMP_RASUSER_SHOW                      L"show user"
#define DMP_RASUSER_SET                       L"set user"
#define DMP_DOMAIN_REGISTER                   L"add registeredserver"
#define DMP_DOMAIN_UNREGISTER                 L"delete registeredserver"
#define DMP_DOMAIN_SHOWREG                    L"show registeredserver"
#define DMP_SHOW_SERVERS                      L"show activeservers"
#define DMP_SHOW_CLIENT                       L"show client"

#define TOKEN_NAME                            L"name"
#define TOKEN_DIALIN                          L"dialin"
#define TOKEN_CBPOLICY                        L"cbpolicy"
#define TOKEN_CBNUMBER                        L"cbnumber"
#define TOKEN_PERMIT                          L"permit"
#define TOKEN_POLICY                          L"policy"
#define TOKEN_DENY                            L"deny"
#define TOKEN_NONE                            L"none"
#define TOKEN_ADMIN                           L"admin"
#define TOKEN_CALLER                          L"caller"
#define TOKEN_FILE                            L"file"
#define TOKEN_PASSWORD                        L"password"
#define TOKEN_FULLNAME                        L"fullname"
#define TOKEN_ADDSET                          L"addset"
#define TOKEN_MODE                            L"mode"
#define TOKEN_SET                             L"set"
#define TOKEN_ADD                             L"add"
#define TOKEN_DELETE                          L"delete"
#define TOKEN_REPORT                          L"report"
#define TOKEN_DOMAIN                          L"domain"
#define TOKEN_SERVER                          L"server"
#define TOKEN_FLAG                            L"flag"
#define TOKEN_LEVEL                           L"level"
#define TOKEN_STANDARD                        L"standard"
#define TOKEN_LEGACY                          L"legacy"
#define TOKEN_STATE                           L"state"
#define TOKEN_ENABLED                         L"enabled"
#define TOKEN_DISABLED                        L"disabled"
#define TOKEN_NODCC                           L"nodcc"
#define TOKEN_BYPASS                          L"bypass"
#define TOKEN_PAP                             L"PAP"
#define TOKEN_SPAP                            L"SPAP"
#define TOKEN_MD5CHAP                         L"MD5CHAP"
#define TOKEN_MSCHAP                          L"MSCHAP"
#define TOKEN_MSCHAP2                         L"MSCHAPv2"
#define TOKEN_EAP                             L"EAP"
#define TOKEN_TYPE                            L"type"
#define TOKEN_COMPONENT                       L"component"
#define TOKEN_SWC                             L"SWC"
#define TOKEN_LCP                             L"LCP"
#define TOKEN_MULTI                           L"MULTI"
#define TOKEN_BACP                            L"BACP"

#define DMP_RAS_PUSHD                         L"pushd ras\n\n"
#define DMP_RAS_POPD                          L"\npopd\n"

//
// Strings used by the 'ras ip' context
//

#define CMD_RASIP_HELP1                       L"help"
#define CMD_RASIP_HELP2                       L"?"
#define CMD_RASIP_DUMP                        L"dump"

#define CMD_RASIP_SHOW_CONFIG                 L"config"
#define CMD_RASIP_SET_NEGOTIATION             L"negotiation"
#define CMD_RASIP_SET_ACCESS                  L"access"
#define CMD_RASIP_SET_ASSIGNMENT              L"addrassign"
#define CMD_RASIP_SET_CALLERSPEC              L"addrreq"
#define CMD_RASIP_SET_NETBTBCAST              L"broadcastnameresolution"
#define CMD_RASIP_ADD_RANGE                   L"range"
#define CMD_RASIP_DEL_RANGE                   L"range"
#define CMD_RASIP_DEL_POOL                    L"pool"

#define DMP_RASIP_SHOW_CONFIG                 L"show config"
#define DMP_RASIP_SET_NEGOTIATION             L"set negotiation"
#define DMP_RASIP_SET_ACCESS                  L"set access"
#define DMP_RASIP_SET_ASSIGNMENT              L"set addrassign"
#define DMP_RASIP_SET_CALLERSPEC              L"set addrreq"
#define DMP_RASIP_SET_NETBTBCAST              L"set broadcastnameresolution"
#define DMP_RASIP_ADD_RANGE                   L"add range"
#define DMP_RASIP_DEL_RANGE                   L"delete range"
#define DMP_RASIP_DEL_POOL                    L"delete pool"

#define TOKEN_METHOD                          L"method"
#define TOKEN_FROM                            L"from"
#define TOKEN_TO                              L"to"
#define TOKEN_MODE                            L"mode"

#define TOKEN_AUTO                            L"auto"
#define TOKEN_POOL                            L"pool"
#define TOKEN_ALLOW                           L"allow"
#define TOKEN_DENY                            L"deny"
#define TOKEN_ALL                             L"all"
#define TOKEN_SERVERONLY                      L"serveronly"

#define DMP_RASIP_PUSHD                       L"pushd ras ip\n\n"
#define DMP_RASIP_POPD                        L"\npopd\n"

//
// Strings used by the 'ras ipx' context
//

#define CMD_RASIPX_HELP1                       L"help"
#define CMD_RASIPX_HELP2                       L"?"
#define CMD_RASIPX_DUMP                        L"dump"

#define TOKEN_AUTOSAME                         L"autosame"
#define TOKEN_POOLSAME                         L"poolsame"
#define TOKEN_FIRSTNET                         L"firstnet"
#define TOKEN_SIZE                             L"size"
#define TOKEN_DYNAMIC                          L"dynamic"

#define CMD_RASIPX_SHOW_CONFIG                 L"config"
#define CMD_RASIPX_SET_NEGOTIATION             L"negotiation"
#define CMD_RASIPX_SET_ACCESS                  L"access"
#define CMD_RASIPX_SET_ASSIGNMENT              L"netassign"
#define CMD_RASIPX_SET_POOL                    L"pool"
#define CMD_RASIPX_SET_CALLERSPEC              L"nodereq"

#define DMP_RASIPX_SHOW_CONFIG                 L"show config"
#define DMP_RASIPX_SET_NEGOTIATION             L"set negotiation"
#define DMP_RASIPX_SET_ACCESS                  L"set access"
#define DMP_RASIPX_SET_ASSIGNMENT              L"set netassign"
#define DMP_RASIPX_SET_POOL                    L"set pool"
#define DMP_RASIPX_SET_CALLERSPEC              L"set nodereq"

#define DMP_RASIPX_PUSHD                       L"pushd ras ipx\n\n"
#define DMP_RASIPX_POPD                        L"\npopd\n"

//
// Strings used by the 'ras nbf' context
//

#define CMD_RASNBF_HELP1                       L"help"
#define CMD_RASNBF_HELP2                       L"?"
#define CMD_RASNBF_DUMP                        L"dump"

#define CMD_RASNBF_SHOW_CONFIG                 L"config"
#define CMD_RASNBF_SET_NEGOTIATION             L"negotiation"
#define CMD_RASNBF_SET_ACCESS                  L"access"

#define DMP_RASNBF_SHOW_CONFIG                 L"show config"
#define DMP_RASNBF_SET_NEGOTIATION             L"set negotiation"
#define DMP_RASNBF_SET_ACCESS                  L"set access"

#define DMP_RASNBF_PUSHD                       L"pushd ras netbeui\n\n"
#define DMP_RASNBF_POPD                        L"\npopd\n"

//
// Strings used by the 'ras at' context
//

#define CMD_RASAT_HELP1                        L"help"
#define CMD_RASAT_HELP2                        L"?"
#define CMD_RASAT_DUMP                         L"dump"

#define CMD_RASAT_SHOW_CONFIG                  L"config"
#define CMD_RASAT_SET_NEGOTIATION              L"negotiation"

#define DMP_RASAT_SHOW_CONFIG                  L"show config"
#define DMP_RASAT_SET_NEGOTIATION              L"set negotiation"

#define DMP_RASAT_PUSHD                        L"pushd ras appletalk\n\n"
#define DMP_RASAT_POPD                         L"\npopd\n"

//
// Strings used by the 'ras aaaa' context
//

#define CMD_RASAAAA_HELP1                        L"help"
#define CMD_RASAAAA_HELP2                        L"?"
#define CMD_RASAAAA_DUMP                         L"dump"

#define CMD_RASAAAA_ADD_AUTHSERV                 L"authserver"
#define CMD_RASAAAA_ADD_ACCTSERV                 L"acctserver"

#define CMD_RASAAAA_DEL_AUTHSERV                 L"authserver"
#define CMD_RASAAAA_DEL_ACCTSERV                 L"acctserver"

#define CMD_RASAAAA_SET_AUTH                     L"authentication"
#define CMD_RASAAAA_SET_ACCT                     L"accounting"
#define CMD_RASAAAA_SET_AUTHSERV                 L"authserver"
#define CMD_RASAAAA_SET_ACCTSERV                 L"acctserver"

#define CMD_RASAAAA_SHOW_AUTH                    L"authentication"
#define CMD_RASAAAA_SHOW_ACCT                    L"accounting"
#define CMD_RASAAAA_SHOW_AUTHSERV                L"authserver"
#define CMD_RASAAAA_SHOW_ACCTSERV                L"acctserver"

#define DMP_RASAAAA_ADD_AUTHSERV                 L"add authserver"
#define DMP_RASAAAA_ADD_ACCTSERV                 L"add acctserver"
#define DMP_RASAAAA_DEL_AUTHSERV                 L"delete authserver"
#define DMP_RASAAAA_DEL_ACCTSERV                 L"delete acctserver"
#define DMP_RASAAAA_SET_AUTH                     L"set authentication"
#define DMP_RASAAAA_SET_ACCT                     L"set accounting"
#define DMP_RASAAAA_SET_AUTHSERV                 L"set authserver"
#define DMP_RASAAAA_SET_ACCTSERV                 L"set acctserver"
#define DMP_RASAAAA_SHOW_AUTH                    L"show authentication"
#define DMP_RASAAAA_SHOW_ACCT                    L"show accounting"
#define DMP_RASAAAA_SHOW_AUTHSERV                L"show authserver"
#define DMP_RASAAAA_SHOW_ACCTSERV                L"show acctserver"

#define TOKEN_SECRET                             L"secret"
#define TOKEN_PORT                               L"port"
#define TOKEN_INITSCORE                          L"init-score"
#define TOKEN_TIMEOUT                            L"timeout"
#define TOKEN_SIGNATURE                          L"signature"
#define TOKEN_MESSAGES                           L"messages"
#define TOKEN_WINDOWS                            L"windows"
#define TOKEN_RADIUS                             L"radius"
#define TOKEN_PROVIDER                           L"provider"
#define TOKEN_RASAAAA_ALLSERVERS                 L"*"

#define DMP_RASAAAA_PUSHD                        L"pushd ras aaaa\n\n"
#define DMP_RASAAAA_POPD                         L"\npopd\n"

//
// Strings used by the 'ras diag' context
//

#define CMD_TRACE_SET                            L"tracing"
#define CMD_TRACE_SHOW                           L"tracing"

#define CMD_RASDIAG_SET_TRACEALL                 L"tracefacilities"
#define CMD_RASDIAG_SHOW_TRACEALL                L"tracefacilities"

#define CMD_RASDIAG_SET_RASTRACE                 L"rastracing"
#define CMD_RASDIAG_SHOW_RASTRACE                L"rastracing"
#define DMP_TRACE_SET                            L"set rastracing"

#define CMD_RASDIAG_SET_MODEMTRACE               L"modemtracing"
#define CMD_RASDIAG_SHOW_MODEMTRACE              L"modemtracing"
#define DMP_RASDIAG_SET_MODEMTRACE               L"set modemtracing"

#define CMD_RASDIAG_SET_CMTRACE                  L"cmtracing"
#define CMD_RASDIAG_SHOW_CMTRACE                 L"cmtracing"
#define DMP_RASDIAG_SET_CMTRACE                  L"set cmtracing"

#define CMD_RASDIAG_SET_AUDITING                 L"securityeventlog"
#define CMD_RASDIAG_SHOW_AUDITING                L"securityeventlog"
#define DMP_RASDIAG_SET_AUDITING                 L"set securityeventlogs"

#define CMD_RASDIAG_SHOW_LOGS                    L"logs"
#define CMD_RASDIAG_SHOW_ALL                     L"all"
#define CMD_RASDIAG_SHOW_RASCHK                  L"installation"
#define CMD_RASDIAG_SHOW_CONFIG                  L"configuration"

#define CMD_RASDIAG_SHOW_NETCOMP                 L"netcomponents"
#define CMD_RASDIAG_ADD_NETCOMP                  L"netcomponents"
#define CMD_RASDIAG_DEL_NETCOMP                  L"netcomponents"
#define CMD_RASDIAG_REPAIR                       L"repair"

#define TOKEN_NETADAPTERS                        L"netadapters"
#define TOKEN_NETPROTOCOL                        L"netprotocols"
#define TOKEN_NETSERVICES                        L"netservices"
#define TOKEN_NETCLIENTS                         L"netclients"
#define TOKEN_ANSWERFILE                         L"answerfile"
#define TOKEN_CLEARED                            L"clear"
#define TOKEN_HOURS                              L"hours"
#define TOKEN_COMPRESSION                        L"compression"
#define TOKEN_EMAIL                              L"email"
#define TOKEN_DESTINATION                        L"destination"
#define TOKEN_VERBOSE                            L"verbose"

#define DMP_RASDIAG_PUSHD                        L"pushd ras diagnostics\n\n"
#define DMP_RASDIAG_POPD                         L"\npopd\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\regprint.c ===
/*
    File:   regprint.c

    'ras diag' sub context

    08/21/01
*/

#include "precomp.h"

//
// const's only used in this obj
//
static CONST WCHAR g_wszLParen = L'(';
static CONST WCHAR g_wszRParen = L')';
static CONST WCHAR g_wszAmp = L'@';
static CONST WCHAR g_wszEqual = L'=';
static CONST WCHAR g_wszQuote = L'\"';
static CONST WCHAR g_wszColon = L':';
static CONST WCHAR g_wszComma = L',';
static CONST WCHAR g_wszZero = L'0';
static CONST WCHAR g_pwszDword[] = L"dword:";
static CONST WCHAR g_pwszHex[] = L"hex";
static CONST WCHAR g_HexConversion[16] = {L'0', L'1', L'2', L'3', L'4', L'5',
                                          L'6', L'7', L'8', L'9', L'a', L'b',
                                          L'c', L'd', L'e', L'f'};

static CONST REGISTRYROOT g_RegRoots[] =
{
    L"HKEY_ROOT",            9, HKEY_ROOT,
    L"HKEY_LOCAL_MACHINE",  18, HKEY_LOCAL_MACHINE,
    L"HKEY_USERS",          10, HKEY_USERS,
    L"HKEY_CURRENT_USER",   17, HKEY_CURRENT_USER,
    L"HKEY_CURRENT_CONFIG", 19, HKEY_CURRENT_CONFIG,
    L"HKEY_CLASSES_ROOT",   17, HKEY_CLASSES_ROOT,
    L"HKEY_DYN_DATA",       13, HKEY_DYN_DATA,
};

static CONST UINT g_ulNumRegRoots = sizeof(g_RegRoots) / sizeof(REGISTRYROOT);

static CONST PWCHAR g_pwszRegKeys[] =
{
    RASREGCHK01, RASREGCHK02, RASREGCHK03, RASREGCHK04, RASREGCHK05,
    RASREGCHK06, RASREGCHK07, RASREGCHK08, RASREGCHK09, RASREGCHK10,
    RASREGCHK11, RASREGCHK12, RASREGCHK13, RASREGCHK14, RASREGCHK15,
    RASREGCHK16, RASREGCHK17, RASREGCHK18, RASREGCHK19, RASREGCHK20,
    RASREGCHK21, RASREGCHK22, RASREGCHK23, RASREGCHK24, RASREGCHK25,
    RASREGCHK26, RASREGCHK27, RASREGCHK28, RASREGCHK29, RASREGCHK30,
    RASREGCHK31, RASREGCHK32, RASREGCHK33, RASREGCHK34, RASREGCHK35,
    RASREGCHK36, RASREGCHK37, RASREGCHK38, RASREGCHK39, RASREGCHK40,
    RASREGCHK41, RASREGCHK42, RASREGCHK43, RASREGCHK44, RASREGCHK45,
    RASREGCHK46
};

static CONST UINT g_ulNumRegKeys = sizeof(g_pwszRegKeys) / sizeof(PWCHAR);

//
// This count is used to control how many places over to the right that we
// print before going to the next line
//
UINT g_ulCharCount = 0;

BOOL
RegPrintSubtree(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszFullKeyName);

HKEY
ConvertRootStringToKey(
    IN CONST PWCHAR pwszFullKeyName);

DWORD
PutBranch(
    IN BUFFER_WRITE_FILE* pBuff,
    IN HKEY hKey,
    IN LPCWSTR pwszFullKeyName);

VOID
PutString(
    IN BUFFER_WRITE_FILE* pBuff,
    IN PWCHAR pwszString);

VOID
PutDword(
    IN BUFFER_WRITE_FILE* pBuff,
    IN DWORD Dword,
    IN BOOL fLeadingZeroes);

VOID
PutBinary(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST BYTE FAR* lpBuffer,
    IN DWORD Type,
    IN DWORD cbBytes);

VOID
PrintRasRegistryKeys(
    IN BUFFER_WRITE_FILE* pBuff)
{
    UINT i;
    BOOL bAtleastOneFail = FALSE;
    LPBYTE pFailed = NULL;

    do
    {
        pFailed = RutlAlloc(g_ulNumRegKeys * sizeof(BYTE), TRUE);
        if (!pFailed)
        {
            break;
        }

        for (i = 0; i < g_ulNumRegKeys; i++)
        {
            if (RegPrintSubtree(pBuff, g_pwszRegKeys[i]))
            {
                pFailed[i] = TRUE;
                bAtleastOneFail = TRUE;
            }
        }
        //
        // Print all failures at the end
        //
        if (bAtleastOneFail)
        {
            BufferWriteMessage(
                pBuff,
                g_hModule,
                MSG_RASDIAG_SHOW_RASCHK_REG_NOT_FOUND);

            for (i = 0; i < g_ulNumRegKeys; i++)
            {
                if (pFailed[i])
                {
                    BufferWriteFileStrW(pBuff, g_pwszRegKeys[i]);
                    WriteNewLine(pBuff);
                }
            }
        }

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pFailed);

    return;
}

BOOL
RegPrintSubtree(
    IN BUFFER_WRITE_FILE* pBuff,
    IN LPCWSTR pwszFullKeyName)
{
    HKEY hKey = NULL;
    BOOL bReturn = TRUE;
    DWORD dwErr = ERROR_SUCCESS;

    do
    {
        hKey = ConvertRootStringToKey((PWCHAR)pwszFullKeyName);
        if (!hKey)
        {
            break;
        }

        if (PutBranch(pBuff, hKey, pwszFullKeyName))
        {
            break;
        }
        //
        // Success
        //
        bReturn = FALSE;

    } while (FALSE);
    //
    // Clean up
    //
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return bReturn;
}

HKEY
ConvertRootStringToKey(
    IN CONST PWCHAR pwszFullKeyName)
{
    HKEY hKey = NULL;
    UINT i;
    PWCHAR pwszKey = NULL;

    for (i = 0; i < g_ulNumRegRoots; i++)
    {
        if (RutlStrNCmp(
                pwszFullKeyName,
                g_RegRoots[i].RootText,
                g_RegRoots[i].TextLength))
        {
            continue;
        }

        if (pwszFullKeyName[g_RegRoots[i].TextLength] != g_pwszBackSlash)
        {
            continue;
        }

        pwszKey = pwszFullKeyName + g_RegRoots[i].TextLength + 1;

        if (RegOpenKeyEx(
                g_RegRoots[i].RootKey,
                pwszKey,
                0,
                KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                &hKey)
           )
        {
            hKey = NULL;
            break;
        }
    }

    return hKey;
}

DWORD
PutBranch(
    IN BUFFER_WRITE_FILE* pBuff,
    IN HKEY hKey,
    IN LPCWSTR pwszFullKeyName)
{
    HKEY hSubKey = NULL;
    DWORD dwErr = NO_ERROR;
    UINT ulLenFullKey = 0;
    PBYTE pbValueData = NULL;
    DWORD EnumIndex = 0, cchValueName = 0, cbValueData = 0, Type = 0;
    WCHAR szValueNameBuffer[MAX_PATH];
    LPTSTR lpSubKeyName = NULL, lpTempFullKeyName = NULL;

    do
    {
        //
        // Write out the section header.
        //
        BufferWriteFileCharW(pBuff, g_pwszLBracket);
        BufferWriteFileStrW(pBuff, pwszFullKeyName);
        BufferWriteFileCharW(pBuff, g_pwszRBracket);
        WriteNewLine(pBuff);
        //
        // Write out all of the value names and their data.
        //
        for (;;)
        {
            cchValueName = ARRAYSIZE(szValueNameBuffer);
            //
            // VALUE DATA
            // Query for data size
            //
            dwErr = RegEnumValue(
                            hKey,
                            EnumIndex++,
                            szValueNameBuffer,
                            &cchValueName,
                            NULL,
                            &Type,
                            NULL,
                            &cbValueData);
            BREAK_ON_DWERR(dwErr);
            //
            // allocate memory for data
            //
            pbValueData = LocalAlloc(LPTR, cbValueData + ExtraAllocLen(Type));
            if (!pbValueData)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwErr = RegQueryValueEx(
                        hKey,
                        szValueNameBuffer,
                        NULL,
                        &Type,
                        pbValueData,
                        &cbValueData);
            BREAK_ON_DWERR(dwErr);
            //
            //  If cbValueName is zero, then this is the default value of
            //  the key, or the Windows 3.1 compatible key value.
            //
            g_ulCharCount = 0;

            if (cchValueName)
            {
                PutString(pBuff, szValueNameBuffer);
            }
            else
            {
                BufferWriteFileCharW(pBuff, g_wszAmp);
                g_ulCharCount = 1;
            }

            BufferWriteFileCharW(pBuff, g_wszEqual);
            g_ulCharCount++;

            switch (Type)
            {
                case REG_SZ:
                    PutString(pBuff, (PWCHAR)pbValueData);
                    break;

                case REG_DWORD:
                    if (cbValueData == sizeof(DWORD))
                    {
                        BufferWriteFileStrW(pBuff, g_pwszDword);
                        PutDword(pBuff, *((LPDWORD) pbValueData), TRUE);
                        break;
                    }
                    //
                    // FALL THROUGH
                    //
                case REG_BINARY:
                default:
                    PutBinary(pBuff, (LPBYTE) pbValueData, Type, cbValueData);
                    break;
            }

            WriteNewLine(pBuff);

            LocalFree(pbValueData);
            pbValueData = NULL;
        }

        WriteNewLine(pBuff);

        if (dwErr == ERROR_NO_MORE_ITEMS)
        {
            dwErr = NO_ERROR;
        }
        else
        {
            break;
        }
        //
        // Write out all of the subkeys and recurse into them.
        //
        // copy the existing key into a new buffer with enough room for the next key
        //
        ulLenFullKey = lstrlen(pwszFullKeyName);

        lpTempFullKeyName = LocalAlloc(
                                LPTR,
                                (ulLenFullKey + MAX_PATH) * sizeof(WCHAR));
        if (!lpTempFullKeyName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        lstrcpy(lpTempFullKeyName, pwszFullKeyName);
        lpSubKeyName = lpTempFullKeyName + ulLenFullKey;
        *lpSubKeyName++ = g_pwszBackSlash;
        *lpSubKeyName = 0;

        EnumIndex = 0;

        for (;;)
        {
            dwErr = RegEnumKey(hKey, EnumIndex++, lpSubKeyName, MAX_PATH - 1);
            BREAK_ON_DWERR(dwErr);

            dwErr = RegOpenKeyEx(
                        hKey,
                        lpSubKeyName,
                        0,
                        KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                        &hSubKey);
            BREAK_ON_DWERR(dwErr);

            dwErr = PutBranch(pBuff, hSubKey, lpTempFullKeyName);
            BREAK_ON_DWERR(dwErr);

            RegCloseKey(hSubKey);
            hSubKey = NULL;
        }

        if (dwErr == ERROR_NO_MORE_ITEMS)
        {
            dwErr = NO_ERROR;
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (hSubKey)
    {
        RegCloseKey(hSubKey);
        hSubKey = NULL;
    }
    if (lpTempFullKeyName)
    {
        LocalFree(lpTempFullKeyName);
        lpTempFullKeyName = NULL;
    }
    if (pbValueData)
    {
        LocalFree(pbValueData);
        pbValueData = NULL;
    }

    return dwErr;
}

VOID
PutString(
    IN BUFFER_WRITE_FILE* pBuff,
    IN PWCHAR pwszString)
{
    WCHAR Char;

    BufferWriteFileCharW(pBuff, g_wszQuote);
    g_ulCharCount++;

    while ((Char = *pwszString++) != 0)
    {
        switch (Char)
        {
            case L'\\':
            case L'"':
                BufferWriteFileCharW(pBuff, g_pwszBackSlash);
                g_ulCharCount++;
                //
                // FALL THROUGH
                //
            default:
                BufferWriteFileCharW(pBuff, Char);
                g_ulCharCount++;
                break;
        }
    }

    BufferWriteFileCharW(pBuff, g_wszQuote);
    g_ulCharCount++;

    return;
}

VOID
PutDword(
    IN BUFFER_WRITE_FILE* pBuff,
    IN DWORD Dword,
    IN BOOL fLeadingZeroes)
{
    INT CurrentNibble;
    BOOL fWroteNonleadingChar = fLeadingZeroes;
    WCHAR Char;

    for (CurrentNibble = 7; CurrentNibble >= 0; CurrentNibble--)
    {
        Char = g_HexConversion[(Dword >> (CurrentNibble * 4)) & 0x0F];

        if (fWroteNonleadingChar || Char != g_wszZero)
        {
            BufferWriteFileCharW(pBuff, Char);
            g_ulCharCount++;
            fWroteNonleadingChar = TRUE;
        }
    }
    //
    // We need to write at least one character, so if we haven't written
    // anything yet, just spit out one zero.
    //
    if (!fWroteNonleadingChar)
    {
        BufferWriteFileCharW(pBuff, g_wszZero);
        g_ulCharCount++;
    }

    return;
}

VOID
PutBinary(
    IN BUFFER_WRITE_FILE* pBuff,
    IN CONST BYTE FAR* lpBuffer,
    IN DWORD Type,
    IN DWORD cbBytes)
{
    BOOL fFirstByteOnLine;
    BYTE Byte;

    BufferWriteFileStrW(pBuff, g_pwszHex);
    g_ulCharCount += 3;

    if (Type != REG_BINARY)
    {
        BufferWriteFileCharW(pBuff, g_wszLParen);
        PutDword(pBuff, Type, FALSE);
        BufferWriteFileCharW(pBuff, g_wszRParen);
        g_ulCharCount += 2;
    }

    BufferWriteFileCharW(pBuff, g_wszColon);
    g_ulCharCount++;

    fFirstByteOnLine = TRUE;

    while (cbBytes--)
    {
        if (g_ulCharCount > 75 && !fFirstByteOnLine)
        {
            BufferWriteFileCharW(pBuff, g_wszComma);
            BufferWriteFileCharW(pBuff, g_pwszBackSlash);
            WriteNewLine(pBuff);
            BufferWriteFileStrW(pBuff, g_pwszSpace);
            BufferWriteFileStrW(pBuff, g_pwszSpace);
            fFirstByteOnLine = TRUE;
            g_ulCharCount = 3;
        }

        if (!fFirstByteOnLine)
        {
            BufferWriteFileCharW(pBuff, g_wszComma);
            g_ulCharCount++;
        }

        Byte = *lpBuffer++;

        BufferWriteFileCharW(pBuff, g_HexConversion[Byte >> 4]);
        BufferWriteFileCharW(pBuff, g_HexConversion[Byte & 0x0F]);
        g_ulCharCount += 2;

        fFirstByteOnLine = FALSE;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    NOTE - DONT USE 15000-15999    

Author:

    Amritansh Raghav  01/25/1996

Revision History:

        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__

#define MSG_NULL                               1001

#define HLP_RAS_HELP1                          2300
#define HLP_RAS_HELP1_EX                       2301
#define HLP_RAS_HELP2                          HLP_RAS_HELP1
#define HLP_RAS_HELP2_EX                       HLP_RAS_HELP1_EX

#define HLP_RAS_DUMP                           3201
#define HLP_RAS_DUMP_EX                        3202

#define HLP_RASFLAG_SET                        2302
#define HLP_RASFLAG_SET_EX                     2303
#define HLP_RASFLAG_SHOW                       2342
#define HLP_RASFLAG_SHOW_EX                    2343
#define HLP_RASFLAG_AUTHMODE_SHOW              2344
#define HLP_RASFLAG_AUTHMODE_SHOW_EX           2345
#define HLP_RASFLAG_AUTHMODE_SET               2346
#define HLP_RASFLAG_AUTHMODE_SET_EX            2347
#define HLP_RASFLAG_AUTHTYPE_ADD               2348
#define HLP_RASFLAG_AUTHTYPE_ADD_EX            2349
#define HLP_RASFLAG_AUTHTYPE_DEL               2350
#define HLP_RASFLAG_AUTHTYPE_DEL_EX            2351
#define HLP_RASFLAG_AUTHTYPE_SHOW              2352
#define HLP_RASFLAG_AUTHTYPE_SHOW_EX           2353
#define HLP_RASFLAG_LINK_ADD                   2354
#define HLP_RASFLAG_LINK_ADD_EX                2355
#define HLP_RASFLAG_LINK_DEL                   2356
#define HLP_RASFLAG_LINK_DEL_EX                2357
#define HLP_RASFLAG_LINK_SHOW                  2358
#define HLP_RASFLAG_LINK_SHOW_EX               2359
#define HLP_RASFLAG_MLINK_ADD                  2360
#define HLP_RASFLAG_MLINK_ADD_EX               2361
#define HLP_RASFLAG_MLINK_DEL                  2362
#define HLP_RASFLAG_MLINK_DEL_EX               2363
#define HLP_RASFLAG_MLINK_SHOW                 2364
#define HLP_RASFLAG_MLINK_SHOW_EX              2365

#define HLP_RASUSER_SHOW                       2402
#define HLP_RASUSER_SHOW_EX                    2403
#define HLP_RASUSER_SET                        2421
#define HLP_RASUSER_SET_EX                     2422

#define HLP_DOMAIN_REGISTER                    2461
#define HLP_DOMAIN_REGISTER_EX                 2462
#define HLP_DOMAIN_UNREGISTER                  2481
#define HLP_DOMAIN_UNREGISTER_EX               2482
#define HLP_DOMAIN_SHOWREG                     2541
#define HLP_DOMAIN_SHOWREG_EX                  2542

#define HLP_GROUP_SET                          3292
#define HLP_GROUP_SHOW                         3293
#define HLP_GROUP_ENABLE                       3294
#define HLP_GROUP_DISABLE                      3295
#define HLP_GROUP_ADD                          3298
#define HLP_GROUP_DEL                          3299

#define HLP_SHOW_SERVERS                       3301
#define HLP_SHOW_SERVERS_EX                    3302

#define HLP_SHOW_CLIENT                        3325
#define HLP_SHOW_CLIENT_EX                     3326

#define MSG_RAS_SCRIPTHEADER                    4501
#define MSG_RAS_SCRIPTFOOTER                    4502
#define MSG_RAS_SHOW_SERVERS_HEADER             4503

#define MSG_RASUSER_RASINFO                     5001
#define MSG_RASUSER_SET_CMD                     5003

#define MSG_DOMAIN_REGISTER_SUCCESS             5200
#define MSG_DOMAIN_REGISTER_FAIL                5201
#define MSG_DOMAIN_UNREGISTER_SUCCESS           5202
#define MSG_DOMAIN_UNREGISTER_FAIL              5203
#define MSG_DOMAIN_SHOW_REGISTERED              5208
#define MSG_DOMAIN_SHOW_UNREGISTERED            5209
#define MSG_DOMAIN_SHOW_REGISTER_FAIL           5211

#define MSG_RASFLAG_DUMP                        5401
#define MSG_RASFLAG_DUMP2                       5402
#define MSG_RASFLAG_AUTHMODE_STANDARD           5407
#define MSG_RASFLAG_AUTHMODE_NODCC              5408
#define MSG_RASFLAG_AUTHMODE_BYPASS             5410
#define MSG_RASFLAG_AUTHTYPE_HEADER             5411
#define MSG_RASFLAG_AUTHTYPE_PAP                5412
#define MSG_RASFLAG_AUTHTYPE_SPAP               5413
#define MSG_RASFLAG_AUTHTYPE_MD5CHAP            5414
#define MSG_RASFLAG_AUTHTYPE_MSCHAP             5415
#define MSG_RASFLAG_AUTHTYPE_MSCHAP2            5416
#define MSG_RASFLAG_AUTHTYPE_EAP                5417
#define MSG_RASFLAG_LINK_HEADER                 5418
#define MSG_RASFLAG_LINK_SWC                    5419
#define MSG_RASFLAG_LINK_LCP                    5420
#define MSG_RASFLAG_MLINK_HEADER                5421
#define MSG_RASFLAG_MLINK_MULTI                 5422
#define MSG_RASFLAG_MLINK_BACP                  5423

#define MSG_CLIENT_SHOW                         5450
#define EMSG_UNABLE_TO_ENUM_CLIENTS             5451

#define EMSG_CANT_FIND_EOPT                    10002
#define EMSG_BAD_OPTION_VALUE                  10003
#define EMSG_UNABLE_TO_ENUM_USERS              10004
#define EMSG_RASUSER_MUST_PROVIDE_CB_NUMBER    10008

//
// Defined for ip subcontext
//

#define HLP_RASIP_HELP1                        20001
#define HLP_RASIP_HELP1_EX                     20002
#define HLP_RASIP_HELP2                        HLP_RASIP_HELP1
#define HLP_RASIP_HELP2_EX                     HLP_RASIP_HELP1_EX
#define HLP_RASIP_DUMP                         20003
#define HLP_RASIP_DUMP_EX                      20004

#define HLP_RASIP_SET_ASSIGNMENT               20005
#define HLP_RASIP_SET_ASSIGNMENT_EX            20006
#define HLP_RASIP_SET_CALLERSPEC               20011
#define HLP_RASIP_SET_CALLERSPEC_EX            20012
#define HLP_RASIP_SET_ACCESS                   20013
#define HLP_RASIP_SET_ACCESS_EX                20014
#define HLP_RASIP_SHOW_CONFIG                  20015
#define HLP_RASIP_SHOW_CONFIG_EX               20016
#define HLP_RASIP_SET_NEGOTIATION              20017
#define HLP_RASIP_SET_NEGOTIATION_EX           20018
#define HLP_RASIP_ADD_RANGE                    20019
#define HLP_RASIP_ADD_RANGE_EX                 20020
#define HLP_RASIP_DEL_RANGE                    20021
#define HLP_RASIP_DEL_RANGE_EX                 20022
#define HLP_RASIP_DEL_POOL                     20023
#define HLP_RASIP_DEL_POOL_EX                  20024
#define HLP_RASIP_SET_NETBTBCAST               20025
#define HLP_RASIP_SET_NETBTBCAST_EX            20026

#define MSG_RASIP_SERVERCONFIG                 21000
#define MSG_RASIP_SET_CMD                      21001
#define MSG_RASIP_ADD_RANGE_CMD                21002
#define MSG_RASIP_SCRIPTHEADER                 21003
#define MSG_RASIP_SCRIPTFOOTER                 21004
#define MSG_RASIP_SHOW_POOL                    21005
#define EMSG_RASIP_BAD_ADDRESS                 21050
#define EMSG_RASIP_NEED_VALID_POOL             21053
#define EMSG_RASIP_NETID_127                   21054
#define EMSG_RASIP_BAD_RANGE                   21055
#define EMSG_RASIP_BAD_POOL_GENERIC            21056
#define EMSG_RASIP_INVALID_POOL                21057
#define EMSG_RASIP_OVERLAPPING_RANGE           21058

//
// Defined for ipx subcontext
//

#define HLP_RASIPX_HELP1                        22001
#define HLP_RASIPX_HELP1_EX                     22002
#define HLP_RASIPX_HELP2                        HLP_RASIPX_HELP1
#define HLP_RASIPX_HELP2_EX                     HLP_RASIPX_HELP1_EX
#define HLP_RASIPX_DUMP                         22003
#define HLP_RASIPX_DUMP_EX                      22004

#define HLP_RASIPX_SET_ASSIGNMENT               22005
#define HLP_RASIPX_SET_ASSIGNMENT_EX            22006
#define HLP_RASIPX_SET_POOL                     22007
#define HLP_RASIPX_SET_POOL_EX                  22008
#define HLP_RASIPX_SET_CALLERSPEC               22011
#define HLP_RASIPX_SET_CALLERSPEC_EX            22012
#define HLP_RASIPX_SET_ACCESS                   22013
#define HLP_RASIPX_SET_ACCESS_EX                22014
#define HLP_RASIPX_SHOW_CONFIG                  22015
#define HLP_RASIPX_SHOW_CONFIG_EX               22016
#define HLP_RASIPX_SET_NEGOTIATION              22017
#define HLP_RASIPX_SET_NEGOTIATION_EX           22018

#define MSG_RASIPX_SERVERCONFIG                 23000
#define MSG_RASIPX_SET_CMD                      23001
#define MSG_RASIPX_SET_POOL_CMD                 23002
#define MSG_RASIPX_SCRIPTHEADER                 23003
#define MSG_RASIPX_SCRIPTFOOTER                 23004
#define EMSG_RASIPX_BAD_IPX                     23050
#define EMSG_RASIPX_BAD_POOLSIZE                23051

//
// Defined for nbf subcontext
//

#define HLP_RASNBF_HELP1                        24001
#define HLP_RASNBF_HELP1_EX                     24002
#define HLP_RASNBF_HELP2                        HLP_RASNBF_HELP1
#define HLP_RASNBF_HELP2_EX                     HLP_RASNBF_HELP1_EX
#define HLP_RASNBF_DUMP                         24003
#define HLP_RASNBF_DUMP_EX                      24004

#define HLP_RASNBF_SET_NEGOTIATION              24005
#define HLP_RASNBF_SET_NEGOTIATION_EX           24006
#define HLP_RASNBF_SET_ACCESS                   24007
#define HLP_RASNBF_SET_ACCESS_EX                24008
#define HLP_RASNBF_SHOW_CONFIG                  24009
#define HLP_RASNBF_SHOW_CONFIG_EX               24010

#define MSG_RASNBF_SERVERCONFIG                 24500
#define MSG_RASNBF_SET_CMD                      24501
#define MSG_RASNBF_SCRIPTHEADER                 24503
#define MSG_RASNBF_SCRIPTFOOTER                 24504

//
// Defined for at subcontext
//

#define HLP_RASAT_HELP1                         25001
#define HLP_RASAT_HELP1_EX                      25002
#define HLP_RASAT_HELP2                         HLP_RASAT_HELP1
#define HLP_RASAT_HELP2_EX                      HLP_RASAT_HELP1_EX
#define HLP_RASAT_DUMP                          25003
#define HLP_RASAT_DUMP_EX                       25004

#define HLP_RASAT_SET_NEGOTIATION               25005
#define HLP_RASAT_SET_NEGOTIATION_EX            25006
#define HLP_RASAT_SHOW_CONFIG                   25009
#define HLP_RASAT_SHOW_CONFIG_EX                25010

#define MSG_RASAT_SERVERCONFIG                  25500
#define MSG_RASAT_SET_CMD                       25501
#define MSG_RASAT_SCRIPTHEADER                  25503
#define MSG_RASAT_SCRIPTFOOTER                  25504

//
// Defined for aaaa subcontext
//

#define HLP_RASAAAA_ADD_AUTHSERV                26000
#define HLP_RASAAAA_ADD_ACCTSERV                26002

#define HLP_RASAAAA_DEL_AUTHSERV                26003
#define HLP_RASAAAA_DEL_ACCTSERV                26004

#define HLP_RASAAAA_SET_AUTH                    26005
#define HLP_RASAAAA_SET_ACCT                    26006
#define HLP_RASAAAA_SET_AUTHSERV                26007
#define HLP_RASAAAA_SET_ACCTSERV                26008

#define HLP_RASAAAA_SHOW_AUTH                   26010
#define HLP_RASAAAA_SHOW_ACCT                   26013
#define HLP_RASAAAA_SHOW_AUTHSERV               26011
#define HLP_RASAAAA_SHOW_ACCTSERV               26014

#define HLP_RASAAAA_ADD_AUTHSERV_EX             26016
#define HLP_RASAAAA_ADD_ACCTSERV_EX             26018

#define HLP_RASAAAA_DEL_AUTHSERV_EX             26020
#define HLP_RASAAAA_DEL_ACCTSERV_EX             26022

#define HLP_RASAAAA_SET_AUTH_EX                 26024
#define HLP_RASAAAA_SET_ACCT_EX                 26025
#define HLP_RASAAAA_SET_AUTHSERV_EX             26026
#define HLP_RASAAAA_SET_ACCTSERV_EX             26027

#define HLP_RASAAAA_SHOW_AUTH_EX                26028
#define HLP_RASAAAA_SHOW_ACCT_EX                26029
#define HLP_RASAAAA_SHOW_AUTHSERV_EX            26030
#define HLP_RASAAAA_SHOW_ACCTSERV_EX            26031

#define HLP_RASAAAA_HELP1                       26032
#define HLP_RASAAAA_HELP1_EX                    26033
#define HLP_RASAAAA_HELP2                       HLP_RASAAAA_HELP1
#define HLP_RASAAAA_HELP2_EX                    HLP_RASAAAA_HELP1_EX
#define HLP_RASAAAA_DUMP                        26034
#define HLP_RASAAAA_DUMP_EX                     26035

#define MSG_RASAAAA_SHOW_AUTH                   26100
#define MSG_RASAAAA_SHOW_ACCT                   26101
#define MSG_RASAAAA_SHOW_AUTHSERV               26102
#define MSG_RASAAAA_SHOW_AUTHSERV_HDR           26104
#define MSG_RASAAAA_SHOW_ACCTSERV_HDR           26105
#define MSG_RASAAAA_MUST_RESTART_SERVICES       26106
#define MSG_RASAAAA_SCRIPTHEADER                26107
#define MSG_RASAAAA_SCRIPTFOOTER                26108
#define MSG_RASAAAA_CMD1                        26109
#define MSG_RASAAAA_CMD5                        26110

//
// Defined for diag subcontext
//

#define HLP_TRACE_SHOW                          27035
#define HLP_TRACE_SHOW_EX                       27036
#define HLP_TRACE_SET                           27037
#define HLP_TRACE_SET_EX                        27038

#define HLP_RASDIAG_SET_TRACEALL                27031
#define HLP_RASDIAG_SET_TRACEALL_EX             27032
#define HLP_RASDIAG_SHOW_TRACEALL               27033
#define HLP_RASDIAG_SHOW_TRACEALL_EX            27034

#define HLP_RASDIAG_SHOW_RASTRACE               27146
#define HLP_RASDIAG_SHOW_RASTRACE_EX            27147
#define HLP_RASDIAG_SET_RASTRACE                27148
#define HLP_RASDIAG_SET_RASTRACE_EX             27149

#define MSG_TRACE_SHOW                          27039
#define MSG_TRACE_DUMP                          27040
#define MSG_TRACE_DUMP2                         27143

#define MSG_RASDIAG_SCRIPTHEADER                27144
#define MSG_RASDIAG_SCRIPTFOOTER                27145

#define MSG_RASDIAG_CLEAR_TRACE_OK              27053
#define EMSG_RASDIAG_CLEAR_TRACE_FAIL           27054

#define MSG_RASDIAG_TRACEALL_RAS_OK             27041
#define EMSG_RASDIAG_TRACEALL_RAS_FAIL          27042

#define HLP_RASDIAG_SET_MODEMTRACE              27045
#define HLP_RASDIAG_SET_MODEMTRACE_EX           27046
#define HLP_RASDIAG_SHOW_MODEMTRACE             27047
#define HLP_RASDIAG_SHOW_MODEMTRACE_EX          27048

#define MSG_RASDIAG_CLEAR_MODEMTRACE            27050
#define EMSG_RASDIAG_CLEAR_MODEMTRACE_FAIL      27052

#define MSG_RASDIAG_SET_MODEMTRACE_OK           27043
#define EMSG_RASDIAG_SET_MODEMTRACE_FAIL        27044

#define MSG_RASDIAG_SHOW_MODEMTRACE_ENABLED     27049
#define EMSG_RASDIAG_SHOW_MODEMTRACE_DISABLED   27055

#define HLP_RASDIAG_SET_CMTRACE                 27056
#define HLP_RASDIAG_SET_CMTRACE_EX              27057
#define HLP_RASDIAG_SHOW_CMTRACE                27058
#define HLP_RASDIAG_SHOW_CMTRACE_EX             27059

#define MSG_RASDIAG_CLEAR_CMTRACE               27060
#define EMSG_RASDIAG_CLEAR_CMTRACE_FAIL         27061

#define MSG_RASDIAG_SET_CMTRACE_OK              27062
#define EMSG_RASDIAG_SET_CMTRACE_FAIL           27063

#define MSG_RASDIAG_SHOW_CMTRACE_ENABLED        27064
#define EMSG_RASDIAG_SHOW_CMTRACE_DISABLED      27065

#define MSG_RASDIAG_SET_IPSEC_OK                27088
#define EMSG_RASDIAG_SET_IPSEC_FAIL             27087

#define HLP_RASDIAG_SET_AUDITING                27077
#define HLP_RASDIAG_SET_AUDITING_EX             27078
#define HLP_RASDIAG_SHOW_AUDITING               27075
#define HLP_RASDIAG_SHOW_AUDITING_EX            27076

#define MSG_RASDIAG_CLEAR_AUDITING              27069
#define EMSG_RASDIAG_CLEAR_AUDITING_FAIL        27070

#define MSG_RASDIAG_SET_AUDITING_OK             27071
#define EMSG_RASDIAG_SET_AUDITING_FAIL          27072

#define MSG_RASDIAG_SHOW_AUDITING_ENABLED       27073
#define EMSG_RASDIAG_SHOW_AUDITING_DISABLED     27074

#define HLP_RASDIAG_SHOW_ALL                    27098
#define HLP_RASDIAG_SHOW_ALL_EX                 27099

#define HLP_RASDIAG_SHOW_LOGS                   27081
#define HLP_RASDIAG_SHOW_LOGS_EX                27082

#define EMSG_RASDIAG_SHOW_TRACE_LOGS_FAIL       27083
#define EMSG_RASDIAG_SHOW_MODEMTRACE_LOGS_FAIL  27084
#define EMSG_RASDIAG_SHOW_CM_LOGS_FAIL          27085
#define EMSG_RASDIAG_SHOW_IPSEC_LOGS_FAIL       27086

#define HLP_RASDIAG_SHOW_RASCHK                 27000
#define HLP_RASDIAG_SHOW_RASCHK_EX              27001

#define MSG_RASDIAG_SHOW_RASCHK_FILE            27002
#define EMSG_RASDIAG_SHOW_RASCHK_FILE           27067
#define EMSG_RASDIAG_SHOW_RASCHK_RASCOMP        27089
#define EMSG_RASDIAG_SHOW_RASCHK_NETCOMP        27090

#define MSG_RASDIAG_SHOW_RASCHK_NETCOMP         27003
#define MSG_RASDIAG_SHOW_RASCHK_OK              27004
#define MSG_RASDIAG_SHOW_RASCHK_NOTOK           27005
#define MSG_RASDIAG_SHOW_RASCHK_REG_NOT_FOUND   27030

#define HLP_RASDIAG_SHOW_CONFIG                 27079
#define HLP_RASDIAG_SHOW_CONFIG_EX              27080

#define MSG_RASDIAG_SHOW_CONFIG_RASENUM         27066
#define MSG_RASDIAG_SHOW_PROCESS                27127
#define MSG_RASDIAG_SHOW_PROCESS_TITLE          27128
#define MSG_RASDIAG_SHOW_PROCESS_SVCNAME        27129

#define MSG_RASDIAG_SHOW_EVENT_SUCCESS          27130
#define MSG_RASDIAG_SHOW_EVENT_ERROR            27131
#define MSG_RASDIAG_SHOW_EVENT_WARNING          27132
#define MSG_RASDIAG_SHOW_EVENT_INFO             27133
#define MSG_RASDIAG_SHOW_EVENT_SAUDIT           27134
#define MSG_RASDIAG_SHOW_EVENT_FAUDIT           27135
#define MSG_RASDIAG_SHOW_EVENT_NONE             27136
#define MSG_RASDIAG_SHOW_EVENT_NA               27137
#define MSG_RASDIAG_SHOW_EVENT_LOG_USER         27138
#define MSG_RASDIAG_SHOW_EVENT_LOG_USERDOM      27139

#define EMSG_RASDIAG_SHOW_CONFIG_RASENUM        27068
#define EMSG_RASDIAG_SHOW_CONFIG_PROC           27093
#define EMSG_RASDIAG_SHOW_CONFIG_EVENTLOG       27094
#define EMSG_RASDIAG_SHOW_CONFIG_SECEVENTLOG    27107
#define EMSG_RASDIAG_SHOW_CONFIG_ALLPBK         27095
#define EMSG_RASDIAG_SHOW_CONFIG_USERPBK        27096
#define EMSG_RASDIAG_SHOW_CONFIG_CONSOLE        27097
#define EMSG_RASDIAG_SHOW_CONFIG_WINMSD         27100

#define HLP_RASDIAG_SHOW_NETCOMP                27006
#define HLP_RASDIAG_SHOW_NETCOMP_EX             27007

#define MSG_RASDIAG_SHOW_NETCOMP                27008
#define MSG_RASDIAG_SHOW_NETCOMP_NET_HDR        27009
#define MSG_RASDIAG_SHOW_NETCOMP_NETTRANS_HDR   27010
#define MSG_RASDIAG_SHOW_NETCOMP_NETSERVICE_HDR 27011
#define MSG_RASDIAG_SHOW_NETCOMP_NETCLIENT_HDR  27012

#define HLP_RASDIAG_ADD_NETCOMP                 27013
#define HLP_RASDIAG_ADD_NETCOMP_EX              27014

#define HLP_RASDIAG_DEL_NETCOMP                 27015
#define HLP_RASDIAG_DEL_NETCOMP_EX              27016

#define HLP_RASDIAG_REPAIR                      27017
#define HLP_RASDIAG_REPAIR_EX                   27018

#define MSG_RASDIAG_REPAIR_SUCCESS_REBOOT       27019
#define EMSG_RASDIAG_REPAIR_FAIL                27091
#define EMSG_RASDIAG_BAD_ANSWERFILE             27023

#define MSG_RASDIAG_REPORT_TITLE                27114
#define MSG_RASDIAG_REPORT_HTMLTOC              27113
#define MSG_RASDIAG_REPORT_TOC                  27109
#define MSG_RASDIAG_REPORT_TRACEEVENT           27115
#define MSG_RASDIAG_REPORT_TRACE                27110
#define MSG_RASDIAG_REPORT_TRACE_CM             27140
#define MSG_RASDIAG_REPORT_TRACE_MODEM          27141
#define MSG_RASDIAG_REPORT_TRACE_IPSEC          27142
#define MSG_RASDIAG_REPORT_RASEVENT             27111
#define MSG_RASDIAG_REPORT_SECEVENT             27112
#define MSG_RASDIAG_REPORT_INSTALL              27116
#define MSG_RASDIAG_REPORT_RASINF               27117
#define MSG_RASDIAG_REPORT_RASCHK               27118
#define MSG_RASDIAG_REPORT_NETINST              27119
#define MSG_RASDIAG_REPORT_RASREG               27120
#define MSG_RASDIAG_REPORT_CONFIG               27121
#define MSG_RASDIAG_REPORT_RASENUM              27122
#define MSG_RASDIAG_REPORT_TLIST                27123
#define MSG_RASDIAG_REPORT_CONSOLE              27124
#define MSG_RASDIAG_REPORT_WINMSD               27125
#define MSG_RASDIAG_REPORT_RASPBK               27126
#define EMSG_RASDIAG_SHOW_CONFIG_CONSOLE_TIMOUT 27150

#define MSG_RASDIAG_REPORT_OK                   27101
#define MSG_RASDIAG_REPORT_EMAIL_OK             27102
#define EMSG_RASDIAG_REPORT_FAIL                27103
#define EMSG_RASDIAG_REPORT_EMAIL_FAIL          27104
#define EMSG_RASDIAG_REPORT_CAB_FAIL            27105
#define EMSG_RASDIAG_REPORT_DISPLAY_FAIL        27106

#endif //__STDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\rasnetcfg.cpp ===
extern "C"
{
#include "precomp.h"
#include <netcfgn.h>
#include <netcfgp.h>
#include <netcfgx.h>

HRESULT
HrInstallRas(
    IN CONST PWCHAR pszFilePath);

HRESULT
HrUninstallRas();

VOID
HrShowNetComponentsAll(
    IN BUFFER_WRITE_FILE* pBuff);

VOID
HrValidateRas(
    IN BUFFER_WRITE_FILE* pBuff);

PWCHAR
RasDiagVerifyAnswerFile(
    IN CONST PWCHAR pwszFilePath);
}

#define ASYCMINI L"sw\\{eeab7790-c514-11d1-b42b-00805fc1270e}"
#define IRDAMINI L"ms_irdaminiport"
#define IRMDMINI L"ms_irmodemminiport"
#define L2TPMINI L"ms_l2tpminiport"
#define PPTPMINI L"ms_pptpminiport"
#define PTIMINI  L"ms_ptiminiport"
#define P3OEMINI L"ms_pppoeminiport"
#define NDSNATLK L"ms_ndiswanatalk"
#define NDWNNETM L"ms_ndiswanbh"
#define NDWNTCP  L"ms_ndiswanip"
#define NDWNIPX  L"ms_ndiswanipx"
//#define NDWNNBFI L"ms_ndiswannbfin"
//#define NDWNNBDO L"ms_ndiswannbfout"
#define MSPPPOE  L"ms_pppoe"
#define MSPPTP   L"ms_pptp"
#define MSL2TP   L"ms_l2tp"
#define RASCLINT L"ms_rascli"
#define RASSRV   L"ms_rassrv"
#define STEELHED L"ms_steelhead"
//#define APPLAYER L"ms_alg"
#define NDISWAN  L"ms_ndiswan"
#define RASMAN   L"ms_rasman"

typedef enum _NetClass
{
    NC_NetAdapter = 0,
    NC_NetProtocol,
    NC_NetService,
    NC_NetClient,
    NC_Unknown

} NetClass;

typedef struct _RAS_COMP_IDS
{
    PWCHAR szComponentId;
    NetClass nc;

} RAS_COMP_IDS;

// Globals
//
static CONST RAS_COMP_IDS c_RasCompIds[] =
{
    {ASYCMINI, NC_NetAdapter},
    {IRDAMINI, NC_NetAdapter},
    {IRMDMINI, NC_NetAdapter},
    {L2TPMINI, NC_NetAdapter},
    {PPTPMINI, NC_NetAdapter},
    {PTIMINI,  NC_NetAdapter},
    {P3OEMINI, NC_NetAdapter},
    {NDSNATLK, NC_NetAdapter},
    {NDWNNETM, NC_NetAdapter},
    {NDWNTCP,  NC_NetAdapter},
    {NDWNIPX,  NC_NetAdapter},
//    {NDWNNBFI, NC_NetAdapter},
//    {NDWNNBDO, NC_NetAdapter},
    {MSPPPOE,  NC_NetProtocol},
    {MSPPTP,   NC_NetProtocol},
    {MSL2TP,   NC_NetProtocol},
    {RASCLINT, NC_NetService},
    {RASSRV,   NC_NetService},
    {STEELHED, NC_NetService},
//    {APPLAYER, NC_NetService},
    {NDISWAN,  NC_NetProtocol},
    {RASMAN,   NC_NetService}
};

static CONST UINT g_ulNumRasCompIds = sizeof(c_RasCompIds) /
                                        sizeof(RAS_COMP_IDS);

static CONST GUID* c_aguidClass[] =
{
    &GUID_DEVCLASS_NET,
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_NETCLIENT
};

HRESULT
HrInstallNetComponent(
    IN INetCfg* pnc,
    IN CONST PWCHAR szComponentId,
    IN CONST NetClass nc,
    IN CONST PWCHAR pszFilePath);

HRESULT
HrUninstallNetComponent(
    IN INetCfg* pnc,
    IN CONST PWCHAR szComponentId);

HRESULT
HrShowNetComponents(
    IN BUFFER_WRITE_FILE* pBuff,
    IN INetCfg* pnc,
    IN CONST GUID* pguidClass);

HRESULT
HrConfigureComponent(
    IN INetCfgComponent* pncc,
    IN CONST PWCHAR pszComponentId,
    IN CONST NetClass nc,
    IN CONST PWCHAR pszAnswerfilePath);

HRESULT
HrGetINetCfg(
    IN BOOL fGetWriteLock,
    IN INetCfg** ppnc);

HRESULT
HrReleaseINetCfg(
    IN BOOL fHasWriteLock,
    IN INetCfg* pnc);

inline ULONG ReleaseObj(IUnknown* punk)
{
    return (punk) ? punk->Release() : 0;
}

HRESULT
HrInstallRas(
    IN CONST PWCHAR pszFilePath)
{
    BOOL fOk = FALSE;
    HRESULT hr = S_OK;
    INetCfg* pnc;

    //
    // Get INetCfg interface
    //
    hr = HrGetINetCfg(TRUE, &pnc);
    if (SUCCEEDED(hr))
    {
//        NT_PRODUCT_TYPE ProductType = NtProductServer;
//        RtlGetNtProductType(&ProductType);

        for (UINT i = 0; i < g_ulNumRasCompIds; i++)
        {
            if ((c_RasCompIds[i].nc == NC_NetAdapter) &&
                (lstrcmp(c_RasCompIds[i].szComponentId, ASYCMINI) != 0)
               )
            {
                continue;
            }
/*            else if ((ProductType != NtProductWinNt) &&
                     (//(lstrcmp(c_RasCompIds[i].szComponentId, RASCLINT) == 0)||
                      (lstrcmp(c_RasCompIds[i].szComponentId, APPLAYER) == 0))
                    )
            {
                continue;
            }*/
            //
            // Install szComponentId
            //
            hr = HrInstallNetComponent(
                    pnc,
                    c_RasCompIds[i].szComponentId,
                    c_RasCompIds[i].nc,
                    pszFilePath);
            if (S_OK == hr)
            {
                fOk = TRUE;
            }
        }
        //
        // Apply the changes
        //
        if (fOk)
        {
            hr = pnc->Apply();
        }
        //
        // Release INetCfg
        //
        (VOID) HrReleaseINetCfg(TRUE, pnc);
    }

    return hr;
}

HRESULT
HrUninstallRas()
{
    BOOL fOk = FALSE;
    HRESULT hr = S_OK;
    INetCfg* pnc;

    //
    // Get INetCfg interface
    //
    hr = HrGetINetCfg(TRUE, &pnc);
    if (SUCCEEDED(hr))
    {
        for (UINT i = 0; i < g_ulNumRasCompIds; i++)
        {
            if ((c_RasCompIds[i].nc == NC_NetAdapter) &&
                (lstrcmp(c_RasCompIds[i].szComponentId, ASYCMINI) != 0)
               )
            {
                continue;
            }
            //
            // Uninstall szComponentId
            //
            hr = HrUninstallNetComponent(pnc, c_RasCompIds[i].szComponentId);
            if (S_OK == hr)
            {
                fOk = TRUE;
            }
        }
        //
        // Apply the changes
        //
        if (fOk)
        {
            hr = pnc->Apply();
        }
        //
        // Release INetCfg
        //
        (VOID) HrReleaseINetCfg(TRUE, pnc);
    }

    return hr;
}


///
// Install the specified net component
//
HRESULT
HrInstallNetComponent(
    IN INetCfg* pnc,
    IN CONST PWCHAR szComponentId,
    IN CONST NetClass nc,
    IN CONST PWCHAR pszFilePath)
{
    HRESULT hr = S_OK;
    OBO_TOKEN OboToken;
    INetCfgClassSetup* pncClassSetup;
    INetCfgComponent* pncc;

    //
    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being installed
    //
    // set it to OBO_USER so that szComponentId will be installed
    // On-Behalf-Of "user"
    //
    ZeroMemory(&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    hr = pnc->QueryNetCfgClass(
                c_aguidClass[nc],
                IID_INetCfgClassSetup,
                (void**)&pncClassSetup);
    if (SUCCEEDED(hr))
    {
        hr = pncClassSetup->Install(szComponentId,
                                &OboToken,
                                NSF_POSTSYSINSTALL,
                                0,
                                NULL,
                                NULL,
                                &pncc);
        if (S_OK == hr)
        {
            if (pszFilePath)
            {
                hr = HrConfigureComponent(pncc, szComponentId, nc, pszFilePath);
            }
            //
            // we dont want to use pncc (INetCfgComponent), release it
            //
            ReleaseObj(pncc);
        }

        ReleaseObj(pncClassSetup);
    }

    return hr;
}

//
// Uninstall the specified component
//
HRESULT
HrUninstallNetComponent(
    IN INetCfg* pnc,
    IN CONST PWCHAR szComponentId)
{
    HRESULT hr = S_OK;
    OBO_TOKEN OboToken;
    INetCfgComponent* pncc;
    GUID guidClass;
    INetCfgClass* pncClass;
    INetCfgClassSetup* pncClassSetup;

    //
    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being uninstalld
    //
    // set it to OBO_USER so that szComponentId will be uninstalld
    // On-Behalf-Of "user"
    //
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;
    //
    // see if the component is really installed
    //
    hr = pnc->FindComponent(szComponentId, &pncc);

    if (S_OK == hr)
    {
        //
        // yes, it is installed. obtain INetCfgClassSetup and DeInstall
        //
        hr = pncc->GetClassGuid(&guidClass);

        if (S_OK == hr)
        {
            hr = pnc->QueryNetCfgClass(
                        &guidClass,
                        IID_INetCfgClass,
                        (void**)&pncClass);
            if (SUCCEEDED(hr))
            {
                hr = pncClass->QueryInterface(
                                IID_INetCfgClassSetup,
                                (void**)&pncClassSetup);
                    if (SUCCEEDED(hr))
                    {
                        hr = pncClassSetup->DeInstall(pncc, &OboToken, NULL);
                        ReleaseObj(pncClassSetup);
                    }

                ReleaseObj(pncClass);
            }
        }

        ReleaseObj(pncc);
    }

    return hr;
}

//
// Display the list of installed components of the specified class.
//
HRESULT
HrShowNetComponents(
    IN BUFFER_WRITE_FILE* pBuff,
    IN INetCfg* pnc,
    IN CONST GUID* pguidClass)
{
    ULONG celtFetched;
    PWSTR szInfId, szDisplayName;
    DWORD dwcc;
    HRESULT hr = S_OK;
    INetCfgClass* pncclass;
    INetCfgComponent* pncc;
    IEnumNetCfgComponent* pencc;

    hr = pnc->QueryNetCfgClass(
                pguidClass,
                IID_INetCfgClass,
                (void**)&pncclass);
    if (SUCCEEDED(hr))
    {
        //
        // get IEnumNetCfgComponent so that we can enumerate
        //
        hr = pncclass->EnumComponents(&pencc);
        ReleaseObj(pncclass);

        while (SUCCEEDED(hr) &&
               (S_OK == (hr = pencc->Next(1, &pncc, &celtFetched))))
        {
            hr = pncc->GetId(&szInfId);

            if (S_OK == hr)
            {
                hr = pncc->GetDisplayName(&szDisplayName);
                if (SUCCEEDED(hr))
                {
                    BufferWriteMessage(
                        pBuff,
                        g_hModule,
                        MSG_RASDIAG_SHOW_NETCOMP,
                        szInfId,
                        szDisplayName);

                    CoTaskMemFree(szDisplayName);
                }

                CoTaskMemFree(szInfId);
            }
            //
            // we dont want to stop enumeration just because 1 component
            // failed either GetId or GetDisplayName, therefore reset hr to S_OK
            //
            hr = S_OK;
            ReleaseObj(pncc);
        }

        ReleaseObj(pencc);
    }

    return hr;
}

//
// Display installed net components
//
VOID
HrShowNetComponentsAll(
    IN BUFFER_WRITE_FILE* pBuff)
{
    HRESULT hr = S_OK;
    INetCfg* pnc;

    static CONST ULONG c_cClassNames[] =
    {
        MSG_RASDIAG_SHOW_NETCOMP_NET_HDR,
        MSG_RASDIAG_SHOW_NETCOMP_NETTRANS_HDR,
        MSG_RASDIAG_SHOW_NETCOMP_NETSERVICE_HDR,
        MSG_RASDIAG_SHOW_NETCOMP_NETCLIENT_HDR,
    };

    static CONST UINT ulNumClasses = sizeof(c_cClassNames) / sizeof(ULONG);

    //
    // Get INetCfg interface
    //
    hr = HrGetINetCfg(FALSE, &pnc);
    if (SUCCEEDED(hr))
    {
        for (UINT i = 0 ; i < ulNumClasses; i++)
        {
            BufferWriteMessage(pBuff, g_hModule, c_cClassNames[i]);
            (VOID) HrShowNetComponents(pBuff, pnc, c_aguidClass[i]);
        }
        //
        // Release INetCfg
        //
        (VOID) HrReleaseINetCfg(FALSE, pnc);
    }

    if (FAILED(hr))
    {
        BufferWriteMessage(pBuff, g_hModule, EMSG_RASDIAG_SHOW_RASCHK_NETCOMP);
    }

    return;
}

//
// Display installed ras components
//
VOID
HrValidateRas(
    IN BUFFER_WRITE_FILE* pBuff)
{
    HRESULT hr = S_OK;
    INetCfg* pnc;

    //
    // Get INetCfg interface
    //
    hr = HrGetINetCfg(TRUE, &pnc);
    if (SUCCEEDED(hr))
    {
        INetCfgComponent* pncc;
//        NT_PRODUCT_TYPE ProductType = NtProductServer;
//        RtlGetNtProductType(&ProductType);

        for (UINT i = 0; i < g_ulNumRasCompIds; i++)
        {
            //
            // see if the component is really installed
            //
            BufferWriteMessage(
                pBuff,
                g_hModule,
                MSG_RASDIAG_SHOW_RASCHK_NETCOMP,
                c_RasCompIds[i].szComponentId);

            hr = pnc->FindComponent(c_RasCompIds[i].szComponentId, &pncc);
            if (S_OK == hr)
            {
                BufferWriteMessage(
                    pBuff,
                    g_hModule,
                    MSG_RASDIAG_SHOW_RASCHK_OK);
                ReleaseObj(pncc);
            }
            else
            {
                BufferWriteMessage(
                    pBuff,
                    g_hModule,
                    MSG_RASDIAG_SHOW_RASCHK_NOTOK);
                hr = S_OK;
            }
        }
        //
        // Release INetCfg
        //
        (VOID) HrReleaseINetCfg(TRUE, pnc);
    }

    if (FAILED(hr))
    {
        BufferWriteMessage(pBuff, g_hModule, EMSG_RASDIAG_SHOW_RASCHK_RASCOMP);
    }

    return;
}

HRESULT
HrConfigureComponent(
    IN INetCfgComponent* pncc,
    IN CONST PWCHAR pszComponentId,
    IN CONST NetClass nc,
    IN CONST PWCHAR pszAnswerfilePath)
{
    WCHAR szParamsSectionName[1025];
    HRESULT hr = S_OK;

    static CONST PWCHAR c_pszSetupSection[] =
    {
        TOKEN_NETADAPTERS,
        TOKEN_NETPROTOCOL,
        TOKEN_NETSERVICES,
        TOKEN_NETCLIENTS
    };

    GetPrivateProfileString(
        c_pszSetupSection[nc],
        pszComponentId,
        g_pwszEmpty,
        szParamsSectionName,
        sizeof(szParamsSectionName) / sizeof(WCHAR) - 1,
        pszAnswerfilePath );
    //
    // Need to query for the private component interface which
    // gives us access to the INetCfgComponentSetup interface.
    //
    INetCfgComponentPrivate* pnccPrivate = NULL;

    hr = pncc->QueryInterface(
                    IID_INetCfgComponentPrivate,
                    reinterpret_cast<void**>(&pnccPrivate));
    if(SUCCEEDED(hr))
    {
        INetCfgComponentSetup* pNetCfgComponentSetup = NULL;
        //
        // Query the notify object for its setup interface.
        //
        hr = pnccPrivate->QueryNotifyObject(
                            IID_INetCfgComponentSetup,
                            reinterpret_cast<void**>(&pNetCfgComponentSetup));
        if(SUCCEEDED(hr))
        {
            hr = pNetCfgComponentSetup->ReadAnswerFile(
                                            pszAnswerfilePath,
                                            szParamsSectionName);
            if(SUCCEEDED(hr))
            {
                hr = pnccPrivate->SetDirty();
            }
        }
    }

    return hr;
}

//
// Initialize COM, create and init INetCfg; Obtain write lock if indicated.
//
HRESULT
HrGetINetCfg(
    IN BOOL fGetWriteLock,
    IN INetCfg** ppnc)
{
    HRESULT hr=S_OK;

    //
    // Initialize the output parameters.
    //
    *ppnc = NULL;
    //
    // initialize COM
    //
    hr = CoInitializeEx(
            NULL,
            COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);

    if (SUCCEEDED(hr))
    {
        //
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_INetCfg,
                (void**)&pnc);
        if (SUCCEEDED(hr))
        {
            INetCfgLock* pncLock = NULL;
            if (fGetWriteLock)
            {
                //
                // Get the locking interface
                //
                hr = pnc->QueryInterface(IID_INetCfgLock, (LPVOID *)&pncLock);
                if (SUCCEEDED(hr))
                {
                    //
                    // Attempt to lock the INetCfg for read/write
                    //

                    static CONST ULONG c_cmsTimeout = 15000;
                    static CONST WCHAR c_szRasmontr[] =
                        L"Remote Access Monitor (rasmontr.dll)";
                    PWSTR szLockedBy;

                    hr = pncLock->AcquireWriteLock(
                                    c_cmsTimeout,
                                    c_szRasmontr,
                                    &szLockedBy);
                    if (S_FALSE == hr)
                    {
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                //
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize(NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef();
                }
                else
                {
                    //
                    // initialize failed, if obtained lock, release it
                    //
                    if (pncLock)
                    {
                        pncLock->ReleaseWriteLock();
                    }
                }
            }

            ReleaseObj(pncLock);
            ReleaseObj(pnc);
        }

        if (FAILED(hr))
        {
            CoUninitialize();
        }
    }

    return hr;
}

//
// Uninitialize INetCfg, release write lock (if present) and uninitialize COM.
//
HRESULT
HrReleaseINetCfg(
    IN BOOL fHasWriteLock,
    IN INetCfg* pnc)
{
    HRESULT hr = S_OK;

    //
    // uninitialize INetCfg
    //
    hr = pnc->Uninitialize();
    //
    // if write lock is present, unlock it
    //
    if (SUCCEEDED(hr) && fHasWriteLock)
    {
        INetCfgLock* pncLock;

        //
        // Get the locking interface
        //
        hr = pnc->QueryInterface(IID_INetCfgLock, (LPVOID *)&pncLock);
        if (SUCCEEDED(hr))
        {
            hr = pncLock->ReleaseWriteLock();
            ReleaseObj(pncLock);
        }
    }

    ReleaseObj(pnc);
    CoUninitialize();

    return hr;
}

PWCHAR
RasDiagVerifyAnswerFile(
    IN CONST PWCHAR pwszFilePath)
{
    WCHAR szFullPathToAnswerFile[MAX_PATH + 1];
    PWCHAR pszFilePath = NULL, pszDontCare;
    HANDLE hFile = NULL;

    //
    // Get the full path to the answerfile, ignore any error return
    //
    GetFullPathName(
        pwszFilePath,
        MAX_PATH,
        szFullPathToAnswerFile,
        &pszDontCare);
    //
    //  Make sure the answerfile actually exists
    //
    hFile = CreateFile(
                szFullPathToAnswerFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        pszFilePath = RutlStrDup(szFullPathToAnswerFile);
        CloseHandle(hFile);
    }

    return pszFilePath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\user.c ===
#include "precomp.h"

BOOL
UserServerInfoIsInit(
    IN  RASMON_SERVERINFO * pServerInfo)
{
    return ((pServerInfo->hServer) || 
            (pServerInfo->dwBuild == RASMONTR_OS_BUILD_NT40));
}

DWORD
UserServerInfoInit(
    IN RASMON_SERVERINFO * pServerInfo)
{
    DWORD dwErr = NO_ERROR;
    BOOL bInit = UserServerInfoIsInit(pServerInfo);

    // If we're already initailized, return
    //
    if (bInit)
    {
        return NO_ERROR;
    }

    if ((pServerInfo->dwBuild != RASMONTR_OS_BUILD_NT40) &&
        (pServerInfo->hServer == NULL))
    {
        //
        // first time connecting to user server
        //
        MprAdminUserServerConnect (
            pServerInfo->pszServer, 
            TRUE, 
            &(pServerInfo->hServer));
    }

    return dwErr;
}

DWORD 
UserServerInfoUninit(
    IN RASMON_SERVERINFO * pServerInfo)
{
    // Release the reference to the user server
    if (g_pServerInfo->hServer)
    {
        MprAdminUserServerDisconnect(g_pServerInfo->hServer);
        g_pServerInfo->hServer = NULL;
    }

    return NO_ERROR;    
}

DWORD
UserGetRasProperties (
    IN  RASMON_SERVERINFO * pServerInfo,
    IN  LPCWSTR pwszUser,
    IN  RAS_USER_0* pUser0)
{
    HANDLE  hUser = NULL;
    DWORD   dwErr;
    BOOL    bInit = UserServerInfoIsInit(pServerInfo);

    do 
    {
        UserServerInfoInit(pServerInfo);
        
        // Get the information using nt40 apis
        //
        if (pServerInfo->dwBuild == RASMONTR_OS_BUILD_NT40)
        {
            dwErr = MprAdminUserGetInfo(
                        pServerInfo->pszServer,
                        pwszUser,
                        0,
                        (LPBYTE)pUser0);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }

        // Or get it using nt50 apis
        else
        {
            // Get a reference to the given user
            //
            dwErr = MprAdminUserOpen(
                        pServerInfo->hServer,
                        (LPWSTR)pwszUser,
                        &hUser);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }

            // Set the information
            //
            dwErr = MprAdminUserRead(
                        hUser,
                        1,      // Gives us RASPRIV_DialinPolicy
                        (LPBYTE)pUser0);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }
        }
        
    } while (FALSE);       
                    
    // Cleanup
    //
    {
        if(hUser)
        {
            MprAdminUserClose(hUser);
        }
        if (!bInit)
        {
            UserServerInfoUninit(pServerInfo);
        }            
    }

    return dwErr;
}

DWORD
UserSetRasProperties (
    IN  RASMON_SERVERINFO * pServerInfo,
    IN  LPCWSTR pwszUser,
    IN  RAS_USER_0* pUser0)
{
    HANDLE  hUser = NULL;
    DWORD   dwErr;
    BOOL    bInit = UserServerInfoIsInit(pServerInfo);

    do 
    {
        UserServerInfoInit(pServerInfo);
        
        // Set the information using nt40 apis
        //
        if (pServerInfo->dwBuild == RASMONTR_OS_BUILD_NT40)
        {
            dwErr = MprAdminUserSetInfo(
                        pServerInfo->pszServer,
                        pwszUser,
                        0,
                        (LPBYTE)pUser0);
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }

        // Or get it using nt50 apis
        else
        {
            // Get a reference to the given user
            //
            dwErr = MprAdminUserOpen(
                        pServerInfo->hServer,
                        (LPWSTR)pwszUser,
                        &hUser);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }

            // Set the information
            //
            dwErr = MprAdminUserWrite(
                        hUser,
                        1,      // Gives us RASPRIV_DialinPolicy
                        (LPBYTE)pUser0);
            if (dwErr isnot NO_ERROR)
            {
                break;
            }
        }
        
    } while (FALSE);       
                    
    // Cleanup
    //
    {
        if(hUser)
        {
            MprAdminUserClose(hUser);
        }
        if (!bInit)
        {
            UserServerInfoUninit(pServerInfo);
        }            
    }

    return dwErr;
}

DWORD
UserAdd(
    IN LPCWSTR           pwszServer,
    IN PRASUSER_DATA     pUser)
    
/*++

Routine Description:

    Adds the given user to the system

--*/

{
    NET_API_STATUS nStatus;
    USER_INFO_2 *  pUser2;
    LPCWSTR        pwszFmtServer = pwszServer;

    // Initialize the base user information
    USER_INFO_1 UserInfo1 = 
    {
        pUser->pszUsername,
        pUser->pszPassword,
        0,
        USER_PRIV_USER,
        L"",
        L"",
        UF_SCRIPT | UF_DONT_EXPIRE_PASSWD | UF_NORMAL_ACCOUNT,
        L""
    };

    // Add the user
    nStatus = NetUserAdd(
                pwszFmtServer,
                1,
                (LPBYTE)&UserInfo1,
                NULL);

    // If the user wasn't added, find out why
    if (nStatus != NERR_Success) 
    {
        switch (nStatus) 
        {
            case ERROR_ACCESS_DENIED:
                return ERROR_ACCESS_DENIED;
                
            case NERR_UserExists:
                return ERROR_USER_EXISTS;
                
            case NERR_PasswordTooShort:
                return ERROR_INVALID_PASSWORDNAME;
        }
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Add the user's full name if provided
    if (pUser->pszFullname)
    {
        // add the user's full name
        nStatus = NetUserGetInfo(
                        pwszFmtServer, 
                        pUser->pszUsername, 
                        2, 
                        (LPBYTE*)&pUser2);
                        
        if (nStatus is NERR_Success) 
        {
            // Modify the full name in the structure
            pUser2->usri2_full_name = pUser->pszFullname;
            NetUserSetInfo(
                pwszFmtServer, 
                pUser->pszUsername, 
                2, 
                (LPBYTE)pUser2, 
                NULL);
                
            NetApiBufferFree((LPBYTE)pUser2);

            return NO_ERROR;
        }
        
        return ERROR_CAN_NOT_COMPLETE;
    }                

    return NO_ERROR;
}

DWORD
UserDelete(
    IN LPCWSTR           pwszServer,
    IN PRASUSER_DATA     pUser)

/*++

Routine Description:

    Deletes the given user from the system

--*/
{
    NET_API_STATUS nStatus;
    
    // Delete the user and return the status code.  If the
    // specified user is not in the user database, consider
    // it a success
    nStatus = NetUserDel(
                pwszServer,
                pUser->pszUsername);
    if (nStatus is NERR_UserNotFound)
    {
        return NO_ERROR;
    }

    return (nStatus is NERR_Success) ? NO_ERROR : ERROR_CAN_NOT_COMPLETE;
}
    
DWORD
UserDumpConfig(
    IN  HANDLE hFile
    )

/*++

Routine Description:

    Dumps a script to set the ras USER information to 
    the given text file.

Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD dwErr;

    // Enumerate the users dumping them as we go
    dwErr = UserEnumUsers(
                g_pServerInfo,
                UserShowSet,
                (HANDLE)hFile);
    if (dwErr isnot NO_ERROR)
    {
        DisplayMessage(
            g_hModule,
            EMSG_UNABLE_TO_ENUM_USERS);
    }

    return dwErr;
}
    
BOOL 
UserShowReport(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    )

/*++

Routine Description:

    Prints ras user information to the display or a file if specified.
    This function can be used as a callback function (see UserEnumUsers).

Arguments:

    pUser       - The user
    hFile       - The file

Return Value:

    TRUE - continue enumeration
    FALSE - stop enumeration

--*/

{
    DWORD   dwErr, dwSize;
    WCHAR   rgwcIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PWCHAR  pwszDialin   = NULL, 
            pwszCbPolicy = NULL, 
            pwszCbNumber = NULL,
            pwszSetCmd   = NULL;

    // Initialize the set command
    //
    pwszSetCmd = DMP_RASUSER_SET;

    // Initialize the dialin string
    //
    if (pUser->User0.bfPrivilege & RASPRIV_DialinPolicy)
    {
        pwszDialin = TOKEN_POLICY;
    }
    else if (pUser->User0.bfPrivilege & RASPRIV_DialinPrivilege)
    {
        pwszDialin = TOKEN_PERMIT;
    }
    else 
    {
        pwszDialin = TOKEN_DENY;
    }

    // Initialize the callback policy string
    //
    if (pUser->User0.bfPrivilege & RASPRIV_NoCallback)
    {
        pwszCbPolicy = TOKEN_NONE;
    }
    else if (pUser->User0.bfPrivilege & RASPRIV_CallerSetCallback)
    {
        pwszCbPolicy = TOKEN_CALLER;
    }
    else
    {
        pwszCbPolicy = TOKEN_ADMIN;
    }

    // Initialize the callback number string
    //
    pwszCbNumber   = pUser->User0.wszPhoneNumber;

    do
    {
        if(!pwszSetCmd              or
           !pUser->pszUsername      or
           !pwszDialin              or
           !pwszCbNumber 
          )
        {

            DisplayError(NULL,
                         ERROR_NOT_ENOUGH_MEMORY);

            break;
        }

        DisplayMessage(g_hModule,
                       MSG_RASUSER_RASINFO,
                       pUser->pszUsername,
                       pwszDialin,
                       pwszCbPolicy,
                       pwszCbNumber);
    
    } while(FALSE);

    return TRUE;
}    

BOOL 
UserShowSet(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    )

/*++

Routine Description:

    Prints ras user information to the display or a file if specified.
    This function can be used as a callback function (see UserEnumUsers).

Arguments:

    pUser       - The user
    hFile       - The file

Return Value:

    TRUE - continue enumeration
    FALSE - stop enumeration

--*/

{
    DWORD   dwErr, dwSize;
    WCHAR   rgwcIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PWCHAR  pwszName     = NULL, 
            pwszDialin   = NULL, 
            pwszCbPolicy = NULL, 
            pwszCbNumber = NULL,
            pwszSetCmd   = NULL;

    // Initialize the set command
    //
    pwszSetCmd = DMP_RASUSER_SET;

    // Initialize the dialin string
    //
    if (pUser->User0.bfPrivilege & RASPRIV_DialinPolicy)
    {
        pwszDialin = RutlAssignmentFromTokens(
                        g_hModule, 
                        TOKEN_DIALIN, 
                        TOKEN_POLICY);
    }
    else if (pUser->User0.bfPrivilege & RASPRIV_DialinPrivilege)
    {
        pwszDialin = RutlAssignmentFromTokens(
                        g_hModule, 
                        TOKEN_DIALIN, 
                        TOKEN_PERMIT);
    }
    else 
    {
        pwszDialin = RutlAssignmentFromTokens(
                        g_hModule, 
                        TOKEN_DIALIN, 
                        TOKEN_DENY);
    }

    // Initialize the callback policy string
    //
    if (pUser->User0.bfPrivilege & RASPRIV_NoCallback)
    {
        pwszCbPolicy = RutlAssignmentFromTokens(
                            g_hModule, 
                            TOKEN_CBPOLICY, 
                            TOKEN_NONE);
    }
    else if (pUser->User0.bfPrivilege & RASPRIV_CallerSetCallback)
    {
        pwszCbPolicy = RutlAssignmentFromTokens(
                            g_hModule, 
                            TOKEN_CBPOLICY, 
                            TOKEN_CALLER);
    }
    else
    {
        pwszCbPolicy = RutlAssignmentFromTokens(
                            g_hModule, 
                            TOKEN_CBPOLICY, 
                            TOKEN_CALLER);
    }

    // Initialize the callback number string
    //
    if (*(pUser->User0.wszPhoneNumber))
    {
        pwszCbNumber = RutlAssignmentFromTokens(
                            g_hModule,
                            TOKEN_CBNUMBER,
                            pUser->User0.wszPhoneNumber);
    }
    else
    {
        pwszCbNumber = NULL;
    }
                        
    pwszName = RutlAssignmentFromTokens(
                        g_hModule,
                        TOKEN_NAME,
                        pUser->pszUsername);
    
    do
    {
        if(!pwszSetCmd              or
           !pwszName                or
           !pwszDialin              or
           !pwszCbPolicy            
          )
        {

            DisplayError(NULL,
                         ERROR_NOT_ENOUGH_MEMORY);

            break;
        }

        DisplayMessage(g_hModule,
                       MSG_RASUSER_SET_CMD,
                       pwszSetCmd,
                       pwszName,
                       pwszDialin,
                       pwszCbPolicy,
                       (pwszCbNumber) ? pwszCbNumber : L"");

    } while(FALSE);

    // Callback
    {
        if (pwszDialin)
        {
            RutlFree(pwszDialin);
        }
        if (pwszCbPolicy)
        {
            RutlFree(pwszCbPolicy);
        }
        if (pwszCbNumber)
        {
            RutlFree(pwszCbNumber);
        }
        if (pwszName)
        {
            RutlFree(pwszName);
        }
    }

    return TRUE;
}    

BOOL 
UserShowPermit(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    )
{
    if (pUser->User0.bfPrivilege & RASPRIV_DialinPrivilege)
    {
        return UserShowReport(pUser, hFile);
    }

    return TRUE;
}

DWORD 
UserEnumUsers(
    IN RASMON_SERVERINFO* pServerInfo,
    IN PFN_RASUSER_ENUM_CB pEnumFn,
    IN HANDLE hData
    )
    
/*++

Routine Description:

    Enumerates all users by calling the given callback function and 
    passing it the user information and some user defined data.

    Enumeration stops when all the users have been enumerated or when
    the enumeration function returns FALSE.

Arguments:

    pwszServer  - The server on which the users should be enumerated
    pEnumFn     - Enumeration function
    hData       - Caller defined opaque data blob

Return Value:

    NO_ERROR

--*/

{
    DWORD dwErr, dwIndex = 0, dwCount = 100, dwEntriesRead, i;
    NET_DISPLAY_USER  * pUsers;
    NET_API_STATUS nStatus;
    RAS_USER_0 RasUser0;
    HANDLE hUser = NULL;
    RASUSER_DATA UserData, *pUserData = &UserData;
    BOOL bInit = UserServerInfoIsInit(pServerInfo);

    UserServerInfoInit(pServerInfo);
    
    // Enumerate the users
    //
    while (TRUE) 
    {
        // Read in the next block of user names
        nStatus = NetQueryDisplayInformation(
                    pServerInfo->pszServer,
                    1,
                    dwIndex,
                    dwCount,
                    dwCount * sizeof(NET_DISPLAY_USER),    
                    &dwEntriesRead,
                    &pUsers);
                    
        // Get out if there's an error getting user names
        if ((nStatus isnot NERR_Success) and 
            (nStatus isnot ERROR_MORE_DATA))
        {
            break;
        }

        for (i = 0; i < dwEntriesRead; i++) 
        {
            // Initialize the user data
            ZeroMemory(pUserData, sizeof(RASUSER_DATA));
        
            // Read in the old information
            dwErr = UserGetRasProperties (
                        pServerInfo, 
                        pUsers[i].usri1_name,
                        &(pUserData->User0));
            if (dwErr isnot NO_ERROR)
            {
                continue;
            }

            // Initialize the rest of the data structure
            pUserData->pszUsername = pUsers[i].usri1_name;
            pUserData->pszFullname = pUsers[i].usri1_full_name;

            // Call the enumeration callback
            if (! ((*(pEnumFn))(pUserData, hData)))
            {
                nStatus = NO_ERROR;
                break;
            }
        }

        // Set the index to read in the next set of users
        dwIndex = pUsers[dwEntriesRead - 1].usri1_next_index;  
        
        // Free the users buffer
        NetApiBufferFree (pUsers);

        // If we've read in everybody, go ahead and break
        if (nStatus isnot ERROR_MORE_DATA)
        {
            break;
        }
    }

    if (!bInit)
    {
        UserServerInfoUninit(pServerInfo);
    }        

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\userhndl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ras\userhndl.c

Abstract:

    Handlers for user commands

Revision History:

    pmay

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
HandleUserSet(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Handler for setting the ras information for a user

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    USERMON_PARAMS*     pParams = NULL;
    RAS_USER_0          RasUser0;
    DWORD               dwErr;
    RASUSER_DATA           UserData, *pUserData = &UserData;

    do {
        // Initialize
        ZeroMemory(&RasUser0, sizeof(RasUser0));
        ZeroMemory(pUserData, sizeof(RASUSER_DATA));
        
        // Parse the options
        dwErr = UserParseSetOptions(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    &pParams);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Read in the current user settings
        dwErr = UserGetRasProperties(
                    g_pServerInfo,
                    pParams->pwszUser,
                    &RasUser0);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Merge in the dialin bit
        if (pParams->lpdwDialin isnot NULL)
        {
            RasUser0.bfPrivilege &= ~RASPRIV_DialinPrivilege;
            RasUser0.bfPrivilege &= ~RASPRIV_DialinPolicy;
            RasUser0.bfPrivilege |= *(pParams->lpdwDialin);
        }

        // Merge in the callback policy
        if (pParams->lpdwCallback isnot NULL)
        {
            RasUser0.bfPrivilege &= ~RASPRIV_NoCallback;
            RasUser0.bfPrivilege &= ~RASPRIV_AdminSetCallback; 
            RasUser0.bfPrivilege &= ~RASPRIV_CallerSetCallback;
            RasUser0.bfPrivilege |= *(pParams->lpdwCallback);
        }            
            
        // Merge in the callback number
        if (pParams->pwszCbNumber isnot NULL)
        {
            wcscpy(RasUser0.wszPhoneNumber, pParams->pwszCbNumber);
            if (wcslen(RasUser0.wszPhoneNumber) > 48)
            {
                dwErr = ERROR_BAD_FORMAT;
                break;
            }
        }            

        // Make sure that if admin set callback is specified, that we
        // force the user to specify a callback number.
        //
        if ((RasUser0.bfPrivilege & RASPRIV_AdminSetCallback) &&
            (wcscmp(RasUser0.wszPhoneNumber, L"") == 0))
        {
            DisplayMessage(
                g_hModule,
                EMSG_RASUSER_MUST_PROVIDE_CB_NUMBER);
                
            dwErr = ERROR_CAN_NOT_COMPLETE;
            
            break;
        }

        // Write out the new user settings
        //
        dwErr = UserSetRasProperties(
                    g_pServerInfo,
                    pParams->pwszUser,
                    &RasUser0);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Read back the settings to see what's
        // new
        //
        dwErr = UserGetRasProperties(
                    g_pServerInfo,
                    pParams->pwszUser,
                    &RasUser0);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Display the new user settings
        pUserData->pszUsername = pParams->pwszUser;
        CopyMemory(&(pUserData->User0), &RasUser0, sizeof(RAS_USER_0));
        UserShowReport(pUserData, NULL);
        
    } while (FALSE);

    // Cleanup
    {
        UserFreeParameters(pParams);
    }

    return dwErr;
}

DWORD
HandleUserShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    DWORD           dwErr = NO_ERROR;
    RASUSER_DATA    UserData, *pUser = &UserData;
    PFN_RASUSER_ENUM_CB pEnumFunc = UserShowReport;
    TOKEN_VALUE     rgEnumMode[] = 
    {
        {TOKEN_REPORT,  0},
        {TOKEN_PERMIT,  1}
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME,    FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_MODE,    FALSE,   FALSE}, 
            rgEnumMode,
            sizeof(rgEnumMode)/sizeof(*rgEnumMode),
            NULL
        }
    };        

    do {
        // Initialize
        ZeroMemory(pUser, sizeof(RASUSER_DATA));

        // Parse
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        //
        // Name
        //
        pUser->pszUsername = RASMON_CMD_ARG_GetPsz(&pArgs[0]);

        //
        // Mode
        //
        if (pArgs[1].rgTag.bPresent)
        {
            if (pArgs[1].Val.dwValue == 0)
            {
                pEnumFunc = UserShowReport;
            }
            else if (pArgs[1].Val.dwValue == 1)
            {
                pEnumFunc = UserShowPermit;
            }
        }
        
        // No user, enumerate all
        //
        if(pUser->pszUsername is NULL)
        {
            dwErr = UserEnumUsers(
                        g_pServerInfo,
                        pEnumFunc,
                        NULL);
            if (dwErr isnot NO_ERROR)
            {
                DisplayMessage(
                    g_hModule,
                    EMSG_UNABLE_TO_ENUM_USERS);
            }
        }

        // Specific user named
        //
        else 
        {
            // Get the user parms
            // 
            dwErr = UserGetRasProperties(
                        g_pServerInfo,
                        pUser->pszUsername,
                        &(pUser->User0));
            if (dwErr isnot NO_ERROR)
            {
                break;
            }

            // Display user properties
            // 
            (*pEnumFunc)(pUser, NULL);
        }

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pUser->pszUsername);
    }
    
    return dwErr;
}

DWORD
UserParseSetOptions(
    IN OUT  LPWSTR              *ppwcArguments,
    IN      DWORD               dwCurrentIndex,
    IN      DWORD               dwArgCount,
    OUT     USERMON_PARAMS**    ppParams
    )

/*++

Routine Description:

    Converts a set of command line arguments into a USERMON_PARAMS 
    structure.  The set operation is assumed.

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg
    ppParams        - receives the parameters

Return Value:

    NO_ERROR

--*/
    
{
    USERMON_PARAMS* pParams = NULL;
    DWORD           i, dwErr;
    BOOL            bDone = FALSE;
    TOKEN_VALUE     rgEnumDialin[] = 
    {
        {TOKEN_PERMIT, RASPRIV_DialinPrivilege},
        {TOKEN_POLICY, RASPRIV_DialinPolicy},
        {TOKEN_DENY,   0}
    };
    TOKEN_VALUE     rgEnumPolicy[] = 
    {
        {TOKEN_NONE,   RASPRIV_NoCallback},
        {TOKEN_CALLER, RASPRIV_CallerSetCallback},
        {TOKEN_ADMIN,  RASPRIV_AdminSetCallback}
    };
    RASMON_CMD_ARG  pArgs[] = 
    {
        {
            RASMONTR_CMD_TYPE_STRING, 
            {TOKEN_NAME, TRUE, FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_DIALIN,FALSE,FALSE},
            rgEnumDialin,
            sizeof(rgEnumDialin)/sizeof(*rgEnumDialin),
            NULL
        },

        {
            RASMONTR_CMD_TYPE_ENUM,
            {TOKEN_CBPOLICY, FALSE,FALSE},
            rgEnumPolicy,
            sizeof(rgEnumPolicy)/sizeof(*rgEnumPolicy),
            NULL
        },

        {
            RASMONTR_CMD_TYPE_STRING,
            {TOKEN_CBNUMBER, FALSE,FALSE},
            NULL,
            0,
            NULL
        }
    };

    do
    {
        // Allocate and initialize the return value
        //
        pParams = RutlAlloc(sizeof(USERMON_PARAMS), TRUE);
        if (pParams is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Parse the command line
        //
        dwErr = RutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    &bDone,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Get strings
        //
        pParams->pwszUser = RASMON_CMD_ARG_GetPsz(&pArgs[0]);
        pParams->pwszCbNumber = RASMON_CMD_ARG_GetPsz(&pArgs[3]);

        // Dialin
        //
        if (pArgs[1].rgTag.bPresent)
        {
            pParams->lpdwDialin = RutlDwordDup(pArgs[1].Val.dwValue);
        }   

        // Callback policy
        //
        if (pArgs[2].rgTag.bPresent)
        {
            pParams->lpdwCallback = RutlDwordDup(pArgs[2].Val.dwValue);
        }   
       
    } while (FALSE);

    // Cleanup
    //
    {
        if (dwErr is NO_ERROR)
        {
            *ppParams = pParams;            
        }
        else
        {
            RutlFree(pParams);
            *ppParams = NULL;
        }
    }
    
    return dwErr;
}

DWORD 
UserFreeParameters(
    IN USERMON_PARAMS *     pParams
    )

/*++

Routine Description:

    Frees the parameter structure returned by UserParseSetOptions 

Arguments:

    pParams        - the parameters to be freed

Return Value:

    NO_ERROR

--*/
    
{
    if (pParams) 
    {
        RutlFree(pParams->pwszUser);
        RutlFree(pParams->lpdwDialin);
        RutlFree(pParams->lpdwCallback);
        RutlFree(pParams->pwszCbNumber);
        RutlFree(pParams);
    }
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\utils.h ===
#define BREAK_ON_DWERR(_e) if ((_e)) break;

#define RutlDispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)

//
// NOTE since WIN32 errors are assumed to fall in the range -32k to 32k
// (see comment in winerror.h near HRESULT_FROM_WIN32 definition), we can
// re-create original Win32 error from low-order 16 bits of HRESULT.
//
#define WIN32_FROM_HRESULT(x) \
    ((HRESULT_FACILITY(x) == FACILITY_WIN32) ? ((DWORD)((x) & 0x0000FFFF)) : (x))

extern CONST WCHAR pszRemoteAccessParamStub[];
extern CONST WCHAR pszEnableIn[];
extern CONST WCHAR pszAllowNetworkAccess[];

typedef
DWORD
(*RAS_REGKEY_ENUM_FUNC_CB)(
    IN LPCWSTR pszName,         // sub key name
    IN HKEY hKey,               // sub key
    IN HANDLE hData);

typedef
DWORD
(*RAS_FILE_ENUM_FUNC_CB)(
    IN LPCWSTR pwszFQFileName,
    IN LPCWSTR pwszFileName,
    IN HANDLE hData);

typedef
BOOL
(*RAS_EVENT_ENUM_FUNC_CB)(
    IN PEVENTLOGRECORD pevlr,
    IN HANDLE hModule,
    IN HANDLE hData);

DWORD
RutlRegEnumKeys(
    IN  HKEY hKey,
    IN  RAS_REGKEY_ENUM_FUNC_CB pEnum,
    IN  HANDLE hData);

DWORD
RutlRegReadDword(
    IN  HKEY hKey,
    IN  LPCWSTR pszValName,
    OUT LPDWORD lpdwValue);

DWORD
RutlRegReadString(
    IN  HKEY hKey,
    IN  LPCWSTR pszValName,
    OUT LPWSTR* ppszValue);

DWORD
RutlRegWriteDword(
    IN HKEY hKey,
    IN LPCWSTR pszValName,
    IN DWORD   dwValue);

DWORD
RutlRegWriteString(
    IN HKEY hKey,
    IN LPCWSTR  pszValName,
    IN LPCWSTR  pszValue);

DWORD
RutlEnumFiles(
    IN LPCWSTR pwszSrchPath,
    IN LPCWSTR pwszSrchStr,
    IN RAS_FILE_ENUM_FUNC_CB pCallback,
    IN HANDLE hData);

DWORD
RutlEnumEventLogs(
    IN LPCWSTR pwszSourceName,
    IN LPCWSTR pwszMsdDll,
    IN DWORD dwMaxEntries,
    IN RAS_EVENT_ENUM_FUNC_CB pCallback,
    IN HANDLE hData);

INT
RutlStrNCmp(
    IN LPCWSTR psz1,
    IN LPCWSTR psz2,
    IN UINT nlLen);

PCHAR
RutlStrDupAFromWAnsi(
    LPCTSTR psz);

PCHAR
RutlStrDupAFromW(
    LPCTSTR psz);

LPWSTR
RutlGetTimeStr(
    ULONG ulTime,
    LPWSTR wszBuf,
    ULONG cchBuf);

LPWSTR
RutlGetDateStr(
    ULONG ulDate,
    LPWSTR wszBuf,
    ULONG cchBuf);

VOID
RutlConvertGuidToString(
    IN  CONST GUID *pGuid,
    OUT LPWSTR      pwszBuffer);

DWORD
RutlConvertStringToGuid(
    IN  LPCWSTR  pwszGuid,
    IN  USHORT   usStringLen,
    OUT GUID    *pGuid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\alias.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\shell\alias.c

Abstract:

    Alias table manipulation functions to add/delete/read aliases.
    The aliases are stored using a hash table (chaining).
  
Revision History:

    Anand Mahalingam          7/6/98  Created

--*/

#include "precomp.h"

//
// The Alias Table
//

PLIST_ENTRY AliasTable[ALIAS_TABLE_SIZE];


//
// Functions to manipulate the Alias Table
//

DWORD
ATHashAlias(
    IN    LPCWSTR pwszAliasName,
    OUT   PWORD   pwHashValue
    )
/*++

Routine Description:

    Computes the hash value for the given string.

Arguments:

    pwszAliasName  - Alias Name
    pwHashValue    - Hash value for Alias
    
Return Value:

    NO_ERROR

--*/
{
    LPCWSTR  p;
    WORD     h = 0,g;

    for (p = pwszAliasName; *p != L'\0'; p++)
    {
        h = (h<<4) + (*p);
        
        if(g = h&0xf0000000)
        {
            h = h ^ (g >> 24);
            h = h ^ g;
        }   
    }

    *pwHashValue = h % ALIAS_TABLE_SIZE;
    
    return NO_ERROR;
}

DWORD
ATInitTable(
    VOID
    )
/*++

Routine Description:

    Initializes the Alias Table to NULL.

Arguments:

Return Value:

--*/
{
    DWORD i;
    PLIST_ENTRY ple;
    
    for (i = 0; i < ALIAS_TABLE_SIZE; i++)
    {
        ple = HeapAlloc(GetProcessHeap(),
                        0,
                        sizeof(LIST_ENTRY));

        if (ple is NULL)
        {
            PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
            break;
        }
        
        InitializeListHead(ple);
        
        AliasTable[i] = ple;
    }

    if (i isnot ALIAS_TABLE_SIZE)
    {
        //
        // malloc error
        //
        for (; i < ALIAS_TABLE_SIZE; AliasTable[i++] = NULL);
        FreeAliasTable();
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return NO_ERROR;
}

VOID
ATCleanupTable(
    VOID
    )
/*++

Routine Description:

    Frees memory allocated for the alias table

Arguments:

Return Value:

--*/
{
    DWORD i;
    
    for (i = 0; i < ALIAS_TABLE_SIZE; i++)
    {
        HeapFree(GetProcessHeap(), 0, AliasTable[i]);
    }

    return;
}

DWORD
ATAddAlias(
    IN    LPCWSTR   pwszAliasName,
    IN    LPCWSTR   pwszAliasString
    )
/*++

Routine Description:

    Adds a new entry in the Alias Table. If alias already
    exists, then set it to the new string.

Arguments:

    pwszAliasName   - Alias Name
    pwszAliasString - Equivalent string
    
Return Value:

    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY

--*/
{
    WORD                  wHashValue;
    PALIAS_TABLE_ENTRY    pateATEntry;
    PLIST_ENTRY           ple;
    
    //
    // Compute hash value for the alias
    //
    ATHashAlias(pwszAliasName,&wHashValue);

    //
    // Check if alias is already present
    //
    ple = AliasTable[wHashValue]->Flink;

    while (ple != AliasTable[wHashValue])
    {
        pateATEntry = CONTAINING_RECORD(ple,ALIAS_TABLE_ENTRY, le);
        
        if (wcscmp(pwszAliasName,pateATEntry->pszAlias) == 0)
        {
            //
            // Alias already exists. Free memory allocated for
            // previous string. Allocate memory for this string.
            //
            
            HeapFree(GetProcessHeap(), 0 , pateATEntry->pszString);

            pateATEntry->pszString = HeapAlloc(GetProcessHeap(),
                                               0 ,
                                               (wcslen(pwszAliasString) + 1)
                                               * sizeof(WCHAR));

            if (pateATEntry->pszString is NULL)
            {
                PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            
            wcscpy(pateATEntry->pszString,pwszAliasString);
            return NO_ERROR;
        }
	
        ple = ple->Flink;
    }

    //
    // Create new Entry and add to beginning of list
    //

    pateATEntry = HeapAlloc(GetProcessHeap(),
                            0,
                            sizeof(ALIAS_TABLE_ENTRY));

    if (pateATEntry is NULL)
    {
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pateATEntry->pszAlias = HeapAlloc(GetProcessHeap(),
                                      0 ,
                                      (wcslen(pwszAliasName) + 1)
                                      * sizeof(WCHAR)); 
    
    if (pateATEntry->pszAlias is NULL)
    {
        HeapFree(GetProcessHeap(), 0 , pateATEntry);
        
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pateATEntry->pszString = HeapAlloc(GetProcessHeap(),
                                       0 ,
                                       (wcslen(pwszAliasString) + 1)
                                       * sizeof(WCHAR)); 
    
    if (pateATEntry->pszString is NULL)
    {
        HeapFree(GetProcessHeap(), 0 , pateATEntry->pszAlias);
        HeapFree(GetProcessHeap(), 0 , pateATEntry);
        
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    wcscpy(pateATEntry->pszAlias, pwszAliasName);
    wcscpy(pateATEntry->pszString, pwszAliasString);

    InsertHeadList(AliasTable[wHashValue],&(pateATEntry->le));

    return NO_ERROR;
}

DWORD
ATDeleteAlias(
    IN    LPCWSTR    pwszAliasName
    )
/*++

Routine Description:

    Deletes an alias in the Alias Table.

Arguments:

    pwszAliasName  - Alias Name

Return Value:

    NO_ERROR, ERROR_ALIAS_NOT_FOUND

--*/
{
    WORD                  wHashValue;
    PALIAS_TABLE_ENTRY    pateATEntry;
    PLIST_ENTRY           ple;
    
    //
    // Compute hash value of alias
    //
    ATHashAlias(pwszAliasName,&wHashValue);

    //
    // Try to find the alias
    //
    ple =  AliasTable[wHashValue];

    if (IsListEmpty(AliasTable[wHashValue]))
    {
        return ERROR_ALIAS_NOT_FOUND;
    }

    ple = AliasTable[wHashValue]->Flink;

    while (ple != AliasTable[wHashValue])
    {
        pateATEntry = CONTAINING_RECORD(ple, ALIAS_TABLE_ENTRY, le);
        
        if (!wcscmp(pwszAliasName,pateATEntry->pszAlias))
        {
            //
            // Found it.
            //
            RemoveEntryList(ple);

            HeapFree(GetProcessHeap(), 0 , pateATEntry->pszAlias);
            HeapFree(GetProcessHeap(), 0 , pateATEntry->pszString);

            HeapFree(GetProcessHeap(),
                     0,
                     pateATEntry);

            return NO_ERROR;
        }
	
        ple = ple->Flink;
    }

    return ERROR_ALIAS_NOT_FOUND;
}
    
DWORD
ATLookupAliasTable(
    IN    LPCWSTR    pwszAliasName,
    OUT   LPWSTR    *ppwszAliasString
    )
/*++

Routine Description:

    Looks up an alias in the Alias Table.

Arguments:

    pwszAliasName     - Alias name
    ppwszAliasString  - Equivalent string
    
Return Value:

    NO_ERROR

--*/
{
    WORD                  wHashValue;
    PALIAS_TABLE_ENTRY    pateATEntry;
    PLIST_ENTRY           ple;
    
    //
    // Compute hash value for alias
    //
    ATHashAlias(pwszAliasName,&wHashValue);

    if (IsListEmpty(AliasTable[wHashValue]))
    {   
        *ppwszAliasString = NULL;
        return NO_ERROR;
    }

    ple = AliasTable[wHashValue]->Flink;
    
    while (ple !=  AliasTable[wHashValue])
    {
        pateATEntry = CONTAINING_RECORD(ple, ALIAS_TABLE_ENTRY, le);
        
        if (wcscmp(pateATEntry->pszAlias,pwszAliasName) == 0)
        {
            //
            // Found Alias
            //
            
            *ppwszAliasString = pateATEntry->pszString;
            return NO_ERROR;
        }

        ple = ple->Flink;
    }

    //
    // Alias not found
    //
    *ppwszAliasString = NULL;
    return NO_ERROR;
}

DWORD
PrintAliasTable(
    VOID
    ) 
/*++

Routine Description:

    Prints the aliases in the alias table

Arguments:

Return Value:

    NO_ERROR

--*/
{
    DWORD                 k;   
    PALIAS_TABLE_ENTRY    pateATEntry;  
    PLIST_ENTRY           ple;
    
    for ( k = 0; k < ALIAS_TABLE_SIZE ; k++) 
    { 
        ple = AliasTable[k]->Flink;
        
        while ( ple != AliasTable[k]) 
        {
            pateATEntry = CONTAINING_RECORD(ple, ALIAS_TABLE_ENTRY, le);
            
            PrintMessage(L"%1!s!\t%2!s!\n", 
                    pateATEntry->pszAlias, 
                    pateATEntry->pszString);
            
            ple = ple->Flink;
        } 
    }

    return NO_ERROR;
    
} 

DWORD
FreeAliasTable(
    VOID
    ) 
/*++

Routine Description:

    Prints the aliases in the alias table

Arguments:

Return Value:

    NO_ERROR

--*/
{
    DWORD                 k;   
    PALIAS_TABLE_ENTRY    pateATEntry;  
    PLIST_ENTRY           pleHead;
    
    for ( k = 0; k < ALIAS_TABLE_SIZE ; k++) 
    { 
        pleHead = AliasTable[k];

        if (pleHead is NULL)
            continue;
        
        while ( !IsListEmpty(pleHead) )
        {
            pateATEntry = CONTAINING_RECORD(pleHead->Flink,
                                            ALIAS_TABLE_ENTRY, le);
            RemoveHeadList(pleHead);

            HeapFree(GetProcessHeap(), 0, pateATEntry);
        }

        HeapFree(GetProcessHeap(), 0, pleHead);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\utils.c ===
#include "precomp.h"

CONST WCHAR pszRemoteAccessParamStub[] =
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\";
CONST WCHAR pszEnableIn[]              = L"EnableIn";
CONST WCHAR pszAllowNetworkAccess[]    = L"AllowNetworkAccess";

CONST WCHAR c_szCurrentBuildNumber[]   = L"CurrentBuildNumber";
CONST WCHAR c_szWinVersionPath[]       =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
CONST WCHAR c_szAssignFmt[]            = L"%s = %s";
CONST WCHAR c_szAssignFmt10[]          = L"%s = %d";
CONST WCHAR c_szAssignFmt16[]          = L"%s = %x";

typedef struct _NAME_NODE
{
    PWCHAR pszName;
    struct _NAME_NODE* pNext;
} NAME_NODE;

DWORD
WINAPI
RutlGetTagToken(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN      PTAG_TYPE   pttTagToken,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    )

/*++

Routine Description:

    Identifies each argument based on its tag. It assumes that each argument
    has a tag. It also removes tag= from each argument.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG

--*/

{
    DWORD      i,j,len;
    PWCHAR     pwcTag,pwcTagVal,pwszArg = NULL;
    BOOL       bFound = FALSE;

    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        len = wcslen(ppwcArguments[i]);

        if (len is 0)
        {
            //
            // something wrong with arg
            //

            pdwOut[i] = (DWORD) -1;
            continue;
        }

        pwszArg = RutlAlloc((len + 1) * sizeof(WCHAR), FALSE);

        if (pwszArg is NULL)
        {
            DisplayError(NULL, 
                         ERROR_NOT_ENOUGH_MEMORY);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        //

        pwcTagVal = wcstok((PWCHAR)NULL,  NETSH_ARG_DELIMITER);

        if (pwcTagVal is NULL)
        {
            DisplayMessage(g_hModule, 
                           ERROR_NO_TAG,
                           ppwcArguments[i]);

            RutlFree(pwszArg);

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //

        bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (MatchToken(pwcTag, pttTagToken[j].pwszTag))
            {
                //
                // Tag matched
                //

                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                break;
            }
        }

        if (bFound)
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            DisplayError(NULL,
                         ERROR_INVALID_OPTION_TAG, 
                         pwcTag);

            RutlFree(pwszArg);

            return ERROR_INVALID_OPTION_TAG;
        }

        RutlFree(pwszArg);
    }

    return NO_ERROR;
}

DWORD
WINAPI
RutlCreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
    )
{
    HANDLE  hFile;

    *phFile = NULL;

    // Create/open the file
    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    // Go to the end of the file
    SetFilePointer(hFile, 0, NULL, FILE_END);    

    *phFile = hFile;

    return NO_ERROR;
}

VOID
WINAPI
RutlCloseDumpFile(
    HANDLE  hFile
    )
{
    CloseHandle(hFile);
}

//
// Returns an allocated block of memory conditionally
// zeroed of the given size.
//
PVOID 
WINAPI
RutlAlloc(
    IN DWORD dwBytes,
    IN BOOL bZero
    )
{
    PVOID pvRet;
    DWORD dwFlags = 0;

    if (bZero)
    {
        dwFlags |= HEAP_ZERO_MEMORY;
    }

    return HeapAlloc(GetProcessHeap(), dwFlags, dwBytes);
}

//
// Conditionally free's a pointer if it is non-null
//
VOID 
WINAPI
RutlFree(
    IN PVOID pvData
    )
{
    if (pvData)
    {
        HeapFree(GetProcessHeap(), 0, pvData);
    }
}

// 
// Uses RutlAlloc to copy a string
//
PWCHAR
WINAPI
RutlStrDup(
    IN LPCWSTR  pwszSrc
    )
{
    PWCHAR pszRet = NULL;
    DWORD dwLen; 
    
    if ((pwszSrc is NULL) or
        ((dwLen = wcslen(pwszSrc)) == 0)
       )
    {
        return NULL;
    }

    pszRet = (PWCHAR) RutlAlloc((dwLen + 1) * sizeof(WCHAR), FALSE);
    if (pszRet isnot NULL)
    {
        wcscpy(pszRet, pwszSrc);
    }

    return pszRet;
}

// 
// Uses RutlAlloc to copy a dword
//
LPDWORD
WINAPI
RutlDwordDup(
    IN DWORD dwSrc
    )
{
    LPDWORD lpdwRet = NULL;
    
    lpdwRet = (LPDWORD) RutlAlloc(sizeof(DWORD), FALSE);
    if (lpdwRet isnot NULL)
    {
        *lpdwRet = dwSrc;
    }

    return lpdwRet;
}

//
// Returns the build number of operating system
//
DWORD
WINAPI
RutlGetOsVersion(
    IN  RASMON_SERVERINFO *pServerInfo
    )
{

    DWORD dwErr, dwType = REG_SZ, dwLength;
    HKEY  hkVersion = NULL;
    WCHAR pszBuildNumber[64];

    //
    // Initialize
    //
    pServerInfo->dwBuild = 0;

    do 
    {
        //
        // Connect to the remote server
        //
        dwErr = RegConnectRegistry(
                    pServerInfo->pszServer,
                    HKEY_LOCAL_MACHINE,
                    &pServerInfo->hkMachine);
        if ( dwErr != ERROR_SUCCESS )        
        {
            break;
        }

        //
        // Open the windows version key
        //

        dwErr = RegOpenKeyEx(
                    pServerInfo->hkMachine, 
                    c_szWinVersionPath, 
                    0, 
                    KEY_QUERY_VALUE, 
                    &hkVersion
                    );
        if ( dwErr != NO_ERROR ) 
        { 
            break; 
        }

        //
        // Read in the current version key
        //
        dwLength = sizeof(pszBuildNumber);
        dwErr = RegQueryValueEx (
                    hkVersion, 
                    c_szCurrentBuildNumber, 
                    NULL, 
                    &dwType,
                    (BYTE*)pszBuildNumber, 
                    &dwLength
                    );
        if (dwErr != NO_ERROR) 
        { 
            break; 
        }

        pServerInfo->dwBuild = (DWORD) wcstol(pszBuildNumber, NULL, 10);
        
    } while (FALSE);


    // Cleanup
    {
        if ( hkVersion )
        {
            RegCloseKey( hkVersion );
        }
    }

    return dwErr;
}

DWORD 
WINAPI
RutlParseOptions(
    IN OUT  LPWSTR                 *ppwcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      DWORD                   dwNumArgs,
    IN      TAG_TYPE*               rgTags,
    IN      DWORD                   dwTagCount,
    OUT     LPDWORD*                ppdwTagTypes)

/*++

Routine Description:

    Based on an array of tag types returns which options are
    included in the given command line.

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
    
{
    LPDWORD     pdwTagType;
    DWORD       i, dwErr = NO_ERROR;
    
    // If there are no arguments, there's nothing to to
    //
    if ( dwNumArgs == 0 )
    {   
        return NO_ERROR;
    }

    // Set up the table of present options
    pdwTagType = (LPDWORD) RutlAlloc(dwArgCount * sizeof(DWORD), TRUE);
    if(pdwTagType is NULL)
    {
        DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do {
        //
        // The argument has a tag. Assume all of them have tags
        //
        if(wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER))
        {
            dwErr = RutlGetTagToken(
                        g_hModule, 
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        rgTags,
                        dwTagCount,
                        pdwTagType);

            if(dwErr isnot NO_ERROR)
            {
                if(dwErr is ERROR_INVALID_OPTION_TAG)
                {
                    dwErr = ERROR_INVALID_SYNTAX;
                    break;
                }
            }
        }
        else
        {
            //
            // No tags - all args must be in order
            //
            for(i = 0; i < dwNumArgs; i++)
            {
                pdwTagType[i] = i;
            }
        }
        
    } while (FALSE);        

    // Cleanup
    {
        if (dwErr is NO_ERROR)
        {
            *ppdwTagTypes = pdwTagType;
        }
        else
        {
            RutlFree(pdwTagType);
        }
    }

    return dwErr;
}

BOOL
WINAPI
RutlIsHelpToken(
    PWCHAR  pwszToken
    )
{
    if(MatchToken(pwszToken, CMD_RAS_HELP1))
        return TRUE;

    if(MatchToken(pwszToken, CMD_RAS_HELP2))
        return TRUE;

    return FALSE;
}

PWCHAR
WINAPI
RutlAssignmentFromTokens(
    IN HINSTANCE hModule,
    IN LPCWSTR pwszToken,
    IN LPCWSTR pszString)
{
    PWCHAR  pszRet = NULL;
    LPCWSTR pszCmd = NULL;
    DWORD dwErr = NO_ERROR, dwSize;
    
    do 
    {
        pszCmd = pwszToken;

        // Compute the string lenghth needed
        //
        dwSize = wcslen(pszString)      + 
                 wcslen(pszCmd)         + 
                 wcslen(c_szAssignFmt)  + 
                 1;
        dwSize *= sizeof(WCHAR);

        // Allocate the return value
        pszRet = (PWCHAR) RutlAlloc(dwSize, FALSE);
        if (pszRet is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy in the command assignment
        wsprintfW(pszRet, c_szAssignFmt, pszCmd, pszString);

    } while (FALSE);

    // Cleanup
    {
        if (dwErr isnot NO_ERROR)
        {
            if (pszRet isnot NULL)
            {
                RutlFree(pszRet);
            }
            pszRet = NULL;
        }
    }

    return pszRet;
}

PWCHAR
WINAPI
RutlAssignmentFromTokenAndDword(
    IN HINSTANCE hModule,
    IN LPCWSTR  pwszToken,
    IN DWORD dwDword,
    IN DWORD dwRadius)
{
    PWCHAR  pszRet = NULL;
    LPCWSTR pszCmd = NULL;
    DWORD dwErr = NO_ERROR, dwSize;
    
    do 
    {
        pszCmd = pwszToken;

        // Compute the string length needed
        //
        dwSize = 64                       + 
                 wcslen(pszCmd)           + 
                 wcslen(c_szAssignFmt10)  + 
                 1;
        dwSize *= sizeof(WCHAR);

        // Allocate the return value
        pszRet = (PWCHAR) RutlAlloc(dwSize, FALSE);
        if (pszRet is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy in the command assignment
        if (dwRadius == 10)
        {
            wsprintfW(pszRet, c_szAssignFmt10, pszCmd, dwDword);
        }
        else
        {
            wsprintfW(pszRet, c_szAssignFmt16, pszCmd, dwDword);
        }

    } while (FALSE);

    // Cleanup
    {
        if (dwErr isnot NO_ERROR)
        {
            if (pszRet isnot NULL)
            {
                RutlFree(pszRet);
            }
            pszRet = NULL;
        }
    }

    return pszRet;
}


DWORD
RutlRegReadDword(
    IN  HKEY hKey,
    IN  LPCWSTR  pszValName,
    OUT LPDWORD lpdwValue)
{
    DWORD dwSize = sizeof(DWORD), dwType = REG_DWORD, dwErr;

    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                &dwType,
                (LPBYTE)lpdwValue,
                &dwSize);
    if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        dwErr = NO_ERROR;
    }

    return dwErr;
}

DWORD
RutlRegReadString(
    IN  HKEY hKey,
    IN  LPCWSTR  pszValName,
    OUT LPWSTR* ppszValue)
{
    DWORD dwErr = NO_ERROR, dwSize = 0;

    *ppszValue = NULL;
    
    // Findout how big the buffer should be
    //
    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                NULL,
                NULL,
                &dwSize);
    if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        return NO_ERROR;
    }
    if (dwErr != ERROR_SUCCESS)
    {
        return dwErr;
    }

    // Allocate the string
    //
    *ppszValue = (PWCHAR) RutlAlloc(dwSize, TRUE);
    if (*ppszValue == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Read the value in and return 
    //
    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                NULL,
                (LPBYTE)*ppszValue,
                &dwSize);
                
    return dwErr;
}

DWORD
RutlRegWriteDword(
    IN HKEY hKey,
    IN LPCWSTR  pszValName,
    IN DWORD dwValue)
{
    return RegSetValueExW(
                hKey,
                pszValName,
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(DWORD));
}

DWORD
RutlRegWriteString(
    IN HKEY hKey,
    IN LPCWSTR  pszValName,
    IN LPCWSTR  pszValue)
{
    return RegSetValueExW(
                hKey,
                pszValName,
                0,
                REG_SZ,
                (LPBYTE)pszValue,
                (wcslen(pszValue) + 1) * sizeof(WCHAR));
}


//
// Enumerates all of the subkeys of a given key
//
DWORD
RutlRegEnumKeys(
    IN HKEY hkKey,
    IN RAS_REGKEY_ENUM_FUNC_CB pCallback,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, i, dwNameSize = 0, dwCurSize = 0;
    DWORD dwCount = 0;
    HKEY hkCurKey = NULL;
    PWCHAR pszName = NULL;
    NAME_NODE *pHead = NULL, *pTemp = NULL;

    do
    {
        // Find out how many sub keys there are
        //
        dwErr = RegQueryInfoKeyW(
                    hkKey,
                    NULL,
                    NULL,
                    NULL,
                    &dwCount,
                    &dwNameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
        if (dwErr != ERROR_SUCCESS)
        {
            return dwErr;
        }
        dwNameSize++;

        // Allocate the name buffer
        //
        pszName = (PWCHAR) RutlAlloc(dwNameSize * sizeof(WCHAR), FALSE);
        if (pszName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Loop through the keys building the list
        //
        for (i = 0; i < dwCount; i++)
        {
            dwCurSize = dwNameSize;
            
            // Get the name of the current key
            //
            dwErr = RegEnumKeyExW(
                        hkKey, 
                        i, 
                        pszName, 
                        &dwCurSize, 
                        0, 
                        NULL, 
                        NULL, 
                        NULL);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Add the key to the list
            //
            pTemp = (NAME_NODE*) RutlAlloc(sizeof(NAME_NODE), TRUE);
            if (pTemp == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            pTemp->pszName = RutlStrDup(pszName);
            if (pTemp->pszName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            pTemp->pNext = pHead;
            pHead = pTemp;
        }

        BREAK_ON_DWERR(dwErr);
        
        // Now loop through the list, calling the callback.
        // The reason the items are added to a list like this
        // is that this allows the callback to safely delete 
        // the reg key without messing up the enumeration
        //
        pTemp = pHead;
        while (pTemp)
        {
            // Open the subkey
            //
            dwErr = RegOpenKeyExW(
                        hkKey,
                        pTemp->pszName,
                        0,
                        KEY_ALL_ACCESS,
                        &hkCurKey);
            if (dwErr != ERROR_SUCCESS)
            {
                continue;
            }

            // Call the callback
            //
            dwErr = pCallback(pTemp->pszName, hkCurKey, hData);
            RegCloseKey(hkCurKey);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            pTemp = pTemp->pNext;
        }            

    } while (FALSE);

    // Cleanup
    {
        RutlFree(pszName);
        while (pHead)
        {
            RutlFree(pHead->pszName);
            pTemp = pHead->pNext;
            RutlFree(pHead);
            pHead = pTemp;
        }
    }

    return dwErr;
}

//
// Generic parse
//
DWORD
RutlParse(
    IN  OUT LPWSTR*         ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      BOOL*           pbDone,
    OUT     RASMON_CMD_ARG* pRasArgs,
    IN      DWORD           dwRasArgCount)
{
    DWORD            i, dwNumArgs, dwErr, dwLevel = 0;
    LPDWORD          pdwTagType = NULL;
    TAG_TYPE*        pTags = NULL;
    RASMON_CMD_ARG*  pArg = NULL;

    if (dwRasArgCount == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do {
        // Initialize
        dwNumArgs = dwArgCount - dwCurrentIndex;
        
        // Generate a list of the tags
        //
        pTags = (TAG_TYPE*)
            RutlAlloc(dwRasArgCount * sizeof(TAG_TYPE), TRUE);
        if (pTags == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        for (i = 0; i < dwRasArgCount; i++)
        {
            CopyMemory(&pTags[i], &pRasArgs[i].rgTag, sizeof(TAG_TYPE));
        }

        // Get the list of present options
        //
        dwErr = RutlParseOptions(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    dwNumArgs,
                    pTags,
                    dwRasArgCount,
                    &pdwTagType);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Copy the tag info back
        //
        for (i = 0; i < dwRasArgCount; i++)
        {
            CopyMemory(&pRasArgs[i].rgTag, &pTags[i], sizeof(TAG_TYPE));
        }
    
        for(i = 0; i < dwNumArgs; i++)
        {
            // Validate the current argument
            //
            if (pdwTagType[i] >= dwRasArgCount)
            {
                i = dwNumArgs;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            pArg = &pRasArgs[pdwTagType[i]];

            // Get the value of the argument
            //
            switch (pArg->dwType)
            {
                case RASMONTR_CMD_TYPE_STRING:
                    pArg->Val.pszValue = 
                        RutlStrDup(ppwcArguments[i + dwCurrentIndex]);
                    break;

                case RASMONTR_CMD_TYPE_DWORD:                    
                    pArg->Val.dwValue = 
                        _wtol(ppwcArguments[i + dwCurrentIndex]);
                    break;
                    
                case RASMONTR_CMD_TYPE_ENUM:
                    dwErr = MatchEnumTag(g_hModule,
                                         ppwcArguments[i + dwCurrentIndex],
                                         pArg->dwEnumCount,
                                         pArg->rgEnums,
                                         &(pArg->Val.dwValue));

                    if(dwErr != NO_ERROR)
                    {
                        RutlDispTokenErrMsg(
                            g_hModule, 
                            EMSG_BAD_OPTION_VALUE,
                            pArg->rgTag.pwszTag,
                            ppwcArguments[i + dwCurrentIndex]);
                        i = dwNumArgs;
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                    break;
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Mark the argument as present if needed
            //
            if (pArg->rgTag.bPresent)
            {
                dwErr = ERROR_TAG_ALREADY_PRESENT;
                i = dwNumArgs;
                break;
            }
            pArg->rgTag.bPresent = TRUE;
        }
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        // Make sure that all of the required parameters have
        // been included.
        //
        for (i = 0; i < dwRasArgCount; i++)
        {
            if ((pRasArgs[i].rgTag.dwRequired & NS_REQ_PRESENT) 
             && !pRasArgs[i].rgTag.bPresent)
            {
                DisplayMessage(g_hModule, EMSG_CANT_FIND_EOPT);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

    } while (FALSE);  
    
    // Cleanup
    {
        if (pTags)
        {
            RutlFree(pTags);
        }
        if (pdwTagType)
        {
            RutlFree(pdwTagType);
        }
    }

    return dwErr;
}

DWORD
RutlEnumFiles(
    IN LPCWSTR pwszSrchPath,
    IN LPCWSTR pwszSrchStr,
    IN RAS_FILE_ENUM_FUNC_CB pCallback,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, dwSize = 0;
    PWCHAR pwszFileSearch = NULL;
    HANDLE hSearch = NULL;
    WIN32_FIND_DATA FindFileData;

    do
    {
        if (!pwszSrchPath || !pwszSrchStr || !pCallback)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        dwSize = lstrlen(pwszSrchPath) + lstrlen(pwszSrchStr) + 1;
        if (dwSize < 2)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        pwszFileSearch = RutlAlloc(dwSize * sizeof(WCHAR), TRUE);
        if (!pwszFileSearch)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        lstrcpy(pwszFileSearch, pwszSrchPath);
        lstrcat(pwszFileSearch, pwszSrchStr);

        hSearch = FindFirstFile(pwszFileSearch, &FindFileData);
        if (INVALID_HANDLE_VALUE == hSearch)
        {
            dwErr = GetLastError();
            break;
        }

        for (;;)
        {
            PWCHAR pwszFileName = NULL;

            dwSize = lstrlen(pwszSrchPath) +
                     lstrlen(FindFileData.cFileName) + 1;
            if (dwSize < 2)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            pwszFileName = RutlAlloc(dwSize * sizeof(WCHAR), TRUE);
            if (!pwszFileName)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            lstrcpy(pwszFileName, pwszSrchPath);
            lstrcat(pwszFileName, FindFileData.cFileName);
            //
            // Call the callback
            //
            dwErr = pCallback(pwszFileName, FindFileData.cFileName, hData);
            //
            // Clean up
            //
            RutlFree(pwszFileName);

            if (dwErr)
            {
                break;
            }

            if (!FindNextFile(hSearch, &FindFileData))
            {
                break;
            }
        }

        FindClose(hSearch);

    } while (FALSE);
    //
    // Clean up
    //
    RutlFree(pwszFileSearch);

    return dwErr;
}

DWORD
RutlEnumEventLogs(
    IN LPCWSTR pwszSourceName,
    IN LPCWSTR pwszMsdDll,
    IN DWORD dwMaxEntries,
    IN RAS_EVENT_ENUM_FUNC_CB pCallback,
    IN HANDLE hData)
{
    DWORD dwErr = NO_ERROR, dwSize, dwRead, dwNeeded, dwCount = 0;
    LPBYTE pBuffer = NULL;
    HANDLE hLog = NULL;
    HMODULE hMod = NULL;
    PEVENTLOGRECORD pevlr = NULL;

    do
    {
        hLog = OpenEventLog(NULL, pwszSourceName);
        if (!hLog)
        {
            dwErr = GetLastError();
            break;
        }

        dwSize = 1024 * sizeof(EVENTLOGRECORD);

        pBuffer = RutlAlloc(dwSize, FALSE);
        if (!pBuffer)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        hMod = LoadLibrary(pwszMsdDll);
        if (!hMod)
        {
            dwErr = GetLastError();
            break;
        }

        pevlr = (PEVENTLOGRECORD)pBuffer;
        //
        // Opening the event log positions the file pointer for this
        // handle at the beginning of the log. Read the records
        // sequentially until there are no more.
        //
        for (;;)
        {
            if (!ReadEventLog(
                        hLog,
                        EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                        0,
                        pevlr,
                        dwSize,
                        &dwRead,
                        &dwNeeded))
            {
                dwErr = GetLastError();
                break;
            }

            while ((dwRead > 0) && (dwCount < dwMaxEntries))
            {
                //
                // Call the callback
                //
                if (pCallback(pevlr, hMod, hData))
                {
                    dwCount++;
                }

                dwRead -= pevlr->Length;
                pevlr = (PEVENTLOGRECORD) ((LPBYTE) pevlr + pevlr->Length);
            }

            if (dwCount >= dwMaxEntries)
            {
                break;
            }

            pevlr = (PEVENTLOGRECORD)pBuffer;
        }

    } while (FALSE);
    //
    // Clean up
    //
    if (hMod)
    {
        FreeLibrary(hMod);
    }
    RutlFree(pBuffer);
    if (hLog)
    {
        CloseEventLog(hLog);
    }

    return dwErr;
}

INT
RutlStrNCmp(
    IN LPCWSTR psz1,
    IN LPCWSTR psz2,
    IN UINT nlLen)
{
    UINT i;

    for (i = 0; i < nlLen; ++i)
    {
        if (*psz1 == *psz2)
        {
            if (*psz1 == g_pwszNull)
                return 0;
        }
        else if (*psz1 < *psz2)
            return -1;
        else
            return 1;

        ++psz1;
        ++psz2;
    }

    return 0;
}

//
// Returns heap block containing a copy of 0-terminated string 'psz' or
// NULL on error or is 'psz' is NULL.  The output string is converted to
// MB ANSI.  It is caller's responsibility to 'Free' the returned string.
//
PCHAR
RutlStrDupAFromWInternal(
    LPCTSTR psz,
    IN DWORD dwCp)
{
    CHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = WideCharToMultiByte(dwCp, 0, psz, -1, NULL, 0, NULL, NULL);
        ASSERT(cb);

        pszNew = (CHAR* )RutlAlloc(cb + 1, FALSE);
        if (!pszNew)
        {
            return NULL;
        }

        cb = WideCharToMultiByte(dwCp, 0, psz, -1, pszNew, cb, NULL, NULL);
        if (cb == 0)
        {
            RutlFree(pszNew);
            return NULL;
        }
    }

    return pszNew;
}

PCHAR
RutlStrDupAFromWAnsi(
    LPCTSTR psz)
{
    return RutlStrDupAFromWInternal(psz, CP_ACP);
}

PCHAR
RutlStrDupAFromW(
    LPCTSTR psz)
{
    return RutlStrDupAFromWInternal(psz, CP_UTF8);
}

BOOL
RutlSecondsSince1970ToSystemTime(
    IN DWORD dwSecondsSince1970,
    OUT SYSTEMTIME* pSystemTime)
{
    LARGE_INTEGER liTime;
    FILETIME ftUTC;
    FILETIME ftLocal;

    //
    // Seconds since the start of 1970 -> 64 bit Time value
    //
    RtlSecondsSince1970ToTime(dwSecondsSince1970, &liTime);
    //
    // The time is in UTC. Convert it to local file time
    //
    ftUTC.dwLowDateTime  = liTime.LowPart;
    ftUTC.dwHighDateTime = liTime.HighPart;

    if (FileTimeToLocalFileTime(&ftUTC, &ftLocal) == FALSE)
    {
        return FALSE;
    }
    //
    //  Convert local file time to system time.
    //
    if (FileTimeToSystemTime(&ftLocal, pSystemTime) == FALSE)
    {
        return FALSE;
    }

    return TRUE;
}

LPWSTR
RutlGetTimeStr(
    ULONG ulTime,
    LPWSTR wszBuf,
    ULONG cchBuf)
{
    ULONG cch;
    SYSTEMTIME stGenerated;

    if (RutlSecondsSince1970ToSystemTime(ulTime, &stGenerated))
    {
        cch = GetTimeFormat(LOCALE_USER_DEFAULT,
                            0,
                            &stGenerated,
                            NULL,
                            wszBuf,
                            cchBuf);
        if (!cch)
        {
            wszBuf[0] = g_pwszNull;
        }
    }

    return wszBuf;
}

LPWSTR
RutlGetDateStr(
    ULONG ulDate,
    LPWSTR wszBuf,
    ULONG cchBuf)
{
    ULONG cch;
    SYSTEMTIME stGenerated;

    wszBuf[0] = g_pwszNull;

    do
    {
        if (!RutlSecondsSince1970ToSystemTime(ulDate, &stGenerated))
        {
            break;
        }

        cch = GetDateFormat(LOCALE_USER_DEFAULT,
                            DATE_SHORTDATE,
                            &stGenerated,
                            NULL,
                            wszBuf,
                            cchBuf);
        if (!cch)
        {
            wszBuf[0] = g_pwszNull;
        }

    } while (FALSE);

    return wszBuf;
}

VOID
RutlConvertGuidToString(
    IN  CONST GUID *pGuid,
    OUT LPWSTR      pwszBuffer)
{
    wsprintf(pwszBuffer, L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        pGuid->Data1, pGuid->Data2, pGuid->Data3,
        pGuid->Data4[0], pGuid->Data4[1],
        pGuid->Data4[2], pGuid->Data4[3],
        pGuid->Data4[4], pGuid->Data4[5],
        pGuid->Data4[6], pGuid->Data4[7]);
}

DWORD
RutlConvertStringToGuid(
    IN  LPCWSTR  pwszGuid,
    IN  USHORT   usStringLen,
    OUT GUID    *pGuid)
{
    UNICODE_STRING  Temp;

    Temp.Length = Temp.MaximumLength = usStringLen;

    Temp.Buffer = (LPWSTR)pwszGuid;

    if(RtlGUIDFromString(&Temp, pGuid) isnot STATUS_SUCCESS)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\userhndl.h ===
//
// Structure contains the various parameters that can be
// set for users.  If a parameter is NULL, it means that 
// it was not specified.
//
typedef struct _USERMON_PARAMS
{
    PWCHAR  pwszUser;
    LPDWORD lpdwDialin;
    LPDWORD lpdwCallback;
    PWCHAR  pwszCbNumber;
} USERMON_PARAMS;

//
// Define the operations that drive the option parser.
//
#define RASUSER_OP_SHOW     0x1
#define RASUSER_OP_SET      0x2


FN_HANDLE_CMD    HandleUserSet;
FN_HANDLE_CMD    HandleUserShow;
FN_HANDLE_CMD    HandleUserAdd;
FN_HANDLE_CMD    HandleUserDelete;

DWORD
UserParseSetOptions(
    IN OUT  LPWSTR              *ppwcArguments,
    IN      DWORD               dwCurrentIndex,
    IN      DWORD               dwArgCount,
    OUT     USERMON_PARAMS**    ppParams);

DWORD 
UserFreeParameters(
    IN USERMON_PARAMS *     pParams);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\ras\user.h ===
/*
    File: user.h
    
    Utilities that directly affect users.  The caching mechanism is made
    transparent through this interface.

    Paul Mayfield
*/

//
// This structure defines all that is needed to describe
// a user with respect to ras.
//
typedef struct _RASUSER_DATA
{
    PWCHAR pszUsername;
    PWCHAR pszFullname;
    PWCHAR pszPassword;
    RAS_USER_0 User0;
} RASUSER_DATA, *PRASUSER_DATA;    

//
// Defines a prototype for a callback function provided to
// enumerate users (see UserEnumUsers)
//
// Return TRUE to continue enumeration, FALSE to stop it.
//
typedef BOOL (* PFN_RASUSER_ENUM_CB)(
                    IN PRASUSER_DATA pUser, 
                    IN HANDLE hData);
    
DWORD
UserGetRasProperties (
    IN  RASMON_SERVERINFO * pServerInfo,
    IN  LPCWSTR pwszUser,
    IN  RAS_USER_0* pUser0);
    
DWORD
UserSetRasProperties (
    IN  RASMON_SERVERINFO * pServerInfo,
    IN  LPCWSTR pwszUser,
    IN  RAS_USER_0* pUser0);

DWORD 
UserEnumUsers(
    IN RASMON_SERVERINFO* pServerInfo,
    IN PFN_RASUSER_ENUM_CB pEnumFn,
    IN HANDLE hData
    );

DWORD 
UserDumpConfig(
    IN HANDLE hFile);
    
BOOL 
UserShowSet(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    );

BOOL 
UserShowReport(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    );

BOOL 
UserShowPermit(
    IN  PRASUSER_DATA          pUser,
    IN  HANDLE              hFile
    );
    
DWORD
UserServerInfoInit(
    IN RASMON_SERVERINFO * pServerInfo
    );

DWORD
UserServerInfoUninit(
    IN RASMON_SERVERINFO * pServerInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\alias.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\common\alias.h

Abstract:

    Hash Table implementation include.

Revision History:

    Anand Mahalingam          7/6/98  Created

--*/


#define ALIAS_TABLE_SIZE    211

//
// Type definitions for Alias Table
//

typedef struct _ALIAS_TABLE_ENTRY
{
    LPWSTR        pszAlias;    // Alias Name
    LPWSTR        pszString;   // Corresponding string
    LIST_ENTRY    le;          // list pointers
}ALIAS_TABLE_ENTRY,*PALIAS_TABLE_ENTRY;


//
// Prototypes of functions to manipulate Alias Table
//

DWORD
ATHashAlias(
    IN    LPCWSTR pwszAliasName,
    OUT   PWORD   pwHashValue
    );

DWORD
ATInitTable(
    VOID
    );

DWORD
ATAddAlias(
    IN    LPCWSTR pwszAliasName,
    IN    LPCWSTR pwszAliasString
    );

DWORD
ATDeleteAlias(
    IN    LPCWSTR pwszAliasName
    );

DWORD
ATLookupAliasTable(
    IN    LPCWSTR pwszAliasName,
    OUT   LPWSTR *ppwszAliasString
    );

DWORD
PrintAliasTable(
    VOID
    ) ;

DWORD
FreeAliasTable(
    VOID
    ) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\guidmap.h ===
/*
	File	GuidMap.h

	Defines functions to map guid instances to descriptive names. 

	Paul Mayfield, 8/25/97

	Copyright 1997, Microsoft Corporation.
*/	

DWORD
RmpInitIfNameMapServer(
    IN  LPCWSTR  pwszServerName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\handle.h ===
FN_HANDLE_CMD HandleAddHelper;
FN_HANDLE_CMD HandleDelHelper;
FN_HANDLE_CMD HandleShowHelper;
FN_HANDLE_CMD HandleShowAlias;
FN_HANDLE_CMD HandleSetFile;
FN_HANDLE_CMD HandleSetMode;
FN_HANDLE_CMD HandleShowMode;
FN_HANDLE_CMD HandleSetMachine;
FN_HANDLE_CMD HandleShellDump;
FN_HANDLE_CMD HandleShellFlush;
FN_HANDLE_CMD HandleShellHelp;
FN_HANDLE_CMD HandleShellLoad;
FN_HANDLE_CMD HandleShellSave;
FN_HANDLE_CMD HandleShellCommit;
FN_HANDLE_CMD HandleShellUncommit;
FN_HANDLE_CMD HandleShellCommitstate;
FN_HANDLE_CMD HandleShellExit;
FN_HANDLE_CMD HandleShellAlias;
FN_HANDLE_CMD HandleShellUnalias;
FN_HANDLE_CMD HandleShellUplevel;
FN_HANDLE_CMD HandleShellPushd;
FN_HANDLE_CMD HandleShellPopd;
FN_HANDLE_CMD HandleUbiqDump;
FN_HANDLE_CMD HandleUbiqHelp;


DWORD
ShowShellHelp(
    DWORD   dwDisplayFlags,
    LPCWSTR pwszGroup,
    DWORD   dwCmdFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\nsstring.h ===
#define MSG_NEWLINE          _T("\n")
#define MSG_STRING           _T("%1!s!")
#define MSG_HELP_START       _T("%1!-14s! - ")
#define STRING_NETSH         _T("netsh")

#define CMD_ALIAS            _T("alias")
#define CMD_UNALIAS          _T("unalias")
#define CMD_UPLEVEL          _T("..")
#define CMD_PUSHD            _T("pushd")
#define CMD_POPD             _T("popd")
#define CMD_COMMIT           _T("online")
#define CMD_UNCOMMIT         _T("offline")
#define CMD_DUMP             _T("dump")
#define CMD_LOAD             _T("exec")
#define CMD_FLUSH            _T("abort")
#define CMD_QUIT             _T("quit")
#define CMD_BYE              _T("bye")
#define CMD_EXIT             _T("exit")
#define CMD_SAVE             _T("commit")
#define CMD_HELP1            _T("help")
#define CMD_HELP2            _T("?")
#define CMD_SHOW_HELPER      _T("helper")
#define CMD_ADD_HELPER        L"helper"
#define CMD_DEL_HELPER        L"helper"
#define CMD_SHOW_ALIAS        L"alias"
#define CMD_GROUP_ADD        _T("add")
#define CMD_GROUP_DELETE     _T("delete")
#define CMD_GROUP_SET        _T("set")
#define CMD_GROUP_SHOW        L"show"
#define CMD_SET_FILE		 _T("file")
#define CMD_SET_MODE          L"mode"
#define CMD_SHOW_MODE         L"mode"
#define CMD_SET_MACHINE       L"machine"

#define TOKEN_VALUE_OFFLINE  L"offline"
#define TOKEN_VALUE_ONLINE   L"online"
#define TOKEN_MODE           L"mode"
#define TOKEN_FILE           L"file"
#define TOKEN_NAME           L"name"
#define TOKEN_VALUE_OPEN     L"open"
#define TOKEN_VALUE_APPEND   L"append"
#define TOKEN_VALUE_CLOSE    L"close"
#define TOKEN_USER_NAME      L"user"
#define TOKEN_PASSWORD       L"pwd"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\guidmap.c ===
/*
    File        GuidMap.c

    Defines function to map a guid interface name to an unique descriptive 
    name describing that interface and vice versa.

    Paul Mayfield, 8/25/97

    Copyright 1997, Microsoft Corporation.
*/

#include "precomp.h"
#pragma hdrstop

DWORD 
NsGetFriendlyNameFromIfName(
    IN  HANDLE  hMprConfig,
    IN  LPCWSTR pwszName, 
    OUT LPWSTR  pwszBuffer, 
    IN  PDWORD pdwBufSize
    )
/*++
Arguments:

    hMprConfig          - Handle to the MprConfig
    pwszName            - Buffer holding the Guid Interface Name
    pwszBuffer          - Buffer to hold the Friendly Interface Name
    pdwBufSize          - pointer to, size (in Bytes) of the pwszBuffer buffer

--*/
{
    DWORD   dwErr;

    if ((pdwBufSize == NULL) || (*pdwBufSize == 0) || (pwszName == NULL))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    if (g_pwszRouterName is NULL) 
    {
        GUID Guid;
        UNICODE_STRING us;
        NTSTATUS ntStatus;

        //
        // If we're operating on the local machine, just use IPHLPAPI
        // which works for some ras client interfaces too.  The Mpr
        // API will fail for all ras client interfaces, but it's 
        // remotable whereas IPHLPAPI is not.
        //

        RtlInitUnicodeString(&us, pwszName);
        ntStatus = RtlGUIDFromString(&us, &Guid);
        if (ntStatus == STATUS_SUCCESS)
        {
            dwErr = NhGetInterfaceNameFromGuid(
                        &Guid,
                        pwszBuffer,
                        pdwBufSize,
                        FALSE,
                        FALSE);
            if (dwErr == NO_ERROR)
            {
                return dwErr;
            }
        }                                       
    }

    if (hMprConfig == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    dwErr =  MprConfigGetFriendlyName(hMprConfig, 
                                      (LPWSTR)pwszName,
                                      pwszBuffer, 
                                      *pdwBufSize);

    if(dwErr isnot NO_ERROR)
    {
        HANDLE hIfHandle;
        
        dwErr = MprConfigInterfaceGetHandle(hMprConfig,
                                            (LPWSTR)pwszName,
                                            &hIfHandle);

        if (dwErr is NO_ERROR)
        {
            wcsncpy(pwszBuffer,
                    pwszName,
                    (*pdwBufSize)/sizeof(WCHAR));
        }
        else
        {
            dwErr = ERROR_NO_SUCH_INTERFACE ;
        }
    }

    return dwErr;
}


DWORD
NsGetIfNameFromFriendlyName(
    IN  HANDLE  hMprConfig,
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    )
/*++
Arguments:

    hMprConfig          - Handle to the MprConfig
    pwszName            - Buffer holding the Friendly Interface Name
    pwszBuffer          - Buffer to hold the Guid Interface Name
    pdwBufSize          - pointer to, size (in Bytes) of the pwszBuffer buffer

Return:
    NO_ERROR, ERROR_NO_SUCH_INTERFACE
--*/
{
    DWORD            dwErr, i, dwCount, dwTotal, dwSize;
    HANDLE           hIfHandle;
    PMPR_INTERFACE_0 pmi0;
    WCHAR            wszFriendlyName[MAX_INTERFACE_NAME_LEN+1];

    if((hMprConfig == NULL) || 
       (pdwBufSize == NULL) ||
       (*pdwBufSize == 0))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // First try to map a friendly name to a GUID name

    dwErr = MprConfigGetGuidName(hMprConfig, 
                                 (LPWSTR)pwszName, 
                                 pwszBuffer, 
                                 *pdwBufSize);

    if (dwErr isnot ERROR_NOT_FOUND)
    {
        return dwErr;
    }

    // Next see if the friendly name is the same as an interface name
    
    dwErr = MprConfigInterfaceGetHandle(hMprConfig,
                                        (LPWSTR)pwszName,
                                        &hIfHandle);

    if (dwErr is NO_ERROR)
    {
        wcsncpy(pwszBuffer,
                pwszName,
                (*pdwBufSize)/sizeof(WCHAR));
    }

    if (dwErr isnot ERROR_NO_SUCH_INTERFACE)
    {
        return dwErr;
    }

    // Exact match failed, try a longest match by enumerating
    // all interfaces and comparing friendly names (yes this
    // can be slow, but I can't think of any other way offhand
    // to allow interface names to be abbreviated)

    dwErr = MprConfigInterfaceEnum( hMprConfig,
                                    0,
                                    (LPBYTE*) &pmi0,
                                    (DWORD) -1,
                                    &dwCount,
                                    &dwTotal,
                                    NULL );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    dwErr = ERROR_NO_SUCH_INTERFACE;

    for (i=0; i<dwCount; i++)
    {
        DWORD   dwRet;

        // Get interface friendly name

        dwSize = sizeof(wszFriendlyName);

        dwRet = NsGetFriendlyNameFromIfName( hMprConfig,
                                             pmi0[i].wszInterfaceName,
                                             wszFriendlyName, 
                                             &dwSize );

        if(dwRet is NO_ERROR)
        {
            //
            // Check for substring match
            //

            if (MatchToken( pwszName, wszFriendlyName))
            {
                wcsncpy(pwszBuffer,
                        pmi0[i].wszInterfaceName,
                        (*pdwBufSize)/sizeof(WCHAR));

                dwErr = NO_ERROR;
            
                break;
            }
        }
    }

    MprConfigBufferFree(pmi0);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\defs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\shell\defs.h

Abstract:

    Definitions for all files in the shell.

Revision History:

    Anand Mahalingam          7/6/98  Created

--*/

#define is       ==
#define isnot    !=
#define or       ||
#define and      &&

#define MAX_CMD_LEN      8192            // total size of command line
#define MAX_MSG_LENGTH   5120            // length of message in resource

//
// These are passed as arguments to the helper commit fn.
// So, must have the same definition there too.
//

#define SHELL_ERROR_BASE                0xff00
#define ERROR_STRING_TOO_LONG           (SHELL_ERROR_BASE + 1)
#define ERROR_MALLOC_FAILED             (SHELL_ERROR_BASE + 2)
#define ERROR_ALIAS_NOT_FOUND           (SHELL_ERROR_BASE + 3)
#define ERROR_ENTRY_FN_NOT_FOUND        (SHELL_ERROR_BASE + 4)
//
// This again must be defined the same way in the helpers.
//

typedef
DWORD
(*PHELPER_ENTRY_FN)(
    IN    LPCWSTR              pwszRouter,
    IN    LPCWSTR             *pptcArguments,
    IN    DWORD                dwArgCount,
    OUT   LPWSTR               pwcNewContext
    );

#define wctomb(wcs, str)    \
WideCharToMultiByte(GetConsoleOutputCP(), 0, (wcs), -1, (str), MAX_NAME_LEN, NULL, NULL)

#define PRINTA(str)     printf("%s\n", str)
#define PRINT(wstr)     wprintf(L"%s\n", wstr)
#define PRINT1(wstr)     wprintf(L"%s\n", L##wstr)

#define MALLOC(x)    HeapAlloc(GetProcessHeap(), 0, (x))
#define REALLOC(w,x) HeapReAlloc(GetProcessHeap(), 0, (w), (x))
#define FREE(x)      HeapFree(GetProcessHeap(), 0, (x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\handle.c ===
#include "precomp.h"

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x)   HeapFree(GetProcessHeap(), 0, (x))

DWORD
HandleShowAlias(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    return PrintAliasTable();
}

DWORD
HandleShellExit(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_COMMIT_STATE, &bTmp);

    if (!bTmp)
    {
        CallCommit(NETSH_FLUSH, &bTmp);
    }

    *pbDone = TRUE;

    return NO_ERROR;
}

DWORD
HandleShellLoad(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD dwErr, dwNumArgs;

    dwNumArgs = dwArgCount - dwCurrentIndex;

    //
    // Load Command
    //
    switch (dwNumArgs)
    {
        case 1 :
            return LoadScriptFile(ppwcArguments[dwCurrentIndex]);

        default :
            return ERROR_INVALID_SYNTAX;
    }

    return NO_ERROR;
}

DWORD
HandleShellSave(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_SAVE, &bTmp);
            
    return NO_ERROR;
}

DWORD
HandleShellUncommit(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_UNCOMMIT, &bTmp);
            
    return NO_ERROR;
}

DWORD
HandleSetMachine(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    TAG_TYPE pttTags[] = {{TOKEN_NAME,      FALSE, FALSE },
                          {TOKEN_USER_NAME, FALSE, FALSE },
                          {TOKEN_PASSWORD,  FALSE, FALSE }};
    DWORD    dwNumTags = sizeof(pttTags)/sizeof(TAG_TYPE);
    PDWORD   pdwTagType;
    DWORD    dwErr, dwNumArg, dwMode, i;
    BOOL     bTmp;
    LPWSTR   szMachine  = NULL;
    LPWSTR   szUserName = NULL;
    LPWSTR   szPassword = NULL;
    BOOL     fFreePassword = FALSE;

    dwNumArg = dwArgCount - dwCurrentIndex;

    if (dwNumArg < 1)
    {
        return SetMachine(NULL, NULL, NULL);
    }

    if ((dwNumArg > 3) || IsHelpToken(ppwcArguments[dwCurrentIndex]))
    {
        return ERROR_SHOW_USAGE;
    }

    pdwTagType = MALLOC(dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, 
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               pttTags,
                               dwNumTags,
                               pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        FREE(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }
        return dwErr;
    }


    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // NAME
            {
                szMachine = ppwcArguments[i + dwCurrentIndex];
                break;
            }

            case 1: // USER NAME
            {
                szUserName = ppwcArguments[i + dwCurrentIndex];
                break;
            }

            case 2: // PASSWORD
            {
                szPassword = ppwcArguments[i + dwCurrentIndex];
                break;
            }

            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }

    if ( (!szMachine) && (szUserName || szPassword) )
    {
        return ERROR_SHOW_USAGE;
    }

    if (szPassword && _wcsicmp(szPassword, L"*") == 0)
    {
        DWORD dwLen = 0;
        PrintMessageFromModule(g_hModule, MSG_NETSH_LOGIN_PASSWORD, szMachine);

        szPassword = MALLOC(sizeof(WCHAR) * MAX_PATH);
        if (!szPassword)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        fFreePassword = TRUE;
        if (0 != GetPasswdStr(szPassword, MAX_PATH, &dwLen))
        {
            FREE(szPassword);
            return ERROR_INVALID_SYNTAX;
        }
    }

    dwErr = SetMachine(szMachine, szUserName, szPassword);

    if (fFreePassword)
    {
        FREE(szPassword);
    }

    FREE(pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_TAG_ALREADY_PRESENT:
            PrintMessageFromModule(g_hModule, ERROR_TAG_ALREADY_PRESENT);
            return dwErr;

        default:
            return dwErr;
    }

    return dwErr;
}

extern HANDLE g_hLogFile;

DWORD
HandleSetFile(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    TAG_TYPE pttTags[] = {
				{TOKEN_MODE, TRUE, FALSE }, 
				{TOKEN_NAME, FALSE, FALSE }, 
				};
    DWORD    dwNumTags = sizeof(pttTags)/sizeof(TAG_TYPE);
    PDWORD   pdwTagType;
    DWORD    dwErr, dwNumArg, dwMode = -1, i;
    BOOL     bTmp;
	LPCWSTR  wszFileName = NULL;
	HANDLE   hLogFile = NULL;

    dwNumArg = dwArgCount - dwCurrentIndex;

    if ((!dwNumArg) || (dwNumArg > 2) || IsHelpToken(ppwcArguments[dwCurrentIndex]))
    {
        return ERROR_SHOW_USAGE;
    }

    pdwTagType = MALLOC(dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, 
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               pttTags,
                               dwNumTags,
                               pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        FREE(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }
        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // Mode
            {
                TOKEN_VALUE    rgEnums[] = {{TOKEN_VALUE_OPEN,  0},
                                            {TOKEN_VALUE_APPEND, 1},
                                            {TOKEN_VALUE_CLOSE, 2}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwMode);

                if (dwErr != NO_ERROR)
                {
                    PrintMessageFromModule( g_hModule,
                                    ERROR_INVALID_OPTION_VALUE,
                                    ppwcArguments[i + dwCurrentIndex],
                                    pttTags[pdwTagType[i]].pwszTag );

                    i = dwNumArg;

                    dwErr = ERROR_SHOW_USAGE;

                    break;
                }

                break;
            }
            case 1: // Name
            {
                wszFileName = ppwcArguments[i + dwCurrentIndex];
                break;
            }	
            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }

    FREE(pdwTagType);
    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_TAG_ALREADY_PRESENT:
            PrintMessageFromModule(g_hModule, ERROR_TAG_ALREADY_PRESENT);
            return dwErr;

        default:
            return dwErr;
    }

    switch(dwMode) 
	{
    case 0: // open
		if (!wszFileName)
			return ERROR_SHOW_USAGE;

		if (g_hLogFile)
		{
			CloseHandle(g_hLogFile);
			g_hLogFile = NULL;
		}

		hLogFile = CreateFile(wszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (INVALID_HANDLE_VALUE == hLogFile)
			return GetLastError();

		g_hLogFile = hLogFile;
        break;

	case 1: // append
		if (!wszFileName)
			return ERROR_SHOW_USAGE;

		if (g_hLogFile)
		{
			CloseHandle(g_hLogFile);
			g_hLogFile = NULL;
		}
	
		hLogFile = CreateFile(wszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (INVALID_HANDLE_VALUE == hLogFile)
			return GetLastError();

		if (INVALID_SET_FILE_POINTER == SetFilePointer(hLogFile, 0, NULL, FILE_END))
			return GetLastError();
		
		g_hLogFile = hLogFile;

		break;

    case 2: // close
        if (wszFileName)
			return ERROR_SHOW_USAGE;

		if (g_hLogFile)
		{
			CloseHandle(g_hLogFile);
			g_hLogFile = NULL;
		}
        break;
    }

    return dwErr;
}


DWORD
HandleSetMode(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    TAG_TYPE pttTags[] = {{TOKEN_MODE, TRUE, FALSE }};
    DWORD    dwNumTags = sizeof(pttTags)/sizeof(TAG_TYPE);
    PDWORD   pdwTagType;
    DWORD    dwErr, dwNumArg, dwMode, i;
    BOOL     bTmp;

    dwNumArg = dwArgCount - dwCurrentIndex;

    if ((dwNumArg != 1) || IsHelpToken(ppwcArguments[dwCurrentIndex]))
    {
        return ERROR_SHOW_USAGE;
    }

    pdwTagType = MALLOC(dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, 
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               pttTags,
                               dwNumTags,
                               pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        FREE(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }
        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // LOGLEVEL
            {
                TOKEN_VALUE    rgEnums[] = {{TOKEN_VALUE_ONLINE,  TRUE},
                                            {TOKEN_VALUE_OFFLINE, FALSE}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwMode);

                if (dwErr != NO_ERROR)
                {
                    PrintMessageFromModule( g_hModule,
                                    ERROR_INVALID_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    i = dwNumArg;

                    dwErr = ERROR_INVALID_PARAMETER;

                    break;
                }

                break;
            }

            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }


    FREE(pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_TAG_ALREADY_PRESENT:
            PrintMessageFromModule(g_hModule, ERROR_TAG_ALREADY_PRESENT);
            return dwErr;

        default:
            return dwErr;
    }

    switch(dwMode) {
    case TRUE: // set to online
        dwErr = CallCommit(NETSH_COMMIT, &bTmp);
        break;

    case FALSE: // set to offline
        dwErr = CallCommit(NETSH_UNCOMMIT, &bTmp);
        break;
    }

    return dwErr;
}

DWORD
HandleShellCommit(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_COMMIT, &bTmp);
            
    return NO_ERROR;
}

DWORD
HandleShellFlush(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_FLUSH, &bTmp);
            
    return NO_ERROR;
}

DWORD
HandleShellUnalias(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD dwNumArgs;
    DWORD dwRes = NO_ERROR;

    dwNumArgs = dwArgCount - dwCurrentIndex;

    //
    // Unalias Command
    //

    switch (dwNumArgs)
    {
        case 1 :

            dwRes = ATDeleteAlias(ppwcArguments[dwCurrentIndex]);

            if (dwRes is NO_ERROR)
            {
                dwRes = ERROR_OKAY;
                break;
            }

            PrintMessageFromModule(g_hModule, MSG_ALIAS_NOT_FOUND, ppwcArguments[dwCurrentIndex]);

            break;

        default :

            dwRes = ERROR_INVALID_SYNTAX;
            break;

    }

    return dwRes;
}

DWORD
HandleShellAlias(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    LPWSTR         pwszAliasString;
    WCHAR          wszAliasString[MAX_CMD_LEN];
    DWORD          i, dwNumArgs, dwRes = NO_ERROR;

    dwNumArgs = dwArgCount - dwCurrentIndex;

    //
    // An alias command
    //
    switch (dwNumArgs)
    {
        case 0 : 
            //
            // Display all aliases in use
            //
            PrintAliasTable();
            
            break;

        case 1 :
            //
            // Display string for given alias
            //

            ATLookupAliasTable(ppwcArguments[dwCurrentIndex], &pwszAliasString);

            if (pwszAliasString)
            {
                PrintMessage(L"%1!s!\n",pwszAliasString);
            }
            else
            {
                PrintMessageFromModule( g_hModule, 
                                MSG_ALIAS_NOT_FOUND,
                                ppwcArguments[dwCurrentIndex] );
            }
            
            break;

        default :

            //
            // Set alias
            //

            if (IsLocalCommand(ppwcArguments[dwCurrentIndex], 0))
            {
                PrintMessageFromModule(g_hModule, EMSG_ALIASING_KEYWORD);
                break;
            }

            wszAliasString[0] = L'\0';
            
            for ( i = dwCurrentIndex+1 ; i < dwArgCount ; i++)
            {
                wcscat(wszAliasString, ppwcArguments[i]);
                wcscat(wszAliasString,L" ");
            }

            wszAliasString[wcslen(wszAliasString)-1] = L'\0';

            dwRes = ATAddAlias(ppwcArguments[dwCurrentIndex], wszAliasString);

            if (dwRes is NO_ERROR)
            {
                dwRes = ERROR_OKAY;
                break;
            }
                    
            //
            // Error in set alias
            //

            PrintMessageFromModule(g_hModule, MSG_CMD_FAILED);

            break;
    }

    return dwRes;
}

DWORD
HandleUbiqDump(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD                          dwErr = NO_ERROR;
    PNS_HELPER_TABLE_ENTRY         pHelper;

    //
    // Dump Command
    //

    do {
        dwErr = DumpContext( g_CurrentContext, 
                             ppwcArguments, 
                             dwArgCount, 
                             pvData);

    } while (FALSE);

    return dwErr;
}

DWORD
HandleUbiqHelp(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD dwDisplayFlags = CMD_FLAG_PRIVATE;

    if (g_bInteractive)
    {
        dwDisplayFlags |= CMD_FLAG_INTERACTIVE;
    }
    
    return DisplayContextHelp( g_CurrentContext,
                               dwDisplayFlags,
                               dwFlags,
                               dwArgCount-2+1,
                               NULL );
}

DWORD
HandleShowMode(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    BOOL bTmp;

    CallCommit(NETSH_COMMIT_STATE, &bTmp);

    if (bTmp)
    {
        PrintMessage(CMD_COMMIT);
    }
    else
    {
        PrintMessage(CMD_UNCOMMIT);
    }
    PrintMessage(MSG_NEWLINE);

    return NO_ERROR;
}

DWORD
HandleShellUplevel(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    DWORD       dwRes;
    PLIST_ENTRY pleHead, ple;
    PARG_ENTRY  pae;

    // Convert current context to list
    dwRes = ConvertBufferToArgList(&pleHead, g_pwszContext);
    if (dwRes isnot NO_ERROR) 
    {
        return dwRes;
    }

    // Remove last element if more than two
    if (!IsListEmpty(pleHead) and (pleHead->Flink->Flink isnot pleHead))
    {
        // Delete the last element of the context list
        // (Try inheriting a command from one level up)

        ple = pleHead->Blink;
        pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
        if (pae->pwszArg)
            FREE(pae->pwszArg);
        RemoveEntryList(ple);
        FREE(pae);
    }

    // Convert back to buffer
    dwRes = ConvertArgListToBuffer(pleHead, g_pwszContext);

    FREE_ARG_LIST(pleHead);

    return NO_ERROR;
}

typedef struct {
    LIST_ENTRY le;
    WCHAR      wszBuffer[MAX_CMD_LEN];
} CONTEXT_BUFFER, *PCONTEXT_BUFFER;

LIST_ENTRY leContextStackHead;
BOOL bContextStackInit = FALSE;

VOID
InitContextStack()
{
    if (bContextStackInit)
        return;

    bContextStackInit = TRUE;

    InitializeListHead(&leContextStackHead);
}

DWORD
HandleShellPushd(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    PCONTEXT_BUFFER pcb;
    DWORD           dwErr = NO_ERROR;

    InitContextStack();

    // Malloc another buffer
    pcb = MALLOC(sizeof(CONTEXT_BUFFER));
    if (!pcb)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(pcb->wszBuffer, g_pwszContext);

    // Push buffer on stack
    InsertHeadList(&leContextStackHead, &pcb->le);

    if (dwArgCount > dwCurrentIndex)
    {
        LPWSTR pwszBuffer;

        // execute the rest of the arguments as a new command

        // Copy arg array to a buffer
        ConvertArgArrayToBuffer( dwArgCount - dwCurrentIndex, 
                                 ppwcArguments + dwCurrentIndex,
                                 &pwszBuffer );

        if (!pwszBuffer)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = ProcessCommand(pwszBuffer, pbDone);
        if (dwErr)
        {
            dwErr = ERROR_SUPPRESS_OUTPUT;
        }
        FREE(pwszBuffer);

        // XXX If the command failed, we probably want to set the
        // XXX current context to some NULL context so all commands fail
    }

    return dwErr;
}

DWORD
HandleShellPopd(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    LPCVOID   pvData,
    BOOL     *pbDone
    )
{
    PLIST_ENTRY ple;
    PCONTEXT_BUFFER pcb;

    InitContextStack();

    if (IsListEmpty(&leContextStackHead))
        return NO_ERROR;

    // Pop buffer off stack
    ple = leContextStackHead.Flink;
    pcb = CONTAINING_RECORD(ple, CONTEXT_BUFFER, le);
    RemoveEntryList(ple);

    // Copy buffer to current context
    wcscpy( g_pwszContext, pcb->wszBuffer );

    // Free buffer
    FREE(pcb);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <time.h>
#include <tchar.h>
#include <winsock2.h>
#include <memory.h>
#include <malloc.h>
#include <fltdefs.h>
#include <rtutils.h>
#include <mprerror.h>
#include <routprot.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <rtinfo.h>
#include <iprtinfo.h>
#include <priopriv.h>
#include <ipriprm.h>
#include <ipbootp.h>
#include <ospf_cfg.h>
#include <mprapi.h>
#include <nhapi.h>
#include <ipinfoid.h>
#include <ras.h>

#include <netsh.h>
#include <netshp.h>

#include "handle.h"

#include "strdefs.h"
#include "defs.h"
#include "reghlp.h"
#include "guidmap.h"
#include "alias.h"
#include "shell.h"
#include "utils.h"
#include "nsstring.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\reghlp.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    routing\netsh\shell\reghlp.c

Abstract:

    To get information about helper DLLs from registry.

Revision History:

    Anand Mahalingam          7/06/98  Created
    Dave Thaler              11/13/98  Revised

--*/

#include "precomp.h"

#define MALLOC(x)    HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x)      HeapFree(GetProcessHeap(), 0, (x))
#define DLL_INIT_FN        "InitHelperDll"
#define DLL_INIT_FN_NAME  L"InitHelperDll"
#define REG_KEY_NETSH_HELPER   L"SOFTWARE\\Microsoft\\NetSh"

PNS_HELPER_TABLE_ENTRY  g_CurrentHelper = NULL;
PCNS_CONTEXT_ATTRIBUTES g_CurrentContext = NULL;

/* fa85c48a-68d7-4a8c-891c-2360edc4d78 */
#define NETSH_NULL_GUID \
{ 0xfa85c48a, 0x68d7, 0x4a8c, {0x89, 0x1c, 0x23, 0x60, 0xed, 0xc4, 0xd7, 0x8} };

static const GUID g_NetshGuid = NETSH_ROOT_GUID;
static const GUID g_NullGuid  = NETSH_NULL_GUID;

//
// Initialize helper Table
//
PNS_HELPER_TABLE_ENTRY    g_HelperTable;
DWORD                     g_dwNumHelpers = 0;

PNS_DLL_TABLE_ENTRY       g_DllTable;
DWORD                     g_dwNumDlls = 0;

// This variable maintains the index of the Dll currently being called out to.
DWORD                     g_dwDllIndex;

DWORD WINAPI
RegisterContext(
    IN    CONST NS_CONTEXT_ATTRIBUTES *pChildContext
    );

DWORD
FindHelper(
    IN    CONST GUID  *pguidHelper,
    OUT   PDWORD       pdwIndex
    );

DWORD
GenericDeleteContext(
    IN PNS_HELPER_TABLE_ENTRY pParentHelper,
    IN DWORD                  dwContextIdx
    );

DWORD
CommitSubContexts(
    IN  PNS_HELPER_TABLE_ENTRY pHelper,
    IN  DWORD                  dwAction
    );

DWORD
WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    );

DWORD
UninstallDll(
    IN LPCWSTR pwszConfigDll,
    IN BOOL    fDeleteFromRegistry
    );

//
// Local copy of the commit state.
//

BOOL    g_bCommit = TRUE;

int __cdecl
ContextCmp(
    const void *a,
    const void *b
    )
{
    PCNS_CONTEXT_ATTRIBUTES pCA = (PCNS_CONTEXT_ATTRIBUTES)a;
    PCNS_CONTEXT_ATTRIBUTES pCB = (PCNS_CONTEXT_ATTRIBUTES)b;
    ULONG ulPriA = (pCA->dwFlags & CMD_FLAG_PRIORITY)? pCA->ulPriority : DEFAULT_CONTEXT_PRIORITY;
    ULONG ulPriB = (pCB->dwFlags & CMD_FLAG_PRIORITY)? pCB->ulPriority : DEFAULT_CONTEXT_PRIORITY;
        
    return ulPriA - ulPriB;
}

DWORD
DumpContext(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
{
    DWORD                  dwErr = NO_ERROR;
    PNS_HELPER_TABLE_ENTRY pChildHelper;

    do {
        if (pContext->pfnDumpFn)
        {
            dwErr = pContext->pfnDumpFn( g_pwszRouterName, 
                                         ppwcArguments, 
                                         dwArgCount, 
                                         pvData );
            if (dwErr)
            {
                break;
            }
        }

        // Dump child contexts (even if parent didn't have a dump function)

        dwErr = GetHelperEntry(&pContext->guidHelper, &pChildHelper);
        if (dwErr)
        {
            break;
        }

        dwErr = DumpSubContexts(pChildHelper, 
                                ppwcArguments, dwArgCount, pvData);
        if (dwErr)
        {
            break;
        }
    } while (FALSE);

    return NO_ERROR;
}

DWORD
DumpSubContexts(
    IN  PNS_HELPER_TABLE_ENTRY pHelper,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
{
    DWORD             i, dwSize,
                      dwErr = NO_ERROR;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    PBYTE             pSubContextTable;

    // Copy contexts for sorting
    dwSize =pHelper->ulNumSubContexts * pHelper->ulSubContextSize;
    pSubContextTable = MALLOC( dwSize );
    if (!pSubContextTable)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(pSubContextTable, pHelper->pSubContextTable, dwSize );

    // Sort copy of contexts by priority
    qsort(pSubContextTable, 
          pHelper->ulNumSubContexts, 
          pHelper->ulSubContextSize,
          ContextCmp);

    for (i = 0; i < pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pSubContextTable + i*pHelper->ulSubContextSize);

        dwErr = DumpContext( pSubContext, 
                             ppwcArguments, dwArgCount, pvData );
        if (dwErr)
        {
            break;
        }
    }

    // Free contexts for sorting
    FREE(pSubContextTable);

    return dwErr;
}

DWORD
CommitContext(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    IN  DWORD                   dwAction
    )
{
    DWORD                  dwErr = NO_ERROR;
    PNS_HELPER_TABLE_ENTRY pChildHelper;

    do {
        if (pContext->pfnCommitFn)
        {
            // No need to call connect since you cannot change machines in 
            // offline mode

            dwErr = pContext->pfnCommitFn(dwAction);
            if (dwErr)
            {
                break;
            }
        }

        // Commit child contexts (even if parent didn't have a commit function)

        dwErr = GetHelperEntry(&pContext->guidHelper, &pChildHelper);
        if (dwErr)
        {
            break;
        }

        dwErr = CommitSubContexts(pChildHelper, dwAction);
        if (dwErr)
        {
            break;
        }
    } while (FALSE);

    return NO_ERROR;
}

DWORD
CommitSubContexts(
    IN  PNS_HELPER_TABLE_ENTRY pHelper,
    IN  DWORD                  dwAction
    )
{
    DWORD             i, dwSize,
                      dwErr = NO_ERROR;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    PBYTE             pSubContextTable;

    // Copy contexts for sorting
    dwSize =pHelper->ulNumSubContexts * pHelper->ulSubContextSize;
    pSubContextTable = MALLOC( dwSize );
    if (!pSubContextTable)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(pSubContextTable, pHelper->pSubContextTable, dwSize );

    // Sort copy of contexts by priority
    qsort(pSubContextTable, 
          pHelper->ulNumSubContexts, 
          pHelper->ulSubContextSize,
          ContextCmp);

    for (i = 0; i < pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pSubContextTable + i*pHelper->ulSubContextSize);

        dwErr = CommitContext(pSubContext, dwAction);
        if (dwErr)
        {
            break;
        }
    }

    // Free contexts for sorting
    FREE(pSubContextTable);

    return dwErr;
}


DWORD
CallCommit(
    IN    DWORD    dwAction,
    OUT   BOOL     *pbCommit
    )
/*++

Routine Description:

    Calls commit for all the transports.

Arguments:

    dwAction - What to do. Could be one of COMMIT, UNCOMMIT, FLUSH,
               COMMIT_STATE

   pbCommit  - The current commit state.
   
Return Value:

    NO_ERROR
    
--*/
{
    DWORD               i, dwErr;
    PHELPER_ENTRY_FN    pfnEntry;
    PCNS_CONTEXT_ATTRIBUTES pContext, pSubContext;
    PNS_HELPER_TABLE_ENTRY         pHelper;
    
    switch (dwAction)
    {
        case NETSH_COMMIT_STATE :
            *pbCommit = g_bCommit;
            return NO_ERROR;
            
        case NETSH_COMMIT :
            g_bCommit = TRUE;
            break;
            
        case NETSH_UNCOMMIT :
            g_bCommit = FALSE;
            
        default :
            break;
    }

    //
    // Call commit for each sub context
    //

    dwErr = GetRootContext( &pContext, &pHelper );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = CommitContext( pContext, dwAction );
    if (dwErr isnot NO_ERROR)
    {
        PrintMessageFromModule(g_hModule, MSG_COMMIT_ERROR, 
                       pContext->pwszContext);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    return dwErr;
}

DWORD
FindHelper(
    IN    CONST GUID  *pguidHelper,
    OUT   PDWORD       pdwIndex
    )
{
    DWORD i;

    for (i=0; i<g_dwNumHelpers; i++)
    {
        if (!memcmp(pguidHelper,  &g_HelperTable[i].nha.guidHelper, sizeof(GUID)))
        {
            *pdwIndex = i;
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}
    
DWORD
AddHelper(
    IN    CONST GUID                  *pguidParent,
    IN    CONST NS_HELPER_ATTRIBUTES  *pAttributes
    )
{
    PNS_HELPER_TABLE_ENTRY phtTmp;

    //
    // Need to add entries in the helper table
    //
    
    phtTmp = MALLOC((g_dwNumHelpers + 1) * sizeof(NS_HELPER_TABLE_ENTRY));

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp, g_HelperTable,
               g_dwNumHelpers * sizeof(NS_HELPER_TABLE_ENTRY));

    CopyMemory(&phtTmp[g_dwNumHelpers], 
               pAttributes, 
               sizeof(NS_HELPER_ATTRIBUTES));

    CopyMemory(&phtTmp[g_dwNumHelpers].guidParent, pguidParent, sizeof(GUID));
    phtTmp[g_dwNumHelpers].dwDllIndex         = g_dwDllIndex;
    phtTmp[g_dwNumHelpers].bStarted           = FALSE;
    phtTmp[g_dwNumHelpers].ulSubContextSize   = sizeof(NS_CONTEXT_ATTRIBUTES);
    phtTmp[g_dwNumHelpers].ulNumSubContexts   = 0;
    phtTmp[g_dwNumHelpers].pSubContextTable   = (UINT_PTR)NULL;
        
    g_dwNumHelpers ++;
    
    FREE(g_HelperTable);
    g_HelperTable = phtTmp;
    
    return ERROR_SUCCESS;
}

DWORD
WINAPI
GenericDeregisterAllContexts(
    IN CONST GUID *pguidChild
    )
/*++
Description: 
    Remove all contexts registered by a given helper
--*/
{
    DWORD j, dwErr;
    PNS_HELPER_TABLE_ENTRY  pChildHelper, pParentHelper;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;

    dwErr = GetHelperEntry(pguidChild, &pChildHelper);
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GetHelperEntry(&pChildHelper->guidParent, &pParentHelper);
    if (dwErr)
    {
        return dwErr;
    }

    for (j=0; j<pParentHelper->ulNumSubContexts; j++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pParentHelper->pSubContextTable + j*pParentHelper->ulSubContextSize);

        if (!memcmp( &pSubContext->guidHelper, pguidChild, sizeof(GUID) ))
        {
            GenericDeleteContext(pParentHelper, j);
            j--;
        }
    }
    
    return dwErr;
}

DWORD
DeleteHelper(
    IN    DWORD dwHelperIdx
    )
{
    DWORD                  j, dwErr, dwParentIndex;
    PNS_HELPER_TABLE_ENTRY phtTmp = NULL;
    
    // Tell parent helper to 
    // uninstall all contexts for this helper

    dwErr = FindHelper(&g_HelperTable[dwHelperIdx].guidParent, &dwParentIndex);
    if (dwErr is NO_ERROR)
    {
        GenericDeregisterAllContexts(&g_HelperTable[dwHelperIdx].nha.guidHelper);
    }

    phtTmp = MALLOC((g_dwNumHelpers - 1) * sizeof(NS_HELPER_TABLE_ENTRY));

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp, 
               g_HelperTable,
               dwHelperIdx * sizeof(NS_HELPER_TABLE_ENTRY));

    CopyMemory(phtTmp + dwHelperIdx, 
               g_HelperTable + dwHelperIdx + 1,
               (g_dwNumHelpers - 1 - dwHelperIdx) 
                    * sizeof(NS_HELPER_TABLE_ENTRY));

    g_dwNumHelpers --;

    FREE(g_HelperTable);

    g_HelperTable = phtTmp;

    return ERROR_SUCCESS;
}

DWORD
GetHelperEntry(
    IN    CONST GUID             *pGuid,
    OUT   PNS_HELPER_TABLE_ENTRY *ppHelper
    )
{
    DWORD i, dwErr;

    dwErr = FindHelper(pGuid, &i);

    if (dwErr is NO_ERROR)
    {
        *ppHelper = &g_HelperTable[i];
    }

    return dwErr;
}

DWORD
GetDllEntry(
    IN    DWORD                dwDllIndex,
    OUT   PNS_DLL_TABLE_ENTRY *ppDll
    )
{
    *ppDll = &g_DllTable[ dwDllIndex ];

    return NO_ERROR;
}

DWORD
RegisterHelper(
    IN    CONST GUID                  *pguidParent,
    IN    CONST NS_HELPER_ATTRIBUTES  *pAttributes
    )
{
    DWORD i, dwErr;

    dwErr = FindHelper(&pAttributes->guidHelper, &i);

    if (dwErr is NO_ERROR)
    {
       return ERROR_HELPER_ALREADY_REGISTERED; 
    }
    
    //if pguidParent is NULL, the caller means the parent is netsh (g_NetshGuid)
    if (!pguidParent)
    {
        pguidParent = &g_NetshGuid;
    }
    
    // Make sure we don't cause a recursive registration.
    if (IsEqualGUID(&pAttributes->guidHelper, pguidParent))
    {
        if (! (IsEqualGUID(&pAttributes->guidHelper, &g_NullGuid) &&
               IsEqualGUID(pguidParent, &g_NullGuid) )  )
        {
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }
    }
    
    return AddHelper(pguidParent, pAttributes);
}

VOID
ConvertGuidToString(
    IN  CONST GUID *pGuid,
    OUT LPWSTR      pwszBuffer
    )
{
    wsprintf(pwszBuffer, L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        pGuid->Data1, pGuid->Data2, pGuid->Data3,
        pGuid->Data4[0], pGuid->Data4[1],
        pGuid->Data4[2], pGuid->Data4[3],
        pGuid->Data4[4], pGuid->Data4[5],
        pGuid->Data4[6], pGuid->Data4[7]);
}

DWORD
ConvertStringToGuid(
    IN  LPCWSTR  pwszGuid,
    IN  USHORT   usStringLen,
    OUT GUID    *pGuid
    )
{
    UNICODE_STRING  Temp;

    Temp.Length = Temp.MaximumLength = usStringLen;

    Temp.Buffer = (LPWSTR)pwszGuid;

    if(RtlGUIDFromString(&Temp, pGuid) isnot STATUS_SUCCESS)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

DWORD
LoadDll(
    DWORD dwIdx
    )
{
    HANDLE            hDll;
    DWORD             dwErr;
    PNS_DLL_INIT_FN   pfnLoadFn;
    NS_DLL_ATTRIBUTES DllTable;

    g_dwDllIndex = dwIdx;

    //
    // Try to load DLL into memory.
    //

    if (dwIdx is 0)
    {
        // Netsh internal helper
        hDll      = g_hModule;
        pfnLoadFn = InitHelperDll;
    }
    else
    {
        hDll = LoadLibraryW(g_DllTable[dwIdx].pwszDLLName);

        if (hDll is NULL)
        {
            PrintMessageFromModule( g_hModule, 
                            MSG_DLL_LOAD_FAILED,
                            g_DllTable[dwIdx].pwszDLLName );
                
            return ERROR_SUPPRESS_OUTPUT;
        }
        pfnLoadFn = (PNS_DLL_INIT_FN) GetProcAddress(hDll, DLL_INIT_FN);
    }

    if (!pfnLoadFn)
    {
        PrintMessageFromModule( g_hModule,  
                        EMSG_DLL_FN_NOT_FOUND, 
                        DLL_INIT_FN_NAME,
                        g_DllTable[dwIdx].pwszDLLName );
    
        FreeLibrary(hDll);

        g_DllTable[dwIdx].hDll = NULL;

        return ERROR_SUPPRESS_OUTPUT;
    }

    g_DllTable[dwIdx].hDll = hDll;

    memset(&DllTable, 0, sizeof(DllTable));
    dwErr = (pfnLoadFn)( NETSH_VERSION_50, &DllTable );

    if (dwErr == NO_ERROR)
    {
        g_DllTable[dwIdx].bLoaded   = TRUE;
        g_DllTable[dwIdx].pfnStopFn = DllTable.pfnStopFn;
    }
    else
    {
        PrintMessageFromModule( g_hModule, 
                        MSG_DLL_START_FAILED,
                        DLL_INIT_FN_NAME,
                        g_DllTable[dwIdx].pwszDLLName,
                        dwErr );

        UninstallDll(g_DllTable[dwIdx].pwszDLLName, FALSE);
    }
                        
    return NO_ERROR;
}

VOID
StartNewHelpers()

/*++
Description:
    Recursively start all unstarted helpers whose parent (if any) 
    is started.
--*/

{
    BOOL  bFound = FALSE;
    DWORD i, dwParentIndex, dwErr, dwVersion;

    // Mark root as started
    g_HelperTable[0].bStarted = TRUE;

    // Repeat until we couldn't find any helper to start
    do {
        bFound = FALSE;

        // Look for a startable helper
        for (i=0; i<g_dwNumHelpers; i++) 
        {
            if (g_HelperTable[i].bStarted)
                continue;

            dwErr = FindHelper(&g_HelperTable[i].guidParent, &dwParentIndex);
            if (dwErr isnot NO_ERROR)
            {
                continue;
            }

            if (!g_HelperTable[dwParentIndex].bStarted)
            {
                continue;
            }

            dwVersion          = NETSH_VERSION_50;

            bFound = TRUE;
            break;
        }

        if (bFound)
        {
            g_HelperTable[i].bStarted = TRUE;

            if (g_HelperTable[i].nha.pfnStart)
            {
                g_HelperTable[i].nha.pfnStart( &g_HelperTable[i].guidParent,
                                           dwVersion );
            }
        }

    } while (bFound);
}

DWORD
AddDllEntry(
    LPCWSTR pwszValueName,
    LPCWSTR pwszConfigDll
    )
{
    PNS_DLL_TABLE_ENTRY phtTmp = NULL;

#if (WINVER >= 0x0501)

    if ((_wcsicmp(pwszConfigDll, L"ipxmontr.dll") == 0) or
        (_wcsicmp(pwszConfigDll, L"ipxpromn.dll") == 0))
    {
        return ERROR_NOT_SUPPORTED;
    }
    
#endif

    //
    // Need to add entry in the dll table
    //
    
    phtTmp = MALLOC((g_dwNumDlls + 1) * sizeof(NS_DLL_TABLE_ENTRY));

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp, g_DllTable,
               g_dwNumDlls * sizeof(NS_DLL_TABLE_ENTRY));

    ZeroMemory(&phtTmp[g_dwNumDlls], sizeof(NS_DLL_TABLE_ENTRY));

    phtTmp[g_dwNumDlls].pwszValueName = MALLOC( (wcslen(pwszValueName) + 1)
                                        * sizeof(WCHAR));

    if (!phtTmp[g_dwNumDlls].pwszValueName)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(phtTmp[g_dwNumDlls].pwszValueName, pwszValueName);

    phtTmp[g_dwNumDlls].pwszDLLName = MALLOC( (wcslen(pwszConfigDll) + 1)
                                        * sizeof(WCHAR));

    if (!phtTmp[g_dwNumDlls].pwszDLLName)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(phtTmp[g_dwNumDlls].pwszDLLName, pwszConfigDll);

    _wcsupr(phtTmp[g_dwNumDlls].pwszDLLName);

    g_dwNumDlls ++;
    
    FREE(g_DllTable);
    g_DllTable = phtTmp;

    return LoadDll(g_dwNumDlls - 1);
}

DWORD
InstallDll(
    IN LPCWSTR pwszConfigDll
    )

/*++
Called by: HandleAddHelper()
--*/

{
    DWORD               i, dwErr;
    HKEY                hBaseKey;
    DWORD               dwResult = ERROR_SUCCESS;
    BOOL                bFound = FALSE;
    WCHAR               wcszKeyName[80];
    LPWSTR              p, q;
    LPWSTR              pwszConfigDllCopy;
    
    //
    // Check to see if the DLL is already present.
    //

    for (i = 0; i < g_dwNumDlls; i++)
    {
        if (_wcsicmp(g_DllTable[i].pwszDLLName, pwszConfigDll) == 0)
        {
            bFound = TRUE;
            break;
        }
    }

    do
    {
        if (bFound)
            break;

        //
        // Add the key to the registry
        //
        
        //
        // Create Base Key. If it already exists, fine.
        //

        dwResult = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                                   REG_KEY_NETSH_HELPER,
                                   0,
                                   L"STRING",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hBaseKey,
                                   NULL);
        
        if(dwResult != ERROR_SUCCESS)
        {
            break;
        }
        
        //
        // Add key for the Dll
        //

        pwszConfigDllCopy = _wcsdup(pwszConfigDll);
        if (!pwszConfigDllCopy)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        p = pwszConfigDllCopy;
        
        if ((q = wcsrchr(pwszConfigDllCopy, L'/')) isnot NULL)
        {
            p = q+1;
        }
        else if ((q = wcsrchr(pwszConfigDllCopy, L'\\')) isnot NULL)
        {
            p = q+1;
        }
        
        wcscpy(wcszKeyName, p);
        if ((p = wcsrchr(wcszKeyName, L'.')) isnot NULL)
        {
            *p = L'\0';
        }
        
        dwResult = RegSetValueExW(hBaseKey,
                                  wcszKeyName,
                                  0,
                                  REG_SZ,
                                  (PBYTE) pwszConfigDllCopy,
                                  (wcslen(pwszConfigDllCopy) + 1) * sizeof(WCHAR));
        
        RegCloseKey(hBaseKey);
        free(pwszConfigDllCopy);

    } while (FALSE);

    if (dwResult != ERROR_SUCCESS)
    {
        //
        // Could not install key successfully
        //

        PrintMessageFromModule(g_hModule, EMSG_INSTALL_KEY_FAILED, pwszConfigDll);
        return dwResult;
    }

    dwErr = AddDllEntry(wcszKeyName, pwszConfigDll);

    StartNewHelpers();
    
    return dwErr;
}

DWORD
UninstallDll(
    IN LPCWSTR pwszConfigDll,
    IN BOOL    fDeleteFromRegistry
    )
{
    DWORD               i, j;
    HKEY                hBaseKey;
    DWORD               dwResult = ERROR_SUCCESS;
    BOOL                bFound = FALSE;
    PNS_DLL_TABLE_ENTRY phtTmp = NULL;
    
    //
    // Check to see if the DLL is present.
    //

    for (i = 0; i < g_dwNumDlls; i++)
    {
        if (_wcsicmp(g_DllTable[i].pwszDLLName, pwszConfigDll) == 0)
        {
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        //
        // DLL to be uninstalled not found.
        //

        return ERROR_NOT_FOUND;
    }

    // Uninstall all helpers for this DLL

    for (j=0; j<g_dwNumHelpers; j++)
    {
        if (g_HelperTable[j].dwDllIndex is i)
        {
            DeleteHelper(j);
            j--;
        }
    }

    do
    {
        if (fDeleteFromRegistry)
        {
            //
            // Delete the key from registry
            //
            
            //
            // Open Base Key. 
            //
            dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                     REG_KEY_NETSH_HELPER,
                                     0,    
                                     KEY_ALL_ACCESS,
                                     &hBaseKey);
            
            if(dwResult != ERROR_SUCCESS)
            {
                break;
            }

            //
            // Delete key for the Dll
            //

            dwResult = RegDeleteValueW(hBaseKey,
                                       g_DllTable[i].pwszValueName);
            
            RegCloseKey(hBaseKey);
        }
    } while (FALSE);

    if (dwResult != ERROR_SUCCESS)
    {
        //
        // Could not uninstall key successfully
        //

        PrintMessageFromModule(g_hModule, 
                       EMSG_UNINSTALL_KEY_FAILED, 
                       pwszConfigDll);

        return dwResult;
    }

    //
    // Key succesfully deleted from registry. If a DLL table is currently
    // available, then reflect changes in it too.
    //

    FREE( g_DllTable[i].pwszDLLName );
    g_DllTable[i].pwszDLLName = NULL;
    FREE( g_DllTable[i].pwszValueName );
    g_DllTable[i].pwszValueName = NULL;

    phtTmp = MALLOC((g_dwNumDlls - 1) * sizeof(NS_DLL_TABLE_ENTRY));

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp, 
               g_DllTable,
               i * sizeof(NS_DLL_TABLE_ENTRY));

    CopyMemory(phtTmp + i, 
               g_DllTable + i + 1,
               (g_dwNumDlls - 1 - i) * sizeof(NS_DLL_TABLE_ENTRY));

    g_dwNumDlls --;

    // Update the DLL index in all helpers

    for (j=0; j<g_dwNumHelpers; j++)
    {
        if (g_HelperTable[j].dwDllIndex > i)
        {
            g_HelperTable[j].dwDllIndex--;
        }
    }

    //
    // Unload the dll if it was loaded
    //

    if (g_DllTable[i].bLoaded)
    {
#if 0
        if (pHelperTable[i].pfnUnInitFn)
            (pHelperTable[i].pfnUnInitFn)(0);
#endif

        FreeLibrary(g_DllTable[i].hDll);
    }
    
    FREE(g_DllTable);

    g_DllTable = phtTmp;

    return ERROR_SUCCESS;
}

VOID
LoadDllInfoFromRegistry(
    VOID
    )

/*++

Routine Description:

    Loads information about the helper DLLs from the registry.

Arguments:

Return Value:

--*/

{
    DWORD       dwResult, i, dwMaxValueLen, dwValueLen;
    DWORD       dwMaxValueNameLen, dwValueNameLen;
    DWORD       dwSize,dwType,dwNumDlls;
    FILETIME    ftLastTime;
    HKEY        hkeyDlls = NULL;
    LPWSTR      pwValue     = NULL;
    LPWSTR      pwValueName = NULL;

    do {

        //
        // Open Base Key
        //
        dwResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                 REG_KEY_NETSH_HELPER,
                                 0,
                                 KEY_READ,
                                 &hkeyDlls);
        
        if(dwResult != NO_ERROR)
        {
            break;
        }

        //
        // Get Number of DLLs
        //
        dwResult = RegQueryInfoKey(hkeyDlls,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &dwNumDlls,
                                   &dwMaxValueNameLen,
                                   &dwMaxValueLen,
                                   NULL,
                                   NULL);

    
        if(dwResult != NO_ERROR)
        {
            break;
        }
    
        if(dwNumDlls == 0)
        {
            //
            // Nothing registered
            //
            
            break;
        }
    
        //
        // Key len is in WCHARS
        //
    
        dwSize = dwMaxValueNameLen + 1;
        
        pwValueName = HeapAlloc(GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                dwSize * sizeof(WCHAR));
    
        if(pwValueName is NULL)
        {
            PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
            
            break;
        }

        dwSize = dwMaxValueLen + 1;

        pwValue = HeapAlloc(GetProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            dwSize);
    
        if(pwValue is NULL)
        {
            FREE(pwValueName);
    
            PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
    
            break;
        }

        for(i = 0; i < dwNumDlls; i++)
        {
            dwValueLen = dwMaxValueLen + 1;
    
            dwValueNameLen = dwMaxValueNameLen + 1;
    
            dwResult = RegEnumValueW(hkeyDlls,
                                     i,
                                     pwValueName,
                                     &dwValueNameLen,
                                     NULL,
                                     NULL,
                                     (PBYTE)pwValue,
                                     &dwValueLen);
    
            if(dwResult isnot NO_ERROR)
            {
                if(dwResult is ERROR_NO_MORE_ITEMS)
                {
                    //
                    // Done
                    //
    
                    break;
                }
    
                continue;
            }
    
            dwResult = AddDllEntry(pwValueName, pwValue);
        }
    } while (FALSE);

    if (hkeyDlls)
    {
        RegCloseKey(hkeyDlls);
    }

    if (pwValueName)
    {
        FREE(pwValueName);
    }

    if (pwValue)
    {
        FREE(pwValue);
    }
    
    StartNewHelpers();

    return;
}

DWORD
GetContextEntry(
    IN    PNS_HELPER_TABLE_ENTRY   pHelper,
    IN    LPCWSTR                  pwszContext,
    OUT   PCNS_CONTEXT_ATTRIBUTES *ppContext
    )
{
    DWORD k;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;

    for ( k = 0 ; k < pHelper->ulNumSubContexts ; k++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pHelper->pSubContextTable + k*pHelper->ulSubContextSize);

        if (MatchToken(pwszContext, pSubContext->pwszContext))
        {
            *ppContext = (PCNS_CONTEXT_ATTRIBUTES)pSubContext;
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

DWORD
FreeHelpers(
    VOID
    )
{
    DWORD    i;

    for (i = 0; i < g_dwNumHelpers; i++)
    {
        if (g_HelperTable[i].nha.pfnStop)
            (g_HelperTable[i].nha.pfnStop)(0);

    }

    FREE(g_HelperTable);

    return NO_ERROR;
}

DWORD
FreeDlls(
    VOID
    )
{
    DWORD    i;

    for (i = 0; i < g_dwNumDlls; i++)
    {
        if (g_DllTable[i].bLoaded)
        {
            FreeLibrary(g_DllTable[i].hDll);
        }
    }

    FREE(g_DllTable);

    return NO_ERROR;
}

DWORD
ShowHelpers(
    PNS_HELPER_TABLE_ENTRY pHelper,
    DWORD                  dwLevel
    )
{
    DWORD    i, dwDllIndex, dwErr = NO_ERROR, j;
    WCHAR    rgwcHelperGuid[MAX_NAME_LEN];
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    PNS_HELPER_TABLE_ENTRY  pChildHelper;

    for (i = 0; i < pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pHelper->pSubContextTable + i*pHelper->ulSubContextSize);

        dwErr = GetHelperEntry( &pSubContext->guidHelper, &pChildHelper );
        if (dwErr)
        {
            return dwErr;
        }

        ConvertGuidToString(&pSubContext->guidHelper, 
                            rgwcHelperGuid);

        dwDllIndex = pChildHelper->dwDllIndex;

        PrintMessageFromModule( g_hModule, 
                        MSG_SHOW_HELPER_INFO,
                        rgwcHelperGuid,
                        g_DllTable[dwDllIndex].pwszDLLName );

        for (j=0; j<dwLevel; j++)
        {
            PrintMessageFromModule(g_hModule, MSG_SHOW_HELPER_INFO1);
        }

        PrintMessageFromModule( g_hModule, 
                        MSG_SHOW_HELPER_INFO2, 
                        pSubContext->pwszContext );

        dwErr = ShowHelpers( pChildHelper, dwLevel+1 );
    }

    return dwErr;
}

DWORD
HandleShowHelper(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD    i, dwHelperIdx, dwDllIndex, dwErr = NO_ERROR;
    WCHAR    rgwcHelperGuid[MAX_NAME_LEN];
    PNS_HELPER_TABLE_ENTRY pHelper = g_CurrentHelper;
    PCNS_CONTEXT_ATTRIBUTES pContext;
    WCHAR    rgwcParentGuid[MAX_NAME_LEN];
    BOOL     bFound;

    dwErr = GetRootContext(&pContext, &pHelper);
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    PrintMessageFromModule(g_hModule, MSG_SHOW_HELPER_HDR);

    ShowHelpers(pHelper, 0);

    // Show orphaned DLLs
    for (bFound=FALSE,i=0; i<g_dwNumDlls; i++)
    {
        if (!g_DllTable[i].bLoaded)
        {
            if (!bFound)
            {
                PrintMessageFromModule( g_hModule, MSG_SHOW_HELPER_DLL_HDR );
                bFound = TRUE;
            }

            PrintMessage( L"%1!s!\n", g_DllTable[i].pwszDLLName );
        }
    }

    // Show orphaned helpers
    for (bFound=FALSE,i=0; i<g_dwNumHelpers; i++)
    {
        if (!g_HelperTable[i].bStarted)
        {
            ConvertGuidToString(&g_HelperTable[i].nha.guidHelper,
                                rgwcHelperGuid);

            ConvertGuidToString(&g_HelperTable[i].guidParent,
                                rgwcParentGuid);
            
            if (!bFound)
            {
                PrintMessageFromModule( g_hModule, MSG_SHOW_HELPER_ORPHAN_HDR );
                bFound = TRUE;
            }

            PrintMessageFromModule(g_hModule, 
                           MSG_SHOW_HELPER_ORPHAN_INFO,
                           rgwcHelperGuid,
                           g_DllTable[g_HelperTable[i].dwDllIndex].pwszDLLName,
                           rgwcParentGuid);
        }
    }

    return NO_ERROR;
}

DWORD
HandleAddHelper(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Installs a helper under the shell

Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr;

    if (dwArgCount-dwCurrentIndex != 1
      ||  IsHelpToken(ppwcArguments[dwCurrentIndex]))
    {
        //
        // Install requires only the dll name
        //

        return ERROR_INVALID_SYNTAX;
    }

#if 0
    if(IsReservedKeyWord(ppwcArguments[dwCurrentIndex]))
    {
        PrintMessageFromModule(g_hModule, EMSG_RSVD_KEYWORD,
                       ppwcArguments[dwCurrentIndex]);

        return ERROR_INVALID_PARAMETER;
    }
#endif

    dwErr = InstallDll(ppwcArguments[dwCurrentIndex]);

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
    {
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    if (dwErr is ERROR_SUCCESS)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;
}

DWORD
HandleDelHelper(
    LPCWSTR   pwszMachine,
    LPWSTR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )

/*++

Routine Description:

    Removes a helper from under the Shell

Arguments:


Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr;

    if (dwArgCount-dwCurrentIndex != 1)
    {
        //
        // Uninstall requires name of helper
        //

        return ERROR_INVALID_SYNTAX;
    }

    dwErr = UninstallDll(ppwcArguments[dwCurrentIndex], TRUE);

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
    {
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
    }

    if (dwErr is ERROR_SUCCESS)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;
}

DWORD
GenericDeleteContext(
    IN PNS_HELPER_TABLE_ENTRY pParentHelper,
    IN DWORD                  dwContextIdx
    )
{
    DWORD  dwResult = ERROR_SUCCESS;
    PBYTE  phtTmp = NULL;

    phtTmp = MALLOC((pParentHelper->ulNumSubContexts - 1) 
                * pParentHelper->ulSubContextSize);

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(phtTmp,
               pParentHelper->pSubContextTable,
               dwContextIdx * pParentHelper->ulSubContextSize);

    CopyMemory(phtTmp + dwContextIdx * pParentHelper->ulSubContextSize,
               pParentHelper->pSubContextTable + (dwContextIdx + 1) * pParentHelper->ulSubContextSize,
               (pParentHelper->ulNumSubContexts - 1 - dwContextIdx)
                    * pParentHelper->ulSubContextSize);

    pParentHelper->ulNumSubContexts --;

    FREE(pParentHelper->pSubContextTable);

    pParentHelper->pSubContextTable = phtTmp;

    return ERROR_SUCCESS;
}

DWORD
GenericFindContext(
    IN    PNS_HELPER_TABLE_ENTRY         pParentHelper,
    IN    LPCWSTR                        pwszContext,
    OUT   PDWORD                         pdwIndex
    )
{
    DWORD i;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;

    for (i=0; i<pParentHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pParentHelper->pSubContextTable + i*pParentHelper->ulSubContextSize);

        if (!_wcsicmp(pwszContext, pSubContext->pwszContext))
        {
            *pdwIndex = i;

            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

DWORD
GenericAddContext(
    IN    PNS_HELPER_TABLE_ENTRY  pParentHelper,
    IN    PCNS_CONTEXT_ATTRIBUTES pChildContext
    )
{
    PBYTE phtTmp;
    DWORD i;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;

    // Find where in the table the new entry should go
    for (i=0; i<pParentHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
         (pParentHelper->pSubContextTable + i*pParentHelper->ulSubContextSize);

        if (_wcsicmp(pChildContext->pwszContext, pSubContext->pwszContext) < 0)
        {
            break;
        }
    }

    //
    // Need to add entries in the context table
    //
    phtTmp = MALLOC((pParentHelper->ulNumSubContexts + 1) * 
                pParentHelper->ulSubContextSize );

    if (phtTmp is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Copy all contexts which come before the new one

    if (i > 0)
    {
        CopyMemory(phtTmp, pParentHelper->pSubContextTable,
                   i * pParentHelper->ulSubContextSize);
    }

    CopyMemory(phtTmp + i*pParentHelper->ulSubContextSize, 
               pChildContext, pParentHelper->ulSubContextSize);

    // Copy any contexts which come after the new one
    if (i < pParentHelper->ulNumSubContexts)
    {
        CopyMemory(phtTmp + (i+1)*pParentHelper->ulSubContextSize, 
            pParentHelper->pSubContextTable + i*pParentHelper->ulSubContextSize,
            (pParentHelper->ulNumSubContexts - i) 
             * pParentHelper->ulSubContextSize);
    }

    (pParentHelper->ulNumSubContexts) ++;

    FREE(pParentHelper->pSubContextTable);
    pParentHelper->pSubContextTable = phtTmp;

    return ERROR_SUCCESS;
}

DWORD WINAPI
RegisterContext(
    IN    CONST NS_CONTEXT_ATTRIBUTES *pChildContext
    )
{
    DWORD dwErr, i;
    PNS_HELPER_TABLE_ENTRY pParentHelper;
    CONST GUID            *pguidParent;
    ULONG nGroups, nSubGroups;

    if (!pChildContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (!pChildContext->pwszContext) ||
         (wcslen(pChildContext->pwszContext) == 0) ||
         (wcschr(pChildContext->pwszContext, L' ') != 0) || 
         (wcschr(pChildContext->pwszContext, L'=') != 0) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    for (nGroups = 0; nGroups < pChildContext->ulNumTopCmds; nGroups++)
    {
        CMD_ENTRY *cmd = &((*pChildContext->pTopCmds)[nGroups]);
        if ( (!cmd->pwszCmdToken) || 
             (wcslen(cmd->pwszCmdToken) == 0) ||
             (wcschr(cmd->pwszCmdToken, L' ') != 0) || 
             (wcschr(cmd->pwszCmdToken, L'=') != 0) )
        {
            PrintMessageFromModule(g_hModule, MSG_INVALID_TOPLEVEL_CMD, cmd->pwszCmdToken);
            ASSERT(FALSE);
        }
    }

    for (nGroups = 0; nGroups < pChildContext->ulNumGroups; nGroups++)
    {
        CMD_GROUP_ENTRY *grpCmd = &((*pChildContext->pCmdGroups)[nGroups]);
        if ( (!grpCmd->pwszCmdGroupToken) || 
             (wcslen(grpCmd->pwszCmdGroupToken) == 0) ||
             (wcschr(grpCmd->pwszCmdGroupToken, L' ') != 0) || 
             (wcschr(grpCmd->pwszCmdGroupToken, L'=') != 0) )
        {
            PrintMessageFromModule(g_hModule, MSG_INVALID_CMD_GROUP, grpCmd->pwszCmdGroupToken);
            ASSERT(FALSE);
        }

        for (nSubGroups = 0; nSubGroups < grpCmd->ulCmdGroupSize; nSubGroups++)
        {
            CMD_ENTRY *cmd = &((grpCmd->pCmdGroup)[nSubGroups]);
            if ( (!cmd->pwszCmdToken) || 
                 (wcslen(cmd->pwszCmdToken) == 0) ||
                 (wcschr(cmd->pwszCmdToken, L' ') != 0) || 
                 (wcschr(cmd->pwszCmdToken, L'=') != 0) )
            {
                PrintMessageFromModule(g_hModule, MSG_INVALID_CMD, cmd->pwszCmdToken);
                ASSERT(FALSE);
            }

        }
    }

    // Get parent guid from child guid
    dwErr = FindHelper( &pChildContext->guidHelper, &i );
    if (dwErr)
    {
        return dwErr;
    }
    pguidParent = &g_HelperTable[i].guidParent;

    dwErr = GetHelperEntry( pguidParent, &pParentHelper );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GenericFindContext(pParentHelper, pChildContext->pwszContext, &i);
    if (dwErr is NO_ERROR)
    {
        CopyMemory( pParentHelper->pSubContextTable + i*pParentHelper->ulSubContextSize, 
                    pChildContext,
                    pParentHelper->ulSubContextSize );

        return NO_ERROR;
    }

    return GenericAddContext( pParentHelper, pChildContext );
}

DWORD
WINAPI
GetHostMachineInfo(
    IN OUT UINT     *puiCIMOSType,                   // WMI: Win32_OperatingSystem  OSType
    IN OUT UINT     *puiCIMOSProductSuite,           // WMI: Win32_OperatingSystem  OSProductSuite
    IN OUT LPWSTR   pszCIMOSVersion,                 // WMI: Win32_OperatingSystem  Version
    IN OUT LPWSTR   pszCIMOSBuildNumber,             // WMI: Win32_OperatingSystem  BuildNumber
    IN OUT LPWSTR   pszCIMServicePackMajorVersion,   // WMI: Win32_OperatingSystem  ServicePackMajorVersion
    IN OUT LPWSTR   pszCIMServicePackMinorVersion,   // WMI: Win32_OperatingSystem  ServicePackMinorVersion
    IN OUT UINT     *puiCIMProcessorArchitecture)    // WMI: Win32_Processor        Architecture
{
    if (!g_CIMSucceeded)
        return ERROR_HOST_UNREACHABLE;

    if (puiCIMOSType)
        *puiCIMOSType         = g_CIMOSType;

    if (puiCIMOSProductSuite)
        *puiCIMOSProductSuite = g_CIMOSProductSuite;

    if (puiCIMProcessorArchitecture)
        *puiCIMProcessorArchitecture = g_CIMProcessorArchitecture;

    if (pszCIMOSVersion)
        wcsncpy(pszCIMOSVersion, g_CIMOSVersion, MAX_PATH);

    if (pszCIMOSBuildNumber)
        wcsncpy(pszCIMOSBuildNumber, g_CIMOSBuildNumber, MAX_PATH);

    if (pszCIMServicePackMajorVersion)
        wcsncpy(pszCIMServicePackMajorVersion, g_CIMServicePackMajorVersion, MAX_PATH);

    if (pszCIMServicePackMinorVersion)
        wcsncpy(pszCIMServicePackMinorVersion, g_CIMServicePackMinorVersion, MAX_PATH);

    return NO_ERROR;
}

BOOL VerifyOsVersion(IN PNS_OSVERSIONCHECK pfnVersionCheck)
{
    DWORD dwRetVal;
    if (!pfnVersionCheck)
    {
        return TRUE;
    }
    else
    {
        if (g_CIMSucceeded)
        {
            dwRetVal = pfnVersionCheck(
                g_CIMOSType, 
                g_CIMOSProductSuite, 
                g_CIMOSVersion, 
                g_CIMOSBuildNumber, 
                g_CIMServicePackMajorVersion, 
                g_CIMServicePackMinorVersion, 
                g_CIMProcessorArchitecture,
                0);

            return dwRetVal;
        }
        else
        {
            return FALSE;
        }
    }
}
DWORD WINAPI
GenericMonitor(
    IN      const NS_CONTEXT_ATTRIBUTES   *pGenericContext,
    IN      LPCWSTR                        pwszMachine,
    IN OUT  LPWSTR                        *ppwcArguments,
    IN      DWORD                          dwArgCount,
    IN      DWORD                          dwFlags,
    IN      LPCVOID                        pvData,
    OUT     LPWSTR                         pwcNewContext
    )
{
    DWORD       dwErr = NO_ERROR, dwIndex, i, j;
    BOOL        bFound = FALSE;
    DWORD       dwNumMatched;
    DWORD       dwCmdHelpToken;
    LPCWSTR     pwszCmdToken;
    PNS_DLL_TABLE_ENTRY            pDll;
    PNS_HELPER_TABLE_ENTRY         pHelper;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    PCNS_CONTEXT_ATTRIBUTES pContext = pGenericContext;

    GetHelperEntry( &pContext->guidHelper, &pHelper);

    GetDllEntry( pHelper->dwDllIndex, &pDll);

    g_CurrentContext = pContext;
    g_CurrentHelper  = pHelper;

    if (pContext->pfnConnectFn)
    {
        dwErr = pContext->pfnConnectFn(pwszMachine);
        if (dwErr)
        {
            PrintError(NULL, dwErr);
            return ERROR_SUPPRESS_OUTPUT;
        }
    }

    //
    // See if command is a context switch.
    //

    if (dwArgCount is 1)
    {
        UpdateNewContext(pwcNewContext,
                         pContext->pwszContext,
                         dwArgCount);

        return ERROR_CONTEXT_SWITCH;
    }

    // 
    // See if the command is a ubiquitous command
    //
    for (i=0; i<g_ulNumUbiqCmds; i++)
    {
        if (g_UbiqCmds[i].dwFlags & ~dwFlags)
        {
            continue;
        }

        if (MatchToken(ppwcArguments[1],
                      g_UbiqCmds[i].pwszCmdToken))
        {
            if (!VerifyOsVersion(g_UbiqCmds[i].pOsVersionCheck))
            {
                continue;
            }

            dwErr = GetHelperEntry( &g_NetshGuid, &pHelper );
            GetDllEntry( pHelper->dwDllIndex, &pDll);
            
            return ExecuteHandler( pDll->hDll,
                                   &g_UbiqCmds[i],
                                   ppwcArguments,
                                   2,
                                   dwArgCount,
                                   dwFlags,
                                   pvData, 
                                   NULL,
                                   &g_bDone );
        }
    }

    //
    // See if the command is a top level (non group) command
    //

    for(i = 0; i < pContext->ulNumTopCmds; i++)
    {
        // If the command does not match the current display requirements, 
        // don't execute it EXCEPT in the case of a hidden cmd. we still
        // want to execute those.
        //
        if (((*pContext->pTopCmds)[i].dwFlags & ~dwFlags) &&
            ((*pContext->pTopCmds)[i].dwFlags & ~CMD_FLAG_HIDDEN)
           )
        {
            continue;
        }

        if (MatchToken(ppwcArguments[1],
                      (*pContext->pTopCmds)[i].pwszCmdToken))
        {
            if (!VerifyOsVersion( (*pContext->pTopCmds)[i].pOsVersionCheck) )
            {
                continue;
            }
            
            return ExecuteHandler( pDll->hDll,
                                   &(*pContext->pTopCmds)[i],
                                   ppwcArguments,
                                   2,
                                   dwArgCount,
                                   dwFlags,
                                   pvData,
                                   NULL,
                                   &g_bDone );
        }
    }

    //
    // Check to see if it is meant for one of the
    // helpers under it.
    //

    for (i=0; i<pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
            (pHelper->pSubContextTable + i*pHelper->ulSubContextSize);

        if (pSubContext->dwFlags & ~dwFlags)
        {
            continue;
        }


        if (!VerifyOsVersion(pSubContext->pfnOsVersionCheck))
        {
            continue;
        }

        if (MatchToken( ppwcArguments[1], 
                         pSubContext->pwszContext))
        {
            dwIndex = i;
            bFound = TRUE;

            break;
        }
    }

    if (bFound)
    {
        PNS_PRIV_CONTEXT_ATTRIBUTES pNsPrivContextAttributes;
        PNS_PRIV_CONTEXT_ATTRIBUTES pNsPrivSubContextAttributes;

        //
        // Intended for one of the helpers under this one
        // Pass on the command to the helper
        //

        UpdateNewContext(pwcNewContext,
                         pSubContext->pwszContext,
                         dwArgCount - 1);

        //
        // Call entry point of the helper.
        //
        pNsPrivContextAttributes    = pContext->pReserved;
        pNsPrivSubContextAttributes = pSubContext->pReserved;
        if ( (pNsPrivContextAttributes) && (pNsPrivContextAttributes->pfnSubEntryFn) )
        {
            dwErr = (*pNsPrivContextAttributes->pfnSubEntryFn)(
                                        pSubContext,
                                        pwszMachine,
                                        ppwcArguments + 1,
                                        dwArgCount - 1,
                                        dwFlags,
                                        NULL,
                                        pwcNewContext);
        }
        else 
        {
            if ( (!pNsPrivSubContextAttributes) || (!pNsPrivSubContextAttributes->pfnEntryFn) )
            {
                dwErr = GenericMonitor( pSubContext,
                                        pwszMachine,
                                        ppwcArguments + 1,
                                        dwArgCount - 1,
                                        dwFlags,
                                        NULL,
                                        pwcNewContext);
            }
            else
            {
                dwErr = (pNsPrivSubContextAttributes->pfnEntryFn)( 
                                   pwszMachine,
                                   ppwcArguments + 1,
                                   dwArgCount - 1,
                                   dwFlags,
                                   NULL,
                                   pwcNewContext);
            }
        }

        return dwErr;
    }

    //
    // It is a command group 
    //

    bFound = FALSE;

    for(i = 0; i < pContext->ulNumGroups; i++)
    {
        if ((*pContext->pCmdGroups)[i].dwFlags & ~dwFlags)
        {
            continue;
        }
        
        if (MatchToken(ppwcArguments[1],
                      (*pContext->pCmdGroups)[i].pwszCmdGroupToken))
        {
            LPCWSTR pwszCmdGroupToken = (*pContext->pCmdGroups)[i].pwszCmdGroupToken;

            if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pOsVersionCheck))
            {
                continue;
            }
            
            // See if it's a request for help

            if ((dwArgCount<3) || IsHelpToken(ppwcArguments[2]))
            {
                return DisplayContextHelp( 
                            pContext,
                            CMD_FLAG_PRIVATE,
                            dwFlags,
                            dwArgCount-2+1,
                            (*pContext->pCmdGroups)[i].pwszCmdGroupToken );
            }

            //
            // Command matched entry i, so look at the table of sub commands
            // for this command
            //

            for (j = 0; j < (*pContext->pCmdGroups)[i].ulCmdGroupSize; j++)
            {
                // If the command does not match the current display requirements, 
                // don't execute it EXCEPT in the case of a hidden cmd. we still
                // want to execute those.
                //
                if (((*pContext->pCmdGroups)[i].pCmdGroup[j].dwFlags & ~dwFlags) &&
                    ((*pContext->pCmdGroups)[i].pCmdGroup[j].dwFlags & ~CMD_FLAG_HIDDEN)
                   )
                {
                    continue;
                }

                if (MatchCmdLine(ppwcArguments + 2,
                                  dwArgCount - 1,
                                  (*pContext->pCmdGroups)[i].pCmdGroup[j].pwszCmdToken,
                                  &dwNumMatched))
                {
                    if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pCmdGroup[j].pOsVersionCheck))
                    {
                        continue;
                    }
                    
                    return ExecuteHandler( pDll->hDll,
                                           &(*pContext->pCmdGroups)[i].pCmdGroup[j],
                                           ppwcArguments,
                                           dwNumMatched + 2,
                                           dwArgCount,
                                           dwFlags,
                                           pvData,
                                           pwszCmdGroupToken, // the command group name
                                           &g_bDone );
                }
            }

            return ERROR_CMD_NOT_FOUND;
        }
    }

    return ERROR_CMD_NOT_FOUND;
}

DWORD
WINAPI
NetshStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
//  ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext   = L"netsh";
    attMyAttributes.guidHelper    = g_NetshGuid;
    attMyAttributes.dwVersion     = 1;
    attMyAttributes.dwFlags       = 0;
    attMyAttributes.ulNumTopCmds  = g_ulNumShellCmds;
    attMyAttributes.pTopCmds      = (CMD_ENTRY (*)[])&g_ShellCmds;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_ShellCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    NS_HELPER_ATTRIBUTES attMyAttributes;

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper = g_NullGuid;
    attMyAttributes.dwVersion  = 1;
    RegisterHelper( &g_NullGuid, &attMyAttributes );

    attMyAttributes.guidHelper = g_NetshGuid;
    attMyAttributes.dwVersion  = 1;
    attMyAttributes.pfnStart   = NetshStartHelper;
    RegisterHelper( &g_NullGuid, &attMyAttributes );

    return NO_ERROR;
}

DWORD
GetRootContext(
    OUT PCNS_CONTEXT_ATTRIBUTES *ppContext,
    OUT PNS_HELPER_TABLE_ENTRY *ppHelper
    )
{
    PCNS_CONTEXT_ATTRIBUTES pContext;
    DWORD                  dwErr, k;
    PNS_HELPER_TABLE_ENTRY pNull;

    dwErr = GetHelperEntry( &g_NetshGuid, ppHelper );

    dwErr = GetHelperEntry( &g_NullGuid, &pNull );

    for ( k = 0 ; k < pNull->ulNumSubContexts ; k++)
    {
        pContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pNull->pSubContextTable + k*pNull->ulSubContextSize);

        if (memcmp( &g_NetshGuid, &pContext->guidHelper, sizeof(GUID) ))
        {
            continue;
        }

        *ppContext = pContext;
        return NO_ERROR;
    }

    return dwErr;
}

DWORD
GetParentContext( 
    IN  PCNS_CONTEXT_ATTRIBUTES  pChildContext, 
    OUT PCNS_CONTEXT_ATTRIBUTES *ppParentContext
    )
{
    DWORD                   dwErr, k;
    PNS_HELPER_TABLE_ENTRY  pChild, pParent, pGrandParent;
    PCNS_CONTEXT_ATTRIBUTES  pParentContext;

    // For now, just pick the first context in the parent helper
    // To do this, we need to look through the grandparent's subcontexts

    dwErr = GetHelperEntry( &pChildContext->guidHelper, &pChild );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GetHelperEntry( &pChild->guidParent, &pParent );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GetHelperEntry( &pParent->guidParent, &pGrandParent );
    if (dwErr)
    {
        return dwErr;
    }

    for ( k = 0 ; k < pGrandParent->ulNumSubContexts ; k++)
    {
        pParentContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pGrandParent->pSubContextTable + k*pGrandParent->ulSubContextSize);

        if (memcmp( &pChild->guidParent, 
                    &pParentContext->guidHelper, 
                    sizeof(GUID) ))
        {
            continue;
        }

        *ppParentContext = pParentContext;
        return NO_ERROR;
    }

    return ERROR_NOT_FOUND;
}

DWORD
AppendFullContextName(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    OUT LPWSTR                *ppwszContextName
    )
{
    DWORD                  dwErr;
    PCNS_CONTEXT_ATTRIBUTES pParent;

    dwErr = GetParentContext(pContext, &pParent);
    if (dwErr is NO_ERROR)
    {
        dwErr = AppendFullContextName(pParent, ppwszContextName);
        if (dwErr)
        {
            return dwErr;
        }
    }

    if (*ppwszContextName)
    {
       AppendString(ppwszContextName, L" ");
    }

    dwErr = AppendString(ppwszContextName, pContext->pwszContext);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\strdefs.h ===
#define MSG_NULL                                  1
#define MSG_OKAY                                  2

#define MSG_ALIAS_NOT_FOUND                     100
#define MSG_CMD_FAILED                          101
#define MSG_NOT_ENOUGH_MEMORY                   104
#define MSG_SUBCONTEXT_LIST                     105
#define MSG_DLL_LOAD_FAILED                     106
#define MSG_HELP_FOOTER                         107
#define MSG_OPEN_FAILED                         108
#define MSG_COMMIT_ERROR                        109
#define MSG_NETSH_USAGE                         110
#define MSG_GLOBAL_COMMANDS                     111
#define MSG_INHERITED_COMMANDS                  112
#define MSG_LOCAL_COMMANDS                      113
#define HLP_ALIAS                               114
#define HLP_ALIAS_EX                            115
#define HLP_UNALIAS                             116
#define HLP_UNALIAS_EX                          117
#define HLP_COMMIT                              118 
#define HLP_COMMIT_EX                           119 
#define HLP_UNCOMMIT                            120 
#define HLP_UNCOMMIT_EX                         121 
#define HLP_SAVE                                122
#define HLP_SAVE_EX                             123
#define HLP_LOAD                                124
#define HLP_LOAD_EX                             125
#define HLP_SHOW_HELPER                         127
#define HLP_SHOW_HELPER_EX                      128
#define HLP_ADD_HELPER                          129
#define HLP_ADD_HELPER_EX                       130
#define HLP_DEL_HELPER                          131
#define HLP_DEL_HELPER_EX                       132
#define HLP_FLUSH                               133
#define HLP_FLUSH_EX                            134
#define MSG_SHELL_CMD_HELP_HEADER               135
#define MSG_DLL_START_FAILED                    136
#define MSG_HELPER_HELP                         137
#define HLP_DUMP                                141
#define HLP_DUMP_EX                             142
#define HLP_HELP1                               143
#define HLP_HELP1_EX                            144
#define HLP_HELP2                               143
#define HLP_HELP2_EX                            144
#define HLP_EXIT                                151
#define HLP_EXIT_EX                             152
#define HLP_QUIT                                151
#define HLP_QUIT_EX                             152
#define HLP_BYE                                 151
#define HLP_BYE_EX                              152
#define HLP_UPLEVEL                             155
#define HLP_UPLEVEL_EX                          156
#define HLP_PUSHD                               157
#define HLP_PUSHD_EX                            158
#define HLP_POPD                                159
#define HLP_POPD_EX                             160
#define HLP_SHOW_ALIAS                          161
#define HLP_SHOW_ALIAS_EX                       162
#define HLP_SET_MODE                            163
#define HLP_SET_MODE_EX                         164
#define HLP_SHOW_MODE                           153
#define HLP_SHOW_MODE_EX                        154
#define HLP_SET_MACHINE                         165
#define HLP_SET_MACHINE_EX                      166
#define HLP_SET_FILE                            167
#define HLP_SET_FILE_EX                         168
#define MSG_NETSH_LOGIN_PASSWORD                169

#define MSG_WARN_COULDNOTVERCHECKHOST           180
#define MSG_INVALID_TOPLEVEL_CMD                181
#define MSG_INVALID_CMD_GROUP                   182
#define MSG_INVALID_CMD                         183

#define MSG_SHOW_HELPER_INFO                    200
#define MSG_SHOW_HELPER_INFO1                   201
#define MSG_SHOW_HELPER_INFO2                   202
#define MSG_SHOW_HELPER_HDR                     203
#define MSG_SHOW_HELPER_DLL_HDR                 204
#define MSG_SHOW_HELPER_ORPHAN_HDR              205
#define MSG_SHOW_HELPER_ORPHAN_INFO             206

#define EMSG_INSTALL_KEY_FAILED                 1000
#define EMSG_UNINSTALL_KEY_FAILED               1001
#define EMSG_ALIASING_KEYWORD                   1002
#define EMSG_REMOTE_CONNECT_FAILED              1003
#define EMSG_INCOMPLETE_COMMAND                 1004
#define EMSG_DLL_FN_NOT_FOUND                   1005

#define HLP_GROUP_ADD                           2000
#define HLP_GROUP_DELETE                        2001
#define HLP_GROUP_SET                           2002
#define HLP_GROUP_SHOW                          2003
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\shell.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    routing\netsh\shell\shell.c

Abstract:

    The command shell. 

Revision History:

    Anand Mahalingam          7/6/98  Created
    Dave Thaler                   99  Updated

--*/

#include "precomp.h"

#undef EXTRA_DEBUG

//
// Define this when we allow a -r option to do remote config
//
#define ALLOW_REMOTES

#define DEFAULT_STARTUP_CONTEXT L"netsh"

WCHAR   RtmonPrompt[MAX_CMD_LEN];
WCHAR   g_pwszContext[MAX_CMD_LEN] = DEFAULT_STARTUP_CONTEXT;
WCHAR   g_pwszNewContext[MAX_CMD_LEN] = DEFAULT_STARTUP_CONTEXT;
LPWSTR  g_pwszRouterName = NULL;
LPWSTR  g_pwszRememberedConnection = NULL;
HANDLE  g_hModule;
BOOL    g_bVerbose = FALSE;
BOOL    g_bInteractive = FALSE;
DWORD   g_dwContextArgCount;
DWORD   g_dwTotalArgCount;
BOOL    g_bDone = FALSE;
HANDLE  g_hLogFile = NULL;

BOOL
WINAPI
HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    );

//
// If quiet, "Ok" and other informational messages will be suppressed.
//
BOOL    g_bQuiet = TRUE;

CMD_ENTRY g_UbiqCmds[] =
{
    CREATE_CMD_ENTRY(   DUMP,     HandleUbiqDump),
    CREATE_CMD_ENTRY(   HELP1,    HandleUbiqHelp),
    CREATE_CMD_ENTRY(   HELP2,    HandleUbiqHelp),
};

ULONG   g_ulNumUbiqCmds = sizeof(g_UbiqCmds)/sizeof(CMD_ENTRY);

CMD_ENTRY g_ShellCmds[] = 
{
//  CREATE_CMD_ENTRY(   DUMP,     HandleShellDump),
//  CREATE_CMD_ENTRY(   HELP1,    HandleShellHelp),
//  CREATE_CMD_ENTRY(   HELP2,    HandleShellHelp),
    CREATE_CMD_ENTRY(   LOAD,     HandleShellLoad),
    CREATE_CMD_ENTRY_EX(QUIT,     HandleShellExit,    CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(BYE,      HandleShellExit,    CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(EXIT,     HandleShellExit,    CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(FLUSH,    HandleShellFlush,   CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(SAVE,     HandleShellSave,    CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(COMMIT,   HandleShellCommit,  CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(UNCOMMIT, HandleShellUncommit,CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(ALIAS,    HandleShellAlias,   CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(UNALIAS,  HandleShellUnalias, CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(UPLEVEL,  HandleShellUplevel, CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(PUSHD,    HandleShellPushd,   CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(POPD,     HandleShellPopd,    CMD_FLAG_INTERACTIVE),
};

ULONG   g_ulNumShellCmds = sizeof(g_ShellCmds)/sizeof(CMD_ENTRY);

CMD_ENTRY g_ShellAddCmdTable[] = {
    CREATE_CMD_ENTRY_EX(ADD_HELPER,  HandleAddHelper, CMD_FLAG_LOCAL),
};

CMD_ENTRY g_ShellSetCmdTable[] = {
    CREATE_CMD_ENTRY_EX(SET_MACHINE, HandleSetMachine,CMD_FLAG_ONLINE),
    CREATE_CMD_ENTRY_EX(SET_MODE,    HandleSetMode,   CMD_FLAG_INTERACTIVE),
    CREATE_CMD_ENTRY_EX(SET_FILE,    HandleSetFile,  CMD_FLAG_INTERACTIVE),
};

CMD_ENTRY g_ShellDelCmdTable[] = {
    CREATE_CMD_ENTRY_EX(DEL_HELPER,  HandleDelHelper, CMD_FLAG_LOCAL),
};

CMD_ENTRY g_ShellShowCmdTable[] = {
    CREATE_CMD_ENTRY_EX(SHOW_ALIAS,  HandleShowAlias, 0),
    CREATE_CMD_ENTRY_EX(SHOW_HELPER, HandleShowHelper, 0),
    CREATE_CMD_ENTRY_EX(SHOW_MODE,   HandleShowMode, CMD_FLAG_INTERACTIVE),
};

CMD_GROUP_ENTRY g_ShellCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,    g_ShellAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_ShellDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,    g_ShellSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,   g_ShellShowCmdTable),
};

ULONG   g_ulNumGroups = sizeof(g_ShellCmdGroups)/sizeof(CMD_GROUP_ENTRY);

DWORD
ParseCommand(
    IN    PLIST_ENTRY    pleEntry,
    IN    BOOL           bAlias
    )
/*++

Routine Description:

    This converts any multi-token arguments into separate arg entries.
    If bAlias is set, it also expands any args which are aliases.

Arguments:

    ple        - Pointer to the argument.
    bAlias     - To look for alias or not.

Called by: ConvertBufferToArgList(), ProcessCommand()
    
Return Value:

    ERROR_NOT_ENOUGH_MEMORY, NO_ERROR
    
--*/
{
    DWORD          dwErr = NO_ERROR, dwLen , i;
    LPWSTR         pw1, pw2, pwszAlias;
    PLIST_ENTRY    ple, ple1, pleTmp, plePrev, pleAlias;
    PARG_ENTRY     pae, paeArg;
    WCHAR          wcTmp;

    paeArg = CONTAINING_RECORD(pleEntry, ARG_ENTRY, le);

    if (! paeArg->pwszArg)
    {
        return NO_ERROR;
    }
    
    pw1 = paeArg->pwszArg;
    
    //
    // Get each argument in the command. Argument within " must
    // be retained as is. The token delimiters are ' ' and '='
    //
    
    for (plePrev = pleEntry ; ; )
    {
        // Skip leading whitespace
        for(; *pw1 && *pw1 != L'#' && (*pw1 == L' ' || *pw1 == L'\t'); pw1++);

        // If it starts with a #, it's the same as an empty string
        if (*pw1 == L'#')
            *pw1 = L'\0';
        
        // If it's an empty string, we're done
        if (!(*pw1))
        {
            break;
        }   

        if (*pw1 is L'"')
        {
            for (pw2 = pw1 + 1; *pw2 && *pw2 != L'"'; pw2++);
            if (*pw2)
            {
                pw2++;
            }
        }
        else if (*pw1 is L'=')
        {
            pw2 = pw1 + 1;
        }
        else
        {
            for(pw2 = pw1 + 1; *pw2 && *pw2 != L' ' && *pw2 != L'=' ; pw2++);
        }
        
        //
        // Add the new argument to the list.
        //
        
        pae = MALLOC(sizeof(ARG_ENTRY));
        
        if (pae is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        ple = &(pae->le);
        
        ple->Flink = plePrev->Flink;
        ple->Blink = plePrev;
        plePrev->Flink = ple;
        ple->Flink->Blink = ple;

        plePrev = ple;
        
        wcTmp = *pw2;
        *pw2 = L'\0';
        
        //
        // The argument could be an alias. If so replace it by
        // the original string.
        //

        if (bAlias)
        {
            ATLookupAliasTable(pw1, &pwszAlias);
        }
        else
        {
            pwszAlias = NULL;
        }
        
        if (pwszAlias)
        {
            pw1 = pwszAlias;
            dwLen = wcslen(pwszAlias) + 1;
        }
        else
        {
            dwLen = (DWORD)(pw2 - pw1 + 1);
        }
        
        pae->pwszArg = MALLOC(dwLen * sizeof(WCHAR));

        if (pae->pwszArg is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Convert /? and -? to just ?
        if (!wcscmp(pw1, L"/?") or !wcscmp(pw1, L"-?"))
        {
            pw1++;
        }

        wcscpy(pae->pwszArg, pw1);

        *pw2 = wcTmp;
        pw1 = pw2;
    }

    if (dwErr is NO_ERROR)
    {
        // Free the argument
        FREE(paeArg->pwszArg);
        pleEntry->Blink->Flink = pleEntry->Flink;
        pleEntry->Flink->Blink = pleEntry->Blink;
        FREE(paeArg);
    }

    return dwErr;
}

DWORD
WINAPI
UpdateNewContext(
    IN OUT  LPWSTR  pwszBuffer,
    IN      LPCWSTR pwszNewToken,
    IN      DWORD   dwArgs
    )
/*++
    pwszBuffer - a static buffer (should be g_pwszNewContext)
                 currently this can't be dynamic since the context buffer
                 would have to be an IN/OUT parameter to this function
                 and hence to all monitor Entry points.
--*/
{
    DWORD        dwErr;
    PLIST_ENTRY  pleHead, pleNode;
    PARG_ENTRY   pae;

    // Convert buffer to list

    dwErr = ConvertBufferToArgList( &pleHead, pwszBuffer );

    if (dwErr)
    {
        return dwErr;
    }

    // Locate in list

    for (pleNode = pleHead->Blink; dwArgs>1; pleNode=pleNode->Blink)
    {
        if (pleNode->Blink isnot pleHead) 
        {
            pae = CONTAINING_RECORD(pleNode->Blink, ARG_ENTRY, le);
            if (!wcscmp(pae->pwszArg,L"="))
            {
                pleNode=pleNode->Blink; // back up over =
                if (pleNode->Blink isnot pleHead) 
                {
                    pleNode=pleNode->Blink; // back up over tag too
                }
            }
        }

        dwArgs--;
    }

    // Update in list

    pae = CONTAINING_RECORD(pleNode, ARG_ENTRY, le);
    if (pae->pwszArg)
    {
        FREE(pae->pwszArg);
    }
    pae->pwszArg = MALLOC((wcslen(pwszNewToken)+1) * sizeof(WCHAR));
    if (pae->pwszArg is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(pae->pwszArg, pwszNewToken);

    // Convert list to buffer

    dwErr = ConvertArgListToBuffer( pleHead, pwszBuffer );

    return dwErr;
}

DWORD
GetNewContext(
    IN    LPCWSTR   pwszArgument,
    OUT   LPWSTR    *ppwszNewContext,
    OUT   BOOL      *pbContext
    )
/*++

Routine Description:

    Based on the first command argument and the current context,
    determines the context for the new command.

Arguments:

    pwszArgument    - First argument in the command line.
    ppwszNewContext - Pointer to the new context.
    pbContext       - Is it a new context ?
    
Return Value:

    ERROR_NOT_ENOUGH_MEMORY, NO_ERROR
    
--*/
{
    LPWSTR    pwszNewContext, pwcToken, pw1, pwszArgumentCopy, pwszArgumentPtr;
    DWORD     dwSize;

    pwszArgumentCopy = _wcsdup(pwszArgument);

    if ( pwszArgumentCopy is NULL )
    {
        *pbContext = FALSE;
        
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pwszArgumentPtr  = pwszArgumentCopy;

    //
    // New Context cannot be longer than the combined lengths
    // of pwszArgument and g_pwszContext.
    //

    dwSize = wcslen(pwszArgumentCopy) + wcslen(g_pwszContext) + 2;

    pwszNewContext = MALLOC(dwSize * sizeof(WCHAR));

    if (pwszNewContext is NULL)
    {
        *pbContext = FALSE;
        
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        free(pwszArgumentPtr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    if (pwszArgumentCopy[0] is L'\\')
    {
        //
        // The context is an absolute one.
        //
        
        pwszNewContext[0] = L'\0';
        pwszArgumentCopy++;
        *pbContext = TRUE;
    }
    else
    {
        //
        // Context is relative to current.
        //

        wcscpy(pwszNewContext,g_pwszContext);
    }

    if ((pwcToken = wcstok(pwszArgumentCopy, L"\\" )) is NULL)
    {
        *ppwszNewContext = pwszNewContext;
        free(pwszArgumentPtr);
        return NO_ERROR;
    }

    do
    {
        if (_wcsicmp(pwcToken, L"..") == 0)
        {
            //
            // Go back one level. If already at root, ignore.
            //

            if (_wcsicmp(pwszNewContext,L"\\") == 0)
            {
            }
            else
            {
                pw1 = wcsrchr(pwszNewContext,L'\\');
                if (pw1)
                {
                    *pw1 = L'\0';
                }
            }

            *pbContext = TRUE;
        }
        else
        {
            //
            // add this level to context
            //

            wcscat(pwszNewContext,L"\\");
            wcscat(pwszNewContext,pwcToken);
            *pbContext = TRUE;
            
        }
        
    } while ((pwcToken = wcstok((LPWSTR)NULL, L"\\" )) != NULL);

    *ppwszNewContext = pwszNewContext;

    free(pwszArgumentPtr);
    return NO_ERROR;
}

DWORD
AppendString(
    IN OUT LPWSTR    *ppwszBuffer,
    IN     LPCWSTR    pwszString
    )
{
    LPWSTR  pwszNewBuffer;
    DWORD   dwLen;

    if (*ppwszBuffer is NULL) {
        dwLen = wcslen(pwszString) + 1;

        pwszNewBuffer = MALLOC( dwLen * sizeof(WCHAR));

        if (pwszNewBuffer) {
            pwszNewBuffer[0] = 0;
        }
    } else {
        dwLen = wcslen(*ppwszBuffer) + wcslen(pwszString) + 1;

        pwszNewBuffer = REALLOC( *ppwszBuffer, dwLen * sizeof(WCHAR));
    }

    if (!pwszNewBuffer)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppwszBuffer = pwszNewBuffer;
    wcscat(pwszNewBuffer, pwszString);

    return NO_ERROR;
}

VOID
ConvertArgArrayToBuffer(
    IN  DWORD       dwArgCount, 
    IN  LPCWSTR    *argv, 
    OUT LPWSTR     *ppwszBuffer
    )
{
    DWORD i;

#ifdef EXTRA_DEBUG
    PRINT1("In ConvertArgArrayToBuffer:");
    for( i = 0; i < dwArgCount; i++)
    {
        PRINT(argv[i]);
    }
#endif

    // Initial string to empty
    *ppwszBuffer = NULL;

    for (i=0; i<dwArgCount; i++)
    {
        if (i)
        {
            AppendString(ppwszBuffer, L" ");
        }

        if (wcschr(argv[i], L' '))
        {
            AppendString(ppwszBuffer, L"\"");
            AppendString(ppwszBuffer, argv[i]);
            AppendString(ppwszBuffer, L"\"");
        }
        else
        {
            AppendString(ppwszBuffer, argv[i]);
        }
    }

#ifdef EXTRA_DEBUG
    PRINT1("At end of ConvertArgArrayToBuffer:");
    PRINT(*ppwszBuffer);
#endif
}

VOID
SetContext(
    IN  LPCWSTR wszNewContext
    )
{
    wcscpy(g_pwszContext, wszNewContext);
    _wcslwr(g_pwszContext);
}

BOOL
IsImmediate(
    IN  DWORD dwCmdFlags,
    IN  DWORD dwRemainingArgs
    )
/*++
Description:
    Determines whether a command was "immediate".  A command is immediate
    if the context in which it exists was the current context in the 
    shell.
Returns: 
    TRUE if command is "immediate", FALSE if not
--*/
{
    if (!(dwCmdFlags & CMD_FLAG_PRIVATE))
    {
        return FALSE;
    }

    // One way to tell is to get the current context arg count,
    // the total arg count, and the remaining arg count.
    
    return (g_dwContextArgCount + dwRemainingArgs is g_dwTotalArgCount);
}

DWORD
ProcessHelperCommand2(
    IN      PCNS_CONTEXT_ATTRIBUTES pContext,
    IN      DWORD   dwArgCount, 
    IN OUT  LPWSTR *argv,
    IN      DWORD   dwDisplayFlags,
    OUT     BOOL    *pbDone
    )
{
    PNS_CONTEXT_ENTRY_FN pfnEntryPt;
    DWORD               dwRes, dwIdx;
    LPWSTR              pwszNewContext = NULL;
    LPWSTR              pwszOrigContext = NULL;

    if (pContext->dwFlags & ~dwDisplayFlags)
    {
        return ERROR_CMD_NOT_FOUND;
    }

    pfnEntryPt = (!pContext->pReserved) ? NULL : ((PNS_PRIV_CONTEXT_ATTRIBUTES)pContext->pReserved)->pfnEntryFn;

    // If arg was abbreviated, replace argv[0] with expanded name
    if (wcscmp(argv[0], pContext->pwszContext))
    {
        pwszOrigContext = argv[0];

        argv[0] = pContext->pwszContext;
    }

    ConvertArgArrayToBuffer(dwArgCount, argv, &pwszNewContext);
    if (pwszNewContext) 
    {
        wcsncpy(g_pwszNewContext, pwszNewContext, MAX_CMD_LEN);
        
        //
        // this is something of a hack - we put the NULL 100 chars before the end of the buffer to prevent a buffer overrun later
        // in UpdateNewContext: 190933 netsh hit an AV on netsh!._wcsnicmp     
        //
        g_pwszNewContext[ MAX_CMD_LEN - 100 ] = 0;

        FREE(pwszNewContext);
        pwszNewContext = NULL;
    }

    //
    // Call the entry point of helper.
    //

    if (pfnEntryPt)
    {
        dwRes = (*pfnEntryPt)(g_pwszRouterName,
                              argv, // + 1,
                              dwArgCount, // - 1,
                              dwDisplayFlags,
                              NULL,
                              g_pwszNewContext);
    }
    else
    {
        dwRes = GenericMonitor(pContext,
                               g_pwszRouterName,
                               argv, // + 1,
                               dwArgCount, // - 1,
                               dwDisplayFlags,
                               NULL,
                               g_pwszNewContext);
    }

    if (pwszOrigContext)
    {
        argv[0] = pwszOrigContext;
    }

    if (dwRes isnot NO_ERROR)
    {
        if (dwRes is ERROR_CONTEXT_SWITCH)
        {
            if (!(dwDisplayFlags & CMD_FLAG_INTERACTIVE))
            {
                LPWSTR *argv2 = MALLOC((dwArgCount+1) * sizeof(LPWSTR));

                if (argv2 is NULL)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                CopyMemory(argv2, argv, dwArgCount * sizeof(LPWSTR));

                argv2[dwArgCount] = MALLOC((wcslen(CMD_HELP2)+1) * sizeof(WCHAR));

                if (argv2[dwArgCount] is NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    wcscpy(argv2[dwArgCount], CMD_HELP2);

                    g_dwTotalArgCount = dwArgCount+1;

                    dwRes = ProcessHelperCommand2(pContext,
                                                  dwArgCount+1, 
                                                  argv2,
                                                  dwDisplayFlags,
                                                  pbDone);
    
                    FREE(argv2[dwArgCount]);
                }
                FREE(argv2);

                return dwRes;
            }

            //
            // A context switch.
            // 
        
            SetContext(g_pwszNewContext);

            dwRes = NO_ERROR;
        }
        else if (dwRes is ERROR_CONNECT_REMOTE_CONFIG)
        {
            PrintMessageFromModule(g_hModule, EMSG_REMOTE_CONNECT_FAILED,
                           g_pwszRouterName);
                    
            *pbDone = TRUE;
        }
    }


    return dwRes;
}

DWORD
WINAPI
ProcessHelperCommand(
    IN      DWORD    dwArgCount, 
    IN OUT  LPWSTR  *argv,
    IN      DWORD    dwDisplayFlags,
//  OUT     LPWSTR  *ppwszNewContext,
    OUT     BOOL    *pbDone
    )
{
    PCNS_CONTEXT_ATTRIBUTES pContext;
    PNS_CONTEXT_ENTRY_FN pfnEntryPt;
    DWORD               dwRes, dwIdx;
    LPWSTR              pwszNewContext = NULL;
    LPWSTR              pwszOrigContext = NULL;
    PNS_HELPER_TABLE_ENTRY pHelper;

    dwRes = GetRootContext( &pContext, &pHelper);
    if (dwRes)
    {
        return dwRes;
    }

    dwRes = GetContextEntry(pHelper, argv[0], &pContext);

    if (dwRes isnot NO_ERROR)
    {
        return ERROR_CMD_NOT_FOUND;
    }

    if (pContext->dwFlags & ~dwDisplayFlags)
    {
        return ERROR_CMD_NOT_FOUND;
    }

#if 1
    pfnEntryPt = (!pContext->pReserved) ? NULL : ((PNS_PRIV_CONTEXT_ATTRIBUTES)pContext->pReserved)->pfnEntryFn;
#else
    dwRes = GetHelperAttributes(dwIdx, &pfnEntryPt);

    if (dwRes != NO_ERROR)
    {
        //
        // Could not find helper or could not load the DLL
        //

        return dwRes;
    }
#endif

    // If arg was abbreviated, replace argv[0] with expanded name
    if (wcscmp(argv[0], pContext->pwszContext))
    {
        pwszOrigContext = argv[0];

        argv[0] = pContext->pwszContext;
    }

    ConvertArgArrayToBuffer(dwArgCount, argv, &pwszNewContext);
    if (pwszNewContext) 
    {
        wcsncpy(g_pwszNewContext, pwszNewContext, MAX_CMD_LEN);
        g_pwszNewContext[ MAX_CMD_LEN - 1 ] = '\0';

        FREE(pwszNewContext);
        pwszNewContext = NULL;
    }

    //
    // Call the entry point of helper.
    //

    if (pfnEntryPt)
    {
        dwRes = (*pfnEntryPt)(g_pwszRouterName,
                              argv + 1,
                              dwArgCount - 1,
                              dwDisplayFlags,
                              NULL,
                              g_pwszNewContext);
    }
    else
    {
        dwRes = GenericMonitor(pContext,
                               g_pwszRouterName,
                               argv + 1,
                               dwArgCount - 1,
                               dwDisplayFlags,
                               NULL,
                               g_pwszNewContext);
    }

    if (pwszOrigContext)
    {
        argv[0] = pwszOrigContext;
    }

    if (dwRes isnot NO_ERROR)
    {
        if (dwRes is ERROR_CONTEXT_SWITCH)
        {
            if (!(dwDisplayFlags & CMD_FLAG_INTERACTIVE))
            {
                LPWSTR *argv2 = MALLOC((dwArgCount+1) * sizeof(LPWSTR));

                if (argv2 is NULL)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                CopyMemory(argv2, argv, dwArgCount * sizeof(LPWSTR));

                argv2[dwArgCount] = MALLOC((wcslen(CMD_HELP2)+1) * sizeof(WCHAR));

                if (argv2[dwArgCount] is NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    wcscpy(argv2[dwArgCount], CMD_HELP2);

                    g_dwTotalArgCount = dwArgCount+1;

                    dwRes = ProcessHelperCommand(dwArgCount+1, 
                                                 argv2,
                                                 dwDisplayFlags,
                                                 pbDone);
    
                    FREE(argv2[dwArgCount]);
                }
                FREE(argv2);

                return dwRes;
            }

            //
            // A context switch.
            // 
        
            SetContext(g_pwszNewContext);

            dwRes = NO_ERROR;
        }
        else if (dwRes is ERROR_CONNECT_REMOTE_CONFIG)
        {
            PrintMessageFromModule(g_hModule, EMSG_REMOTE_CONNECT_FAILED,
                           g_pwszRouterName);
                    
            *pbDone = TRUE;
        }
    }


    return dwRes;
}

DWORD 
WINAPI
ExecuteHandler(
    IN      HANDLE     hModule,
    IN      CMD_ENTRY *pCmdEntry,
    IN OUT  LPWSTR   *argv, 
    IN      DWORD      dwNumMatched, 
    IN      DWORD      dwArgCount, 
    IN      DWORD      dwFlags,
    IN      LPCVOID    pvData,
    IN      LPCWSTR    pwszGroupName,
    OUT     BOOL      *pbDone)
{
    DWORD dwErr = NO_ERROR;
    
    if (((dwArgCount - dwNumMatched) == 1)
     && IsHelpToken(argv[dwNumMatched]))
    {
        dwErr = ERROR_SHOW_USAGE;
    }
    else 
    {
        //
        // Call the parsing routine for the command
        //
        dwErr = pCmdEntry->pfnCmdHandler( g_pwszRouterName,
                                          argv, 
                                          dwNumMatched, 
                                          dwArgCount, 
                                          dwFlags,
                                          pvData,
                                          pbDone );
    }

    if (dwErr is ERROR_INVALID_SYNTAX)
    {
        PrintError(NULL, dwErr);
        dwErr = ERROR_SHOW_USAGE;
    }

    switch (dwErr) {
    
    case ERROR_SHOW_USAGE:
        //
        // If the only argument is a help token, just
        // display the help.
        //

        if (NULL != pwszGroupName)
        {
            LPWSTR pwszGroupFullCmd = (LPWSTR) 
                                        MALLOC( ( wcslen(pwszGroupName) +  
                                                  wcslen(pCmdEntry->pwszCmdToken) + 
                                                  2   // for blank and NULL characters
                                                ) * sizeof(WCHAR) 
                                              );
            if (NULL == pwszGroupFullCmd)
            {
                // we still try to print without group name
                PrintMessageFromModule( hModule,
                                        pCmdEntry->dwCmdHlpToken,
                                        pCmdEntry->pwszCmdToken );
            }
            else
            {
                wcscpy(pwszGroupFullCmd, pwszGroupName);
                wcscat(pwszGroupFullCmd, L" ");
                wcscat(pwszGroupFullCmd, pCmdEntry->pwszCmdToken);

                PrintMessageFromModule( hModule,
                                        pCmdEntry->dwCmdHlpToken,
                                        pwszGroupFullCmd );
                FREE(pwszGroupFullCmd);
            }


        }
        else
        {
            PrintMessageFromModule( hModule,
                                    pCmdEntry->dwCmdHlpToken,
                                    pCmdEntry->pwszCmdToken );
        }
        dwErr = NO_ERROR;
        break;

    case NO_ERROR:
    case ERROR_SUPPRESS_OUTPUT:
        break;

    case ERROR_OKAY:
        if (!g_bQuiet)
        {
            PrintMessageFromModule( NULL, MSG_OKAY);
        }
        dwErr = NO_ERROR;
        break;

    default:
        PrintError(NULL, dwErr);
        break;
    }
    
    if (!g_bQuiet)
    {
        PrintMessage( MSG_NEWLINE );
    }

    return dwErr;
}

BOOL
ProcessGroupCommand(
    IN  DWORD   dwArgCount, 
    IN  PTCHAR *argv,
    IN  DWORD   dwDisplayFlags,
    OUT BOOL   *pbDone
    )
{
    BOOL bFound = FALSE;
    DWORD i, j, dwNumMatched, dwErr;

    for(i = 0; i < g_ulNumGroups; i++)
    {
        if (g_ShellCmdGroups[i].dwFlags & ~dwDisplayFlags)
        {
            continue;
        }

        if (MatchToken(argv[0],
                       g_ShellCmdGroups[i].pwszCmdGroupToken))
        {
            
            // See if it's a request for help

            if ((dwArgCount < 2) || IsHelpToken(argv[1]))
            {
                PCNS_CONTEXT_ATTRIBUTES pContext;
        
                dwErr = GetRootContext(&pContext, NULL);

                if (dwErr is NO_ERROR)
                {
                    dwErr = DisplayContextHelp( 
                                       pContext,
                                       CMD_FLAG_PRIVATE,
                                       dwDisplayFlags,
                                       dwArgCount-2+1,
                                       g_ShellCmdGroups[i].pwszCmdGroupToken );
                }

                return TRUE;
            }

            //
            // Command matched entry i, so look at the table of sub commands
            // for this command
            //

            for (j = 0; j < g_ShellCmdGroups[i].ulCmdGroupSize; j++)
            {
                if (g_ShellCmdGroups[i].pCmdGroup[j].dwFlags 
                 & ~dwDisplayFlags)
                {
                    continue;
                }

                if (MatchCmdLine(argv,
                                  dwArgCount,
                                  g_ShellCmdGroups[i].pCmdGroup[j].pwszCmdToken,
                                  &dwNumMatched))
                {
                    bFound = TRUE;



                    dwErr = ExecuteHandler(g_hModule,
                             &g_ShellCmdGroups[i].pCmdGroup[j],
                             argv, dwNumMatched, dwArgCount, 
                             dwDisplayFlags,
                             NULL,
                             g_ShellCmdGroups[i].pwszCmdGroupToken,
                             pbDone);
                    
                    //
                    // quit the for(j)
                    //

                    break;
                }
            }

            break;
        }
    }

    return bFound;
}

DWORD
LookupCommandHandler(
    IN LPCWSTR pwszCmd
    )
{
    // Eventually, we want to look up commands in sub-contexts first,
    // and end up with the global context.  For now, we'll just do global.

    DWORD i;

    for (i = 0; i < g_ulNumShellCmds; i++)
    {
        if (MatchToken(pwszCmd, g_ShellCmds[i].pwszCmdToken))
        {
            return i;
        }
    }

    return -1;
}

VOID
FreeArgArray(
    DWORD    argc, 
    LPWSTR  *argv
    )
{
    DWORD i;

    for (i = 0; i < argc; i++)
    {
        FREE(argv[i]);
    }
    
    FREE(argv);
}

DWORD
ConvertArgListToBuffer(
    IN  PLIST_ENTRY pleHead,
    OUT LPWSTR      pwszBuffer
    )
{
    PLIST_ENTRY ple;
    PARG_ENTRY  pae;
    LPWSTR  p = pwszBuffer;

    *p = '\0';

    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink )
    {
        pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);

        if (p isnot pwszBuffer)
        {
           *p++ = ' ';
        }
        wcscpy(p, pae->pwszArg);
        p += wcslen(p);
    }

    return NO_ERROR;
}



DWORD
AppendArgument(
    IN OUT LPWSTR    **pargv,
    IN     DWORD       i,
    IN     LPCWSTR     pwszString
    )
{
    DWORD dwErr;

    dwErr = AppendString( &(*pargv)[i], pwszString );

    if ((*pargv)[i] is NULL) {
        FreeArgArray(i, *pargv);
        *pargv = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}

DWORD
ConvertArgListToArray(
    IN  PLIST_ENTRY pleContextHead,
    IN  PLIST_ENTRY pleHead,
    OUT PDWORD      pargc,
    OUT LPWSTR    **pargv,
    OUT PDWORD      pdwContextArgc
    )
{
    DWORD    dwErr = NO_ERROR;
    DWORD    argc = 0, i = 0;
    LPWSTR  *argv = NULL, p;
    BOOL     bEqualTo;
    PLIST_ENTRY ple;
    PARG_ENTRY  pae;

#ifdef EXTRA_DEBUG
    if (pleHead)
    {
        PLIST_ENTRY ple;

        PRINT1("In ConvertArgListToArray:");
        for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
        {
            pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
            PRINT(pae->pwszArg);

        }
    }
#endif

    // Count tokens

    if (pleContextHead)
    {
        for (ple = pleContextHead->Flink; ple != pleContextHead; ple = ple->Flink)
            argc++;
    }
    *pdwContextArgc = argc;

    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
        argc++;

    do {
        if (!argc)
            break;
        
        //
        // Allocate space for arguments 
        //
    
        argv = MALLOC(argc * sizeof(LPCWSTR));
    
        if (argv is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        memset(argv, 0, argc * sizeof(LPCWSTR));
        
        bEqualTo = FALSE;

        //
        // Copy the arguments from the list into an argv kind of
        // structure. At this point, the arguments tag, '=' and
        // the value are made into one argument tag=value.
        //

        //
        // Copy context
        //

        i = 0;

        if (pleContextHead)
        {
            for (ple = pleContextHead->Flink; 
                 ple != pleContextHead; 
                 ple = ple->Flink)
            {
                pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
                dwErr = AppendArgument( &argv, i++, pae->pwszArg );
                if ( dwErr isnot NO_ERROR ) {
                    break;
                }
            }
        }

        for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink )
        {
            pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);

            //
            // Remove any " from the string name
            //
            
            if (pae->pwszArg[0] == L'"')
            {
                if (bEqualTo)
                {
                    dwErr=AppendArgument(&argv, i-1, pae->pwszArg+1);
                    if ( dwErr isnot NO_ERROR ) {
                        break;
                    }
                    bEqualTo = FALSE;
                }
                else
                {
                    dwErr=AppendArgument(&argv, i++, pae->pwszArg+1);
                    if (dwErr isnot NO_ERROR ) {
                        break;
                    }
                }

                p = argv[i-1];
                if (p[wcslen(p) - 1] == L'"')
                {
                    p[wcslen(p) - 1] = L'\0';
                }
                continue;
            }

            //
            // combine arguments of the form tag = value
            //
            
            if ((wcscmp(pae->pwszArg,L"=") == 0) || bEqualTo)
            {
                bEqualTo = (bEqualTo) ? FALSE : TRUE;
                
                if (i > 0)
                {
                    i--;
                }
                dwErr = AppendArgument( &argv, i++, pae->pwszArg);
                if (dwErr isnot NO_ERROR ) {
                    break;
                }
            }
            else
            {
                dwErr = AppendArgument( &argv, i++, pae->pwszArg);
                if (dwErr isnot NO_ERROR ) {
                    break;
                }
            }
        }
    } while (FALSE);

#ifdef EXTRA_DEBUG
    PRINT1("At end of ConvertArgListToArray:");
    for( i = 0; i < argc; i++)
    {
        PRINT(argv[i]);
    }
#endif

    *pargc = i;
    *pargv = argv;

    return dwErr;
}

DWORD
ConvertBufferToArgList(
    PLIST_ENTRY *ppleHead,
    LPCWSTR      pwszBuffer
    )
{
    PLIST_ENTRY pleHead = NULL;
    DWORD       dwErr = NO_ERROR;
    PARG_ENTRY  pae;

#ifdef EXTRA_DEBUG
    PRINT1("In ConvertBufferToArgList:");
    PRINT(pwszBuffer);
#endif

    do {
        //
        // First convert the command line to a list of tokens
        //  

        pleHead = MALLOC(sizeof(ARG_ENTRY));

        if (pleHead is NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        ZeroMemory(pleHead, sizeof(ARG_ENTRY));

        InitializeListHead(pleHead);

        pae = MALLOC(sizeof(ARG_ENTRY));
    
        if (pae is NULL)
        {
            FREE(pleHead);
            pleHead = NULL; 
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pae->pwszArg = MALLOC((wcslen(pwszBuffer)+1) * sizeof(WCHAR));
    
        if (pae->pwszArg is NULL)
        {
            FREE(pleHead);
            FREE(pae);
        
            pleHead = NULL; 
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wcscpy(pae->pwszArg, pwszBuffer);
    
        InsertHeadList(pleHead, &(pae->le));

        dwErr = ParseCommand(pleHead->Flink, FALSE);

        if (dwErr isnot NO_ERROR)
        {
            FREE_ARG_LIST(pleHead);
            pleHead = NULL; 
            break;
        }

    } while (FALSE);

#ifdef EXTRA_DEBUG
    if (pleHead) 
    {
        PLIST_ENTRY ple;

        PRINT1("At end of ConvertBufferToArgList:");
        for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
        {
            pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
            PRINT(pae->pwszArg);
            
        }
    }
#endif

    *ppleHead = pleHead;

    if (dwErr is ERROR_NOT_ENOUGH_MEMORY)
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);

    return dwErr;
}

DWORD
ProcessShellCommand( 
    IN      DWORD    dwArgCount,
    IN OUT  LPWSTR *argv,
    IN      DWORD    dwDisplayFlags,
//  OUT     LPWSTR  *ppwszNewContext,
    OUT     BOOL    *pbDone
    )
{
    DWORD i;

    for (i = 0; i < g_ulNumShellCmds; i++)
    {
        if (g_ShellCmds[i].dwFlags & ~dwDisplayFlags)
        {
            continue;
        }

        if (MatchToken( argv[0],
                        g_ShellCmds[i].pwszCmdToken ))
        {
            return ExecuteHandler( g_hModule,
                                   &g_ShellCmds[i],
                                   argv, 
                                   1, 
                                   dwArgCount, 
                                   dwDisplayFlags,
                                   NULL,
                                   NULL,
                                   pbDone );

        }
    }

    return ERROR_CMD_NOT_FOUND;
}

DWORD
ProcessCommand(
    IN    LPCWSTR    pwszCmdLine,
    OUT   BOOL      *pbDone
    )
/*++

Routine Description:

    Executes command if it is for the shell or else calls the
    corresponding helper routine.

Arguments:

    pwszCmdLine - The command line to be executed.
    
Return Value:

    TRUE, FALSE  - (Whether to quit the program or not)
    
--*/
{
    LPCWSTR             pwszAliasString = NULL;
    DWORD               dwRes = NO_ERROR, i, dwLen, j;
    WCHAR               wszAliasString[MAX_CMD_LEN],
                        pwszContext[MAX_CMD_LEN];
    WCHAR               pwszCommandLine[MAX_CMD_LEN],*pwszNewContext;
    LPCWSTR             pwcAliasString, pw1,pw2,pw3;
    BOOL                bContext, bEqualTo, bTmp;
    LPCWSTR             pwszArg0, pwszArg1, pwszArg2;
    PLIST_ENTRY         ple, ple1, ple2, pleHead, pleTmp, pleNext;
    PLIST_ENTRY         pleContextHead;
    PARG_ENTRY          pae;
    DWORD               dwArgCount = 0, dwContextArgCount = 0;
    LPWSTR             *argv, pwcNewContext = NULL;
    BOOL                bShellCmd, bAlias, bFound = FALSE, dwDisplayFlags;
    PCNS_CONTEXT_ATTRIBUTES pContext;

    *pbDone = FALSE;

    dwDisplayFlags = (g_bInteractive)? CMD_FLAG_INTERACTIVE : 0;

    dwDisplayFlags |= ~CMD_FLAG_LIMIT_MASK;

    // Command is executed on the local machine if router name is null
    if (!g_pwszRouterName)
    {
        dwDisplayFlags |= CMD_FLAG_LOCAL;
    }

    if (g_bCommit)
    {
        dwDisplayFlags |= CMD_FLAG_ONLINE;
    }

    if (g_bVerbose)
    {
        PrintMessage(L"> %1!s!\n", pwszCmdLine);
    }

    dwRes = ConvertBufferToArgList(&pleContextHead, g_pwszContext);
    
    if (dwRes isnot NO_ERROR)
    {
        *pbDone = TRUE;
        return dwRes;
    }

    dwRes = ConvertBufferToArgList(&pleHead, pwszCmdLine);
    
    if (dwRes isnot NO_ERROR)
    {
        FREE_ARG_LIST(pleContextHead);
        *pbDone = TRUE;
        return dwRes;
    }
    
    if (IsListEmpty(pleHead))
    {
        FREE_ARG_LIST(pleHead);
        FREE_ARG_LIST(pleContextHead);
        return NO_ERROR;
    }

    // Expand alias (not recursive)

    dwRes = ParseCommand(pleHead->Flink, TRUE);

    if (dwRes isnot NO_ERROR)
    {
        FREE_ARG_LIST(pleHead);
        FREE_ARG_LIST(pleContextHead);
        *pbDone = TRUE;
        return dwRes;
    }

#ifdef EXTRA_DEBUG
    PRINT1("In ProcessCommand 2:");
    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
        PRINT(pae->pwszArg);
    }
#endif
    
    // Go through and expand any multi-tokens args into separate args
    for (ple = (pleHead->Flink); ple != pleHead; ple = pleNext)
    {
        pleNext = ple->Flink;
        
        dwRes = ParseCommand(ple, FALSE);

        if (dwRes isnot NO_ERROR)
        {
            break;
        }
    }

    if (dwRes isnot NO_ERROR)
    {
        FREE_ARG_LIST(pleHead);
        FREE_ARG_LIST(pleContextHead);
        *pbDone = TRUE;
        return dwRes;
    }

#ifdef EXTRA_DEBUG
    PRINT1("In ProcessCommand 3:");
    for (ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
        PRINT(pae->pwszArg);
    }
#endif

    //
    // At this point, we should have a fully formed command,
    // hopefully operable within the current context.
    // The first token may be a command.  If so, then the args
    // will be the context followed by the rest of the tokens.
    // If the first token is not a command, then the args will
    // be the context followed by all the tokens.
    //

    if (IsListEmpty(pleHead))
    {
        FREE_ARG_LIST(pleHead);
        FREE_ARG_LIST(pleContextHead);
        return NO_ERROR;
    }
    
    pae = CONTAINING_RECORD(pleHead->Flink, ARG_ENTRY, le);
    pwszArg0 = pae->pwszArg;

    GetRootContext( &g_CurrentContext, &g_CurrentHelper );

    do
    {
        // In the first context (only) we try, private commands are valid.

        dwDisplayFlags |= CMD_FLAG_PRIVATE;

        pContext = g_CurrentContext;

        for(;;) 
        {
            dwRes = ConvertArgListToArray( pleContextHead, 
                                           pleHead, 
                                           &dwArgCount, 
                                           &argv,
                                           &dwContextArgCount );

            g_dwTotalArgCount   = dwArgCount;
            g_dwContextArgCount = dwContextArgCount;
                
#if 1
# if 1
            dwRes = ProcessHelperCommand2( pContext,
                                           dwArgCount,
                                           argv,
                                           dwDisplayFlags,
                                           pbDone );
# else
            dwRes = GenericMonitor( pContext,
                                    g_pwszRouterName,
                                    argv,
                                    dwArgCount,
                                    dwDisplayFlags,
                                    NULL,
                                    g_pwszNewContext );
# endif
#else
{
            if (!ProcessGroupCommand(dwArgCount, argv, dwDisplayFlags, pbDone))
            {
                //
                // Having got the context and the command, see if there
                // is a helper for it.
                //

                dwRes = ProcessHelperCommand( dwArgCount, 
                                              argv, 
                                              dwDisplayFlags,
                                              // &pwszNewContext, 
                                              pbDone );

                if (dwRes is ERROR_CMD_NOT_FOUND)
                {
                    dwRes = ProcessShellCommand( dwArgCount,
                                                 argv,
                                                 dwDisplayFlags,
                                                 // &pwszNewContext,
                                                 pbDone );
                }    
            }
}
#endif

            FreeArgArray(dwArgCount, argv);

            if (*pbDone or ((dwRes isnot ERROR_CMD_NOT_FOUND)
                       && (dwRes isnot ERROR_CONTINUE_IN_PARENT_CONTEXT)))
            {
                break;
            }

            // Make sure we don't look above "netsh"
            if (pleContextHead->Flink->Flink == pleContextHead)
            {
                break;
            }

            // Delete the last element of the context list
            // (Try inheriting a command from one level up)

            ple = pleContextHead->Blink;
            pae = CONTAINING_RECORD(ple, ARG_ENTRY, le);
            if (pae->pwszArg)
                FREE(pae->pwszArg);
            RemoveEntryList(ple);
            FREE(pae);

            GetParentContext(pContext, &pContext);

            dwDisplayFlags &= ~CMD_FLAG_PRIVATE;
        }
        
#if 0
        if (pwszNewContext)
        {
            FREE(pwszNewContext);
            pwszNewContext = NULL;
        }
#endif

    } while (FALSE);

    switch(dwRes)
    {
    case ERROR_OKAY:
        if (!g_bQuiet)
        {
            PrintMessageFromModule(g_hModule, MSG_OKAY);
        }
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
        *pbDone = TRUE;
        break;

    case ERROR_CMD_NOT_FOUND:
        {
            LPWSTR pwszCmdLineDup = _wcsdup(pwszCmdLine);
            if (!pwszCmdLineDup)
            {
                PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            if (wcslen(pwszCmdLineDup) > 256)
            {
               wcscpy(pwszCmdLineDup + 250, L"...");
            }
            
            PrintMessageFromModule(NULL, ERROR_CMD_NOT_FOUND, pwszCmdLineDup);
            free(pwszCmdLineDup);
        }
        break;

    case ERROR_CONTEXT_SWITCH:
        {
            if (!(dwDisplayFlags & CMD_FLAG_INTERACTIVE))
            {
                LPWSTR *argv2 = MALLOC((dwArgCount+1) * sizeof(LPWSTR));

                if (argv2 is NULL)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                CopyMemory(argv2, argv, dwArgCount * sizeof(LPWSTR));

                argv2[dwArgCount] = MALLOC((wcslen(CMD_HELP2)+1) * sizeof(WCHAR));

                if (argv2[dwArgCount] is NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    wcscpy(argv2[dwArgCount], CMD_HELP2);

                    g_dwTotalArgCount = dwArgCount+1;

                    dwRes = ProcessHelperCommand(dwArgCount+1,
                                                 argv2,
                                                 dwDisplayFlags,
                                                 pbDone);

                    FREE(argv2[dwArgCount]);
                }
                FREE(argv2);

                return dwRes;
            }

            //
            // A context switch.
            //

            SetContext(g_pwszNewContext);

            dwRes = NO_ERROR;

            break;
        }

    case ERROR_CONNECT_REMOTE_CONFIG:
        PrintMessageFromModule(g_hModule, EMSG_REMOTE_CONNECT_FAILED,
                       g_pwszRouterName);

        g_bDone = TRUE;
        break;

    default:
        // We don't want to print out an error in the default case here since one would have 
        // printed by ExecuteHandler already. Doing this will cause a duplicate message to
        // be displayed.
        break;
    }
    
    FREE_ARG_LIST(pleHead);
    FREE_ARG_LIST(pleContextHead);
    
    return dwRes;
}

// Append line to the full command
DWORD
AppendLineToCommand( 
    LPCWSTR  pwszCmdLine, 
    DWORD    dwCmdLineLen,
    LPWSTR  *ppwszFullCommand,
    DWORD   *dwFullCommandLen
    )
{
    LPWSTR  pwszNewCommand;
    DWORD   dwErr = NO_ERROR;
    DWORD   dwLen;

    // Allocate enough space to hold the full command
    dwLen = *dwFullCommandLen + dwCmdLineLen;
    if (*ppwszFullCommand is NULL)
    {
        pwszNewCommand = MALLOC( (dwLen+1) * sizeof(WCHAR) );
    }
    else
    {
        pwszNewCommand = REALLOC(*ppwszFullCommand, (dwLen+1) * sizeof(WCHAR) );
    }
    if (!pwszNewCommand) 
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Append cmd 
    wcscpy(pwszNewCommand + *dwFullCommandLen, pwszCmdLine);

    // Update the pointer
    *ppwszFullCommand = pwszNewCommand;
    *dwFullCommandLen = dwLen;

    return dwErr;
}

DWORD
MainCommandLoop(
    FILE   *fp,
    BOOL    bDisplayPrompt
    )
{
    LPWSTR  pwszFullCommand, p, pwszCmdLine;
    DWORD   dwFullCommandLen, dwCmdLineLen, dwErr = NO_ERROR;
    DWORD   dwAnyErr = NO_ERROR;
    BOOL    bEof, bDone;

    for ( ; ; )
    {
        pwszFullCommand = NULL;
        dwFullCommandLen = 0;
        bEof = FALSE;

        if (bDisplayPrompt)
        {
            if (g_pwszRouterName)
            {
                PrintMessage(L"[%1!s!] ", g_pwszRouterName);
            }

            if (g_pwszContext[0] is L'\0')
            {
                PrintMessage(RtmonPrompt);
            }
            else
            {
                PrintMessage(L"%1!s!>",g_pwszContext);
            }
        }

        // Get an entire command        

        for (;;) 
        {

            // Get a single line, which may be \ terminated

            pwszCmdLine = OEMfgets(&dwCmdLineLen, fp);
            if (pwszCmdLine is NULL)
            {
                bEof = TRUE;
                break;
            }

            p = pwszCmdLine + (dwCmdLineLen-1);

            // Trim trailing whitespace
            while ((p > pwszCmdLine) && iswspace(p[-1]))
            {
                *(--p) = 0;
            }
        
            if ((p > pwszCmdLine) && (p[-1] is '\\'))
            {
                // Strip '\\' from the end of the line
                *(--p) = 0;

                // Append line to the full command
                AppendLineToCommand( pwszCmdLine, 
                                     (DWORD)(p-pwszCmdLine),
                                     &pwszFullCommand, 
                                     &dwFullCommandLen );
            
                FREE(pwszCmdLine);
                continue; // Get more input
            }

            // Append line to the full command
            AppendLineToCommand( pwszCmdLine, 
                                 (DWORD)(p-pwszCmdLine),
                                 &pwszFullCommand,
                                 &dwFullCommandLen );
        
            // We're done
            FREE(pwszCmdLine);
            break;
        }
        if (bEof) 
        {
            break;
        }

        dwErr = ProcessCommand(pwszFullCommand, &bDone);
        if (bDone || g_bDone)
        {
            FREE(pwszFullCommand);
            break;
        }

        if (dwErr)
        {
            dwAnyErr = dwErr;
        }

        FREE(pwszFullCommand);
    }

    return dwAnyErr;
}

DWORD
LoadScriptFile(
    IN    LPCWSTR pwszFileName
    )
/*++

Routine Description:

    Reads in commands from the file and processes them.

Arguments:

    pwszFileName - Name of script file.
    
Return Value:

    TRUE, FALSE

--*/
{
    FILE*     fp;
    DWORD     i, dwErr = NO_ERROR;
    BOOL      bOldInteractive = g_bInteractive;
    BOOL      bOldQuiet       = g_bQuiet;

    if ((fp = _wfopen(pwszFileName,L"r")) is NULL)
    {
        PrintMessageFromModule(g_hModule, MSG_OPEN_FAILED, pwszFileName);
        return GetLastError();
    }

    g_bInteractive = TRUE;
    g_bQuiet       = TRUE;

    dwErr = MainCommandLoop(fp, FALSE);

    g_bInteractive = bOldInteractive;
    g_bQuiet       = bOldQuiet;

    fclose(fp);

    if (dwErr)
    {
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    return dwErr;
}

// This drops the IPC$ connection to the remote machine (if any).
// This function is called when we switch to a new machine, or netsh finally exits.
//
// deonb     7 Dec 2001
DWORD DisconnectFromCurrentRouter()
{
    DWORD dwErr = NO_ERROR;

    if (g_pwszRememberedConnection)
    {
        dwErr = WNetCancelConnection2(g_pwszRememberedConnection, 0, TRUE);
        if (dwErr)
        {
            PrintError(NULL, dwErr);
        }
        
        FREE(g_pwszRememberedConnection);
        g_pwszRememberedConnection = NULL;
    }
    return dwErr;
}

DWORD
SetMachine(
    IN LPCWSTR pwszNewRouter,
    IN LPCWSTR pwszUserName,
    IN LPCWSTR pwszPassword
    )
{
    HRESULT hr;
    if (g_pwszRouterName)
    {
        FREE(g_pwszRouterName);
    }

    DisconnectFromCurrentRouter();
    
    if (pwszNewRouter)
    {
        g_pwszRouterName = MALLOC((wcslen(pwszNewRouter) + 1) * sizeof(WCHAR));

        if (!g_pwszRouterName)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(g_pwszRouterName, pwszNewRouter);
    }
    else
    {
        g_pwszRouterName = NULL;
    }

    // Change back to root context
    SetContext(DEFAULT_STARTUP_CONTEXT);

    hr = UpdateVersionInfoGlobals(g_pwszRouterName, pwszUserName, pwszPassword);
    if (FAILED(hr))
    {
        if (g_pwszRouterName)
        {
            PrintMessageFromModule(g_hModule, MSG_WARN_COULDNOTVERCHECKHOST,  g_pwszRouterName);
        }
        else
        {
            TCHAR szComputerName[MAX_PATH];
            DWORD dwComputerNameLen = MAX_PATH;
            GetComputerName(szComputerName, &dwComputerNameLen);
            PrintMessageFromModule(g_hModule, MSG_WARN_COULDNOTVERCHECKHOST,  szComputerName);
        }
        PrintError(NULL, hr);
    }

    // Also create a connection to that machine on IPC$. This eliminates the need
    // to do a net use before netsh, and then specify the username & password AGAIN to the
    // netsh command line.
    if (g_pwszRouterName && (pwszUserName || pwszPassword) )
    {
        WCHAR szIPC[MAX_PATH];
        NETRESOURCE NetResource;

        wsprintf(szIPC, L"\\\\%s\\ipc$", g_pwszRouterName);
        
        ZeroMemory(&NetResource, sizeof(NETRESOURCE));
        NetResource.dwType      = RESOURCETYPE_ANY;
        NetResource.lpLocalName = NULL;
        NetResource.lpProvider  = NULL;
        NetResource.lpRemoteName= szIPC; // OS Selects a provider

        hr = WNetAddConnection2(&NetResource, pwszPassword, pwszUserName, CONNECT_COMMANDLINE | CONNECT_INTERACTIVE);
        if (S_OK == hr)
        {
            g_pwszRememberedConnection = MALLOC(sizeof(WCHAR) * MAX_PATH);
            if (!g_pwszRememberedConnection)
            {
                PrintMessageFromModule(NULL, ERROR_OUTOFMEMORY);
                return NO_ERROR; // don't fail the set machine since it did actually work if we're at this point.
            }
            wcsncpy(g_pwszRememberedConnection, szIPC, MAX_PATH);
        }
        else
        {
            PrintError(NULL, hr);
        }
    }
    return NO_ERROR;
}

void SetThreadCodePage()
{
    LANGID (WINAPI *pSetThreadUILanguage)() = NULL;
    HMODULE hKernel32 = NULL;

    hKernel32 = LoadLibrary(L"kernel32.dll");
    if (hKernel32)
    {
        pSetThreadUILanguage = (PVOID) GetProcAddress( hKernel32, "SetThreadUILanguage" );

        // OS Platforms before WinXP doesn't support MUI command line utilities so
        // we don't need to worry about it if the O/S doesn't support this API.
        if (pSetThreadUILanguage) 
        {
            (*pSetThreadUILanguage)( 0 );
        }

        FreeLibrary(hKernel32);
    }
}

int
MainFunction(
    int     argc,
    WCHAR   *argv[]
    )
{
    WCHAR     pwszCmdLine[MAX_CMD_LEN] = L"\0";
    WCHAR     pwszArgContext[MAX_CMD_LEN] = L"\0";
    BOOL      bOnce = FALSE, bDone = FALSE;
    LPCWSTR   pwszArgAlias = NULL;
    LPCWSTR   pwszArgScript = NULL;
    DWORD     dwErr = NO_ERROR, i;
    LPCWSTR   p;
    HRESULT   hr;
    LPCWSTR   pwszMachineName = NULL;
    LPCWSTR   pwszUserName    = NULL;
    LPCWSTR   pwszPassword    = NULL;
    WCHAR     szPasswordPrompt[MAX_PATH];

    if ((g_hModule = GetModuleHandle(NULL)) is NULL)
    {
        PRINT1("GetModuleHandle failed");
        return 1;
    }

    swprintf(RtmonPrompt, L"%s>", STRING_NETSH);

    //
    // Initialize the Alias Table
    //

    dwErr = ATInitTable();

    if (dwErr isnot NO_ERROR)
    {
        return 0;
    }

    // Initialize the root helper
    AddDllEntry(L"", L"netsh.exe");

    //
    // Load information about the helpers from the registry.
    //

    LoadDllInfoFromRegistry();
    
    // Need to set the Ctrl Handler so it can catch the Ctrl C and close window events.
    // This is done so the helper dlls can properly be unloaded. 
    //
    SetConsoleCtrlHandler(HandlerRoutine,
                          TRUE);

    //
    // Set TEB's language ID to correspond to the console output code page.  This
    // will ensure the correct language message is displayed when FormatMessage is
    // called.
    // 
    SetThreadCodePage();

    for ( i = 1; i < (DWORD) argc; i++ )
    {
        if (_wcsicmp(argv[i], L"-?")==0 ||
            _wcsicmp(argv[i], L"-h")==0 ||
            _wcsicmp(argv[i], L"?" )==0 ||
            _wcsicmp(argv[i], L"/?")==0)
        {
            (VOID) UpdateVersionInfoGlobals(NULL, NULL, NULL);
            // deonb: If this fails we want to restrict the helper from showing up in the context - ignoring
            // the return value will accomplish this.
        
            PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
            ProcessCommand(L"?", &bDone);

            // Need to free the helper DLLs before we exit
            //
            FreeHelpers();
            FreeDlls();
            return 1;
        }

        if (_wcsicmp(argv[i], L"-v") == 0)
        {
            g_bVerbose = TRUE;
            continue;
        }
        
        if (_wcsicmp(argv[i], L"-a") == 0)
        {
            //
            // alias file
            //
            if (i + 1 >= (DWORD)argc)
            {
                PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            else
            {
                pwszArgAlias = argv[i+1];
                i++;
                continue;
            }
        }

        if (_wcsicmp(argv[i], L"-c") == 0)
        {
            //
            // starting context
            //
            if (i + 1 >= (DWORD)argc)
            {
                PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            else
            {
                wcscpy(pwszArgContext, argv[i+1]);
                i++;
                continue;
            }
        }

        if (_wcsicmp(argv[i], L"-f") == 0)
        {
            //
            // command to run
            //
            if (i + 1 >= (DWORD)argc)
            {
                PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            else
            {
                pwszArgScript = argv[i+1];
                i++;
                bOnce = TRUE;
                continue;
            }
        }
        
#ifdef ALLOW_REMOTES
        if (_wcsicmp(argv[i], L"-r") == 0)
        {
            //
            // router name
            //
            if (i + 1 >= (DWORD)argc)
            {
                PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            else
            {
                if (wcslen(argv[i+1]))
                {
                    pwszMachineName = argv[i+1];
                }

                i++;
                continue;
            }
        }

        if (_wcsicmp(argv[i], L"-u") == 0)
        {
            //
            // user name
            //
            if (i + 1 >= (DWORD)argc)
            {
                PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            else
            {
                if (wcslen(argv[i+1]))
                {
                    pwszUserName = argv[i+1];
                }

                i++;
                continue;
            }
        }

    if (_wcsicmp(argv[i], L"-p") == 0)
    {
        //
        // password
        //
        if (i + 1 >= (DWORD)argc)
        {
            PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        else
        {
            if (wcslen(argv[i+1]))
            {
                pwszPassword = argv[i+1];
            }

            i++;
            continue;
        }
    }
#endif

        if (!bOnce)
        {
            while (i < (DWORD)argc)
            {
                if (pwszCmdLine[0])
                {
                    wcscat(pwszCmdLine, L" ");
                }

                p = argv[i];

                if (!p[0] || wcschr(argv[i], L' '))
                {
                    wcscat(pwszCmdLine, L"\"");
                    wcscat(pwszCmdLine, p);
                    wcscat(pwszCmdLine, L"\"");
                }
                else
                {
                    wcscat(pwszCmdLine, p);
                }

                i++;
            }
        }
        else
        {
            PrintMessageFromModule(g_hModule, MSG_NETSH_USAGE, argv[0]);
            dwErr = ERROR_INVALID_SYNTAX;
        }
        break;
    }
        
    do 
    {
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        if (pwszMachineName)
        {
            if (pwszPassword && _wcsicmp(pwszPassword, L"*") == 0)
            {
                DWORD  dwLen = 0;
                PrintMessageFromModule(g_hModule, MSG_NETSH_LOGIN_PASSWORD, pwszMachineName);
                if (0 != GetPasswdStr(szPasswordPrompt, MAX_PATH, &dwLen))
                {
                    dwErr = ERROR_INVALID_SYNTAX;
                    break;
                }
                else
                {
                    pwszPassword = szPasswordPrompt;
                }
            }

            dwErr = SetMachine( pwszMachineName, pwszUserName, pwszPassword );
            if (dwErr isnot NO_ERROR)
            {
                PrintMessageFromModule(g_hModule, dwErr);
                break;
            }
        }

        if (!g_pwszRouterName) 
        {
            hr = UpdateVersionInfoGlobals(NULL, NULL, NULL); // Update the info for the local machine
            if (FAILED(hr))
            {
                if (g_pwszRouterName)
                {
                    PrintMessageFromModule(g_hModule, MSG_WARN_COULDNOTVERCHECKHOST,  g_pwszRouterName);
                }
                else
                {
                    TCHAR szComputerName[MAX_PATH];
                    DWORD dwComputerNameLen = MAX_PATH;
                    GetComputerName(szComputerName, &dwComputerNameLen);
                    PrintMessageFromModule(g_hModule, MSG_WARN_COULDNOTVERCHECKHOST,  szComputerName);
                }
                PrintError(NULL, hr);
            }
        }

        if (pwszArgAlias)
        {
            dwErr = LoadScriptFile(pwszArgAlias);
            if (dwErr)
            {
                break;
            }
        }

        if (pwszArgContext[0] != L'\0')
        {
            // The context switch command should be processed in
            // interactive mode (which is the only time a context
            // switch is legal).
    
            g_bInteractive = TRUE;
            dwErr = ProcessCommand(pwszArgContext, &bDone);
            g_bInteractive = FALSE;
            if (dwErr)
            {
                break;
            }
        }

        if (pwszCmdLine[0] != L'\0')
        {
            g_bQuiet       = FALSE; // Bug# 262183
            dwErr = ProcessCommand(pwszCmdLine, &bDone);
            break;
        }

        if (pwszArgScript)
        {
            g_bInteractive = TRUE;
            dwErr = LoadScriptFile(pwszArgScript);
            break;
        }
         
        g_bInteractive = TRUE;
        g_bQuiet       = FALSE;

        // Main command loop
        dwErr = MainCommandLoop(stdin, TRUE);
    
    } while (FALSE);

    //
    // Clean up
    //
    DisconnectFromCurrentRouter();
    FreeHelpers();
    FreeDlls();
    FreeAliasTable();

    if(g_pwszRouterName)
    {
        FREE(g_pwszRouterName);

        g_pwszRouterName = NULL;
    }

    // Return 1 on error, 0 if not
    return (dwErr isnot NO_ERROR);
}

int _cdecl
wmain(
    int     argc,
    WCHAR   *argv[]
    )
/*++

Routine Description:

    The main function.

Arguments:

Return Value:

--*/
{
    HANDLE                     hStdOut;
    DWORD                      dwRet;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    WORD                       oldXSize;
    char                       buff[256];
    WSADATA                    wsaData;
    HRESULT                    hr;

#if 0
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    
    if (hStdOut is INVALID_HANDLE_VALUE)
    {
        PRINT1("Standard output could not be opened.");
        return 0;
    }

    GetConsoleScreenBufferInfo(hStdOut, &csbi);
    
    oldXSize = csbi.dwSize.X;
    csbi.dwSize.X = 120;
    SetConsoleScreenBufferSize(hStdOut, csbi.dwSize);
#endif

#if 0
    WSAStartup(MAKEWORD(2,0), &wsaData);
    if (!gethostname(buff, sizeof(buff)))
    {
        g_pwszRouterName = MALLOC( (strlen(buff)+1) * sizeof(WCHAR) );
        swprintf(g_pwszRouterName, L"%hs", buff);
    }
#endif
    
    dwRet = MainFunction(argc, argv);
    
#if 0
    GetConsoleScreenBufferInfo(hStdOut, &csbi);
    
    csbi.dwSize.X = oldXSize;
    SetConsoleScreenBufferSize(hStdOut, csbi.dwSize);
    CloseHandle(hStdOut);
#endif

    return dwRet;
}

BOOL
IsLocalCommand(
    IN LPCWSTR pwszCmd,
    IN DWORD   dwSkipFlags
    )
/*++
Arguments:
    pwszCmd     - string to see if it matches a command
    dwSkipFlags - any commands with these flags will be ignored.
                  This is the opposite semantics of the "dwDisplayFlags"
                  parameter used elsewhere (dwSkipFlags = ~dwDisplayFlags)
--*/
{
    DWORD i, dwErr;
    PCNS_CONTEXT_ATTRIBUTES pContext, pSubContext;
    PNS_HELPER_TABLE_ENTRY         pHelper;

    dwErr = GetRootContext( &pContext, &pHelper );
    if (dwErr)
    {
        return FALSE;
    }

    for (i=0; i<g_ulNumShellCmds; i++)
    {
        if (!(g_ShellCmds[i].dwFlags & dwSkipFlags)
         && !_wcsicmp( pwszCmd, 
                       g_ShellCmds[i].pwszCmdToken ))
        {
            return TRUE;
        }
    }

    for (i=0; i<g_ulNumGroups; i++)
    {
        if (!(g_ShellCmdGroups[i].dwFlags & dwSkipFlags)
         && !_wcsicmp( pwszCmd, 
                       g_ShellCmdGroups[i].pwszCmdGroupToken ))
        {
            return TRUE;
        }
    }

    for (i=0; i<pHelper->ulNumSubContexts; i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)
          (pHelper->pSubContextTable + i*pHelper->ulSubContextSize);

        if (!(pSubContext->dwFlags & dwSkipFlags)
         && !_wcsicmp( pwszCmd,
                       pSubContext->pwszContext))
        {
            return TRUE;
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\reghlp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\shell\reghlp.h

Abstract:

    Include for reghlp.c

Revision History:

    Anand Mahalingam          7/6/98  Created

--*/

typedef struct _NS_DLL_TABLE_ENTRY
{
    //
    // Name of the DLL servicing the context
    //

    LPWSTR                  pwszDLLName; // Corresponding DLL

    //
    // Registry value used for this DLL
    //

    LPWSTR                  pwszValueName;

    //
    // TRUE if loaded
    //

    BOOL                    bLoaded;                   // In memory or not

    //
    // Handle to DLL instance if loaded
    //

    HANDLE                  hDll;                      // DLL handle if loaded

    //
    // Function to stop this DLL
    //

    PNS_DLL_STOP_FN         pfnStopFn;

} NS_DLL_TABLE_ENTRY,*PNS_DLL_TABLE_ENTRY;

typedef struct _NS_HELPER_TABLE_ENTRY
{
    NS_HELPER_ATTRIBUTES    nha;
    //
    // GUID associated with the parent helper
    //

    GUID                    guidParent;

    //
    // Index of the DLL implementing the helper
    //

    DWORD                   dwDllIndex;

    //
    // TRUE if started
    //

    BOOL                    bStarted;

    // Number of subcontexts

    ULONG                    ulNumSubContexts;

    // Array of subcontexts

    PBYTE                    pSubContextTable;

    // Size of a subcontext entry

    ULONG                    ulSubContextSize;

}NS_HELPER_TABLE_ENTRY,*PNS_HELPER_TABLE_ENTRY;

//
// Function Prototypes
//
VOID
LoadDllInfoFromRegistry(
    VOID
    );

DWORD
GetContextEntry(
    IN    PNS_HELPER_TABLE_ENTRY   pHelper,
    IN    LPCWSTR                  pwszContext,
    OUT   PCNS_CONTEXT_ATTRIBUTES *ppContext
    );

DWORD
GetHelperAttributes(
    IN    DWORD               dwIndex,
    OUT   PHELPER_ENTRY_FN    *ppfnEntryPt
    );

DWORD
PrintHelperHelp(
    DWORD   dwDisplayFlags
    );

DWORD
DumpSubContexts(
    IN  PNS_HELPER_TABLE_ENTRY pHelper,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    );

DWORD
CallCommit(
    IN    DWORD    dwAction,
    OUT   PBOOL    pbCommit
    );

DWORD
FreeHelpers(
	VOID
	);

DWORD
FreeDlls(
	VOID
	);

DWORD
UninstallTransport(
    IN    LPCWSTR   pwszTransport
    );

DWORD
InstallTransport(
    IN    LPCWSTR   pwszTransport,
    IN    LPCWSTR   pwszConfigDll,
    IN    LPCWSTR   pwszInitFnName
    );

extern BOOL                    g_bCommit;

DWORD
GetHelperEntry(
    IN    CONST GUID             *pGuid,
    OUT   PNS_HELPER_TABLE_ENTRY *ppHelper
    );

DWORD
GetRootContext(
    OUT PCNS_CONTEXT_ATTRIBUTES        *ppContext,
    OUT PNS_HELPER_TABLE_ENTRY         *ppHelper
    );

extern PNS_HELPER_TABLE_ENTRY         g_CurrentHelper;
extern PCNS_CONTEXT_ATTRIBUTES        g_CurrentContext;

DWORD
GetDllEntry(
    IN    DWORD                dwDllIndex,
    OUT   PNS_DLL_TABLE_ENTRY *ppDll
    );

DWORD
DumpContext(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    );

DWORD
GetParentContext(
    IN  PCNS_CONTEXT_ATTRIBUTES  pChild,
    OUT PCNS_CONTEXT_ATTRIBUTES *ppParent
    );

DWORD
AppendFullContextName(
    IN  PCNS_CONTEXT_ATTRIBUTES pContext,
    OUT LPWSTR                 *pwszContextName
    );

DWORD
AddDllEntry(
    LPCWSTR pwszValueName,
    LPCWSTR pwszConfigDll
    );

BOOL VerifyOsVersion(IN PNS_OSVERSIONCHECK pfnVersionCheck);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\utils.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\shell\utils.h

Abstract:

    Include for utils.c

Revision History:

        6/12/96     V Raman

--*/

#define IsHelpToken(pwszToken)\
    (MatchToken(pwszToken, CMD_HELP1)  \
    || MatchToken(pwszToken, CMD_HELP2))


typedef struct _EVENT_PRINT_INFO
{
    LPCWSTR  pwszLogName;
    LPCWSTR  pwszComponent;
    LPCWSTR  pwszSubComponent;
    DWORD    fFlags;
    DWORD    dwHistoryContext;
    ULONG    ulEventCount;
    PDWORD   pdwEventIds;
    PNS_EVENT_FILTER    pfnEventFilter;
    LPCVOID  pvFilterContext;
    
} EVENT_PRINT_INFO, *PEVENT_PRINT_INFO;
    
DWORD
DisplayMessageM(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

DWORD GetPasswdStr(IN LPTSTR  buf,
                   IN DWORD   buflen,
                   IN PDWORD  len);

LPWSTR
OEMfgets(
    OUT PDWORD  pdwLen,
    IN  FILE   *fp
    );
//
// Event log printing related functions
//

#define EVENT_MSG_KEY_W L"System\\CurrentControlSet\\Services\\EventLog\\"
#define EVENT_MSG_FILE_VALUE_W  L"EventMessageFile"

DWORD
SetupEventLogSeekPtr(
    OUT PHANDLE             phEventLog,
    IN  PEVENT_PRINT_INFO   pEventInfo
    );

BOOL
IsOurRecord(
    IN  EVENTLOGRECORD      *pRecord,
    IN  PEVENT_PRINT_INFO   pEventInfo
    );

DWORD
DisplayContextHelp(
    IN  PCNS_CONTEXT_ATTRIBUTES    pContext,
    IN  DWORD                      dwDisplayFlags,
    IN  DWORD                      dwCmdFlags,
    IN  DWORD                      dwArgsRemaining,
    IN  LPCWSTR                    pwszGroup
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\utils.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\shell\utils.c

Abstract:

    Utilities.

Revision History:

    6/12/96     V Raman

--*/

#include "precomp.h"

#include <wincon.h>
#include <winbase.h>

#define STOP_EVENT   L"NetshStopRefreshEvent"

extern HANDLE   g_hModule;

BOOL
WINAPI
MatchCmdLine(
    IN  LPWSTR  *ppwcArguments,
    IN  DWORD    dwArgCount,
    IN  LPCWSTR  pwszCmdToken,
    OUT PDWORD   pdwNumMatched
    )
{
    LPCWSTR pwcToken;
    DWORD   dwCount;
    WCHAR   wcszBuffer[256];

    //
    // Compare the two strings
    //

    dwCount = 0;

    if (!ppwcArguments || !pwszCmdToken || !pdwNumMatched)
    {
        return FALSE;
    }
    *pdwNumMatched = 0; // init OUT parameter

    if ( (wcslen(pwszCmdToken) + 1) > (sizeof(wcszBuffer)/sizeof(wcszBuffer[0])) )
    {
        // incoming command string is too large for processing
        
        return FALSE;
    }
    // copy into a buffer which wcstok can munge
    wcscpy(wcszBuffer, pwszCmdToken);

    if((pwcToken = wcstok(wcszBuffer,
                          NETSH_CMD_DELIMITER)) != NULL)
    {
        do
        {
            if (dwCount < dwArgCount &&
                (_wcsnicmp(ppwcArguments[dwCount],
                           pwcToken,
                           wcslen(ppwcArguments[dwCount])) == 0))
            {
                dwCount++;
            }
            else
            {

                return FALSE;
            }

        } while((pwcToken = wcstok((LPWSTR) NULL, NETSH_CMD_DELIMITER )) != NULL);
    }

    *pdwNumMatched = dwCount;

    return TRUE;
}

#if 0
BOOL
WINAPI
MatchCmdTokenId(
    IN  HANDLE   hModule,
    IN  LPCWSTR  *ppwcArguments,
    IN  DWORD    dwArgCount,
    IN  DWORD    dwCmdId,
    OUT PDWORD   pdwNumMatched
    )

/*++

Routine Description:

    Tries to match a command in the given command line.
    The function takes the id of the command of the command message.
    A command message consists of command words separated by white space.
    The function tokenises this messages into separate words and then
    tries to match the first N arguments against the N separate tokens that
    constitute the command.
    e.g if the command is "add if neighbour" - the function will generate
    3 tokens "add" "if" and "neighbour". It will then try and match the
    all these to the given arg array.


Arguments:

    ppwcArguments - Argument array
    dwArgCount    - Number of arguments
    dwTokenId     - Token Id of command
    pdwNumMatched - Number of arguments matched in the array

Return Value:

    TRUE if matched else FALSE

--*/

{

    WCHAR   pwszTemp[NETSH_MAX_CMD_TOKEN_LENGTH];
    LPCWSTR pwcToken;
    DWORD   dwCount;

    if(!LoadStringW(hModule,
                    dwCmdId,
                    pwszTemp,
                    NETSH_MAX_CMD_TOKEN_LENGTH) )
    {
        return FALSE;
    }

    //
    // Compare the two strings
    //

    dwCount = 0;

    if((pwcToken = wcstok(pwszTemp,
                          NETSH_CMD_DELIMITER)) != NULL)
    {
        do
        {
            if (dwCount < dwArgCount &&
                (_wcsnicmp(ppwcArguments[dwCount],
                           pwcToken,
                           wcslen(ppwcArguments[dwCount])) == 0))
            {
                dwCount++;
            }
            else
            {
                *pdwNumMatched = 0;

                return FALSE;
            }

        } while((pwcToken = wcstok((LPCWSTR) NULL, NETSH_CMD_DELIMITER )) != NULL);
    }

    *pdwNumMatched = dwCount;

    return TRUE;
}
#endif


DWORD
WINAPI
MatchEnumTag(
    IN  HANDLE             hModule,
    IN  LPCWSTR            pwcArg,
    IN  DWORD              dwNumArg,
    IN  CONST TOKEN_VALUE *pEnumTable,
    OUT PDWORD             pdwValue
    )

/*++

Routine Description:

    Used for options that take a specific set of values. Matches argument
    with the set of values specified and returns corresponding value.

Arguments:

    pwcArg - Argument
    dwNumArg - Number of possible values.

Return Value:

    NO_ERROR
    ERROR_NOT_FOUND

--*/

{
    DWORD      i;

    if ( (!pdwValue) || (!pEnumTable) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    for (i = 0; i < dwNumArg; i++)
    {
        if (MatchToken(pwcArg,
                       pEnumTable[i].pwszToken))
        {
            *pdwValue = pEnumTable[i].dwValue;

            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

DWORD
MatchTagsInCmdLine(
    IN      HANDLE      hModule,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN OUT  PTAG_TYPE   pttTagToken,
    IN      DWORD       dwNumTags,
    OUT     PDWORD      pdwOut
    )

/*++

Routine Description:

    Identifies each argument based on its tag.
    It also removes tag= from each argument.
    It also sets the bPresent flag in the tags present.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument, where
                     pdwOut[0] is for ppwcArguments[dwCurrentIndex]

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG

--*/

{
    DWORD      i,j,len;
    LPCWSTR    pwcTag;
    LPWSTR     pwcTagVal, pwszArg;
    BOOL       bFound = FALSE;
    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        if (!wcspbrk(ppwcArguments[i], NETSH_ARG_DELIMITER))
        {
            pdwOut[i - dwCurrentIndex] = (DWORD) -2;
            continue;
        }

        len = wcslen(ppwcArguments[i]);

        if (len is 0)
        {
            //
            // something wrong with arg
            //

            pdwOut[i - dwCurrentIndex] = (DWORD) -1;
            continue;
        }

        pwszArg = HeapAlloc(GetProcessHeap(),0,(len + 1) * sizeof(WCHAR));

        if (pwszArg is NULL)
        {
            PrintMessageFromModule(g_hModule, MSG_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        //

        pwcTagVal = wcstok((LPWSTR)NULL,  NETSH_ARG_DELIMITER);

        if (pwcTagVal is NULL)
        {
            PrintMessageFromModule(g_hModule, ERROR_NO_TAG, ppwcArguments[i]);
            HeapFree(GetProcessHeap(),0,pwszArg);
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //

        bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (MatchToken(pwcTag, pttTagToken[j].pwszTag))
            {
                //
                // Tag matched
                //

                if (pttTagToken[j].bPresent
                 && !(pttTagToken[j].dwRequired & NS_REQ_ALLOW_MULTIPLE))
                {
                    HeapFree(GetProcessHeap(),0,pwszArg);

                    PrintMessageFromModule(g_hModule, ERROR_TAG_ALREADY_PRESENT, pwcTag);
                    return ERROR_TAG_ALREADY_PRESENT;
                }

                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                pttTagToken[j].bPresent = TRUE;
                break;
            }
        }

        if (bFound)
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            PrintMessageFromModule(g_hModule, ERROR_INVALID_OPTION_TAG, pwcTag);
            HeapFree(GetProcessHeap(),0,pwszArg);
            return ERROR_INVALID_OPTION_TAG;
        }

        HeapFree(GetProcessHeap(),0,pwszArg);
    }

    // Now tag all untagged arguments

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        if ( pdwOut[i - dwCurrentIndex] != -2)
        {
            continue;
        }

        bFound = FALSE;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (!pttTagToken[j].bPresent)
            {
                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                pttTagToken[j].bPresent = TRUE;
                break;
            }
        }

        if (!bFound)
        {
            pdwOut[i - dwCurrentIndex] = (DWORD) -1;
        }
    }
    return NO_ERROR;
}

BOOL
WINAPI
MatchToken(
    IN  LPCWSTR  pwszUserToken,
    IN  LPCWSTR  pwszCmdToken
    )
{
    if ( (!pwszUserToken) || (!pwszCmdToken) )
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    return !_wcsnicmp(pwszUserToken,
                      pwszCmdToken,
                      wcslen(pwszUserToken));
}


BOOL
WINAPI
MatchTokenId( // changed this name since I don't think anything will use it
    IN  HANDLE  hModule,
    IN  LPCWSTR pwszToken,
    IN  DWORD   dwTokenId
    )

/*++

Routine Description:

    Sees if the given string and the string corresponding to dwTokenId
    are the same.

Arguments:

    pwszToken - Token string
    dwTokenId - Token Id

Return Value:

    TRUE is matched else FALSE

--*/

{

    WCHAR   pwszTemp[NETSH_MAX_TOKEN_LENGTH];

    if(!LoadStringW(hModule,
                    dwTokenId,
                    pwszTemp,
                    NETSH_MAX_TOKEN_LENGTH))
    {
        return FALSE;
    }

    return MatchToken(pwszToken, pwszTemp);
}

extern HANDLE g_hLogFile;

//+--------------------------------------------------------------------------
//
//  Function:   GetPasswdStr
//
//  Synopsis:   Reads a password string from stdin without echoing the keystrokes
//
//  Arguments:  [buf - OUT]    : buffer to put string in
//              [buflen - IN]  : size of the buffer
//              [&len - OUT]   : length of the string placed into the buffer
//
//  Returns:    DWORD : 0 or ERROR_INSUFFICIENT_BUFFER if user typed too much.
//                      Buffer contents are only valid on 0 return.
//
//  History:    07-Dec-2001   deonb     Copied from dscmd parseutil.cpp sources
//              07-Sep-2000   JeffJon   Created 
//
//---------------------------------------------------------------------------
#define CR              0xD
#define BACKSPACE       0x8

DWORD GetPasswdStr(IN LPTSTR  buf,
                   IN DWORD   buflen,
                   IN PDWORD  len)
{
    TCHAR    ch;
    TCHAR    *bufPtr = buf;
    DWORD    c;
    int      err;
    DWORD    mode;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;               /* GP fault probe (a la API's) */
    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) 
    {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) 
        {  /* back up one or two */
           /*
           * IF bufPtr == buf then the next two lines are
           * a no op.
           */
           if (bufPtr != buf) 
           {
                bufPtr--;
                (*len)--;
           }
        }
        else 
        {
            *bufPtr = ch;

            if (*len < buflen) 
                bufPtr++ ;                   /* don't overflow buf */
            (*len)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = TEXT('\0');         /* null terminate the string */
    putwchar(TEXT('\n'));

    return ((*len <= buflen) ? 0 : ERROR_INSUFFICIENT_BUFFER);
}

LPWSTR
OEMfgets(
    OUT PDWORD  pdwLen,
    IN  FILE   *fp
    )
{
    LPWSTR  pwszUnicode;
    DWORD   dwErr = NO_ERROR;
    DWORD   dwLen;
    CHAR    buff[MAX_CMD_LEN];

    fflush(stdout);
    if (fgets( buff, sizeof(buff), fp ) is NULL)
    {
        return NULL;
    }

    dwLen = MultiByteToWideChar( GetConsoleOutputCP(),
                                 0,
                                 buff,
                                 -1,
                                 NULL,
                                 0 );

    if (g_hLogFile)
    {
        DWORD dwWritten;
        CHAR  szCrLf[] = "\r\n";
        if (0 == WriteFile( g_hLogFile, buff, dwLen-2, &dwWritten, NULL ))
        {
            CloseHandle(g_hLogFile);
            g_hLogFile = NULL;
            PrintError(NULL, GetLastError());
        }
        if (0 == WriteFile( g_hLogFile, szCrLf, 2, &dwWritten, NULL ))
        {
            CloseHandle(g_hLogFile);
            g_hLogFile = NULL;
            PrintError(NULL, GetLastError());
        }
    }

    pwszUnicode = MALLOC(dwLen * sizeof(WCHAR));
    if (pwszUnicode)
    {
        MultiByteToWideChar( GetConsoleOutputCP(),
                             0,
                             buff,
                             sizeof(buff),
                             pwszUnicode,
                             dwLen );
    }

    *pdwLen = dwLen;
    return pwszUnicode;
}

VOID
OEMfprintf(
    IN  HANDLE  hHandle,
    IN  LPCWSTR pwszUnicode
    )
{
    PCHAR achOem;
    DWORD dwLen, dwWritten;

    dwLen = WideCharToMultiByte( GetConsoleOutputCP(),
                         0,
                         pwszUnicode,
                         -1,
                         NULL,
                         0,
                         NULL,
                         NULL );

    achOem = MALLOC(dwLen);
    if (achOem)
    {
        WideCharToMultiByte( GetConsoleOutputCP(),
                             0,
                             pwszUnicode,
                             -1,
                             achOem,
                             dwLen,
                             NULL,
                             NULL );

        WriteFile( hHandle, achOem, dwLen-1, &dwWritten, NULL );

        if (g_hLogFile)
        {
            if (0 == WriteFile( g_hLogFile, achOem, dwLen-1, &dwWritten, NULL ))
            {
                CloseHandle(g_hLogFile);
                g_hLogFile = NULL;
                PrintError(NULL, GetLastError());
            }
        }

        FREE(achOem);
    }
}

#define OEMprintf(pwszUnicode) \
    OEMfprintf( GetStdHandle(STD_OUTPUT_HANDLE), pwszUnicode)

LPWSTR
WINAPI
GetEnumString(
    IN  HANDLE          hModule,
    IN  DWORD           dwValue,
    IN  DWORD           dwNumVal,
    IN  PTOKEN_VALUE    pEnumTable
    )
/*++

Routine Description:

    This routine looks up the value specified, dwValue, in the Value table
    pEnumTable and returns the string corresponding to the value


Arguments :

    hModule - handle to current module

    dwValue - Value whose display string is required

    dwNumVal - Number of elements in pEnumTable

    pEnumTable - Table of enumerated value and corresp. string IDs


Return Value :

    NULL - Value not found in pEnumTable

    Pointer to string on success

--*/
{
    DWORD dwInd;

    for ( dwInd = 0; dwInd < dwNumVal; dwInd++ )
    {
        if ( pEnumTable[ dwInd ].dwValue == dwValue )
        {
            // ISSUE: const_cast
            return (LPWSTR)pEnumTable[ dwInd ].pwszToken;
        }
    }

    return NULL;
}


LPWSTR
WINAPI
MakeString(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    )

{
    DWORD        dwMsgLen;
    LPWSTR       pwszInput, pwszOutput = NULL;
    va_list      arglist;


    do
    {
        va_start( arglist, dwMsgId );

        pwszInput = HeapAlloc(GetProcessHeap(),
                              0,
                              MAX_MSG_LENGTH * sizeof(WCHAR) );

        if ( pwszInput == NULL )
        {
            break;
        }

        if ( !LoadStringW(hModule,
                          dwMsgId,
                          pwszInput,
                          MAX_MSG_LENGTH) )
        {
            break;
        }

        FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                       pwszInput,
                       0,
                       0L,         // Default country ID.
                       (LPWSTR)&pwszOutput,
                       0,
                       &arglist);

    } while ( FALSE );

    if ( pwszInput ) { HeapFree( GetProcessHeap(), 0, pwszInput ); }

    return pwszOutput;
}

VOID
WINAPI
FreeString(
    IN  LPWSTR pwszMadeString
    )

/*++

Routine Description:

    Frees string allocated by make string.

Arguments:

Return Value:

--*/

{
    LocalFree( pwszMadeString );
}

LPWSTR
WINAPI
MakeQuotedString(
    IN  LPCWSTR pwszOrigString
    )
{
    LPWSTR pwszNewString;

    pwszNewString = HeapAlloc(GetProcessHeap(),
                              0,
                              (wcslen(pwszOrigString) + 3) * sizeof(WCHAR));

    if(pwszNewString == NULL)
    {
        return NULL;
    }

    wsprintfW(pwszNewString, L"\"%s\"",pwszOrigString);

    pwszNewString[wcslen(pwszOrigString) + 2] = UNICODE_NULL;

    return pwszNewString;
}

VOID
WINAPI
FreeQuotedString(
    LPWSTR pwszString
    )
{
    HeapFree(GetProcessHeap(),
             0,
             pwszString);
}

DWORD
PrintError(
    IN  HANDLE  hModule, OPTIONAL
    IN  DWORD   dwErrId,
    ...
    )


/*++

Routine Description:

    Displays an error message.
    We first search for the error code in the module specified by the caller
    (if one is specified)
    If no module is given, or the error code doesnt exist we look for MPR
    errors, RAS errors and Win32 errors - in that order

Arguments:

    hModule   - Module to load the string from
    dwMsgId   - Message to be printed
    ...       - Insert strings

Return Value:

    Message length

--*/

{
    DWORD        dwMsgLen;
    LPWSTR       pwszOutput = NULL;
    WCHAR        rgwcInput[MAX_MSG_LENGTH + 1];
    va_list      arglist;

    va_start(arglist, dwErrId);

    if(hModule)
    {
        if(LoadStringW(hModule,
                       dwErrId,
                       rgwcInput,
                       MAX_MSG_LENGTH))
        {
            //
            // Found the message in the callers module
            //

            dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |FORMAT_MESSAGE_FROM_STRING,
                                      rgwcInput,
                                      0,
                                      0L,
                                      (LPWSTR)&pwszOutput,
                                      0,
                                      &arglist);

            if(dwMsgLen == 0)
            {
                ASSERT(pwszOutput == NULL);
            }
            else
            {
                OEMprintf(pwszOutput);

                LocalFree(pwszOutput);

                return dwMsgLen;
            }
        }
        else
        {
            return 0;
        }
    }

    //
    // Next try, local errors
    //

    if((dwErrId > NETSH_ERROR_BASE) &&
       (dwErrId < NETSH_ERROR_END))
    {
        if(LoadStringW(g_hModule,
                       dwErrId,
                       rgwcInput,
                       MAX_MSG_LENGTH))
        {
            //
            // Found the message in our module
            //

            dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |FORMAT_MESSAGE_FROM_STRING,
                                      rgwcInput,
                                      0,
                                      0L,
                                      (LPWSTR)&pwszOutput,
                                      0,
                                      &arglist);

            if(dwMsgLen == 0)
            {
                ASSERT(pwszOutput == NULL);
            }
            else
            {
                OEMprintf(pwszOutput);

                LocalFree(pwszOutput);

                return dwMsgLen;
            }
        }
    }

    //
    // Next try MPR errors
    //

    if (MprAdminGetErrorString(dwErrId,
                              &pwszOutput) == NO_ERROR)
    {
        wcscpy(rgwcInput, pwszOutput);
        LocalFree(pwszOutput);

        wcscat(rgwcInput, L"\r\n");
        OEMprintf(rgwcInput);
        
        dwMsgLen = wcslen(rgwcInput);

        return dwMsgLen;
    }

    //
    // Next try RAS errors
    //

    if (RasGetErrorStringW(dwErrId,
                          rgwcInput,
                          MAX_MSG_LENGTH) == NO_ERROR)
    {
        wcscat(rgwcInput, L"\r\n");

        OEMprintf(rgwcInput);

        dwMsgLen = wcslen(rgwcInput);
        return dwMsgLen;
    }

    //
    // Finally try Win32
    //

    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwErrId,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              rgwcInput,
                              MAX_MSG_LENGTH,
                              &arglist);

    if(dwMsgLen)
    {
        OEMprintf(rgwcInput);

        return dwMsgLen;
    }
    
    return 0;
}

DWORD
DisplayMessageVA(
    IN  LPCWSTR  pwszFormat,
    IN  va_list *parglist
    )
{
    DWORD        dwMsgLen = 0;
    LPWSTR       pwszOutput = NULL;

    do
    {
        dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                   |FORMAT_MESSAGE_FROM_STRING,
                                  pwszFormat,
                                  0,
                                  0L,         // Default country ID.
                                  (LPWSTR)&pwszOutput,
                                  0,
                                  parglist);

        if(dwMsgLen == 0)
        {
            // ISSUE: Unlocalized string.
            wprintf( L"Error %d in FormatMessageW()\n", GetLastError());

            ASSERT(pwszOutput == NULL);

            break;
        }

        OEMprintf( pwszOutput );

    } while ( FALSE );

    if ( pwszOutput) { LocalFree( pwszOutput ); }

    return dwMsgLen;
}

DWORD
PrintMessage(
    IN  LPCWSTR rgwcInput,
    ...
    )
{
    DWORD        dwMsgLen = 0;
    LPCWSTR      pwszOutput = NULL;
    va_list      arglist;

    va_start(arglist, rgwcInput);

    if (!rgwcInput)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return DisplayMessageVA(rgwcInput, &arglist);
}

DWORD
PrintMessageFromModule(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    )
{
    WCHAR        rgwcInput[MAX_MSG_LENGTH + 1];
    va_list      arglist;

    if ( !LoadStringW(hModule,
                      dwMsgId,
                      rgwcInput,
                      MAX_MSG_LENGTH) )
    {
        return 0;
    }

    va_start(arglist, dwMsgId);

    return DisplayMessageVA(rgwcInput, &arglist);
}

DWORD
DisplayMessageM(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    )
{
    DWORD        dwMsgLen;
    LPWSTR       pwszOutput = NULL;
    va_list      arglist;

    do
    {
        va_start(arglist, dwMsgId);

        dwMsgLen = FormatMessageW(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_HMODULE,
                        hModule,
                        dwMsgId,
                        0L,
                        (LPWSTR)&pwszOutput,
                        0,
                        &arglist
                        );

        if(dwMsgLen == 0)
        {
            DWORD   dwErr;

            dwErr = GetLastError();

            ASSERT(pwszOutput == NULL);

            break;
        }

        OEMprintf( pwszOutput );

    } while ( FALSE );

    if ( pwszOutput) { LocalFree( pwszOutput ); }

    return dwMsgLen;
}

DWORD
DisplayMessageToConsole(
    IN  HANDLE  hModule,
    IN  HANDLE  hConsole,
    IN  DWORD   dwMsgId,
    ...
    )
{
    DWORD       dwMsgLen = 0;
    LPWSTR      pwszInput, pwszOutput = NULL;
    va_list     arglist;
    DWORD       dwNumWritten;

    do
    {
        va_start(arglist, dwMsgId);

        pwszInput = HeapAlloc(GetProcessHeap(),
                              0,
                              MAX_MSG_LENGTH * sizeof(WCHAR));

        if ( pwszInput == (LPCWSTR) NULL )
        {
            break;
        }

        if ( !LoadStringW(hModule,
                          dwMsgId,
                          pwszInput,
                          MAX_MSG_LENGTH) )
        {
            break;
        }

        dwMsgLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                                  pwszInput,
                                  0,
                                  0L,         // Default country ID.
                                  (LPWSTR)&pwszOutput,
                                  0,
                                  &arglist);

        if ( dwMsgLen == 0 )
        {
            break;
        }

        OEMfprintf( hConsole, pwszOutput );

        fflush(stdout);

    } while ( FALSE );

    if ( pwszInput ) { HeapFree( GetProcessHeap(), 0, pwszInput ); }
    if ( pwszOutput) { LocalFree( pwszOutput ); }

    return dwMsgLen;
}


BOOL
WINAPI
HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    )
{
    HANDLE hStop;

    if (dwCtrlType == CTRL_C_EVENT)
    {
        hStop = OpenEvent(EVENT_ALL_ACCESS,
                          FALSE,
                          STOP_EVENT);
        
        if (hStop isnot NULL)
        {
            SetEvent(hStop);

            CloseHandle(hStop);
        }
        return TRUE;
    }
    else
    {       
        // Need to handle the other events...       
        // CTRL_BREAK_EVENT
        // CTRL_CLOSE_EVENT
        // CTRL_LOGOFF_EVENT
        // Need to clean up, free all the dll's we loaded.
        //
        FreeHelpers();
        FreeDlls();

        // Always need to return false for these events, otherwise the app will hang.
        //
        return FALSE;
    }
};

void
cls(
    IN    HANDLE    hConsole
    )
{
    COORD    coordScreen = { 0, 0 };
    BOOL     bSuccess;
    DWORD    cCharsWritten;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD    dwConSize;
    WORD     wAttr;

    bSuccess = GetConsoleScreenBufferInfo(hConsole, &csbi);

    dwConSize = (WORD) csbi.dwSize.X * (WORD) csbi.dwSize.Y;

    bSuccess =  FillConsoleOutputCharacter(hConsole,
                                           _TEXT(' '),
                                           dwConSize,
                                           coordScreen,
                                           &cCharsWritten);

    //
    // get the current text attribute
    //

    bSuccess = GetConsoleScreenBufferInfo(hConsole, &csbi);

    //
    // Make the background and foreground the same
    //

    wAttr = (csbi.wAttributes & 0xFFF0) | ((csbi.wAttributes & 0x00F0) >> 4);

    //
    // now set the buffer's attributes accordingly
    //

    bSuccess = FillConsoleOutputAttribute(hConsole,
                                          wAttr,
                                          dwConSize,
                                          coordScreen,
                                          &cCharsWritten);

    bSuccess = SetConsoleCursorPosition(hConsole, coordScreen);

    return;
}

BOOL
WINAPI
InitializeConsole(
    IN    OUT    PDWORD    pdwRR,
    OUT          HANDLE    *phMib,
    OUT          HANDLE    *phConsole
    )
{
    HANDLE    hMib, hStdOut, hConsole;
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (hStdOut is INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if (!*pdwRR)
    {
        //
        // No refresh. Display to standard output
        //

        *phConsole = hStdOut;
        *phMib = (HANDLE) NULL;

        return TRUE;
    }

    do
    {
        hMib = CreateEvent( NULL, TRUE, FALSE, STOP_EVENT);

        if (hMib == NULL)
        {
            *pdwRR = 0;
            *phConsole = hStdOut;
            *phMib = (HANDLE) NULL;
            break;
        }

        *phMib = hMib;

        hConsole = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                             0,  // NO sharing
                                             NULL,
                                             CONSOLE_TEXTMODE_BUFFER,
                                             NULL);

        if (hConsole is INVALID_HANDLE_VALUE)
        {
            //
            // No refresh will be done
            //

            *pdwRR = 0;
            *phConsole = hStdOut;
            *phMib = (HANDLE) NULL;

            break;
        }
        else
        {
            GetConsoleScreenBufferInfo(hStdOut, &csbi);

            csbi.dwSize.X = 80;
            SetConsoleScreenBufferSize(hConsole, csbi.dwSize);
            SetConsoleActiveScreenBuffer(hConsole);
            SetConsoleCtrlHandler(HandlerRoutine,TRUE);
            *phConsole = hConsole;
        }

    }while (FALSE);

    return TRUE;
}

DWORD 
WINAPI 
RefreshConsole(
    IN    HANDLE    hMib,
    IN    HANDLE    hConsole,
    IN    DWORD     dwRR
    )
{
    COORD    origin = {0,0};

    if (dwRR)
    {
        SetConsoleCursorPosition(hConsole, origin);

        if (WaitForSingleObject(hMib, dwRR) == WAIT_OBJECT_0)
        {
            //
            // End of refresh
            //

            ResetEvent(hMib);
            SetConsoleCtrlHandler(HandlerRoutine,FALSE);
            CloseHandle(hMib);
            CloseHandle(hConsole);
//            SetConsoleActiveScreenBuffer(g_hStdOut);
            return FALSE;
        }
        else
        {
            //
            // Go in loop again
            //

            cls(hConsole);

            return TRUE;
        }
    }

    return FALSE;
}

#define HT_TOP     0
#define HT_CONTEXT 1
#define HT_GROUP   2

typedef struct {
    HANDLE     hModule;
    LPCWSTR    pwszContext;
    DWORD      dwType;
    LPCWSTR    pwszCommand;
    DWORD      dwDescr;
    LPCWSTR    pwszDescr;
    LPCWSTR    pwszGroup;
} help_t;

#define MAX_HELP_COMMANDS 100
help_t help[MAX_HELP_COMMANDS];
ULONG ulNumHelpCommands = 0;

DWORD
FindHelpCommand(
    IN  LPCWSTR    pwszCommand
    )
{
    ULONG i;

    for (i=0; i<ulNumHelpCommands; i++)
    {
        if (!wcscmp(pwszCommand, help[i].pwszCommand))
        {
            return i;
        }
    }
    return -1;
}

DWORD
AddHelpCommand(
    IN  HANDLE     hModule,
    IN  LPCWSTR    pwszContext,
    IN  DWORD      dwType,
    IN  LPCWSTR    pwszCommand,
    IN  DWORD      dwDescr,
    IN  LPCWSTR    pwszDescr,
    IN  LPCWSTR    pwszGroup
    )
{
    ULONG i;

    ASSERT(ulNumHelpCommands < MAX_HELP_COMMANDS); // XXX

    i = ulNumHelpCommands++;

    help[i].hModule     = hModule;
    help[i].pwszContext = pwszContext;
    help[i].dwType      = dwType;
    help[i].pwszCommand = pwszCommand;
    help[i].dwDescr     = dwDescr;
    help[i].pwszDescr   = pwszDescr;
    help[i].pwszGroup   = pwszGroup;
    return NO_ERROR;
}

int
__cdecl
helpcmp(
    const void *a,
    const void *b
    )
{
    return _wcsicmp(((help_t*)a)->pwszCommand, ((help_t*)b)->pwszCommand);
}

DWORD
DisplayAllHelpCommands(
    )
{
    ULONG i;

    // Sort

    qsort( (void*)help, ulNumHelpCommands, sizeof(help_t), helpcmp );

    for (i=0; i<ulNumHelpCommands; i++)
    {
        if ((HT_GROUP == help[i].dwType) && help[i].pwszGroup)
        {
            LPWSTR pwszGroupFullCmd = (LPWSTR) 
                                        MALLOC( ( wcslen(help[i].pwszGroup) +  
                                                  wcslen(help[i].pwszCommand) + 
                                                  2 // for blank and NULL characters 
                                                ) * sizeof(WCHAR)
                                              );
            if (NULL == pwszGroupFullCmd)
            {
                PrintMessage( MSG_HELP_START, help[i].pwszCommand );
            }
            else
            {
                wcscpy(pwszGroupFullCmd, help[i].pwszGroup);
                wcscat(pwszGroupFullCmd, L" ");
                wcscat(pwszGroupFullCmd, help[i].pwszCommand);
                PrintMessage( MSG_HELP_START, pwszGroupFullCmd );
                FREE(pwszGroupFullCmd);
            }
        }
        else
        {
            PrintMessage( MSG_HELP_START, help[i].pwszCommand );
        }
        if (!PrintMessageFromModule( help[i].hModule, help[i].dwDescr, help[i].pwszDescr,
                        help[i].pwszContext,
                        (help[i].pwszContext[0])? L" " : L"" ))
        {
            PrintMessage(MSG_NEWLINE);
        }
    }

    // Delete all help commands
    ulNumHelpCommands = 0;

    return NO_ERROR;
}

VOID
DisplayContextsHere(
    IN  ULONG   ulNumContexts,
    IN  PBYTE   pByteContexts,
    IN  DWORD   dwContextSize,
    IN  DWORD   dwDisplayFlags
    )
{
    DWORD                   i;
    PCNS_CONTEXT_ATTRIBUTES pContext;

    if (!ulNumContexts)
    {
        return;
    }
    
    PrintMessageFromModule(g_hModule, MSG_SUBCONTEXT_LIST);

    for (i = 0; i < ulNumContexts; i++)
    {
        pContext = (PCNS_CONTEXT_ATTRIBUTES)(pByteContexts + i*dwContextSize);

        if (pContext->dwFlags & ~dwDisplayFlags)
        {
            continue;
        }

        if (!VerifyOsVersion(pContext->pfnOsVersionCheck))
        {
            continue;
        }

        PrintMessage(L" %1!s!", pContext->pwszContext);
    }

    PrintMessage(MSG_NEWLINE);
}

DWORD
DisplayContextHelp(
    IN  PCNS_CONTEXT_ATTRIBUTES    pContext,
    IN  DWORD                      dwDisplayFlags,
    IN  DWORD                      dwCmdFlags,
    IN  DWORD                      dwArgsRemaining,
    IN  LPCWSTR                    pwszGroup
    )
{
    DWORD                   i, j, dwErr;
    PNS_HELPER_TABLE_ENTRY  pHelper;
    ULONG                   ulNumContexts;
    DWORD                   dwContextSize;
    PBYTE                   pByteContexts;
    PNS_DLL_TABLE_ENTRY     pDll;
    PCNS_CONTEXT_ATTRIBUTES pSubContext;
    LPWSTR                  pwszFullContextName = NULL;

    dwErr = GetHelperEntry(&pContext->guidHelper, &pHelper);
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = GetDllEntry( pHelper->dwDllIndex, &pDll );
    if (dwErr)
    {
        return dwErr;
    }

    dwErr = AppendFullContextName(pContext, &pwszFullContextName);

    ulNumContexts = pHelper->ulNumSubContexts;
    dwContextSize = pHelper->ulSubContextSize;
    pByteContexts = pHelper->pSubContextTable;

    // First set up flags

    if (dwCmdFlags & CMD_FLAG_INTERACTIVE)
    {
        dwDisplayFlags |= CMD_FLAG_INTERACTIVE;
    }

    if (dwCmdFlags & CMD_FLAG_ONLINE)
    {
        dwDisplayFlags |= CMD_FLAG_ONLINE;
    }

    if (dwCmdFlags & CMD_FLAG_LOCAL)
    {
        dwDisplayFlags |= CMD_FLAG_LOCAL;
    }

    if (IsImmediate(dwCmdFlags, dwArgsRemaining))
    {
        dwCmdFlags |= CMD_FLAG_IMMEDIATE;
    }

    // Turn on any flags not used to limit commands
    // so they won't cause commands to not be displayed
    dwDisplayFlags |= ~CMD_FLAG_LIMIT_MASK;

    if (dwDisplayFlags & CMD_FLAG_PRIVATE)
    {
        PrintMessageFromModule(g_hModule, MSG_SHELL_CMD_HELP_HEADER);
    }

    // dwDisplayFlags has PRIVATE set *unless* this is called as a result of
    // printing help in the parent context, and non-inheritable commands
    // should not be printed.
    //
    // dwCmdFlags has IMMEDIATE set *unless* this is called from a parent
    // context, in which case parent help should not be printed.

    if ((!(dwDisplayFlags & CMD_FLAG_PRIVATE)
     || (dwCmdFlags & CMD_FLAG_IMMEDIATE)))
    {
        // Print help on inherited commands

        PCNS_CONTEXT_ATTRIBUTES pParentContext;

        dwErr = GetParentContext( pContext, &pParentContext );

        if (dwErr is NO_ERROR)
        {
            dwErr =  DisplayContextHelp( pParentContext,
                                         dwDisplayFlags & ~CMD_FLAG_PRIVATE,
                                         dwCmdFlags,
                                         dwArgsRemaining,
                                         pwszGroup );
        }
    }

    for(i = 0; !pwszGroup && (i < pContext->ulNumTopCmds); i++)
    {
        if (((*pContext->pTopCmds)[i].dwCmdHlpToken == MSG_NULL)
         || ((*pContext->pTopCmds)[i].dwFlags & ~dwDisplayFlags))
        {
            continue;
        }

        if (!VerifyOsVersion((*pContext->pTopCmds)[i].pOsVersionCheck))
        {
            continue;
        }
        
        AddHelpCommand( pDll->hDll,
                        pwszFullContextName,
                        HT_TOP,
                        (*pContext->pTopCmds)[i].pwszCmdToken,
                        (*pContext->pTopCmds)[i].dwShortCmdHelpToken,
                        NULL, NULL );
    }

    for(i = 0; i < pContext->ulNumGroups; i++)
    {
        if (((*pContext->pCmdGroups)[i].dwShortCmdHelpToken == MSG_NULL)
         || ((*pContext->pCmdGroups)[i].dwFlags & ~dwDisplayFlags))
        {
            continue;
        }

        if (!(*pContext->pCmdGroups)[i].pwszCmdGroupToken[0])
        {
            continue;
        }

        if (pwszGroup)
        {
            if (_wcsicmp(pwszGroup, (*pContext->pCmdGroups)[i].pwszCmdGroupToken))
            {
                continue;
            }

            if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pOsVersionCheck))
            {
                continue;
            }

            for (j = 0; j < (*pContext->pCmdGroups)[i].ulCmdGroupSize; j++)
            {
                if ((*pContext->pCmdGroups)[i].pCmdGroup[j].dwFlags & ~dwDisplayFlags)
                {
                    continue;
                }
                        
                if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pCmdGroup[j].pOsVersionCheck))
                {
                    continue;
                }

                AddHelpCommand( pDll->hDll,
                                pwszFullContextName,
                                HT_GROUP,
                                (*pContext->pCmdGroups)[i].pCmdGroup[j].pwszCmdToken,
                                (*pContext->pCmdGroups)[i].pCmdGroup[j].dwShortCmdHelpToken,
                                NULL,
                                pwszGroup);
            }
        }
        else
        {
            if (!VerifyOsVersion((*pContext->pCmdGroups)[i].pOsVersionCheck))
            {
                continue;
            }

            AddHelpCommand( pDll->hDll,
                            pwszFullContextName,
                            HT_GROUP,
                            (*pContext->pCmdGroups)[i].pwszCmdGroupToken,
                            (*pContext->pCmdGroups)[i].dwShortCmdHelpToken,
                            NULL, NULL );
        }
    }

    for (i = 0; !pwszGroup && (i < ulNumContexts); i++)
    {
        pSubContext = (PCNS_CONTEXT_ATTRIBUTES)(pByteContexts + i * dwContextSize);

        if ((pSubContext->dwFlags & ~dwDisplayFlags))
        {
            continue;
        }

         if (!VerifyOsVersion(pSubContext->pfnOsVersionCheck))
        {
            continue;
        }

        AddHelpCommand( g_hModule,
                        pwszFullContextName,
                        HT_CONTEXT,
                        pSubContext->pwszContext,
                        MSG_HELPER_HELP,
                        pSubContext->pwszContext, NULL );
    }

    if (dwDisplayFlags & CMD_FLAG_PRIVATE)
    {
        // Add any ubiquitous commands that aren't already added

        for(i = 0; !pwszGroup && (i < g_ulNumUbiqCmds); i++)
        {
            if ((g_UbiqCmds[i].dwCmdHlpToken == MSG_NULL)
             || (g_UbiqCmds[i].dwFlags & ~dwDisplayFlags))
            {
                continue;
            }

            if (FindHelpCommand(g_UbiqCmds[i].pwszCmdToken) isnot -1)
            {
                continue;
            }
    
            AddHelpCommand( g_hModule,
                            pwszFullContextName,
                            HT_TOP,
                            g_UbiqCmds[i].pwszCmdToken,
                            g_UbiqCmds[i].dwShortCmdHelpToken,
                            NULL, NULL );
        }
    }

    if (ulNumHelpCommands > 0)
    {
        if (dwDisplayFlags & CMD_FLAG_PRIVATE)
        {
            PrintMessageFromModule( g_hModule, MSG_LOCAL_COMMANDS );
        }
        else if (help[0].pwszContext[0])
        {
            PrintMessageFromModule( g_hModule,
                            MSG_INHERITED_COMMANDS,
                            help[0].pwszContext );
        } 
        else 
        {
            PrintMessageFromModule( g_hModule, MSG_GLOBAL_COMMANDS );
        }
        
        DisplayAllHelpCommands();
    }

    // Once we've popped the stack back up to the original context
    // in which the help command was run, display all the subcontexts
    // available here.

    if ((dwDisplayFlags & CMD_FLAG_PRIVATE) && !pwszGroup)
    {
        DisplayContextsHere( pHelper->ulNumSubContexts,
                             pHelper->pSubContextTable,
                             pHelper->ulSubContextSize,
                             dwDisplayFlags );

        PrintMessageFromModule( g_hModule, MSG_HELP_FOOTER, CMD_HELP2 );
    }

    if (pwszFullContextName)
    {
        FREE(pwszFullContextName);
    }

    return NO_ERROR;
}

DWORD
WINAPI
DisplayHelp(
    IN  CONST GUID                *pguidHelper,
    IN  LPCWSTR                    pwszContext,
    IN  DWORD                      dwDisplayFlags,
    IN  DWORD                      dwCmdFlags,
    IN  DWORD                      dwArgsRemaining,
    IN  LPCWSTR                    pwszGroup
    )
{
    DWORD    i, j, dwErr;
    PCNS_CONTEXT_ATTRIBUTES pContext;
    PNS_HELPER_TABLE_ENTRY pHelper;

    // Locate helper

    dwErr = GetHelperEntry( pguidHelper, &pHelper );

    // Locate context

    dwErr = GetContextEntry( pHelper, pwszContext, &pContext );
    if (dwErr)
    {
        return dwErr;
    }

    return DisplayContextHelp( pContext,
                               dwDisplayFlags,
                               dwCmdFlags,
                               dwArgsRemaining,
                               pwszGroup );
}

DWORD
WINAPI
PreprocessCommand(
    IN      HANDLE    hModule,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN OUT  PTAG_TYPE pttTags,
    IN      DWORD     dwTagCount,
    IN      DWORD     dwMinArgs,
    IN      DWORD     dwMaxArgs,
    OUT     DWORD    *pdwTagType
    )

/*++

Description:

    Make sure the number of arguments is valid.
    Make sure there are no duplicate or unrecognized tags.

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg
    pttTags          - Legal tags
    dwTagCount      - Number of legal tags
    dwMinArgs       - minimum # of args required
    dwMaxArgs       - maximum # of args required
    pdwTagType      - Index into pttTags for each argument

--*/

{
    DWORD dwNumArgs, i;
    DWORD dwErr = NO_ERROR;
    DWORD dwTagEnum;

    if ( (!ppwcArguments) || (!pttTags) || (!pdwTagType) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    for (dwTagEnum = 0; dwTagEnum < dwTagCount; dwTagEnum++)
    {
        pttTags->bPresent = FALSE;
    }

#ifdef EXTRA_DEBUG
    PRINT("PreHandleCommand:");
    for( i = 0; i < dwArgCount; i++)
    {
        PRINT(ppwcArguments[i]);
    }
#endif

    dwNumArgs = dwArgCount - dwCurrentIndex;

    if((dwNumArgs < dwMinArgs) or
       (dwNumArgs > dwMaxArgs))
    {
        //
        // Wrong number of arguments specified
        //

        return ERROR_INVALID_SYNTAX;
    }

    if ( dwNumArgs > 0 )
    {
        dwErr = MatchTagsInCmdLine(hModule,
                            ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            pttTags,
                            dwTagCount,
                            pdwTagType);

        if (dwErr isnot NO_ERROR)
        {
            if (dwErr is ERROR_INVALID_OPTION_TAG)
            {
                return ERROR_INVALID_SYNTAX;
            }

            return dwErr;
        }
    }

    // Make sure we don't have duplicate or unrecognized tags

    for(i = 0; i < dwNumArgs; i ++)
    {
        if ((int) pdwTagType[i] < 0 || pdwTagType[i] >= dwTagCount)
        {
            dwErr = ERROR_INVALID_SYNTAX;

            break;
        }
    }

    switch(dwErr)
    {
        case NO_ERROR:
        {
            break;
        }

        default:
        {
            return dwErr;
        }
    }

    // Make sure every required tag is present

    for(i = 0; i < dwTagCount; i++)
    {
        if ((pttTags[i].dwRequired & NS_REQ_PRESENT)
         && !pttTags[i].bPresent)
        {
            PrintMessageFromModule(g_hModule, ERROR_MISSING_OPTION);

            return ERROR_INVALID_SYNTAX;
        }
    }

    return NO_ERROR;
}

#define HISTORY_MASK (NS_EVENT_LAST_N | NS_EVENT_FROM_N |   \
                      NS_EVENT_FROM_START | NS_EVENT_LAST_SECS)

DWORD
SetupEventLogSeekPtr(
    OUT PHANDLE             phEventLog,
    IN  PEVENT_PRINT_INFO   pEventInfo
    )
    
/*++

Routine Description:

    This function opens a handle to the appropriate event log and "rewinds"
    to the correct point as specified by the fflags. When the function returns
    the eventlog handle is setup such that reading the log sequentially in a
    forward direction will get the events the caller wants

Locks:

    None

Arguments:

    See above, args are passed pretty much the same

Return Value:

    Win32

--*/

{
    DWORD       dwResult, dwRead, dwNeed, i, dwHistoryContext;
    BYTE        Buffer[2048]; // Huge buffer
    DWORD_PTR   pNextEvent;
    BOOL        bResult, bDone;
    LPCWSTR     pwszComponent;

    EVENTLOGRECORD *pStartEvent;

    dwResult = NO_ERROR;

    //
    // Open the event log
    //
    
    *phEventLog = OpenEventLogW(g_pwszRouterName,
                                pEventInfo->pwszLogName);

    if(*phEventLog is NULL)
    {
        return GetLastError();
    }

    if(pEventInfo->fFlags is 0)
    {
        //
        // If no history is being requested, just return. Our seek ptr
        // will be already setup
        //

        return NO_ERROR;
    }

    if(pEventInfo->fFlags & NS_EVENT_FROM_START)
    {
        //
        // We can use the same matching for this as we do for NS_EVENT_FROM_N
        // by setting component to eventlog and dwHistoryContext to 6005
        //

        pwszComponent    = L"eventlog";
        dwHistoryContext = 6005;
    }
    else
    {
        pwszComponent    = pEventInfo->pwszComponent;
        dwHistoryContext = pEventInfo->dwHistoryContext;
    }

    //
    // Okay so she wants history. Either way we read backwards
    //

    i = 0;

    pStartEvent = NULL;
    bDone       = FALSE;

    //
    // Read the event log till we find a record to stop at
    // This is signalled by the code setting bDone to TRUE
    //

    while(!bDone)
    {
        //
        // Get a bunch of events
        //

        bResult = ReadEventLogW(
                    *phEventLog,
                    EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ,
                    0,
                    (PVOID)Buffer,
                    sizeof(Buffer),
                    &dwRead,
                    &dwNeed
                    );

        if(bResult isnot TRUE)
        {
            dwResult = GetLastError();

            if(dwResult is ERROR_HANDLE_EOF)
            {
                //
                // If we have reached the end of the log, break out
                //

                bDone = TRUE;

                break;
            }
            else
            {
                return dwResult;
            }
        }

        //
        // Start at the beginning of the buffer we just read
        //

        pNextEvent = (DWORD_PTR)Buffer;

        //
        // Read till we walk off the end of the buffer or find a record
        //
        // If we find the starting record, we set pStartEvent to one after that
        // It may so happen that the starting record is the last one in
        // the block that we have read. In that case, we set pStartEvent
        // to NULL but bDone to TRUE
        //

        while((pNextEvent < (DWORD_PTR)Buffer + dwRead) and !bDone)
        {
            EVENTLOGRECORD *pCurrentEvent;

            pCurrentEvent = (EVENTLOGRECORD *)pNextEvent;

            pNextEvent += pCurrentEvent->Length;

            switch(pEventInfo->fFlags)
            {
                case NS_EVENT_LAST_N:
                case NS_EVENT_LAST_SECS:
                {
                    //
                    // We are being asked to go back N (of our records)
                    // or go back N secs
                    //

                    if(!IsOurRecord(pCurrentEvent,
                                    pEventInfo))
                    {
                        //
                        // Not one of ours
                        //

                        continue;
                    }

                    if(pEventInfo->fFlags is NS_EVENT_LAST_N)
                    {
                        //
                        // i is the count of events
                        //

                        i++;
                    }
                    else
                    {
                        time_t CurrentTime;

                        //
                        // i is the time difference in seconds
                        // = currentTime - eventTime
                        //

                        time(&CurrentTime);

                        //
                        // Subtract and truncate
                        //

                        i = (DWORD)(CurrentTime - pCurrentEvent->TimeGenerated);

                    }

                    if(i >= dwHistoryContext)
                    {
                        //
                        // Have gone back N (records or seconds)
                        //

                        if(pNextEvent < (DWORD_PTR)Buffer + dwRead)
                        {
                            //
                            // Have some more records in this buffer, so
                            // set pStartEvent to the next one
                            //

                            pStartEvent = (EVENTLOGRECORD *)pNextEvent;
                        }
                        else
                        {
                            pStartEvent = NULL;
                        }

                        //
                        // Done, break out of while(pNextEvent... and
                        // while(!bDone)
                        //

                        bDone = TRUE;

                        break;
                    }

                    break;
                }

                case NS_EVENT_FROM_N:
                case NS_EVENT_FROM_START:
                {
                    //
                    // We are being asked to go to the the most recent
                    // occurance of a certain event.
                    //

                    if(_wcsicmp((LPCWSTR)((DWORD_PTR)pCurrentEvent + sizeof(*pCurrentEvent)),
                                pwszComponent) == 0)
                    {
                        if(pCurrentEvent->EventID is dwHistoryContext)
                        {
                            if(pNextEvent < (DWORD_PTR)Buffer + dwRead)
                            {
                                pStartEvent = (EVENTLOGRECORD *)pNextEvent;
                            }
                            else
                            {
                                pStartEvent = NULL;
                            }

                            //
                            // Done, break out of while(pCurrent...
                            // and while(!bDone)
                            //

                            bDone = TRUE;

                            break;
                        }
                    }
                }

                default:
                {
                    ASSERT(FALSE);
                }
            }
        }
    }

    if(pStartEvent)
    {
        //
        // So we found a record at which to start.
        // API wants a buffer even if we set the size to 0
        //

        bResult = ReadEventLogW(*phEventLog,
                                EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,
                                pStartEvent->RecordNumber,
                                (PVOID)Buffer,
                                0,
                                &dwRead,
                                &dwNeed);

        if(dwNeed < sizeof(Buffer))
        {
            ReadEventLogW(*phEventLog,
                          EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,
                          pStartEvent->RecordNumber,
                          (PVOID)Buffer,
                          dwNeed,
                          &dwRead,
                          &dwNeed);
        }
    }

    return NO_ERROR;
}

BOOL
IsOurRecord(
    IN  EVENTLOGRECORD      *pRecord,
    IN  PEVENT_PRINT_INFO   pEventInfo
    )
{
    BOOL    bRet;
    DWORD   i;

    if(_wcsicmp((LPCWSTR)((DWORD_PTR)pRecord + sizeof(*pRecord)),
                pEventInfo->pwszComponent) isnot 0)
    {
        return FALSE;
    }

    bRet = TRUE;

    //
    // If ulEventCount is 0 means any event. So return TRUE
    //

    for(i = 0; i < pEventInfo->ulEventCount; i++)
    {
        bRet = (pRecord->EventID is pEventInfo->pdwEventIds[i]);

        if(bRet)
        {
            break;
        }
    }

    if(bRet)
    {
        if(pEventInfo->pfnEventFilter)
        {
            if(!(pEventInfo->pfnEventFilter)(pRecord,
                                             pEventInfo->pwszLogName,
                                             pEventInfo->pwszComponent,
                                             pEventInfo->pwszSubComponent,
                                             pEventInfo->pvFilterContext))
            {
                //
                // It fell in our subcomp, but the caller doesnt
                // consider it so
                //

                bRet = FALSE;
                
            }
        }
    }
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\shell.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    routing\netsh\shell\shell.h

Abstract:

    Include for shell.c

Revision History:

    Anand Mahalingam          7/6/98  Created

--*/


extern HANDLE  g_hModule;
extern WCHAR   g_pwszContext[MAX_CMD_LEN];
extern BOOL    g_bInteractive;
extern BOOL    g_bDone;
extern HANDLE  g_hLogFile;
extern LPWSTR  g_pwszRouterName;
extern LPWSTR  g_pwszRememberedConnection;

//
// The entry in the argument list.
//

typedef struct _ARG_ENTRY
{
    LIST_ENTRY    le;         
    LPWSTR        pwszArg;    // Argument String
}ARG_ENTRY, *PARG_ENTRY;

//
// Macro to free memory allocated for the argument list
//

#define FREE_ARG_LIST(ple)  \
{   \
     PLIST_ENTRY    ple1 = ple->Flink, pleTmp;  \
     PARG_ENTRY     pae;    \
     \
     while (ple1 != ple)    \
     {  \
         pae = CONTAINING_RECORD(ple1, ARG_ENTRY, le);  \
         if (pae->pwszArg)  \
             HeapFree(GetProcessHeap(), 0, pae->pwszArg);   \
         pleTmp = ple1->Flink;   \
         RemoveEntryList(ple1); \
         HeapFree(GetProcessHeap(), 0, pae);    \
         ple1 = pleTmp;  \
     }  \
     HeapFree(GetProcessHeap(), 0, ple);    \
}

//
// Function Prototypes
//
DWORD 
WINAPI
ExecuteHandler(
    IN      HANDLE     hModule,
    IN      CMD_ENTRY *pCmdEntry,
    IN OUT  LPWSTR    *argv, 
    IN      DWORD      dwNumMatched, 
    IN      DWORD      dwArgCount, 
    IN      DWORD      dwFlags,
    IN      LPCVOID    pvData,
    IN      LPCWSTR    pwszGroupName,
    OUT     BOOL      *pbDone);

DWORD
ParseCommand(
    IN   PLIST_ENTRY    ple,
    IN   BOOL           bAlias
    );

DWORD
ParseCommandLine(
    IN    LPCWSTR    pwszCmdLine,
    OUT   PLIST_ENTRY    *pple
    );

DWORD
ProcessCommand(
    IN    LPCWSTR    pwszCmdLine,
    OUT   BOOL      *pbDone
    );

DWORD
LoadScriptFile(
    IN    LPCWSTR pwszFileName
    );

DWORD
ConvertBufferToArgList(
    PLIST_ENTRY *ppleHead,
    LPCWSTR     pwszBuffer
    );

DWORD
ConvertArgListToBuffer(
    IN  PLIST_ENTRY pleHead,
    OUT LPWSTR      pwszBuffer
    );

VOID
ConvertArgArrayToBuffer(
    IN  DWORD       dwArgCount,
    IN  LPCWSTR    *argv,
    OUT LPWSTR     *ppwszBuffer
    );

BOOL
IsLocalCommand(
    IN LPCWSTR pwszCmd,
    IN DWORD   dwSkipFlags
    );

extern ULONG g_ulNumUbiqCmds;
extern ULONG g_ulNumShellCmds;
extern ULONG g_ulNumGroups;
extern CMD_GROUP_ENTRY g_ShellCmdGroups[];
extern CMD_ENTRY g_ShellCmds[];
extern CMD_ENTRY g_UbiqCmds[];

BOOL
IsImmediate(
    IN  DWORD dwCmdFlags,
    IN  DWORD dwRemainingArgs
    );

DWORD DisconnectFromCurrentRouter();

DWORD
SetMachine(
    IN  LPCWSTR pwszNewRouter,
    IN  LPCWSTR pwszUserName,
    IN  LPCWSTR pwszPassword
    );

DWORD
AppendString(
    IN OUT LPWSTR    *ppwszBuffer,
    IN     LPCWSTR    pwszString
    );

DWORD
WINAPI
UpdateNewContext(
    IN OUT  LPWSTR  pwszBuffer,
    IN      LPCWSTR pwszNewToken,
    IN      DWORD   dwArgs
    );

HRESULT WINAPI
    UpdateVersionInfoGlobals
    (
    IN  LPCWSTR pwszMachine, 
    IN  LPCWSTR pwszUserName, 
    IN  LPCWSTR pwszPassword);

extern UINT     g_CIMOSType;
extern UINT     g_CIMOSProductSuite;
extern WCHAR    g_CIMOSVersion[MAX_PATH];
extern WCHAR    g_CIMOSBuildNumber[MAX_PATH];
extern WCHAR    g_CIMServicePackMajorVersion[MAX_PATH];
extern WCHAR    g_CIMServicePackMinorVersion[MAX_PATH];
extern UINT     g_CIMProcessorArchitecture;

extern BOOL     g_CIMAttempted;
extern BOOL     g_CIMSucceeded;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\acddefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    acddefs.h

Abstract:

    Shared internal structure defintions for the Implicit
    Connection Driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  23-Jun-1995

Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _ACDDEFS_
#define _ACDDEFS_

//
// Min macro
//
#define MIN(a, b) (a) < (b) ? (a) : (b)

//
// List entry structure for the AcdCompletionQueue.
//
typedef struct _ACD_COMPLETION {
    LIST_ENTRY ListEntry;
    ULONG ulDriverId;             // transport driver id
    BOOLEAN fCanceled;            // TRUE if request was canceled
    BOOLEAN fCompleted;           // TRUE if request was completed
    ACD_NOTIFICATION notif;
    ACD_CONNECT_CALLBACK pProc;   // callback proc
    USHORT nArgs;                 // argument count
    PVOID pArgs[1];               // variable length arguments
} ACD_COMPLETION, *PACD_COMPLETION;

//
// A connection block.
//
// For each pending connection, there is a
// connection block that describes the current
// state.
//
typedef struct _ACD_CONNECTION {
    LIST_ENTRY ListEntry;           // connection list
    BOOLEAN fNotif;                 // TRUE if service has been notified
    BOOLEAN fProgressPing;          // TRUE if service has pinged
    BOOLEAN fCompleting;            // TRUE if in AcdSignalCompletionCommon
    ULONG ulTimerCalls;             // # of total pings
    ULONG ulMissedPings;            // # of missed pings
    LIST_ENTRY CompletionList;      // completion list
} ACD_CONNECTION, *PACD_CONNECTION;

typedef struct _ACD_DISABLED_ADDRESSES {
    LIST_ENTRY ListEntry;
    ULONG ulNumAddresses;
    ULONG ulMaxAddresses;
} ACD_DISABLED_ADDRESSES, *PACD_DISABLED_ADDRESSES;

typedef struct _ACD_DISABLED_ADDRESS {
    LIST_ENTRY ListEntry;
    ACD_ENABLE_ADDRESS EnableAddress;
} ACD_DISABLED_ADDRESS, *PACD_DISABLED_ADDRESS;

//
// Generic hash table entry.
//
typedef struct _HASH_ENTRY {
    LIST_ENTRY ListEntry;
    ACD_ADDR szKey;
    ULONG ulData;
} HASH_ENTRY, *PHASH_ENTRY;

extern KSPIN_LOCK AcdSpinLockG;

extern KEVENT AcdRequestThreadEventG;

extern LIST_ENTRY AcdNotificationQueueG;
extern LIST_ENTRY AcdCompletionQueueG;
extern LIST_ENTRY AcdConnectionQueueG;
extern LIST_ENTRY AcdDriverListG;

extern BOOLEAN fConnectionInProgressG;
extern BOOLEAN fProgressPingG;
extern ULONG nTimerCallsG;
extern ULONG nMissedPingsG;

extern PDEVICE_OBJECT pAcdDeviceObjectG;

extern ACD_ADDR szComputerName;

extern BOOLEAN AcdStopThread;

//
// Miscellaneous routines.
//
VOID
AcdPrintAddress(
    IN PACD_ADDR pAddr
    );

#endif // _ACDDEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\debug.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debugging defintions for the Automatic
    Connection Driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  3-Aug-1995

Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _ACDDBG_
#define _ACDDBG_

//
// Debug tracing flags.
//
// To enable debug tracing for a module, set the
// appropriate bit in ntinit\AcdDebugG.
//
#if DBG

#define ACD_DEBUG_IOCTL             0x00000001  // ntdisp.c/AcdDispatchDeviceControl()
#define ACD_DEBUG_OPENCOUNT         0x00000002  // ntdisp.c/Acd{Open,Close}()
#define ACD_DEBUG_TIMER             0x00000004  // timer.c
#define ACD_DEBUG_CONNECTION        0x00000008  // api.c/AcdStartConnection()
#define ACD_DEBUG_WORKER            0x00000010  // api.c/AcdNotificationRequestThread()
#define ACD_DEBUG_RESET             0x00000020  // api.c/AcdReset()
#define ACD_DEBUG_MEMORY            0x80000000  // memory alloc/free

#define IF_ACDDBG(flag)     if (AcdDebugG & flag)
#define AcdPrint(many_args) DbgPrint many_args

extern ULONG AcdDebugG;

#else

#define IF_ACDDBG(flag)     if (0)
#define AcdPrint(many_args)

#endif

#define ALLOCATE_CONNECTION(pObject) \
    pObject = ExAllocatePoolWithTag (NonPagedPool, sizeof (ACD_CONNECTION), 'NdcA');

#define FREE_CONNECTION(pObject) \
    ExFreePool (pObject);

#define FREE_MEMORY(pObject) \
    ExFreePool (pObject);

#define ALLOCATE_MEMORY(ulSize, pObject) \
    pObject = ExAllocatePoolWithTag (NonPagedPool, ulSize, 'NdcA');


#endif // _ACDDBG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\netsh\shell\wmi.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <netsh.h>
#include "objbase.h"
#include "Wbemidl.h"
#include "wincred.h"

extern "C"
{
    UINT     g_CIMOSType = 0;
    UINT     g_CIMOSProductSuite = 0;
    UINT     g_CIMProcessorArchitecture = 0;
    WCHAR    g_CIMOSVersion[MAX_PATH];
    WCHAR    g_CIMOSBuildNumber[MAX_PATH];
    WCHAR    g_CIMServicePackMajorVersion[MAX_PATH];
    WCHAR    g_CIMServicePackMinorVersion[MAX_PATH];
    BOOL     g_CIMAttempted = FALSE;
    BOOL     g_CIMSucceeded = FALSE;

    HRESULT WINAPI UpdateVersionInfoGlobals(LPCWSTR pwszMachine, LPCWSTR pwszUserName, LPCWSTR pwszPassword);
}

//
// SetSecurity - set the Proxy Blanket on an IUnknown* interface so that it can be used by WMI 
//               cross-machine calls.
//
//               Okay for any of pwszDomainName, pwszUserName or pwszPassword to be NULL.
//
// deonb 12/20/2001
//
HRESULT WINAPI SetSecurity(IN OUT IUnknown* pUnk, IN USHORT* pwszDomainName, IN USHORT* pwszUserName, IN USHORT* pwszPassword)
{
    HRESULT hr = S_OK;

    COAUTHIDENTITY authident;
    authident.Domain = pwszDomainName;
    authident.DomainLength = pwszDomainName ? wcslen(pwszDomainName) : 0;
    authident.Password = pwszPassword;
    authident.PasswordLength = pwszPassword ? wcslen(pwszPassword) : 0;
    authident.User = pwszUserName;
    authident.UserLength = pwszUserName ? wcslen(pwszUserName) : 0;
    authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    
    hr = CoSetProxyBlanket(pUnk,
                           RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE,
                           NULL,
                           RPC_C_AUTHN_LEVEL_PKT,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           &authident,
                           EOAC_NONE);

    return hr;
}

#define FImplies(a,b) (!(a) || (b))

HRESULT WINAPI
UpdateVersionInfoGlobalsFromWMI(LPCWSTR pwszMachine, LPCWSTR pwszUserName, LPCWSTR pwszPassword)
{
    HRESULT hr = S_OK;

    g_CIMAttempted = TRUE;
    g_CIMSucceeded = FALSE;
    
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr) && (RPC_E_CHANGED_MODE != hr))
    {
        return hr;
    }

    // Create an instance of the WbemLocator interface.
    IWbemLocator *pIWbemLocator = NULL;
    hr = CoCreateInstance(CLSID_WbemLocator,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IWbemLocator,
        (LPVOID *) &pIWbemLocator);

    if (FAILED(hr))
    {
        return hr;
    }

    IWbemServices *pIWbemServices;
    // If already connected, release m_pIWbemServices.
    // Using the locator, connect to CIMOM in the given namespace.


    BSTR pNamespace = NULL; 
    BSTR pDomain    = NULL; 
    BSTR pUserName  = NULL; 
    BSTR pFQUserName= NULL; 
    BSTR pPassword  = NULL;
    
    do 
    {
        WCHAR szPath[MAX_PATH];
        wsprintf(szPath, L"\\\\%s\\root\\cimv2", !pwszMachine ? L"." : pwszMachine);
    
        pNamespace = SysAllocString(szPath);
        if ( (szPath) && (!pNamespace) )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        if (pwszUserName)
        {
            WCHAR szUserNameExtract[MAX_PATH];
            WCHAR szDomainNameExtract[MAX_PATH];

            // Break a domain\username type of username up into a seperate domain and username
            // It doesn't do this for username@domain format, but it doesn't matter since
            // the API using this (CoSetProxyBlanket) accepts names in username@domain format
            DWORD dwErr = CredUIParseUserName(pwszUserName, szUserNameExtract, MAX_PATH, szDomainNameExtract, MAX_PATH);
            hr = HRESULT_FROM_WIN32(dwErr);
            if (FAILED(hr))
            {
                break;
            }

            pDomain     = SysAllocString(szDomainNameExtract);
            pUserName   = SysAllocString(szUserNameExtract);
            pFQUserName = SysAllocString(pwszUserName);
            if ( (!FImplies(szDomainNameExtract, pDomain)) ||
                 (!FImplies(szUserNameExtract, pUserName)) ||
                 (!FImplies(pwszUserName, pFQUserName)) )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        pPassword = SysAllocString(pwszPassword);
        if (!FImplies(pwszPassword, pPassword))
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    } while (FALSE);
    
    if (FAILED(hr))
    {
        SysFreeString(pPassword);
        SysFreeString(pUserName);
        SysFreeString(pFQUserName);
        SysFreeString(pDomain);
        SysFreeString(pNamespace);
        return hr;
    }

    hr = pIWbemLocator->ConnectServer(pNamespace,
                            pFQUserName, // username 
                            pPassword,   // password
                            0L,          // locale
                            0L,          // securityFlags
                            NULL,        // authority (domain for NTLM)
                            NULL,        // context
                            &pIWbemServices); 

    if (SUCCEEDED(hr))
    {   
        hr = SetSecurity(pIWbemServices, pDomain, pUserName, pPassword);
        if (SUCCEEDED(hr))
        {
            IEnumWbemClassObject *pEnum = NULL;
            BSTR bstrWQL  = SysAllocString(L"WQL");
            BSTR bstrPath = SysAllocString(L"select * from Win32_OperatingSystem");
            
            VARIANT varOSType;
            VARIANT varOSVersion;
            VARIANT varOSProductSuite;
            VARIANT varOSBuildNumber;
            VARIANT varServicePackMajorVersion;
            VARIANT varServicePackMinorVersion;
            VARIANT varArchitecture;
    
            hr = pIWbemServices->ExecQuery(bstrWQL, bstrPath, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnum);
            if (SUCCEEDED(hr))
            {
                hr = SetSecurity(pEnum, pDomain, pUserName, pPassword);
            }

            if (SUCCEEDED(hr))
            {
                IWbemClassObject *pNSClass;
                ULONG uReturned;
                hr = pEnum->Next(WBEM_INFINITE, 1, &pNSClass, &uReturned );
                if (SUCCEEDED(hr))
                {
                    if (uReturned)
                    {
                        do
                        {
                            g_CIMSucceeded = TRUE;
                            CIMTYPE ctpeType;
                            hr = pNSClass->Get(L"OSType", NULL, &varOSType, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varOSType, &varOSType, 0, VT_UINT);
                                if (SUCCEEDED(hr))
                                {
                                    g_CIMOSType = varOSType.uintVal;
                                }
                            }
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"Version", NULL, &varOSVersion, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varOSVersion, &varOSVersion, 0, VT_BSTR);
                                if (SUCCEEDED(hr))
                                {
                                    wcscpy(g_CIMOSVersion, varOSVersion.bstrVal);
                                }
                            }
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"OSProductSuite", NULL, &varOSProductSuite, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                //
                                // if the return type is VT_NULL, leave g_CIMOSProductSuite value alone (0)
                                if (VT_NULL != varOSProductSuite.vt)
                                {
                                    hr = VariantChangeType(&varOSProductSuite, &varOSProductSuite, 0, VT_UINT);
                                    if (SUCCEEDED(hr))
                                    {
                                        g_CIMOSProductSuite = varOSProductSuite.uintVal;
                                    }
                                }
                            }                    
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"BuildNumber", NULL, &varOSBuildNumber, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varOSBuildNumber, &varOSBuildNumber, 0, VT_BSTR);
                                if (SUCCEEDED(hr))
                                {
                                    wcscpy(g_CIMOSBuildNumber,  varOSBuildNumber.bstrVal);
                                }
                            }                    
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"ServicePackMajorVersion", NULL, &varServicePackMajorVersion, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varServicePackMajorVersion, &varServicePackMajorVersion, 0, VT_BSTR);
                                if (SUCCEEDED(hr))
                                {
                                    wcscpy(g_CIMServicePackMajorVersion,  varServicePackMajorVersion.bstrVal);
                                }
                            }        
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        
                            hr = pNSClass->Get(L"ServicePackMinorVersion", NULL, &varServicePackMinorVersion, &ctpeType, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantChangeType(&varServicePackMinorVersion, &varServicePackMinorVersion, 0, VT_BSTR);
                                if (SUCCEEDED(hr))
                                {
                                    wcscpy(g_CIMServicePackMinorVersion,  varServicePackMinorVersion.bstrVal);
                                }
                            }
                            if (FAILED(hr))
                            {
                                g_CIMSucceeded = FALSE;
                                break;
                            }
                        }
                        while (FALSE);
                    }
                    else
                    {
                        hr = E_UNEXPECTED;
                    }
                    pNSClass->Release();
                }
                pEnum->Release();
            }
    
            SysFreeString(bstrPath);
    
            if (SUCCEEDED(hr))
            {
                    bstrPath = SysAllocString(L"select * from Win32_Processor");
                
                    hr = pIWbemServices->ExecQuery(bstrWQL, bstrPath, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnum);
                    if (SUCCEEDED(hr))
                    {
                        hr = SetSecurity(pEnum, pDomain, pUserName, pPassword);
                    }

                    if (SUCCEEDED(hr))
                    {
                        IWbemClassObject *pNSClass;
                        ULONG uReturned;
                        hr = pEnum->Next(WBEM_INFINITE, 1, &pNSClass, &uReturned );
                        if (SUCCEEDED(hr))
                        {
                            if (uReturned)
                            {
                                CIMTYPE ctpeType;
                                hr = pNSClass->Get(L"Architecture", NULL, &varArchitecture, &ctpeType, NULL);
                                if (SUCCEEDED(hr))
                                {
                                    hr = VariantChangeType(&varArchitecture, &varArchitecture, 
                                             0, VT_UINT);
                                    if (SUCCEEDED(hr))
                                    {
                                        g_CIMProcessorArchitecture = varArchitecture.uintVal;
                                    }
                                    else
                                    {
                                        g_CIMSucceeded = FALSE;
                                    }
                                }
                                else
                                {
                                    g_CIMSucceeded = FALSE;
                                }
                            }
                            else
                            {
                                hr = E_UNEXPECTED;
                            }
                            pNSClass->Release();
                        }
                        pEnum->Release();
                    }
                    SysFreeString(bstrPath);
            }
            
            SysFreeString(bstrWQL);
            pIWbemServices->Release();
        }  //hr = CoSetProxyBlanket(pIWbemServices.., if (SUCCEEDED(hr))
        
    }  //hr = pIWbemLocator->ConnectServer.., if (SUCCEEDED(hr))
    SysFreeString(pPassword);
    SysFreeString(pUserName);
    SysFreeString(pFQUserName);
    SysFreeString(pDomain);
    SysFreeString(pNamespace);

    CoUninitialize();
    
    // Translate any WMI errors into Win32 errors:
    switch (hr)
    {
        case WBEM_E_NOT_FOUND:
            hr = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE);
            break;

        case WBEM_E_ACCESS_DENIED:
            hr = E_ACCESSDENIED;
            break;

        case WBEM_E_PROVIDER_FAILURE:
            hr = E_FAIL;
            break;

        case WBEM_E_TYPE_MISMATCH:
        case WBEM_E_INVALID_CONTEXT:
        case WBEM_E_INVALID_PARAMETER:
            hr = E_INVALIDARG;
            break;

        case WBEM_E_OUT_OF_MEMORY:
            hr = E_OUTOFMEMORY;
            break;

    }
    
    if ( (hr == S_OK) && (!g_CIMSucceeded) )
    {
        return E_FAIL;
    }
    else
    {
        return hr;
    }
}

HRESULT WINAPI
    UpdateVersionInfoGlobalsFromLocalMachine()
{
    HRESULT hr = S_OK;
    BOOL fFailed = FALSE;

    do
    {
        OSVERSIONINFOEX osv;
        ZeroMemory(&osv, sizeof(OSVERSIONINFOEX));
        osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        
        if (!GetVersionEx( reinterpret_cast<LPOSVERSIONINFO>(&osv)))
        {
            fFailed = TRUE;
            break;
        }

        g_CIMOSType = 18; // WINNT
        g_CIMOSProductSuite = osv.wSuiteMask;

#if defined(_X86_)
        g_CIMProcessorArchitecture = 0;
#elif defined(_IA64_)
        g_CIMProcessorArchitecture = 6;
#else
        fFailed = TRUE;
        break;
#endif
        wsprintf(g_CIMOSVersion, L"%d.%d.%d", osv.dwMajorVersion, osv.dwMinorVersion, osv.dwBuildNumber);
        wsprintf(g_CIMOSBuildNumber, L"%d", osv.dwBuildNumber);
        wsprintf(g_CIMServicePackMajorVersion, L"%d", osv.wServicePackMajor);
        wsprintf(g_CIMServicePackMinorVersion, L"%d", osv.wServicePackMinor);
        
        g_CIMSucceeded = TRUE;
        g_CIMAttempted = TRUE;

    } while (FALSE);

    if (fFailed)
    {
        return UpdateVersionInfoGlobalsFromWMI(NULL, NULL, NULL);
    }

    return hr;
}

HRESULT WINAPI
UpdateVersionInfoGlobals(LPCWSTR pwszMachine, LPCWSTR pwszUserName, LPCWSTR pwszPassword)
{
    HRESULT hr = S_OK;
    HRESULT hrWMI = S_OK;
    if (pwszMachine)
    {
        return UpdateVersionInfoGlobalsFromWMI(pwszMachine, pwszUserName, pwszPassword);
    }
    else // Resolve locally
    {
        hr = UpdateVersionInfoGlobalsFromLocalMachine();
#ifdef DBG
        UINT     CIMOSType = g_CIMOSType;
        UINT     CIMOSProductSuite = g_CIMOSProductSuite;
        UINT     CIMProcessorArchitecture = g_CIMProcessorArchitecture;

        WCHAR    CIMOSVersion[MAX_PATH];
        WCHAR    CIMOSBuildNumber[MAX_PATH];
        WCHAR    CIMServicePackMajorVersion[MAX_PATH];
        WCHAR    CIMServicePackMinorVersion[MAX_PATH];
        wcsncpy(CIMOSVersion, g_CIMOSVersion, MAX_PATH);
        wcsncpy(CIMOSBuildNumber, g_CIMOSBuildNumber, MAX_PATH);
        wcsncpy(CIMServicePackMajorVersion, g_CIMServicePackMajorVersion, MAX_PATH);
        wcsncpy(CIMServicePackMinorVersion, g_CIMServicePackMinorVersion, MAX_PATH);
            
        hrWMI = UpdateVersionInfoGlobalsFromWMI(pwszMachine, NULL, NULL);
        if(SUCCEEDED(hr) && SUCCEEDED(hrWMI))
        {
            if (  (CIMOSType != g_CIMOSType) ||
                  ( (CIMOSProductSuite & ~VER_SUITE_SINGLEUSERTS) != (g_CIMOSProductSuite & ~VER_SUITE_SINGLEUSERTS) ) ||
                  (CIMProcessorArchitecture != g_CIMProcessorArchitecture) ||
                  (0 != wcsncmp(CIMOSVersion, g_CIMOSVersion, MAX_PATH)) ||
                  (0 != wcsncmp(CIMOSBuildNumber, g_CIMOSBuildNumber, MAX_PATH)) ||
                  (0 != wcsncmp(CIMServicePackMajorVersion, g_CIMServicePackMajorVersion, MAX_PATH)) ||
                  (0 != wcsncmp(CIMServicePackMinorVersion, g_CIMServicePackMinorVersion, MAX_PATH)) )
            {
                WCHAR szAssertText[4096];
                wsprintf(szAssertText, L"NETSH.EXE: ASSERT - mismatch between GetVersionInfoEx and WMI information:\r\n"
                         L"CIMOSType: %x vs. %x\r\n"
                         L"CIMOSProductSuite: %x vs. %x\r\n"
                         L"CIMProcessorArchitecture: %x vs %x\r\n"
                         L"CIMOSVersion: %s vs. %s\r\n"
                         L"CIMOSBuildNumber: %s vs. %s\r\n"
                         L"CIMServicePackMajorVersion: %s vs. %s\r\n"
                         L"CIMServicePackMinorVersion: %s vs. %s\r\n",
                         CIMOSType, g_CIMOSType,
                         CIMOSProductSuite, g_CIMOSProductSuite,
                         CIMProcessorArchitecture, g_CIMProcessorArchitecture,
                         CIMOSVersion, g_CIMOSVersion, 
                         CIMOSBuildNumber, g_CIMOSBuildNumber, 
                         CIMServicePackMajorVersion, g_CIMServicePackMajorVersion, 
                         CIMServicePackMinorVersion, g_CIMServicePackMinorVersion);
                                        
                ASSERTMSG((PCHAR)(szAssertText), FALSE);
            }
        }
#endif
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\api.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    api.c

Abstract:

    Exported routines to transports for automatic connection
    management.

Author:

    Anthony Discolo (adiscolo)  17-Apr-1995

Environment:

    Kernel Mode

Revision History:

--*/

#include <ntddk.h>
//#include <ntifs.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "acddefs.h"
#include "request.h"
#include "mem.h"
#include "debug.h"

PACD_DISABLED_ADDRESSES pDisabledAddressesG;



//
// Driver enabled mode.  The automatic
// connection system service sets
// this depending on whether a user
// has logged in, and whether there's
// general network connectivity.
//
BOOLEAN fAcdEnabledG;

//
// Spin lock for this module.
//
KSPIN_LOCK AcdSpinLockG;

//
// Event signaled when the AcdNotificationRequestThread
// thread has a notification to process.
//
KEVENT AcdRequestThreadEventG;

//
// This is a list of one irp representing
// a user-space process waiting to create a
// new network connection given an address.
//
LIST_ENTRY AcdNotificationQueueG;

//
// This is a list of ACD_CONNECTION blocks representing
// requests from transports about unsuccessful connection
// attempts.  There may be multiple ACD_COMPLETION block
// linked onto the same ACD_CONNECTION, grouped by
// address.
//
LIST_ENTRY AcdConnectionQueueG;

//
// This is a list of ACD_COMPLETION blocks representing
// other requests from transports.
//
LIST_ENTRY AcdCompletionQueueG;

//
// The list of drivers that have binded
// with us.
//
LIST_ENTRY AcdDriverListG;

//
// Count of outstanding irps - we need to maintain this
// to limit the number of outstanding requests to acd
// ow there is a potential of running out of non-paged
// pool memory.
//
LONG lOutstandingRequestsG = 0;

// ULONG count = 0;

#define MAX_ACD_REQUESTS 100

//
// BOOLEAN that enables autoconnect notifications
// from redir/CSC.
//
extern BOOLEAN fAcdEnableRedirNotifs;

//
// Statistics
//
typedef struct _ACD_STATS {
    ULONG ulConnects;   // connection attempts
    ULONG ulCancels;    // connection cancels
} ACD_STATS;
ACD_STATS AcdStatsG[ACD_ADDR_MAX];

//
// Forward declarations
//
VOID
AcdPrintAddress(
    IN PACD_ADDR pAddr
    );

VOID
ClearRequests(
    IN KIRQL irql
    );

//
// External variables
//
extern ULONG ulAcdOpenCountG;



VOID
SetDriverMode(
    IN BOOLEAN fEnable
    )

/*++

DESCRIPTION
    Set the global driver mode value, and inform
    all bound transports of the change.

    Note: this call assumes AcdSpinLockG is already
    acquired.

ARGUMENTS
    fEnable: the new driver mode value

RETURN VALUE
    None.

--*/

{
    KIRQL dirql;
    PLIST_ENTRY pEntry;
    PACD_DRIVER pDriver;

    //
    // Set the new global driver mode value.
    //
    fAcdEnabledG = fEnable;
    //
    // Inform all the drivers that have binded
    // with us of the new enable mode.
    //
    for (pEntry = AcdDriverListG.Flink;
         pEntry != &AcdDriverListG;
         pEntry = pEntry->Flink)
    {
        pDriver = CONTAINING_RECORD(pEntry, ACD_DRIVER, ListEntry);

        KeAcquireSpinLock(&pDriver->SpinLock, &dirql);
        pDriver->fEnabled = fEnable;
        KeReleaseSpinLock(&pDriver->SpinLock, dirql);
    }
} // SetDriverMode



NTSTATUS
AcdEnable(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Set the enable mode for the driver.  This determines
    which notifications it will pass up to the automatic
    connection system service.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL: the supplied user buffer is too small to hold
        an ACD_ENABLE_MODE value.

    STATUS_SUCCESS: if the enabled bit was set successfully.

--*/

{
    KIRQL irql;
    BOOLEAN fEnable;

    //
    // Verify the input buffer is sufficient to hold
    // a BOOLEAN structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (BOOLEAN))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    fEnable = *(BOOLEAN *)pIrp->AssociatedIrp.SystemBuffer;
    SetDriverMode(fEnable);
    //
    // Clear all pending requests if
    // we are disabling the driver.
    //
    if (!fEnable)
    {
        ClearRequests(irql);

        if(pDisabledAddressesG->ulNumAddresses > 1)
        {
            PLIST_ENTRY pEntry;
            PACD_DISABLED_ADDRESS pDisabledAddress;
            
            while(pDisabledAddressesG->ulNumAddresses > 1)
            {
                pEntry = pDisabledAddressesG->ListEntry.Flink;

                RemoveEntryList(
                        pDisabledAddressesG->ListEntry.Flink);

                pDisabledAddress = 
                CONTAINING_RECORD(pEntry, ACD_DISABLED_ADDRESS, ListEntry);                        

                FREE_MEMORY(pDisabledAddress);

                pDisabledAddressesG->ulNumAddresses -= 1;
            }
        }
    }
    
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    return STATUS_SUCCESS;
} // AcdEnable



VOID
CancelNotification(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )

/*++

DESCRIPTION
    Generic cancel routine for irps on the AcdNotificationQueueG.

ARGUMENTS
    pDeviceObject: unused

    pIrp: pointer to the irp to be cancelled.

RETURN VALUE
    None.

--*/

{
    KIRQL irql;

    UNREFERENCED_PARAMETER(pDeviceObject);
    //
    // Mark this irp as cancelled.
    //
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;
    //
    // Remove it from our list.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // Release the spinlock Io Subsystem acquired.
    //
    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    //
    // Complete the request.
    //
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
} // CancelNotification



VOID
AcdCancelNotifications()

/*++

DESCRIPTION
    Cancel all irps on the AcdNotification queue.  Although
    technically more than one user address space can be waiting
    for these notifications, we allow only one at this time.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    KIRQL irql;
    PLIST_ENTRY pHead;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Complete all the irps in the list.
    //
    while ((pHead = ExInterlockedRemoveHeadList(
                      &AcdNotificationQueueG,
                      &AcdSpinLockG)) != NULL)
    {
        pIrp = CONTAINING_RECORD(pHead, IRP, Tail.Overlay.ListEntry);
        //
        // Mark this irp as cancelled.
        //
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pIrp->IoStatus.Information = 0;
        //
        // Complete the irp.
        //
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }
} // AcdCancelNotifications



NTSTATUS
AcdWaitForNotification(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Enqueue an connection notification irp.  This is done
    done by the automatic connection system service.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL: the supplied user buffer is too small to hold
        an ACD_NOTIFICATION structure.

    STATUS_PENDING: if the ioctl was successfully enqueued

    STATUS_SUCCESS: if there is a notification already available

--*/

{
    KIRQL irql, irql2;
    PLIST_ENTRY pHead;
    PACD_COMPLETION pCompletion;
    PACD_NOTIFICATION pNotification;
    PEPROCESS pProcess;

    //
    // Verify the output buffer is sufficient to hold
    // an ACD_NOTIFICATION structure - note that this
    // should only be called from rasuato service which
    // is a 64 bit process on win64. This should never
    // be called from a 32 bit process so no thunking is
    // done.
    //
    if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof (ACD_NOTIFICATION))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    IoAcquireCancelSpinLock(&irql);
    KeAcquireSpinLock(&AcdSpinLockG, &irql2);
    //
    // There is no notification available.
    // Mark the irp as pending and wait for one.
    //
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);
    //
    // Set the irp's cancel routine.
    //
    IoSetCancelRoutine(pIrp, CancelNotification);
    //
    // Append the irp at the end of the
    // connection notification list.
    //
    InsertTailList(&AcdNotificationQueueG, &pIrp->Tail.Overlay.ListEntry);
    //
    // Signal the request thread there is
    // work to do.
    //
    KeSetEvent(&AcdRequestThreadEventG, 0, FALSE);

    KeReleaseSpinLock(&AcdSpinLockG, irql2);
    IoReleaseCancelSpinLock(irql);

    return STATUS_PENDING;
} // AcdWaitForNotification



BOOLEAN
EqualAddress(
    IN PACD_ADDR p1,
    IN PACD_ADDR p2
    )
{
    ULONG i;

    if (p1->fType != p2->fType)
        return FALSE;

    switch (p1->fType) {
    case ACD_ADDR_IP:
        return (p1->ulIpaddr == p2->ulIpaddr);
    case ACD_ADDR_IPX:
        return (BOOLEAN)RtlEqualMemory(
                 &p1->cNode,
                 &p2->cNode,
                 ACD_ADDR_IPX_LEN);
    case ACD_ADDR_NB:
        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint((
              "EqualAddress: NB: (%15s,%15s) result=%d\n",
              p1->cNetbios,
              p2->cNetbios,
              RtlEqualMemory(&p1->cNetbios, &p2->cNetbios, ACD_ADDR_NB_LEN - 1)));
        }
        return (BOOLEAN)RtlEqualMemory(
                 &p1->cNetbios,
                 &p2->cNetbios,
                 ACD_ADDR_NB_LEN - 1);
    case ACD_ADDR_INET:
        for (i = 0; i < ACD_ADDR_INET_LEN; i++) {
            if (p1->szInet[i] != p2->szInet[i])
                return FALSE;
            if (p1->szInet[i] == '\0' || p2->szInet[i] == '\0')
                break;
        }
        return TRUE;
    default:
        ASSERT(FALSE);
        break;
    }

    return FALSE;
} // EqualAddress



PACD_CONNECTION
FindConnection(
    IN PACD_ADDR pAddr
    )

/*++

DESCRIPTION
    Search for a connection block with the specified
    address.

ARGUMENTS
    pAddr: a pointer to the target ACD_ADDR

RETURN VALUE
    A PACD_CONNECTION with the specified address, if found;
    otherwise NULL.

--*/

{
    PLIST_ENTRY pEntry;
    PACD_CONNECTION pConnection;
    PACD_COMPLETION pCompletion;

    for (pEntry = AcdConnectionQueueG.Flink;
         pEntry != &AcdConnectionQueueG;
         pEntry = pEntry->Flink)
    {
        pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);
        pCompletion = CONTAINING_RECORD(pConnection->CompletionList.Flink, ACD_COMPLETION, ListEntry);

        if (EqualAddress(pAddr, &pCompletion->notif.addr))
            return pConnection;
    }

    return NULL;
} // FindConnection



NTSTATUS
AcdConnectionInProgress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Refresh the progress indicator for the connection
    attempt.  If the progress indicator is not updated
    by the user

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_INVALID_CONNECTION: if there is no connection
        attempt in progress.

    STATUS_SUCCESS

--*/

{
    KIRQL irql;
    PACD_STATUS pStatus;
    PACD_CONNECTION pConnection;

    //
    // Verify the input buffer is sufficient to hold
    // a BOOLEAN structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (ACD_STATUS))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Get the success code from the
    // connection attempt and pass it
    // to the completion routine.
    //
    pStatus = (PACD_STATUS)pIrp->AssociatedIrp.SystemBuffer;
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    pConnection = FindConnection(&pStatus->addr);
    if (pConnection != NULL)
        pConnection->fProgressPing = TRUE;
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    return (pConnection != NULL) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
} // AcdConnectionInProgress



BOOLEAN
AddCompletionToConnection(
    IN PACD_COMPLETION pCompletion
    )
{
    PACD_CONNECTION pConnection;

    pConnection = FindConnection(&pCompletion->notif.addr);
    //
    // If the connection already exists, then add
    // the completion request to its list.
    //
    if (pConnection != NULL) {
        InsertTailList(&pConnection->CompletionList, &pCompletion->ListEntry);
        return TRUE;
    }
    //
    // This is a connection to a new address.
    // Create the connection block, enqueue it,
    // and start the connection timer.
    //
    ALLOCATE_CONNECTION(pConnection);
    if (pConnection == NULL) {
        // DbgPrint("AddCompletionToConnection: ExAllocatePool failed\n");
        return FALSE;
    }
    pConnection->fNotif = FALSE;
    pConnection->fProgressPing = FALSE;
    pConnection->fCompleting = FALSE;
    pConnection->ulTimerCalls = 0;
    pConnection->ulMissedPings = 0;
    InitializeListHead(&pConnection->CompletionList);
    InsertHeadList(&pConnection->CompletionList, &pCompletion->ListEntry);
    InsertTailList(&AcdConnectionQueueG, &pConnection->ListEntry);
    return TRUE;
} // AddCompletionToConnection



BOOLEAN
AddCompletionBlock(
    IN ULONG ulDriverId,
    IN PACD_ADDR pAddr,
    IN ULONG ulFlags,
    IN PACD_ADAPTER pAdapter,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )

/*++

DESCRIPTION
    Create a block that represents an outstanding
    transport request waiting for an automatic
    connection.  Link this block into the global
    list of outstanding transport requests.

ARGUMENTS
    ulDriverId: a unique value for the transport driver

    pAddr: the network address of the connection

    ulFlags: connection flags

    pAdapter: pointer to adapter identifier

    pProc: a completion callback procedure

    nArgs: the number of parameters passed in pArgs

    pArgs: the parameters to pProc

RETURN VALUE
    TRUE if successful, FALSE otherwise

--*/

{
    PACD_COMPLETION pCompletion;
    ULONG i;

    if(lOutstandingRequestsG >= MAX_ACD_REQUESTS)
    {
        /*
        if(0 == (count % 5))
        {
            count += 1;
        }
        */
        return FALSE;
    }

    ALLOCATE_MEMORY(
      sizeof (ACD_COMPLETION) + ((nArgs - 1) * sizeof (PVOID)),
      pCompletion);
    if (pCompletion == NULL) {
        // DbgPrint("AcdAddCompletionBlock: ExAllocatePool failed\n");
        return FALSE;
    }
    //
    // Copy the arguments into the information block.
    //
    pCompletion->ulDriverId = ulDriverId;
    pCompletion->fCanceled = FALSE;
    pCompletion->fCompleted = FALSE;
    RtlCopyMemory(&pCompletion->notif.addr, pAddr, sizeof (ACD_ADDR));

    pCompletion->notif.Pid = PsGetCurrentProcessId();

    // DbgPrint("ACD: request by Process %lx\n",
    //         pCompletion->notif.Pid);
    
    pCompletion->notif.ulFlags = ulFlags;
    if (pAdapter != NULL) {
        RtlCopyMemory(
          &pCompletion->notif.adapter,
          pAdapter,
          sizeof (ACD_ADAPTER));
    }
    else
        RtlZeroMemory(&pCompletion->notif.adapter, sizeof (ACD_ADAPTER));
    pCompletion->pProc = pProc;
    pCompletion->nArgs = nArgs;
    for (i = 0; i < nArgs; i++)
        pCompletion->pArgs[i] = pArgs[i];
    //
    // If this is a unsuccessful connection request,
    // then insert it onto the connection queue for
    // that address; Otherwise, insert it into the list
    // for all other requests.
    //
    if (ulFlags & ACD_NOTIFICATION_SUCCESS) {
        InsertTailList(&AcdCompletionQueueG, &pCompletion->ListEntry);
    }
    else {
        if (!AddCompletionToConnection(pCompletion)) {
            FREE_MEMORY(pCompletion);
            return FALSE;
        }
    }

    lOutstandingRequestsG++;
    
    //
    // Inform the request thread
    // there is new work to do.
    //
    KeSetEvent(&AcdRequestThreadEventG, 0, FALSE);

    return TRUE;
} // AddCompletionBlock



VOID
AcdNewConnection(
    IN PACD_ADDR pAddr,
    IN PACD_ADAPTER pAdapter
    )
{
    KIRQL irql;

    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint(("AcdNewConnection: "));
        AcdPrintAddress(pAddr);
        AcdPrint(("\n"));
    }
    //
    // If the driver is disabled, then fail
    // all requests.
    //
    if (!fAcdEnabledG) {
        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint(("AcdNewConnection: driver disabled\n"));
        }
        return;
    }
    //
    // Acquire our spin lock.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Allocate a new completion block.
    //
    AddCompletionBlock(
      0,
      pAddr,
      ACD_NOTIFICATION_SUCCESS,
      pAdapter,
      NULL,
      0,
      NULL);
    //
    // Release the spin lock.
    //
    KeReleaseSpinLock(&AcdSpinLockG, irql);
} // AcdNewConnection



BOOLEAN
AcdStartConnection(
    IN ULONG ulDriverId,
    IN PACD_ADDR pAddr,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )

/*++

DESCRIPTION
    Create a new connection completion block, and enqueue
    it on the list of network requests to be completed when
    a new network connection has been created.

ARGUMENTS
    ulDriverId: a unique value for the transport driver

    pAddr: the address of the connection attempt

    ulFlags: connection flags

    pProc: the transport callback to be called when a new
        connection has been created.

    nArgs: the number of arguments to pProc.

    pArgs: a pointer to an array of pProc's parameters

RETURN VALUE
    TRUE if successful, FALSE otherwise.

--*/

{
    BOOLEAN fSuccess = FALSE, fFound;
    KIRQL irql;
    ULONG ulAttributes = 0;
    PACD_COMPLETION pCompletion;
    PCHAR psz, pszOrg;
    ACD_ADDR szOrgAddr;

    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint(("AcdStartConnection: "));
        AcdPrintAddress(pAddr);
        AcdPrint((", ulFlags=0x%x\n", ulFlags));
    }
    //
    // If the driver is disabled, then fail
    // all requests.
    //
    if (!fAcdEnabledG) {
        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint(("AcdStartConnection: driver disabled\n"));
        }
        return FALSE;
    }
    //
    // Validate the address type.
    //
    if ((ULONG)pAddr->fType >= ACD_ADDR_MAX) {
        AcdPrint(("AcdStartConnection: bad address type (%d)\n", pAddr->fType));
        return FALSE;
    }
    //
    // Acquire our spin lock.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Update statistics.
    //
    AcdStatsG[pAddr->fType].ulConnects++;
    //
    // Allocate a new completion block.
    //
    fSuccess = AddCompletionBlock(
                 ulDriverId,
                 pAddr,
                 ulFlags,
                 NULL,
                 pProc,
                 nArgs,
                 pArgs);
    //
    // Release the spin lock.
    //
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    return fSuccess;
} // AcdStartConnection



BOOLEAN
AcdCancelConnection(
    IN ULONG ulDriverId,
    IN PACD_ADDR pAddr,
    IN ACD_CANCEL_CALLBACK pProc,
    IN PVOID pArg
    )

/*++

DESCRIPTION
    Remove a previously enqueued connection information
    block from the list.

ARGUMENTS
    ulDriverId: a unique value for the transport driver

    pAddr: the address of the connection attempt

    pProc: the enumerator procecdure

    pArg: the enumerator procedure argument

RETURN VALUE
    None.

--*/

{
    BOOLEAN fCanceled = FALSE;
    KIRQL irql;
    PLIST_ENTRY pEntry;
    PACD_CONNECTION pConnection;
    PACD_COMPLETION pCompletion;

    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint(("AcdCancelConnection: ulDriverId=0x%x, "));
        AcdPrintAddress(pAddr);
        AcdPrint(("\n"));
    }
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Enumerate the list looking for
    // the information block with the
    // supplied parameters.
    //
    pConnection = FindConnection(pAddr);
    if (pConnection != NULL) {
        for (pEntry = pConnection->CompletionList.Flink;
             pEntry != &pConnection->CompletionList;
             pEntry = pEntry->Flink)
        {
            pCompletion = CONTAINING_RECORD(pEntry, ACD_COMPLETION, ListEntry);
            //
            // If we have a match, remove it from
            // the list and free the information block.
            //
            if (pCompletion->ulDriverId == ulDriverId &&
                !pCompletion->fCanceled &&
                !pCompletion->fCompleted)
            {
                IF_ACDDBG(ACD_DEBUG_CONNECTION) {
                    AcdPrint((
                      "AcdCancelConnection: pCompletion=0x%x\n",
                      pCompletion));
                }
                if ((*pProc)(
                         pArg,
                         pCompletion->notif.ulFlags,
                         pCompletion->pProc,
                         pCompletion->nArgs,
                         pCompletion->pArgs))
                {
                    pCompletion->fCanceled = TRUE;
                    fCanceled = TRUE;
                    //
                    // Update statistics.
                    //
                    AcdStatsG[pAddr->fType].ulCancels++;
                    break;
                }
            }
        }
    }
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    return fCanceled;
} // AcdCancelConnection



VOID
ConnectAddressComplete(
    BOOLEAN fSuccess,
    PVOID *pArgs
    )
{
    PIRP pIrp = pArgs[0];
    PIO_STACK_LOCATION pIrpSp = pArgs[1];
    KIRQL irql;

    //
    // Complete the request.
    //
    pIrp->IoStatus.Status = fSuccess ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    pIrp->IoStatus.Information = 0;
    IoAcquireCancelSpinLock(&irql);
    IoSetCancelRoutine(pIrp, NULL);
    IoReleaseCancelSpinLock(irql);
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
} // ConnectAddressComplete



BOOLEAN
CancelConnectAddressCallback(
    IN PVOID pArg,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )
{
    return (nArgs == 2 && pArgs[0] == pArg);
} // CancelConnectAddressCallback



VOID
CancelConnectAddress(
    PDEVICE_OBJECT pDevice,
    PIRP pIrp
    )
{
    KIRQL irql;
    PACD_NOTIFICATION pNotification;

    ASSERT(pIrp->Cancel);
    //
    // Remove our outstanding request.
    //
    pNotification = (PACD_NOTIFICATION)pIrp->AssociatedIrp.SystemBuffer;
    //
    // If we can't find the request on the connection
    // list, then it has already been completed.
    //
    if (!AcdCancelConnection(
          0,
          &pNotification->addr,
          CancelConnectAddressCallback,
          pIrp))
    {
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        return;
    }
    //
    // Mark this irp as cancelled.
    //
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;
    IoSetCancelRoutine(pIrp, NULL);
    //
    // Release the spin lock the I/O system acquired.
    //
    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    //
    // Complete the I/O request.
    //
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
} // CancelConnectAddress

BOOLEAN
FDisabledAddress(
    IN  ACD_ADDR *pAddr
    )
{
    BOOLEAN bRet = FALSE;
    KIRQL irql;
    PACD_DISABLED_ADDRESS pDisabledAddress;
    PLIST_ENTRY pEntry;

    KeAcquireSpinLock(&AcdSpinLockG, &irql);

    if(!fAcdEnabledG)
    {
        KeReleaseSpinLock(&AcdSpinLockG, irql);
        return FALSE;
    }

    for (pEntry = pDisabledAddressesG->ListEntry.Flink;
         pEntry != &pDisabledAddressesG->ListEntry;
         pEntry = pEntry->Flink)
    {
        pDisabledAddress = 
        CONTAINING_RECORD(pEntry, ACD_DISABLED_ADDRESS, ListEntry);

        if(pDisabledAddress->EnableAddress.fDisable &&
            RtlEqualMemory(
            pDisabledAddress->EnableAddress.addr.szInet,
            pAddr->szInet,
            ACD_ADDR_INET_LEN))
        {
            bRet = TRUE;
        }
    }
    
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    //DbgPrint("FDisabledAddress: Address %s. Disabled=%d\n",
    //        pAddr->szInet, bRet);

    return bRet;
}


NTSTATUS
AcdConnectAddress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Manufacture a call to ourselves to simulate a transport
    requesting an automatic connection.  This allows a user
    address space to initiate an automatic connection.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL: the supplied user buffer is too small to hold
        an ACD_NOTIFICATION structure.

    STATUS_UNSUCCESSFUL: an error occurred initiating the
        automatic connection.

    STATUS_PENDING: success

--*/

{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    KIRQL irql;
    PACD_NOTIFICATION pNotification;
    PVOID pArgs[2];
    ACD_ADDR *pAddr;
    ACD_ADAPTER *pAdapter;
    ULONG ulFlags;

    //
    // Verify the input buffer is sufficient to hold
    // an ACD_NOTIFICATION (_32) structure.
    //
#if defined (_WIN64)
    ACD_NOTIFICATION_32 *pNotification32;
    
    if(IoIs32bitProcess(pIrp))
    {
        if(pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ACD_NOTIFICATION_32))
        {
            return STATUS_BUFFER_TOO_SMALL;
        }
    }
    else
#endif
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
          sizeof (ACD_NOTIFICATION))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Doing the whole 32 bit stuff for correctness. The code will
    // work even if left alone i.e casting the systembuffer to
    // ACD_NOTIFICATION * [raos].
    //
#if defined (_WIN64)
    if(IoIs32bitProcess(pIrp))
    {
        pNotification32 = (PACD_NOTIFICATION_32) 
                          pIrp->AssociatedIrp.SystemBuffer;

        pAddr = &pNotification32->addr;                          
        pAdapter = &pNotification32->adapter;
        ulFlags = pNotification32->ulFlags;
        
    }
    else
#endif
    {
        pNotification = (PACD_NOTIFICATION)pIrp->AssociatedIrp.SystemBuffer;
        pAddr = &pNotification->addr;
        pAdapter = &pNotification->adapter;
        ulFlags = pNotification->ulFlags;
    }

    if(FDisabledAddress(pAddr))
    {
        //DbgPrint("AcdConnectAddress: returning because address is disabled\n");
        return status;
    }

    pArgs[0] = pIrp;
    pArgs[1] = pIrpSp;
    //
    // Start the connection.
    //
    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint(("AcdConnectAddress: "));
        AcdPrintAddress(pAddr);
        AcdPrint((", ulFlags=0x%x\n", ulFlags));
    }
    if (ulFlags & ACD_NOTIFICATION_SUCCESS) {
        AcdNewConnection(
          pAddr,
          pAdapter);
        status = STATUS_SUCCESS;
    }
    else {
        IoAcquireCancelSpinLock(&irql);
        if (AcdStartConnection(
                     0,
                     pAddr,
                     ulFlags,
                     ConnectAddressComplete,
                     2,
                     pArgs))
        {
            //
            // We enqueued the request successfully.
            // Mark the irp as pending.
            //
            IoSetCancelRoutine(pIrp, CancelConnectAddress);
            IoMarkIrpPending(pIrp);
            status = STATUS_PENDING;
        }
        IoReleaseCancelSpinLock(irql);
    }

    return status;
} // AcdConnectAddress

NTSTATUS
AcdQueryState(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    KIRQL irql;
    
    if(pIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(BOOLEAN))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    KeAcquireSpinLock(&AcdSpinLockG, &irql);

    if(fAcdEnableRedirNotifs)
    {
        *(BOOLEAN *)pIrp->AssociatedIrp.SystemBuffer = fAcdEnabledG;
    }
    else
    {
        *(BOOLEAN *)pIrp->AssociatedIrp.SystemBuffer = FALSE;
    }
    
    pIrp->IoStatus.Information = sizeof(BOOLEAN);
    KeReleaseSpinLock(&AcdSpinLockG, irql);

    // KdPrint(("AcdQueryState: returned %d\n",
    //    *(BOOLEAN *)pIrp->AssociatedIrp.SystemBuffer));

    return STATUS_SUCCESS;
}



VOID
AcdSignalCompletionCommon(
    IN PACD_CONNECTION pConnection,
    IN BOOLEAN fSuccess
    )
{
    KIRQL irql;
    PLIST_ENTRY pEntry;
    PACD_COMPLETION pCompletion;
    BOOLEAN fFound;

    IF_ACDDBG(ACD_DEBUG_CONNECTION) {
        AcdPrint((
          "AcdSignalCompletionCommon: pConnection=0x%x, fCompleting=%d\n",
          pConnection,
          pConnection->fCompleting));
    }
again:
    fFound = FALSE;
    //
    // Acquire our lock and look for
    // the next uncompleted request.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    for (pEntry = pConnection->CompletionList.Flink;
         pEntry != &pConnection->CompletionList;
         pEntry = pEntry->Flink)
    {
        pCompletion = CONTAINING_RECORD(pEntry, ACD_COMPLETION, ListEntry);

        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint((
              "AcdSignalCompletionCommon: pCompletion=0x%x, fCanceled=%d, fCompleted=%d\n",
              pCompletion,
              pCompletion->fCanceled,
              pCompletion->fCompleted));
        }
        //
        // Only complete this request if it
        // hasn't already been completed
        // or canceled.
        //
        if (!pCompletion->fCanceled && !pCompletion->fCompleted) {
            pCompletion->fCompleted = TRUE;
            fFound = TRUE;
            break;
        }
    }
    //
    // If there are no more requests to
    // complete then remove this connection
    // from the connection list and free its
    // memory.
    //
    if (!fFound) {
        RemoveEntryList(&pConnection->ListEntry);
        while (!IsListEmpty(&pConnection->CompletionList)) {
            pEntry = RemoveHeadList(&pConnection->CompletionList);
            pCompletion = CONTAINING_RECORD(pEntry, ACD_COMPLETION, ListEntry);

            FREE_MEMORY(pCompletion);

            lOutstandingRequestsG--;
            
        }
        FREE_CONNECTION(pConnection);
        //
        // Signal the request thread that
        // the connection list has changed.
        //
        KeSetEvent(&AcdRequestThreadEventG, 0, FALSE);
    }
    //
    // Release our lock.
    //
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // If we found a request, then
    // call its completion proc.
    //
    if (fFound) {
        IF_ACDDBG(ACD_DEBUG_CONNECTION) {
            AcdPrint(("AcdSignalCompletionCommon: pCompletion=0x%x, ", pCompletion));
            AcdPrintAddress(&pCompletion->notif.addr);
            AcdPrint(("\n"));
        }
        (*pCompletion->pProc)(fSuccess, pCompletion->pArgs);
        //
        // Look for another request.
        //
        goto again;
    }
} // AcdSignalCompletionCommon



NTSTATUS
AcdSignalCompletion(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    For each thread waiting on the AcdCompletionQueueG,
    call the transport-dependent callback to retry the
    connection attempt and complete the irp.

ARGUMENTS
    pIrp: unused

    pIrpSp: unused

RETURN VALUE
    STATUS_SUCCESS

--*/

{
    KIRQL irql;
    PACD_STATUS pStatus;
    PACD_CONNECTION pConnection;
    BOOLEAN fFound = FALSE;

    //
    // Verify the input buffer is sufficient to hold
    // a BOOLEAN structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (ACD_STATUS))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Get the success code from the
    // connection attempt and pass it
    // to the completion routine.
    //
    pStatus = (PACD_STATUS)pIrp->AssociatedIrp.SystemBuffer;
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    pConnection = FindConnection(&pStatus->addr);
    if (pConnection != NULL && !pConnection->fCompleting) {
        //
        // Set the completion-in-progress flag so
        // this request cannot be timed-out after
        // we release the spin lock.
        //
        pConnection->fCompleting = TRUE;
        fFound = TRUE;
    }
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // If we didn't find the connection block,
    // or the completion was already in progress,
    // then return an error.
    //
    if (!fFound)
        return STATUS_UNSUCCESSFUL;

    AcdSignalCompletionCommon(pConnection, pStatus->fSuccess);
    return STATUS_SUCCESS;
} // AcdSignalCompletion

NTSTATUS
AcdpEnableAddress(PACD_ENABLE_ADDRESS  pEnableAddress)
{
    PLIST_ENTRY pEntry = NULL;
    PACD_DISABLED_ADDRESS pDisabledAddress = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;
    
    KeAcquireSpinLock(&AcdSpinLockG, &irql);

    ASSERT(pDisabledAddressesG->ulNumAddresses >= 1);
    
    if(pDisabledAddressesG->ulNumAddresses == 1)
    {
        pDisabledAddress =
        CONTAINING_RECORD(pDisabledAddressesG->ListEntry.Flink, 
                    ACD_DISABLED_ADDRESS, ListEntry);

        RtlZeroMemory(&pDisabledAddress->EnableAddress,
                        sizeof(ACD_ENABLE_ADDRESS));

        //DbgPrint("AcdEnableAddress: reenabling\n");                            
    }
    else if(pDisabledAddressesG->ulNumAddresses > 1)
    {
        for (pEntry = pDisabledAddressesG->ListEntry.Flink;
             pEntry != &pDisabledAddressesG->ListEntry;
             pEntry = pEntry->Flink)
        {
            pDisabledAddress = 
            CONTAINING_RECORD(pEntry, ACD_DISABLED_ADDRESS, ListEntry);

            if(RtlEqualMemory(
                pDisabledAddress->EnableAddress.addr.szInet,
                pEnableAddress->addr.szInet,
                ACD_ADDR_INET_LEN))
            {
                break;
            }
        }

        if(pEntry != &pDisabledAddressesG->ListEntry)
        {
            //DbgPrint("AcdEnableAddress: removing %s (%p) from disabled list\n",
            //         pDisabledAddress->EnableAddress.addr.szInet,
            //         pDisabledAddress);

            RemoveEntryList(pEntry);
            pDisabledAddressesG->ulNumAddresses -= 1;
        }
        else
        {
            pEntry = NULL;
        }
        
    }

    KeReleaseSpinLock(&AcdSpinLockG, irql);

    if(pEntry != NULL)
    {
        FREE_MEMORY(pDisabledAddress);
    }

    return status;
}

NTSTATUS
AcdpDisableAddress(PACD_ENABLE_ADDRESS pEnableAddress)
{
    PACD_DISABLED_ADDRESS pDisabledAddress;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;
    
    KeAcquireSpinLock(&AcdSpinLockG, &irql);

    ASSERT(pDisabledAddressesG->ulNumAddresses >= 1);
    pDisabledAddress = 
    CONTAINING_RECORD(pDisabledAddressesG->ListEntry.Flink, 
                ACD_DISABLED_ADDRESS, ListEntry);

    if(!pDisabledAddress->EnableAddress.fDisable)
    {
        RtlCopyMemory(&pDisabledAddress->EnableAddress, 
                      pEnableAddress, 
                      sizeof(ACD_ENABLE_ADDRESS));

        KeReleaseSpinLock(&AcdSpinLockG, irql);                          
                  
    }                      
    else if(pDisabledAddressesG->ulNumAddresses < 
                pDisabledAddressesG->ulMaxAddresses)
    {
        KeReleaseSpinLock(&AcdSpinLockG, irql);
        
        ALLOCATE_MEMORY(sizeof(ACD_DISABLED_ADDRESS), pDisabledAddress);
        if(pDisabledAddress != NULL)
        {
            RtlCopyMemory(&pDisabledAddress->EnableAddress,
                         pEnableAddress,
                         sizeof(ACD_ENABLE_ADDRESS));

            //DbgPrint("AcdEnableAddress: Adding %p to list \n",
            //        pDisabledAddress)                             ;

            KeAcquireSpinLock(&AcdSpinLockG, &irql);                             
            InsertTailList(&pDisabledAddressesG->ListEntry, 
                           &pDisabledAddress->ListEntry);   
            pDisabledAddressesG->ulNumAddresses += 1;                               
            KeReleaseSpinLock(&AcdSpinLockG, irql);
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //DbgPrint("AcdDisableAddress: Disabling %s, status=0x%x\n",
    //         pEnableAddress->addr.szInet, status);

    return status;             
        
 }

NTSTATUS
AcdEnableAddress(
    IN PIRP                 pIrp,
    IN PIO_STACK_LOCATION   pIrpSp
    )
{
    PACD_ENABLE_ADDRESS pEnableAddress;
    KIRQL irql;
    PACD_DISABLED_ADDRESS pDisabledAddress = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    
    if(pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ACD_ENABLE_ADDRESS))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if(!fAcdEnabledG)
    {
        return STATUS_UNSUCCESSFUL;
    }

    pEnableAddress = (PACD_ENABLE_ADDRESS)pIrp->AssociatedIrp.SystemBuffer;

    if(pEnableAddress->fDisable)
    {
        Status = AcdpDisableAddress(pEnableAddress);
    }
    else
    {
        Status = AcdpEnableAddress(pEnableAddress);
    }

    //DbgPrint("AcdEnableAddress. status=0x%x\n", Status);
    return Status;
    
}
    


VOID
ClearRequests(
    IN KIRQL irql
    )

/*++

DESCRIPTION
    Complete all pending requests with failure status.
    This call assumes the AcdSpinLockG is already held,
    and it returns with it held.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    PLIST_ENTRY pHead, pEntry;
    PACD_COMPLETION pCompletion;
    PACD_CONNECTION pConnection;

again:
    //
    // Complete all pending connections with
    // an error.
    //
    for (pEntry = AcdConnectionQueueG.Flink;
         pEntry != &AcdConnectionQueueG;
         pEntry = pEntry->Flink)
    {
        pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);

        if (!pConnection->fCompleting) {
            pConnection->fCompleting = TRUE;
            //
            // We need to release our lock to
            // complete the request.
            //
            KeReleaseSpinLock(&AcdSpinLockG, irql);
            //
            // Complete the request.
            //
            AcdSignalCompletionCommon(pConnection, FALSE);
            //
            // Check for more uncompleted requests.
            //
            KeAcquireSpinLock(&AcdSpinLockG, &irql);
            goto again;
        }
    }
    //
    // Clear out all other pending requests.
    //
    while (!IsListEmpty(&AcdCompletionQueueG)) {
        pHead = RemoveHeadList(&AcdCompletionQueueG);
        pCompletion = CONTAINING_RECORD(pHead, ACD_COMPLETION, ListEntry);

        FREE_MEMORY(pCompletion);

        lOutstandingRequestsG--;

    }
} // ClearRequests



VOID
AcdReset()

/*++

DESCRIPTION
    Complete all pending requests with failure status.
    This is called when the reference count on the driver
    object goes to zero, and prevents stale requests from
    being presented to the system service if it is restarted
    when there are pending completion requests.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    KIRQL irql;
    PLIST_ENTRY pHead, pEntry;
    PACD_COMPLETION pCompletion;
    PACD_CONNECTION pConnection;

    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Reset the notification mode to disabled.
    //
    SetDriverMode(FALSE);
    //
    // Complete all pending connections with
    // an error.
    //
    ClearRequests(irql);
    KeReleaseSpinLock(&AcdSpinLockG, irql);
} // AcdReset



NTSTATUS
AcdBind(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Return the list of entry points to a client
    transport driver.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL if the supplied SystemBuffer is too
    small.  STATUS_SUCCESS otherwise.

--*/

{
    NTSTATUS status;
    PACD_DRIVER *ppDriver, pDriver;
    KIRQL irql, dirql;

    //
    // Verify the input buffer a pointer to
    // the driver's ACD_DRIVER structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (PACD_DRIVER))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    ppDriver = (PACD_DRIVER *)pIrp->AssociatedIrp.SystemBuffer;
    pDriver = *ppDriver;
#if DBG
    //
    // Selectively bind with some transports.
    //
    switch (pDriver->ulDriverId) {
    case 'Nbf ':
        break;
    case 'Tcp ':
#ifdef notdef
        DbgPrint("AcdBind: ignoring Tcp\n");
        pDriver->fEnabled = FALSE;
        pIrp->IoStatus.Information = 0;
        return STATUS_SUCCESS;
#endif
        break;
    case 'Nbi ':
#ifdef notdef
        DbgPrint("AcdBind: ignoring Nbi\n");
        pDriver->fEnabled = FALSE;
        pIrp->IoStatus.Information = 0;
        return STATUS_SUCCESS;
#endif
        break;
    }
#endif
    //
    // Fill in the entry point structure.
    //
    pDriver->lpfnNewConnection = AcdNewConnection;
    pDriver->lpfnStartConnection = AcdStartConnection;
    pDriver->lpfnCancelConnection = AcdCancelConnection;
    //
    // Insert this block into our driver list.
    //
    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    KeAcquireSpinLock(&pDriver->SpinLock, &dirql);
    pDriver->fEnabled = fAcdEnabledG;
    KeReleaseSpinLock(&pDriver->SpinLock, dirql);
    InsertTailList(&AcdDriverListG, &pDriver->ListEntry);
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // No data should be copied back.
    //
    pIrp->IoStatus.Information = 0;

    return STATUS_SUCCESS;
} // AcdBind



NTSTATUS
AcdUnbind(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )

/*++

DESCRIPTION
    Unbind a client transport driver.

ARGUMENTS
    pIrp: a pointer to the irp to be enqueued.

    pIrpSp: a pointer to the current irp stack.

RETURN VALUE
    STATUS_BUFFER_TOO_SMALL if the supplied SystemBuffer is too
    small.  STATUS_SUCCESS otherwise.

--*/

{
    KIRQL irql, dirql;
    PLIST_ENTRY pEntry, pEntry2;
    PACD_DRIVER *ppDriver, pDriver;
    PACD_CONNECTION pConnection;
    PACD_COMPLETION pCompletion;

    //
    // Verify the input buffer a pointer to
    // the driver's ACD_DRIVER structure.
    //
    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (PACD_DRIVER))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    ppDriver = (PACD_DRIVER *)pIrp->AssociatedIrp.SystemBuffer;
    pDriver = *ppDriver;

    KeAcquireSpinLock(&AcdSpinLockG, &irql);
    //
    // Enumerate the list looking for
    // any connection request initiated by the
    // specified driver.
    //
    for (pEntry = AcdConnectionQueueG.Flink;
         pEntry != &AcdConnectionQueueG;
         pEntry = pEntry->Flink)
    {
        pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);

        for (pEntry2 = pConnection->CompletionList.Flink;
             pEntry2 != &pConnection->CompletionList;
             pEntry2 = pEntry2->Flink)
        {
            pCompletion = CONTAINING_RECORD(pEntry2, ACD_COMPLETION, ListEntry);

            //
            // If we have a match, cancel it.
            //
            if (pCompletion->ulDriverId == pDriver->ulDriverId)
                pCompletion->fCanceled = TRUE;
        }
    }
    //
    // Set this driver's enable mode to ACD_ENABLE_NONE.
    //
    KeAcquireSpinLock(&pDriver->SpinLock, &dirql);
    pDriver->fEnabled = FALSE;
    KeReleaseSpinLock(&pDriver->SpinLock, dirql);
    //
    // Remove this driver from the list.
    //
    RemoveEntryList(&pDriver->ListEntry);
    KeReleaseSpinLock(&AcdSpinLockG, irql);
    //
    // No data should be copied back.
    //
    pIrp->IoStatus.Information = 0;

    return STATUS_SUCCESS;
} // AcdUnbind


VOID
AcdPrintAddress(
    IN PACD_ADDR pAddr
    )
{
#if DBG
    PUCHAR puc;

    switch (pAddr->fType) {
    case ACD_ADDR_IP:
        puc = (PUCHAR)&pAddr->ulIpaddr;
        AcdPrint(("IP: %d.%d.%d.%d", puc[0], puc[1], puc[2], puc[3]));
        break;
    case ACD_ADDR_IPX:
        AcdPrint((
          "IPX: %02x:%02x:%02x:%02x:%02x:%02x",
          pAddr->cNode[0],
          pAddr->cNode[1],
          pAddr->cNode[2],
          pAddr->cNode[3],
          pAddr->cNode[4],
          pAddr->cNode[5]));
        break;
    case ACD_ADDR_NB:
        AcdPrint(("NB: %15.15s", pAddr->cNetbios));
        break;
    case ACD_ADDR_INET:
        AcdPrint(("INET: %s", pAddr->szInet));
        break;
    default:
        AcdPrint(("UNKNOWN: ????"));
        break;
    }
#endif
} // AcdPrintAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\mem.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    mem.h

ABSTRACT
    Header file for memory allocation routines.

AUTHOR
    Anthony Discolo (adiscolo) 18-Aug-1995

REVISION HISTORY

--*/

//
// Pre-defined object types.
// Any other value represents a
// byte count.
//
#define ACD_OBJECT_CONNECTION    0
#define ACD_OBJECT_MAX           1

NTSTATUS
InitializeObjectAllocator();

PVOID
AllocateObjectMemory(
    IN ULONG fObject
    );

VOID
FreeObjectMemory(
    IN PVOID pObject
    );

VOID
FreeObjectAllocator();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\request.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    request.c

Abstract:

    Worker thread for the automatic connection driver.

Author:

    Anthony Discolo (adiscolo)  17-Apr-1995

Environment:

    Kernel Mode

Revision History:

--*/

#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "acddefs.h"
#include "mem.h"
#include "debug.h"

//
// External declarations
//
VOID AcdPrintAddress(
    IN PACD_ADDR pAddr
    );

extern LONG lOutstandingRequestsG;


VOID
ProcessCompletion(
    IN PACD_COMPLETION pCompletion,
    IN KIRQL irqlCancel,
    IN KIRQL irqlLock
    )
{
    PLIST_ENTRY pHead;
    KIRQL irql;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    PACD_NOTIFICATION pNotification;

    ASSERT(!IsListEmpty(&AcdNotificationQueueG));
    //
    // Complete the next irp in the
    // AcdNotificationQueueG queue.  These
    // represent the ioctl completions the
    // system service has posted.  Completing
    // this request will start the system service
    // to create a new RAS connection.
    // Logically, there is always just one.
    //
    pHead = RemoveHeadList(&AcdNotificationQueueG);
    pIrp = CONTAINING_RECORD(pHead, IRP, Tail.Overlay.ListEntry);
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    //
    // Disable the irp's cancel routine.
    //
    IoSetCancelRoutine(pIrp, NULL);

    //
    // The irp thats being completed below will always be
    // from a 64bit process. We are doing the check below
    // to protect against some penetration program trying
    // to break this code.
    //
    #if defined (_WIN64)
    if(IoIs32bitProcess(pIrp))
    {
        ACD_NOTIFICATION_32 *pNotification32 =
                (PACD_NOTIFICATION_32) pIrp->AssociatedIrp.SystemBuffer;

        RtlCopyMemory(
                &pNotification32->addr,
                &pCompletion->notif.addr,
                sizeof(ACD_ADDR));

        RtlCopyMemory(
                &pNotification32->adapter,
                &pCompletion->notif.adapter,
                sizeof(ACD_ADAPTER));

        pNotification32->ulFlags = pCompletion->notif.ulFlags;                
        pNotification32->Pid = (VOID * POINTER_32) HandleToUlong(
                            pCompletion->notif.Pid);
    }
    else
    #endif
    {
        //
        // Copy the success flag and the address into the
        // system buffer.  This will get copied into the
        // user's buffer on return.
        //
        pNotification = (PACD_NOTIFICATION)pIrp->AssociatedIrp.SystemBuffer;
        RtlCopyMemory(
          pNotification,
          &pCompletion->notif,
          sizeof (ACD_NOTIFICATION));
        IF_ACDDBG(ACD_DEBUG_WORKER) {
            AcdPrint(("AcdNotificationRequestThread: "));
            AcdPrintAddress(&pCompletion->notif.addr);
            AcdPrint((", ulFlags=0x%x\n", pCompletion->notif.ulFlags));
        }
    }
    
    //
    // We can release both the cancel lock
    // and our lock now.
    //
    KeReleaseSpinLock(&AcdSpinLockG, irqlLock);
    IoReleaseCancelSpinLock(irqlCancel);
    //
    // Set the status code and the number
    // of bytes to be copied back to the user
    // buffer.
    //
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = sizeof (ACD_NOTIFICATION);
    //
    // Complete the irp.
    //
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
} // ProcessCompletion



VOID
AcdNotificationRequestThread(
    PVOID context
    )

/*++

DESCRIPTION
    This thread handles the notification that an automatic
    connection may need to be initiated.  This needs to
    happen in a separate thread, because the notification
    may occur at DPC irql.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    KIRQL irql, irql2;
    PLIST_ENTRY pEntry, pEntry2;
    PACD_CONNECTION pConnection;
    PACD_COMPLETION pCompletion;
    BOOLEAN bStartTimer, bStopTimer;

    UNREFERENCED_PARAMETER(context);

    IoStartTimer(pAcdDeviceObjectG);

    for (;;) {
        bStartTimer = bStopTimer = FALSE;
        //
        // Acquire our lock.
        //
        IoAcquireCancelSpinLock(&irql);
        KeAcquireSpinLock(&AcdSpinLockG, &irql2);
        //
        // If there are no irps to complete,
        // then go back to sleep.
        //
        if (IsListEmpty(&AcdNotificationQueueG)) {
            IF_ACDDBG(ACD_DEBUG_WORKER) {
                AcdPrint(("AcdNotificationRequestThread: no ioctl to complete\n"));
            }
            KeReleaseSpinLock(&AcdSpinLockG, irql2);
            IoReleaseCancelSpinLock(irql);
            goto again;
        }
        //
        // Search for connections that haven't
        // been processed yet.
        //
        for (pEntry = AcdConnectionQueueG.Flink;
             pEntry != &AcdConnectionQueueG;
             pEntry = pEntry->Flink)
        {
            pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);

            //
            // Don't issue a request to the service
            // for more than one simultaneous connection.
            //
            IF_ACDDBG(ACD_DEBUG_WORKER) {
                AcdPrint((
                  "AcdNotificationRequestThread: pConnection=0x%x, fNotif=%d, fCompleting=%d\n",
                  pConnection,
                  pConnection->fNotif,
                  pConnection->fCompleting));
            }
            if (pConnection->fNotif)
                break;
            //
            // Skip all connections that are in
            // the process of being completed.
            //
            if (pConnection->fCompleting)
                continue;
            //
            // Make sure there is at least one
            // request in this connection that
            // hasn't been canceled.
            //
            for (pEntry2 = pConnection->CompletionList.Flink;
                 pEntry2 != &pConnection->CompletionList;
                 pEntry2 = pEntry2->Flink)
            {
                pCompletion = CONTAINING_RECORD(pEntry2, ACD_COMPLETION, ListEntry);

                if (!pCompletion->fCanceled) {
                    IF_ACDDBG(ACD_DEBUG_WORKER) {
                        AcdPrint((
                          "AcdNotificationRequestThread: starting pConnection=0x%x, pCompletion=0x%x\n",
                          pConnection,
                          pCompletion));
                    }
                    pConnection->fNotif = TRUE;
                    //
                    // This call releases both the cancel lock
                    // and our lock.
                    //
                    ProcessCompletion(pCompletion, irql, irql2);
                    //
                    // Start the connection timer.
                    //
                    bStartTimer = TRUE;
                    //
                    // We can only process one completion
                    // at a time.
                    //
                    goto again;
                }
            }
        }
        //
        // Complete other requests.
        //
        if (!IsListEmpty(&AcdCompletionQueueG)) {
            pEntry = RemoveHeadList(&AcdCompletionQueueG);
            pCompletion = CONTAINING_RECORD(pEntry, ACD_COMPLETION, ListEntry);

            IF_ACDDBG(ACD_DEBUG_WORKER) {
                AcdPrint((
                  "AcdNotificationRequestThread: starting pCompletion=0x%x\n",
                  pCompletion));
            }

            lOutstandingRequestsG--;

            //
            // This call releases both the cancel lock
            // and our lock.
            //
            ProcessCompletion(pCompletion, irql, irql2);
            //
            // We are done with the completion,
            // so we can free the memory now.
            //
            FREE_MEMORY(pCompletion);

            
            //
            // We can only process one completion
            // at a time.
            //
            goto again;

        }
        //
        // If there are no connections pending,
        // then stop the connection timer.
        //
        if (IsListEmpty(&AcdConnectionQueueG))
            bStopTimer = TRUE;
        //
        // Release our lock.
        //
        KeReleaseSpinLock(&AcdSpinLockG, irql2);
        IoReleaseCancelSpinLock(irql);
again:
        //
        // Start or stop the timer, depending
        // on what we found while we had the
        // spinlock.  We can't hold our spin
        // lock when we call the Io*Timer
        // routines.
        //
#ifdef notdef
        if (bStopTimer)
            IoStopTimer(pAcdDeviceObjectG);
        else if (bStartTimer)
            IoStartTimer(pAcdDeviceObjectG);
#endif

        //
        // Unload is telling us to stop. Exit
        //
        if (AcdStopThread == TRUE) {
            break;
        }
        //
        // Wait for something to do.  This event
        // will be signaled by AcdSignalNotification().
        //
        IF_ACDDBG(ACD_DEBUG_WORKER) {
            AcdPrint(("AcdNotificationRequestThread: waiting on AcdPendingCompletionEventG\n"));
        }
        KeWaitForSingleObject(
          &AcdRequestThreadEventG,
          Executive,
          KernelMode,
          FALSE,
          NULL);
        KeClearEvent(&AcdRequestThreadEventG);
        IF_ACDDBG(ACD_DEBUG_WORKER) {
            AcdPrint(("AcdNotificationRequestThread: AcdPendingCompletionEventG signalled\n"));
        }
    }
} // AcdNotificationRequestThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\mem.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.c

ABSTRACT
    Generic hash table manipulation routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>
#include <acdapi.h>

#include "acddefs.h"
#include "mem.h"
#include "debug.h"

//
// The maximum number of allocated
// objects we allocate from outside
// our zones.
//
#define MAX_ALLOCATED_OBJECTS   100

//
// Rounding up macro.
//
#define ROUNDUP(n, b)   (((n) + ((b) - 1)) & ~((b) - 1))



NTSTATUS
InitializeObjectAllocator()
{
    return STATUS_SUCCESS;    
} // InitializeObjectAllocator



VOID
FreeObjectAllocator()
{
} // FreeObjectAllocator
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\request.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    request.h

ABSTRACT
    Header file for completion queue routines.

AUTHOR
    Anthony Discolo (adiscolo) 18-Aug-1995

REVISION HISTORY

--*/

PACD_COMPLETION GetNextRequest();

BOOLEAN
EqualAddress(
    PACD_ADDR pszAddr1,
    PACD_ADDR pszAddr2
    );

PACD_COMPLETION GetNextRequestAddress(
    IN PACD_ADDR pszAddr
    );

PACD_COMPLETION GetCurrentRequest();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\ntinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntinit.c

Abstract:

    NT specific routines for loading and configuring the
    automatic connection notification driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  18-Apr-1995

Revision History:

--*/
#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "acddefs.h"
#include "mem.h"
#include "debug.h"


//
// Global variables
//
#if DBG
ULONG AcdDebugG = 0x0;    // see debug.h for flags
#endif

PDRIVER_OBJECT pAcdDriverObjectG;
PDEVICE_OBJECT pAcdDeviceObjectG;
PACD_DISABLED_ADDRESSES pDisabledAddressesG = NULL;


HANDLE hSignalNotificationThreadG;

BOOLEAN AcdStopThread = FALSE; // Set to TRUE to stop system thread
PETHREAD NotificationThread;
BOOLEAN fAcdEnableRedirNotifs = FALSE;

extern LONG lOutstandingRequestsG;

//
// Imported routines
//
VOID
AcdNotificationRequestThread(
    PVOID context
    );

//
// External function prototypes
//
NTSTATUS
AcdDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );

VOID
AcdConnectionTimer(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PVOID          pContext
    );

//
// Internal function prototypes
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

BOOLEAN
GetComputerName(
    IN PUCHAR szName,
    IN USHORT cbName
    );

VOID
AcdUnload(
    IN PDRIVER_OBJECT pDriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, AcdUnload)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    )

/*++

DESCRIPTION
    Initialization routine for the network connection notification driver.
    It creates the device object and initializes the driver.

ARGUMENTS
    pDriverObject: a pointer to the driver object created by the system.

    pRegistryPath - the name of the configuration node in the registry.

RETURN VALUE
    The final status from the initialization operation.

--*/

{
    NTSTATUS        status;
    UNICODE_STRING  deviceName;
    ULONG           i;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    PDEVICE_OBJECT pDeviceObject;
    PFILE_OBJECT pFileObject;
    PACD_DISABLED_ADDRESS pDisabledAddress = NULL;

    //
    // Initialize the spin lock.
    //
    KeInitializeSpinLock(&AcdSpinLockG);
    //
    // Initialize the notification and completion
    // connection queues.
    //
    InitializeListHead(&AcdNotificationQueueG);
    InitializeListHead(&AcdCompletionQueueG);
    InitializeListHead(&AcdConnectionQueueG);
    InitializeListHead(&AcdDriverListG);
    lOutstandingRequestsG = 0;
    //
    // Initialize our zone allocator.
    //
    status = InitializeObjectAllocator();
    if(!NT_SUCCESS(status))
    {
#if DBG
        DbgPrint("AcdDriverEntry: InitializeObjectAllocator"
                 " failed. (status=0x%x)\n",
                 status);
#endif

        return status;
    }
    //
    // Create the device object.
    //
    pAcdDriverObjectG = pDriverObject;
    RtlInitUnicodeString(&deviceName, ACD_DEVICE_NAME);
    status = IoCreateDevice(
               pDriverObject,
               0,
               &deviceName,
               FILE_DEVICE_ACD,
               0,
               FALSE,
               &pAcdDeviceObjectG);

    if (!NT_SUCCESS(status)) {
        DbgPrint(
          "AcdDriverEntry: IoCreateDevice failed (status=0x%x)\n",
          status);
        FreeObjectAllocator();
        return status;
    }
    //
    // Initialize the driver object.
    //
    pDriverObject->DriverUnload = AcdUnload;
    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
        pDriverObject->MajorFunction[i] = AcdDispatch;
    pDriverObject->FastIoDispatch = NULL;
    //
    // Initialize the connection timer.  This is
    // used to make sure pending requests aren't
    // blocked forever because the user-space
    // process died trying to make a connection.
    //
    IoInitializeTimer(pAcdDeviceObjectG, AcdConnectionTimer, NULL);

    {
        RTL_QUERY_REGISTRY_TABLE QueryTable[2];
        PWSTR EnableRedirNotifs = L"EnableRedirNotifications";
        PWSTR ParameterKey = L"RasAcd\\Parameters";
        ULONG ulEnableRedirNotifs = 0;
    
        //
        // Read the registry key that enables redir notifications
        //
        RtlZeroMemory(QueryTable, 2 * sizeof(RTL_QUERY_REGISTRY_TABLE));
        QueryTable[0].QueryRoutine = NULL;
        QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        QueryTable[0].Name = EnableRedirNotifs;
        QueryTable[0].EntryContext = (PVOID)&ulEnableRedirNotifs;
        QueryTable[0].DefaultType = 0;
        status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                        ParameterKey,
                                        &QueryTable[0],
                                        NULL,
                                        NULL);

        if((status == STATUS_SUCCESS) && (ulEnableRedirNotifs != 0))
        {
            fAcdEnableRedirNotifs = TRUE;
        }

        // KdPrint(("AcdDriverEntry: EnableRedirNotifs=%d\n", fAcdEnableRedirNotifs));
        
        status = STATUS_SUCCESS;
    }                                    
    
    
    //
    // Create the worker thread.  We need
    // a thread because these operations can occur at
    // DPC irql.
    //
    KeInitializeEvent(
      &AcdRequestThreadEventG,
      NotificationEvent,
      FALSE);
    status = PsCreateSystemThread(
        &hSignalNotificationThreadG,
        THREAD_ALL_ACCESS,
        NULL,
        NULL,
        NULL,
        AcdNotificationRequestThread,
        NULL);
    if (!NT_SUCCESS(status)) {
        DbgPrint(
          "AcdDriverEntry: PsCreateSystemThread failed (status=0x%x)\n",
          status);
        IoDeleteDevice(pAcdDeviceObjectG);
        FreeObjectAllocator();
        return status;
    }

    //
    // Allocate memory for keeping track of disabled addresses
    //
    ALLOCATE_MEMORY(sizeof(ACD_DISABLED_ADDRESSES), pDisabledAddressesG);

    if(pDisabledAddressesG == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        IoDeleteDevice(pAcdDeviceObjectG);
        FreeObjectAllocator();
        return status;
    }

    ALLOCATE_MEMORY(sizeof(ACD_DISABLED_ADDRESS), pDisabledAddress);

    if(pDisabledAddress == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        IoDeleteDevice(pAcdDeviceObjectG);
        FREE_MEMORY(pDisabledAddressesG);
        FreeObjectAllocator();
        return status;
    }

    RtlZeroMemory(pDisabledAddressesG, sizeof(ACD_DISABLED_ADDRESSES));
    RtlZeroMemory(pDisabledAddress, sizeof(ACD_DISABLED_ADDRESS));

    InitializeListHead(&pDisabledAddressesG->ListEntry);
    InsertTailList(&pDisabledAddressesG->ListEntry, &pDisabledAddress->ListEntry);
    pDisabledAddressesG->ulNumAddresses = 1;
    
    pDisabledAddressesG->ulMaxAddresses = 10;
    
    //
    // If this fails then we have no way to wait for the thread to terminate
    //
    status = ObReferenceObjectByHandle (hSignalNotificationThreadG,
                                        0,
                                        NULL,
                                        KernelMode,
                                        &NotificationThread,
                                        NULL);
    ASSERT (NT_SUCCESS (status));
    return STATUS_SUCCESS;
} // DriverEntry



VOID
AcdUnload(
    IN PDRIVER_OBJECT pDriverObject
    )
{
    NTSTATUS status;

    //
    // Terminate the system thread and wait for it to exit
    //
    AcdStopThread = TRUE;
    KeSetEvent(&AcdRequestThreadEventG, 0, FALSE); // Wake the thread so it sees to exit
    //
    // Wait for the thread to leave the drivers address space.
    //
    KeWaitForSingleObject (NotificationThread, Executive, KernelMode, FALSE, 0);

    ObDereferenceObject (NotificationThread);
    ZwClose (hSignalNotificationThreadG);
    //
    // Make sure to unlink all driver
    // blocks before unloading!
    //
    IoDeleteDevice(pAcdDeviceObjectG);
    
    if(pDisabledAddressesG)
    {
        PLIST_ENTRY pListEntry;
        PACD_DISABLED_ADDRESS pDisabledAddress;
        
        while(!IsListEmpty(&pDisabledAddressesG->ListEntry))
        {
            pListEntry = RemoveHeadList(&pDisabledAddressesG->ListEntry);
            pDisabledAddress = 
            CONTAINING_RECORD(pListEntry, ACD_DISABLED_ADDRESS, ListEntry);

            FREE_MEMORY(pDisabledAddress);
        }
        
        FREE_MEMORY(pDisabledAddressesG);
        pDisabledAddressesG = NULL;
    }        

    //
    // Free zone allocator.
    //
    FreeObjectAllocator();

} // AcdUnload
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\ntdisp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntdisp.c

Abstract:

    NT specific routines for dispatching and handling automatic
    connection notification IRPs.

    The basic architecture involves a user address space,
    a network transport, and this driver.

    The user address space is responsible for creating a
    new network connection given a notification from this
    driver (IOCTL_ACD_NOTIFICATION).  When it gets a
    notification, it is also responsible for pinging the
    this driver (IOCTL_ACD_KEEPALIVE) so it can be guaranteed
    the connection is progressing.  Once the connection is
    created, it informs this driver of the success or
    failure of the connection attempt (IOCTL_ACD_CONNECTION).

    Network transports are responsible for informing this
    driver of network unreachable errors via TdiConnect()
    or TdiSendDatagram().  When this happens, the transport
    is responsible for dequeueing the send request from any
    of its internal queues and enqueueing the request in
    this driver (AcdWaitForCompletion()), supplying a callback
    to be called when the connection has been completed.

Author:

    Anthony Discolo (adiscolo)  18-Apr-1995

Revision History:

--*/
#include <ndis.h>
#include <cxport.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "debug.h"

//
// Driver reference count
//
ULONG ulAcdOpenCountG;

//
// Imported routines
//
NTSTATUS
AcdEnable(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

VOID
AcdCancelNotifications();

NTSTATUS
AcdWaitForNotification(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdConnectionInProgress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdSignalCompletion(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdConnectAddress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

VOID
AcdReset();

NTSTATUS
AcdGetAddressAttributes(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdSetAddressAttributes(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdQueryState(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdEnableAddress(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

//
// Internal function prototypes
//
NTSTATUS
AcdCreate(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdDispatchDeviceControl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdDispatchInternalDeviceControl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdCleanup(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdClose(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdBind(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

NTSTATUS
AcdUnbind(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    );

//
// All of this code is pageable.
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcdCreate)
#pragma alloc_text(PAGE, AcdDispatchDeviceControl)
#pragma alloc_text(PAGE, AcdDispatchInternalDeviceControl)
#pragma alloc_text(PAGE, AcdCleanup)
#pragma alloc_text(PAGE, AcdClose)
#endif // ALLOC_PRAGMA



NTSTATUS
AcdCreate(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    ulAcdOpenCountG++;
    IF_ACDDBG(ACD_DEBUG_OPENCOUNT) {
        AcdPrint(("AcdCreate: ulAcdOpenCountG=%d\n", ulAcdOpenCountG));
    }
    return STATUS_SUCCESS;
} // AcdCreate



NTSTATUS
AcdDispatchDeviceControl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS status;


    PAGED_CODE();
    //
    // Set this in advance. Any IOCTL dispatch routine that cares about it
    // will modify it itself.
    //
    pIrp->IoStatus.Information = 0;

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_ACD_RESET:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_RESET\n"));
        }
        AcdReset();
        status = STATUS_SUCCESS;
        break;
    case IOCTL_ACD_ENABLE:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_ENABLE\n"));
        }
        //
        // Enable/disable requests to/from the driver.
        //
        status = AcdEnable(pIrp, pIrpSp);
        break;
    case IOCTL_ACD_NOTIFICATION:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_NOTIFICATION\n"));
        }
        //
        // This irp will be completed upon the
        // next connection attempt to
        // allow a user-space process to attempt
        // to make a connection.
        //
        status = AcdWaitForNotification(pIrp, pIrpSp);
        break;
    case IOCTL_ACD_KEEPALIVE:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_KEEPALIVE\n"));
        }
        //
        // Inform the driver that the connection
        // is in the process of being created.
        //
        status = AcdConnectionInProgress(pIrp, pIrpSp);
        break;
    case IOCTL_ACD_COMPLETION:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_COMPLETION\n"));
        }
        //
        // Complete all pending irps that initially
        // encountered a network unreachable error,
        // and have been waiting for a connection to be
        // made.
        //
        status = AcdSignalCompletion(pIrp, pIrpSp);
        break;
    case IOCTL_ACD_CONNECT_ADDRESS:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_ACD_CONNECT_ADDRESS\n"));
        }
        //
        // This allows a user space application to
        // generate the same automatic connection
        // mechanism as a transport protocol.
        //
        status = AcdConnectAddress(pIrp, pIrpSp);
        break;

    case IOCTL_ACD_ENABLE_ADDRESS:
        //DbgPrint("AcdDispatchDeviceControl: IOCTL_ACD_ENABLE_ADDRESS\n");
        status = AcdEnableAddress(pIrp, pIrpSp);
        break;
        
    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (status != STATUS_PENDING) {
        pIrp->IoStatus.Status = status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return status;
} // AcdDispatchDeviceControl



NTSTATUS
AcdDispatchInternalDeviceControl(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    NTSTATUS status;

    PAGED_CODE();
    //
    // Set this in advance. Any IOCTL dispatch routine that cares about it
    // will modify it itself.
    //
    pIrp->IoStatus.Information = 0;

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_INTERNAL_ACD_BIND:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchInternalDeviceControl: IOCTL_INTERNAL_ACD_BIND\n"));
        }
        //
        // Transfer entrypoints to client.
        //
        status = AcdBind(pIrp, pIrpSp);
        break;
    case IOCTL_INTERNAL_ACD_UNBIND:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchInternalDeviceControl: IOCTL_INTERNAL_ACD_UNBIND\n"));
        }
        //
        // Remove any pending requests from
        // this driver.
        //
        status = AcdUnbind(pIrp, pIrpSp);
        break;
    case IOCTL_INTERNAL_ACD_QUERY_STATE:
        IF_ACDDBG(ACD_DEBUG_IOCTL) {
            AcdPrint(("AcdDispatchDeviceControl: IOCTL_INTERNAL_ACD_QUERY_STATE\n"));
        }
        status = AcdQueryState(pIrp, pIrpSp);
        break;
    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (status != STATUS_PENDING) {
        pIrp->IoStatus.Status = status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return status;
} // AcdDispatchInternalDeviceControl



NTSTATUS
AcdCleanup(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    return STATUS_SUCCESS;
} // AcdCleanup



NTSTATUS
AcdClose(
    IN PIRP               pIrp,
    IN PIO_STACK_LOCATION pIrpSp
    )
{
    ulAcdOpenCountG--;
    IF_ACDDBG(ACD_DEBUG_OPENCOUNT) {
        AcdPrint(("AcdClose: ulAcdOpenCountG=%d\n", ulAcdOpenCountG));
    }
    if (!ulAcdOpenCountG)
        AcdReset();
    return STATUS_SUCCESS;
} // AcdClose



NTSTATUS
AcdDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )

/*++

DESCRIPTION
    This is the dispatch routine for the network connection
    notification driver.

ARGUMENTS
    pDeviceObject: a pointer to device object for target device

    pIrp: a pointer to I/O request packet

Return Value:
    NTSTATUS

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;

    UNREFERENCED_PARAMETER(pDeviceObject);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    switch (pIrpSp->MajorFunction) {
    case IRP_MJ_CREATE:
        status = AcdCreate(pIrp, pIrpSp);
        break;
    case IRP_MJ_DEVICE_CONTROL:
        return AcdDispatchDeviceControl(pIrp, pIrpSp);
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        return AcdDispatchInternalDeviceControl(pIrp, pIrpSp);
    case IRP_MJ_CLEANUP:
        status = AcdCleanup(pIrp, pIrpSp);
        break;
    case IRP_MJ_CLOSE:
        status = AcdClose(pIrp, pIrpSp);
        break;
    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (status != STATUS_PENDING) {
        pIrp->IoStatus.Status = status;
        pIrp->IoStatus.Information = 0;

        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    return status;
} // AcdDispatch


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\table.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.c

ABSTRACT
    Generic hash table manipulation routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>
#include <acdapi.h>

#include "table.h"
#include "acddefs.h"
#include "mem.h"
#include "debug.h"



PHASH_TABLE
NewTable()
{
    PHASH_TABLE pTable;
    INT i;

    ALLOCATE_MEMORY(sizeof (HASH_TABLE), pTable);
    if (pTable == NULL) {
        // DbgPrint("AcdNewTable: ExAllocatePool failed\n");
        return NULL;
    }
    KeInitializeSpinLock(&pTable->SpinLock);
    for (i = 0; i < NBUCKETS; i++)
        InitializeListHead(&pTable->ListEntry[i]);

    return pTable;
} // NewTable



VOID
FreeHashTableEntry(
    PHASH_ENTRY pHashEntry
    )
{
    FREE_MEMORY(pHashEntry);
} // FreeHashTableEntry



VOID
ClearTable(
    PHASH_TABLE pTable
    )
{
    KIRQL irql;
    INT i;
    PLIST_ENTRY pHead;
    PHASH_ENTRY pHashEntry;

    KeAcquireSpinLock(&pTable->SpinLock, &irql);
    for (i = 0; i < NBUCKETS; i++) {
        while (!IsListEmpty(&pTable->ListEntry[i])) {
            pHead = RemoveHeadList(&pTable->ListEntry[i]);
            pHashEntry = CONTAINING_RECORD(pHead, HASH_ENTRY, ListEntry);

            FreeHashTableEntry(pHashEntry);
        }
    }
    KeReleaseSpinLock(&pTable->SpinLock, irql);
} // ClearTable



VOID
FreeTable(
    PHASH_TABLE pTable
    )
{
    ClearTable(pTable);
    FREE_MEMORY(pTable);
} // FreeTable



VOID
EnumTable(
    IN PHASH_TABLE pTable,
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    )
{
    INT i;
    PLIST_ENTRY pEntry;
    PHASH_ENTRY pHashEntry;
    KIRQL irql;

    KeAcquireSpinLock(&pTable->SpinLock, &irql);
    for (i = 0; i < NBUCKETS; i++) {
        for (pEntry = pTable->ListEntry[i].Flink;
             pEntry != &pTable->ListEntry[i];
             pEntry = pEntry->Flink)
        {
            pHashEntry = CONTAINING_RECORD(pEntry, HASH_ENTRY, ListEntry);

            //
            // If the enumerator procedure
            // returns FALSE, terminate the
            // enumeration.
            //
            if (!pProc(pArg, &pHashEntry->szKey, pHashEntry->ulData))
                goto done;
        }
    }
done:
    KeReleaseSpinLock(&pTable->SpinLock, irql);
} // EnumTable



INT
HashString(
    IN PACD_ADDR pszKey
    )
{
    ULONG ulHashValue = 0;
    CHAR ch;
    PCSZ p = (PCSZ)pszKey;

    while (*p != L'\0') {
        ch = tolower(*p);
        ulHashValue += (INT)(ch) * (INT)(ch);
        p++;
    }

    return (INT)(ulHashValue % NBUCKETS);
} // HashString



BOOLEAN
IsEqualKey(
    PACD_ADDR pszKey1,
    PACD_ADDR pszKey2
    )
{
    BOOLEAN fFound;

    fFound = (BOOLEAN)RtlEqualMemory(pszKey1, pszKey2, sizeof (ACD_ADDR));
    IF_ACDDBG(ACD_DEBUG_TABLE) {
        AcdPrint(("AcdIsEqualKey(%s, %s) returns %d\n", pszKey1, pszKey2, fFound));
    }
    return fFound;
} // IsEqualKey



PHASH_ENTRY
GetTableEntryNL(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey
    )
{
    INT nBucket = HashString(pszKey);
    PLIST_ENTRY pEntry;
    PHASH_ENTRY pHashEntry;

    for (pEntry = pTable->ListEntry[nBucket].Flink;
         pEntry != &pTable->ListEntry[nBucket];
         pEntry = pEntry->Flink)
    {
        pHashEntry = CONTAINING_RECORD(pEntry, HASH_ENTRY, ListEntry);

        if (IsEqualKey(&pHashEntry->szKey, pszKey)) {
            IF_ACDDBG(ACD_DEBUG_TABLE) {
                AcdPrint(("AcdGetTableEntryNL(0x%x, %s) returns 0x%x\n", pTable, pszKey, pHashEntry));
            }
            return pHashEntry;
        }
    }

    IF_ACDDBG(ACD_DEBUG_TABLE) {
        AcdPrint(("AcdGetTableEntryNL(0x%x, %s) returns NULL\n", pTable, pszKey));
    }
    return NULL;
} // GetTableEntryNL



BOOLEAN
GetTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey,
    OUT PULONG pulData
    )
{
    KIRQL irql;
    PHASH_ENTRY pHashEntry;

    KeAcquireSpinLock(&pTable->SpinLock, &irql);
    pHashEntry = GetTableEntryNL(pTable, pszKey);
    KeReleaseSpinLock(&pTable->SpinLock, irql);

    if (pHashEntry != NULL) {
        if (pulData != NULL)
            *pulData = pHashEntry->ulData;
        return TRUE;
    }

    return FALSE;
} // GetTableEntry



BOOLEAN
PutTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey,
    IN ULONG ulData
    )
{
    KIRQL irql;
    BOOLEAN fSuccess = FALSE;
    INT nBucket = HashString(pszKey);
    PHASH_ENTRY pHashEntry;

    IF_ACDDBG(ACD_DEBUG_TABLE) {
        AcdPrint(("AcdPutTableEntry(0x%x, %s)\n", pTable, pszKey));
    }

    KeAcquireSpinLock(&pTable->SpinLock, &irql);

    pHashEntry = GetTableEntryNL(pTable, pszKey);
    if (pHashEntry == NULL) {
        ALLOCATE_MEMORY(ACD_OBJECT_HASHENTRY, pHashEntry);
        if (pHashEntry == NULL) {
            // DbgPrint("PutTableEntry: ExAllocatePool failed\n");
            goto done;
        }
        RtlCopyMemory(pHashEntry->szKey, pszKey, sizeof (ACD_ADDR));
        InsertHeadList(
          &pTable->ListEntry[nBucket],
          &pHashEntry->ListEntry);
    }
    pHashEntry->ulData = ulData;
    fSuccess = TRUE;

done:
    KeReleaseSpinLock(&pTable->SpinLock, irql);
    return fSuccess;
} // PutTableEntry



BOOLEAN
DeleteTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey
    )
{
    KIRQL irql;
    PHASH_ENTRY pHashEntry;

    KeAcquireSpinLock(&pTable->SpinLock, &irql);
    pHashEntry = GetTableEntryNL(pTable, pszKey);
    if (pHashEntry != NULL) {
        RemoveEntryList(&pHashEntry->ListEntry);
        FreeHashTableEntry(pHashEntry);
    }
    KeReleaseSpinLock(&pTable->SpinLock, irql);

    return (pHashEntry != NULL);
} // DeleteTableEntry

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\table.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.h

ABSTRACT
    Header file for generic hash table routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

//
// Number of hash table buckets.
//
#define NBUCKETS   13

//
// Generic hash table structure.
//
typedef struct _HASH_TABLE {
    LIST_ENTRY ListEntry[NBUCKETS];
    KSPIN_LOCK SpinLock;
} HASH_TABLE, *PHASH_TABLE;

//
// Hash table enumerator procedure.
// Returns TRUE to continue enumeration,
// FALSE to terminate enumeration.
//
typedef BOOLEAN (*PHASH_TABLE_ENUM_PROC)(PVOID, PACD_ADDR, ULONG);


PHASH_TABLE
NewTable();

VOID
ClearTable(
    IN PHASH_TABLE pTable
    );

VOID
FreeTable(
    IN PHASH_TABLE pTable
    );

VOID
EnumTable(
    IN PHASH_TABLE pTable,
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    );

BOOLEAN
GetTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey,
    OUT PULONG pulData
    );

BOOLEAN
PutTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey,
    IN ULONG ulData
    );

BOOLEAN
DeleteTableEntry(
    IN PHASH_TABLE pTable,
    IN PACD_ADDR pszKey
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasadhlp\autodial.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

MODULE NAME

    autodial.h

ABSTRACT

    This module contains definitions for Autodial driver routines.

AUTHOR

    Anthony Discolo (adiscolo) 08-May-1996

REVISION HISTORY

--*/


BOOLEAN
AcsHlpAttemptConnection(
    IN PACD_ADDR pAddr
    );

VOID
AcsHlpNoteNewConnection(
    IN PACD_ADDR pAddr,
    IN PACD_ADAPTER pAdapter
    );

BOOL
AcsHlpNbConnection(
    TCHAR *pszName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasadhlp\init.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

MODULE NAME
    init.c

ABSTRACT
    Initialization for the Autodial helper DLL.

AUTHOR
    Anthony Discolo (adiscolo) 22-Apr-1996

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#define DEBUGGLOBALS
#include <debug.h>


BOOL
WINAPI
InitAcsHelperDLL(
    HINSTANCE   hinstDLL,
    DWORD       fdwReason,
    LPVOID      lpvReserved
    )

/*++

DESCRIPTION
    Initialize the DLL.  All we do right now is to initialize
    the debug tracing library.

ARGUMENTS
    hinstDLL:

    fdwReason:

    lpvReserved:

RETURN VALUE
    Always TRUE.

--*/

{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hinstDLL);
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasadhlp\autodial.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

MODULE NAME

    autodial.c

ABSTRACT

    This module contains support for RAS AutoDial system service.

AUTHOR

    Anthony Discolo (adiscolo) 22-Apr-1996

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <acd.h>
#include <debug.h>
#include <winsock2.h>
#include <dnsapi.h>

#define NEW_TRANSPORT_INTERVAL      0

BOOLEAN
AcsHlpSendCommand(
    IN PACD_NOTIFICATION pRequest
    )

/*++

DESCRIPTION
    Take an automatic connection driver command block 
    and send it to the driver.

ARGUMENTS
    pRequest: a pointer to the command block

RETURN VALUE 
    TRUE if successful; FALSE otherwise.

--*/

{
    NTSTATUS status;
    HANDLE hAcd;
    HANDLE hNotif = NULL;
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Initialize the object attributes.
    //
    InitializeObjectAttributes(
      &objectAttributes,
      &nameString,
      OBJ_CASE_INSENSITIVE,
      (HANDLE)NULL,
      (PSECURITY_DESCRIPTOR)NULL);
    //
    // Open the automatic connection device.
    //
    status = NtCreateFile(
               &hAcd,
               FILE_READ_DATA|FILE_WRITE_DATA,
               &objectAttributes,
               &ioStatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ|FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               0,
               NULL,
               0);
    if (status != STATUS_SUCCESS)
        return FALSE;
    //
    // Create an event to wait on.
    //
    hNotif = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hNotif == NULL) {
        CloseHandle(hAcd);
        return FALSE;
    }
    status = NtDeviceIoControlFile(
               hAcd,
               hNotif,
               NULL,
               NULL,
               &ioStatusBlock,
               IOCTL_ACD_CONNECT_ADDRESS,
               pRequest,
               sizeof (ACD_NOTIFICATION),
               NULL,
               0);
    if (status == STATUS_PENDING) {
        status = WaitForSingleObject(hNotif, INFINITE);
        //
        // If WaitForSingleObject() returns successfully,
        // return the status from the status block,
        // otherwise return the wait status.
        //
        if (status == WAIT_OBJECT_0)
            status = ioStatusBlock.Status;
    }
    //
    // Free resources.
    //
    CloseHandle(hNotif);
    CloseHandle(hAcd);

    return (status == STATUS_SUCCESS);
} // AcsHlpSendCommand



BOOLEAN
AcsHlpAttemptConnection(
    IN PACD_ADDR pAddr
    )

/*++

DESCRIPTION
    Construct an automatic connection driver command block 
    to attempt to create an autodial connection for 
    the specified address.

ARGUMENTS
    pAddr: a pointer to the address

RETURN VALUE
    TRUE if successful; FALSE otherwise.

--*/

{
    ACD_NOTIFICATION request;

    //
    // Initialize the request with
    // the address.
    //
    RtlCopyMemory(&request.addr, pAddr, sizeof (ACD_ADDR));
    request.ulFlags = 0;
    RtlZeroMemory(&request.adapter, sizeof (ACD_ADAPTER));
    //
    // Give this request to the automatic
    // connection driver.
    //
    return AcsHlpSendCommand(&request);
} // AcsHlpAttemptConnection



BOOLEAN
AcsHlpNoteNewConnection(
    IN PACD_ADDR pAddr,
    IN PACD_ADAPTER pAdapter
    )

/*++

DESCRIPTION
    Construct an automatic connection driver command block 
    to notify the automatic connection service of a new connection.

ARGUMENTS
    pAddr: a pointer to the address

    pAdapter: a pointer to the adapter over which the new
        connection was made

RETURN VALUE
    TRUE if successful; FALSE otherwise.

--*/

{
    ULONG cbAddress;
    ACD_NOTIFICATION request;

    //
    // Initialize the request with
    // the address.
    //
    RtlCopyMemory(&request.addr, pAddr, sizeof (ACD_ADDR));
    request.ulFlags = ACD_NOTIFICATION_SUCCESS;
    RtlCopyMemory(&request.adapter, pAdapter, sizeof (ACD_ADAPTER));
    //
    // Give this request to the automatic
    // connection driver.
    //
    return AcsHlpSendCommand(&request);
} // AcsHlpNoteNewConnection

CHAR *
pszDupWtoA(
    IN LPCWSTR psz
    )
{
    CHAR* pszNew = NULL;

    if (NULL != psz) 
    {
        DWORD cb;

        cb = WideCharToMultiByte(CP_ACP, 
                                 0, 
                                 psz, 
                                 -1, 
                                 NULL, 
                                 0, 
                                 NULL, 
                                 NULL);
                                 
        pszNew = (CHAR*) LocalAlloc(LPTR, cb);
        
        if (NULL == pszNew) 
        {
            goto done;
        }

        cb = WideCharToMultiByte(CP_ACP, 
                                 0, 
                                 psz, 
                                 -1, 
                                 pszNew, 
                                 cb, 
                                 NULL, 
                                 NULL);
                                 
        if (!cb) 
        {
            LocalFree(pszNew);
            pszNew = NULL;
            goto done;
        }
    }

done:    
    return pszNew;
}

BOOL
fIsDnsName(LPCWSTR pszName)
{
    HINSTANCE hInst              = NULL;
    BOOL      fRet               = FALSE;
    FARPROC   pfnDnsValidateName = NULL;

    if(     (NULL == (hInst = LoadLibrary(TEXT("dnsapi.dll"))))
    
        ||  (NULL == (pfnDnsValidateName = GetProcAddress(
                                            hInst,
                                            "DnsValidateName_W")
                                            )))
    {
        DWORD retcode = GetLastError();

        goto done;
    }

    fRet = (ERROR_SUCCESS == pfnDnsValidateName(pszName, DnsNameDomain));

done:
    if(NULL != hInst)
    {
        FreeLibrary(hInst);
    }

    return fRet;
}

ULONG
ulGetAutodialSleepInterval()
{
    DWORD dwSleepInterval = NEW_TRANSPORT_INTERVAL;

    HKEY hkey = NULL;

    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    TCHAR *pszAutodialParam = 
           TEXT("SYSTEM\\CurrentControlSet\\Services\\RasAuto\\Parameters");
            

    if (ERROR_SUCCESS != RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                pszAutodialParam,
                                0, KEY_READ,
                                &hkey))
    {
        goto done;
    }

    if(ERROR_SUCCESS != RegQueryValueEx(
                            hkey,
                            TEXT("NewTransportWaitInterval"),
                            NULL,
                            &dwType,
                            (LPBYTE) &dwSleepInterval,
                            &dwSize))
    {
        goto done;
    }
    

done:

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    return (ULONG) dwSleepInterval;
                                    
}

DWORD
DwGetAcdAddr(ACD_ADDR *paddr, LPCWSTR pszName)
{
    CHAR *pszNameA  = NULL;
    CHAR *pszNameAt = NULL;
    DWORD retcode   = ERROR_SUCCESS;
    ULONG ulIpAddr  = 0;

    if(     (NULL == pszName)
        ||  (NULL == paddr))
    {
        retcode = E_INVALIDARG;
        goto done;
    }

    pszNameA = pszDupWtoA(pszName);

    if(NULL == pszNameA)
    {
        retcode = E_FAIL;
        goto done;
    }

    if(INADDR_NONE != (ulIpAddr = inet_addr(pszNameA)))
    {
        paddr->fType = ACD_ADDR_IP;
        paddr->ulIpaddr = ulIpAddr;
        goto done;
    }

    if(fIsDnsName(pszName))
    {
        paddr->fType = ACD_ADDR_INET;
        RtlCopyMemory((PBYTE) paddr->szInet,
                      (PBYTE) pszNameA,
                      strlen(pszNameA) + 1);

        goto done;                      
    }

    pszNameAt = pszNameA;

    //
    // Skip '\\' if required
    //
    if(     (TEXT('\0') != pszName[0])
        &&  (TEXT('\\') == pszName[0])
        &&  (TEXT('\\') == pszName[1]))
    {
        pszNameA += 2;
    }

    //
    // Default to a netbios name if its neither an ip address
    // or a dns name
    //
    paddr->fType = ACD_ADDR_NB;
    RtlCopyMemory((PBYTE) paddr->cNetbios,
                  (PBYTE) pszNameA,
                  strlen(pszNameA) + 1);

done:

    if(NULL != pszNameAt)
    {   
        LocalFree(pszNameAt);
    }

    return retcode;
    
}    

BOOL
AcsHlpNbConnection(LPCWSTR pszName)
{
    ACD_ADDR addr = {0};
    BOOL fRet;

    if(!(fRet = (ERROR_SUCCESS == DwGetAcdAddr(&addr, pszName))))
    {
    
        goto done;
    }
    
    fRet = AcsHlpAttemptConnection(&addr);

    //
    // Temporary solution for beta2. We may need to wait till redir gets
    // a new transport notification. Currently There is no way to 
    // guarantee that redir is bound to some transport before returning
    // from this api.
    //
    if(fRet)
    {
        ULONG ulSleepInterval = ulGetAutodialSleepInterval();

        if(ulSleepInterval > 0)
        {
            Sleep(ulSleepInterval);
        }
    }

done:

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasadhlp\winsock.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

MODULE NAME

    winsock.c

ABSTRACT

    This module contains support for the Winsock2
    Autodial callout.

AUTHOR

    Anthony Discolo (adiscolo) 15-May-1996

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <acd.h>
#include <debug.h>
#include <winsock2.h>
#include <svcguid.h>
#include <wsipx.h>
#include <wsnetbs.h>

#include "autodial.h"

#define GuidEqual(g1, g2)   RtlEqualMemory((g1), (g2), sizeof (GUID))

//
// GUIDs we know about.
//
GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID AddressGuid = SVCID_INET_HOSTADDRBYINETSTRING;



BOOL
WSAttemptAutodialAddr(
    IN const struct sockaddr FAR *name,
    IN int namelen
    )
{
    struct sockaddr_in *sin;
    struct sockaddr_ipx *sipx;
    struct sockaddr_nb *snb;
    ACD_ADDR addr;

    RtlZeroMemory(&addr, sizeof(ACD_ADDR));

    //
    // We only know about a few address families.
    //
    switch (name->sa_family) {
    case AF_INET:
        sin = (struct sockaddr_in *)name;
        addr.fType = ACD_ADDR_IP;
        addr.ulIpaddr = sin->sin_addr.s_addr;
        break;
    case AF_IPX:
        sipx = (struct sockaddr_ipx *)name;
        return FALSE;
        break;
    case AF_NETBIOS:
        snb = (struct sockaddr_nb *)name;
        addr.fType = ACD_ADDR_NB;
        RtlCopyMemory(&addr.cNetbios, snb->snb_name, NETBIOS_NAME_LENGTH);
        break;
    default:
        return FALSE;
    }

    return AcsHlpAttemptConnection(&addr);
} // WSAttemptAutodialAddr



BOOL
WSAttemptAutodialName(
    IN const LPWSAQUERYSETW lpqsRestrictions
    )
{
    ACD_ADDR addr;

    RtlZeroMemory(&addr, sizeof(ACD_ADDR));

    //
    // If there is no address, then
    // we're done.
    //
    if (lpqsRestrictions->lpszServiceInstanceName == NULL)
        return FALSE;

    if (GuidEqual(lpqsRestrictions->lpServiceClassId, &HostnameGuid)) {
        //
        // This is a hostname.
        //
        addr.fType = ACD_ADDR_INET;
        if (!WideCharToMultiByte(
              CP_ACP,
              0,
              lpqsRestrictions->lpszServiceInstanceName,
              -1,
              addr.szInet,
              ACD_ADDR_INET_LEN - 1,
              0,
              0))
        {
            return FALSE;
        }
        return AcsHlpAttemptConnection(&addr);
    }
    else if (GuidEqual(lpqsRestrictions->lpServiceClassId, &AddressGuid)) {
        CHAR szIpAddress[17];

        //
        // This is an IP address.
        //
        addr.fType = ACD_ADDR_IP;
        if (!WideCharToMultiByte(
              CP_ACP,
              0,
              lpqsRestrictions->lpszServiceInstanceName,
              -1,
              szIpAddress,
              sizeof (szIpAddress) - 1,
              0,
              0))
        {
            return FALSE;
        }


        _strlwr(szIpAddress);
        addr.ulIpaddr = inet_addr(szIpAddress);
        if (addr.ulIpaddr == INADDR_NONE)
            return FALSE;
        return AcsHlpAttemptConnection(&addr);
    }

    return FALSE;
} // WSAttemptAutodialName



VOID
WSNoteSuccessfulHostentLookup(
    IN const char FAR *name,
    IN const ULONG ipaddr
    )
{
    ACD_ADDR addr;
    ACD_ADAPTER adapter;

    //
    // If there is no address, then
    // we're done.
    //
    if (name == NULL || !strlen(name))
        return;

    addr.fType = ACD_ADDR_INET;
    strcpy((PCHAR)&addr.szInet, name);
    adapter.fType = ACD_ADAPTER_IP;
    adapter.ulIpaddr = ipaddr;
    AcsHlpNoteNewConnection(&addr, &adapter);
} // WSNoteSuccessfulHostentLookup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\access.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    access.h

ABSTRACT
    Header file for address accessibility routines.

AUTHOR
    Anthony Discolo (adiscolo) 27-Jul-1995

REVISION HISTORY

--*/

LPTSTR
IpAddressToNetbiosName(
    IN LPTSTR pszIpAddress,
    IN HPORT hPort
    );

LPTSTR
IpxAddressToNetbiosName(
    IN LPTSTR pszIpxAddress
    );

VOID
StringToNodeNumber(
    IN PCHAR pszString,
    OUT PCHAR pszNode
    );

VOID
NodeNumberToString(
    IN PCHAR pszNode,
    OUT PCHAR pszString
    );

BOOLEAN
NetbiosFindName(
    IN LPTSTR *pszDevices,
    IN DWORD dwcDevices,
    IN LPTSTR pszAddress
    );

struct hostent *
InetAddressToHostent(
    IN LPTSTR pszIpAddress
    );

struct hostent *
IpAddressToHostent(
    IN LPTSTR pszIpAddress
    );

BOOLEAN
PingIpAddress(
    IN LPTSTR pszIpAddress
    );


VOID
LoadIcmpDll(VOID);

VOID
UnloadIcmpDll(VOID);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasacd\timer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Timer thread to monitor connection progress in the
    automatic connection driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  25-Apr-1995

Environment:

    Kernel Mode

Revision History:

--*/

#include <ndis.h>
#include <cxport.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <acd.h>

#include "acdapi.h"
#include "table.h"
#include "acddefs.h"
#include "debug.h"

//
// Imported routines.
//
VOID
AcdSignalCompletionCommon(
    IN PACD_CONNECTION pConnection,
    IN BOOLEAN fSuccess
    );

//
// Keep track how long the user-space
// process has been attempting a connection.
//
#define ACD_MAX_TIMER_CALLS    3*60     // 3 minutes

//
// We give the user-space process
// some slack on missed pings.
//
#define ACD_MAX_MISSED_PINGS   40       // 20 seconds



VOID
AcdConnectionTimer(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PVOID          pContext
    )
{
    PLIST_ENTRY pEntry;
    PACD_CONNECTION pConnection;
    BOOLEAN bCancel = FALSE;

    //
    // Acquire the spin lock.
    // We're guaranteed to be at DPC
    // since this is a timer routine.
    //
    KeAcquireSpinLockAtDpcLevel(&AcdSpinLockG);
    //
    // If the user-space process responsible
    // for creating the connection hasn't
    // pinged us in a while, or if it hasn't
    // created a connection in 3 minutes,
    // cancel all the pending requests.
    //
    for (pEntry = AcdConnectionQueueG.Flink;
         pEntry != &AcdConnectionQueueG;
         pEntry = pEntry->Flink)
    {
        pConnection = CONTAINING_RECORD(pEntry, ACD_CONNECTION, ListEntry);

        IF_ACDDBG(ACD_DEBUG_TIMER) {
            PACD_COMPLETION pCompletion;

            AcdPrint((
              "AcdConnectionTimer: pConnection=0x%x, fNotif=%d, szAddr=",
              pConnection,
              pConnection->fNotif));
            pCompletion = CONTAINING_RECORD(pConnection->CompletionList.Flink, ACD_COMPLETION, ListEntry);
            AcdPrintAddress(&pCompletion->notif.addr);
            AcdPrint((", nTimerCalls=%d, nMissedPings=%d\n",
              pConnection->ulTimerCalls,
              pConnection->ulMissedPings));
        }
        //
        // If we haven't reported the connection to
        // user space yet, or it is in the process of
        // being completed, then don't time it out.
        //
        if (!pConnection->fNotif || pConnection->fCompleting)
            continue;

        pConnection->ulTimerCalls++;
        if (pConnection->fProgressPing)
            pConnection->ulMissedPings = 0;
        else
            pConnection->ulMissedPings++;
        if (pConnection->ulTimerCalls >= ACD_MAX_TIMER_CALLS ||
            pConnection->ulMissedPings >= ACD_MAX_MISSED_PINGS)
        {
            IF_ACDDBG(ACD_DEBUG_TIMER) {
                AcdPrint((
                  "AcdConnectionTimer: canceling pConnection=0x%x\n",
                  pConnection));
            }
            //
            // Set the completion-in-progress flag so
            // this request cannot be completed after
            // we release the spin lock.
            //
            pConnection->fCompleting = TRUE;
            bCancel = TRUE;
            break;
        }
    }
    //
    // Release the spin lock.
    //
    KeReleaseSpinLockFromDpcLevel(&AcdSpinLockG);
    //
    // We now process all the canceled requests.
    //
    if (bCancel)
        AcdSignalCompletionCommon(pConnection, FALSE);
} // AcdConnectionTimer


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\access.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    access.c

ABSTRACT
    Address accessibility routines for automatic connections

AUTHOR
    Anthony Discolo (adiscolo) 26-Jul-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <tdi.h>
#include <nb30.h>
#include <nbtioctl.h>
#include <stdio.h>
#include <npapi.h>
#include <ctype.h>
#include <winsock.h>
#include <acd.h>
#include <ras.h>
#include <raserror.h>
#include <rasman.h>
#include <debug.h>
#include <ipexport.h>
#include <icmpapi.h>

#include "reg.h"
#include "rasprocs.h"
#include "misc.h"
#include "table.h"
#include "addrmap.h"
#include "imperson.h"

//
// The format of Adapter Status responses.
//
typedef struct _ADAPTERSTATUS
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} ADAPTERSTATUS, *PADAPTERSTATUS;

//
// Icmp.dll library entrypoints.
//
#define ICMP_MODULE     L"icmp"
HANDLE hIcmpG;

#define ICMPCREATEFILE  "IcmpCreateFile"
FARPROC lpfnIcmpCreateFileG;

#define ICMPSENDECHO    "IcmpSendEcho"
FARPROC lpfnIcmpSendEchoG;

#define ICMPCLOSEHANDLE "IcmpCloseHandle"
FARPROC lpfnIcmpCloseHandleG;

//
// PingIpAddress constants
//
#define PING_SEND_SIZE  32
#define PING_RECV_SIZE  (0x2000 - 8)
#define PING_TTL        32
#define PING_TIMEOUT    2000L   // needs to be long enough to succeed over slow links

//
// External variables
//
extern HANDLE hTerminatingG;



BOOLEAN
CopyNetbiosName(
    IN NAME_BUFFER *pNames,
    IN DWORD dwcNames,
    OUT LPSTR pszNetbiosName
    )
{
    BOOLEAN fFound = FALSE;
    DWORD i, iWks = 0;
    CHAR szWks[NCBNAMSZ];
    PCHAR p = pszNetbiosName;

    //
    // Find the unique workstation name.
    //
again:
    szWks[0] = '\0';
    for (i = iWks; i < dwcNames; i++) {
        RASAUTO_TRACE2(
          "CopyNetbiosName: wks %15.15s (0x%x)",
          pNames[i].name,
          pNames[i].name[NCBNAMSZ - 1]);
        if (pNames[i].name[NCBNAMSZ - 1] == 0x0 &&
            !(pNames[i].name_flags & GROUP_NAME))
        {
            RASAUTO_TRACE1("CopyNetbiosName: iWks=%d\n", iWks);
            iWks = i;
            memcpy(szWks, pNames[i].name, NCBNAMSZ - 1);
            break;
        }
    }
    //
    // Check to make sure we found one.
    //
    if (szWks[0] == '\0')
        return FALSE;
    //
    // Find the unique server name and make
    // sure it matches the workstation name.
    //
    for (i = 0; i < dwcNames; i++) {
        RASAUTO_TRACE3(
          "CopyNetbiosName: srv %15.15s (0x%x), cmp=%d",
          pNames[i].name,
          pNames[i].name[NCBNAMSZ - 1],
          memcmp(szWks, pNames[i].name, NCBNAMSZ - 1));
        if (pNames[i].name[NCBNAMSZ - 1] == 0x20 &&
            !(pNames[i].name_flags & GROUP_NAME) &&
            !memcmp(szWks, pNames[i].name, NCBNAMSZ - 1))
        {
            DWORD j;

            //
            // Copy up to a null or a space.
            //
            for (j = 0; j < NCBNAMSZ - 1; j++) {
                if (pNames[i].name[j] == '\0' || pNames[i].name[j] == ' ')
                    break;
                *p++ = pNames[i].name[j];
            }
            *p++ = '\0';
            return TRUE;
        }
    }
    //
    // No match found.  Look for another unique workstation
    // name and try again if we haven't exhausted the list.
    //
    if (++iWks >= dwcNames)
        return FALSE;
    goto again;
} // CopyNetbiosName



LPTSTR
IpAddressToNetbiosName(
    IN LPTSTR pszIpAddress,
    IN HPORT hPort
    )
{
    BOOLEAN fFound;
    RAS_PROTOCOLS Protocols;
    DWORD i, dwcProtocols;
    RASMAN_ROUTEINFO *pRoute;
    WCHAR szAdapterName[MAX_PATH];
    NTSTATUS status;
    HANDLE fd;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING unicodeString;
    ULONG ipaddr;
    CHAR szIpAddress[17];
    tIPANDNAMEINFO ipAndNameInfo;
    PVOID pBuffer;
    DWORD dwSize;
    PADAPTERSTATUS pAdapterStatus;
    NAME_BUFFER *pNames;
    DWORD dwcNames;
    LPTSTR pszNetbiosName = NULL;

    //
    // Enumerate the bindings for the port to
    // try to find the Netbt device.
    //
    GetPortProtocols(hPort, &Protocols, &dwcProtocols);
    fFound = FALSE;
    for (i = 0; i < dwcProtocols; i++) {
        pRoute = &Protocols.RP_ProtocolInfo[i];
        RASAUTO_TRACE3(
          "IpAddressToNetbiosName: adapter type=%d, name=%S, xport=%S",
          pRoute->RI_Type,
          pRoute->RI_AdapterName,
          pRoute->RI_XportName);
        if (pRoute->RI_Type == IP) {
            wcscpy(szAdapterName, L"\\Device\\Netbt_Tcpip_");
            wcscat(szAdapterName, &pRoute->RI_AdapterName[8]);
            fFound = TRUE;
            break;
        }
    }
    if (!fFound)
        return NULL;
    //
    // Open the device and issue a remote
    // adapter status command.
    //
    RtlInitUnicodeString(&unicodeString, szAdapterName);
    InitializeObjectAttributes(
      &objectAttributes,
      &unicodeString,
      OBJ_CASE_INSENSITIVE,
      NULL,
      NULL);
    status = NtCreateFile(
               &fd,
               SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
               &objectAttributes,
               &ioStatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ|FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               0,
               NULL,
               0);
    if (!NT_SUCCESS(status)) {
        RASAUTO_TRACE1(
          "IpAddressToNetbiosName: NtCreateFile failed (status=0x%x)\n",
          status);
        return NULL;
    }

    UnicodeStringToAnsiString(pszIpAddress, szIpAddress, sizeof (szIpAddress));
    ipaddr = inet_addr(szIpAddress);
    if (ipaddr == INADDR_ANY)
        return NULL;

    RtlZeroMemory(&ipAndNameInfo, sizeof (ipAndNameInfo));
    ipAndNameInfo.IpAddress = ntohl(ipaddr);
    ipAndNameInfo.NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';
    ipAndNameInfo.NetbiosAddress.TAAddressCount = 1;
    ipAndNameInfo.NetbiosAddress.Address[0].AddressLength =
      sizeof (TDI_ADDRESS_NETBIOS);
    ipAndNameInfo.NetbiosAddress.Address[0].AddressType =
      TDI_ADDRESS_TYPE_NETBIOS;
    ipAndNameInfo.NetbiosAddress.Address[0].Address[0].NetbiosNameType =
      TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    dwSize = 2048;
    for (;;) {
        pBuffer = LocalAlloc(LPTR, dwSize);
        if (pBuffer == NULL) {
            RASAUTO_TRACE("IpAddressToNetbiosName: LocalAlloc failed");
            return NULL;
        }
        status = NtDeviceIoControlFile(
                   fd,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_NETBT_ADAPTER_STATUS,
                   &ipAndNameInfo,
                   sizeof (tIPANDNAMEINFO),
                   pBuffer,
                   dwSize);
        if (status != STATUS_BUFFER_OVERFLOW)
            break;

        LocalFree(pBuffer);
        dwSize *= 2;
        if (dwSize >= 0xffff) {
            RASAUTO_TRACE("IpAddressToNetbiosName: Unable to allocate packet");
            return NULL;
        }
    }
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(fd, TRUE, NULL);
        if (status == STATUS_SUCCESS)
            status = ioStatusBlock.Status;
    }
    NtClose(fd);

    pAdapterStatus = (PADAPTERSTATUS)pBuffer;
    dwcNames = pAdapterStatus->AdapterInfo.name_count;
    RASAUTO_TRACE2(
      "IpAddressToNetbiosName: results (status=0x%x, dwcNames=%d)\n",
      status,
      dwcNames);
    if (status == STATUS_SUCCESS && dwcNames) {
        CHAR szNetbiosName[NCBNAMSZ + 1];

        pNames = pAdapterStatus->Names;
        if (CopyNetbiosName(pNames, dwcNames, szNetbiosName))
            pszNetbiosName = AnsiStringToUnicodeString(szNetbiosName, NULL, 0);
    }
    LocalFree(pBuffer);

    return pszNetbiosName;
} // IpAddressToNetbiosName



UCHAR
HexByte(
    IN PCHAR p
    )
{
    UCHAR c;

    c = *(UCHAR *)p;
    if (c >= '0' && c <= '9')
        return c - '0';
    if ((c >= 'A' && c <= 'F') ||
        (c >= 'a' && c <= 'f'))
    {
        return c - ('A' - 10);
    }
    return 0xff;
} // HexByte



VOID
StringToNodeNumber(
    IN PCHAR pszString,
    OUT PCHAR pszNode
    )
{
    UCHAR c1, c2;
    INT i;

    if (strlen(pszString) != 12) {
        RASAUTO_TRACE("StringToNodeNumber: bad node number length\n");
        return;
    }
    for (i = 0; i < 6; i++) {
        c1 = HexByte(pszString++);
        c2 = HexByte(pszString++);
        if (c1 == 0xff || c2 == 0xff) {
            RASAUTO_TRACE("StringToNodeNumber: bad digit");
            return;
        }
        *pszNode++ = (c1 << 4) + c2;
    }
} // StringToNodeNumber



VOID
NodeNumberToString(
    IN PCHAR pszNode,
    OUT PCHAR pszString
    )
{
    UCHAR c1, c2;
    INT i;

    sprintf(
      pszString,
      "%02x:%02x:%02x:%02x:%02x:%02x",
      pszNode[0],
      pszNode[1],
      pszNode[2],
      pszNode[3],
      pszNode[4],
      pszNode[5]);
} // NodeNumberToString



LPTSTR
IpxAddressToNetbiosName(
    IN LPTSTR pszIpxAddress
    )
{
    NTSTATUS status;
    HANDLE fd;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING unicodeString;
    PTDI_REQUEST_QUERY_INFORMATION pQuery;
    PTDI_CONNECTION_INFORMATION pConnectionInformation;
    PTA_NETBIOS_ADDRESS pRemoteAddress;
    CHAR szIpxAddress[13];
    PVOID pBuffer;
    DWORD dwQuerySize, dwBufferSize;
    PADAPTERSTATUS pAdapterStatus;
    NAME_BUFFER *pNames;
    DWORD dwcNames;
    LPTSTR pszNetbiosName = NULL;

    RtlInitUnicodeString(&unicodeString, L"\\Device\\Nwlnknb");
    InitializeObjectAttributes(
      &objectAttributes,
      &unicodeString,
      OBJ_CASE_INSENSITIVE,
      NULL,
      NULL);
    status = NtCreateFile(
               &fd,
               SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
               &objectAttributes,
               &ioStatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ|FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               0,
               NULL,
               0);
    if (!NT_SUCCESS(status)) {
        RASAUTO_TRACE1("IpxAddressToNetbiosName: NtCreateFile failed (status=0x%x)", status);
        return NULL;
    }

    dwQuerySize = sizeof (TDI_REQUEST_QUERY_INFORMATION) +
                    sizeof (TDI_CONNECTION_INFORMATION) +
                    sizeof (TA_NETBIOS_ADDRESS);
    pQuery = LocalAlloc(LPTR, dwQuerySize);
    if (pQuery == NULL) {
        RASAUTO_TRACE("IpxAddressToNetbiosName: LocalAlloc failed");
        return NULL;
    }
    pQuery->QueryType = TDI_QUERY_ADAPTER_STATUS;
      (PTDI_CONNECTION_INFORMATION)&pQuery->RequestConnectionInformation;
    pQuery->RequestConnectionInformation =
      (PTDI_CONNECTION_INFORMATION)(pQuery + 1);
    pConnectionInformation = pQuery->RequestConnectionInformation;
    pConnectionInformation->UserDataLength = 0;
    pConnectionInformation->UserData = NULL;
    pConnectionInformation->OptionsLength = 0;
    pConnectionInformation->Options = NULL;
    pConnectionInformation->RemoteAddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    pConnectionInformation->RemoteAddress =
      (PTA_NETBIOS_ADDRESS)(pConnectionInformation + 1);
    pRemoteAddress = pConnectionInformation->RemoteAddress;
    pRemoteAddress->TAAddressCount = 1;
    pRemoteAddress->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pRemoteAddress->Address[0].Address[0].NetbiosNameType =
      TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    UnicodeStringToAnsiString(
      pszIpxAddress,
      szIpxAddress,
      sizeof (szIpxAddress));
    RtlZeroMemory((PCHAR)&pRemoteAddress->Address[0].Address[0].NetbiosName, 10);
    StringToNodeNumber(
      (PCHAR)szIpxAddress,
      (PCHAR)&pRemoteAddress->Address[0].Address[0].NetbiosName[10]);
    RASAUTO_TRACE6("IpxAddressToNetbiosName: Node=%02x:%02x:%02x:%02x:%02x:%02x\n",
      pRemoteAddress->Address[0].Address[0].NetbiosName[10],
      pRemoteAddress->Address[0].Address[0].NetbiosName[11],
      pRemoteAddress->Address[0].Address[0].NetbiosName[12],
      pRemoteAddress->Address[0].Address[0].NetbiosName[13],
      pRemoteAddress->Address[0].Address[0].NetbiosName[14],
      pRemoteAddress->Address[0].Address[0].NetbiosName[15]);

    dwBufferSize = 2048;
    for (;;) {
        pBuffer = LocalAlloc(LPTR, dwBufferSize);
        if (pBuffer == NULL) {
            RASAUTO_TRACE("IpxAddressToNetbiosName: LocalAlloc failed");
            LocalFree(pQuery);
            return NULL;
        }
        status = NtDeviceIoControlFile(
                   fd,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_TDI_QUERY_INFORMATION,
                   pQuery,
                   dwQuerySize,
                   pBuffer,
                   dwBufferSize);
        if (status != STATUS_BUFFER_OVERFLOW)
            break;

        LocalFree(pBuffer);
        dwBufferSize *= 2;
        if (dwBufferSize >= 0xffff) {
            RASAUTO_TRACE("IpxAddressToNetbiosName: Unable to allocate packet");
            LocalFree(pQuery);
            return NULL;
        }
    }
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(fd, TRUE, NULL);
        if (status == STATUS_SUCCESS)
            status = ioStatusBlock.Status;
    }
    NtClose(fd);

    pAdapterStatus = (PADAPTERSTATUS)pBuffer;
    dwcNames = pAdapterStatus->AdapterInfo.name_count;
    RASAUTO_TRACE2(
      "IpxAddressToNetbiosName: results (status=0x%x, dwcNames=%d)",
      status,
      dwcNames);
    if (status == STATUS_SUCCESS && dwcNames) {
        CHAR szNetbiosName[NCBNAMSZ + 1];

        pNames = pAdapterStatus->Names;
        if (CopyNetbiosName(pNames, dwcNames, szNetbiosName))
            pszNetbiosName = AnsiStringToUnicodeString(pNames->name, NULL, 0);
    }
    LocalFree(pBuffer);
    LocalFree(pQuery);

    return pszNetbiosName;
} // IpxAddressToNetbiosName



BOOLEAN
NetbiosFindName(
    IN LPTSTR *pszDevices,
    IN DWORD dwcDevices,
    IN LPTSTR pszAddress
    )
{
    NTSTATUS *pStatus;
    PHANDLE pfd;
    PHANDLE pEvent;
    POBJECT_ATTRIBUTES pObjectAttributes;
    PIO_STATUS_BLOCK pIoStatusBlock;
    PUNICODE_STRING pUnicodeString;
    PTDI_REQUEST_QUERY_INFORMATION pQuery;
    PTDI_CONNECTION_INFORMATION pConnectionInformation;
    PTA_NETBIOS_ADDRESS pRemoteAddress;
    CHAR szAddress[NCBNAMSZ];
    PVOID *pBuffer;
    DWORD i, dwQuerySize, dwBufferSize;
    PADAPTERSTATUS pAdapterStatus;
    NAME_BUFFER *pNames;
    DWORD dwcWait, dwcNames;
    BOOLEAN bFound = FALSE;

    //
    // If there are no Netbios devices, then we're done.
    //
    if (pszDevices == NULL || !dwcDevices)
        return FALSE;
    //
    // Allocate our arrays up front.
    //
    pStatus = (NTSTATUS *)LocalAlloc(LPTR, dwcDevices * sizeof (NTSTATUS));
    if (pStatus == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        return FALSE;
    }
    pfd = (PHANDLE)LocalAlloc(LPTR, dwcDevices * sizeof (HANDLE));
    if (pfd == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        return FALSE;
    }
    pUnicodeString = (PUNICODE_STRING)LocalAlloc(LPTR, dwcDevices * sizeof (UNICODE_STRING));
    if (pUnicodeString == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        return FALSE;
    }
    pEvent = (PHANDLE)LocalAlloc(
               LPTR,
               dwcDevices * sizeof (HANDLE));
    if (pEvent == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        return FALSE;
    }
    pObjectAttributes = (POBJECT_ATTRIBUTES)LocalAlloc(
                          LPTR,
                          dwcDevices * sizeof (OBJECT_ATTRIBUTES));
    if (pObjectAttributes == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        LocalFree(pEvent);
        return FALSE;
    }
    pIoStatusBlock = (PIO_STATUS_BLOCK)LocalAlloc(
                       LPTR,
                       dwcDevices * sizeof (IO_STATUS_BLOCK));
    if (pIoStatusBlock == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        LocalFree(pEvent);
        LocalFree(pObjectAttributes);
        return FALSE;
    }
    pBuffer = LocalAlloc(LPTR, dwcDevices * sizeof (PVOID));
    if (pBuffer == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        LocalFree(pEvent);
        LocalFree(pObjectAttributes);
        LocalFree(pIoStatusBlock);
        return FALSE;
    }
    //
    // Allocate and initialize our query structure.
    // We will give the same query to all the devices.
    //
    dwQuerySize = sizeof (TDI_REQUEST_QUERY_INFORMATION) +
                    sizeof (TDI_CONNECTION_INFORMATION) +
                    sizeof (TA_NETBIOS_ADDRESS);
    pQuery = LocalAlloc(LPTR, dwQuerySize);
    if (pQuery == NULL) {
        RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
        LocalFree(pStatus);
        LocalFree(pfd);
        LocalFree(pUnicodeString);
        LocalFree(pEvent);
        LocalFree(pObjectAttributes);
        LocalFree(pIoStatusBlock);
        return FALSE;
    }
    pQuery->QueryType = TDI_QUERY_ADAPTER_STATUS;
      (PTDI_CONNECTION_INFORMATION)&pQuery->RequestConnectionInformation;
    pQuery->RequestConnectionInformation =
      (PTDI_CONNECTION_INFORMATION)(pQuery + 1);
    pConnectionInformation = pQuery->RequestConnectionInformation;
    pConnectionInformation->UserDataLength = 0;
    pConnectionInformation->UserData = NULL;
    pConnectionInformation->OptionsLength = 0;
    pConnectionInformation->Options = NULL;
    pConnectionInformation->RemoteAddressLength = sizeof (TA_NETBIOS_ADDRESS);
    pConnectionInformation->RemoteAddress =
      (PTA_NETBIOS_ADDRESS)(pConnectionInformation + 1);
    pRemoteAddress = pConnectionInformation->RemoteAddress;
    pRemoteAddress->TAAddressCount = 1;
    pRemoteAddress->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pRemoteAddress->Address[0].Address[0].NetbiosNameType =
      TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    UnicodeStringToAnsiString(
      pszAddress,
      szAddress,
      sizeof (szAddress));
    RtlFillMemory(
      (PCHAR)&pRemoteAddress->Address[0].Address[0].NetbiosName,
      NCBNAMSZ,
      ' ');
    //
    // Make sure the Netbios name is in uppercase!
    //
    _strupr(szAddress);
    RtlCopyMemory(
      (PCHAR)&pRemoteAddress->Address[0].Address[0].NetbiosName,
      szAddress,
      strlen(szAddress));
    pRemoteAddress->Address[0].Address[0].NetbiosName[NCBNAMSZ - 1] = '\0';
    RASAUTO_TRACE1("NetbiosFindName: address=%s", szAddress);
    //
    // Initialize the OBJECT_ATTRIBUTES structure,
    // open the device, and start the query
    // for each device.
    //
    for (i = 0; i < dwcDevices; i++) {
        pBuffer[i] = NULL;

        RtlInitUnicodeString(&pUnicodeString[i], pszDevices[i]);
        InitializeObjectAttributes(
          &pObjectAttributes[i],
          &pUnicodeString[i],
          OBJ_CASE_INSENSITIVE,
          NULL,
          NULL);
        pEvent[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pEvent[i] == NULL) {
            RASAUTO_TRACE("NetbiosFindName: CreateEvent failed");
            goto done;
        }
        pStatus[i] = NtCreateFile(
                       &pfd[i],
                       FILE_READ_DATA|FILE_WRITE_DATA,
                       &pObjectAttributes[i],
                       &pIoStatusBlock[i],
                       NULL,
                       FILE_ATTRIBUTE_NORMAL,
                       FILE_SHARE_READ|FILE_SHARE_WRITE,
                       FILE_OPEN_IF,
                       0,
                       NULL,
                       0);
        if (!NT_SUCCESS(pStatus[i])) {
            RASAUTO_TRACE1("NetbiosFindName: NtCreateFile failed (status=0x%x)", pStatus[i]);
            continue;
        }
        //
        // Allocate the results buffer.
        //
        dwBufferSize = 2048;
        for (;;) {
            pBuffer[i] = LocalAlloc(LPTR, dwBufferSize);
            if (pBuffer[i] == NULL) {
                RASAUTO_TRACE("NetbiosFindName: LocalAlloc failed");
                goto done;
            }
            pStatus[i] = NtDeviceIoControlFile(
                           pfd[i],
                           pEvent[i],
                           NULL,
                           NULL,
                           &pIoStatusBlock[i],
                           IOCTL_TDI_QUERY_INFORMATION,
                           pQuery,
                           dwQuerySize,
                           pBuffer[i],
                           dwBufferSize);
            if (pStatus[i] != STATUS_BUFFER_OVERFLOW)
                break;

            LocalFree(pBuffer[i]);
            pBuffer[i] = NULL;
            dwBufferSize *= 2;
            if (dwBufferSize >= 0xffff) {
                RASAUTO_TRACE("NetbiosFindName: Unable to allocate packet");
                break;
            }
        }
    }
    //
    // Determine whether any of the
    // requests returned STATUS_SUCCESS.
    //
    RASAUTO_TRACE("NetbiosFindName: checking for STATUS_SUCCESS");
    dwcWait = 0;
    for (i = 0; i < dwcDevices; i++) {
        RASAUTO_TRACE2("NetbiosFindName: %S: status=%d", pszDevices[i], pStatus[i]);
        if (pStatus[i] == STATUS_SUCCESS) {
            pAdapterStatus = (PADAPTERSTATUS)pBuffer[i];
            dwcNames = pAdapterStatus->AdapterInfo.name_count;
            RASAUTO_TRACE2(
              "NetbiosFindName: %S: dwcNames=%d",
              pszDevices[i],
              dwcNames);
            if (dwcNames) {
                bFound = TRUE;
                goto done;
            }
        }
        else if (pStatus[i] == STATUS_PENDING)
            dwcWait++;
    }
    //
    // If we didn't find a successful return,
    // then wait for the others to complete.
    //
    RASAUTO_TRACE1("NetbiosFindName: dwcWait=%d", dwcWait);
    for (i = 0; i < dwcWait; i++) {
        NTSTATUS status;
        DWORD dwiDevice;

        status = WaitForMultipleObjects(dwcDevices, pEvent, FALSE, INFINITE);
        RASAUTO_TRACE1("NetbiosFindName: WaitForMultipleObjects returned 0x%x", status);
        if (status == WAIT_FAILED) {
            RASAUTO_TRACE1(
              "NetbiosFindName: WaitForMultipleObjects failed (status=0x%x)",
              GetLastError());
            goto done;
        }
        dwiDevice = (DWORD)status - WAIT_OBJECT_0;
        if (dwiDevice >= dwcDevices) {
            RASAUTO_TRACE(
              "NetbiosFindName: WaitForMultipleObjects returned STATUS_ABANDONED?");
            goto done;
        }
        pStatus[dwiDevice] = pIoStatusBlock[dwiDevice].Status;
        RASAUTO_TRACE2(
          "NetbiosFindName: %S returned status 0x%x from wait",
          pszDevices[dwiDevice],
          pStatus[dwiDevice]);
        if (pStatus[dwiDevice] == STATUS_SUCCESS) {
            pAdapterStatus = (PADAPTERSTATUS)pBuffer[dwiDevice];
            dwcNames = pAdapterStatus->AdapterInfo.name_count;
            RASAUTO_TRACE2(
              "NetbiosFindName: %S: dwcNames=%d",
              pszDevices[dwiDevice],
              dwcNames);
            if (dwcNames) {
                bFound = TRUE;
                goto done;
            }
        }
    }
done:
    //
    // Free the resources associated with
    // each device.
    //
    for (i = 0; i < dwcDevices; i++) {
        RASAUTO_TRACE4(
          "NetbiosFindName: pIoStatusBlock[%d]=0x%x, pBuffer[%d]=0x%x",
          i,
          &pIoStatusBlock[i],
          i,
          pBuffer[i]);
          
        if (pfd[i] != NULL)
        {
            (void)NtCancelIoFile(pfd[i], &pIoStatusBlock[i]);
            NtClose(pfd[i]);
        }
        if (pEvent[i] != NULL)
            CloseHandle(pEvent[i]);
        if (pBuffer[i] != NULL)
            LocalFree(pBuffer[i]);
    }
    //
    // Free the buffers we allocated above.
    //
    LocalFree(pStatus);
    LocalFree(pfd);
    LocalFree(pUnicodeString);
    LocalFree(pEvent);
    LocalFree(pObjectAttributes);
    LocalFree(pIoStatusBlock);
    LocalFree(pBuffer);

    return bFound;
} // NetbiosFindName



struct hostent *
IpAddressToHostent(
    IN LPTSTR pszInetAddress
    )
{
    CHAR szInetAddress[ACD_ADDR_INET_LEN];
    ULONG inaddr;
    struct hostent *hp;

    UnicodeStringToAnsiString(
      pszInetAddress,
      szInetAddress,
      sizeof (szInetAddress));
    inaddr = inet_addr(szInetAddress);
    //
    // Disable the address so when we call gethostbyname(),
    // we won't cause an autodial attempt.  Enable it after
    // we're done.
    //
    SetAddressDisabled(pszInetAddress, TRUE);
    hp = gethostbyaddr((char *)&inaddr, 4, PF_INET);
    SetAddressDisabled(pszInetAddress, FALSE);

    return hp;
} // InetAddressToHostent



struct hostent *
InetAddressToHostent(
    IN LPTSTR pszInetAddress
    )
{
    CHAR szInetAddress[ACD_ADDR_INET_LEN];
    struct hostent *hp;

    UnicodeStringToAnsiString(
      pszInetAddress,
      szInetAddress,
      sizeof (szInetAddress));
    //
    // Disable the address so when we call gethostbyname(),
    // we won't cause an autodial attempt.  Enable it after
    // we're done.
    //
    SetAddressDisabled(pszInetAddress, TRUE);
    hp = gethostbyname(szInetAddress);
    SetAddressDisabled(pszInetAddress, FALSE);

    return hp;
} // InetAddressToHostEnt



BOOLEAN
PingIpAddress(
    IN LPTSTR pszIpAddress
    )

/*++

DESCRIPTION
    Determine whether an IP address is accessible by pinging it.

ARGUMENTS
    lpszAddress: the IP address

RETURN VALUE
    TRUE if lpszAddress is accessible, FALSE otherwise.

--*/

{
    BOOLEAN fSuccess = FALSE;
    LONG inaddr;
    char szIpAddress[17];
    int i, nReplies, nTry;
    char *lpSendBuf = NULL, *lpRecvBuf = NULL;
    HANDLE hIcmp = NULL;
    IP_OPTION_INFORMATION SendOpts;
    PICMP_ECHO_REPLY lpReply;

    UnicodeStringToAnsiString(pszIpAddress, szIpAddress, sizeof (szIpAddress));
    inaddr = inet_addr(szIpAddress);
    RASAUTO_TRACE2("PingIpAddress: IP address=(%s, 0x%x)", szIpAddress, inaddr);
    //
    // Check to make sure we loaded icmp.dll.
    //
    if (hIcmpG == NULL) {
        RASAUTO_TRACE("PingIpAddress: icmp.dll not loaded!");
        return FALSE;
    }
    //
    // Open the icmp device.
    //
    hIcmp = (HANDLE)(*lpfnIcmpCreateFileG)();
    if (hIcmp == INVALID_HANDLE_VALUE) {
        RASAUTO_TRACE("PingIpAddress: IcmpCreateFile failed");
        return FALSE;
    }
    //
    // Allocate the send and receive buffers.
    //
    lpSendBuf = LocalAlloc(LMEM_FIXED, PING_SEND_SIZE);
    if (lpSendBuf == NULL) {
        RASAUTO_TRACE("PingIpAddress: LocalAlloc failed");
        goto done;
    }
    lpRecvBuf = LocalAlloc(LMEM_FIXED, PING_RECV_SIZE);
    if (lpRecvBuf == NULL) {
        RASAUTO_TRACE("PingIpAddress: LocalAlloc failed");
        goto done;
    }
    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < PING_SEND_SIZE; i++)
        lpSendBuf[i] = 'a' + (i % 23);
    //
    // Initialize the send options.
    //
    SendOpts.OptionsData = (unsigned char FAR *)0;
    SendOpts.OptionsSize = 0;
    SendOpts.Ttl = PING_TTL;
    SendOpts.Tos = 0;
    SendOpts.Flags = 0;
    //
    // Ping the host.
    //
    for (nTry = 0; nTry < 3; nTry++) {
        DWORD dwTimeout = 750;

#ifdef notdef
        if (nTry < 2)
            dwTimeout = 750;
        else
            dwTimeout = 2000;
#endif
        //
        // Check to make sure the service isn't shutting
        // down before we start on our next iteration.
        //
        if (WaitForSingleObject(hTerminatingG, 0) != WAIT_TIMEOUT) {
            RASAUTO_TRACE("PingIpAddress: shutting down");
            LocalFree(lpRecvBuf);
            LocalFree(lpSendBuf);
            return FALSE;
        }
        nReplies = (int) (*lpfnIcmpSendEchoG)(
                             hIcmp,
                             inaddr,
                             lpSendBuf,
                             (unsigned short)PING_SEND_SIZE,
                             &SendOpts,
                             lpRecvBuf,
                             PING_RECV_SIZE,
                             dwTimeout);
        //
        // Look at the responses to see
        // if any are successful.
        //
        for (lpReply = (PICMP_ECHO_REPLY)lpRecvBuf, i = 0;
             i < nReplies;
             lpReply++, i++)
        {
            RASAUTO_TRACE2(
              "PingIpAddress: ping reply status[%d]=%d",
              i,
              lpReply->Status);
            //
            // Unless the status is IP_REQ_TIMED_OUT,
            // we're done.
            //
            fSuccess = (lpReply->Status == IP_SUCCESS);
            if (lpReply->Status != IP_REQ_TIMED_OUT)
                goto done;
        }
    }
    //
    // Clean up.
    //
done:
    if (lpRecvBuf != NULL)
        LocalFree(lpRecvBuf);
    if (lpSendBuf != NULL)
        LocalFree(lpSendBuf);
    if (hIcmp != NULL)
        (*lpfnIcmpCloseHandleG)(hIcmp);

    return fSuccess;
} // PingIpAddress



VOID
LoadIcmpDll(VOID)
{
    hIcmpG = LoadLibrary(ICMP_MODULE);
    if (hIcmpG == NULL)
        return;
    lpfnIcmpCreateFileG = GetProcAddress(hIcmpG, ICMPCREATEFILE);
    lpfnIcmpSendEchoG = GetProcAddress(hIcmpG, ICMPSENDECHO);
    lpfnIcmpCloseHandleG = GetProcAddress(hIcmpG, ICMPCLOSEHANDLE);
    if (lpfnIcmpCreateFileG == NULL ||
        lpfnIcmpSendEchoG == NULL ||
        lpfnIcmpCloseHandleG == NULL)
    {
        FreeLibrary(hIcmpG);
        hIcmpG = NULL;
        return;
    }
} // LoadIcmpDll



VOID
UnloadIcmpDll(VOID)
{
    if (hIcmpG != NULL) {
        FreeLibrary(hIcmpG);
        hIcmpG = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\addrmap.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    addrmap.c

ABSTRACT
    Address attributes database routines shared between
    the automatic connection driver, the registry, and
    the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 01-Sep-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <npapi.h>
#include <acd.h>
#include <ras.h>
#include <raserror.h>
#include <rasman.h>
#include <debug.h>
#include <time.h>
#include <wchar.h>

#include "table.h"
#include "reg.h"
#include "imperson.h"
#include "misc.h"
#include "addrmap.h"
#include "netmap.h"
#include "rasprocs.h"
#include "tapiproc.h"

#define DAYSECONDS  (60*60*24)

extern HKEY hkeyCUG;

extern LONG g_lRasAutoRunning;

extern DWORD g_dwCritSecFlags;

//
// All the information we cache about
// an address is below.  The ulAttributes
// field is written to the automatic connection
// driver, and the rest of the fields are written
// to the registry.
//
#define ADDRESS_MAP_FIELD_DIALINGLOC    0x00000001  // locationList changed
#define ADDRESS_MAP_FIELD_PARAMS        0x00000002  // params

typedef struct _ADDRESS_DIALING_ENTRY {
    LIST_ENTRY ListEntry;
    BOOLEAN fChanged;           // modified bit
    ADDRESS_LOCATION_INFORMATION location;
} ADDRESS_DIALING_ENTRY, *PADDRESS_DIALING_ENTRY;

typedef struct _ADDRESS_MAP_ENTRY {
    LPTSTR pszNetwork;          // the remote network this address is on
    ULONG ulModifiedMask;       // which fields have been changed
    BOOLEAN fDisabled;          // disabled for connection attempts
    DWORD dwFailedConnectTicks; // last failed connect time
    ADDRESS_PARAMS params;      // used to garbage collect unref addresses
    LIST_ENTRY locationHead;    // list of ADDRESS_DIALING_ENTRYs
    BOOLEAN fPruned;            // removed by the list writer
    LIST_ENTRY writerList;      // list writer links
} ADDRESS_MAP_ENTRY, *PADDRESS_MAP_ENTRY;

//
// The address map head.
//
typedef struct _ADDRESS_MAP {
    CRITICAL_SECTION csLock;
    PHASH_TABLE pTable;
} ADDRESS_MAP, *PADDRESS_MAP;

//
// Information needed by the address
// enumerator procedure.
//
typedef struct _ADDRESS_ENUM_INFO {
    ULONG ulIndex;
    LPTSTR *pAddresses;
} ADDRESS_ENUM_INFO, *PADDRESS_ENUM_INFO;

//
// Information needed by the address map list
// builder enumerator procedure.
//
typedef struct _ADDRESS_LIST_INFO {
    LIST_ENTRY tagHead[3];      // one per ADDRMAP_TAG_*
} ADDRESS_LIST_INFO, *PADDRESS_LIST_INFO;

//
// Structure shared by GetOrganizationDialingLocationEntry()
// and FindOrganization() when looking for an address that
// has the same organization name.
//
typedef struct _MATCH_INFO {
    BOOLEAN fWww;                        // look for www-style address
    BOOLEAN fOrg;                        // look for organization
    DWORD dwLocationID;                  // current dialing location
    BOOLEAN bFound;                      // TRUE if success
    WCHAR szOrganization[ACD_ADDR_INET_LEN]; // organization we're looking for
    WCHAR szAddress[ACD_ADDR_INET_LEN];  // matching address, if found
    PADDRESS_DIALING_ENTRY pDialingEntry; // dialing location entry pointer
} MATCH_INFO, *PMATCH_INFO;

//
// Default permanently disabled addresses.
//
#define MAX_DISABLED_ADDRESSES  5
TCHAR *szDisabledAddresses[MAX_DISABLED_ADDRESSES] = {
    TEXT("0.0.0.0"),
    TEXT("255.255.255.255"),
    TEXT("127.0.0.0"),
    TEXT("127.0.0.1"),
    TEXT("dialin_gateway")
};

//
// Global variables
//
ADDRESS_MAP AddressMapG;
HANDLE hAutodialRegChangeG = NULL;
DWORD dwLearnedAddressIndexG;
PHASH_TABLE pDisabledAddressesG;
CRITICAL_SECTION csDisabledAddressesLockG;

//
// External variables
//
extern HANDLE hAcdG;
extern HANDLE hNewLogonUserG;
extern HANDLE hNewFusG;         // Fast user switching
extern HANDLE hPnpEventG;
extern HANDLE hLogoffUserG;
extern HANDLE hLogoffUserDoneG;
extern HANDLE hTapiChangeG;
extern HANDLE hTerminatingG;
extern IMPERSONATION_INFO ImpersonationInfoG;



PADDRESS_MAP_ENTRY
NewAddressMapEntry()
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = LocalAlloc(LPTR, sizeof (ADDRESS_MAP_ENTRY));
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("NewAddressMapEntry: LocalAlloc failed");
        return NULL;
    }
    pAddressMapEntry->pszNetwork = NULL;
    pAddressMapEntry->ulModifiedMask = 0;
    InitializeListHead(&pAddressMapEntry->locationHead);
    pAddressMapEntry->params.dwTag = 0xffffffff;
    pAddressMapEntry->params.dwModifiedTime = (DWORD)time(0);

    return pAddressMapEntry;
} // NewAddressMapEntry



PADDRESS_MAP_ENTRY
GetAddressMapEntry(
    IN LPTSTR pszAddress,
    IN BOOLEAN fAllocate
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry = NULL;

    if (pszAddress == NULL)
        return NULL;

    if (GetTableEntry(
          AddressMapG.pTable,
          pszAddress,
          &pAddressMapEntry))
    {
        goto done;
    }
    if (fAllocate) {
        pAddressMapEntry = NewAddressMapEntry();
        if (pAddressMapEntry == NULL) {
            RASAUTO_TRACE("GetAddressMapEntry: NewAddressMapEntry failed");
            goto done;
        }
        if (!PutTableEntry(AddressMapG.pTable, pszAddress, pAddressMapEntry))
        {
            RASAUTO_TRACE("GetAddressMapEntry: PutTableEntry failed");
            LocalFree(pAddressMapEntry);
            pAddressMapEntry = NULL;
            goto done;
        }
    }

done:
    return pAddressMapEntry;
} // GetAddressMapEntry



VOID
FreeAddressMapEntry(
    IN PADDRESS_MAP_ENTRY pAddressMapEntry
    )
{
    PLIST_ENTRY pEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    //
    // Free all dynamically allocated strings.
    //
    if (pAddressMapEntry->pszNetwork != NULL)
        LocalFree(pAddressMapEntry->pszNetwork);
    while (!IsListEmpty(&pAddressMapEntry->locationHead)) {
        pEntry = RemoveHeadList(&pAddressMapEntry->locationHead);
        pDialingEntry =
          CONTAINING_RECORD(pEntry, ADDRESS_DIALING_ENTRY, ListEntry);

        LocalFree(pDialingEntry);
    }
    //
}



BOOLEAN
ResetDriver()
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    status = NtDeviceIoControlFile(
               hAcdG,
               NULL,
               NULL,
               NULL,
               &ioStatusBlock,
               IOCTL_ACD_RESET,
               NULL,
               0,
               NULL,
               0);
    if (status != STATUS_SUCCESS) {
        RASAUTO_TRACE1(
          "ResetDriver: NtDeviceIoControlFile failed (status=0x%x)",
          status);
        return FALSE;
    }
    return TRUE;
} // ResetDriver



BOOLEAN
EnableDriver()
{
    NTSTATUS status;
    DWORD dwErr;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN fEnable = TRUE;

    dwErr = AutoDialEnabled(&fEnable);
    RASAUTO_TRACE1("EnableDriver: fEnable=%d", fEnable);
    status = NtDeviceIoControlFile(
               hAcdG,
               NULL,
               NULL,
               NULL,
               &ioStatusBlock,
               IOCTL_ACD_ENABLE,
               &fEnable,
               sizeof (fEnable),
               NULL,
               0);
    if (status != STATUS_SUCCESS) {
        RASAUTO_TRACE1(
          "ResetDriver: NtDeviceIoControlFile failed (status=0x%x)",
          status);
        return FALSE;
    }
    return TRUE;
} // EnableDriver



PADDRESS_DIALING_ENTRY
FindAddressDialingEntry(
    IN PADDRESS_MAP_ENTRY pAddressMapEntry,
    IN DWORD dwLocation
    )
{
    PLIST_ENTRY pEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    for (pEntry = pAddressMapEntry->locationHead.Flink;
         pEntry != &pAddressMapEntry->locationHead;
         pEntry = pEntry->Flink)
    {
        pDialingEntry = CONTAINING_RECORD(
                             pEntry,
                             ADDRESS_DIALING_ENTRY,
                             ListEntry);

        if (pDialingEntry->location.dwLocation == dwLocation)
            return pDialingEntry;
    }

    return NULL;
} // FindAddressDialingEntry



BOOLEAN
ClearAddressMapEntry(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;

    FreeAddressMapEntry(pAddressMapEntry);

    return TRUE;
} // ClearAddressMapEntry



VOID
ClearAddressMap(VOID)
{
    EnumTable(AddressMapG.pTable, ClearAddressMapEntry, NULL);
    ClearTable(AddressMapG.pTable);
} // ClearAddressMap



VOID
ResetAddressMapAddress(
    IN LPTSTR pszAddress
    )
{
    DWORD dwErr, dwcb, dwcAddresses, dwcEntries;
    DWORD i, j;
    PADDRESS_MAP_ENTRY pAddressMapEntry = NULL;
    PADDRESS_LOCATION_INFORMATION pLocationInfo = NULL;

    RASAUTO_TRACE1("ResetAddressMapAddress(%S)", pszAddress);

    dwErr = GetAddressDialingLocationInfo(
              pszAddress,
              &pLocationInfo,
              &dwcEntries);
    if (dwErr || !dwcEntries)
        return;
    //
    // Enter this address into the address map
    // if it doesn't already exist.
    //
    if (!GetTableEntry(AddressMapG.pTable, pszAddress, &pAddressMapEntry)) {
        pAddressMapEntry = NewAddressMapEntry();
        if (pAddressMapEntry == NULL) {
            RASAUTO_TRACE("ResetAddressMapAddress: NewAddressMapEntry failed");
            goto done;
        }
        pAddressMapEntry->fDisabled = FALSE;
        RASAUTO_TRACE1(
          "ResetAddressMap: inserting pszAddress=%S",
          RASAUTO_TRACESTRW(pszAddress));
        if (!PutTableEntry(
              AddressMapG.pTable,
              pszAddress,
              pAddressMapEntry))
        {
            RASAUTO_TRACE("ResetAddressMapAddress: PutTableEntry failed");
            goto done;
        }
    }
    //
    // Get the network for this address.
    //
    if (pAddressMapEntry->pszNetwork == NULL) {
        pAddressMapEntry->pszNetwork = AddressToNetwork(pszAddress);
        if (pAddressMapEntry->pszNetwork == NULL) {
            RASAUTO_TRACE1(
              "ResetAddressMapAddress: AddressToNetwork(%S) failed",
              pszAddress);
            LocalFree(pAddressMapEntry);
            goto done;
        }
    }
    //
    // Read the Autodial parameters for this address.
    //
    GetAddressParams(pszAddress, &pAddressMapEntry->params);
    //
    // Add this address to the associated
    // network map.
    //
    LockNetworkMap();
    AddNetworkAddress(
      pAddressMapEntry->pszNetwork,
      pszAddress,
      pAddressMapEntry->params.dwTag);
    UnlockNetworkMap();
    //
    // Add each dialing location onto
    // the address's list.
    //
    for (j = 0; j < dwcEntries; j++) {
        PADDRESS_DIALING_ENTRY pDialingEntry;

        pDialingEntry = FindAddressDialingEntry(
                          pAddressMapEntry,
                          pLocationInfo[j].dwLocation);
        if (pDialingEntry == NULL) {
            //
            // The dialing entry doesn't exist.
            // We need to create it.
            //
            pDialingEntry = LocalAlloc(LPTR, sizeof (ADDRESS_DIALING_ENTRY));
            if (pDialingEntry == NULL) {
                RASAUTO_TRACE("ResetAddressMapAddress: LocalAlloc failed");
                goto done;
            }
            RASAUTO_TRACE1(
              "ResetAddressMapAddress: inserting dwLocationID=%d",
              pLocationInfo[j].dwLocation);
            pDialingEntry->fChanged = FALSE;
            pDialingEntry->location = pLocationInfo[j];
            InsertTailList(&pAddressMapEntry->locationHead, &pDialingEntry->ListEntry);
        }
        else if (_wcsicmp(
                   pDialingEntry->location.pszEntryName,
                   pLocationInfo[j].pszEntryName))
        {
            //
            // The dialing entry does exist, but
            // the phonebook entry has changed.
            //
            RASAUTO_TRACE2(
              "ResetAddressMapAddress: updating dwLocationID=%d with %S",
              pLocationInfo[j].dwLocation,
              RASAUTO_TRACESTRW(pLocationInfo[j].pszEntryName));
            pDialingEntry->location.pszEntryName =
              pLocationInfo[j].pszEntryName;
        }
        else {
            //
            // The dialing entry exists, and we
            // already have it loaded.
            //
            RASAUTO_TRACE1(
              "ResetAddressMapAddress: no changes for dwLocationID=%d",
              pLocationInfo[j].dwLocation);
            LocalFree(pLocationInfo[j].pszEntryName);
        }
    }

done:
    LocalFree(pLocationInfo);
} // ResetAddressMapAddress



BOOLEAN
ResetAddressMap(
    IN BOOLEAN fClear
    )
{
    BOOLEAN fSuccess = FALSE;
    DWORD dwErr, i, dwcb, dwcAddresses;
    LPTSTR *ppAddresses = NULL;

    //
    // Clear the current addresses from the table.
    // and reset the driver.
    //
    if (fClear) {
        LockAddressMap();
        ClearAddressMap();
        UnlockAddressMap();
        if (!ResetDriver())
            return FALSE;
    }
    //
    // Enumerate the Autodial addresses.
    //
    dwErr = EnumAutodialAddresses(NULL, &dwcb, &dwcAddresses);
    if (dwErr && dwErr != ERROR_BUFFER_TOO_SMALL) {
        RASAUTO_TRACE1(
          "ResetAddressMap: RasEnumAutodialAddresses failed (dwErr=%d)",
          dwErr);
        return FALSE;
    }
    if (!dwcAddresses)
        return TRUE;
    ppAddresses = LocalAlloc(LPTR, dwcb);
    if (ppAddresses == NULL) {
        RASAUTO_TRACE("ResetAddressMap: LocalAlloc failed");
        return FALSE;
    }
    dwErr = EnumAutodialAddresses(
              ppAddresses,
              &dwcb,
              &dwcAddresses);
    if (dwErr) {
        RASAUTO_TRACE1(
          "ResetAddressMap: RasEnumAutodialAddresses failed (dwErr=%d)",
          dwErr);
        goto done;
    }
    //
    // Get the Autodial information for
    // each of the addresses.
    //
    LockAddressMap();
    for (i = 0; i < dwcAddresses; i++)
        ResetAddressMapAddress(ppAddresses[i]);
    UnlockAddressMap();
    LocalFree(ppAddresses);
    ppAddresses = NULL;
    fSuccess = TRUE;

done:
    //
    // Free resources.
    //
    if (ppAddresses != NULL)
        LocalFree(ppAddresses);

    return fSuccess;
} // ResetAddressMap



BOOLEAN
InitializeAddressMap()
{
    DWORD dwErr;

    RasInitializeCriticalSection(&AddressMapG.csLock, &dwErr);

    if(dwErr != ERROR_SUCCESS)
    {
        return FALSE;
    }

    g_dwCritSecFlags |= RASAUTO_CRITSEC_ADDRMAP;
    
    AddressMapG.pTable = NewTable();
    if (AddressMapG.pTable == NULL) {
        RASAUTO_TRACE("InitializeAddressMap: NewTable failed");
        DeleteCriticalSection(&AddressMapG.csLock);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_ADDRMAP);
        return FALSE;
    }
    return TRUE;
} // InitializeAddressMap

VOID
UninitializeAddressMap()
{
    if(g_dwCritSecFlags & RASAUTO_CRITSEC_ADDRMAP)
    {
        DeleteCriticalSection(&AddressMapG.csLock);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_ADDRMAP);
    }
}


VOID
LockAddressMap()
{
    EnterCriticalSection(&AddressMapG.csLock);
} // LockAddressMap



VOID
UnlockAddressMap()
{
    LeaveCriticalSection(&AddressMapG.csLock);
} // UnlockAddressMap


VOID
LockDisabledAddresses()
{
    EnterCriticalSection(&csDisabledAddressesLockG);
}

VOID
UnlockDisabledAddresses()
{
    LeaveCriticalSection(&csDisabledAddressesLockG);
}


BOOLEAN
WriteRegistryFields(
    IN LPTSTR pszAddress,
    IN PADDRESS_MAP_ENTRY pAddressMapEntry
    )
{
    DWORD dwErr;
    PLIST_ENTRY pEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    //
    // Write the address garbage-collection params.
    //
    if (pAddressMapEntry->ulModifiedMask & ADDRESS_MAP_FIELD_PARAMS) {
        dwErr = SetAddressParams(pszAddress, &pAddressMapEntry->params);
        if (dwErr)
            return FALSE;
        pAddressMapEntry->ulModifiedMask &= ~ADDRESS_MAP_FIELD_PARAMS;
    }
    //
    // Write the dialing location information.
    //
    if (pAddressMapEntry->ulModifiedMask & ADDRESS_MAP_FIELD_DIALINGLOC) {
        for (pEntry = pAddressMapEntry->locationHead.Flink;
             pEntry != &pAddressMapEntry->locationHead;
             pEntry = pEntry->Flink)
        {
            LPTSTR pszPhonebook, pszEntry;

            pDialingEntry = CONTAINING_RECORD(
                                 pEntry,
                                 ADDRESS_DIALING_ENTRY,
                                 ListEntry);

            if (!pDialingEntry->fChanged)
                continue;
            RASAUTO_TRACE3(
              "WriteRegistryFields: writing %S=%d/%S",
              RASAUTO_TRACESTRW(pszAddress),
              pDialingEntry->location.dwLocation,
              pDialingEntry->location.pszEntryName);
            dwErr = SetAddressDialingLocationInfo(
                      pszAddress,
                      &pDialingEntry->location);
            if (dwErr)
                return FALSE;
            pDialingEntry->fChanged = FALSE;
        }
        //
        // If the network value for this address
        // is NULL, read it now from the registry.
        //
        if (pAddressMapEntry->pszNetwork == NULL) {
            pAddressMapEntry->pszNetwork = AddressToNetwork(pszAddress);
            if (pAddressMapEntry->pszNetwork == NULL) {
                RASAUTO_TRACE1(
                  "WriteRegistryFields: AddressToNetwork(%S) failed",
                  RASAUTO_TRACESTRW(pszAddress));
            }
        }
        //
        // Clear the modified field mask.
        //
        pAddressMapEntry->ulModifiedMask &= ~ADDRESS_MAP_FIELD_DIALINGLOC;
    }

    return TRUE;
} // WriteRegistryFields



BOOLEAN
BuildAddressList(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_LIST_INFO pAddressListInfo = (PADDRESS_LIST_INFO)pArg;
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;
    PADDRESS_MAP_ENTRY pAddrMapEntry;
    PLIST_ENTRY pPrevEntry, pEntry;
    DWORD dwTag = pAddressMapEntry->params.dwTag;

    //
    // If the address does not have any
    // dialing location information, then
    // skip it.
    //
    if (IsListEmpty(&pAddressMapEntry->locationHead)) {
        pAddressMapEntry->fPruned = TRUE;
        RASAUTO_TRACE1("BuildAddressList: %S has no location info", pszAddress);
        return TRUE;
    }
    dwTag = pAddressMapEntry->params.dwTag < ADDRMAP_TAG_LEARNED ?
              pAddressMapEntry->params.dwTag :
              ADDRMAP_TAG_LEARNED;
    //
    // If the list is empty, insert it at the head.
    // Otherwise sort the items in descending order
    // by last modified time per tag.  There is no order
    // for ADDRMAP_TAG_NONE addresses, so we insert them
    // all at the head of the list.
    //
    if (dwTag == ADDRMAP_TAG_NONE ||
        IsListEmpty(&pAddressListInfo->tagHead[dwTag]))
    {
        InsertHeadList(&pAddressListInfo->tagHead[dwTag], &pAddressMapEntry->writerList);
    }
    else {
        BOOLEAN fInserted = FALSE;

        pPrevEntry = &pAddressListInfo->tagHead[dwTag];
        for (pEntry = pAddressListInfo->tagHead[dwTag].Flink;
             pEntry != &pAddressListInfo->tagHead[dwTag];
             pEntry = pEntry->Flink)
        {
            pAddrMapEntry = CONTAINING_RECORD(pEntry, ADDRESS_MAP_ENTRY, writerList);

            //
            // There are two cases to skip to the next
            // entry:
            //
            //     (1) If the tag is either ADDRMAP_TAG_NONE or
            //         ADDRMAP_TAG_USED, then we insert sorted
            //         by dwModifiedTime.
            //     (2) If the tag is ADDRMAP_TAG_LEARNED, then
            //         we insert sorted by dwTag, and then by
            //         dwModifiedTime.
            // dwTag.
            //
            if ((dwTag < ADDRMAP_TAG_LEARNED &&
                 pAddressMapEntry->params.dwModifiedTime <=
                   pAddrMapEntry->params.dwModifiedTime) ||
                (dwTag == ADDRMAP_TAG_LEARNED &&
                 (pAddressMapEntry->params.dwTag >
                   pAddrMapEntry->params.dwTag) ||
                 (pAddressMapEntry->params.dwTag ==
                   pAddrMapEntry->params.dwTag &&
                     (pAddressMapEntry->params.dwModifiedTime <=
                       pAddrMapEntry->params.dwModifiedTime))))
            {
                pPrevEntry = pEntry;
                continue;
            }
            InsertHeadList(pPrevEntry, &pAddressMapEntry->writerList);
            fInserted = TRUE;
            break;
        }
        if (!fInserted) {
            InsertTailList(
              &pAddressListInfo->tagHead[dwTag],
              &pAddressMapEntry->writerList);
        }
    }

    return TRUE;
} // BuildAddressList



VOID
MarkAddressList(
    IN PADDRESS_LIST_INFO pAddressListInfo
    )
{
    DWORD i, dwcAddresses = 0;
    DWORD dwMaxAddresses = GetAutodialParam(RASADP_SavedAddressesLimit);
    PLIST_ENTRY pEntry;
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    RASAUTO_TRACE1("MarkAddressList: RASADP_SavedAddressesLimit=%d", dwMaxAddresses);
    //
    // Enumerate the entries in the list in order,
    // and mark the fPruned bit if its order in the
    // list exceeds the maximum set by the user.
    // We do not include the ADDRMAP_TAG_NONE address
    // in the address count.  All of these addresses
    // always get written.
    //
    for (i = 0; i < 3; i++) {
        for (pEntry = pAddressListInfo->tagHead[i].Flink;
             pEntry != &pAddressListInfo->tagHead[i];
             pEntry = pEntry->Flink)
        {
            pAddressMapEntry = CONTAINING_RECORD(pEntry, ADDRESS_MAP_ENTRY, writerList);

            //
            // If we exceed the limit of addresses in the
            // registry, we have to delete it.
            //
            if (i == ADDRMAP_TAG_NONE)
                pAddressMapEntry->fPruned = FALSE;
            else
                pAddressMapEntry->fPruned = (++dwcAddresses > dwMaxAddresses);
        }
    }
} // MarkAddressList



BOOLEAN
PruneAddressList(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;

    if (pAddressMapEntry->fPruned) {
        RASAUTO_TRACE1("PruneAddressList: NEED TO DELETE ADDRESS %S in the driver!", pszAddress);
        ClearAddressDialingLocationInfo(pszAddress);
        FreeAddressMapEntry(pAddressMapEntry);
        DeleteTableEntry(AddressMapG.pTable, pszAddress);
    }

    return TRUE;
} // PruneAddressList



BOOLEAN
WriteAddressMap(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;

    if (pAddressMapEntry->ulModifiedMask) {
        if (!WriteRegistryFields(
               pszAddress,
               pAddressMapEntry))
        {
            RASAUTO_TRACE("WriteAddressMap: WriteRegistryFields failed");
        }
    }

    return TRUE;
} // WriteAddressMap



BOOLEAN
FlushAddressMap()
{
    ADDRESS_LIST_INFO addressListInfo;

    //
    // Build a new list sorted by address tag and modified
    // date.
    //
    InitializeListHead(&addressListInfo.tagHead[ADDRMAP_TAG_LEARNED]);
    InitializeListHead(&addressListInfo.tagHead[ADDRMAP_TAG_USED]);
    InitializeListHead(&addressListInfo.tagHead[ADDRMAP_TAG_NONE]);
    EnumTable(AddressMapG.pTable, BuildAddressList, &addressListInfo);
    MarkAddressList(&addressListInfo);
    EnumTable(AddressMapG.pTable, PruneAddressList, NULL);
    //
    // Turn off registry change notifications
    // while we are doing this.
    //
    EnableAutoDialChangeEvent(hAutodialRegChangeG, FALSE);
    EnumTable(AddressMapG.pTable, WriteAddressMap, NULL);
    //
    // Enable registry change events again.
    //
    EnableAutoDialChangeEvent(hAutodialRegChangeG, TRUE);

    return TRUE;
} // FlushAddressMap



ULONG
AddressMapSize()
{
    return AddressMapG.pTable->ulSize;
} // AddressMapSize;



BOOLEAN
EnumAddresses(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )
{
    PADDRESS_ENUM_INFO pEnumInfo = (PADDRESS_ENUM_INFO)pArg;

    pEnumInfo->pAddresses[pEnumInfo->ulIndex++] = CopyString(pszAddress);
    return TRUE;
} // EnumAddresses



BOOLEAN
ListAddressMapAddresses(
    OUT LPTSTR **ppszAddresses,
    OUT PULONG pulcAddresses
    )
{
    ADDRESS_ENUM_INFO enumInfo;

    //
    // Check for an empty list.
    //
    *pulcAddresses = AddressMapG.pTable->ulSize;
    if (!*pulcAddresses) {
        *ppszAddresses = NULL;
        return TRUE;
    }
    //
    // Allocate a list large enough to hold all
    // the addresses.
    //
    *ppszAddresses = LocalAlloc(LPTR, *pulcAddresses * sizeof (LPTSTR));
    if (*ppszAddresses == NULL) {
        RASAUTO_TRACE("ListAddressMapAddresses: LocalAlloc failed");
        return FALSE;
    }
    //
    // Set up the structure for the enumerator
    // procedure.
    //
    enumInfo.ulIndex = 0;
    enumInfo.pAddresses = *ppszAddresses;
    EnumTable(AddressMapG.pTable, EnumAddresses, &enumInfo);

    return TRUE;
} // ListAddressMapAddresses



VOID
EnumAddressMap(
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    )
{
    EnumTable(AddressMapG.pTable, pProc, pArg);
} // EnumAddressMap



BOOLEAN
GetAddressDisabled(
    IN LPTSTR pszAddress,
    OUT PBOOLEAN pfDisabled
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;


    {
        DWORD i;
        LPTSTR pszDisabled[] =
            {
                TEXT("wpad"),
                TEXT("pnptriage"),
                TEXT("nttriage"),
                TEXT("ntcore2"),
                TEXT("liveraid")
            };

        for (i = 0; i < sizeof(pszDisabled)/sizeof(LPTSTR); i++)
        {
            if(      (0 == (lstrcmpi(pszDisabled[i], pszAddress)))
                ||  (wcsstr(_wcslwr(pszAddress), pszDisabled[i]) 
                        == pszAddress))
            {
                *pfDisabled = TRUE;
                return TRUE;
            }
        }
    }        

    

    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL) {
        *pfDisabled = FALSE;
        return FALSE;
    }
    *pfDisabled = pAddressMapEntry->fDisabled;

    return TRUE;
} // GetAddressDisabled



BOOLEAN
SetAddressDisabled(
    IN LPTSTR pszAddress,
    IN BOOLEAN fDisabled
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, TRUE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("SetAddressDisabled: GetAddressMapEntry failed");
        return FALSE;
    }
    pAddressMapEntry->fDisabled = fDisabled;

    return TRUE;
} // SetAddressDisabled

BOOLEAN
SetAddressDisabledEx(
    IN LPTSTR pszAddress,
    IN BOOLEAN fDisable
    )
{
    LONG l;
    IO_STATUS_BLOCK ioStatusBlock;
    ACD_ENABLE_ADDRESS *pEnableAddress;

    //
    // .NET bug# 514423 new verbose RASAUTO/RASAUTOU prefast warnings
    //
    if (!pszAddress)
    {
        return FALSE;
    }

    l = InterlockedIncrement(&g_lRasAutoRunning); 
    InterlockedDecrement(&g_lRasAutoRunning);

    if(l == 1)
    {
        //
        // rasauto isn't running. Bail.
        //
        return TRUE;
    }

    //
    // Also set this address as disabled in the driver
    //
    pEnableAddress = LocalAlloc(LPTR, sizeof(ACD_ENABLE_ADDRESS));
    if(NULL != pEnableAddress)
    {
        NTSTATUS status;
        CHAR *pszNew;
        DWORD cb;

        cb = WideCharToMultiByte(CP_ACP, 0, pszAddress, 
                            -1, NULL, 0, NULL, NULL);
                            
        pszNew = (CHAR*)LocalAlloc(LPTR, cb);
        if (pszNew == NULL) {
            return FALSE;
        }

        cb = WideCharToMultiByte(CP_ACP, 0, pszAddress, 
                            -1, pszNew, cb, NULL, NULL);
                            
        if (!cb) {
            LocalFree(pszNew);
            return FALSE;
        }

        _strlwr(pszNew);

        pEnableAddress->fDisable = fDisable;
        RtlCopyMemory(pEnableAddress->addr.szInet,
                      pszNew,
                      cb);
        
        status = NtDeviceIoControlFile(
                   hAcdG,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_ACD_ENABLE_ADDRESS,
                   pEnableAddress,
                   sizeof (ACD_ENABLE_ADDRESS),
                   NULL,
                   0);
        if (status != STATUS_SUCCESS) 
        {
            RASAUTO_TRACE("SetAddressDisabledEx: ioctl failed");
        }

        LocalFree(pEnableAddress);
    }
    
    return TRUE;
} // SetAddressDisabled



BOOLEAN
GetAddressDialingLocationEntry(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszEntryName
    )
{
    DWORD dwErr, dwLocationID;
    PLIST_ENTRY pEntry;
    PADDRESS_MAP_ENTRY pAddressMapEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    dwErr = TapiCurrentDialingLocation(&dwLocationID);
    if (dwErr)
        return FALSE;
    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL || IsListEmpty(&pAddressMapEntry->locationHead))
        return FALSE;
    //
    // Search for the dialing information
    // that maps to the current dialing
    // location.
    //
    for (pEntry = pAddressMapEntry->locationHead.Flink;
         pEntry != &pAddressMapEntry->locationHead;
         pEntry = pEntry->Flink)
    {
        pDialingEntry = CONTAINING_RECORD(
                             pEntry,
                             ADDRESS_DIALING_ENTRY,
                             ListEntry);

        if (pDialingEntry->location.dwLocation == dwLocationID) {
            *ppszEntryName = CopyString(pDialingEntry->location.pszEntryName);
            return TRUE;
        }
    }

    return FALSE;
} // GetAddressDialingLocationEntry



BOOLEAN
IsAWwwAddress(
    IN LPTSTR pszAddr
    )
{
    DWORD dwcbAddress;
    DWORD i;
    BOOLEAN fDot = FALSE, fIsAWwwAddress = FALSE;

    //
    // See if this address starts with "www*.".
    //
    if (!_wcsnicmp(pszAddr, L"www", 3)) {
        dwcbAddress = wcslen(pszAddr);
        //
        // Search for a '.' and something else
        // after the '.'.
        //
        for (i = 3; i < dwcbAddress; i++) {
            if (!fDot)
                fDot = (pszAddr[i] == L'.');
            fIsAWwwAddress = fDot && (pszAddr[i] != L'.');
            if (fIsAWwwAddress)
                break;
        }
    }

    return fIsAWwwAddress;
} // IsAWwwAddress



BOOLEAN
FindSimilarAddress(
    IN PVOID pArg,
    IN LPTSTR pszAddr,
    IN PVOID pData
    )

/*++

DESCRIPTION
    This is a table enumerator procedure that searches
    for address with a www-style name or the same
    organization name.  For example, it will consider
    "www1.netscape.com" and "www2.netscape.com" equal
    since they share the same organization and domain
    address components.

ARGUMENTS
    pArg: a pointer to a MATCH_INFO structure

    pszAddr: a pointer to the enumerated address

    ulData: the address's data value

RETURN VALUE
    TRUE if the enumeration should continue (match
    not found), or FALSE when the enumerations should
    terminate (match found).

--*/

{
    BOOLEAN fIsWww = FALSE, fHasOrg = FALSE;
    BOOLEAN fDialingLocationFound;
    PMATCH_INFO pMatchInfo = (PMATCH_INFO)pArg;
    PADDRESS_MAP_ENTRY pAddressMapEntry = (PADDRESS_MAP_ENTRY)pData;
    PLIST_ENTRY pEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;
    WCHAR szOrganization[ACD_ADDR_INET_LEN];

    if (pMatchInfo->fWww)
        fIsWww = IsAWwwAddress(pszAddr);
    else if (pMatchInfo->fOrg)
        fHasOrg = GetOrganization(pszAddr, szOrganization);
    //
    // If it has neither a www-style address nor
    // it has an organization, then return
    // immediately.
    //
    if ((pMatchInfo->fWww && !fIsWww) ||
        (pMatchInfo->fOrg && !fHasOrg))
    {
        return TRUE;
    }
    if (fIsWww)
        RASAUTO_TRACE1("FindSimilarAddress: fIsWww=1, %S", pszAddr);
    else {
        RASAUTO_TRACE2(
          "FindSimilarAddress: fHasOrg=1, comparing (%S, %S)",
          pMatchInfo->szOrganization,
          szOrganization);
    }
    //
    // If we're looking for an organization,
    // and the organization's don't match,
    // then return.
    //
    if (fHasOrg && _wcsicmp(pMatchInfo->szOrganization, szOrganization))
    {
        return TRUE;
    }
    //
    // Search for the dialing information
    // that maps to the current dialing
    // location.
    //
    fDialingLocationFound = FALSE;
    for (pEntry = pAddressMapEntry->locationHead.Flink;
         pEntry != &pAddressMapEntry->locationHead;
         pEntry = pEntry->Flink)
    {
        pDialingEntry = CONTAINING_RECORD(
                             pEntry,
                             ADDRESS_DIALING_ENTRY,
                             ListEntry);

        if (pDialingEntry->location.dwLocation == pMatchInfo->dwLocationID) {
            fDialingLocationFound = TRUE;
            break;
        }
    }
    if (!fDialingLocationFound) {
        RASAUTO_TRACE1("FindSimilarAddress: dialing location %d not found", pMatchInfo->dwLocationID);
        return TRUE;
    }
    //
    // If we already have found a match,
    // then make sure the network is the
    // same for all the matching addresses.
    // If not terminate the enumeration.
    //
    if (pMatchInfo->bFound &&
        pDialingEntry->location.pszEntryName != NULL &&
        pMatchInfo->pDialingEntry->location.pszEntryName != NULL &&
        _wcsicmp(
          pMatchInfo->pDialingEntry->location.pszEntryName,
          pDialingEntry->location.pszEntryName))
    {
        pMatchInfo->bFound = FALSE;
        RASAUTO_TRACE("FindSimilarAddress: returning FALSE");
        return FALSE;
    }
    //
    // Update the closure and continue
    // the enumeration.
    //
    if (!pMatchInfo->bFound) {
        pMatchInfo->bFound = TRUE;
        wcscpy(pMatchInfo->szAddress, pszAddr);
        pMatchInfo->pDialingEntry = pDialingEntry;
    }
    return TRUE;
} // FindSimilarAddress



BOOLEAN
GetSimilarDialingLocationEntry(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszEntryName
    )

/*++

DESCRIPTION
    Parse the organization name from the Internet
    address, and look for an address that we know
    about with the same organization name.  If we
    find it, make that address our target address.
    This enables us to treat addresses like
    "www1.netscape.com" and "www2.netscape.com"
    equivalently without having to have all
    combinations in our address map.

ARGUMENTS
    pszAddress: a pointer to the original address

    ppszEntryName: a pointer to the phonebook entry of
        a similar address

RETURN VALUE
    TRUE if there is a unique phonebook entry;
    FALSE otherwise.

--*/

{
    DWORD dwErr;
    MATCH_INFO matchInfo;
    BOOLEAN fIsAWwwAddress = FALSE;

    //
    // Check to see if this is "www*." style address.
    //
    matchInfo.fWww = IsAWwwAddress(pszAddress);
    //
    // Get the organization for the specified address.
    //
    if (!matchInfo.fWww)
        matchInfo.fOrg = GetOrganization(pszAddress, (LPTSTR)&matchInfo.szOrganization);
    else
        matchInfo.fOrg = FALSE;
    if (!matchInfo.fWww && !matchInfo.fOrg) {
        RASAUTO_TRACE1(
          "GetSimilarDialingLocationEntry: %S is not www and has no organization",
          pszAddress);
        return FALSE;
    }
    RASAUTO_TRACE4(
      "GetSimilarDialingLocationEntry: %S: fWww=%d, fOrg=%d, org is %S",
      pszAddress,
      matchInfo.fWww,
      matchInfo.fOrg,
      matchInfo.szOrganization);
    //
    // Search the table.
    //
    dwErr = TapiCurrentDialingLocation(&matchInfo.dwLocationID);
    if (dwErr) {
        RASAUTO_TRACE1(
          "GetSimilarDialingLocationEntry: TapiCurrentDialingLocation failed (dwErr=%d)",
          dwErr);
        return FALSE;
    }
    matchInfo.bFound = FALSE;
    RtlZeroMemory(&matchInfo.szAddress, sizeof (matchInfo.szAddress));
    matchInfo.pDialingEntry = NULL;
    EnumTable(AddressMapG.pTable, FindSimilarAddress, &matchInfo);
    //
    // If we didn't find it, then return.
    //
    if (!matchInfo.bFound) {
        RASAUTO_TRACE1(
          "GetSimilarDialingLocationEntry: %S: did not find matching org",
          pszAddress);
        return FALSE;
    }
    RASAUTO_TRACE2(
      "GetSimilarDialingLocationEntry: %S: matching address is %S",
      pszAddress,
      matchInfo.szAddress);
    //
    // Return the dialing location entry for
    // the matching address.
    //
    return GetAddressDialingLocationEntry(matchInfo.szAddress, ppszEntryName);
} // GetSimilarDialingLocationEntry



BOOLEAN
SetAddressLastFailedConnectTime(
    IN LPTSTR pszAddress
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, TRUE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("SetAddressLastFailedConnectTime: GetAddressMapEntry failed");
        return FALSE;
    }
    pAddressMapEntry->dwFailedConnectTicks = GetTickCount();

    return TRUE;
} // SetAddressLastFailedConnectTime



BOOLEAN
GetAddressLastFailedConnectTime(
    IN LPTSTR pszAddress,
    OUT LPDWORD lpdwTicks
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("GetAddressLastFailedConnectTime: GetAddressMapEntry failed");
        return FALSE;
    }
    *lpdwTicks = pAddressMapEntry->dwFailedConnectTicks;

    return (*lpdwTicks != 0);
} // GetAddressLastFailedConnectTime



BOOLEAN
SetAddressTag(
    IN LPTSTR pszAddress,
    IN DWORD dwTag
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;
    time_t clock = time(0);

    pAddressMapEntry = GetAddressMapEntry(pszAddress, TRUE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("SetAddressWeight: GetAddressMapEntry failed");
        return FALSE;
    }
    if (dwTag == ADDRMAP_TAG_LEARNED) {
        LockNetworkMap();
        dwTag =
          ADDRMAP_TAG_LEARNED +
            GetNetworkConnectionTag(
              pAddressMapEntry->pszNetwork,
              FALSE);
        if (dwTag < pAddressMapEntry->params.dwTag) {
            //
            // We want to use this tag.  Call
            // GetNetworkConnectionTag(TRUE) to
            // increment the next tag.
            //
            (void)GetNetworkConnectionTag(pAddressMapEntry->pszNetwork, TRUE);
        }
        UnlockNetworkMap();
    }
    //
    // If there is no modified time associated with this
    // address then it can only have a tag of ADDR_TAG_NONE.
    //
    if (!pAddressMapEntry->params.dwModifiedTime ||
        dwTag >= pAddressMapEntry->params.dwTag)
    {
        return TRUE;
    }

    pAddressMapEntry->params.dwTag = dwTag;
    pAddressMapEntry->params.dwModifiedTime = (DWORD)clock;
    pAddressMapEntry->ulModifiedMask |= ADDRESS_MAP_FIELD_PARAMS;

    return TRUE;
} // SetAddressTag



BOOLEAN
GetAddressTag(
    IN LPTSTR pszAddress,
    OUT LPDWORD lpdwTag
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("GetAddressWeight: GetAddressMapEntry failed");
        return FALSE;
    }
    *lpdwTag = pAddressMapEntry->params.dwTag;

    return TRUE;
} // GetAddressWeight



VOID
ResetLearnedAddressIndex()
{
    dwLearnedAddressIndexG = 0;
} // ResetLearnedAddressIndex



BOOLEAN
GetAddressNetwork(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszNetwork
    )
{
    PADDRESS_MAP_ENTRY pAddressMapEntry;

    pAddressMapEntry = GetAddressMapEntry(pszAddress, FALSE);
    if (pAddressMapEntry == NULL || pAddressMapEntry->pszNetwork == NULL)
        return FALSE;
    *ppszNetwork = CopyString(pAddressMapEntry->pszNetwork);

    return TRUE;
} // GetAddressNetwork



BOOLEAN
SetAddressDialingLocationEntry(
    IN LPTSTR pszAddress,
    IN LPTSTR pszEntryName
    )
{
    DWORD dwErr, dwLocationID;
    BOOLEAN fFound = FALSE;
    PLIST_ENTRY pEntry;
    PADDRESS_MAP_ENTRY pAddressMapEntry;
    PADDRESS_DIALING_ENTRY pDialingEntry;

    //
    // Get the current dialing location.
    //
    dwErr = TapiCurrentDialingLocation(&dwLocationID);
    if (dwErr)
        return FALSE;
    //
    // Find the address map entry that
    // corresponds to the address.
    //
    pAddressMapEntry = GetAddressMapEntry(pszAddress, TRUE);
    if (pAddressMapEntry == NULL) {
        RASAUTO_TRACE("SetAddressDialingLocationEntry: GetAddressMapEntry failed");
        return FALSE;
    }
    //
    // Search for the existing dialing
    // information that maps to the current
    // dialing location.
    //
    for (pEntry = pAddressMapEntry->locationHead.Flink;
         pEntry != &pAddressMapEntry->locationHead;
         pEntry = pEntry->Flink)
    {
        pDialingEntry = CONTAINING_RECORD(
                             pEntry,
                             ADDRESS_DIALING_ENTRY,
                             ListEntry);

        if (pDialingEntry->location.dwLocation == dwLocationID) {
            fFound = TRUE;
            break;
        }
    }
    //
    // If we didn't find one, then
    // create a new one.
    //
    if (!fFound) {
        pDialingEntry = LocalAlloc(LPTR, sizeof (ADDRESS_DIALING_ENTRY));
        if (pDialingEntry == NULL) {
            RASAUTO_TRACE("SetAddressDialingLocationEntry: LocalAlloc failed");
            return FALSE;
        }
        pDialingEntry->location.dwLocation = dwLocationID;
        InsertTailList(&pAddressMapEntry->locationHead, &pDialingEntry->ListEntry);
    }
    //
    // Update the dialing location structure
    // with the new values.
    //
    pDialingEntry->fChanged = TRUE;
    if (pDialingEntry->location.pszEntryName != NULL)
        LocalFree(pDialingEntry->location.pszEntryName);
    pDialingEntry->location.pszEntryName = CopyString(pszEntryName);
    pAddressMapEntry->ulModifiedMask |= ADDRESS_MAP_FIELD_DIALINGLOC;

    return TRUE;
} // SetAddressDialingLocationEntry



VOID
ResetDisabledAddresses(VOID)
{
    HKEY hkey = NULL;
    DWORD dwErr, i, dwi, dwLength, dwDisp, dwcbDisabledAddresses, dwType;
    LPTSTR pszStart, pszNull, pszDisabledAddresses;

    RASAUTO_TRACE("resetting disabled addresses");

    ClearTable(pDisabledAddressesG);

    //
    // Hold the impersonation lock because otherwise
    // hkeycug may be free from under this function.
    //
    
    LockImpersonation();

    //
    // Make sure that we have hkcu
    //
    dwErr = DwGetHkcu();

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }
        
    dwErr = RegCreateKeyEx(
              hkeyCUG,
              AUTODIAL_REGCONTROLBASE,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkey,
              &dwDisp);
    if (dwErr) {
        RASAUTO_TRACE1("ResetDisabledAddresses: RegCreateKey failed (dwErr=%d)", dwErr);
        goto done;
    }
    if (RegGetValue(
          hkey,
          AUTODIAL_REGDISABLEDADDRVALUE,
          &pszDisabledAddresses,
          &dwcbDisabledAddresses,
          &dwType) &&
          (REG_MULTI_SZ == dwType) &&
          dwcbDisabledAddresses)
    {
        //
        // The registry key exists.  Load only the addresses
        // found in the registry into the table.
        //
        pszStart = pszDisabledAddresses;
        for (;;) {
            if (*pszStart == TEXT('\0'))
                break;
            pszNull = _tcschr(pszStart, '\0');
            RASAUTO_TRACE1(
              "ResetDisabledAddresses: adding %S as a disabled address",
              pszStart);
            PutTableEntry(pDisabledAddressesG, pszStart, NULL);
            pszStart = pszNull + 1;
        }
        LocalFree(pszDisabledAddresses);
    }
    else {
        //
        // Initialize the disabled address table
        // with the list of default disabled addresses.
        //
        dwcbDisabledAddresses = 1; // account for extra NULL at the end
        for (i = 0; i < MAX_DISABLED_ADDRESSES; i++) {
            RASAUTO_TRACE1(
              "ResetDisabledAddresses: adding %S as a disabled address",
              szDisabledAddresses[i]);
            PutTableEntry(pDisabledAddressesG, szDisabledAddresses[i], NULL);
            dwcbDisabledAddresses += _tcslen(szDisabledAddresses[i]) + 1;
        }
        pszDisabledAddresses = LocalAlloc(
                                 LPTR,
                                 dwcbDisabledAddresses * sizeof (TCHAR));
        if (pszDisabledAddresses != NULL) {
            *pszDisabledAddresses = TEXT('\0');
            //
            // A REG_MULTI_SZ has the strings separated by
            // a NULL character and two NULL characters at
            // the end.
            //
            for (i = 0, dwi = 0; i < MAX_DISABLED_ADDRESSES; i++) {
                _tcscpy(&pszDisabledAddresses[dwi], szDisabledAddresses[i]);
                dwi += _tcslen(szDisabledAddresses[i]) + 1;
            }
            dwErr = RegSetValueEx(
                      hkey,
                      AUTODIAL_REGDISABLEDADDRVALUE,
                      0,
                      REG_MULTI_SZ,
                      (PVOID)pszDisabledAddresses,
                      dwcbDisabledAddresses * sizeof (TCHAR));
            if (dwErr)
                RASAUTO_TRACE1("ResetDisabledAddresses: RegSetValue failed (dwErr=%d)", dwErr);
            LocalFree(pszDisabledAddresses);
        }
    }

done:

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    
    UnlockImpersonation();
} // ResetDisabledAddresses

//
//  Handles a new user coming active in the system (either by logging in or by 
//  FUS.
//
DWORD
AcsHandleNewUser(
    IN HANDLE* phProcess)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hProcess = *phProcess;
    DWORD i;

    do
    {
        //
        // make sure that we think there is no user currently
        // active.
        //
        if (hProcess != NULL) 
        {
            RASAUTO_TRACE(
              "AcsHandleNewUser: spurious signal of RasAutodialNewLogonUser event!");
            break;
        }
        
        RASAUTO_TRACE("AcsHandleNewUser: new user came active");
        
        //
        // Refresh the impersonation token for this thread with that of the
        // newly logged-in user.  You may have to wait for the shell to 
        // start up.
        //
        for (i = 0; i < 15; i++) 
        {
            Sleep(1000);
            hProcess = RefreshImpersonation(hProcess);
            if (hProcess != NULL)
            {
                break;
            }            
            RASAUTO_TRACE("AcsHandleNewUser: waiting for shell startup");
        }
        
        if (hProcess == NULL) 
        {
            RASAUTO_TRACE("AcsHandleNewUser: wait for shell startup failed!");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        //
        // Load in the list of permanently disabled addresses.
        //
        LockDisabledAddresses();
        ResetDisabledAddresses();
        UnlockDisabledAddresses();
        
        //
        // Load in the address map from the registry.
        //
        if (!ResetAddressMap(TRUE)) 
        {
            RASAUTO_TRACE("AcsHandleNewUser: ResetAddressMap failed");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        //
        // Calculate the initial network connectivity.
        //
        if (!UpdateNetworkMap(TRUE)) 
        {
            RASAUTO_TRACE("AcsHandleNewUser: UpdateNetworkMap failed");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        //
        // Reset the "disable autodial for this login session" flag.
        //
        SetAutodialParam(RASADP_LoginSessionDisable, 0);
        
        //
        // Create an event to monitor AutoDial
        // registry changes.
        //
        dwErr = CreateAutoDialChangeEvent(&hAutodialRegChangeG);
        if (dwErr) 
        {
            RASAUTO_TRACE1("AcsHandleNewUser: CreateAutoDialChangeEvent failed (dwErr=%d)", dwErr);
            break;
        }
        
        //
        // Enable the driver for notifications.
        //
        if (!EnableDriver()) 
        {
            RASAUTO_TRACE("AcsHandleNewUser: EnableDriver failed!");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
    }while (FALSE);        

    // Cleanup
    {
        *phProcess = hProcess;
    }

    return dwErr;
}

DWORD
AcsAddressMapThread(
    LPVOID lpArg
    )

/*++

DESCRIPTION
    Periodically enumerate the disabled address list and
    age-out (enable) old disabled addresses.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    NTSTATUS status;
    BOOLEAN bStatus;
    DWORD dwNow, dwLastFlushTicks = 0, dwLastAgeTicks = 0;
    DWORD dwFlushFlags, dwErr, dwTimeout, dwcEvents;
    HANDLE hProcess = NULL;
    HANDLE hEvents[8];

    //
    // Create the table that contains the disabled addresses
    // for the user.  These are addresses that never cause
    // Autodial attempts.
    //
    LockDisabledAddresses();
    pDisabledAddressesG = NewTable();
    UnlockDisabledAddresses();
    if (pDisabledAddressesG == NULL) {
        RASAUTO_TRACE("AcsAddressMapThread: NewTable failed");
        return GetLastError();
    }
    //
    // We can't load the RAS DLLs in the main line
    // of this system service's initialization, or
    // we will cause a deadlock in the service
    // controller, so we do it here.
    //
    if (!LoadRasDlls()) {
        RASAUTO_TRACE("AcsAddressMapThread: LoadRasDlls failed");
        return GetLastError();
    }
    //
    // Initialize the first entry of our
    // event array for WaitForMutlipleObjects
    // below.
    //
    hEvents[0] = hTerminatingG;
    hEvents[1] = hNewLogonUserG;
    hEvents[2] = hNewFusG;
    hEvents[3] = hPnpEventG;
    hEvents[4] = hConnectionEventG;
    
    //
    // Manually set hNewLogonUserG before we
    // start to force us to check for a user
    // logged into the workstation.  We need
    // to do this because userinit.exe signals
    // this event upon logon, but it may
    // run before this service is started
    // after boot.
    //
    if (RefreshImpersonation(NULL) != NULL)
        SetEvent(hNewLogonUserG);
    //
    // Periodically write changes to the registry,
    // and age timeout addresses.
    //
    for (;;) {
        //
        // Unload any user-based resources before
        // a potentially long-term wait.
        //
        // PrepareForLongWait();
        //
        // Construct the event array for
        // WaitForMultipleObjects.
        //
        if (hProcess != NULL) {
            hEvents[5] = hTapiChangeG;
            hEvents[6] = hAutodialRegChangeG;
            hEvents[7] = hLogoffUserG;
            dwcEvents = 8;
        }
        else {
            hEvents[5] = NULL;
            hEvents[6] = NULL;
            hEvents[7] = NULL;
            dwcEvents = 5;
        }
        
        RASAUTO_TRACE1("AcsAddressMapThread: waiting for events..dwcEvents = %d", dwcEvents);
        status = WaitForMultipleObjects(
                   dwcEvents,
                   hEvents,
                   FALSE,
                   INFINITE);
        RASAUTO_TRACE1(
          "AcsAddressMapThread: WaitForMultipleObjects returned %d",
          status);
        //
        // RASAUTO_TRACE() who we think the currently
        // impersonated user is.
        //
        TraceCurrentUser();
        //
        // Process the WaitForMultipleObjects() results.
        //
        if (status == WAIT_OBJECT_0 || status == WAIT_FAILED) {
            RASAUTO_TRACE1("AcsAddressMapThread: status=%d: shutting down", status);
            break;
        }
        else if (status == WAIT_OBJECT_0 + 1) 
        {
            AcsHandleNewUser(&hProcess);
        }
        else if (status == WAIT_OBJECT_0 + 2)
        {
            // 
            // A new user has fast-user-switched to the console.
            //
            // XP 353082
            //
            // The service control handler will have set the 
            // new active session id so we just need to refresh
            // impersonation.
            //
            RevertImpersonation();
            hProcess = NULL;
            AcsHandleNewUser(&hProcess);
        }
        else if (status == WAIT_OBJECT_0 + 3) 
        {
            // 
            // A pnp event has occured that may affect network
            // connectivity
            //
            // XP 364593
            //
            // Recalculate what networks are up/down.
            //
            RASAUTO_TRACE("AcsAddressMapThread: pnp event signaled");
            if (!ResetAddressMap(TRUE)) 
            {
                RASAUTO_TRACE("AcsAddressMapThread: ResetAddressMap failed");
                continue;
            }
            
            //
            // Calculate the initial network connectivity.
            //
            if (!UpdateNetworkMap(TRUE)) 
            {
                RASAUTO_TRACE("AcsAddressMapThread: UpdateNetworkMap failed");
                continue;
            }

            if (!EnableDriver()) {
                RASAUTO_TRACE("AcsAddressMapThread: EnableDriver failed!");
                continue;
            }
        
        }
        else if (status == WAIT_OBJECT_0 + 4) {
            //
            // A RAS connection has been created
            // or destroyed.  Flush the address
            // map to the registry.
            //
            RASAUTO_TRACE("AcsAddressMapThread: RAS connection change");
            if (hProcess != NULL) {
                LockAddressMap();
                FlushAddressMap();
                UnlockAddressMap();
                ResetAddressMap(FALSE);

                if (!UpdateNetworkMap(FALSE))
                    RASAUTO_TRACE("AcsAddressMapThread: UpdateNetworkMap failed");
            }
        }
        else if (status == WAIT_OBJECT_0 + 5) {
            //
            // Process the TAPI event that just ocurred.
            //
            RASAUTO_TRACE("AcsAddressMapThread: TAPI changed");
            ProcessTapiChangeEvent();
            //
            // Enable the driver for notifications
            // for possibly a new dialing location.
            //
            if (!EnableDriver()) {
                RASAUTO_TRACE("AcsAddressMapThread: EnableDriver failed!");
                continue;
            }
        }
        else if (status == WAIT_OBJECT_0 + 6) {
            //
            // The Autodial registry changed.  Reset the
            // address map.
            //
            RASAUTO_TRACE("AcsAddressMapThread: registry changed");
            if (ExternalAutoDialChangeEvent()) {
                //
                // We fake this today by making it appear
                // a new user has logged in.  We definitely
                // could be smarter about how we do this
                // in the future.
                //
                if (!ResetAddressMap(FALSE)) {
                    RASAUTO_TRACE("AcsAddressMapThread: ResetAddressMap failed");
                    continue;
                }
            }
            //
            // Re-register the change notification.
            //
            NotifyAutoDialChangeEvent(hAutodialRegChangeG);
            //
            // Enable the driver for notifications
            // for possibly a new enabled value for
            // the current dialing location.
            //
            if (!EnableDriver()) {
                RASAUTO_TRACE("AcsAddressMapThread: EnableDriver failed!");
                continue;
            }
        }
        else if (status == WAIT_OBJECT_0 + 7) {
            //
            // The user is logging out.
            //
            RASAUTO_TRACE("AcsAddressThread: user is logging out");
            //
            // Write out the address map to the registry
            // before we reset.
            //
            LockAddressMap();
            FlushAddressMap();
            ClearAddressMap();
            UnlockAddressMap();
            //
            // Clear the network database.
            //
            LockNetworkMap();
            ClearNetworkMap();
            UnlockNetworkMap();
            //
            // Remove our registry change event.
            //
            CloseAutoDialChangeEvent(hAutodialRegChangeG);
            hAutodialRegChangeG = NULL;
            //
            // Clear out the user tokens.
            //
            RevertImpersonation();
            hProcess = NULL;
            //
            // Reset the driver.
            //
            ResetDriver();
            //
            // Unload HKEY_CURRENT_USER.
            //
            // PrepareForLongWait();
            //
            // Signal winlogon that we have flushed
            // HKEY_CURRENT_USER.
            //
            SetEvent(hLogoffUserDoneG);
        }
    }

    RASAUTO_TRACE("AcsAddressMapThread: exiting");
    return 0;
} // AcsAddressMapThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\addrmap.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    addrmap.h

ABSTRACT
    Header file for address attributes database shared
    between the automatic connection driver, the registry
    and the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 01-Sep-1995

REVISION HISTORY

--*/

//
// Flags for FlushAddressMap().
//
#define ADDRMAP_FLUSH_DRIVER        0x00000001
#define ADDRMAP_FLUSH_REGISTRY      0x00000002

//
// Address tag types.
//
#define ADDRMAP_TAG_NONE        0
#define ADDRMAP_TAG_USED        1
#define ADDRMAP_TAG_LEARNED     2


BOOLEAN
InitializeAddressMap();

VOID
UninitializeAddressMap();

BOOLEAN
ResetAddressMap();

VOID
LockAddressMap();

VOID
UnlockAddressMap();

VOID
LockDisabledAddresses();

VOID
UnlockDisabledAddresses();

BOOLEAN
FlushAddressMap();

VOID
ResetAddressMapAddress(
    IN LPTSTR pszAddress
    );

VOID
EnumAddressMap(
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    );

BOOLEAN
ListAddressMapAddresses(
    OUT LPTSTR **ppszAddresses,
    OUT PULONG pulcAddresses
    );

BOOLEAN
GetAddressDisabled(
    IN LPTSTR pszAddress,
    OUT PBOOLEAN pfDisabled
    );

BOOLEAN
SetAddressDisabled(
    IN LPTSTR pszAddress,
    IN BOOLEAN fDisabled
    );

BOOLEAN
GetAddressDialingLocationEntry(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszEntryName
    );

BOOLEAN
SetAddressDialingLocationEntry(
    IN LPTSTR pszAddress,
    IN LPTSTR pszEntryName
    );

BOOLEAN
GetSimilarDialingLocationEntry(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszEntryName
    );

BOOLEAN
SetAddressLastFailedConnectTime(
    IN LPTSTR pszAddress
    );

BOOLEAN
GetAddressLastFailedConnectTime(
    IN LPTSTR pszAddress,
    OUT LPDWORD dwTicks
    );

BOOLEAN
SetAddressTag(
    IN LPTSTR pszAddress,
    IN DWORD dwTag
    );

BOOLEAN
GetAddressTag(
    IN LPTSTR pszAddress,
    OUT LPDWORD lpdwTag
    );

VOID
ResetLearnedAddressIndex();

BOOLEAN
GetAddressNetwork(
    IN LPTSTR pszAddress,
    OUT LPTSTR *ppszNetwork
    );

BOOLEAN
DisableAutodial();

DWORD
AcsAddressMapThread(
    LPVOID lpArg
    );

VOID
ResetDisabledAddresses();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\connect.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    connect.c

ABSTRACT
    Connection routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 23-Feb-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <ras.h>
#include <rasman.h>
#include <raserror.h>
#include <rasuip.h>
#include <acd.h>
#include <debug.h>
#include <nouiutil.h>
#include <pbk.h>

#include "table.h"
#include "addrmap.h"
#include "netmap.h"
#include "rasprocs.h"
#include "reg.h"
#include "misc.h"
#include "imperson.h"
#include "init.h"
#include "process.h"

extern LONG g_lRasAutoRunning;

extern DWORD g_dwCritSecFlags;

//
// A request from the driver.
//
typedef struct _REQUEST_ENTRY {
    LIST_ENTRY listEntry;       // link to other requests
    ACD_NOTIFICATION notif;     // the driver request
} REQUEST_ENTRY, *PREQUEST_ENTRY;

//
// The list of requests from the driver.
//
typedef struct _REQUEST_LIST {
    CRITICAL_SECTION csLock;    // list lock
    HANDLE hEvent;              // non-empty transistion event
    LIST_ENTRY listHead;        // list head
} REQUEST_LIST, *PREQUEST_LIST;

//
// Arguments we pass to AcsCreateConnectionThread().
//
typedef struct _CREATION_ARGS {
    HANDLE hProcess;    // process handle to impersonate
    ACD_ADDR addr;      // original type/address from driver
    LPTSTR pszAddress;  // canonicalized address
    DWORD dwTimeout;    // RASADP_FailedConnectionTimeout
} CREATION_ARGS, *PCREATION_ARGS;

//
// Arguments we pass to AcsProcessLearnedAddressThread().
//
typedef struct _PROCESS_ADDR_ARGS {
    ACD_ADDR_TYPE fType;    // address type
    LPTSTR pszAddress;      // canonicalized address
    ACD_ADAPTER adapter;    // adapter structure
} PROCESS_ADDR_ARGS, *PPROCESS_ADDR_ARGS;

//
// Information we need to pass to ResetEntryName()
// to reset an invalid address map entry name.
//
typedef struct _RESET_ENTRY_INFO {
    LPTSTR pszOldEntryName;
    LPTSTR pszNewEntryName;
} RESET_ENTRY_INFO, *PRESET_ENTRY_INFO;

//
// Arguments we pass to AcsRedialOnLinkFailureThread().
//
typedef struct _REDIAL_ARGS {
    LPTSTR pszPhonebook;    // the phonebook
    LPTSTR pszEntry;        // the phonebook entry
} REDIAL_ARGS, *PREDIAL_ARGS;

//
// Global variables
//
HANDLE hAcdG;
REQUEST_LIST RequestListG;

//
// External variables
//
extern HANDLE hTerminatingG;
extern HANDLE hSharedConnectionG;
extern PHASH_TABLE pDisabledAddressesG;
extern FARPROC lpfnRasDialG;
extern FARPROC lpfnRasQuerySharedAutoDialG;
extern FARPROC lpfnRasQuerySharedConnectionG;
extern FARPROC lpfnRasQueryRedialOnLinkFailureG;
extern FARPROC lpfnRasGetCredentialsG;
extern FARPROC lpfnRasHangUpG;
extern FARPROC lpfnRasGetEntryPropertiesG;

//
// Forward declarations
//
BOOLEAN
CreateConnection(
    IN HANDLE hToken,
    IN PACD_ADDR pAddr,
    IN LPTSTR lpRemoteName,
    IN DWORD dwTimeout
    );

DWORD
AcsRedialOnLinkFailureThread(
    LPVOID lpArg
    );

VOID
AcsRedialOnLinkFailure(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry
    );

VOID
AcsDialSharedConnection(
    HANDLE *phProcess
    );

DWORD WINAPI
AcsDialSharedConnectionNoUser(
    PVOID Parameter
    );


DWORD
AcsRequestWorkerThread(
    LPVOID pArgs
    )
{
    HANDLE hProcess = NULL, hEvents[3];
    NTSTATUS status;
    PLIST_ENTRY pEntry;
    PREQUEST_ENTRY pRequest = NULL;
    LPTSTR pszAddress = NULL;
    IO_STATUS_BLOCK ioStatusBlock;

    hEvents[0] = hTerminatingG;
    hEvents[1] = RequestListG.hEvent;
    hEvents[2] = hSharedConnectionG;
    for (;;) {
        //
        // Unload any user-based resources before
        // a potentially long-term wait.
        //
        // PrepareForLongWait();
        //
        // Wait for something to do.
        //
        RASAUTO_TRACE("AcsRequestWorkerThread: waiting...");
        status = WaitForMultipleObjects(3, hEvents, FALSE, INFINITE);
        if (status == WAIT_OBJECT_0 || status == WAIT_FAILED) {
            RASAUTO_TRACE1("AcsRequestWorkerThread: status=%d: shutting down", status);
            break;
        }
        if (status == WAIT_OBJECT_0 + 2) {
            //
            // Check to see if connections are disabled
            // for this dialing location.
            //
            BOOL fEnabled;
            if ((*lpfnRasQuerySharedAutoDialG)(&fEnabled) || !fEnabled) {
                RASAUTO_TRACE("AcsRequestWorkerThread: shared-autodial disabled!");
                continue;
            }
            //
            // Dial the shared connection
            //
            if ((hProcess = RefreshImpersonation(hProcess)) == NULL) {
                RASAUTO_TRACE("AcsRequestWorkerThread: no currently logged-on user!");
                QueueUserWorkItem(AcsDialSharedConnectionNoUser, NULL, 0);
                continue;
            }
            AcsDialSharedConnection(&hProcess);
            continue;
        }
        //
        // RASAUTO_TRACE() who we think the current user is.
        //
        TraceCurrentUser();
        //
        // Process all requests in the list.
        //
        for (;;) {
            //
            // Make sure we aren't shutting down
            // before processing the next request.
            //
            if (WaitForSingleObject(hTerminatingG, 0) != WAIT_TIMEOUT) {
                RASAUTO_TRACE("AcsRequestWorkerThread: shutting down");
                return 0;
            }
            //
            // Get the next request.
            //
            EnterCriticalSection(&RequestListG.csLock);
            if (IsListEmpty(&RequestListG.listHead)) {
                LeaveCriticalSection(&RequestListG.csLock);
                break;
            }
            pEntry = RemoveHeadList(&RequestListG.listHead);
            LeaveCriticalSection(&RequestListG.csLock);
            pRequest = CONTAINING_RECORD(pEntry, REQUEST_ENTRY, listEntry);
            //
            // Make sure the current thread is impersonating
            // the currently logged-on user.
            //
            if ((hProcess = RefreshImpersonation(hProcess)) == NULL) {
                RASAUTO_TRACE("AcsRequestWorkerThread: no currently logged-on user!");
                goto done;
            }
            //
            // Handle the request.
            //
            pszAddress = AddressToUnicodeString(&pRequest->notif.addr);
            if (pszAddress == NULL) {
                RASAUTO_TRACE("AcsRequestWorkerThread: AddressToUnicodeString failed");
                goto done;
            }
            RASAUTO_TRACE2(
              "AcsRequestWorkerThread: pszAddress=%S, ulFlags=0x%x",
              pszAddress,
              pRequest->notif.ulFlags);
            if (pRequest->notif.ulFlags & ACD_NOTIFICATION_SUCCESS) {
                //
                // Process a learned address.
                //
                ProcessLearnedAddress(
                  pRequest->notif.addr.fType,
                  pszAddress,
                  &pRequest->notif.adapter);
            }
            else {
                ACD_STATUS connStatus;
                DWORD dwTimeout;

                //
                // Get the connection timeout value.
                //
                dwTimeout = GetAutodialParam(RASADP_FailedConnectionTimeout);
                //
                // Create the new connection.
                //
                connStatus.fSuccess = CreateConnection(
                                        hProcess,
                                        &pRequest->notif.addr,
                                        pszAddress,
                                        dwTimeout);
                RASAUTO_TRACE1(
                  "AcsRequestWorkerThread: CreateConnection returned %d",
                  connStatus.fSuccess);
                //
                // Complete the connection by issuing
                // the completion ioctl to the driver.
                //
                RtlCopyMemory(
                  &connStatus.addr,
                  &pRequest->notif.addr,
                  sizeof (ACD_ADDR));
                status = NtDeviceIoControlFile(
                           hAcdG,
                           NULL,
                           NULL,
                           NULL,
                           &ioStatusBlock,
                           IOCTL_ACD_COMPLETION,
                           &connStatus,
                           sizeof (connStatus),
                           NULL,
                           0);
                if (status != STATUS_SUCCESS) {
                    RASAUTO_TRACE1(
                      "AcsRequestWorkerThread: NtDeviceIoControlFile(IOCTL_ACD_COMPLETION) failed (status=0x%x)",
                      status);
                }
            }
done:
            if (pszAddress != NULL) {
                LocalFree(pszAddress);
                pszAddress = NULL;
            }
            if (pRequest != NULL) {
                LocalFree(pRequest);
                pRequest = NULL;
            }
        }
    }

    return 0;
} // AcsRequestWorkerThread

BOOL
fProcessDisabled(HANDLE hPid)
{
    PSYSTEM_PROCESS_INFORMATION pProcessInfo;
    ULONG ulTotalOffset = 0;
    PUCHAR pLargeBuffer = NULL;
    BOOL fProcessDisabled = FALSE;
    
    pProcessInfo = GetSystemProcessInfo();

    if(NULL == pProcessInfo)
    {
        goto done;
    }

    pLargeBuffer  = (PUCHAR)pProcessInfo;

    //
    // Look in the process list for svchost.exe and services.exe
    //
    for (;;) 
    {
        if (    (pProcessInfo->ImageName.Buffer != NULL)
            &&  (hPid == pProcessInfo->UniqueProcessId))
        {
            if(     (0 == _wcsicmp(
                        pProcessInfo->ImageName.Buffer,
                        L"svchost.exe"))
                ||  (0 == _wcsicmp(
                        pProcessInfo->ImageName.Buffer,
                        L"services.exe"))
                ||  (0 == _wcsicmp(
                        pProcessInfo->ImageName.Buffer, 
                        L"llssrv.exe")))
            {
                fProcessDisabled = TRUE;
            }

            break;
        }

        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
        {
            break;
        }
        
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }
    

done:

    if(NULL != pLargeBuffer)
    {
        FreeSystemProcessInfo((PSYSTEM_PROCESS_INFORMATION)pLargeBuffer);
    }

    return fProcessDisabled;
}





VOID
AcsDoService()
{
    HANDLE hProcess = NULL, hNotif, hObjects[2];
    HANDLE hWorkerThread;
    PWCHAR pszAddr;
    LONG cbAddr;
    NTSTATUS status;
    BOOLEAN fDisabled, fStatus, fEnabled;
    BOOLEAN fAsynchronousRequest;
    IO_STATUS_BLOCK ioStatusBlock;
    PREQUEST_ENTRY pRequest;
    ACD_NOTIFICATION connInfo;
    DWORD dwErr, dwThreadId, dwfDisableLoginSession;
    ULONG ulAttributes;

    {
        LONG l;
        l = InterlockedIncrement(&g_lRasAutoRunning);

        // DbgPrint("RASAUTO: AcsDoService: lrasautorunning=%d\n",
        //        l);
    }
    
    //
    // Initialize the request list.
    //
    RasInitializeCriticalSection(&RequestListG.csLock, &dwErr);

    if(dwErr != ERROR_SUCCESS)
    {
        return;
    }

    g_dwCritSecFlags |= RASAUTO_CRITSEC_REQUESTLIST;
    
    RequestListG.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (RequestListG.hEvent == NULL) {
        RASAUTO_TRACE1(
          "AcsDoService: CreateEvent failed (error=0x%x)",
          GetLastError());
        DeleteCriticalSection(&RequestListG.csLock);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_REQUESTLIST);
        return;
    }
    InitializeListHead(&RequestListG.listHead);
    //
    // Start the asynchronous request worker
    // thread.
    //
    hWorkerThread = CreateThread(
                      NULL,
                      10000L,
                      (LPTHREAD_START_ROUTINE)AcsRequestWorkerThread,
                      NULL,
                      0,
                      &dwThreadId);
    if (hWorkerThread == NULL) {
        RASAUTO_TRACE1(
          "AcsDoService: CreateThread failed (error=0x%x)",
          GetLastError());
        //
        // .NET bug# 514423 new verbose RASAUTO/RASAUTOU prefast warnings
        //
        CloseHandle(RequestListG.hEvent);
        RequestListG.hEvent = NULL;
        DeleteCriticalSection(&RequestListG.csLock);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_REQUESTLIST);
        return;
    }
    //
    // Create an event to wait for
    // the ioctl completion.
    //
    hNotif = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hNotif == NULL) {
        RASAUTO_TRACE1(
          "AcsDoService: CreateEvent failed (error=0x%x)",
          GetLastError());
        //
        // .NET bug# 514423 new verbose RASAUTO/RASAUTOU prefast warnings
        //
        CloseHandle(hWorkerThread);
        CloseHandle(RequestListG.hEvent);
        RequestListG.hEvent = NULL;
        DeleteCriticalSection(&RequestListG.csLock);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_REQUESTLIST);
        return;
    }
    //
    // Initialize the array of events
    // we need to wait for with WaitForMultipleObjects()
    // below.
    //
    hObjects[0] = hNotif;
    hObjects[1] = hTerminatingG;
    for (;;) {
        //
        // Unload any user-based resources before
        // a potentially long-term wait.
        //
        // PrepareForLongWait();
        //
        // Initialize the connection information.
        //
        pszAddr = NULL;
        RtlZeroMemory(&connInfo, sizeof (connInfo));
        //
        // Wait for a connection notification.
        //
        status = NtDeviceIoControlFile(
                   hAcdG,
                   hNotif,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_ACD_NOTIFICATION,
                   NULL,
                   0,
                   &connInfo,
                   sizeof (connInfo));
        if (status == STATUS_PENDING) {
            RASAUTO_TRACE("AcsDoService: waiting for notification");
            status = WaitForMultipleObjects(2, hObjects, FALSE, INFINITE);
            RASAUTO_TRACE1(
              "AcsDoService: WaitForMultipleObjects returned 0x%x",
              status);
            if (status == WAIT_OBJECT_0 + 1)
                break;
            status = ioStatusBlock.Status;
        }
        if (status != STATUS_SUCCESS) {
            RASAUTO_TRACE1(
              "AcsDoService: NtDeviceIoControlFile(IOCTL_ACD_NOTIFICATION) failed (status=0x%x)",
              status);
            //
            // .NET bug# 514423 new verbose RASAUTO/RASAUTOU prefast warnings
            //
            CloseHandle(hNotif);
            CloseHandle(hWorkerThread);
            CloseHandle(RequestListG.hEvent);
            RequestListG.hEvent = NULL;
            DeleteCriticalSection(&RequestListG.csLock);
            g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_REQUESTLIST);
            return;
        }
        //
        // Initialize the flag that notes whether
        // the request is added to the list of
        // asynchronous requests.
        //
        fAsynchronousRequest = FALSE;
        //
        // RASAUTO_TRACE() who we think the currently
        // impersonated user is.
        //
        TraceCurrentUser();
        //
        // Convert the address structure to a Unicode string.
        //
        pszAddr = AddressToUnicodeString(&connInfo.addr);
        if (pszAddr == NULL) {
            RASAUTO_TRACE("AcsDoService: AddressToUnicodeString failed");
            continue;
        }
        //
        // If we get a bogus address from
        // the driver, ignore it.
        //
        if (!wcslen(pszAddr)) {
            RASAUTO_TRACE("AcsDoService: ignoring null address");
            LocalFree(pszAddr);
            continue;
        }
        RASAUTO_TRACE2(
          "AcsDoService: got notification: address: %S, ulFlags=0x%x",
          pszAddr,
          connInfo.ulFlags);
        //
        // Make sure the current thread is impersonating
        // the currently logged-on user.  We need this
        // so the RAS utilities run with the user's credentials.
        //
        if ((hProcess = RefreshImpersonation(hProcess)) == NULL) {
            RASAUTO_TRACE("AcsDoService: no currently logged-on user!");
            goto done;
        }
        //
        // Check to see if this address is in the list
        // of disabled addresses.
        //
        LockDisabledAddresses();
        if (GetTableEntry(pDisabledAddressesG, pszAddr, NULL)) {
            RASAUTO_TRACE1("AcsDoService: %S: is disabled", pszAddr);
            UnlockDisabledAddresses();
            goto done;
        }
        UnlockDisabledAddresses();
        
        //
        // Check to see if connections are disabled
        // for this login session.
        //
        dwfDisableLoginSession = GetAutodialParam(RASADP_LoginSessionDisable);
        if (dwfDisableLoginSession) {
            RASAUTO_TRACE("AcsDoService: connections disabled for this login session");
            goto done;
        }
        //
        // Check to see if connections are disabled
        // for this dialing location.
        //
        dwErr = AutoDialEnabled(&fEnabled);
        if (!dwErr && !fEnabled) {
            RASAUTO_TRACE("AcsDoService: connections disabled for this dialing location");
            goto done;
        }
        //
        // If the address we're trying to connect
        // to is on the disabled list, then fail
        // this connection attempt.
        //
        LockAddressMap();
        GetAddressDisabled(pszAddr, &fDisabled);
        UnlockAddressMap();
        if (fDisabled) {
            RASAUTO_TRACE1("AcsDoService: %S: address disabled", RASAUTO_TRACESTRW(pszAddr));
            goto done;
        }

        RASAUTO_TRACE1("AcsDoService: notif.ulFlags=0x%x", connInfo.ulFlags);

        //
        // If autodial is disabled for this pid, don't start autodial and bail
        //
        if(     (0 == (connInfo.ulFlags & ACD_NOTIFICATION_SUCCESS))
            &&  fProcessDisabled(connInfo.Pid))
        {
            RASAUTO_TRACE1("AcsDoService: Autodial is disabled for process 0x%lx",
                    connInfo.Pid);

            goto done;                    
        }
        else
        {
            RASAUTO_TRACE1("AcsDoService: process 0x%lx is not disabled",
                    connInfo.Pid);
        }
        
        //
        // We need to process this request
        // asynchronously.  Create and initialize
        // a request entry.
        //
        pRequest = LocalAlloc(LPTR, sizeof (REQUEST_ENTRY));
        if (pRequest == NULL) {
            RASAUTO_TRACE("AcsDoService: LocalAlloc failed");
            goto done;
        }
        RtlCopyMemory(&pRequest->notif, &connInfo, sizeof (ACD_NOTIFICATION));
        //
        // Add this request to the list of
        // requests to be processed asynchronously.
        //
        EnterCriticalSection(&RequestListG.csLock);
        InsertTailList(&RequestListG.listHead, &pRequest->listEntry);
        SetEvent(RequestListG.hEvent);
        LeaveCriticalSection(&RequestListG.csLock);
        fAsynchronousRequest = TRUE;

done:
        if (pszAddr != NULL)
            LocalFree(pszAddr);
        //
        // If we aren't going to process this request
        // asynchronously, then we need to signal the
        // (unsuccessful) completion of the connection
        // attempt.  Only signal completion of
        // non-ACD_NOTIFICATION_SUCCESS requests.
        //
        if (!fAsynchronousRequest) {
            if (!(connInfo.ulFlags & ACD_NOTIFICATION_SUCCESS)) {
                ACD_STATUS connStatus;

                connStatus.fSuccess = FALSE;
                RtlCopyMemory(&connStatus.addr, &connInfo.addr, sizeof (ACD_ADDR));
                status = NtDeviceIoControlFile(
                           hAcdG,
                           NULL,
                           NULL,
                           NULL,
                           &ioStatusBlock,
                           IOCTL_ACD_COMPLETION,
                           &connStatus,
                           sizeof (connStatus),
                           NULL,
                           0);
                if (status != STATUS_SUCCESS) {
                    RASAUTO_TRACE1(
                      "AcsDoService: NtDeviceIoControlFile(IOCTL_ACD_COMPLETION) failed (status=0x%x)",
                      status);
                }
            }
        }
    }
    //
    // Clean up the worker thread.
    //
    RASAUTO_TRACE("AcsDoService: signaling worker thread to shutdown");
    WaitForSingleObject(hWorkerThread, INFINITE);
    if(RequestListG.hEvent != NULL)
    {
        CloseHandle(RequestListG.hEvent);
        RequestListG.hEvent = NULL;
    }
    
    DeleteCriticalSection(&RequestListG.csLock);
    g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_REQUESTLIST);
    CloseHandle(hWorkerThread);
    RASAUTO_TRACE("AcsDoService: worker thread shutdown done");
    //
    // Clean up all resources associated
    // with the service.
    //
    CloseHandle(hNotif);
    AcsCleanup();
    RASAUTO_TRACE("AcsDoService: exiting");
} // AcsDoService


VOID
AcsDialSharedConnection(
    HANDLE *phProcess
    )

/*++

DESCRIPTION
    Looks for a shared connection and initiates a connection for it.

ARGUMENTS
    phProcess: pointer to the handle to the process token that we inherit the
        security attributes from when we exec the dialer

RETURN VALUE
    none

--*/

{
    DWORD dwErr;
    BOOLEAN fEntryInvalid;
    BOOLEAN fRasLoaded;
    RASSHARECONN rsc;
    TCHAR* pszEntryName;
    TCHAR szEntryName[RAS_MaxEntryName + 1];
    RASAUTO_TRACE("AcsDialSharedConnection");
    //
    // Load RAS entrypoints
    //
    fRasLoaded = LoadRasDlls();
    if (!fRasLoaded) {
        RASAUTO_TRACE("AcsDialSharedConnection: Could not load RAS DLLs.");
        return;
    }
    //
    // A guest isn't able to dial a RAS connection, so if we're currently
    // impersonating a guest we need to perform a no-user autodial
    //
    if (ImpersonatingGuest()) {
        QueueUserWorkItem(AcsDialSharedConnectionNoUser, NULL, 0);
        return;
    }
    //
    // Get the shared connection, if any. We can't do this in an impersonated
    // context, as the user we're impersonating may not have sufficient access
    // to retrieve the current shared connection.
    //
    RevertImpersonation();
    *phProcess = NULL;
    dwErr = (DWORD)(*lpfnRasQuerySharedConnectionG)(&rsc);
    if ((*phProcess = RefreshImpersonation(NULL)) == NULL) {
        RASAUTO_TRACE("AcsDialSharedConnection: unable to refresh impersonation!");
        if (NO_ERROR == dwErr && !rsc.fIsLanConnection) {
            //
            // Attempt to do no-user autodial
            //
            QueueUserWorkItem(AcsDialSharedConnectionNoUser, NULL, 0);
            return;
        }
    }
    if (dwErr) {
        RASAUTO_TRACE1("AcsDialSharedConnection: RasQuerySharedConnection=%d", dwErr);
        return;
    } else if (rsc.fIsLanConnection) {
        RASAUTO_TRACE("AcsDialSharedConnection: shared connection is LAN adapter");
        return;
    }
#ifdef UNICODE
    pszEntryName = rsc.name.szEntryName;
#else
    //
    // Convert to ANSI
    //
    pszEntryName = szEntryName;
    wcstombs(pszEntryName, rsc.name.szEntryName, RAS_MaxEntryName);
#endif
    //
    // Initiate a dial-attempt
    //
    StartAutoDialer(
        *phProcess,
        NULL,
        pszEntryName,
        pszEntryName,
        TRUE,
        &fEntryInvalid);
}


DWORD WINAPI
AcsDialSharedConnectionNoUser(
    PVOID Parameter
    )

/*++

DESCRIPTION
    Looks for a shared connection and initiates a connection for it
    using RasDial and the cached credentials for the connection.

ARGUMENTS
    none

RETURN VALUE
    none

--*/

{
    DWORD dwErr;
    BOOLEAN fRasLoaded;
    HRASCONN hrasconn;
    RASCREDENTIALSW rc;
    RASDIALEXTENSIONS rde;
    RASDIALPARAMSW rdp;
    RASSHARECONN rsc;
    RASAUTO_TRACE("AcsDialSharedConnectionNoUser");
    //
    // Load RAS entrypoints
    //
    fRasLoaded = LoadRasDlls();
    if (!fRasLoaded) {
        RASAUTO_TRACE("AcsDialSharedConnectionNoUser: Could not load RAS DLLs.");
        return NO_ERROR;
    }
    //
    // Get the shared connection, if any
    //
    dwErr = (DWORD)(*lpfnRasQuerySharedConnectionG)(&rsc);
    if (dwErr) {
        RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: RasQuerySharedConnection=%d",
            dwErr);
        return NO_ERROR;
    } else if (rsc.fIsLanConnection) {
        RASAUTO_TRACE("AcsDialSharedConnectionNoUser: shared connection is LAN");
        return NO_ERROR;
    }
    //
    // Retrieve the credentials for the shared connection.
    //
    rc.dwSize = sizeof(rc);
    rc.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain | RASCM_DefaultCreds;
    dwErr = (DWORD)(*lpfnRasGetCredentialsG)(
                rsc.name.szPhonebookPath, rsc.name.szEntryName, &rc
                );
    if (dwErr) {
        RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: "
            "RasGetCredentials=%d", dwErr);
        return NO_ERROR;
    }
    //
    // Prepare to initiate the connection, setting up the dial-extensions
    // and the dial-parameters.
    //
    ZeroMemory(&rde, sizeof(rde));
    rde.dwSize = sizeof(rde);
    rde.dwfOptions = RDEOPT_NoUser;

    ZeroMemory(&rdp, sizeof(rdp));
    rdp.dwSize = sizeof(rdp);
    lstrcpyW(rdp.szEntryName, rsc.name.szEntryName);
    lstrcpyW(rdp.szUserName, rc.szUserName);
    lstrcpyW(rdp.szDomain, rc.szDomain);
    lstrcpyW(rdp.szPassword, rc.szPassword);
    //
    // Clear the credentials from memory, and dial the connection.
    //
    RASAUTO_TRACE("AcsDialSharedConnectionNoUser: RasDial");
    hrasconn = NULL;
    ZeroMemory(&rc, sizeof(rc));
    dwErr = (DWORD)(*lpfnRasDialG)(
                &rde, rsc.name.szPhonebookPath, &rdp, 0, NULL, &hrasconn
                );
    ZeroMemory(&rdp, sizeof(rdp));
    RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: RasDial=%d", dwErr);

    if (E_NOTIMPL == dwErr)
    {
        //
        // This is possibly a Connection Manager connection since it's returning E_NOTIMPL,
        // we should check the phonebook entry for the type and then call the RasDialDlg 
        // with the RASDDFLAG_NoPrompt flag.
        // 
        RASDIALDLG info;
        BOOL fRetVal = FALSE;
        HINSTANCE hRasDlgDll = NULL;
        RASENTRY re;
        DWORD dwRasEntrySize;
        DWORD dwIgnore;
        typedef BOOL (*lpfnRasDialDlgFunc)(LPWSTR, LPWSTR, LPWSTR, LPRASDIALDLG);

        ZeroMemory(&info, sizeof(info));
        info.dwSize = sizeof(info);

        ZeroMemory(&re, sizeof(re));
        dwRasEntrySize = sizeof(re);
        re.dwSize = dwRasEntrySize;

        dwErr = (DWORD)(*lpfnRasGetEntryPropertiesG)(
                          rsc.name.szPhonebookPath,
                          rsc.name.szEntryName,
                          &re,
                          &dwRasEntrySize,
                          NULL,
                          &dwIgnore);

        if (ERROR_SUCCESS == dwErr)
        {
            dwErr = ERROR_NOT_SUPPORTED;
            //
            // Check if this is a Connection Manager entry
            //
            if (RASET_Internet == re.dwType)
            {
                //
                // Prevent the DialerDialog
                //
                info.dwFlags |= RASDDFLAG_NoPrompt;

                hRasDlgDll = LoadLibrary(L"RASDLG.DLL");
                if (hRasDlgDll)
                {
                    lpfnRasDialDlgFunc lpfnRasDialDlg = (lpfnRasDialDlgFunc)GetProcAddress(hRasDlgDll, "RasDialDlgW");

                    if (lpfnRasDialDlg)
                    {
                        fRetVal = (BOOL)(lpfnRasDialDlg)(rsc.name.szPhonebookPath, rsc.name.szEntryName, NULL, &info );
                        RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: lpfnRasDialDlg returns %d", (DWORD)fRetVal);
                        if (fRetVal)
                        {
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                    else
                    {
                        RASAUTO_TRACE("AcsDialSharedConnectionNoUser: Failed to get procaddress for RasDialDlgW");

                    }
                    FreeLibrary(hRasDlgDll);
                    hRasDlgDll = NULL;
                }
                else
                {
                    RASAUTO_TRACE("AcsDialSharedConnectionNoUser: Failed to load RASDLG.dll");
                }
            }
            else
            {   
                RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: Wrong type. RASENTRY.dwType=%d", re.dwType);
            }   
        }
        else
        {
            RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: lpfnRasGetEntryPropertiesG=%d", dwErr);
        }
    }

    //
    // If RasDial returned an error and passed back a valid connection
    // handle we need to call RasHangUp on that handle.
    //
    if (ERROR_SUCCESS != dwErr && NULL != hrasconn) {
        dwErr = (DWORD)(*lpfnRasHangUpG)(hrasconn);
        RASAUTO_TRACE1("AcsDialSharedConnectionNoUser: RasHangUp=%d", dwErr);
    }
    return NO_ERROR;
}


BOOLEAN
ResetEntryName(
    IN PVOID pArg,
    IN LPTSTR pszAddress,
    IN PVOID pData
    )

/*++

DESCRIPTION
    A table enumerator procedure to reset all
    address map entries referencing an old RAS
    phonebook entry to a new one.

ARGUMENTS
    pArg: a pointer to a RESET_ENTRY_INFO structure

    pszAddress: a pointer to the address string

    pData: ignored

RETURN VALUE
    Always TRUE to continue the enumeration.

--*/

{
    PRESET_ENTRY_INFO pResetEntryInfo = (PRESET_ENTRY_INFO)pArg;
    LPTSTR pszEntryName;

    if (GetAddressDialingLocationEntry(pszAddress, &pszEntryName)) {
        if (!_wcsicmp(pszEntryName, pResetEntryInfo->pszOldEntryName)) {
            if (!SetAddressDialingLocationEntry(
                   pszAddress,
                   pResetEntryInfo->pszNewEntryName))
            {
                RASAUTO_TRACE("ResetEntryName: SetAddressEntryName failed");
            }
        }
        LocalFree(pszEntryName);
    }

    return TRUE;
} // ResetEntryName

BOOL
fRequestToSelf(LPTSTR lpRemoteName)
{
    BOOL fRet = FALSE;

    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize;

    RASAUTO_TRACE1("fRequestToSelf. lpRemoteName=%S", lpRemoteName);

    dwSize = MAX_COMPUTERNAME_LENGTH;        
    
    if(GetComputerName(szComputerName, &dwSize))
    {
        if(0 == lstrcmpi(lpRemoteName, szComputerName))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}


BOOLEAN
CreateConnection(
    IN HANDLE hProcess,
    IN PACD_ADDR pAddr,
    IN LPTSTR lpRemoteName,
    IN DWORD dwTimeout
    )

/*++

DESCRIPTION
    Take a notification and figure out what to do with it.

ARGUMENTS
    hToken: the handle to the process token that we inherit the
        security attributes from when we exec the dialer

    pAddr: a pointer to the original address from the driver

    lpRemoteName: a pointer to the address of the connection attempt

    dwTimeout: number of seconds to disable the address between
        failed connections

RETURN VALUE
    Returns TRUE if the net attempt should be retried, FALSE otherwise.

--*/

{
    DWORD dwStatus = WN_SUCCESS;
    RASENTRYNAME entry;
    DWORD dwErr, dwSize, dwEntries;
    DWORD dwPreConnections, dwPostConnections, i;
    DWORD dwTicks;
    BOOLEAN fRasLoaded;
    BOOLEAN fMappingExists, fRasConnectSuccess = FALSE;
    BOOLEAN fStatus, fEntryInvalid;
    BOOLEAN fFailedConnection = FALSE;
    LPTSTR lpEntryName = NULL;
    LPTSTR *lpPreActiveEntries = NULL, *lpPostActiveEntries = NULL;
    LPTSTR lpNewConnection, lpNetworkName = NULL;
    BOOL   fDefault = FALSE;

    RASAUTO_TRACE1("CreateConnection: lpRemoteName=%S", RASAUTO_TRACESTRW(lpRemoteName));
    //
    // Load the RAS DLLs.
    //
    fRasLoaded = LoadRasDlls();
    if (!fRasLoaded) {
        RASAUTO_TRACE("CreateConnection: Could not load RAS DLLs.");
        goto done;
    }

    //
    // Check to see if the request is for the same machine. Bail if so.
    // we don't want autodial to kick in if the connection request is
    // to the same machine.
    //
    if(fRequestToSelf(lpRemoteName))
    {
        RASAUTO_TRACE("CreateConnetion: Request to self. Bailing.");
        goto done;
    }
    
    //
    // Get a list of the active RAS connections before
    // we attempt to create a new one.
    //
    dwPreConnections = ActiveConnections(TRUE, &lpPreActiveEntries, NULL);
    RASAUTO_TRACE1("CreateConnection: dwPreConnections=%d", dwPreConnections);
    //
    // If we reach this point, we have an unsuccessful
    // network connection without any active RAS
    // connections.  Try to start the implicit connection
    // machinery.  See if there already exists a mapping
    // for the address.
    //
    LockAddressMap();
    //
    // Make sure we have the current information
    // about this address from the registry.
    //
    ResetAddressMapAddress(lpRemoteName);
    fMappingExists = GetAddressDialingLocationEntry(lpRemoteName, &lpEntryName);
    //
    // If the entry doesn't exist, and this is a
    // Internet hostname, then see if we can find
    // an address with the same organization name.
    //
    if (!fMappingExists && pAddr->fType == ACD_ADDR_INET)
        fMappingExists = GetSimilarDialingLocationEntry(lpRemoteName, &lpEntryName);
    fFailedConnection = GetAddressLastFailedConnectTime(
                          lpRemoteName,
                          &dwTicks);
    UnlockAddressMap();
    RASAUTO_TRACE2(
      "CreateConnection: lookup of %S returned %S",
      RASAUTO_TRACESTRW(lpRemoteName),
      RASAUTO_TRACESTRW(lpEntryName));
    //
    // If we know nothing about the address, and
    // we are connected to some network, then ignore
    // the request.
    //
    if (!fMappingExists && IsNetworkConnected()) {
        RASAUTO_TRACE1(
          "CreateConnection: no mapping for lpRemoteName=%S and connected to a network",
          lpRemoteName);
        goto done;
    }

    //
    // If no mapping exists and not connected to network, 
    // check to see if theres a default internet connection.
    //
    if(!fMappingExists && !IsNetworkConnected())
    {
        
        RASAUTO_TRACE1(
            "CreateConnection: no mapping for lpRemoteName=%S and"
            " not connected to a network", lpRemoteName);

        dwErr = DwGetDefaultEntryName(&lpEntryName);

        RASAUTO_TRACE1(
            "CreateConnection: found default entry %S",
             (NULL == lpEntryName)?TEXT("NULL"):lpEntryName);

        if(NULL != lpEntryName)
        {
            fMappingExists = TRUE;
            fDefault = TRUE;
        }
    }
    
    //
    // If there is a mapping, but the phonebook
    // entry is missing from the mapping, then
    // ignore the request.  Also check to make
    // sure the phonebook entry isn't already
    // connected.
    //
    //
    // Perform various checks on the mapping.
    //
    if (fMappingExists) {
        BOOLEAN bStatus, bConnected = FALSE;

        //
        // Make sure it's not NULL.
        //
        if (!wcslen(lpEntryName)) {
            RASAUTO_TRACE1(
              "CreateConnection: lpRemoteName=%S is permanently disabled",
              RASAUTO_TRACESTRW(lpRemoteName));
            goto done;
        }
        //
        // If the network associated with this
        // entry is connected, then ignore the
        // request.
        //
        lpNetworkName = EntryToNetwork(lpEntryName);
        RASAUTO_TRACE2(
          "CreateConnection: network for entry %S is %S",
          lpEntryName,
          RASAUTO_TRACESTRW(lpNetworkName));
        if (lpNetworkName != NULL) {
            LockNetworkMap();
            bStatus = GetNetworkConnected(lpNetworkName, &bConnected);
            UnlockNetworkMap();
            if (bStatus && bConnected) {
                RASAUTO_TRACE1(
                  "CreateConnection: %S is already connected!",
                  RASAUTO_TRACESTRW(lpEntryName));
                fRasConnectSuccess = TRUE;
                goto done;
            }
        }
        //
        // If the entry itself is connected,
        // then ignore the request.  We need
        // to do this check as well as the one
        // above, because the mapping may not
        // have a network assigned to it yet.
        //
        for (i = 0; i < dwPreConnections; i++) {
            if (!_wcsicmp(lpEntryName, lpPreActiveEntries[i])) {
                RASAUTO_TRACE1(
                  "CreateConnection: lpEntryName=%S is already connected!", lpEntryName);
                goto done;
            }
        }
    }
    //
    // Check for a recent failed connection
    // attempt.
    //
    if (fFailedConnection) {
        RASAUTO_TRACE1(
          "CreateConnection: RASADP_FailedConnectionTimeout=%d",
          dwTimeout);
        if (GetTickCount() - dwTicks < dwTimeout * 1000) {
            RASAUTO_TRACE2(
              "CreateConnection: lpRemoteName=%S is temporarily disabled (failed connection %d ticks ago)",
              RASAUTO_TRACESTRW(lpRemoteName),
              GetTickCount() - dwTicks);
            goto done;
        }
        else {
            //
            // Reset last failed tick count.
            //
            fFailedConnection = FALSE;
        }
    }
    //
    // If a mapping already exists for the address, then
    // start rasphone with the address.  Otherwise, simply
    // have rasphone show the entire phonebook.
    //
    fEntryInvalid = FALSE;
    fRasConnectSuccess = StartAutoDialer(
                           hProcess,
                           pAddr,
                           lpRemoteName,
                           fMappingExists ? lpEntryName : NULL,
                           FALSE,
                           &fEntryInvalid);
    RASAUTO_TRACE1(
      "CreateConnection: StartDialer returned %d",
      fRasConnectSuccess);
    if (fRasConnectSuccess) {
        //
        // Get the list of active connections again.  We will
        // compare the lists to determine which is the new
        // entry.
        //
        dwPostConnections = ActiveConnections(
                              TRUE,
                              &lpPostActiveEntries,
                              NULL);
        //
        // If the number of active connections before and after
        // the newly created connection differs by more than 1,
        // then we have to skip saving the mapping in the registry,
        // since we cannot determine which is the right one!
        //
        if (dwPostConnections - dwPreConnections == 1) {
            lpNewConnection = CompareConnectionLists(
                                lpPreActiveEntries,
                                dwPreConnections,
                                lpPostActiveEntries,
                                dwPostConnections);
            RASAUTO_TRACE2(
              "CreateConnection: mapped %S->%S",
              RASAUTO_TRACESTRW(lpRemoteName),
              RASAUTO_TRACESTRW(lpNewConnection));
            LockAddressMap();
            if (!fEntryInvalid) {
                //
                // Store the new RAS phonebook entry, since
                // it could be different from the one we
                // retrieved in the mapping.
                //
// #ifdef notdef
                if(!fDefault)
                {
                    //
                    // We do not want to do this because the
                    // user may have selected the wrong phonebook
                    // entry.  We will let a successful connection
                    // notification map it for us.
                    //
                    fStatus = SetAddressDialingLocationEntry(lpRemoteName, lpNewConnection);
// #endif
                    fStatus = SetAddressTag(lpRemoteName, ADDRMAP_TAG_USED);
                }
            }
            else {
                RESET_ENTRY_INFO resetEntryInfo;

                //
                // If the RAS phonebook entry in the mapping
                // was invalid, then automatically
                // remap all other mappings referencing that
                // entry to the newly selected phonebook entry.
                //
                resetEntryInfo.pszOldEntryName = lpEntryName;
                resetEntryInfo.pszNewEntryName = lpNewConnection;
                EnumAddressMap(ResetEntryName, &resetEntryInfo);
            }
            //
            // Flush this mapping to the registry now
            // and reload the address info.  We do this to
            // get the network name for a new address/network
            // pair.
            //
            FlushAddressMap();
            ResetAddressMapAddress(lpRemoteName);
            if (lpNetworkName == NULL &&
                GetAddressNetwork(lpRemoteName, &lpNetworkName))
            {
                LockNetworkMap();
                SetNetworkConnected(lpNetworkName, TRUE);
                UnlockNetworkMap();
            }
            UnlockAddressMap();
            if (!fStatus)
                RASAUTO_TRACE("CreateConnection: SetAddressEntryName failed");
        }
        else {
            RASAUTO_TRACE1(
              "CreateConnection: %d (> 1) new RAS connections! (can't write registry)",
              dwPostConnections - dwPreConnections);
        }
    }

done:
#ifdef notdef
// we only unload rasman.dll if we are going to exit
    if (fRasLoaded)
        UnloadRasDlls();
#endif
    if (!fFailedConnection && !fRasConnectSuccess) {
        //
        // If the connection attempt wasn't successful,
        // then we disable future connections to that
        // address for a while.
        //
        RASAUTO_TRACE1("CreateConnection: disabling %S", RASAUTO_TRACESTRW(lpRemoteName));
        LockAddressMap();
        fStatus = SetAddressLastFailedConnectTime(lpRemoteName);
        UnlockAddressMap();
        if (!fStatus)
            RASAUTO_TRACE("CreateConnection: SetAddressAttribute failed");
    }
    //
    // Free resources.
    //
    if (lpEntryName != NULL)
        LocalFree(lpEntryName);
    if (lpNetworkName != NULL)
        LocalFree(lpNetworkName);
    if (lpPreActiveEntries != NULL)
        FreeStringArray(lpPreActiveEntries, dwPreConnections);
    if (lpPostActiveEntries != NULL)
        FreeStringArray(lpPostActiveEntries, dwPostConnections);

    return fRasConnectSuccess;
} // CreateConnection



DWORD
AcsRedialOnLinkFailureThread(
    LPVOID lpArg
    )
{
    DWORD dwErr;
    PREDIAL_ARGS pRedial = (PREDIAL_ARGS)lpArg;
    HANDLE hProcess = NULL;

    RASAUTO_TRACE2(
      "AcsRedialOnLinkFailureThread: lpszPhonebook=%s, lpszEntry=%s",
      RASAUTO_TRACESTRW(pRedial->pszPhonebook),
      RASAUTO_TRACESTRW(pRedial->pszEntry));

    //
    // Make sure the current thread is impersonating
    // the currently logged-on user.  We need this
    // so the RAS utilities run with the user's credentials.
    //
    if ((hProcess = RefreshImpersonation(hProcess)) == NULL) {
        RASAUTO_TRACE("AcsRedialOnLinkFailureThread: no currently logged-on user!");
        return 0;
    }
    //
    // Reset HKEY_CURRENT_USER to get the
    // correct value with the new impersonation
    // token.
    //
    // RegCloseKey(HKEY_CURRENT_USER);

    /* Check that user has enabled redial on link failure.
    */
    {
        BOOL   fRedial  = FALSE;

        dwErr = (DWORD)(lpfnRasQueryRedialOnLinkFailureG)(
                                                  pRedial->pszPhonebook,
                                                  pRedial->pszEntry,
                                                  &fRedial);

        if(!fRedial)
        {
            PBUSER user;

            dwErr = GetUserPreferences( NULL, &user, FALSE );
            if (dwErr == 0)
            {
                fRedial = user.fRedialOnLinkFailure;
                DestroyUserPreferences( &user );
            }
        }

        if (!fRedial)
        {
            RASAUTO_TRACE1("Skip redial,e=%d",dwErr);
            return 0;
        }
    }

    //
    // Redial the entry.
    //
    dwErr = StartReDialer(hProcess, pRedial->pszPhonebook, pRedial->pszEntry);
    //
    // Free the parameter block we were passed.
    //
    if (pRedial->pszPhonebook != NULL)
        LocalFree(pRedial->pszPhonebook);
    if (pRedial->pszEntry != NULL)
        LocalFree(pRedial->pszEntry);
    LocalFree(pRedial);

    return dwErr;
} // AcsRedialOnLinkFailureThread



VOID
AcsRedialOnLinkFailure(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry
    )

/*++

DESCRIPTION
    This is the redial-on-link-failure handler we give to rasman
    via RasRegisterRedialCallback.  It gets called when the final
    port of a connection is disconnected due to a hardware failure.
    We package up the parameters rasman gives us an create a thread
    because the callback is made within rasman's worker thread
    context.

ARGUMENTS
    lpszPhonebook: the phonebook string of the connection

    lpszEntry: the entry name of the connection

RETURN VALUE
    None.

--*/

{
    PREDIAL_ARGS lpRedial = LocalAlloc(LPTR, sizeof (REDIAL_ARGS));
    HANDLE hThread;
    DWORD dwThreadId;

    if (lpRedial == NULL)
        return;
    lpRedial->pszPhonebook = AnsiStringToUnicodeString(
                              lpszPhonebook,
                              NULL,
                              0);
    if (lpszPhonebook != NULL && lpRedial->pszPhonebook == NULL) {
        RASAUTO_TRACE("AcsRedialOnLinkFailure: LocalAlloc failed");
        LocalFree(lpRedial);
        return;
    }
    lpRedial->pszEntry = AnsiStringToUnicodeString(
                          lpszEntry,
                          NULL,
                          0);
    if (lpszEntry != NULL && lpRedial->pszEntry == NULL) {
        RASAUTO_TRACE("AcsRedialOnLinkFailure: LocalAlloc failed");
        LocalFree(lpRedial->pszPhonebook);
        LocalFree(lpRedial);
        return;
    }
    //
    // Start the connection.
    //
    hThread = CreateThread(
                NULL,
                10000L,
                (LPTHREAD_START_ROUTINE)AcsRedialOnLinkFailureThread,
                (LPVOID)lpRedial,
                0,
                &dwThreadId);
    if (hThread == NULL) {
        RASAUTO_TRACE1(
          "AcsRedialOnLinkFailure: CreateThread failed (error=0x%x)",
          GetLastError());
        LocalFree(lpRedial->pszEntry);
        LocalFree(lpRedial->pszPhonebook);
        LocalFree(lpRedial);
        return;
    }
    CloseHandle(hThread);
} // AcsRedialOnLinkFailure
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\imperson.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    impersn.c

ABSTRACT
    Impersonation routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 04-Aug-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <acd.h>
#include <debug.h>

#include "reg.h"
#include "misc.h"
#include "process.h"
#include "imperson.h"
#include "mprlog.h"
#include "rtutils.h"
#include "rasman.h"

extern HANDLE g_hLogEvent;

extern DWORD g_dwCritSecFlags;

DWORD
LoadGroupMemberships();

//
// The static information we
// need to impersonate the currently
// logged-in user.
//
IMPERSONATION_INFO ImpersonationInfoG;

//
// TRUE if ImpersonationInfoG has been initialized
//

BOOLEAN ImpersonationInfoInitializedG = FALSE;

//
// Security attributes and descriptor
// necessary for creating shareable handles.
//
SECURITY_ATTRIBUTES SecurityAttributeG;
SECURITY_DESCRIPTOR SecurityDescriptorG;

HKEY hkeyCUG = NULL;

#ifdef notdef

BOOLEAN
InteractiveSession()

/*++

DESCRIPTION
    Determine whether the active process is owned by the
    currently logged-in user.

ARGUMENTS
    None.

RETURNS
    TRUE if it is, FALSE if it isn't.

--*/

{
    HANDLE      hToken;
    BOOLEAN     bStatus;
    ULONG       ulInfoLength;
    PTOKEN_GROUPS pTokenGroupList;
    PTOKEN_USER   pTokenUser;
    ULONG       ulGroupIndex;
    BOOLEAN     bFoundInteractive = FALSE;
    PSID        InteractiveSid;
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    static BOOLEAN fIsInteractiveSession = 0xffff;

#if 0
    //
    // Return the previous value of this function
    // if we're called multiple times?!  Doesn't
    // GetCurrentProcess() return different values?
    //
    if (fIsInteractiveSession != 0xffff) {
        return fIsInteractiveSession;
    }
#endif

    bStatus = AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_INTERACTIVE_RID,
                0, 0, 0, 0, 0, 0, 0,
                &InteractiveSid);
    if (!bStatus) {
        RASAUTO_TRACE("InteractiveSession: AllocateAndInitializeSid failed");
        return (fIsInteractiveSession = FALSE);
    }
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        RASAUTO_TRACE("InteractiveSession: OpenProcessToken failed");
        FreeSid(InteractiveSid);
        return (fIsInteractiveSession = FALSE);
    }
    //
    // Get a list of groups in the token.
    //
    GetTokenInformation(
      hToken,
      TokenGroups,
      NULL,
      0,
      &ulInfoLength);
    pTokenGroupList = (PTOKEN_GROUPS)LocalAlloc(LPTR, ulInfoLength);
    if (pTokenGroupList == NULL) {
        RASAUTO_TRACE("InteractiveSession: LocalAlloc failed");
        FreeSid(InteractiveSid);
        return (fIsInteractiveSession = FALSE);
    }
    bStatus = GetTokenInformation(
                hToken,
                TokenGroups,
                pTokenGroupList,
                ulInfoLength,
                &ulInfoLength);
    if (!bStatus) {
        RASAUTO_TRACE("InteractiveSession: GetTokenInformation failed");
        FreeSid(InteractiveSid);
        LocalFree(pTokenGroupList);
        return (fIsInteractiveSession = FALSE);
    }
    //
    // Search group list for admin alias.  If we
    // find a match, it most certainly is an
    // interactive process.
    //
    bFoundInteractive = FALSE;
    for (ulGroupIndex=0; ulGroupIndex < pTokenGroupList->GroupCount;
         ulGroupIndex++)
    {
        if (EqualSid(
              pTokenGroupList->Groups[ulGroupIndex].Sid,
              InteractiveSid))
        {
            bFoundInteractive = TRUE;
            break;
        }
    }

    if (!bFoundInteractive) {
        //
        // If we haven't found a match,
        // query and check the user ID.
        //
        GetTokenInformation(
          hToken,
          TokenUser,
          NULL,
          0,
          &ulInfoLength);
        pTokenUser = LocalAlloc(LPTR, ulInfoLength);
        if (pTokenUser == NULL) {
            RASAUTO_TRACE("InteractiveSession: LocalAlloc failed");
            FreeSid(InteractiveSid);
            LocalFree(pTokenGroupList);
            return (fIsInteractiveSession = FALSE);
        }
        bStatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    pTokenUser,
                    ulInfoLength,
                    &ulInfoLength);
        if (!bStatus) {
            RASAUTO_TRACE("InteractiveSession: GetTokenInformation failed");
            FreeSid(InteractiveSid);
            LocalFree(pTokenGroupList);
            LocalFree(pTokenUser);
            return (fIsInteractiveSession = FALSE);
        }
        if (EqualSid(pTokenUser->User.Sid, InteractiveSid))
            fIsInteractiveSession = TRUE;
        LocalFree(pTokenUser);
    }
    FreeSid(InteractiveSid);
    LocalFree(pTokenGroupList);

    return (fIsInteractiveSession = bFoundInteractive);
}
#endif



BOOLEAN
SetProcessImpersonationToken(
    HANDLE hProcess
    )
{
    NTSTATUS status;
    HANDLE hThread, 
           hToken = NULL;


    //
    // Open the impersonation token for the
    // process we want to impersonate.
    //
    if (ImpersonationInfoG.hTokenImpersonation == NULL) 
    {
        if (!OpenProcessToken(
              hProcess,
              TOKEN_ALL_ACCESS,
              &hToken))
        {
            RASAUTO_TRACE1(
              "SetProcessImpersonationToken: OpenProcessToken failed (dwErr=%d)",
              GetLastError());
              
            return FALSE;
        }
        
        //
        // Duplicate the impersonation token.
        //
        if(!DuplicateToken(
                        hToken,
                        TokenImpersonation,
                        &ImpersonationInfoG.hTokenImpersonation))
        {
            RASAUTO_TRACE1(
              "SetProcessImpersonationToken: NtSetInformationThread failed (error=%d)",
              GetLastError());
              
            return FALSE;
        }
    }
    
    //
    // Set the impersonation token on the current
    // thread.  We are now running in the same
    // security context as the supplied process.
    //
    hThread = NtCurrentThread();
    status = NtSetInformationThread(
               hThread,
               ThreadImpersonationToken,
               (PVOID)&ImpersonationInfoG.hTokenImpersonation,
               sizeof (ImpersonationInfoG.hTokenImpersonation));
               
    if (status != STATUS_SUCCESS) 
    {
        RASAUTO_TRACE1(
          "SetProcessImpersonationToken: NtSetInformationThread failed (error=%d)",
          GetLastError());
    }
    
    if(NULL != hToken)
    {
        CloseHandle(hToken);
    }

    return (status == STATUS_SUCCESS);
} // SetProcessImpersonationToken



VOID
ClearImpersonationToken()
{
    //
    // Clear the impersonation token on the current
    // thread.  We are now running in LocalSystem
    // security context.
    //
    if (!SetThreadToken(NULL, NULL)) {
        DWORD retcode = GetLastError();
        
        RASAUTO_TRACE1(
          "ClearImpersonationToken: SetThreadToken failed (error=%d)",
          retcode);

        //
        // Event log that thread failed to revert.
        //
        RouterLogWarning(
            g_hLogEvent,
            ROUTERLOG_CANNOT_REVERT_IMPERSONATION,
            0, NULL, retcode) ;
    }
} // ClearImpersonationToken



BOOLEAN
SetPrivilege(
    HANDLE hToken,
    LPCTSTR Privilege,
    BOOLEAN fEnable
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);

    if (!LookupPrivilegeValue(NULL, Privilege, &luid))
        return FALSE;

    //
    // First pass.  Get current privilege setting.
    //
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
      hToken,
      FALSE,
      &tp,
      sizeof(TOKEN_PRIVILEGES),
      &tpPrevious,
      &cbPrevious);

    if (GetLastError() != ERROR_SUCCESS)
        return FALSE;

    //
    // Second pass.  Set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount = 1;
    tpPrevious.Privileges[0].Luid = luid;

    if (fEnable)
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
      hToken,
      FALSE,
      &tpPrevious,
      cbPrevious,
      NULL,
      NULL);

    if (GetLastError() != ERROR_SUCCESS)
        return FALSE;

    return TRUE;
} // SetPrivilege



BOOLEAN
GetCurrentlyLoggedOnUser(
    HANDLE *phProcess
    )
{
    BOOLEAN fSuccess = FALSE;
    HKEY hkey;
    DWORD dwErr, dwType;
    DWORD dwDisp;
    WCHAR *pszShell = NULL, **pszShellArray = NULL;
    PSYSTEM_PROCESS_INFORMATION pSystemInfo, pProcessInfo;
    PWCHAR psz, pszStart;
    DWORD i, dwSize, dwcCommands;
    NTSTATUS status;
    HANDLE hProcess = NULL;
    DWORD dwPid = 0;

    //
    // Get the shell process name.  We will look for this
    // to find out who the currently logged-on user is.
    // Create a unicode string that describes this name.
    //
    if (RegCreateKeyEx(
          HKEY_LOCAL_MACHINE,
          SHELL_REGKEY,
          0,
          NULL,
          REG_OPTION_NON_VOLATILE,
          KEY_ALL_ACCESS,
          NULL,
          &hkey,
          &dwDisp) == ERROR_SUCCESS)
    {
        dwSize = 0;
        if (RegQueryValueEx(
              hkey,
              SHELL_REGVAL,
              NULL,
              &dwType,
              NULL,
              &dwSize) == ERROR_SUCCESS)
        {
            pszShell = (PWCHAR)LocalAlloc(LPTR, dwSize + sizeof (WCHAR));
            if (pszShell == NULL) {
                RegCloseKey(hkey);
                return FALSE;
            }
            dwErr = RegQueryValueEx(
                      hkey,
                      SHELL_REGVAL,
                      NULL,
                      &dwType,
                      (LPBYTE)pszShell,
                      &dwSize);
            RegCloseKey(hkey);
            if (dwErr != ERROR_SUCCESS || dwType != REG_SZ) {
                LocalFree(pszShell);
                pszShell = NULL;
            }
        }
    }
    //
    // If no shell was found, use DEFAULT_SHELL.
    //
    if (pszShell == NULL) {
        pszShell = (PWCHAR)LocalAlloc(
                      LPTR, 
                      (lstrlen(DEFAULT_SHELL) + 1) * sizeof (WCHAR));
        if (pszShell == NULL)
            return FALSE;
        lstrcpy(pszShell, DEFAULT_SHELL);
    }
    RASAUTO_TRACE1("ImpersonateCurrentlyLoggedInUser: pszShell is %S", pszShell);
    //
    // This string can be a comma separated list,
    // so we need to parse it into a list of commands.
    //
    dwcCommands = 1;
    for (psz = pszShell; *psz != L'\0'; psz++) {
        if (*psz == L',')
            dwcCommands++;
    }
    //
    // Allocate the list of string pointers.
    //
    pszShellArray = LocalAlloc(LPTR, sizeof (PWCHAR) * dwcCommands);
    if (pszShellArray == NULL) {
        LocalFree(pszShell);
        return FALSE;
    }
    //
    // Ignore any arguments from the command line.
    //
    dwcCommands = 0;
    psz = pszShell;
    pszStart = NULL;
    for (;;) {
        if (*psz == L'\0') {
            if (pszStart != NULL)
                pszShellArray[dwcCommands++] = pszStart;
            break;
        }
        else if (*psz == L',') {
            if (pszStart != NULL)
                pszShellArray[dwcCommands++] = pszStart;
            *psz = L'\0';
            pszStart = NULL;
        }
        else if (*psz == L' ') {
            if (pszStart != NULL)
                *psz = L'\0';
        }
        else {
            if (pszStart == NULL)
                pszStart = psz;
        }
        psz++;
    }
    for (i = 0; i < dwcCommands; i++) {
        RASAUTO_TRACE2(
          "ImpersonateCurrentlyLoggedInUser: pszShellArray[%d] is %S",
          i,
          pszShellArray[i]);
    }
    //
    // Get the process list.
    //
    pSystemInfo = GetSystemProcessInfo();

    if(NULL == pSystemInfo)
    {
        LocalFree(pszShell);
        LocalFree(pszShellArray);
        return FALSE;
    }

    while(TRUE)
    {
        //
        // See if any of the processes are running.
        //
        pProcessInfo = 
            FindProcessByNameList(
                pSystemInfo, 
                pszShellArray, 
                dwcCommands, 
                dwPid,
                ImpersonationInfoG.fSessionInitialized,
                ImpersonationInfoG.dwCurSessionId);
        //
        // Open the process token if we've found a match.
        //
        if (pProcessInfo != NULL) 
        {
            HANDLE hToken;

            //
            // Open the process.
            //
            hProcess = OpenProcess(
                         PROCESS_ALL_ACCESS,
                         FALSE,
                         PtrToUlong(pProcessInfo->UniqueProcessId));
            if (hProcess == NULL) 
            {
                RASAUTO_TRACE2(
                  "ImpersonateCurrentlyLoggedInUser: OpenProcess(%d) failed (dwErr=%d)",
                  PtrToUlong(pProcessInfo->UniqueProcessId),
                  GetLastError());

                  dwPid = PtrToUlong(pProcessInfo->UniqueProcessId);
            }
            else
            {
            
                fSuccess = TRUE;
                break;
            }
        }
        else
        {
            break;
        }
    }

#ifdef notdef
done:
#endif
    //
    // Free resources.
    //
    FreeSystemProcessInfo(pSystemInfo);
    if (pszShell != NULL)
        LocalFree(pszShell);
    if (pszShellArray != NULL)
        LocalFree(pszShellArray);
    //
    // Return process handle.
    //
    *phProcess = hProcess;

    return fSuccess;
} // GetCurrentlyLoggedOnUser

DWORD
SetCurrentLoginSession(
    IN DWORD dwSessionId)
{
    RASAUTO_TRACE1("SetCurrentLoginSession %d", dwSessionId);

    EnterCriticalSection(&ImpersonationInfoG.csLock);
    
    ImpersonationInfoG.dwCurSessionId = dwSessionId;
    ImpersonationInfoG.fSessionInitialized = TRUE;

    LeaveCriticalSection(&ImpersonationInfoG.csLock);
    
    return NO_ERROR;
}

HANDLE
RefreshImpersonation(
    HANDLE hProcess
    )
{
    NTSTATUS status;

    EnterCriticalSection(&ImpersonationInfoG.csLock);
    //
    // If the process still exists,
    // we can return.
    //
    if (ImpersonationInfoG.hProcess != NULL &&
        hProcess == ImpersonationInfoG.hProcess)
    {
        RASAUTO_TRACE1("RefreshImpersonation: hProcess=0x%x no change", hProcess);
        goto done;
    }
    //
    // Otherwise recalcuate the current information.
    // We have to clear the previous impersonation token,
    // if any.
    //
    if (hProcess != NULL)
        ClearImpersonationToken();
    if (ImpersonationInfoG.hProcess == NULL) {
        RASAUTO_TRACE("RefreshImpersonation: recalcuating token");
        if (!GetCurrentlyLoggedOnUser(&ImpersonationInfoG.hProcess)) {
            RASAUTO_TRACE("RefreshImpersonation: GetCurrentlyLoggedOnUser failed");
            goto done;
        }
        RASAUTO_TRACE("RefreshImpersonation: new user logged in");
    }
    //
    // Impersonate the currently logged-in user.
    //
    if (!SetProcessImpersonationToken(ImpersonationInfoG.hProcess))
    {
        RASAUTO_TRACE(
          "RefreshImpersonation: SetProcessImpersonationToken failed");
        goto done;
    }
#ifdef notdef // imperson
    //
    // Reset HKEY_CURRENT_USER to get the
    // correct value with the new impersonation
    // token.
    //
    RegCloseKey(HKEY_CURRENT_USER);
#endif
    RASAUTO_TRACE1(
      "RefreshImpersonation: new hProcess=0x%x",
      ImpersonationInfoG.hProcess);
    TraceCurrentUser();

    //
    // Open the currently logged on users hive and store it in a global
    //
    if(NULL != hkeyCUG)
    {
        NtClose(hkeyCUG);
        hkeyCUG = NULL;
    }

    if(STATUS_SUCCESS != RtlOpenCurrentUser(KEY_ALL_ACCESS, &hkeyCUG))
    {
        RASAUTO_TRACE("Failed to open HKCU for the current user");
    }    

done:
    LeaveCriticalSection(&ImpersonationInfoG.csLock);

    return ImpersonationInfoG.hProcess;
} // RefreshImpersonation



VOID
RevertImpersonation()

/*++

DESCRIPTION
    Close all open handles associated with the
    logged-in user who has just logged out.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    EnterCriticalSection(&ImpersonationInfoG.csLock);

    if(ImpersonationInfoG.hToken != NULL)
    {
        CloseHandle(ImpersonationInfoG.hToken);
        ImpersonationInfoG.hToken = NULL;
    }

    if(ImpersonationInfoG.hTokenImpersonation != NULL)
    {
        CloseHandle(ImpersonationInfoG.hTokenImpersonation);
        ImpersonationInfoG.hTokenImpersonation = NULL;
    }

    if(ImpersonationInfoG.hProcess != NULL)
    {
        CloseHandle(ImpersonationInfoG.hProcess);
        ImpersonationInfoG.hProcess = NULL;
    }
    
    ImpersonationInfoG.fGroupsLoaded = FALSE;

    if(NULL != hkeyCUG)
    {
        NtClose(hkeyCUG);
        hkeyCUG = NULL;
    }
    
    //
    // Clear the thread's impersonation
    // token, or it won't be able to open
    // another user's process the next
    // time around.
    //
    ClearImpersonationToken();
    LeaveCriticalSection(&ImpersonationInfoG.csLock);
} // RevertImpersonation



DWORD
InitSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

DESCRIPTION
    Initialize a security descriptor allowing administrator
    access for the sharing of handles between rasman.dll.

    This code courtesy of Gurdeep.  You need to ask him
    exactly what it does.

ARGUMENTS
    pSecurityDescriptor: a pointer to the security descriptor
        to be initialized.

RETURN VALUE
    Win32 error code.

--*/

{
    DWORD dwErr = 0;
    DWORD cbDaclSize;
    PULONG pSubAuthority;
    PSID pObjSid = NULL;
    PACL pDacl = NULL;
    SID_IDENTIFIER_AUTHORITY sidIdentifierWorldAuth =
        SECURITY_WORLD_SID_AUTHORITY;

    DWORD dwAcls;        

    //
    // Set up the SID for the adminstrators that
    // will be allowed access.  This SID will have
    // 1 sub-authorities: SECURITY_BUILTIN_DOMAIN_RID.
    //
    pObjSid = (PSID)LocalAlloc(LPTR, GetSidLengthRequired(1));
    if (pObjSid == NULL) {
        RASAUTO_TRACE("InitSecurityDescriptor: LocalAlloc failed");
        return GetLastError();
    }
    if (!InitializeSid(pObjSid, &sidIdentifierWorldAuth, 1)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: InitializeSid failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    //
    // Set the sub-authorities.
    //
    pSubAuthority = GetSidSubAuthority(pObjSid, 0);
    *pSubAuthority = SECURITY_WORLD_RID;
    //
    // Set up the DACL that will allow
    // all processes with the above SID all
    // access.  It should be large enough to
    // hold all ACEs.
    //
    cbDaclSize = sizeof(ACCESS_ALLOWED_ACE) +
                 GetLengthSid(pObjSid) +
                 sizeof (ACL);
    pDacl = (PACL)LocalAlloc(LPTR, cbDaclSize);
    if (pDacl == NULL ) {
        RASAUTO_TRACE("InitSecurityDescriptor: LocalAlloc failed");
        dwErr = GetLastError();
        goto done;
    }
    if (!InitializeAcl(pDacl, cbDaclSize, ACL_REVISION2)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: InitializeAcl failed (dwErr=0x%x)", dwErr);
        goto done;
    }

    dwAcls = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;

    dwAcls &= ~(WRITE_DAC | WRITE_OWNER);
    
    //
    // Add the ACE to the DACL
    //
    if (!AddAccessAllowedAce(
          pDacl,
          ACL_REVISION2,
          dwAcls,
          pObjSid))
    {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: AddAccessAllowedAce failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    //
    // Create the security descriptor an put
    // the DACL in it.
    //
    if (!InitializeSecurityDescriptor(pSecurityDescriptor, 1)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: InitializeSecurityDescriptor failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    if (!SetSecurityDescriptorDacl(
          pSecurityDescriptor,
          TRUE,
          pDacl,
          FALSE))
    {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: SetSecurityDescriptorDacl failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    //
    // Set owner for the descriptor.
    //
    if (!SetSecurityDescriptorOwner(pSecurityDescriptor, NULL, FALSE)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: SetSecurityDescriptorOwner failed (dwErr=0x%x)", dwErr);
        goto done;
    }
    //
    // Set group for the descriptor.
    //
    if (!SetSecurityDescriptorGroup(pSecurityDescriptor, NULL, FALSE)) {
        dwErr = GetLastError();
        RASAUTO_TRACE1("InitSecurityDescriptor: SetSecurityDescriptorGroup failed (dwErr=0x%x)", dwErr);
        goto done;
    }

done:
    //
    // Cleanup if necessary.
    //
    if (dwErr) {
        if (pObjSid != NULL)
            LocalFree(pObjSid);
        if (pDacl != NULL)
            LocalFree(pDacl);
    }
    return dwErr;
}



DWORD
InitSecurityAttribute()

/*++

DESCRIPTION
    Initializes the global security attribute used in
    creating shareable handles.

    This code courtesy of Gurdeep.  You need to ask him
    exactly what it does.

ARGUMENTS
    None.

RETURN VALUE
    Win32 error code.

--*/

{
    DWORD dwErr;

    //
    // Initialize the security descriptor.
    //
    dwErr = InitSecurityDescriptor(&SecurityDescriptorG);
    if (dwErr)
        return dwErr;
    //
    // Initialize the security attributes.
    //
    SecurityAttributeG.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecurityAttributeG.lpSecurityDescriptor = &SecurityDescriptorG;
    SecurityAttributeG.bInheritHandle = TRUE;

    return 0;
}



VOID
TraceCurrentUser(VOID)
{
    //WCHAR szUserName[512];
    //DWORD dwSize = sizeof (szUserName) - 1;

    //GetUserName(szUserName, &dwSize);
    RASAUTO_TRACE1(
        "TraceCurrentUser: impersonating Current User %d",
        ImpersonationInfoG.dwCurSessionId);
} // TraceCurrentUser

DWORD
DwGetHkcu()
{
    DWORD dwErr = ERROR_SUCCESS;

    if(NULL == hkeyCUG)
    {
        dwErr = RtlOpenCurrentUser(
                        KEY_ALL_ACCESS,
                        &hkeyCUG);

        if(ERROR_SUCCESS != dwErr)
        {
            RASAUTO_TRACE1("DwGetHhcu: failed to open current user. 0x%x",
                   dwErr);

            goto done;                    
        }
    }

done:
    return dwErr;
}


DWORD
InitializeImpersonation()

/*++

DESCRIPTION
    Initializes the global structures used for impersonation

ARGUMENTS
    None

RETURN VALUE
    Win32 error code.

--*/

{
    DWORD dwError = ERROR_SUCCESS;

    if (!ImpersonationInfoInitializedG)
    {
        ZeroMemory(&ImpersonationInfoG, sizeof(ImpersonationInfoG));
        RasInitializeCriticalSection(&ImpersonationInfoG.csLock, &dwError);

        if(dwError != ERROR_SUCCESS)
        {
            return dwError;
        }

        g_dwCritSecFlags |= RASAUTO_CRITSEC_IMPERSON;
        
        ImpersonationInfoInitializedG = TRUE;
    }

    return dwError;
}


VOID
CleanupImpersonation()

/*++

DESCRIPTION
    Cleans up the global structures used for impersonation

ARGUMENTS
    None

RETURN VALUE
    None

--*/

{
    if (ImpersonationInfoInitializedG)
    {
        EnterCriticalSection(&ImpersonationInfoG.csLock);
        
        if (NULL != ImpersonationInfoG.pGuestSid)
        {
            FreeSid(ImpersonationInfoG.pGuestSid);
            ImpersonationInfoG.pGuestSid = NULL;
        }
        
        LeaveCriticalSection(&ImpersonationInfoG.csLock);
        DeleteCriticalSection(&ImpersonationInfoG.csLock);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_IMPERSON);
        ImpersonationInfoInitializedG = FALSE;
    }
}


BOOLEAN
ImpersonatingGuest()

/*++

DESCRIPTION
    Returns whether or not the user that is currently being impersonating
    is a member of the local guests group

ARGUMENTS
    None

RETURN VALUE
    BOOLEAN -- TRUE if currently impersonating a guests, FALSE otherwise

--*/

{
    BOOLEAN fIsGuest = FALSE;
    
    ASSERT(ImpersonationInfoInitializedG);

    EnterCriticalSection(&ImpersonationInfoG.csLock);

    if (ERROR_SUCCESS == LoadGroupMemberships())
    {
        fIsGuest = ImpersonationInfoG.fGuest;
    }

    LeaveCriticalSection(&ImpersonationInfoG.csLock);

    return fIsGuest;
}


DWORD
LoadGroupMemberships()

/*++

DESCRIPTION
    Caches the group membership information for the impersonated user.

ARGUMENTS
    None

RETURN VALUE
    Win32 error code.

--*/

{
    DWORD dwError = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;
    BOOL fIsGuest;

    EnterCriticalSection(&ImpersonationInfoG.csLock);

    do
    {
        if (ImpersonationInfoG.fGroupsLoaded)
        {
            //
            // Information already loaded
            //

            break;
        }

        if (NULL == ImpersonationInfoG.hTokenImpersonation)
        {
            //
            // There isn't an impersonated user.
            //

            dwError = ERROR_CAN_NOT_COMPLETE; 
            break;
        }

        if (NULL == ImpersonationInfoG.pGuestSid)
        {
            //
            // Allocate the SID for the local guests group;
            //

            if (!AllocateAndInitializeSid(
                    &IdentifierAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_GUESTS,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    &ImpersonationInfoG.pGuestSid
                    ))
            {
                dwError = GetLastError();
                break;
            }   
        }

        if (!CheckTokenMembership(
                ImpersonationInfoG.hTokenImpersonation,
                ImpersonationInfoG.pGuestSid,
                &fIsGuest
                ))
        {
            dwError = GetLastError();
            break;
        }

        ImpersonationInfoG.fGuest = !!fIsGuest;
        
    } while (FALSE);

    LeaveCriticalSection(&ImpersonationInfoG.csLock);

    return dwError;
}

VOID
LockImpersonation()
{
    ASSERT(ImpersonationInfoInitializedG);

    if(ImpersonationInfoInitializedG)
    {
        EnterCriticalSection(&ImpersonationInfoG.csLock);
    }
}

VOID
UnlockImpersonation()
{
    ASSERT(ImpersonationInfoInitializedG);

    if(ImpersonationInfoInitializedG)
    {
        LeaveCriticalSection(&ImpersonationInfoG.csLock);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\init.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    init.c

ABSTRACT
    Initialization for the implicit connection service.

AUTHOR
    Anthony Discolo (adiscolo) 08-May-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <winsock.h>
#include <npapi.h>
#include <ipexport.h>
#include <ras.h>
#include <rasman.h>
#include <acd.h>
#include <tapi.h>
#define DEBUGGLOBALS
#include <debug.h>
#include <rasuip.h>

#include "rasprocs.h"
#include "table.h"
#include "addrmap.h"
#include "netmap.h"
#include "imperson.h"
#include "tapiproc.h"
#include "access.h"
#include "misc.h"
#include "rtutils.h"

//
// Name of the event rasman.dll
// signals whenever a connection
// is created/destroyed.
//
#define CONNECTION_EVENT    L"RasConnectionChangeEvent"

//
// Global variables
//
#if DBG
DWORD AcsDebugG = 0x0;      // flags defined in debug.h
#endif

DWORD dwModuleUsageG = 0;
HANDLE hNewLogonUserG = NULL;      // new user logged into the workstation
HANDLE hNewFusG = NULL;            // FUS caused a new user to get the console
HANDLE hPnpEventG = NULL;           // Pnp event notification
HANDLE hLogoffUserG = NULL;        // user logged off workstation
HANDLE hLogoffUserDoneG = NULL;    // HKEY_CURRENT_USER flushed
HANDLE hTerminatingG = NULL;       // service is terminating
HANDLE hSharedConnectionG = NULL;  // dial shared connection
HANDLE hAddressMapThreadG = NULL;  // AcsAddressMapThread()
extern HANDLE hAutodialRegChangeG;

HINSTANCE hinstDllG;
LONG g_lRasAutoRunning = 0;

HANDLE g_hLogEvent = NULL;

DWORD g_dwCritSecFlags = 0;

//
// External variables
//
extern HANDLE hAcdG;
extern IMPERSONATION_INFO ImpersonationInfoG;
extern CRITICAL_SECTION csRasG;
extern HKEY hkeyCUG;
extern CRITICAL_SECTION csDisabledAddressesLockG;

DWORD
PnpRegister(
    IN BOOL fRegister);


BOOLEAN
WINAPI
InitAcsDLL(
    HINSTANCE   hinstDLL,
    DWORD       fdwReason,
    LPVOID      lpvReserved
    )

/*++

DESCRIPTION
    Initialize the implicit connection DLL.  Dynamically load rasapi32.dll
    and rasman.dll, and initialize miscellaneous other things.

ARGUMENTS
    hinstDLL:

    fdwReason:

    lpvReserved:

RETURN VALUE
    Always TRUE.

--*/

{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        if (hinstDllG == NULL)
            hinstDllG = hinstDLL;

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


DWORD
AcsInitialize()
{
    NTSTATUS status;
    DWORD dwErr, dwcDevices = 0;
    WSADATA wsaData;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    DWORD dwThreadId;
    
    RasAutoDebugInit();
    
    do
    {
        hAcdG = NULL;

        g_dwCritSecFlags = 0;
        
        //
        // Initialize winsock.
        //
        dwErr = WSAStartup(MAKEWORD(2,0), &wsaData);

        if (dwErr) {
            RASAUTO_TRACE1("AcsInitialize: WSAStartup failed (dwErr=%d)",
                           dwErr);
            break;
        }

        //
        // Load icmp.dll.
        //
        LoadIcmpDll();
        
        //
        // Initialize TAPI.
        //
        dwErr = TapiInitialize();
        if (dwErr) 
        {
            RASAUTO_TRACE1("AcsInitialize: TapInitialize failed (dwErr=%d)",
                            dwErr);
            break;
        }

        g_hLogEvent = RouterLogRegister(L"RASAUTO");
        if(NULL == g_hLogEvent)
        {
            dwErr = GetLastError();
            RASAUTO_TRACE1("AcsInitialize: RouterLogRegister failed 0x%x",
                            dwErr);
            break;
        }
        
        //
        // Initialize the name of the implicit
        // connection device.
        //
        RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
        
        //
        // Initialize the object attributes.
        //
        InitializeObjectAttributes(
          &objectAttributes,
          &nameString,
          OBJ_CASE_INSENSITIVE,
          (HANDLE)NULL,
          (PSECURITY_DESCRIPTOR)NULL);
          
        //
        // Open the automatic connection device.
        //
        status = NtCreateFile(
                   &hAcdG,
                   FILE_READ_DATA|FILE_WRITE_DATA,
                   &objectAttributes,
                   &ioStatusBlock,
                   NULL,
                   FILE_ATTRIBUTE_NORMAL,
                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                   FILE_OPEN_IF,
                   0,
                   NULL,
                   0);
                   
        if (status != STATUS_SUCCESS) 
        {
        
            RASAUTO_TRACE1(
              "AcsInitialize: NtCreateFile failed (status=0x%x)",
              status);

            dwErr = ERROR_BAD_DEVICE;
            break;
        }
        
        //
        // Create the event that userinit.exe signals
        // when a new user logs into the workstation.
        // Note we have to create a security descriptor
        // to make this event accessible by a normal user.
        //
        dwErr = InitSecurityAttribute();
        if (dwErr) 
        {
            RASAUTO_TRACE1(
              "AcsInitialize: InitSecurityAttribute failed (dwErr=0x%x)",
              dwErr);
              
            break;
        }
        
        //
        // Create the events that are used for login/logout
        // notification.  userinit.exe signals RasAutodialNewLogonUser
        // winlogon signals RasAutodialLogoffUser, and rasauto.dll
        // signals RasAutodialLogoffUserDone when it has completed
        // flushing HKEY_CURRENT_USER.
        //
        hNewLogonUserG = CreateEvent(&SecurityAttributeG, 
                                    FALSE, 
                                    FALSE, 
                                    L"RasAutodialNewLogonUser");
                                    
        if (hNewLogonUserG == NULL) 
        {
            RASAUTO_TRACE("AcsInitialize: CreateEvent (new user) failed");
            dwErr = GetLastError();
            break;
        }
        
        hNewFusG = CreateEvent(&SecurityAttributeG, FALSE, FALSE, NULL);
        if (hNewFusG == NULL) 
        {
            RASAUTO_TRACE("AcsInitialize: CreateEvent (FUS) failed");
            dwErr = GetLastError();
            break;
        }
        
        hPnpEventG= CreateEvent(&SecurityAttributeG, FALSE, FALSE, NULL);
        if (hPnpEventG == NULL) 
        {
            RASAUTO_TRACE("AcsInitialize: CreateEvent (hPnpEventG) failed");
            dwErr = GetLastError();
            break;
        }
        
        hLogoffUserG = CreateEvent(&SecurityAttributeG, 
                                   FALSE, 
                                   FALSE, 
                                   L"RasAutodialLogoffUser");
                                   
        if (hLogoffUserG == NULL) 
        {
            RASAUTO_TRACE("AcsInitialize: CreateEvent (logoff) failed");
            dwErr = GetLastError();
            break;
        }
        
        hLogoffUserDoneG = CreateEvent(&SecurityAttributeG,     
                                       FALSE, 
                                       FALSE, 
                                       L"RasAutodialLogoffUserDone");
        if (hLogoffUserDoneG == NULL) 
        {
            RASAUTO_TRACE("AcsInitialize: CreateEvent (logoff done) failed");
            dwErr = GetLastError();
            break;
        }
        
        //
        // Create an event to tell us when to dial the shared connection
        //
        hSharedConnectionG = CreateEventA(&SecurityAttributeG, 
                                  FALSE, 
                                  FALSE, 
                                  RAS_AUTO_DIAL_SHARED_CONNECTION_EVENT);
                                          
        if (hSharedConnectionG == NULL) 
        {
            RASAUTO_TRACE("AcsInitialize: CreateEvent failed");
            dwErr = GetLastError();
            break;
        }
        
        //
        // Create an event to give to rasapi32 to let
        // us know when a new RAS connection has been
        // created or destroyed.
        //
        hConnectionEventG = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (hConnectionEventG == NULL) 
        {
            RASAUTO_TRACE("AcsInitialize: CreateEvent failed");
            dwErr = GetLastError();
            break;
        }
        
        //
        // Create the event all threads wait
        // that notify them of termination.
        //
        hTerminatingG = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (hTerminatingG == NULL) 
        {
            RASAUTO_TRACE("AcsInitialize: CreateEvent failed");
            dwErr = GetLastError();
            break;
        }
        
        //
        // Initialize impersonation structures
        //
        dwErr = InitializeImpersonation();
        if (dwErr) 
        {
            RASAUTO_TRACE1(
              "AcsInitialize: InitializeImpersonation failed (dwErr=0x%x)",
              dwErr);
              
            break;              
        }
        
        //
        // Create critical section that protects the
        // RAS module structures.
        //
        RasInitializeCriticalSection(&csRasG, &dwErr);

        if(dwErr != ERROR_SUCCESS)
        {
            break;
        }

        g_dwCritSecFlags |= RASAUTO_CRITSEC_RASG;

        RasInitializeCriticalSection(&csDisabledAddressesLockG, &dwErr);

        if(dwErr != ERROR_SUCCESS)
        {
            break;
        }

        g_dwCritSecFlags |= RASAUTO_CRITSEC_DISABLEDADD;

        //
        // Create a thread to manage the addresses stored
        // in the registry.
        //
        if (!InitializeAddressMap()) 
        {
            RASAUTO_TRACE("AcsInitialize: InitializeAddressMap failed");
            dwErr = ERROR_OUTOFMEMORY;
            break;
        }
        
        if (!InitializeNetworkMap()) 
        {
            RASAUTO_TRACE("AcsInitialize: InitializeNetworkMap failed");
            dwErr = ERROR_OUTOFMEMORY;
            break;
        }
        
        hAddressMapThreadG = CreateThread(
                               NULL,
                               10000L,
                               (LPTHREAD_START_ROUTINE)AcsAddressMapThread,
                               0,
                               0,
                               &dwThreadId);
        if (hAddressMapThreadG == NULL) 
        {
            dwErr = GetLastError();
            RASAUTO_TRACE1(
              "AcsInitialize: CreateThread failed (error=0x%x)",
              dwErr);
            break;              
        }

        // XP 364593
        //
        // Register for pnp not.  Ignore the return value -- if we error,
        // then we simply wont react when a lan adapter comes/goes.
        // It's not worth letting that stop us.
        //
        PnpRegister(TRUE);

        return ERROR_SUCCESS;
    }
    while(FALSE);

    //
    // Cleanup in case of error.
    //

    TapiShutdown();

    if(g_dwCritSecFlags & RASAUTO_CRITSEC_RASG)
    {
        DeleteCriticalSection(&csRasG);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_RASG);
    }

    if(g_dwCritSecFlags & RASAUTO_CRITSEC_DISABLEDADD)
    {
        DeleteCriticalSection(&csDisabledAddressesLockG);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_DISABLEDADD);
    }

    if(NULL != g_hLogEvent)
    {   
        RouterLogDeregister(g_hLogEvent);
        g_hLogEvent = NULL;
    }

    if(NULL != hAcdG)
    {
        CloseHandle(hAcdG);
        hAcdG = NULL;
    }

    if(NULL != hNewLogonUserG)
    {
        CloseHandle(hNewLogonUserG);
        hNewLogonUserG = NULL;
    }

    if(NULL != hNewFusG)
    {
        CloseHandle(hNewFusG);
        hNewFusG = NULL;
    }

    if(NULL != hPnpEventG)
    {
        CloseHandle(hPnpEventG);
        hPnpEventG = NULL;
    }

    if(NULL != hLogoffUserG)
    {
        CloseHandle(hLogoffUserG);
        hLogoffUserG = NULL;
    }

    if(NULL != hLogoffUserDoneG)
    {
        CloseHandle(hLogoffUserDoneG);
        hLogoffUserDoneG = NULL;
    }

    if(NULL != hSharedConnectionG)
    {
        CloseHandle(hSharedConnectionG);
        hSharedConnectionG = NULL;
    }

    if(NULL != hConnectionEventG)
    {
        CloseHandle(hConnectionEventG);
        hConnectionEventG = NULL;
    }

    if(NULL != hTerminatingG)
    {
        CloseHandle(hTerminatingG);
        hTerminatingG = NULL;
    }

    return dwErr;    
} // AcsInitialize



VOID
AcsTerminate()
{
    //
    // Signal other threads to exit.
    // The main service controller
    // thread AcsDoService() will
    // call WaitForAllThreads().
    //
    SetEvent(hTerminatingG);
} // AcsTerminate



VOID
WaitForAllThreads()
{
    RASAUTO_TRACE("WaitForAllThreads: waiting for all threads to terminate");
    //
    // Wait for them to exit.
    //
    WaitForSingleObject(hAddressMapThreadG, INFINITE);
    //
    // Unload icmp.dll.
    //
    UnloadIcmpDll();
    //
    // Cleanup.
    //
    // PrepareForLongWait();
    CloseHandle(hAddressMapThreadG);
    RASAUTO_TRACE("WaitForAllThreads: all threads terminated");
}



VOID
AcsCleanupUser()

/*++

DESCRIPTION
    Unload all resources associated with the currently
    logged-in user.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    if(NULL != hkeyCUG)
    {
        NtClose(hkeyCUG);
        hkeyCUG = NULL;
    }
} // AcsCleanupUser



VOID
AcsCleanup()

/*++

DESCRIPTION
    Unload all resources associated with the entire
    service.

ARGUMENTS
    None.

RETURN VALUE
    None.

--*/

{
    // 
    // Stop receiving pnp events
    //
    PnpRegister(FALSE);
    //
    // Unload per-user resources.
    //
    // AcsCleanupUser();

    //
    // We're terminating.  Wait for the
    // other threads.
    //
    WaitForAllThreads();
    
    //
    // Shutdown TAPI.
    //
    TapiShutdown();
    
    //
    // We've terminated.  Free resources.
    //
    CloseHandle(hAcdG);
    //
    // For now, unload rasman.dll only when
    // we are about to go away.
    //
    //
    // Close all event handles
    //
    if(NULL != hNewLogonUserG)
    {
        CloseHandle(hNewLogonUserG);
        hNewLogonUserG = NULL;
    }

    if(NULL != hNewFusG)
    {
        CloseHandle(hNewFusG);
        hNewFusG = NULL;
    }

    if(NULL != hPnpEventG)
    {
        CloseHandle(hPnpEventG);
        hPnpEventG = NULL;
    }

    if(NULL != hLogoffUserG)
    {
        CloseHandle(hLogoffUserG);
        hLogoffUserG = NULL;
    }

    if(NULL != hLogoffUserDoneG)
    {
        CloseHandle(hLogoffUserDoneG);
        hLogoffUserDoneG = NULL;
    }

    if(NULL != hSharedConnectionG)
    {   
        CloseHandle(hSharedConnectionG);
        hSharedConnectionG = NULL;
    }

    if(NULL != hConnectionEventG)
    {
        CloseHandle(hConnectionEventG);
        hConnectionEventG = NULL;
    }

    if(NULL != hTerminatingG)
    {
        CloseHandle(hTerminatingG);
        hTerminatingG = NULL;
    }

    if(NULL != hAutodialRegChangeG)
    {
        CloseHandle(hAutodialRegChangeG);
        hAutodialRegChangeG = NULL;
    }

    if(NULL != g_hLogEvent)
    {
        RouterLogDeregister(g_hLogEvent);
        g_hLogEvent = NULL;
    }

    {
        LONG l;
        l = InterlockedDecrement(&g_lRasAutoRunning);
        
        {
            // DbgPrint("RASAUTO: AcsCleanup - lrasautorunning=%d\n", l);
        }

        ASSERT(l == 0);
    }


    //
    // Revert impersonation before cleaning up
    //
    RevertImpersonation();

    //
    // Cleanup impersonation structures
    //
    CleanupImpersonation();    

    //
    // Uninitialize addressmap
    //
    UninitializeAddressMap();

    if(g_dwCritSecFlags & RASAUTO_CRITSEC_DISABLEDADD)
    {
        DeleteCriticalSection(&csDisabledAddressesLockG);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_DISABLEDADD);
    }

    //
    // UninitializeNetworkmap
    //
    UninitializeNetworkMap();
    
    RasAutoDebugTerm();

    UnloadRasDlls();

    if(g_dwCritSecFlags & RASAUTO_CRITSEC_RASG)
    {
        DeleteCriticalSection(&csRasG);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_RASG);
    }
} // AcsCleanup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\imperson.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    impersn.h

Abstract:

    Definitions for impersonation routines

Author:

    Anthony Discolo (adiscolo)  04-Aug-1995

Revision History:

--*/

#ifndef _IMPERSON_
#define _IMPERSON_

typedef struct _IMPERSONATION_INFO {
    CRITICAL_SECTION csLock; // lock over entire structure
    HANDLE hToken;          // process token
    HANDLE hTokenImpersonation; // impersonation token
    HANDLE hProcess;        // handle of shell process
    BOOLEAN fGroupsLoaded;  // TRUE if fGuest is valid
    BOOLEAN fGuest;         // user is member of the guests group
    PSID pGuestSid;         // SID of the local guests group
    DWORD dwCurSessionId;
    BOOLEAN fSessionInitialized; 
} IMPERSONATION_INFO;

extern IMPERSONATION_INFO ImpersonationInfoG;
extern SECURITY_ATTRIBUTES SecurityAttributeG;

#define RASAUTO_CRITSEC_ADDRMAP         0x00000001
#define RASAUTO_CRITSEC_REQUESTLIST     0x00000002
#define RASAUTO_CRITSEC_IMPERSON        0x00000004
#define RASAUTO_CRITSEC_RASG            0x00000008
#define RASAUTO_CRITSEC_DISABLEDADD     0x00000010
#define RASAUTO_CRITSEC_NETMAP          0x00000020
#define RASAUTO_CRITSEC_TAPI            0x00000040



BOOLEAN
InteractiveSession();

DWORD
SetCurrentLoginSession(
    IN DWORD dwSessionId);
    
HANDLE
RefreshImpersonation (
    HANDLE hProcess
    );

VOID
RevertImpersonation();

DWORD
InitSecurityAttribute();

VOID
TraceCurrentUser(VOID);

DWORD
DwGetHkcu();

DWORD
InitializeImpersonation();

VOID
CleanupImpersonation();

BOOLEAN
ImpersonatingGuest();

VOID
LockImpersonation();

VOID
UnlockImpersonation();

#endif // _IMPERSON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\init.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    init.h

ABSTRACT
    Header file for initialization routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jun-1995

--*/

DWORD AcsInitialize();

VOID AcsTerminate();

VOID AcsCleanupUser();

VOID AcsCleanup();

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\misc.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    misc.h

ABSTRACT
    Header file for miscellaneous routines.

AUTHOR
    Anthony Discolo (adiscolo) 20-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#include "radebug.h"

LPTSTR
AddressToUnicodeString(
    IN PACD_ADDR pAddr
    );

LPTSTR
CompareConnectionLists(
    IN LPTSTR *lpPreList,
    IN DWORD dwPreSize,
    IN LPTSTR *lpPostList,
    IN DWORD dwPostSize
    );

LPTSTR
CopyString(
    IN LPTSTR pszString
    );

PCHAR
UnicodeStringToAnsiString(
    IN PWCHAR pszUnicode,
    OUT PCHAR pszAnsi,
    IN USHORT cbAnsi
    );

PWCHAR
AnsiStringToUnicodeString(
    IN PCHAR pszAnsi,
    OUT PWCHAR pszUnicode,
    IN USHORT cbUnicode
    );

VOID
FreeStringArray(
    IN LPTSTR *lpArray,
    IN LONG lcEntries
    );

LPTSTR
CanonicalizeAddress(
    IN LPTSTR pszAddress
    );

BOOLEAN
GetOrganization(
    IN LPTSTR pszAddr,
    OUT LPTSTR pszOrganization
    );

/*
VOID
PrepareForLongWait(
    VOID
    );
*/

#if DBG
VOID
DumpHandles(
    IN PCHAR lpString,
    IN ULONG a1,
    IN ULONG a2,
    IN ULONG a3,
    IN ULONG a4,
    IN ULONG a5
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\netmap.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    netmap.c

ABSTRACT
    Network map routines

AUTHOR
    Anthony Discolo (adiscolo) 21-May-1996

REVISION HISTORY

--*/


#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <tdi.h>
#include <nb30.h>
#include <nbtioctl.h>
#include <stdio.h>
#include <npapi.h>
#include <ctype.h>
#include <winsock.h>
#include <acd.h>
#include <ras.h>
#include <raserror.h>
#include <rasman.h>
#include <debug.h>
#include <ipexport.h>
#include <icmpapi.h>

#include "reg.h"
#include "misc.h"
#include "table.h"
#include "access.h"
#include "rasprocs.h"
#include "imperson.h"

extern DWORD g_dwCritSecFlags;

//
// We keep a map of network name to
// address that groups related addresses
// by network name.  We use the network
// name as a remote network identifier to
// allow us to quickly determine whether
// any address belongs to a network that
// is connected or not.
//
typedef struct _NETWORK_MAP_ENTRY {
    BOOLEAN bUp;            // network is connected
    DWORD dwConnectionTag;  // unique index for connections
    PHASH_TABLE pTable;     // table of addresses
    LIST_ENTRY listEntry;   // addresses sorted by tag
} NETWORK_MAP_ENTRY, *PNETWORK_MAP_ENTRY;

//
// The network map.
//
//
typedef struct _NETWORK_MAP {
    CRITICAL_SECTION csLock;
    LPTSTR pszDnsAddresses; // DNS server list
    DWORD dwcConnections; // number of RAS connections
    DWORD dwcUpNetworks;  // number of up networks
    DWORD dwConnectionTag; // unique index for connections for NULL network
    PHASH_TABLE pTable;   // network table
} NETWORK_MAP, PNETWORK_MAP;

//
// This structure is passed to an address
// enumerator procedure to keep track of
// any hosts that are accessible.
//
typedef struct _NETWORK_MAP_ACCESS {
    LPTSTR pszNbDevice; // Netbios device for find name requests
    BOOLEAN bUp;        // network is up
    DWORD dwFailures;   // number of host access failures
} NETWORK_MAP_ACCESS, *PNETWORK_MAP_ACCESS;

//
// This structure is used to store the
// network addresses sorted by tag.
//
typedef struct _TAGGED_ADDRESS {
    DWORD dwTag;            // the tag
    LPTSTR pszAddress;      // the address
    LIST_ENTRY listEntry;   // sorted address list
} TAGGED_ADDRESS, *PTAGGED_ADDRESS;

//
// Netbios device information passed
// to AcsCheckNetworkThread
//
typedef struct _CHECK_NETWORK_INFO {
    LPTSTR *pszNbDevices;   // array of Netbios device strings
    DWORD dwcNbDevices;     // array size
    BOOLEAN fDns;           // DNS server is up
} CHECK_NETWORK_INFO, *PCHECK_NETWORK_INFO;

//
// Global variables
//
NETWORK_MAP NetworkMapG;



LPTSTR
GetPrimaryNetbiosDevice(VOID)
{
    typedef struct _LANA_MAP {
        BOOLEAN fEnum;
        UCHAR bLana;
    } LANA_MAP, *PLANA_MAP;
    BOOLEAN fNetworkPresent = FALSE;
    HKEY hKey;
    PLANA_MAP pLanaMap = NULL, pLana;
    DWORD dwError, dwcbLanaMap;
    PWCHAR pwszLanas = NULL, pwszBuf;
    DWORD dwcBindings, dwcMaxLanas, i, dwcbLanas;
    LONG iLana;
    DWORD dwZero = 0;
    PWCHAR *paszLanas = NULL;
    SOCKET s;
    NTSTATUS status;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES attributes;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    PWCHAR pwszDevice = NULL;

    dwError = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services\\Netbios\\Linkage",
                0,
                KEY_READ,
                &hKey);
    if (dwError != ERROR_SUCCESS) {
        RASAUTO_TRACE1(
          "GetPrimaryNetbiosDevice: RegKeyOpenEx failed (dwError=%d)",
          GetLastError());
        return FALSE;
    }
    //
    // Read in the LanaMap.
    //
    if (!RegGetValue(hKey, L"LanaMap", &pLanaMap, &dwcbLanaMap, NULL)) {
        RASAUTO_TRACE("GetPrimaryNetbiosDevice: RegGetValue(LanaMap) failed");
        goto done;
    }
    dwcBindings = dwcbLanaMap / sizeof (LANA_MAP);
    //
    // Read in the bindings.
    //
    if (!RegGetValue(hKey, L"bind", &pwszLanas, &dwcbLanas, NULL)) {
        RASAUTO_TRACE("GetPrimaryNetbiosDevice: RegGetValue(bind) failed");
        goto done;
    }
    //
    // Allocate a buffer for the binding array.
    //
    paszLanas = LocalAlloc(LPTR, dwcBindings * sizeof (PWCHAR));
    if (paszLanas == NULL) {
        RASAUTO_TRACE("GetPrimaryNetbiosDevice: LocalAlloc failed");
        goto done;
    }
    //
    // Parse the bindings into an array of strings.
    //
    for (dwcMaxLanas = 0, pwszBuf = pwszLanas; 
        (*pwszBuf) && (dwcMaxLanas < dwcBindings); 
        pwszBuf++) 
    {
        paszLanas[dwcMaxLanas++] = pwszBuf;
        while(*++pwszBuf);
    }

    for (iLana = 0, pLana = pLanaMap; dwcBindings--; iLana++, pLana++) {
        int iLanaMap = (int)pLana->bLana;

        if (pLana->fEnum && (DWORD)iLana < dwcMaxLanas) {
            int iError;
            WCHAR *pwsz, szDevice[MAX_DEVICE_NAME + 1];

            if (wcsstr(paszLanas[iLana], L"NwlnkNb") != NULL ||
                wcsstr(paszLanas[iLana], L"_NdisWan") != NULL)
            {
                RASAUTO_TRACE1(
                  "GetPrimaryNetbiosDevice: ignoring %S",
                  RASAUTO_TRACESTRW(paszLanas[iLana]));
                continue;
            }

            RtlInitUnicodeString(&deviceName, paszLanas[iLana]);
            InitializeObjectAttributes(
              &attributes,
              &deviceName,
              OBJ_CASE_INSENSITIVE,
              NULL,
              NULL);
            //
            // Open the lana device.
            //
            status = NtOpenFile(&handle, READ_CONTROL, &attributes, &iosb, 0, 0);
            NtClose(handle);
            if (!NT_SUCCESS(status)) {
                RASAUTO_TRACE2(
                  "GetPrimaryNetbiosDevice: NtOpenFile(%S) failed (status=0x%x)",
                  RASAUTO_TRACESTRW(paszLanas[iLana]),
                  status);
                continue;
            }
            RASAUTO_TRACE1("GetPrimaryNetbiosDevice: opened %S", paszLanas[iLana]);
            //
            // If we succeed in opening the lana
            // device, we need to make sure the
            // underlying netcard device is loaded
            // as well, since transports create
            // device object for non-existent devices.
            //
            pwsz = wcsrchr(paszLanas[iLana], '_');
            if (pwsz == NULL) {
                RASAUTO_TRACE1(
                  "GetPrimaryNetbiosDevice: couldn't parse %S",
                  paszLanas[iLana]);
                continue;
            }
            wsprintf(szDevice, L"\\Device\\%s", pwsz + 1);
            //
            // Open the underlying netcard device.
            //
            RtlInitUnicodeString(&deviceName, szDevice);
            InitializeObjectAttributes(
              &attributes,
              &deviceName,
              OBJ_CASE_INSENSITIVE,
              NULL,
              NULL);
            status = NtOpenFile(&handle, READ_CONTROL, &attributes, &iosb, 0, 0);
            NtClose(handle);
            if (!NT_SUCCESS(status)) {
                RASAUTO_TRACE2(
                  "GetPrimaryNetbiosDevice: NtOpenFile(%S) failed (status=0x%x)",
                  RASAUTO_TRACESTRW(szDevice),
                  status);
                continue;
            }
            //
            // We've succeeded.  The netcard device must
            // be really loaded.
            //
            RASAUTO_TRACE3(
              "GetPrimaryNetbiosDevice: network (%S, %S, %d) is up",
              RASAUTO_TRACESTRW(paszLanas[iLana]),
              szDevice,
              iLana);
            pwszDevice = CopyString(paszLanas[iLana]);
            break;
        }
    }
    //
    // Free resources.
    //
done:
    if (paszLanas != NULL)
        LocalFree(paszLanas);
    if (pwszLanas != NULL)
        LocalFree(pwszLanas);
    if (pLanaMap != NULL)
        LocalFree(pLanaMap);
    RegCloseKey(hKey);

    return pwszDevice;
} // GetPrimaryNetbiosDevice



LPTSTR
DnsAddresses()

/*++

DESCRIPTION
    Return the list of DNS servers for this host.

ARGUMENTS
    None.

RETURN VALUE
    NULL if no DNS servers are configured; a list
    of IP addresses separated by a space otherwise.

--*/

{
    HKEY hkey;
    BOOLEAN fFound = FALSE;
    LPTSTR pszIpAddresses = NULL;
    LPTSTR pszIpAddress, pszIpAddressEnd;
    DWORD dwcbIpAddresses = 0;

    //
    // Look in various places in the registry
    // for one or more DNS addresses.
    //
    if (RegOpenKeyEx(
          HKEY_LOCAL_MACHINE,
          L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Transient",
          0,
          KEY_QUERY_VALUE,
          &hkey) == ERROR_SUCCESS)
    {
        fFound = RegGetValue(
                   hkey,
                   L"NameServer",
                   &pszIpAddresses,
                   &dwcbIpAddresses,
                   NULL);
        RegCloseKey(hkey);
    }
    if (fFound && dwcbIpAddresses > sizeof (TCHAR))
        goto found;
    if (pszIpAddresses != NULL) {
        LocalFree(pszIpAddresses);
        pszIpAddresses = NULL;
    }
    if (RegOpenKeyEx(
          HKEY_LOCAL_MACHINE,
          L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",
          0,
          KEY_QUERY_VALUE,
          &hkey) == ERROR_SUCCESS)
    {
        fFound = RegGetValue(
                   hkey,
                   L"NameServer",
                   &pszIpAddresses,
                   &dwcbIpAddresses,
                   NULL);
        if (fFound && dwcbIpAddresses > sizeof (TCHAR)) {
            RegCloseKey(hkey);
            goto found;
        }
        if (pszIpAddresses != NULL) {
            LocalFree(pszIpAddresses);
            pszIpAddresses = NULL;
        }
        fFound = RegGetValue(
                   hkey,
                   L"DhcpNameServer",
                   &pszIpAddresses,
                   &dwcbIpAddresses,
                   NULL);
        RegCloseKey(hkey);
        if (fFound && dwcbIpAddresses > sizeof (TCHAR))
            goto found;
        if (pszIpAddresses != NULL) {
            LocalFree(pszIpAddresses);
            pszIpAddresses = NULL;
        }
    }

found:
    RASAUTO_TRACE1("DnsAddresses: pszIpAddresses=%S", RASAUTO_TRACESTRW(pszIpAddresses));
    return pszIpAddresses;
} // DnsAddresses



BOOLEAN
PingAddressList(
    IN LPTSTR pszAddresses
    )
{
    TCHAR szAddress[17];
    TCHAR *pSrc, *pDst;

    //
    // If the address list is NULL, we're done.
    //
    if (pszAddresses == NULL)
        return FALSE;
    //
    // Loop through the addresses and try to
    // ping each until one succeeds.
    //
    for (;;) {
        //
        // Copy the next address into szAddress.
        //
        for (pSrc = pszAddresses, pDst = szAddress;
             *pSrc != TEXT(' ') && *pSrc != TEXT(',') && *pSrc != TEXT('\0');
             *pSrc++, *pDst++)
        {
             *pDst = *pSrc;
        }
        *pDst = TEXT('\0');
        //
        // Ping it.  If it succeeds, then
        // we're done.
        //
        if (PingIpAddress(szAddress))
            return TRUE;
        //
        // Skip to the next address.
        //
        if (*pSrc == TEXT('\0'))
            break;
        pSrc++;
        if (*pSrc == TEXT('\0'))
            break;
        pszAddresses = pSrc;
    }

    return FALSE;
} // PingAddressList



BOOLEAN
InitializeNetworkMap(VOID)
{
    DWORD dwError = NO_ERROR;
    
    RasInitializeCriticalSection(&NetworkMapG.csLock, &dwError);

    if(dwError != ERROR_SUCCESS)
    {
        return FALSE;
    }

    g_dwCritSecFlags |= RASAUTO_CRITSEC_NETMAP;
    
    NetworkMapG.pszDnsAddresses = NULL;
    NetworkMapG.dwcConnections = 0;
    NetworkMapG.dwcUpNetworks = 0;
    NetworkMapG.dwConnectionTag = 0;
    NetworkMapG.pTable = NewTable();
    if (NetworkMapG.pTable == NULL) {
        RASAUTO_TRACE("InitializeNetworkMap: NewTable failed");
        return FALSE;
    }
    return TRUE;
} // InitializeNetworkMap



VOID
LockNetworkMap(VOID)
{
    EnterCriticalSection(&NetworkMapG.csLock);
} // LockNetworkMap



VOID
UnlockNetworkMap(VOID)
{
    LeaveCriticalSection(&NetworkMapG.csLock);
} // UnlockNetworkMap


PNETWORK_MAP_ENTRY
NewNetworkMapEntry(
    IN LPTSTR pszNetwork
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;
    DWORD i;

    pNetworkMapEntry = LocalAlloc(LPTR, sizeof (NETWORK_MAP_ENTRY));
    if (pNetworkMapEntry == NULL) {
        RASAUTO_TRACE("NewNetworkMapEntry: LocalAlloc failed");
        return NULL;
    }
    pNetworkMapEntry->bUp = FALSE;
    pNetworkMapEntry->dwConnectionTag = 0;
    pNetworkMapEntry->pTable = NewTable();
    if (pNetworkMapEntry->pTable == NULL) {
        RASAUTO_TRACE("NewNetworkMapEntry: NewTable failed");
        LocalFree(pNetworkMapEntry);
        return NULL;
    }
    InitializeListHead(&pNetworkMapEntry->listEntry);
    if (!PutTableEntry(NetworkMapG.pTable, pszNetwork, pNetworkMapEntry)) {
        RASAUTO_TRACE("NewNetworkMapEntry: PutTableEntry failed");
        LocalFree(pNetworkMapEntry);
        return NULL;
    }

    return pNetworkMapEntry;
} // NewNetworkMapEntry


VOID
FreeNetworkMapEntry(
    IN PNETWORK_MAP_ENTRY pNetworkMapEntry
    )
{
    PLIST_ENTRY pEntry;
    PTAGGED_ADDRESS pTaggedAddress;

    /*
    
    //
    // Since the PTAGGED_ADDRESS structures are
    // in a hash table and a list, we need to
    // free the structures in a special way.  The
    // table package automatically frees the
    // structures when a PutTableEntry(pTable, address, NULL)
    // is called.
    //
    for (pEntry = pNetworkMapEntry->listEntry.Flink;
         pEntry != &pNetworkMapEntry->listEntry;
         pEntry = pEntry->Flink)
    {
        pTaggedAddress = CONTAINING_RECORD(pEntry, TAGGED_ADDRESS, listEntry);

        LocalFree(pTaggedAddress->pszAddress);
    }

    */

    
    while (!IsListEmpty(&pNetworkMapEntry->listEntry)) {

        LPTSTR pszAddress;
    
        pEntry = RemoveHeadList(&pNetworkMapEntry->listEntry);
        pTaggedAddress = CONTAINING_RECORD(pEntry, TAGGED_ADDRESS, listEntry);

        pszAddress = pTaggedAddress->pszAddress;

        //
        // The following call frees the
        // pTaggedAddress structure, as
        // well as frees the table entry.
        //
        PutTableEntry(pNetworkMapEntry->pTable, pszAddress, NULL);

        LocalFree(pszAddress);
    }
    ClearTable(pNetworkMapEntry->pTable);
} // FreeNetworkMapEntry



ACD_ADDR_TYPE
AddressToType(
    IN LPTSTR pszAddress
    )
{
    LONG inaddr;
    CHAR szAddress[17];

    UnicodeStringToAnsiString(pszAddress, szAddress, sizeof (szAddress));
    inaddr = inet_addr(szAddress);
    if (inaddr != INADDR_NONE)
        return ACD_ADDR_IP;
    if (wcschr(pszAddress, ':') != NULL)
        return ACD_ADDR_IPX;
    if (wcschr(pszAddress, '.') != NULL)
        return ACD_ADDR_INET;
    return ACD_ADDR_NB;
} // AddressToType



PNETWORK_MAP_ENTRY
GetNetworkMapEntry(
    IN LPTSTR pszNetwork
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;

    if (GetTableEntry(
          NetworkMapG.pTable,
          pszNetwork,
          &pNetworkMapEntry))
    {
        return pNetworkMapEntry;
    }

    return NULL;
} // GetNetworkMapEntry



BOOLEAN
AddNetworkAddress(
    IN LPTSTR pszNetwork,
    IN LPTSTR pszAddress,
    IN DWORD dwTag
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;
    PTAGGED_ADDRESS pNewTaggedAddress, pTaggedAddress;
    PLIST_ENTRY pPrevEntry, pEntry;
    BOOLEAN bInserted = FALSE;
    BOOLEAN bCreateNew = TRUE;

    RASAUTO_TRACE3(
      "AddNetworkAddress(%S,%S,%d)",
      RASAUTO_TRACESTRW(pszNetwork),
      pszAddress,
      dwTag);
    //
    // Create the network map entry if necessary.
    //
    LockNetworkMap();
    pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
    if (pNetworkMapEntry == NULL) {
        pNetworkMapEntry = NewNetworkMapEntry(pszNetwork);
        if (pNetworkMapEntry == NULL) {
            UnlockNetworkMap();
            return FALSE;
        }
    }
    else {
        //
        // Check to see if the address already exists.
        //
        if (GetTableEntry(
              pNetworkMapEntry->pTable,
              pszAddress,
              &pNewTaggedAddress))
        {
            RASAUTO_TRACE2(
              "AddNetworkAddress: %S exists with dwTag=%d",
              pszAddress,
              pNewTaggedAddress->dwTag);
            //
            // If the address exists with a lower tag, then
            // we don't need to do anything.
            //
            if (pNewTaggedAddress->dwTag <= dwTag) {
                UnlockNetworkMap();
                return TRUE;
            }
            //
            // If the address exists with a higher tag, then
            // we need to remove the existing entry from
            // the list.
            //
            RemoveEntryList(&pNewTaggedAddress->listEntry);
            bCreateNew = FALSE;
        }
    }
    if (bCreateNew) {
        //
        // Create the new tagged address structure.
        //
        pNewTaggedAddress = LocalAlloc(LPTR, sizeof (TAGGED_ADDRESS));
        if (pNewTaggedAddress == NULL) {
            RASAUTO_TRACE("AddNetworkMap: LocalAlloc failed");
            UnlockNetworkMap();
            return FALSE;
        }
        pNewTaggedAddress->pszAddress = CopyString(pszAddress);
        if (pNewTaggedAddress->pszAddress == NULL) {
            RASAUTO_TRACE("AddNetworkMap: LocalAlloc failed");
            UnlockNetworkMap();
            LocalFree(pNewTaggedAddress);
            LocalFree(pNetworkMapEntry);
            return FALSE;
        }
        if (!PutTableEntry(
              pNetworkMapEntry->pTable,
              pszAddress,
              pNewTaggedAddress))
        {
            RASAUTO_TRACE("AddNetworkMap: PutTableEntry failed");
            UnlockNetworkMap();
            LocalFree(pNewTaggedAddress->pszAddress);
            LocalFree(pNewTaggedAddress);
            return FALSE;
        }
    }
    pNewTaggedAddress->dwTag = dwTag;
    //
    // Insert the new address into the list sorted by tag.
    //
    pPrevEntry = &pNetworkMapEntry->listEntry;
    for (pEntry = pNetworkMapEntry->listEntry.Flink;
         pEntry != &pNetworkMapEntry->listEntry;
         pEntry = pEntry->Flink)
    {
        pTaggedAddress = CONTAINING_RECORD(pEntry, TAGGED_ADDRESS, listEntry);

        if (pTaggedAddress->dwTag >= pNewTaggedAddress->dwTag) {
            InsertHeadList(pPrevEntry, &pNewTaggedAddress->listEntry);
            bInserted = TRUE;
            break;
        }
        pPrevEntry = pEntry;
    }
    if (!bInserted) {
        InsertTailList(
          &pNetworkMapEntry->listEntry,
          &pNewTaggedAddress->listEntry);
    }
    UnlockNetworkMap();

    return TRUE;
} // AddNetworkAddress



BOOLEAN
ClearNetworkMapEntry(
    IN PVOID pArg,
    IN LPTSTR pszNetwork,
    IN PVOID pData
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry = (PNETWORK_MAP_ENTRY)pData;

    FreeNetworkMapEntry(pNetworkMapEntry);

    return TRUE;
} // ClearNetworkMapEntry



VOID
ClearNetworkMap(VOID)
{
    LockNetworkMap();
    NetworkMapG.dwcConnections = 0;
    NetworkMapG.dwcUpNetworks = 0;
    NetworkMapG.dwConnectionTag = 0;
    EnumTable(NetworkMapG.pTable, ClearNetworkMapEntry, NULL);
    ClearTable(NetworkMapG.pTable);
    UnlockNetworkMap();
} // ClearNetworkMap



BOOLEAN
IsAddressAccessible(
    IN LPTSTR *pszNbDevices,
    IN DWORD dwcNbDevices,
    IN BOOLEAN fDnsAvailable,
    IN LPTSTR pszAddress
    )
{
    ACD_ADDR_TYPE fType;
    BOOLEAN bSuccess = FALSE;

    //
    // Get the type of the address.
    //
    fType = AddressToType(pszAddress);
    RASAUTO_TRACE2(
      "IsAddressAccessible: fType=%d, pszAddress=%S",
      fType,
      pszAddress);
    //
    // Call the address-specific accessibility routine.
    //
    switch (fType) {
    case ACD_ADDR_IP:
        bSuccess = PingIpAddress(pszAddress);
        break;
    case ACD_ADDR_IPX:
        RASAUTO_TRACE("IsAddressAccessible: IPX address!");
        break;
    case ACD_ADDR_NB:
        bSuccess = NetbiosFindName(pszNbDevices, dwcNbDevices, pszAddress);
        break;
    case ACD_ADDR_INET:
        if (fDnsAvailable) {
            struct hostent *hp;
            struct in_addr in;
            PCHAR pch;
            TCHAR szIpAddress[17];
            LPTSTR psz;

            psz = LocalAlloc(LPTR, (lstrlen(pszAddress) + 1) * sizeof(TCHAR));
            if(NULL == psz)
            {
                break;
            }
            lstrcpy(psz, pszAddress);
            UnlockNetworkMap();
            hp = InetAddressToHostent(psz);
            LocalFree(psz);
            LockNetworkMap();

            if (hp != NULL) {
                in.s_addr = *(PULONG)hp->h_addr;
                pch = inet_ntoa(in);
                if (pch != NULL) {
                    AnsiStringToUnicodeString(
                      pch,
                      szIpAddress,
                      sizeof (szIpAddress) / sizeof(TCHAR));
                    bSuccess = PingIpAddress(szIpAddress);
                }
            }
        }
        break;
    default:
        RASAUTO_TRACE1("IsAddressAccessible: invalid type: %d", fType);
        break;
    }

    return bSuccess;
} // IsAddressAccessible



BOOLEAN
CheckNetwork(
    IN PVOID pArg,
    IN LPTSTR pszNetwork,
    IN PVOID pData
    )
{
    PCHECK_NETWORK_INFO pCheckNetworkInfo = (PCHECK_NETWORK_INFO)pArg;
    PNETWORK_MAP_ENTRY pNetworkMapEntry = (PNETWORK_MAP_ENTRY)pData;
    PLIST_ENTRY pEntry;
    DWORD dwFailures = 0;
    PTAGGED_ADDRESS pTaggedAddress;

    LockNetworkMap();
    //
    // Check the accessiblilty of up
    // to three addresses to
    // determine if the network is up.
    //
    if (!pNetworkMapEntry->bUp) {
        for (pEntry = pNetworkMapEntry->listEntry.Flink;
             pEntry != &pNetworkMapEntry->listEntry;
             pEntry = pEntry->Flink)
        {
            pTaggedAddress = CONTAINING_RECORD(pEntry, TAGGED_ADDRESS, listEntry);

            if (IsAddressAccessible(
                  pCheckNetworkInfo->pszNbDevices,
                  pCheckNetworkInfo->dwcNbDevices,
                  pCheckNetworkInfo->fDns,
                  pTaggedAddress->pszAddress))
            {
                pNetworkMapEntry->bUp = TRUE;
                NetworkMapG.dwcUpNetworks++;
                break;
            }

            //
            // Sanity check to see if the pEntry is
            // still valid - since IsAddressAccessible
            // releases the network map lock.
            //
            {
                PLIST_ENTRY pEntryT;
                
                for (pEntryT = pNetworkMapEntry->listEntry.Flink;
                     pEntryT != &pNetworkMapEntry->listEntry;
                     pEntryT = pEntryT->Flink)
                {
                    if(pEntryT == pEntry)
                    {
                        RASAUTO_TRACE("CheckNetworkMap: Entry valid");
                        break;
                    }
                }

                if(pEntryT != pEntry)
                {
                    RASAUTO_TRACE1("CheckNetworkMap: Entry %p is invalid!",
                            pEntry);
                    break;
                }
            }
            
            if (dwFailures++ > 2)
                break;
        }
    }
    RASAUTO_TRACE3(
      "CheckNetwork: %S is %s (NetworkMapG.dwcUpNetworks=%d",
      pszNetwork,
      pNetworkMapEntry->bUp ? "up" : "down",
      NetworkMapG.dwcUpNetworks);

    UnlockNetworkMap();      
    return TRUE;
} // CheckNetwork



BOOLEAN
MarkNetworkDown(
    IN PVOID pArg,
    IN LPTSTR pszNetwork,
    IN PVOID pData
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry = (PNETWORK_MAP_ENTRY)pData;

    pNetworkMapEntry->bUp = FALSE;
    pNetworkMapEntry->dwConnectionTag = 0;

    return TRUE;
} // MarkNetworkDown



DWORD
AcsCheckNetworkThread(
    LPVOID lpArg
    )
{
    PCHECK_NETWORK_INFO pCheckNetworkInfo = (PCHECK_NETWORK_INFO)lpArg;

    RASAUTO_TRACE("AcsCheckNetworkThread");
    EnumTable(NetworkMapG.pTable, CheckNetwork, pCheckNetworkInfo);

    return 0;
} // AcsCheckNetworkThread



BOOLEAN
UpdateNetworkMap(
    IN BOOLEAN bForce
    )
{
    LPTSTR *pszNbDevices = NULL;
    DWORD i, dwcConnections, dwcNbDevices = 0;
    LPTSTR pszNetwork, *lpActiveEntries = NULL;
    LPTSTR pszDnsAddresses;
    HRASCONN *lphRasconns = NULL;
    PNETWORK_MAP_ENTRY pNetworkMapEntry;
    CHECK_NETWORK_INFO checkNetworkInfo;
    HANDLE hThread;
    DWORD dwThreadId;
    BOOL fLockAcquired = FALSE;

    LockNetworkMap();

    fLockAcquired = TRUE;
    
    //
    // If the previous number of RAS connections
    // equals the current number of RAS connections,
    // then don't waste our time.
    //
    dwcConnections = ActiveConnections(TRUE, &lpActiveEntries, &lphRasconns);
    if (!bForce && dwcConnections == NetworkMapG.dwcConnections) {
        RASAUTO_TRACE1("UpdateNetworkMap: no change (%d connections)", dwcConnections);
        goto done;
    }
    //
    // Allocate the Netbios device array up front.
    //
    pszNbDevices = (LPTSTR *)LocalAlloc(
                               LPTR,
                               (dwcConnections + 1) *
                                 sizeof (LPTSTR));
    if (pszNbDevices == NULL) {
        RASAUTO_TRACE("UpdateNetworkMap: LocalAlloc failed");
        goto done;
    }
    pszNbDevices[0] = GetPrimaryNetbiosDevice();
    if (pszNbDevices[0] != NULL)
        dwcNbDevices++;
    //
    // Wait up to 3 seconds for the new
    // DNS servers to get set.  Otherwise,
    // we may get inaccurate results from
    // subsequent Winsock getxbyy calls.
    //
    if (dwcConnections != NetworkMapG.dwcConnections) {
        for (i = 0; i < 3; i++) {
            BOOLEAN bChanged;

            pszDnsAddresses = DnsAddresses();
            RASAUTO_TRACE2(
              "UpdateNetworkMap: old DNS=%S, new DNS=%S",
              RASAUTO_TRACESTRW(NetworkMapG.pszDnsAddresses),
              RASAUTO_TRACESTRW(pszDnsAddresses));
            bChanged = (pszDnsAddresses != NULL && NetworkMapG.pszDnsAddresses != NULL) ?
                         wcscmp(pszDnsAddresses, NetworkMapG.pszDnsAddresses) :
                         (pszDnsAddresses != NULL || NetworkMapG.pszDnsAddresses != NULL);
            if (bChanged) {
                if (NetworkMapG.pszDnsAddresses != NULL)
                    LocalFree(NetworkMapG.pszDnsAddresses);
                NetworkMapG.pszDnsAddresses = pszDnsAddresses;
                break;
            }
            LocalFree(pszDnsAddresses);
            Sleep(1000);
        }
    }
    else if (bForce && NetworkMapG.pszDnsAddresses == NULL)
        NetworkMapG.pszDnsAddresses = DnsAddresses();
    //
    //
    NetworkMapG.dwcConnections = dwcConnections;
    NetworkMapG.dwConnectionTag = 0;
    //
    // Mark all networks as down initially.
    //
    NetworkMapG.dwcUpNetworks = dwcNbDevices;
    EnumTable(NetworkMapG.pTable, MarkNetworkDown, NULL);
    //
    // Enumerate the connected phonebook entries
    // and automatically mark those networks as
    // connected.
    //
    for (i = 0; i < dwcConnections; i++) {
        pszNetwork = EntryToNetwork(lpActiveEntries[i]);
        RASAUTO_TRACE2(
          "UpdateNetworkMap: entry %S, network %S is connected",
          lpActiveEntries[i],
          RASAUTO_TRACESTRW(pszNetwork));
        //
        // Increment the number of up networks.
        //
        NetworkMapG.dwcUpNetworks++;
        if (pszNetwork != NULL) {
            pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
            if (pNetworkMapEntry != NULL) {
                pNetworkMapEntry->bUp = TRUE;
                RASAUTO_TRACE2(
                  "UpdateNetworkMap: network %S is up (dwcUpNetworks=%d)",
                  pszNetwork,
                  NetworkMapG.dwcUpNetworks);
            }
            LocalFree(pszNetwork);
        }
        else {
            //
            // Add a Netbios device associated with
            // this phonebook entry to the list
            // of Netbios devices representing unknown
            // networks so we can do FIND NAME
            // requests on them below.
            //
            pszNbDevices[dwcNbDevices] = GetNetbiosDevice(lphRasconns[i]);
            if (pszNbDevices[dwcNbDevices] != NULL)
                dwcNbDevices++;
        }
    }


    UnlockNetworkMap();
    fLockAcquired = FALSE;
    
    //
    // Now go through all the networks that are
    // not associated with a connected phonebook
    // entry and see if they are connected (via
    // a netcard).  We need to do this in a new
    // thread because only new Winsock threads
    // will get the new DNS server addresses.
    //
    checkNetworkInfo.pszNbDevices = pszNbDevices;
    checkNetworkInfo.dwcNbDevices = dwcNbDevices;
    checkNetworkInfo.fDns = PingAddressList(NetworkMapG.pszDnsAddresses);
    RASAUTO_TRACE1(
      "UpdateNetworkMap: DNS is %s",
      checkNetworkInfo.fDns ? "up" : "down");
    hThread = CreateThread(
                NULL,
                10000L,
                (LPTHREAD_START_ROUTINE)AcsCheckNetworkThread,
                &checkNetworkInfo,
                0,
                &dwThreadId);
    if (hThread == NULL) {
        RASAUTO_TRACE1(
          "UpdateNetworkMap: CreateThread failed (error=0x%x)",
          GetLastError());
        goto done;
    }
    //
    // Wait for the thread to terminate.
    //
    RASAUTO_TRACE("UpdateNetworkMap: waiting for AcsCheckNetworkThread to terminate...");
    WaitForSingleObject(hThread, INFINITE);
    RASAUTO_TRACE1(
      "UpdateNetworkMap: AcsCheckNetworkThread done (NetworkMapG.dwcUpNetworks=%d",
      NetworkMapG.dwcUpNetworks);
    CloseHandle(hThread);

done:

    if(fLockAcquired)
        UnlockNetworkMap();

    if (lpActiveEntries != NULL)
        FreeStringArray(lpActiveEntries, dwcConnections);
    if (lphRasconns != NULL)
        LocalFree(lphRasconns);
    if (pszNbDevices != NULL)
        FreeStringArray(pszNbDevices, dwcNbDevices);
    return TRUE;
} // UpdateNetworkMap



BOOLEAN
GetNetworkConnected(
    IN LPTSTR pszNetwork,
    OUT PBOOLEAN pbConnected
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;

    pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
    if (pNetworkMapEntry == NULL)
        return FALSE;
    *pbConnected = pNetworkMapEntry->bUp;
    RASAUTO_TRACE2("GetNetworkConnected: %S is %d", pszNetwork, *pbConnected);

    return TRUE;
} // GetNetworkConnected



BOOLEAN
SetNetworkConnected(
    IN LPTSTR pszNetwork,
    IN BOOLEAN bConnected
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry;

    pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
    if (pNetworkMapEntry != NULL)
        pNetworkMapEntry->bUp = bConnected;
    if (bConnected)
        NetworkMapG.dwcUpNetworks++;
    else
        NetworkMapG.dwcUpNetworks--;
    RASAUTO_TRACE3(
      "SetNetworkConnected: %S is %d (dwcUpNetworks=%d)",
      RASAUTO_TRACESTRW(pszNetwork),
      bConnected,
      NetworkMapG.dwcUpNetworks);

    return TRUE;
} // SetNetworkConnected



DWORD
GetNetworkConnectionTag(
    IN LPTSTR pszNetwork,
    IN BOOLEAN bIncrement
    )
{
    PNETWORK_MAP_ENTRY pNetworkMapEntry = NULL;
    DWORD dwTag;

    if (pszNetwork != NULL)
        pNetworkMapEntry = GetNetworkMapEntry(pszNetwork);
    if (bIncrement) {
        dwTag = (pNetworkMapEntry == NULL) ?
                  NetworkMapG.dwConnectionTag++ :
                    pNetworkMapEntry->dwConnectionTag++;
    }
    else {
        dwTag = (pNetworkMapEntry == NULL) ?
                  NetworkMapG.dwConnectionTag :
                    pNetworkMapEntry->dwConnectionTag;
    }
    RASAUTO_TRACE2(
      "GetNetworkConnectionTag: network=%S, tag=%d",
      RASAUTO_TRACESTRW(pszNetwork),
      dwTag);
    return dwTag;
} // GetNetworkConnectionTag



BOOLEAN
IsNetworkConnected(VOID)
{
    BOOLEAN bConnected;

    LockNetworkMap();
    bConnected = (NetworkMapG.dwcUpNetworks > 0);
    RASAUTO_TRACE1("IsNetworkConnected: dwcUpNetworks=%d", NetworkMapG.dwcUpNetworks);
    UnlockNetworkMap();

    return bConnected;
} // IsNetworkConnected

VOID
UninitializeNetworkMap(VOID)
{
    if(g_dwCritSecFlags & RASAUTO_CRITSEC_NETMAP)
    {
        DeleteCriticalSection(&NetworkMapG.csLock);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_NETMAP);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\pnp.c ===
/*
    File    pnp.c

    Handles pnp notifications such as lan interfaces coming up and down.
*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <winsock.h>
#include <npapi.h>
#include <ipexport.h>
#include <ras.h>
#include <rasman.h>
#include <acd.h>
#include <tapi.h>

#include <ndisguid.h>
#include <wmium.h>

#include "radebug.h"

extern HANDLE hPnpEventG;

//**
//
// Call:        PnpMediaSenseCb
//
// Returns:     None
//
// Description:
//
VOID
WINAPI
PnpMediaSenseCb(
    PWNODE_HEADER   pWnodeHeader,
    UINT_PTR        NotificationContext
)
{
    PWNODE_SINGLE_INSTANCE    pWnode   = (PWNODE_SINGLE_INSTANCE)pWnodeHeader;
    LPWSTR                    lpwsName = (LPWSTR)RtlOffsetToPointer( 
                                                pWnode, 
                                                pWnode->OffsetInstanceName );

    //
    // Get the information for the media disconnect.
    //

    if ( memcmp( &(pWnodeHeader->Guid), 
                 &GUID_NDIS_STATUS_MEDIA_DISCONNECT, 
                 sizeof( GUID ) ) == 0 )
    {
        RASAUTO_TRACE1(
            "PnpMediaSenseCb [disconnect] called for %ws",
            lpwsName );

        if (hPnpEventG)
        {
            SetEvent(hPnpEventG);
        }
    }
    else
    {
        //
        // Get the information for the media connect.
        //

        if ( memcmp( &(pWnodeHeader->Guid), 
                     &GUID_NDIS_STATUS_MEDIA_CONNECT, 
                     sizeof( GUID ) ) == 0 )
        {
            RASAUTO_TRACE1(
                "PnpMediaSenseCb [connect] called for %ws",
                lpwsName );

            if (hPnpEventG)
            {
                SetEvent(hPnpEventG);
            }
        }
    }
}

//**
//
// Call:        PnpMediaSenseRegister
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
PnpMediaSenseRegister(
    IN BOOL fRegister
)
{
    DWORD       dwRetCode = NO_ERROR;
    PVOID       pvDeliveryInfo = PnpMediaSenseCb;

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_CONNECT),
                    (BOOLEAN)fRegister,    
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR ) 
    {
        return( dwRetCode );
    }

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_STATUS_MEDIA_DISCONNECT),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    return( NO_ERROR );
}

//**
//
// Call:        PnpBindingsNotificationsCb
//
// Returns:     None
//
// Description:
//
VOID
WINAPI
PnpBindingsNotificationsCb(
    PWNODE_HEADER   pWnodeHeader,
    UINT_PTR        NotificationContext
)
{
    LPWSTR lpwszGUIDStart; 
    LPWSTR lpwszGUIDEnd;
    LPWSTR lpwszGUID;
    WCHAR  wchGUIDSaveLast;
    PWNODE_SINGLE_INSTANCE    pWnode   = (PWNODE_SINGLE_INSTANCE)pWnodeHeader;
    LPWSTR                    lpwsName = (LPWSTR)RtlOffsetToPointer(
                                                pWnode,
                                                pWnode->OffsetInstanceName );
    LPWSTR                    lpwsTransportName = (LPWSTR)RtlOffsetToPointer(
                                                        pWnode,
                                                        pWnode->DataBlockOffset );

    //
    // Extract GUID from the \device\GUID name
    //
    lpwszGUID       = lpwsTransportName + wcslen( lpwsTransportName ) + 1;
    lpwszGUIDStart  = wcsrchr( lpwszGUID, L'{' );
    lpwszGUIDEnd    = wcsrchr( lpwszGUID, L'}' );

    if (    (lpwszGUIDStart != NULL )
        &&  (lpwszGUIDEnd != NULL ))
    {
        BOOL fBind, fUnbind;

        // Only signal when something happens with IP.  This will prevent 
        // us from handling too many notifications
        //
        if ( _wcsicmp( L"TCPIP", lpwsTransportName ) == 0 )
        {
            fBind = ( memcmp( 
                        &(pWnodeHeader->Guid), 
                        &GUID_NDIS_NOTIFY_BIND, 
                        sizeof( GUID ) ) == 0);
            fUnbind = (memcmp( 
                        &(pWnodeHeader->Guid),
                        &GUID_NDIS_NOTIFY_UNBIND,
                        sizeof(GUID))==0);

            if (fBind || fUnbind)
            {
                RASAUTO_TRACE4(
                    "PnpBindingsNotificationsCb %d %d if=%ws, trans=%ws",
                    fBind,
                    fUnbind,
                    lpwsName, 
                    lpwsTransportName );

                if (hPnpEventG)
                {
                    SetEvent(hPnpEventG);
                }                
            }
        }            
        else
        {
            RASAUTO_TRACE2(
                "PnpBindingsNotificationsCb non-tcp: if=%ws, trans=%ws",
                lpwsName, 
                lpwsTransportName );
        }
    }
    
}

//**
//
// Call:        PnpBindingsNotificationsRegister
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
PnpBindingsNotificationsRegister(
    IN BOOL fRegister
)
{
    DWORD       dwRetCode = NO_ERROR;
    PVOID       pvDeliveryInfo = PnpBindingsNotificationsCb;

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_NOTIFY_BIND),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    dwRetCode = WmiNotificationRegistration(
                    (LPGUID)(&GUID_NDIS_NOTIFY_UNBIND),
                    (BOOLEAN)fRegister,
                    pvDeliveryInfo,
                    (ULONG_PTR)NULL,
                    NOTIFICATION_CALLBACK_DIRECT );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    return( NO_ERROR );
}

DWORD
PnpRegister(
    IN BOOL fRegister)
{
    DWORD dwErr = NO_ERROR;

    RASAUTO_TRACE1("PnpRegister: %d", !!fRegister);

    dwErr = PnpBindingsNotificationsRegister(fRegister);
    if (dwErr == NO_ERROR)
    {
        dwErr = PnpMediaSenseRegister(fRegister);
        if (dwErr == NO_ERROR)
        {
            RASAUTO_TRACE("PnpRegister: success.");
        }
        else
        {
            if (fRegister)
            {
                PnpBindingsNotificationsRegister(FALSE);
            }                
            RASAUTO_TRACE1("PnpRegister: MSense reg failure 0x%x", dwErr);
        }
    }
    else
    {
        RASAUTO_TRACE1("PnpRegister: Bingings reg failure 0x%x", dwErr);
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\netmap.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    netmap.h

ABSTRACT
    Network map definitions

AUTHOR
    Anthony Discolo (adiscolo) 18-May-1996

REVISION HISTORY

--*/

BOOLEAN
InitializeNetworkMap(VOID);

VOID
UninitializeNetworkMap(VOID);

VOID
LockNetworkMap(VOID);

VOID
UnlockNetworkMap(VOID);

BOOLEAN
AddNetworkAddress(
    IN LPTSTR pszNetwork,
    IN LPTSTR pszAddress,
    IN DWORD dwTag
    );

VOID
ClearNetworkMap(VOID);

BOOLEAN
UpdateNetworkMap(
    IN BOOLEAN bForce
    );

BOOLEAN
IsNetworkConnected(VOID);

BOOLEAN
GetNetworkConnected(
    IN LPTSTR pszNetwork,
    OUT PBOOLEAN pbConnected
    );

BOOLEAN
SetNetworkConnected(
    IN LPTSTR pszNetwork,
    IN BOOLEAN bConnected
    );

DWORD
GetNetworkConnectionTag(
    IN LPTSTR pszNetwork,
    IN BOOLEAN bIncrement
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\misc.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    misc.c

ABSTRACT
    Miscellaneous routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 20-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <winsock.h>
#include <acd.h>
#include <debug.h>
#include <rasman.h>

#include "access.h"
#include "reg.h"
#include "misc.h"
#include "process.h"
#include "rtutils.h"




LPTSTR
AddressToUnicodeString(
    IN PACD_ADDR pAddr
    )
{
    PCHAR pch;
    struct in_addr in;
    // CHAR szBuf[64];
    CHAR *pszBuf = NULL;
    LPTSTR pszAddrOrig = NULL, pszAddr = NULL;
    INT i;
    INT cch;

    pszBuf = LocalAlloc(LPTR, 1024);

    if(NULL == pszBuf)
    {
        return NULL;
    }

    switch (pAddr->fType) {
    case ACD_ADDR_IP:
        in.s_addr = pAddr->ulIpaddr;
        pch = inet_ntoa(in);
        pszAddrOrig = AnsiStringToUnicodeString(pch, NULL, 0);
        break;
    case ACD_ADDR_IPX:
        NodeNumberToString(pAddr->cNode, pszBuf);
        pszAddrOrig = AnsiStringToUnicodeString(pszBuf, NULL, 0);
        break;
    case ACD_ADDR_NB:
        // RtlZeroMemory(&szBuf, sizeof (szBuf));
        pch = pszBuf;
        for (i = 0; i < 1024; i++) {
            if (pAddr->cNetbios[i] == ' ' || pAddr->cNetbios[i] == '\0')
                break;
            *pch++ = pAddr->cNetbios[i];
        }

        //
        // Make sure this is a string - there are penetration attack
        // tests in stress which pass bogus buffers.
        //
        pszBuf[1023] = '\0';
        
        pszAddrOrig = AnsiStringToUnicodeString(pszBuf, NULL, 0);
        break;
    case ACD_ADDR_INET:
        //
        // Make sure that the address is a string
        // 
        pAddr->szInet[1023]  = '\0';
        pszAddrOrig = AnsiStringToUnicodeString(pAddr->szInet, NULL, 0);
        break;
    default:
        RASAUTO_TRACE1("AddressToUnicodeString: unknown address type (%d)", pAddr->fType);
        break;
    }

    if (pszAddrOrig != NULL) {
        pszAddr = CanonicalizeAddress(pszAddrOrig);
        LocalFree(pszAddrOrig);
    }

    if(NULL != pszBuf)
    {
        LocalFree(pszBuf);
    }
    
    return pszAddr;
} // AddressToUnicodeString



LPTSTR
CompareConnectionLists(
    IN LPTSTR *lpPreList,
    IN DWORD dwPreSize,
    IN LPTSTR *lpPostList,
    IN DWORD dwPostSize
    )
{
    DWORD i, j;
    DWORD iMax, jMax;
    LPTSTR *piList, *pjList;
    BOOLEAN fFound;

    if (dwPostSize > dwPreSize) {
        iMax = dwPostSize;
        piList = lpPostList;
        jMax = dwPreSize;
        pjList = lpPreList;
    }
    else {
        iMax = dwPreSize;
        piList = lpPreList;
        jMax = dwPostSize;
        pjList = lpPostList;
    }
    //
    // If one list is empty, then return
    // the first entry of the other list.
    //
    if (iMax > 0 && jMax == 0)
        return piList[0];
    for (i = 0; i < iMax; i++) {
        fFound = FALSE;
        for (j = 0; j < jMax; j++) {
            if (!wcscmp(piList[i], pjList[j])) {
                fFound = TRUE;
                break;
            }
        }
        if (!fFound)
            return piList[i];
    }
    //
    // Didn't find any differences.
    //
    return NULL;
} // CompareConnectionLists



LPTSTR
CopyString(
    IN LPTSTR pszString
    )
{
    LPTSTR pszNewString;

    pszNewString = LocalAlloc(
                      LPTR,
                      (wcslen(pszString) + 1) * sizeof (TCHAR));
    if (pszNewString == NULL) {
        RASAUTO_TRACE("CopyString: LocalAlloc failed");
        return NULL;
    }

    wcscpy(pszNewString, pszString);

    return pszNewString;
} // CopyString



PCHAR
UnicodeStringToAnsiString(
    IN PWCHAR pszUnicode,
    OUT PCHAR pszAnsi,
    IN USHORT cbAnsi
    )
{
    NTSTATUS status;
    BOOLEAN fAllocate = (pszAnsi == NULL);
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;

    RtlInitUnicodeString(&unicodeString, pszUnicode);
    if (pszAnsi != NULL) {
        ansiString.Length = 0;
        ansiString.MaximumLength = cbAnsi;
        ansiString.Buffer = pszAnsi;
    }
    status = RtlUnicodeStringToAnsiString(
               &ansiString,
               &unicodeString,
               fAllocate);

    return (status == STATUS_SUCCESS ? ansiString.Buffer : NULL);
} // UnicodeStringToAnsiString



PWCHAR
AnsiStringToUnicodeString(
    IN PCHAR pszAnsi,
    OUT PWCHAR pszUnicode,
    IN USHORT cbUnicode
    )
{
    NTSTATUS status;
    BOOLEAN fAllocate = (pszUnicode == NULL);
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;

    RtlInitAnsiString(&ansiString, pszAnsi);
    if (pszUnicode != NULL) {
        unicodeString.Length = 0;
        unicodeString.MaximumLength = cbUnicode;
        unicodeString.Buffer = pszUnicode;
    }
    status = RtlAnsiStringToUnicodeString(
               &unicodeString,
               &ansiString,
               fAllocate);

    return (status == STATUS_SUCCESS ? unicodeString.Buffer : NULL);
} // AnsiStringToUnicodeString



VOID
FreeStringArray(
    IN LPTSTR *lpEntries,
    IN LONG lcEntries
    )
{
    while (--lcEntries >= 0)
        LocalFree(lpEntries[lcEntries]);
    LocalFree(lpEntries);
} // FreeStringArray



LPTSTR
CanonicalizeAddress(
    IN LPTSTR pszAddress
    )
{
    LPTSTR psz, pWhack;

    if (pszAddress[0] == L'\\' && pszAddress[1] == L'\\') {
        psz = CopyString(&pszAddress[2]);
        if (psz == NULL)
            return NULL;
        pWhack = wcschr(psz, '\\');
        if (pWhack != NULL)
            *pWhack = L'\0';
    }
    else {
        psz = CopyString(pszAddress);
        if (psz == NULL)
            return NULL;
    }
    _wcslwr(psz);

    RASAUTO_TRACE2("CanonicalizeAddress(%S) returns %S", pszAddress, psz);
    return psz;
} // CanonicalizeAddress



BOOLEAN
GetOrganization(
    IN LPTSTR pszAddr,
    OUT LPTSTR pszOrganization
    )
{
    BOOLEAN fSuccess = FALSE;
    TCHAR *pszA, *pszO;
    ULONG nDots;

    //
    // Get the domain and organization name.  These
    // are the last two components separated by a '.'.
    //
    for (pszA = pszAddr; *pszA; pszA++);
    for (nDots = 0, pszA--; pszA != pszAddr; pszA--) {
        if (*pszA == TEXT('.'))
            nDots++;
        if (nDots == 2)
            break;
    }
    if (nDots == 2 || (pszA == pszAddr && nDots == 1)) {
        if (nDots == 2)
            pszA++;        // skip '.'
        for (pszO = pszOrganization; *pszO = *pszA; pszA++, pszO++);
        fSuccess = TRUE;
        RASAUTO_TRACE2("GetOrganization: org for %S is %S", pszAddr, pszOrganization);
    }
    return fSuccess;
} // GetOrganization

// Tracing
//
DWORD g_dwRasAutoTraceId = INVALID_TRACEID;

DWORD
RasAutoDebugInit()
{
    DebugInitEx("RASAUTO", &g_dwRasAutoTraceId);
    return 0;
}

DWORD
RasAutoDebugTerm()
{
    DebugTermEx(&g_dwRasAutoTraceId);
    return 0;
}

/*

VOID
repareForLongWait(VOID)
{
    //
    // Unload user-based resources because they
    // cannot be held over logout/login sequence.
    //
    // RegCloseKey(HKEY_CURRENT_USER);
} // PrepareForLongWait
*/

#if DBG
VOID
DumpHandles(
    IN PCHAR lpString,
    IN ULONG a1,
    IN ULONG a2,
    IN ULONG a3,
    IN ULONG a4,
    IN ULONG a5
    )
{
    PSYSTEM_PROCESS_INFORMATION pSystemInfo, pProcessInfo;
    ULONG ulHandles;

    pSystemInfo = GetSystemProcessInfo();
    if (pSystemInfo == NULL)
        return;
    pProcessInfo = FindProcessByName(pSystemInfo, L"rasman.exe");
    if (pProcessInfo == NULL)
        return;
    DbgPrint(lpString, a1, a2, a3, a4, a5);
    DbgPrint(": HANDLES=%d\n", pProcessInfo->HandleCount);
    FreeSystemProcessInfo(pSystemInfo);
} // DumpHandles
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\process.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    process.h

ABSTRACT
    Header file for NT process routines.

AUTHOR
    Anthony Discolo (adiscolo) 12-Aug-1995

REVISION HISTORY

--*/

PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo();

PSYSTEM_PROCESS_INFORMATION
FindProcessByName(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR lpExeName
    );

PSYSTEM_PROCESS_INFORMATION
FindProcessByNameList(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR *lpExeNameArray,
    IN DWORD dwcExeNameArray,
    IN DWORD dwPid,
    IN BOOL fRequireSessionMatch,
    IN DWORD dwSessionId
    );

VOID
FreeSystemProcessInfo(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\rasprocs.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    rasprocs.c

ABSTRACT
    RAS utility routines.

AUTHOR
    Anthony Discolo (adiscolo) 23-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <ras.h>
#include <raserror.h>
#include <rasman.h>
#include <winsock.h>
#include <acd.h>
#include <tapi.h>
#include <debug.h>
#include <userenv.h>

#include "reg.h"
#include "table.h"
#include "addrmap.h"
#include "access.h"
#include "misc.h"
#include "process.h"
#include "rasprocs.h"
#include "tapiproc.h"
#include "imperson.h"

extern HKEY hkeyCUG;

extern PHASH_TABLE pDisabledAddressesG;

//
// rasdlui command line strings.
//
#define RASAUTOUI_EXE               L"rasautou.exe"          // .exe name
#define RASAUTOUI_NOENTRY           L"rasautou -a \"%s\""
#define RASAUTOUI_CUSTOMDIALENTRY   L"rasautou -d \"%s\" -p \"%s\" -e \"%s\""
#define RASAUTOUI_DEFAULTDIALENTRY  L"rasautou -a \"%s\" -e \"%s\""
#define RASAUTOUI_DEFAULTDIALENTRY2 L"rasautou -q -a \"%s\" -e \"%s\""
#define RASAUTOUI_REDIALENTRY       L"rasautou -r -f \"%s\" -e \"%s\""

//
// DLL module handles for rasapi32.dll and rasman.dll.
//
#define RASAPI_MODULE   L"RASAPI32"
HANDLE hRasApiG;

#define RASMAN_MODULE   L"RASMAN"
HANDLE hRasManG;

//
// DLL entrypoints for rasapi32.dll.
//
#define RASDIAL             "RasDialW"
FARPROC lpfnRasDialG;

#define RASENUMCONNECTIONS  "RasEnumConnectionsW"
FARPROC lpfnRasEnumConnectionsG;

#define RASENUMENTRIES      "RasEnumEntriesW"
FARPROC lpfnRasEnumEntriesG;

#define RASGETCONNECTSTATUS "RasGetConnectStatusW"
FARPROC lpfnRasGetConnectStatusG;

#define RASGETHPORT         "RasGetHport"
FARPROC lpfnRasGetHportG;

#define RASGETPROJECTIONINFO "RasGetProjectionInfoW"
FARPROC lpfnRasGetProjectionInfoG;

#define RASGETENTRYPROPERTIES "RasGetEntryPropertiesW"
FARPROC lpfnRasGetEntryPropertiesG;

#define RASGETAUTODIALADDRESS "RasGetAutodialAddressW"
FARPROC lpfnRasGetAutodialAddressG;

#define RASSETAUTODIALADDRESS "RasSetAutodialAddressW"
FARPROC lpfnRasSetAutodialAddressG;

#define RASENUMAUTODIALADDRESSES "RasEnumAutodialAddressesW"
FARPROC lpfnRasEnumAutodialAddressesG;

#define RASGETAUTODIALENABLE    "RasGetAutodialEnableW"
FARPROC lpfnRasGetAutodialEnableG;

#define RASSETAUTODIALENABLE    "RasSetAutodialEnableW"
FARPROC lpfnRasSetAutodialEnableG;

#define RASAUTODIALADDRESSTONETWORK    "RasAutodialAddressToNetwork"
FARPROC lpfnRasAutodialAddressToNetworkG;

#define RASAUTODIALENTRYTONETWORK    "RasAutodialEntryToNetwork"
FARPROC lpfnRasAutodialEntryToNetworkG;

#define RASCONNECTIONNOTIFICATION    "RasConnectionNotificationW"
FARPROC lpfnRasConnectionNotificationG;

#define RASGETAUTODIALPARAM    "RasGetAutodialParamW"
FARPROC lpfnRasGetAutodialParamG;

#define RASSETAUTODIALPARAM    "RasSetAutodialParamW"
FARPROC lpfnRasSetAutodialParamG;

#define RASQUERYSHAREDAUTODIAL      "RasQuerySharedAutoDial"
FARPROC lpfnRasQuerySharedAutoDialG;

#define RASQUERYSHAREDCONNECTION    "RasQuerySharedConnection"
FARPROC lpfnRasQuerySharedConnectionG;

#define RASQUERYREDIALONLINKFAILURE "RasQueryRedialOnLinkFailure"
FARPROC lpfnRasQueryRedialOnLinkFailureG;

#define RASGETCREDENTIALS "RasGetCredentialsW"
FARPROC lpfnRasGetCredentialsG;

#define RASHANGUP "RasHangUpW"
FARPROC lpfnRasHangUpG;

//
// DLL entrypoints for rasman.dll.
//
#define RASPORTRETRIEVEUSERDATA "RasPortRetrieveUserData"
FARPROC lpfnRasPortRetrieveUserDataG;

#define RASPORTENUMPROTOCOLS "RasPortEnumProtocols"
FARPROC lpfnRasPortEnumProtocolsG;

#define RASPORTENUM "RasPortEnum"
FARPROC lpfnRasPortEnumG;

#define RASINITIALIZE "RasInitialize"
FARPROC lpfnRasInitializeG;

#define RASREFERENCERASMAN "RasReferenceRasman"
FARPROC lpfnRasReferenceRasmanG;

#define RASPORTOPEN "RasPortOpen"
FARPROC lpfnRasPortOpenG;

#define RASPORTCLOSE "RasPortClose"
FARPROC lpfnRasPortCloseG;

#define RASGETINFO "RasGetInfo"
FARPROC lpfnRasGetInfoG;

#define RASGETPORTUSERDATA "RasGetPortUserData"
FARPROC lpfnRasGetPortUserDataG;

#define RASREGISTERREDIALCALLBACK "RasRegisterRedialCallback"
FARPROC lpfnRasRegisterRedialCallbackG;

//
// Hostent cache.
//
#define HOSTENTCACHESIZ     10

typedef struct _HOSTENT_CACHE {
    CHAR szDns[ACD_ADDR_INET_LEN];
    ULONG ulIpaddr;
} HOSTENT_CACHE, *PHOSTENT_CACHE;

//
// External definitions
//
VOID
AcsRedialOnLinkFailure(
    LPSTR lpszPhonebook,
    LPSTR lpszEntry);

//
// Global variables
//
CRITICAL_SECTION csRasG;
INT nRasReferencesG;
BOOLEAN fAutoDialRegChangeG;
HKEY hkeyAutoDialRegChangeG;
HANDLE hConnectionEventG = NULL;

HOSTENT_CACHE hostentCacheG[HOSTENTCACHESIZ];
INT iHostentCacheG = 0;

//
// Private structure returned by
// RasPortRetrieveUserData().
//
typedef struct _StoredData {
    DWORD arg;
    BOOLEAN fAuthenticated;
} StoredData;

//
// External variables
//
extern HANDLE hAcdG;
extern HANDLE hTerminatingG;



BOOLEAN
LoadRasDlls()
{
    BOOLEAN fSuccess = FALSE;
    SC_HANDLE hSCManager, hService;
    SERVICE_STATUS status;
    DWORD dwErr, dwcDevices, dwDisp;

    //
    // Since these DLLs will be loaded/unloaded
    // by multiple threads, we must do this under
    // a mutex.
    //
    EnterCriticalSection(&csRasG);
    //
    // If the DLLs have already been successfully
    // loaded, no further processing is necessary.
    //
    if (nRasReferencesG) {
        fSuccess = TRUE;
        goto done;
    }
#ifdef notdef
    //
    // Get a service controller handle on
    // the rasman service.
    //
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager == NULL)
        goto done;
    hService = OpenService(
                 hSCManager,
                 TEXT(RASMAN_SERVICE_NAME),
                 SERVICE_START|SERVICE_QUERY_STATUS);
    if (hService == NULL) {
        CloseServiceHandle(hSCManager);
        goto done;
    }
    //
    // Start the rasman service if necessary.
    //
    do {
        if (!QueryServiceStatus(hService, &status))
            break;
        switch (status.dwCurrentState) {
        case SERVICE_STOP_PENDING:
        case SERVICE_START_PENDING:
            Sleep(500);
            break;
        case SERVICE_STOPPED:
            StartService(hService, 0, NULL);
            break;
        case SERVICE_RUNNING:
            break;
        }
    } while (status.dwCurrentState != SERVICE_RUNNING);
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCManager);
    if (status.dwCurrentState != SERVICE_RUNNING) {
        RASAUTO_TRACE("LoadRasDlls: Could not start rasman service");
        goto done;
    }
#endif
    //
    // Load rasapi32.dll.
    //
    hRasApiG = LoadLibrary(RASAPI_MODULE);
    if (hRasApiG == NULL) {
        RASAUTO_TRACE("LoadRasDlls: couldn't load rasapi32.dll");
        goto done;
    }
    lpfnRasDialG = GetProcAddress(hRasApiG, RASDIAL);
    lpfnRasEnumConnectionsG = GetProcAddress(hRasApiG, RASENUMCONNECTIONS);
    lpfnRasEnumEntriesG = GetProcAddress(hRasApiG, RASENUMENTRIES);
    lpfnRasGetConnectStatusG = GetProcAddress(hRasApiG, RASGETCONNECTSTATUS );
    lpfnRasGetHportG = GetProcAddress(hRasApiG, RASGETHPORT);
    lpfnRasGetProjectionInfoG = GetProcAddress(hRasApiG, RASGETPROJECTIONINFO);
    lpfnRasGetEntryPropertiesG = GetProcAddress(hRasApiG, RASGETENTRYPROPERTIES);
    lpfnRasGetAutodialAddressG = GetProcAddress(hRasApiG, RASGETAUTODIALADDRESS);
    lpfnRasSetAutodialAddressG = GetProcAddress(hRasApiG, RASSETAUTODIALADDRESS);
    lpfnRasEnumAutodialAddressesG = GetProcAddress(hRasApiG, RASENUMAUTODIALADDRESSES);
    lpfnRasGetAutodialEnableG = GetProcAddress(hRasApiG, RASGETAUTODIALENABLE);
    lpfnRasSetAutodialEnableG = GetProcAddress(hRasApiG, RASSETAUTODIALENABLE);
    lpfnRasAutodialAddressToNetworkG =
      GetProcAddress(hRasApiG, RASAUTODIALADDRESSTONETWORK);
    lpfnRasAutodialEntryToNetworkG =
      GetProcAddress(hRasApiG, RASAUTODIALENTRYTONETWORK);
    lpfnRasConnectionNotificationG =
      GetProcAddress(hRasApiG, RASCONNECTIONNOTIFICATION);
    lpfnRasGetAutodialParamG = GetProcAddress(hRasApiG, RASGETAUTODIALPARAM);
    lpfnRasSetAutodialParamG = GetProcAddress(hRasApiG, RASSETAUTODIALPARAM);
    lpfnRasQuerySharedAutoDialG = GetProcAddress(hRasApiG, RASQUERYSHAREDAUTODIAL);
    lpfnRasQuerySharedConnectionG = GetProcAddress(hRasApiG, RASQUERYSHAREDCONNECTION);
    lpfnRasQueryRedialOnLinkFailureG = GetProcAddress(hRasApiG, RASQUERYREDIALONLINKFAILURE);
    lpfnRasGetCredentialsG = GetProcAddress(hRasApiG, RASGETCREDENTIALS);
    lpfnRasHangUpG = GetProcAddress(hRasApiG, RASHANGUP);
    if (!lpfnRasEnumConnectionsG || !lpfnRasEnumEntriesG ||
        !lpfnRasGetConnectStatusG || !lpfnRasGetHportG ||
        !lpfnRasGetProjectionInfoG || !lpfnRasGetAutodialAddressG ||
        !lpfnRasSetAutodialAddressG || !lpfnRasEnumAutodialAddressesG ||
        !lpfnRasGetAutodialEnableG || !lpfnRasSetAutodialEnableG ||
        !lpfnRasAutodialAddressToNetworkG || !lpfnRasAutodialEntryToNetworkG ||
        !lpfnRasConnectionNotificationG || !lpfnRasGetAutodialParamG ||
        !lpfnRasSetAutodialParamG || !lpfnRasQuerySharedConnectionG ||
        !lpfnRasQuerySharedAutoDialG || !lpfnRasQueryRedialOnLinkFailureG ||
        !lpfnRasGetCredentialsG || !lpfnRasHangUpG)
    {
        RASAUTO_TRACE("LoadRasDlls: couldn't find entrypoints in rasapi32.dll");
        goto done;
    }
    //
    // Load rasman.dll.
    //
    hRasManG = LoadLibrary(RASMAN_MODULE);
    if (hRasManG == NULL) {
        RASAUTO_TRACE("LoadRasDlls: couldn't load rasman.dll");
        goto done;
    }
    lpfnRasPortRetrieveUserDataG = GetProcAddress(
                                     hRasManG,
                                     RASPORTRETRIEVEUSERDATA);
    lpfnRasPortEnumProtocolsG = GetProcAddress(hRasManG, RASPORTENUMPROTOCOLS);
    lpfnRasPortEnumG = GetProcAddress(hRasManG, RASPORTENUM);
    lpfnRasInitializeG = GetProcAddress(hRasManG, RASINITIALIZE);
    lpfnRasReferenceRasmanG = GetProcAddress(hRasManG, RASREFERENCERASMAN);
    lpfnRasPortOpenG = GetProcAddress(hRasManG, RASPORTOPEN);
    lpfnRasPortCloseG = GetProcAddress(hRasManG, RASPORTCLOSE);
    lpfnRasGetInfoG = GetProcAddress(hRasManG, RASGETINFO);
    lpfnRasGetPortUserDataG = GetProcAddress(hRasManG, RASGETPORTUSERDATA);
    lpfnRasRegisterRedialCallbackG = GetProcAddress(
                                       hRasManG,
                                       RASREGISTERREDIALCALLBACK);
    if (!lpfnRasPortRetrieveUserDataG ||
        !lpfnRasPortEnumProtocolsG ||
        !lpfnRasPortEnumG ||
        !lpfnRasInitializeG ||
        !lpfnRasReferenceRasmanG ||
        !lpfnRasPortOpenG ||
        !lpfnRasPortCloseG ||
        !lpfnRasGetInfoG ||
        !lpfnRasGetPortUserDataG ||
        !lpfnRasRegisterRedialCallbackG ||
        (*lpfnRasInitializeG)() ||
        (*lpfnRasReferenceRasmanG)(TRUE))
    {
        RASAUTO_TRACE("LoadRasDlls: couldn't find entrypoints in rasman.dll");
        goto done;
    }
    //
    // rasman will let us know when to invoke redial-on-link-failure
    // and for which phonebook entry.
    //
    SetRedialOnLinkFailureHandler((FARPROC)AcsRedialOnLinkFailure);
    RASAUTO_TRACE("LoadRasDlls: set redial-on-link-failure handler");
    //
    // rasapi32 will let us when new RAS connections
    // are created or destroyed by signaling our
    // event.
    //
    dwErr = (DWORD)(*lpfnRasConnectionNotificationG)(
                         INVALID_HANDLE_VALUE,
                         hConnectionEventG,
                         RASCN_Connection|RASCN_Disconnection);
    RASAUTO_TRACE1("LoadRasDlls: RasConnectionNotification returned dwErr=%d", dwErr);
    fSuccess = !dwErr;

done:
    if (fSuccess) {
#ifdef notdef
// for now, we don't need multiple references
        nRasReferencesG++;
#endif
        nRasReferencesG = 1;
    }
    else {
        if (hRasManG != NULL)
            FreeLibrary(hRasManG);
        if (hRasApiG != NULL)
            FreeLibrary(hRasApiG);
        hRasManG = hRasApiG = NULL;
    }
    LeaveCriticalSection(&csRasG);

    return fSuccess;
} // LoadRasDlls



VOID
UnloadRasDlls()
{
    DWORD dwErr;

    //
    // Since these DLLs will be loaded/unloaded
    // by multiple threads, we must do this under
    // a mutex.
    //
    EnterCriticalSection(&csRasG);
    if (nRasReferencesG) {
        //
        // Unregister the callback function for
        // redial on link failure
        //
        (void)(*lpfnRasRegisterRedialCallbackG)(NULL);
        //
        // Inform rasman.dll we are unloading it.
        //
        (void)(*lpfnRasReferenceRasmanG)(FALSE);
        if (hRasApiG != NULL)
            FreeLibrary(hRasApiG);
        if (hRasManG != NULL)
            FreeLibrary(hRasManG);
        nRasReferencesG--;
    }

    LeaveCriticalSection(&csRasG);
} // UnloadRasDlls



BOOLEAN
RasDllsLoaded()
{
    BOOLEAN fLoaded;

    EnterCriticalSection(&csRasG);
    fLoaded = (BOOLEAN)nRasReferencesG;
    LeaveCriticalSection(&csRasG);

    return fLoaded;
} // RasDllsLoaded



DWORD
ActiveConnections(
    IN BOOLEAN fAuthenticated,
    OUT LPTSTR **lppEntryNames,
    OUT HRASCONN **lpphRasConn
    )

/*++

DESCRIPTION
    Enumerate the list of active RAS connections, and put the
    phone book entry names in lppEntryNames.  Return the number
    of entries in the list.

ARGUMENTS
    fAuthenticated: TRUE if the resulting arrays should contain
        only authenticated entries.

    lppEntryNames: a pointer which is set to the allocated array
        of phone book entry names.

    lpphRasConn: a pointer which is set to the allocated array
        of RASCONN descriptors corresponding to the phone book
        entries.

RETURN VALUE
    The number of entries in lppEntryNames.

--*/

{
    RASCONN RasCon;
    RASCONN *lpRasCon = NULL;
    DWORD dwStatus;
    DWORD dwSize;
    DWORD dwConnections;
    DWORD dwRealConnections = 0;
    DWORD dwIndex;
    RASCONNSTATUS RasConStatus;
    HPORT hPort;
    PBYTE lpUserData = NULL;
    BOOLEAN fEntryAuthenticated;

    //
    // Initialize return values.
    //
    if (lppEntryNames != NULL)
        *lppEntryNames = NULL;
    if (lpphRasConn != NULL)
        *lpphRasConn = NULL;
    //
    // Allow this routine to be called
    // even when the RAS dlls are not loaded.
    //
    if (!RasDllsLoaded())
        goto done;
    //
    // Get the number of active connections.  We
    // allocate a buffer large enough for one connection
    // initially, and reallocate it if it's too small.
    //
    lpRasCon = LocalAlloc(LPTR, sizeof (RASCONN));
    if (lpRasCon == NULL) {
        RASAUTO_TRACE("ActiveConnections: LocalAlloc failed");
        goto done;
    }
    lpRasCon[0].dwSize = sizeof (RASCONN);
    dwSize = sizeof (RASCONN);
    dwStatus = (DWORD)(*lpfnRasEnumConnectionsG)(lpRasCon, &dwSize, &dwConnections);
    if (dwStatus == ERROR_BUFFER_TOO_SMALL) {
        //
        // Buffer's too small.  Reallocate and try again.
        //
        LocalFree(lpRasCon);
        lpRasCon = LocalAlloc(LPTR, dwSize);
        if (lpRasCon == NULL) {
            RASAUTO_TRACE("ActiveConnections: LocalAlloc failed");
            goto done;
        }
        lpRasCon[0].dwSize = sizeof (RASCONN);
        dwStatus = (DWORD)(*lpfnRasEnumConnectionsG)(
                             lpRasCon,
                             &dwSize,
                             &dwConnections);
    }
    if (dwStatus) {
        RASAUTO_TRACE1(
          "ActiveConnections: RasEnumConnections failed (dwStatus=0x%x)",
          dwStatus);
        goto done;
    }
    //
    // Short-circuit the rest if there
    // are no connections.
    //
    if (!dwConnections)
        goto done;
    //
    // Allocate the user's return buffers,
    // if necessary.
    //
    if (lppEntryNames != NULL) {
        *lppEntryNames = LocalAlloc(LPTR, (dwConnections+1) * sizeof (LPTSTR));
        if (*lppEntryNames == NULL) {
            RASAUTO_TRACE("ActiveConnections: LocalAlloc failed");
            goto done;
        }
    }
    if (lpphRasConn != NULL) {
        *lpphRasConn = LocalAlloc(LPTR, (dwConnections+1) * sizeof (HRASCONN));
        if (*lpphRasConn == NULL) {
            RASAUTO_TRACE("ActiveConnections: LocalAlloc failed");
            goto done;
        }
    }
    //
    // Go through each connection, and
    // check to see if the connection's
    // passed the authentication phase yet.
    //
    for (dwIndex = 0; dwIndex < dwConnections; dwIndex++) {
        RasConStatus.dwSize = sizeof (RASCONNSTATUS);
        dwStatus = (DWORD)(*lpfnRasGetConnectStatusG)(
                             lpRasCon[dwIndex].hrasconn,
                             &RasConStatus);
        if (dwStatus) {
            RASAUTO_TRACE2(
              "ActiveConnections: RasGetConnectStatus(%S) failed (dwStatus=0x%x)",
              lpRasCon[dwIndex].szEntryName,
              dwStatus);
            continue;
        }
        //
        // If the connection is not connected,
        // then skip it.
        //
        RASAUTO_TRACE2("ActiveConnections: state for hrasconn 0x%x is %d",
          lpRasCon[dwIndex].hrasconn,
          RasConStatus.rasconnstate);
        //
        // If the caller specified only authenticated entries
        // and the entry is not yet connected, then skip it.
        //
        if (fAuthenticated && RasConStatus.rasconnstate != RASCS_Connected)
            continue;
        if (lppEntryNames != NULL) {
            (*lppEntryNames)[dwRealConnections] =
              CopyString(lpRasCon[dwIndex].szEntryName);
        }
        if (lpphRasConn != NULL)
            (*lpphRasConn)[dwRealConnections] = lpRasCon[dwIndex].hrasconn;
        RASAUTO_TRACE2(
          "ActiveConnections: (%S, 0x%x)",
          lpRasCon[dwIndex].szEntryName,
          lpRasCon[dwIndex].hrasconn);
        dwRealConnections++;
    }

done:
    if (lpRasCon != NULL)
        LocalFree(lpRasCon);
    if (lpUserData != NULL)
        LocalFree(lpUserData);
    if (!dwRealConnections) {
        if (lppEntryNames != NULL) {
            if (*lppEntryNames != NULL) {
                LocalFree(*lppEntryNames);
                *lppEntryNames = NULL;
            }
        }
        if (lpphRasConn != NULL) {
            if (*lpphRasConn != NULL) {
                LocalFree(*lpphRasConn);
                *lpphRasConn = NULL;
            }
        }
    }
    return dwRealConnections;
} // ActiveConnections



LPTSTR
AddressToNetwork(
    LPTSTR pszAddress
    )
{
    DWORD dwErr, dwSize;
    LPTSTR pszNetwork = NULL;

    //
    // Map an address to a network name
    // by calling a (currently) private rasapi32 API.
    //
    dwSize = 0;
    dwErr = (DWORD)(*lpfnRasAutodialAddressToNetworkG)(pszAddress, NULL, &dwSize);
    if (dwErr)
        goto done;
    pszNetwork = LocalAlloc(LPTR, dwSize);
    if (pszNetwork == NULL) {
        dwErr = GetLastError();
        goto done;
    }
    dwErr = (DWORD)(*lpfnRasAutodialAddressToNetworkG)(
                      pszAddress,
                      pszNetwork,
                      &dwSize);

done:
    return (!dwErr ? pszNetwork : NULL);
} // AddressToNetwork



LPTSTR
EntryToNetwork(
    LPTSTR pszEntry
    )
{
    DWORD dwErr, dwSize;
    LPTSTR pszNetwork = NULL;

    //
    // Map an address to a network name
    // by calling a (currently) private rasapi32 API.
    //
    dwSize = 0;
    dwErr = (DWORD)(*lpfnRasAutodialEntryToNetworkG)(pszEntry, NULL, &dwSize);
    if (dwErr)
        goto done;
    pszNetwork = LocalAlloc(LPTR, dwSize);
    if (pszNetwork == NULL) {
        dwErr = GetLastError();
        goto done;
    }
    dwErr = (DWORD)(*lpfnRasAutodialEntryToNetworkG)(
                      pszEntry,
                      pszNetwork,
                      &dwSize);

done:
    return (!dwErr ? pszNetwork : NULL);
} // EntryToNetwork



DWORD
AutoDialEnabled(
    IN PBOOLEAN lpfEnabled
    )
{
    DWORD dwErr, dwLocationID;
    BOOL fEnabled;

    //
    // If there is no dialing location
    // defined, then return FALSE.
    //
    dwErr = TapiCurrentDialingLocation(&dwLocationID);
    if (dwErr) {
        *lpfEnabled = FALSE;
        return 0;
    }
    dwErr = (DWORD)(*lpfnRasGetAutodialEnableG)(dwLocationID, &fEnabled);
    if (dwErr)
        return dwErr;
    *lpfEnabled = (BOOLEAN)fEnabled;

    return 0;
} // AutoDialEnabled



DWORD
DisableAutoDial()
{
    DWORD dwErr, dwLocationID;

    dwErr = TapiCurrentDialingLocation(&dwLocationID);
    if (dwErr)
        return dwErr;

    return (DWORD)(*lpfnRasSetAutodialEnableG)(dwLocationID, (BOOL)FALSE);
} // DisableAutoDial



BOOLEAN
PortAvailable(
    IN LPTSTR lpszDeviceType,
    IN LPTSTR lpszDeviceName
    )

/*++

DESCRIPTION
    Determines whether there is a free port
    available to dial the specified entry.

ARGUMENTS
    lpszDeviceType: a pointer to the device type string

    lpszDeviceName: a pointer to the device name string

RETURN VALUE
    TRUE if one or more of the correct port
    type is free; FALSE otherwise.

--*/

{
    DWORD       dwErr;
    DWORD       dwSize = 0, 
                dwEntries, i;
    RASMAN_PORT *pPorts = NULL;
    BOOLEAN     fFound  = FALSE, 
                fOtherType;
    BOOLEAN     fTypeMatch, fNameMatch;
    LPSTR       lpszAnsiDeviceType = NULL, 
                lpszAnsiDeviceName = NULL;

    //
    // If fOtherType is TRUE, then we compare
    // the RASMAN media type with the device type.
    //
    fOtherType = (_wcsicmp(lpszDeviceType, RASDT_Modem) &&
                    _wcsicmp(lpszDeviceType, RASDT_Isdn) &&
                    _wcsicmp(lpszDeviceType, RASDT_X25) &&
                    _wcsicmp(lpszDeviceType, L"VPN"));
    //
    // Convert lpszDeviceType to Ansi so
    // we can compare with rasman's version.
    //
    lpszAnsiDeviceType = UnicodeStringToAnsiString(
                           lpszDeviceType,
                           NULL,
                           0);
    if (lpszAnsiDeviceType == NULL)
        goto done;
    lpszAnsiDeviceName = UnicodeStringToAnsiString(
                           lpszDeviceName,
                           NULL,
                           0);
    if (lpszAnsiDeviceName == NULL)
        goto done;
    //
    // Get a list of ports.
    //
    dwErr = (DWORD)(*lpfnRasPortEnumG)(NULL, NULL, &dwSize, &dwEntries);
    if (!dwErr || dwErr != ERROR_BUFFER_TOO_SMALL) {
        RASAUTO_TRACE1("PortAvailable: RasPortEnum failed (dwErr=%d)", dwErr);
        goto done;
    }
    pPorts = LocalAlloc(LPTR, dwSize);
    if (pPorts == NULL) {
        RASAUTO_TRACE("PortAvailable: LocalAlloc failed");
        goto done;
    }
    dwErr = (DWORD)(*lpfnRasPortEnumG)(NULL, pPorts, &dwSize, &dwEntries);
    if (dwErr) {
        RASAUTO_TRACE1("PortAvailable: RasPortEnum failed (dwErr=%d)", dwErr);
        goto done;
    }
    for (i = 0; i < dwEntries; i++) {
        RASMAN_INFO info;

        RASAUTO_TRACE6(
          "PortAvailable: lpszAnsiDeviceType=%s, lpszAnsiDeviceName=%s, "
          "media=%s, type=%s, name=%s, usage=%d",
          lpszAnsiDeviceType,
          lpszAnsiDeviceName,
          pPorts[i].P_MediaName,
          pPorts[i].P_DeviceType,
          pPorts[i].P_DeviceName,
          pPorts[i].P_ConfiguredUsage);
        RASAUTO_TRACE2("PortAvailable: status=%d, current usage=%d",
                pPorts[i].P_Status,
                pPorts[i].P_CurrentUsage);
        //
        // Only interested in dial-out and biplex ports.
        //
        if (!(pPorts[i].P_ConfiguredUsage & CALL_OUT)
            && !(pPorts[i].P_ConfiguredUsage & CALL_OUT_ONLY))
            continue;
        RtlZeroMemory(&info, sizeof (info));

        //
        // If the port has already been opened for call out
        // fail the call.
        //
        ZeroMemory(&info, sizeof(RASMAN_INFO));

        dwErr = RasGetInfo(NULL,
                            pPorts[i].P_Handle,
                            &info);

        if(NO_ERROR == dwErr)
        {
            if(info.RI_dwFlags & RASMAN_OPEN_CALLOUT)
            {
                RASAUTO_TRACE("Port already open for call out");
                continue;
            }
        }

        if (pPorts[i].P_Status == OPEN) {
            dwErr = (DWORD)(*lpfnRasGetInfoG)(NULL, pPorts[i].P_Handle, &info);
            if (dwErr) {
                RASAUTO_TRACE1("PortAvailable: RasGetInfo failed (dwErr=%d)", dwErr);
                goto statecheck;
            }
        }

#if 0
        //
        // Determine if the connection associated with a
        // disconnected port has gone away.  In this case,
        // we can close the port and attempt to reopen
        // it.  This is essentially what rasapi32/RasDial()
        // when it determines if a port is available for
        // dialing out.
        //
        if (pPorts[i].P_Status == OPEN &&
            info.RI_ConnState == DISCONNECTED &&
            info.RI_ConnectionHandle)
        {
            RASCONNSTATE connstate;
            DWORD dwSize = sizeof (RASCONNSTATE);

            RASAUTO_TRACE1(
              "PortAvailable: Open disconnected port %d found",
              pPorts[i].P_Handle);
            dwErr = (DWORD)(*lpfnRasGetPortUserDataG)(
                              pPorts[i].P_Handle,
                              3, // PORT_CONNSTATE_INDEX
                              &connstate,
                              &dwSize);
            RASAUTO_TRACE2(
              "PortAvailable: RasGetPortUserData(%d), connstate=%d",
              dwErr,
              connstate);
            if (!dwErr &&
                (connstate < RASCS_PrepareForCallback ||
                connstate > RASCS_WaitForCallback))
            {
                RASAUTO_TRACE1(
                  "PortAvailable: RasPortClose(%d)...",
                  pPorts[i].P_Handle);
                dwErr = (DWORD)(*lpfnRasPortCloseG)(pPorts[i].P_Handle);
                RASAUTO_TRACE1("PortAvailable: RasPortClose done(%d)", dwErr);
                //
                // Since we've closed the port,
                // update the P_Status field manually.
                //
                if (!dwErr)
                    pPorts[i].P_Status = CLOSED;
            }
        }

#endif
        //
        // Only interested in dial-out ports if the port
        // is closed.  Biplex port opens, on the other
        // hand, may succeed even if the port is
        // open.
        //
statecheck:
        if (pPorts[i].P_ConfiguredUsage == CALL_OUT
            && pPorts[i].P_Status != CLOSED)
        {
            RASAUTO_TRACE("Port is not available for call_out");
            continue;
        }

        fTypeMatch =
            (!_stricmp(lpszAnsiDeviceType, pPorts[i].P_DeviceType)) ||
              (fOtherType && !_stricmp(lpszAnsiDeviceType, pPorts[i].P_MediaName));
        fNameMatch = !_stricmp(lpszAnsiDeviceName, pPorts[i].P_DeviceName);
        if (fTypeMatch && fNameMatch) {

            fFound = TRUE;

        }
    }

done:
    //
    // Free resources.
    //
    if (lpszAnsiDeviceType != NULL)
        LocalFree(lpszAnsiDeviceType);
    if (lpszAnsiDeviceName != NULL)
        LocalFree(lpszAnsiDeviceName);
    if (pPorts != NULL)
        LocalFree(pPorts);
    return fFound;
} // PortAvailable

DWORD
DisableAddress(PACD_ADDR pAddr)
{
    DWORD retcode = SUCCESS;
    LPTSTR pszAddress = NULL;

    LockDisabledAddresses();
    ASSERT(NULL != pDisabledAddressesG);

    pszAddress = AddressToUnicodeString(pAddr);

    if(NULL == pszAddress)
    {
        retcode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    PutTableEntry(pDisabledAddressesG, pszAddress, NULL);

done:

    if(NULL != pszAddress)
    {
        LocalFree(pszAddress);
    }

    UnlockDisabledAddresses();

    return retcode;
}


BOOLEAN
StartAutoDialer(
    IN HANDLE hProcess,
    IN PACD_ADDR pAddr,
    IN LPTSTR lpAddress,
    IN LPTSTR lpEntryName,
    IN BOOLEAN fSharedAccess,
    OUT PBOOLEAN pfInvalidEntry
    )
{
    NTSTATUS status;
    BOOLEAN fSuccess = FALSE, fEntryFound = FALSE;
    BOOLEAN fUseRasDial, fDialerPresent, fDialerKilled;
    DWORD dwStatus, dwSize, dwIndex, dwEntries, dwCount = 0;
    TCHAR *pszCmdLine = NULL;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    DWORD dwPreConnections, dwConnections;
    DWORD dwExitCode = STILL_ACTIVE;
    HANDLE hToken;
    IO_STATUS_BLOCK ioStatusBlock;
    ACD_STATUS connStatus;
    DWORD dwErr;
    BOOL fDisableAddress = FALSE;
    PVOID pEnvBlock = NULL;

    //
    // Initialization of various variables.
    //
    *pfInvalidEntry = FALSE;
    memset(&StartupInfo, 0, sizeof (StartupInfo));
    memset(&ProcessInfo, 0, sizeof (ProcessInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    StartupInfo.lpDesktop = TEXT("winsta0\\default");
    //
    // Read the phonebook entry to determine whether
    // we need to load a custom AutoDial UI.
    //
    if (lpEntryName != NULL) {
        DWORD dwIgnore;
        LPRASENTRY lpEntry;

        dwErr = (DWORD)(*lpfnRasGetEntryPropertiesG)(
                          NULL,
                          lpEntryName,
                          NULL,
                          &dwSize,
                          NULL,
                          &dwIgnore);
        if (dwErr == ERROR_CANNOT_FIND_PHONEBOOK_ENTRY) {
            //
            // If the phonebook entry has been renamed
            // or deleted, then ask again for an entry.
            //
            lpEntryName = NULL;
            dwErr = 0;
            goto fmtcmd;
        }
        else if (dwErr != ERROR_BUFFER_TOO_SMALL) {
            *pfInvalidEntry = TRUE;
            RASAUTO_TRACE2(
              "StartAutoDialer: RasGetEntryProperties(%S) failed (dwErr=%d)",
              RASAUTO_TRACESTRW(lpEntryName),
              dwErr);
            goto done;
        }
        lpEntry = LocalAlloc(LPTR, dwSize);
        if (lpEntry == NULL) {
            RASAUTO_TRACE("StartAutoDialer: LocalAlloc failed");
            goto done;
        }
        lpEntry->dwSize = sizeof (RASENTRY);
        dwErr = (DWORD)(*lpfnRasGetEntryPropertiesG)(
                          NULL,
                          lpEntryName,
                          lpEntry,
                          &dwSize,
                          NULL,
                          &dwIgnore);
        if (dwErr) {
            *pfInvalidEntry = TRUE;
            RASAUTO_TRACE2(
              "StartAutoDialer: RasGetEntryProperties(%S) failed (dwErr=%d)",
              RASAUTO_TRACESTRW(lpEntryName),
              dwErr);
            LocalFree(lpEntry);
            lpEntry = NULL;
            goto done;
        }

        //
        // While we have the phonebook entry
        // verify there is an available port
        // to dial.
        //
        if (!PortAvailable(lpEntry->szDeviceType, lpEntry->szDeviceName)) {
            RASAUTO_TRACE("StartAutoDialer: no port available");
            LocalFree(lpEntry);
            goto done;
        }
        if (*lpEntry->szAutodialDll != L'\0' &&
            *lpEntry->szAutodialFunc != L'\0')
        {
            //
            // Allocate pszCmdLine
            //
            pszCmdLine = LocalAlloc(
                                LPTR,
                                ( lstrlen(RASAUTOUI_CUSTOMDIALENTRY)
                                + lstrlen(lpEntry->szAutodialDll)
                                + lstrlen(lpEntry->szAutodialFunc)
                                + lstrlen(lpEntryName)
                                + 1) * sizeof(TCHAR));

            if(NULL == pszCmdLine)
            {
                RASAUTO_TRACE1("StartAutoDialer: Failed to allocate pszcmdline. 0x%x", 
                      dwErr);

                goto done;                      
            }
            
            //
            // Run a special program that loads the
            // AutoDial DLL and calls the correct
            // DLL entrypoint.
            //
            wsprintf(
              pszCmdLine,
              RASAUTOUI_CUSTOMDIALENTRY,
              lpEntry->szAutodialDll,
              lpEntry->szAutodialFunc,
              lpEntryName);
        }
        LocalFree(lpEntry);
    }
fmtcmd:
    //
    // Ping the driver before we start
    // the dialing dialer to make sure
    // the connection is still valid.
    //
    if (pAddr)
    {
        connStatus.fSuccess = FALSE;
        RtlCopyMemory(&connStatus.addr, pAddr, sizeof (ACD_ADDR));
        status = NtDeviceIoControlFile(
                   hAcdG,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_ACD_KEEPALIVE,
                   &connStatus,
                   sizeof (connStatus),
                   NULL,
                   0);
        if (status != STATUS_SUCCESS) {
            RASAUTO_TRACE1(
              "StartAutoDialer: NtDeviceIoControlFile(IOCTL_ACD_KEEPALIVE) failed (status=0x%x)",
              status);
            goto done;
        }
    }
    if (NULL == pszCmdLine)
    {
        //
        // Construct the command line when there
        // is not a custom dial DLL.
        //
        if (lpEntryName != NULL)
        {   
            pszCmdLine = LocalAlloc(
                                    LPTR,
                                    ( lstrlen(RASAUTOUI_DEFAULTDIALENTRY2)
                                    + lstrlen(lpAddress)
                                    + lstrlen(lpEntryName)
                                    + 1) * sizeof(TCHAR));

            if(NULL == pszCmdLine)
            {
                dwErr = GetLastError();
                goto done;
            }
                                    
            if (fSharedAccess)
                wsprintf(pszCmdLine, RASAUTOUI_DEFAULTDIALENTRY2, lpAddress, lpEntryName);
            else
                wsprintf(pszCmdLine, RASAUTOUI_DEFAULTDIALENTRY, lpAddress, lpEntryName);
        }
        else
        {
            pszCmdLine = LocalAlloc(
                                    LPTR,
                                    ( lstrlen(RASAUTOUI_NOENTRY)
                                    + lstrlen(lpAddress)
                                    + 1) * sizeof(TCHAR));

            if(NULL == pszCmdLine)
            {
                dwErr = GetLastError();
                goto done;
            }
                                    
            wsprintf(pszCmdLine, RASAUTOUI_NOENTRY, lpAddress);
        }
    }
    
    RASAUTO_TRACE1("StartAutoDialer: szCmdLine=%S", pszCmdLine);
    //
    // Exec the process.
    //
    if (!OpenProcessToken(
          hProcess,
          TOKEN_ALL_ACCESS,
          &hToken))
    {
        RASAUTO_TRACE1(
          "StartAutoDialer: OpenProcessToken failed (dwErr=%d)",
          GetLastError());
        goto done;
    }

    if (!CreateEnvironmentBlock(
          &pEnvBlock, 
          hToken,
          FALSE))
    {
        TRACE1(
          "StartAutoDialer: CreateEnvironmentBlock failed (dwErr=%d)",
          GetLastError());
        goto done;
    }

    if (!CreateProcessAsUser(
          hToken,
          NULL,
          pszCmdLine,
          NULL,
          NULL,
          FALSE,
          NORMAL_PRIORITY_CLASS|DETACHED_PROCESS|CREATE_UNICODE_ENVIRONMENT,
          pEnvBlock,
          NULL,
          &StartupInfo,
          &ProcessInfo))
    {
        RASAUTO_TRACE2(
          "StartAutoDialer: CreateProcessAsUser(%S) failed (error=0x%x)",
          pszCmdLine,
          GetLastError());
        CloseHandle(hToken);
        goto done;
    }
    RASAUTO_TRACE1("StartAutoDialer: started pid %d", ProcessInfo.dwProcessId);
    CloseHandle(hToken);
    CloseHandle(ProcessInfo.hThread);
    //
    // Now that we've started the process, we need to
    // wait until we think the connection has
    // been made.
    //
    fDialerPresent = TRUE;
    dwPreConnections = ActiveConnections(TRUE, NULL, NULL);
    while (dwCount++ < 0xffffffff) {
        //
        // Sleep for one second.
        //
        status = WaitForSingleObject(hTerminatingG, 1000);
        if (status == WAIT_OBJECT_0)
            goto done;
        //
        // Ping the driver to let it
        // know we are working on the
        // request.
        //
        if (pAddr)
        {
            connStatus.fSuccess = FALSE;
            RtlCopyMemory(&connStatus.addr, pAddr, sizeof (ACD_ADDR));
            status = NtDeviceIoControlFile(
                       hAcdG,
                       NULL,
                       NULL,
                       NULL,
                       &ioStatusBlock,
                       IOCTL_ACD_KEEPALIVE,
                       &connStatus,
                       sizeof (connStatus),
                       NULL,
                       0);
            if (status != STATUS_SUCCESS) {
                RASAUTO_TRACE1(
                  "StartAutoDialer: NtDeviceIoControlFile(IOCTL_ACD_KEEPALIVE) failed (status=0x%x)",
                  status);
                // goto done;
            }
        }
        //
        // Check to see if there are any connections yet.
        // If there are, then we are done.
        //
        dwConnections = ActiveConnections(TRUE, NULL, NULL);
        if (dwConnections > dwPreConnections) {
            RASAUTO_TRACE("StartAutoDialer: connection started");
            fSuccess = TRUE;
            goto done;
        }
        //
        // After we have determined there are
        // no active connections, check to see
        // if the dialer is still present.  This
        // was calculated on the *previous* iteration
        // of the loop.  We do this to avoid a race
        // condition of having the dialer go away
        // after we call ActiveConnections().
        //
        if (!fDialerPresent) {
            BOOLEAN fFound = FALSE;
            LPTSTR *lpConnections;

            RASAUTO_TRACE("StartAutoDialer: dialer went away!");
            if (lpEntryName != NULL) {
                //
                // Make absolutely sure if an entry was specified,
                // it is not connected before we return FALSE.
                // It's possible a connection could have been
                // in progress before we started the dialer.
                //
                dwConnections = ActiveConnections(TRUE, &lpConnections, NULL);
                if (dwConnections) {
                    for (dwIndex = 0; dwIndex < dwConnections; dwIndex++) {
                        if (!_wcsicmp(lpConnections[dwIndex], lpEntryName)) {
                            fFound = TRUE;
                            break;
                        }
                    }
                    FreeStringArray(lpConnections, dwConnections);
                    if (fFound) {
                        RASAUTO_TRACE1(
                          "StartAutoDialer: found %S on final check!",
                          RASAUTO_TRACESTRW(lpEntryName));
                    }
                }
            }
            fSuccess = fFound;
            goto done;
        }
        //
        // After 5 seconds, check to see if
        // the dialer has terminated.
        //
        if (dwCount > 5) {
            fDialerPresent =
              GetExitCodeProcess(ProcessInfo.hProcess, &dwExitCode) &&
                dwExitCode == STILL_ACTIVE;
            RASAUTO_TRACE2(
              "StartAutoDialer: GetExitCodeProcess returned %d, dwExitCode=%d",
              fDialerPresent,
              dwExitCode);

            if(ERROR_CANCELLED == dwExitCode)
            {
                RASAUTO_TRACE("User cancelled the connection attempt");
                fDisableAddress = TRUE;
            }
        }
    }

done:
    //
    // We timed out waiting for a connection.
    // If the dialer is still running kill it.
    //
    if (ProcessInfo.hProcess != NULL)
        CloseHandle(ProcessInfo.hProcess);
    //
    // Complete the connection request
    // in the driver.
    //
    if (pAddr)
    {
        connStatus.fSuccess = fSuccess;
        RtlCopyMemory(&connStatus.addr, pAddr, sizeof (ACD_ADDR));
        status = NtDeviceIoControlFile(
                   hAcdG,
                   NULL,
                   NULL,
                   NULL,
                   &ioStatusBlock,
                   IOCTL_ACD_COMPLETION,
                   &connStatus,
                   sizeof (connStatus),
                   NULL,
                   0);
        if (status != STATUS_SUCCESS) {
            RASAUTO_TRACE1(
              "StartAutoDialer: NtDeviceIoControlFile(IOCTL_ACD_COMPLETION) failed (status=0x%x)",
              status);
        }
        
        if(fDisableAddress)
        {
            DWORD retcode;
            
            retcode = DisableAddress(pAddr);

            RASAUTO_TRACE2("StartAutodialer: Disabled %S. rc=0x%x",
                    RASAUTO_TRACESTRW(lpAddress),
                    retcode);

            
        }
    }

    if (NULL != pEnvBlock)
    {
        DestroyEnvironmentBlock(pEnvBlock);
    }

    if(NULL != pszCmdLine)
    {
        LocalFree(pszCmdLine);
    }

    return fSuccess;
} // StartAutoDialer



BOOLEAN
StartReDialer(
    IN HANDLE hProcess,
    IN LPTSTR lpPhonebook,
    IN LPTSTR lpEntry
    )
{
    TCHAR szCmdLine[100];
    TCHAR *pszCmdLine = NULL;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    HANDLE hToken;
    PVOID pEnvBlock = NULL;

    //
    // Initialization of various variables.
    //
    memset(&StartupInfo, 0, sizeof (StartupInfo));
    memset(&ProcessInfo, 0, sizeof (ProcessInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    //
    // Construct the command line when there
    // is not a custom dial DLL.
    //
    pszCmdLine = LocalAlloc(
                            LPTR,
                            ( lstrlen(RASAUTOUI_REDIALENTRY)
                            + lstrlen(lpPhonebook)
                            + lstrlen(lpEntry)
                            + 1) * sizeof(TCHAR));

    if(NULL == pszCmdLine)
    {
        RASAUTO_TRACE1("StartReDialer: failed to allocate pszCmdLine. 0x%x",
               GetLastError());

        return FALSE;               
    }
                            
    wsprintf(pszCmdLine, RASAUTOUI_REDIALENTRY, lpPhonebook, lpEntry);
    RASAUTO_TRACE1("StartReDialer: szCmdLine=%S", pszCmdLine);
    //
    // Exec the process.
    //
    if (!OpenProcessToken(
          hProcess,
          TOKEN_ALL_ACCESS,
          &hToken))
    {
        RASAUTO_TRACE1(
          "StartReDialer: OpenProcessToken failed (dwErr=%d)",
          GetLastError());

        LocalFree(pszCmdLine);
        
        return FALSE;
    }

    if (!CreateEnvironmentBlock(
          &pEnvBlock, 
          hToken,
          FALSE))
    {
        TRACE1(
          "StartReDialer: CreateEnvironmentBlock failed (dwErr=%d)",
          GetLastError());

        LocalFree(pszCmdLine);

        return FALSE;
    }

    if (!CreateProcessAsUser(
          hToken,
          NULL,
          pszCmdLine,
          NULL,
          NULL,
          FALSE,
          NORMAL_PRIORITY_CLASS|DETACHED_PROCESS|CREATE_UNICODE_ENVIRONMENT,
          pEnvBlock,
          NULL,
          &StartupInfo,
          &ProcessInfo))
    {
        RASAUTO_TRACE2(
          "StartReDialer: CreateProcessAsUser(%S) failed (error=0x%x)",
          pszCmdLine,
          GetLastError());
        CloseHandle(hToken);
    
        LocalFree(pszCmdLine);

        if (pEnvBlock)
        {
            DestroyEnvironmentBlock(pEnvBlock);
        }
        
        return FALSE;
    }
    RASAUTO_TRACE1("StartReDialer: started pid %d", ProcessInfo.dwProcessId);
    CloseHandle(hToken);
    CloseHandle(ProcessInfo.hThread);

    LocalFree(pszCmdLine);

    if (pEnvBlock)
    {
        DestroyEnvironmentBlock(pEnvBlock);
    }

    return TRUE;
} // StartReDialer



DWORD
GetAddressDialingLocationInfo(
    IN LPTSTR pszAddress,
    OUT PADDRESS_LOCATION_INFORMATION *lppDialingInfo,
    OUT LPDWORD lpdwcDialingInfo
    )
{
    DWORD dwErr, dwcb, dwcEntries, i;
    LPRASAUTODIALENTRY lpAutoDialEntries;
    PADDRESS_LOCATION_INFORMATION lpDialingInfo;

    //
    // Call RAS to find out how many
    // dialing location entries there are.
    //
    dwcb = 0;
    dwErr = (DWORD)(*lpfnRasGetAutodialAddressG)(
                     pszAddress,
                     NULL,
                     NULL,
                     &dwcb,
                     &dwcEntries);
    if (dwErr && dwErr != ERROR_BUFFER_TOO_SMALL)
        return dwErr;
    if (!dwcEntries) {
        *lppDialingInfo = NULL;
        *lpdwcDialingInfo = 0;
        return 0;
    }
    lpAutoDialEntries = LocalAlloc(LPTR, dwcb);
    if (lpAutoDialEntries == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    lpAutoDialEntries->dwSize = sizeof (RASAUTODIALENTRY);
    dwErr = (DWORD)(*lpfnRasGetAutodialAddressG)(
                     pszAddress,
                     NULL,
                     lpAutoDialEntries,
                     &dwcb,
                     &dwcEntries);
    if (dwErr || (0 == dwcEntries)) {
        LocalFree(lpAutoDialEntries);
        if(0 == dwcEntries)
        {
            dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        }
        return dwErr;
    }
    //
    // Allocate our buffer.
    //
    lpDialingInfo = LocalAlloc(
                      LPTR,
                      dwcEntries * sizeof (ADDRESS_LOCATION_INFORMATION));
    if (lpDialingInfo == NULL) {
        LocalFree(lpAutoDialEntries);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    //
    // Copy this information over to our
    // buffer.
    //
    for (i = 0; i < dwcEntries; i++) {
        lpDialingInfo[i].dwLocation = lpAutoDialEntries[i].dwDialingLocation;
        lpDialingInfo[i].pszEntryName =
          CopyString(lpAutoDialEntries[i].szEntry);
    }
    //
    // Free the RAS buffer.
    //
    LocalFree(lpAutoDialEntries);
    //
    // Set return values.
    //
    *lppDialingInfo = lpDialingInfo;
    *lpdwcDialingInfo = dwcEntries;

    return 0;
} // GetAddressDialingLocationInfo



DWORD
SetAddressDialingLocationInfo(
    IN LPTSTR pszAddress,
    IN PADDRESS_LOCATION_INFORMATION lpDialingInfo
    )
{
    RASAUTODIALENTRY rasAutoDialEntry;

    //
    // Copy the caller's buffer over
    // to the RAS buffer.
    //
    rasAutoDialEntry.dwSize = sizeof (RASAUTODIALENTRY);
    rasAutoDialEntry.dwDialingLocation = lpDialingInfo->dwLocation;
    wcscpy(rasAutoDialEntry.szEntry, lpDialingInfo->pszEntryName);

    return (DWORD)(*lpfnRasSetAutodialAddressG)(
                     pszAddress,
                     0,
                     &rasAutoDialEntry,
                     sizeof (RASAUTODIALENTRY),
                     1);
} // SetAddressDialingLocationInfo



DWORD
ClearAddressDialingLocationInfo(
    IN LPTSTR pszAddress
    )
{
    return (DWORD)(*lpfnRasSetAutodialAddressG)(pszAddress, 0, NULL, 0, 0);
} // ClearAddressDialingLocationInfo



DWORD
GetAddressParams(
    IN LPTSTR pszAddress,
    IN PADDRESS_PARAMS lpParams
    )
{
    HKEY hkey;
    DWORD dwErr, dwSize, dwType;
    LPTSTR lpszAddressKey;

    //
    // Initialize address map fields.
    //
    lpParams->dwTag = ADDRMAP_TAG_NONE;
    lpParams->dwModifiedTime = 0;
    //
    // Read the values from the registry.
    //
    lpszAddressKey = LocalAlloc(
                       LPTR,
                       (lstrlen(AUTODIAL_REGADDRESSBASE) +
                         lstrlen(pszAddress) + 2) * sizeof (TCHAR));
    if (lpszAddressKey == NULL)
        return 0;
    wsprintf(lpszAddressKey, L"%s\\%s", AUTODIAL_REGADDRESSBASE, pszAddress);

    LockImpersonation();

    //
    // Make sure we have hkcu
    //

    dwErr = DwGetHkcu();

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }
    
    dwErr = RegOpenKeyEx(
              hkeyCUG,
              lpszAddressKey,
              0,
              KEY_READ,
              &hkey);
    if (dwErr) {
        LocalFree(lpszAddressKey);
        goto done;
    }
    dwSize = sizeof (DWORD);
    dwErr = RegQueryValueEx(
              hkey,
              AUTODIAL_REGTAGVALUE,
              NULL,
              &dwType,
              (PVOID)&lpParams->dwTag,
              &dwSize);
    if (dwErr || dwType != REG_DWORD)
        lpParams->dwTag = ADDRMAP_TAG_NONE;
    dwSize = sizeof (DWORD);
    dwErr = RegQueryValueEx(
              hkey,
              AUTODIAL_REGMTIMEVALUE,
              NULL,
              &dwType,
              (PVOID)&lpParams->dwModifiedTime,
              &dwSize);
    if (dwErr || dwType != REG_DWORD)
        lpParams->dwModifiedTime = 0;
    RegCloseKey(hkey);
    LocalFree(lpszAddressKey);

    dwErr = ERROR_SUCCESS;

done:

    UnlockImpersonation();
    return dwErr;
} // GetAddressParams



DWORD
SetAddressParams(
    IN LPTSTR pszAddress,
    IN PADDRESS_PARAMS lpParams
    )
{
    HKEY hkey;
    DWORD dwErr, dwSize, dwDisp;
    LPTSTR lpszAddressKey;

    //
    // Write the values to the registry.
    //
    lpszAddressKey = LocalAlloc(
                       LPTR,
                       (lstrlen(AUTODIAL_REGADDRESSBASE) +
                         lstrlen(pszAddress) + 2) * sizeof (TCHAR));
    if (lpszAddressKey == NULL)
        return 0;
    wsprintf(lpszAddressKey, L"%s\\%s", AUTODIAL_REGADDRESSBASE, pszAddress);


    LockImpersonation();

    //
    // Make sure we have hkcu
    //

    dwErr = DwGetHkcu();

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    
    dwErr = RegCreateKeyEx(
              hkeyCUG,
              lpszAddressKey,
              0,
              NULL,
              REG_OPTION_NON_VOLATILE,
              KEY_ALL_ACCESS,
              NULL,
              &hkey,
              &dwDisp);
    if (dwErr) {
        LocalFree(lpszAddressKey);
        goto done;
    }
    dwErr = RegSetValueEx(
              hkey,
              AUTODIAL_REGTAGVALUE,
              0,
              REG_DWORD,
              (PVOID)&lpParams->dwTag,
              sizeof (DWORD));
    dwErr = RegSetValueEx(
              hkey,
              AUTODIAL_REGMTIMEVALUE,
              0,
              REG_DWORD,
              (PVOID)&lpParams->dwModifiedTime,
              sizeof (DWORD));
    RegCloseKey(hkey);
    LocalFree(lpszAddressKey);

    dwErr = ERROR_SUCCESS;

done:
    UnlockImpersonation();
    return dwErr;
} // SetAddressParams



DWORD
EnumAutodialAddresses(
    IN LPTSTR *ppAddresses,
    IN LPDWORD lpdwcbAddresses,
    IN LPDWORD lpdwcAddresses
    )
{
    return (DWORD)(*lpfnRasEnumAutodialAddressesG)(
                     ppAddresses,
                     lpdwcbAddresses,
                     lpdwcAddresses);
} // EnumAutodialAddresses



DWORD
GetAutodialParam(
    IN DWORD dwKey
    )
{
    DWORD dwValue, dwcb = sizeof (DWORD);

    (void)(*lpfnRasGetAutodialParamG)(dwKey, &dwValue, &dwcb);
    return dwValue;
} // GetAutodialParam



VOID
SetAutodialParam(
    IN DWORD dwKey,
    IN DWORD dwValue
    )
{
    (void)(*lpfnRasSetAutodialParamG)(dwKey, &dwValue, sizeof (DWORD));
} // SetAutodialParam



DWORD
NotifyAutoDialChangeEvent(
    IN HANDLE hEvent
    )
{
    DWORD dwErr, dwDisp;

    //
    // Make sure we have hkcu
    //

    LockImpersonation();
    
    dwErr = DwGetHkcu();

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }
    
    //
    // Open the AutoDial registry key.
    //
    if (hkeyAutoDialRegChangeG == NULL) {
        dwErr = RegCreateKeyEx(
                  hkeyCUG,
                  L"Software\\Microsoft\\RAS AutoDial",
                  0,
                  NULL,
                  REG_OPTION_NON_VOLATILE,
                  KEY_NOTIFY,
                  NULL,
                  &hkeyAutoDialRegChangeG,
                  &dwDisp);
        if (dwErr)
        {
            goto done;
        }   
    }
    //
    // Set the notification change.
    //
    dwErr = RegNotifyChangeKeyValue(
              hkeyAutoDialRegChangeG,
              TRUE,
              REG_NOTIFY_CHANGE_NAME|REG_NOTIFY_CHANGE_ATTRIBUTES|REG_NOTIFY_CHANGE_LAST_SET|REG_NOTIFY_CHANGE_SECURITY,
              hEvent,
              TRUE);

done:
    UnlockImpersonation();
    return dwErr;
} // NotifyAutoDialChangeEvent



DWORD
CreateAutoDialChangeEvent(
    IN PHANDLE phEvent
    )
{
    //
    // Reset the internal change flag.
    //
    fAutoDialRegChangeG = TRUE;
    //
    // Create the event.
    //
    *phEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (*phEvent == NULL)
        return GetLastError();
    //
    // Register it.
    //
    return NotifyAutoDialChangeEvent(*phEvent);
} // CreateAutoDialChangeEvent



VOID
EnableAutoDialChangeEvent(
    IN HANDLE hEvent,
    IN BOOLEAN fEnabled
    )
{
    EnterCriticalSection(&csRasG);
    //
    // If the event was disabled, and now
    // it is being enabled, then we reset
    // the event.
    //
    if (!fAutoDialRegChangeG && fEnabled)
        ResetEvent(hEvent);
    fAutoDialRegChangeG = fEnabled;
    LeaveCriticalSection(&csRasG);
}


BOOLEAN
ExternalAutoDialChangeEvent()
{
    BOOLEAN fChanged;

    EnterCriticalSection(&csRasG);
    fChanged = fAutoDialRegChangeG;
    LeaveCriticalSection(&csRasG);

    return fChanged;
} // ExternalAutoDialChangeEvent



VOID
CloseAutoDialChangeEvent(
    IN HANDLE hEvent
    )
{
    if (hkeyAutoDialRegChangeG != NULL) {
        RegCloseKey(hkeyAutoDialRegChangeG);
        hkeyAutoDialRegChangeG = NULL;
    }
    CloseHandle(hEvent);
} // CloseAutoDialChangeEvent



VOID
SetHostentCache(
    IN PCHAR pszDns,
    IN ULONG ulIpaddr
    )
{
    EnterCriticalSection(&csRasG);
    lstrcpynA(
        (PCHAR)&hostentCacheG[iHostentCacheG].szDns,
        pszDns,
        ACD_ADDR_INET_LEN);
    hostentCacheG[iHostentCacheG].ulIpaddr = ulIpaddr;
    iHostentCacheG = (iHostentCacheG + 1) % HOSTENTCACHESIZ;
    LeaveCriticalSection(&csRasG);
} // SetHostentCache



PCHAR
GetHostentCache(
    IN ULONG ulIpaddr
    )
{
    PCHAR pszDns = NULL;
    INT i;

    EnterCriticalSection(&csRasG);
    for (i = 0; i < HOSTENTCACHESIZ; i++) {
        if (hostentCacheG[i].ulIpaddr == ulIpaddr) {
            pszDns = hostentCacheG[i].szDns;
            break;
        }
    }
    LeaveCriticalSection(&csRasG);

    return pszDns;
} // GetHostentCache



LPTSTR
GetNetbiosDevice(
    IN HRASCONN hrasconn
    )
{
    INT i, nProtocols;
    RAS_PROTOCOLS Protocols;
    HPORT hPort;
    RASMAN_ROUTEINFO *pRoute;
    WCHAR szDevice[MAX_DEVICE_NAME + 1];
    DWORD dwErr;

    nProtocols = 0;
    hPort = (HPORT) (*lpfnRasGetHportG)(hrasconn);

    if(INVALID_HPORT == hPort)
    {
        return NULL;
    }

    if(ERROR_SUCCESS != (dwErr = (DWORD)(*lpfnRasPortEnumProtocolsG)(
                        NULL, hPort, 
                        &Protocols, &nProtocols)))
    {
        RASAUTO_TRACE1("GetNetbiosDevice: RasPortEnumProtocolsG failed"
                        " and returned 0x%x", dwErr);
        return NULL;
    }
    
    for (i = 0; i < nProtocols; i++) {
        pRoute = &Protocols.RP_ProtocolInfo[i];
        RASAUTO_TRACE3(
          "GetNetbiosDevice: lana=%d, xport=%S, adapter=%S",
          pRoute->RI_LanaNum,
          pRoute->RI_XportName,
          pRoute->RI_AdapterName);
        switch (pRoute->RI_Type) {
        case IPX:
            return CopyString(L"\\Device\\Nwlnknb");
        case IP:
            wsprintf(szDevice, L"\\Device\\NetBT_Tcpip%s", &pRoute->RI_AdapterName[8]);
            return CopyString(szDevice);
        case ASYBEUI:
            wsprintf(szDevice, L"\\Device\\Nbf_%s", &pRoute->RI_AdapterName[8]);
            return CopyString(szDevice);
        }
    }

    return NULL;
} // GetNetbiosDevice


DWORD
DwGetDefaultEntryName(LPTSTR *ppszEntryName)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwcb = sizeof(RASAUTODIALENTRY);
    RASAUTODIALENTRY Entry;
    DWORD dwEntries = 0;
    LPTSTR pszEntryName = NULL;

    if(NULL == ppszEntryName)
    {
        dwErr = E_INVALIDARG;
        goto done;
    }

    ZeroMemory(&Entry, sizeof(RASAUTODIALENTRY));

    Entry.dwSize = sizeof(RASAUTODIALENTRY);
    dwErr = (DWORD) (*lpfnRasGetAutodialAddressG)(
            NULL, NULL, &Entry,
            &dwcb, &dwEntries);                

    if(ERROR_SUCCESS != dwErr)
    {
        goto done;
    }

    if(0 != dwEntries)
    {
        pszEntryName = LocalAlloc(LPTR,
            sizeof(TCHAR) * (lstrlen(Entry.szEntry) + 1));

        if(NULL != pszEntryName)
        {
            //
            // Got a default entry.
            //
            lstrcpy(pszEntryName, Entry.szEntry);
        }
        else
        {
            dwErr = E_OUTOFMEMORY;
        }
    }
    else
    {
        RASAUTO_TRACE("No default connection defined");
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
    }

    *ppszEntryName = pszEntryName;
    
done:
    return dwErr;
}


VOID
ProcessLearnedAddress(
    IN ACD_ADDR_TYPE fType,
    IN LPTSTR pszAddress,
    IN PACD_ADAPTER pAdapter
    )
{
    BOOLEAN fStatus;
    DWORD dwConn, dwConnections, dwSize;
    LPTSTR *pEntryNames, pszEntryName = NULL;
    HRASCONN *phRasConn;
    union {
        RASPPPNBF pppNbf;
        RASPPPIP pppIp;
        RASPPPIPX pppIpx;
    } projBuf;
    RASPROJECTION fProjection;
    INT i, nProtocols;
    RAS_PROTOCOLS Protocols;
    RASMAN_ROUTEINFO *pRoute;
    HPORT hPort;
    PCHAR pszIpAddr, pszMac = NULL;
    WCHAR szIpAddr[17], *p, *pwszMac;
    UCHAR cMac[6];
    struct in_addr in;
    LPTSTR pszDefaultEntry = NULL;
        

    RASAUTO_TRACE2("ProcessLearnedAddress(%S,%d)", RASAUTO_TRACESTRW(pszAddress), pAdapter->fType);
    dwConnections = ActiveConnections(TRUE, &pEntryNames, &phRasConn);
    if (!dwConnections)
        return;

    (VOID) DwGetDefaultEntryName(&pszDefaultEntry);

    if(NULL != pszDefaultEntry)
    {
        //
        // Check to see if we have default entries as one of the
        // connected entries. If it is we don't learn the address
        //
        for(dwConn = 0; dwConn < dwConnections; dwConn++)
        {
            if(0 == lstrcmpi(pEntryNames[dwConn], pszDefaultEntry))
            {
                break;
            }
        }

        LocalFree(pszDefaultEntry);
        if(dwConn != dwConnections)
        {   
            RASAUTO_TRACE("ProcessLearnedAddress: not processing the address since"
                " its learned over the default connection");

            return;                
        }
    }
        
    //
    // If this is a DNS-to-IP address mapping,
    // then simply enter it into the hostent
    // cache and return.
    //
    if (fType == ACD_ADDR_INET && pAdapter->fType == ACD_ADAPTER_IP) {
        PCHAR pszDns = UnicodeStringToAnsiString(pszAddress, NULL, 0);

        if (pszDns != NULL)
        {
            SetHostentCache(pszDns, pAdapter->ulIpaddr);
            LocalFree(pszDns);
        }
        // return;
    }
    //
    // Set the buffer size according to the
    // adapter's type.
    //
    switch (pAdapter->fType) {
    case ACD_ADAPTER_LANA:
        RASAUTO_TRACE1(
          "ProcessLearnedAddress: ACD_ADAPTER_LANA: bLana=%d",
          pAdapter->bLana);
        fProjection = RASP_PppNbf;
        dwSize = sizeof (RASPPPNBF);
        break;
    case ACD_ADAPTER_IP:
        fProjection = RASP_PppIp;
        dwSize = sizeof (RASPPPIP);
        //
        // Convert the ULONG into a formatted IP address.
        //
        in.s_addr = pAdapter->ulIpaddr;
        pszIpAddr = inet_ntoa(in);
        RASAUTO_TRACE1(
          "ProcessLearnedAddress: ACD_ADAPTER_IPADDR: %s",
          pszIpAddr);
        AnsiStringToUnicodeString(
            pszIpAddr,
            szIpAddr,
            sizeof (szIpAddr) / sizeof(WCHAR));
        break;
    case ACD_ADAPTER_NAME:
        RASAUTO_TRACE1(
          "ProcessLearnedAddress: ACD_ADAPTER_NAME: %S",
          pAdapter->szName);
        dwSize = 0;
        break;
    case ACD_ADAPTER_MAC:
        RASAUTO_TRACE6(
          "ProcessLearnedAddress: ACD_ADAPTER_MAC: %02x:%02x:%02x:%02x:%02x:%02x",
          pAdapter->cMac[0],
          pAdapter->cMac[1],
          pAdapter->cMac[2],
          pAdapter->cMac[3],
          pAdapter->cMac[4],
          pAdapter->cMac[5]);
        fProjection = RASP_PppIpx;
        dwSize = sizeof (RASPPPIPX);
        break;
    }
    for (dwConn = 0; dwConn < dwConnections; dwConn++) {
        //
        // If we are looking for a device name,
        // we have to use RasPortEnumProtocols(),
        // otherwise it's easier to use
        // RasGetProjectionInfo.
        //
        if (pAdapter->fType != ACD_ADAPTER_NAME) {
            //
            // Note: the following statement assumes the
            // dwSize field is at the same offset for
            // all members of the union.
            //
            projBuf.pppNbf.dwSize = dwSize;
            if ((*lpfnRasGetProjectionInfoG)(
                    phRasConn[dwConn],
                    fProjection,
                    &projBuf,
                    &dwSize))
            {
                RASAUTO_TRACE1(
                  "ProcessLearnedAddress: RasGetProjectionInfo(%S) failed",
                  RASAUTO_TRACESTRW(pEntryNames[dwConn]));
                continue;
            }
            RASAUTO_TRACE3(
              "ProcessLearnedAddress: RasGetProjectionInfo returned dwSize=%d, dwError=%d, szIpAddress=%S",
              projBuf.pppIp.dwSize,
              projBuf.pppIp.dwError,
              projBuf.pppIp.szIpAddress);
            //
            // Note: the following statement assumes the
            // dwError field is at the same offset for
            // all members of the union.
            //
            if (projBuf.pppNbf.dwError) {
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: %S: dwError=0x%x",
                  RASAUTO_TRACESTRW(pEntryNames[dwConn]),
                  projBuf.pppNbf.dwError);
                continue;
            }
            switch (pAdapter->fType) {
            case ACD_ADAPTER_LANA:
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: comparing lanas (%d, %d)",
                  pAdapter->bLana,
                  projBuf.pppNbf.bLana);
                if (pAdapter->bLana == projBuf.pppNbf.bLana) {
                    pszEntryName = CopyString(pEntryNames[dwConn]);
                    goto done;
                }
                break;
            case ACD_ADAPTER_IP:
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: comparing ipaddrs (%S, %S)",
                  szIpAddr,
                  projBuf.pppIp.szIpAddress);
                // if (!_wcsicmp(szIpAddr, projBuf.pppIp.szIpAddress)) {
                    pszEntryName = CopyString(pEntryNames[dwConn]);
                    goto done;
                //}
                break;
            case ACD_ADAPTER_MAC:
                //
                // Terminate IPX address after network number.
                //
                pwszMac = wcschr(projBuf.pppIpx.szIpxAddress, '.');
                if (pwszMac == NULL)
                    goto done;
                pszMac = UnicodeStringToAnsiString(pwszMac + 1, NULL, 0);
                if (pszMac == NULL)
                    goto done;
                StringToNodeNumber(pszMac, cMac);
                RASAUTO_TRACE6(
                  "ProcessLearnedAddress: mac addr #1: %02x:%02x:%02x:%02x:%02x:%02x",
                  pAdapter->cMac[0],
                  pAdapter->cMac[1],
                  pAdapter->cMac[2],
                  pAdapter->cMac[3],
                  pAdapter->cMac[4],
                  pAdapter->cMac[5]);
                RASAUTO_TRACE6(
                  "ProcessLearnedAddress: mac addr #2: %02x:%02x:%02x:%02x:%02x:%02x",
                  cMac[0],
                  cMac[1],
                  cMac[2],
                  cMac[3],
                  cMac[4],
                  cMac[5]);
                if (RtlEqualMemory(pAdapter->cMac, cMac, sizeof (cMac)))
                {
                    pszEntryName = CopyString(pEntryNames[dwConn]);
                    goto done;
                }
                break;
            }
        }
        else {
            nProtocols = 0;
            hPort = (HPORT)(*lpfnRasGetHportG)(phRasConn[dwConn]);
            (*lpfnRasPortEnumProtocolsG)(NULL, hPort, &Protocols, &nProtocols);
            for (i = 0; i < nProtocols; i++) {
                pRoute = &Protocols.RP_ProtocolInfo[i];
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: comparing (%S, %S)",
                  pAdapter->szName,
                  &pRoute->RI_AdapterName[8]);
                //
                // Skip the "/Device/" prefix in
                // RI_AdapterName for the comparison.
                //
                if (!_wcsicmp(
                       pAdapter->szName,
                       &pRoute->RI_AdapterName[8]))
                {
                    pszEntryName = CopyString(pEntryNames[dwConn]);
                    goto done;
                }
            }
        }
    }

done:
    //
    // Create a mapping for the original address
    // if we found one.
    //
    if (pszEntryName != NULL) {
        LPTSTR pszNetbiosName, pszAlias = NULL;
        CHAR szIpAddress[17], *psz;
        ULONG inaddr;
        struct hostent *hp;

        switch (fType) {
        case ACD_ADDR_IP:
            //
            // Get the Netbios name from the IP address,
            // if any.
            //
            hPort = (HPORT)(*lpfnRasGetHportG)(phRasConn[dwConn]);
            pszNetbiosName = IpAddressToNetbiosName(pszAddress, hPort);
            if (pszNetbiosName != NULL) {
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: ipaddr %S maps to Netbios name %S",
                  pszAddress,
                  pszNetbiosName);
                LockAddressMap();
                fStatus = SetAddressDialingLocationEntry(
                            pszNetbiosName,
                            pszEntryName);
                fStatus = SetAddressTag(
                            pszNetbiosName,
                            ADDRMAP_TAG_LEARNED);
                UnlockAddressMap();
                LocalFree(pszNetbiosName);
            }
            //
            // Get the DNS name from the IP address,
            // if any.
            //
            UnicodeStringToAnsiString(
              pszAddress,
              szIpAddress,
              sizeof (szIpAddress));
            inaddr = inet_addr(szIpAddress);
            psz = GetHostentCache(inaddr);
            if (psz != NULL)
                pszAlias = AnsiStringToUnicodeString(psz, NULL, 0);
            if (pszAlias != NULL) {
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: ipaddr %S maps to DNS %S",
                  pszAddress,
                  pszAlias);
                LockAddressMap();
                fStatus = SetAddressDialingLocationEntry(
                            pszAlias,
                            pszEntryName);
                fStatus = SetAddressTag(
                            pszAlias,
                            ADDRMAP_TAG_LEARNED);
                UnlockAddressMap();
                LocalFree(pszAlias);
            }
            break;
        case ACD_ADDR_IPX:
            //
            // Get the Netbios name from the IPX address,
            // if any.
            //
            pszNetbiosName = IpxAddressToNetbiosName(pszAddress);
            if (pszNetbiosName != NULL) {
                RASAUTO_TRACE2(
                  "ProcessLearnedAddress: ipaddr %S maps to Netbios name %S",
                  pszAddress,
                  pszNetbiosName);
                LockAddressMap();
                fStatus = SetAddressDialingLocationEntry(
                            pszNetbiosName,
                            pszEntryName);
                fStatus = SetAddressTag(
                            pszNetbiosName,
                            ADDRMAP_TAG_LEARNED);
                UnlockAddressMap();
                LocalFree(pszNetbiosName);
            }
            break;
        }
        RASAUTO_TRACE2(
          "ProcessLearnedAddress: learned %S->%S",
          pszAddress,
          pszEntryName);
        LockAddressMap();
        fStatus = SetAddressDialingLocationEntry(
                    pszAddress,
                    pszEntryName);
        fStatus = SetAddressTag(
                    pszAddress,
                    ADDRMAP_TAG_LEARNED);
        UnlockAddressMap();
        LocalFree(pszEntryName);
    }
    //
    // Free resources.
    //
    if (dwConnections) {
        FreeStringArray(pEntryNames, dwConnections);
        LocalFree(phRasConn);
    }

    if(NULL != pszMac)
    {
        LocalFree(pszMac);
    }
} // ProcessLearnedAddress



VOID
SetRedialOnLinkFailureHandler(
    IN FARPROC lpProc
    )
{
    (*lpfnRasRegisterRedialCallbackG)(lpProc);
} // SetRedialOnLinkFailureHandler


VOID
GetPortProtocols(
    IN HPORT hPort,
    IN RAS_PROTOCOLS *pProtocols,
    IN LPDWORD lpdwcProtocols
    )
{
    (*lpfnRasPortEnumProtocolsG)(NULL, hPort, pProtocols, lpdwcProtocols);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\radebug.h ===
/*
    File    radebug.h

    Rasauto debugging header
*/

#ifndef __RASAUTO_DEBUG_H
#define __RASAUTO_DEBUG_H

#include <debug.h>

// Tracing macros
//
extern DWORD g_dwRasAutoTraceId;

DWORD
RasAutoDebugInit();

DWORD
RasAutoDebugTerm();

#define RASAUTO_TRACESTRA(s)    ((s) != NULL ? (s) : "(null)")
#define RASAUTO_TRACESTRW(s)    ((s) != NULL ? (s) : L"(null)")
#define RASAUTO_TRACE(a)               TRACE_ID(g_dwRasAutoTraceId, a)
#define RASAUTO_TRACE1(a,b)            TRACE_ID1(g_dwRasAutoTraceId, a,b)
#define RASAUTO_TRACE2(a,b,c)          TRACE_ID2(g_dwRasAutoTraceId, a,b,c)
#define RASAUTO_TRACE3(a,b,c,d)        TRACE_ID3(g_dwRasAutoTraceId, a,b,c,d)
#define RASAUTO_TRACE4(a,b,c,d,e)      TRACE_ID4(g_dwRasAutoTraceId, a,b,c,d,e)
#define RASAUTO_TRACE5(a,b,c,d,e,f)    TRACE_ID5(g_dwRasAutoTraceId, a,b,c,d,e,f)
#define RASAUTO_TRACE6(a,b,c,d,e,f,g)  TRACE_ID6(g_dwRasAutoTraceId, a,b,c,d,e,f,g)

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\rasprocs.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    rasprocs.h

ABSTRACT
    Header file for RAS utility routines.

AUTHOR
    Anthony Discolo (adiscolo) 23-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

//
// Dialing location information per address.
//
typedef struct _ADDRESS_LOCATION_INFORMATION {
    DWORD dwLocation;       // TAPI dialing location
    LPTSTR pszEntryName;    // phonebook/entry
} ADDRESS_LOCATION_INFORMATION, *PADDRESS_LOCATION_INFORMATION;

//
// Autodial-related parameters per address.
//
typedef struct _ADDRESS_PARAMS {
    DWORD dwTag;            // ADDRMAP_TAG_*
    DWORD dwModifiedTime;   // last modified time
} ADDRESS_PARAMS, *PADDRESS_PARAMS;

extern HANDLE hConnectionEventG;

BOOLEAN LoadRasDlls();

VOID UnloadRasDlls();

DWORD
ActiveConnections(
    IN BOOLEAN fAuthenticated,
    OUT LPTSTR **lppEntryNames,
    OUT HRASCONN **lpphRasConn
    );

BOOLEAN
WaitForConnectionCompletion(
    IN DWORD dwConnections,
    IN HRASCONN *phRasCon
    );

BOOLEAN
StartAutoDialer(
    IN HANDLE hProcess,
    IN PACD_ADDR pAddr,
    IN LPTSTR lpAddress,
    IN LPTSTR lpEntryName,
    IN BOOLEAN fSharedAccess,
    OUT PBOOLEAN pfInvalidEntry
    );

BOOLEAN
StartReDialer(
    IN HANDLE hProcess,
    IN LPTSTR lpPhonebook,
    IN LPTSTR lpEntry
    );

LPTSTR
GetNetbiosDevice(
    IN HRASCONN hrasconn
    );

VOID
ProcessLearnedAddress(
    IN ACD_ADDR_TYPE fType,
    IN LPTSTR pszAddress,
    IN PACD_ADAPTER pAdapter
    );

DWORD
GetAddressDialingLocationInfo(
    IN LPTSTR pszAddress,
    OUT PADDRESS_LOCATION_INFORMATION *lppDialingInfo,
    OUT LPDWORD lpdwcDialingInfo
    );

DWORD
SetAddressDialingLocationInfo(
    IN LPTSTR pszAddress,
    IN PADDRESS_LOCATION_INFORMATION lpDialingInfo
    );

DWORD
ClearAddressDialingLocationInfo(
    IN LPTSTR pszAddress
    );

DWORD
GetAddressParams(
    IN LPTSTR pszAddress,
    OUT PADDRESS_PARAMS lpParams
    );

DWORD
SetAddressParams(
    IN LPTSTR pszAddress,
    IN PADDRESS_PARAMS lpParams
    );

DWORD
EnumAutodialAddresses(
    IN LPTSTR *ppAddresses,
    IN LPDWORD lpdwcbAddresses,
    IN LPDWORD lpdwcAddresses
    );

DWORD
CreateAutoDialChangeEvent(
    IN PHANDLE phEvent
    );

DWORD
NotifyAutoDialChangeEvent(
    IN HANDLE hEvent
    );

VOID
EnableAutoDialChangeEvent(
    IN HANDLE hEvent,
    IN BOOLEAN fEnabled
    );

BOOLEAN
ExternalAutoDialChangeEvent();

VOID
CloseAutoDialChangeEvent(
    IN HANDLE hEvent
    );

LPTSTR
AddressToNetwork(
    IN LPTSTR pszAddress
    );

LPTSTR
EntryToNetwork(
    IN LPTSTR pszEntry
    );

DWORD
AutoDialEnabled(
    IN PBOOLEAN lpfEnabled
    );

DWORD
DisableAutoDial();

DWORD
GetAutodialParam(
    IN DWORD dwKey
    );

VOID
SetAutodialParam(
    IN DWORD dwKey,
    IN DWORD dwValue
    );

VOID
SetRedialOnLinkFailureHandler(
    IN FARPROC lpProc
    );

VOID
GetPortProtocols(
    IN HPORT hPort,
    IN RAS_PROTOCOLS *pProtocols,
    IN LPDWORD lpdwcProtocols
    );

DWORD
DwGetDefaultEntryName(
    LPTSTR *ppszEntryName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\process.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    process.c

ABSTRACT
    NT process routines for the automatic connection system service.

AUTHOR
    Anthony Discolo (adiscolo) 12-Aug-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <debug.h>

#include "radebug.h"



PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo()

/*++

DESCRIPTION
    Return a block containing information about all processes
    currently running in the system.

ARGUMENTS
    None.

RETURN VALUE
    A pointer to the system process information or NULL if it could
    not be allocated or retrieved.

--*/

{
    NTSTATUS status;
    PUCHAR pLargeBuffer;
    ULONG ulcbLargeBuffer = 64 * 1024;

    //
    // Get the process list.
    //
    for (;;) {
        pLargeBuffer = VirtualAlloc(
                         NULL,
                         ulcbLargeBuffer, MEM_COMMIT, PAGE_READWRITE);
        if (pLargeBuffer == NULL) {
            RASAUTO_TRACE1(
              "GetSystemProcessInfo: VirtualAlloc failed (status=0x%x)",
              GetLastError());
            return NULL;
        }

        status = NtQuerySystemInformation(
                   SystemProcessInformation,
                   pLargeBuffer,
                   ulcbLargeBuffer,
                   NULL);
        if (status == STATUS_SUCCESS) break;
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            VirtualFree(pLargeBuffer, 0, MEM_RELEASE);
            ulcbLargeBuffer += 8192;
            RASAUTO_TRACE1(
              "GetSystemProcesInfo: enlarging buffer to %d",
              ulcbLargeBuffer);
        }
    }

    return (PSYSTEM_PROCESS_INFORMATION)pLargeBuffer;
} // GetSystemProcessInfo



PSYSTEM_PROCESS_INFORMATION
FindProcessByNameList(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR *lpExeNameList,
    IN DWORD dwcExeNameList,
    IN DWORD dwPid,
    IN BOOL fRequireSessionMatch,
    IN DWORD dwSessionId
    )

/*++

DESCRIPTION
    Given a pointer returned by GetSystemProcessInfo(), find
    a process by name.

ARGUMENTS
    pProcessInfo: a pointer returned by GetSystemProcessInfo().

    lpExeNameList: a pointer to a list of Unicode strings containing the
        process to be found.

    dwcExeNameList: the number of strings in lpExeNameList

RETURN VALUE
    A pointer to the process information for the supplied
    process or NULL if it could not be found.

--*/

{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    DWORD i = 0;
    ULONG ulTotalOffset = 0;
    BOOL fValid = ((0 == dwPid) ? TRUE : FALSE);

    //
    // Look in the process list for lpExeName.
    //
    for (;;) {
        if (pProcessInfo->ImageName.Buffer != NULL) 
        {
            RASAUTO_TRACE3(
              "FindProcessByName: process: %S (%d) (%d)",
              pProcessInfo->ImageName.Buffer,
              pProcessInfo->UniqueProcessId,
              pProcessInfo->SessionId);
            for (i = 0; i < dwcExeNameList; i++) 
            {
                if (!_wcsicmp(pProcessInfo->ImageName.Buffer, lpExeNameList[i]))
                {
                    // return pProcessInfo;
                    break;
                }
            }
        }

        if (    (NULL != pProcessInfo->ImageName.Buffer)
            &&  (i < dwcExeNameList))
        {
            if(fValid)
            {
                // XP 353082
                //
                // If we know the id of the session currently attached to the 
                // console, then require our process to match that session id.
                //
                if (fRequireSessionMatch) 
                {
                    if (pProcessInfo->SessionId == dwSessionId)
                    {
                        RASAUTO_TRACE1(
                            "FindProcess...: Success (==) pid=%d",
                            pProcessInfo->UniqueProcessId);
                        return pProcessInfo;
                    }
                    else
                    {
                        RASAUTO_TRACE1(
                            "FindProcess...: %d name match, but not sessionid",
                            pProcessInfo->UniqueProcessId);
                    }
                }
                else
                {
                    RASAUTO_TRACE1(
                        "FindProcess...: Success (any) pid=%d",
                        pProcessInfo->UniqueProcessId);
                    return pProcessInfo;
                }
            }
            else
            {
                RASAUTO_TRACE1(
                    "Looking for other instances of %ws",
                   lpExeNameList[i]);

                if (PtrToUlong(pProcessInfo->UniqueProcessId) == dwPid)
                {
                    fValid = TRUE;                       
                }
            }
        }
        
        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
            break;
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    RASAUTO_TRACE1("No more instances of %ws found", 
            pProcessInfo->ImageName.Buffer);
    
    return NULL;
} // FindProcessByNameList



PSYSTEM_PROCESS_INFORMATION
FindProcessByName(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPTSTR lpExeName
    )

/*++

DESCRIPTION
    Given a pointer returned by GetSystemProcessInfo(), find
    a process by name.

ARGUMENTS
    pProcessInfo: a pointer returned by GetSystemProcessInfo().

    lpExeName: a pointer to a Unicode string containing the
        process to be found.

RETURN VALUE
    A pointer to the process information for the supplied
    process or NULL if it could not be found.

--*/

{
    LPTSTR lpExeNameList[1];

    lpExeNameList[0] = lpExeName;
    return FindProcessByNameList(
                pProcessInfo, 
                lpExeNameList, 
                1, 
                0, 
                FALSE, 
                0);
} // FindProcessByName



VOID
FreeSystemProcessInfo(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo
    )

/*++

DESCRIPTION
    Free a buffer returned by GetSystemProcessInfo().

ARGUMENTS
    pProcessInfo: the pointer returned by GetSystemProcessInfo().

RETURN VALUE
    None.

--*/

{
    VirtualFree((PUCHAR)pProcessInfo, 0, MEM_RELEASE);
} // FreeSystemProcessInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\reg.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    reg.c

ABSTRACT
    Registry routines for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 20-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <acd.h>
#include <debug.h>

#include "reg.h"
#include "misc.h"

//
// The maximum size of TOKEN_USER information.
//
#define TOKEN_INFORMATION_SIZE  (sizeof (TOKEN_USER) + sizeof (SID) + (sizeof (ULONG) * SID_MAX_SUB_AUTHORITIES))


HKEY
GetHkeyCurrentUser(
    HANDLE hToken
    )
{
    BOOLEAN fSuccess;
    HKEY hkey = NULL;
    UCHAR TokenInformation[TOKEN_INFORMATION_SIZE];
    DWORD dwReturnLength;
    UNICODE_STRING sidString, keyString;
    OBJECT_ATTRIBUTES objectAttributes;

    if (!GetTokenInformation(
           hToken,
           TokenUser,
           TokenInformation,
           sizeof (TokenInformation),
           &dwReturnLength))
    {
        RASAUTO_TRACE1(
          "GetHkeyCurrentUser: GetTokenInformation failed (error=%d)",
          GetLastError());
        return NULL;
    }
    if (RtlConvertSidToUnicodeString(
          &sidString,
          ((PTOKEN_USER)TokenInformation)->User.Sid,
          TRUE) != STATUS_SUCCESS)
    {
        RASAUTO_TRACE1(
          "GetHkeyCurrentUser: RtlConvertSidToUnicodeString failed (error=%d)",
          GetLastError());
        return NULL;
    }
    keyString.Length = 0;
    keyString.MaximumLength =
      sidString.Length + sizeof (L"\\REGISTRY\\USER\\") + sizeof (L"\0");
    keyString.Buffer = LocalAlloc(LPTR, keyString.MaximumLength);
    if (keyString.Buffer == NULL) {
        RASAUTO_TRACE("GetHkeyCurrentUser: LocalAlloc failed");
        RtlFreeUnicodeString(&sidString);
        return NULL;
    }
    //
    // Copy \REGISTRY\USER to keyString.
    //
    RtlAppendUnicodeToString(&keyString, L"\\REGISTRY\\USER\\");
    //
    // Append the user's SID to keyString.
    //
    if (RtlAppendUnicodeStringToString(
          &keyString,
          &sidString) != STATUS_SUCCESS)
    {
        RASAUTO_TRACE1(
          "GetHkeyCurrentUser: RtlAppendUnicodeToString failed (error=%d)",
          GetLastError());
        RtlFreeUnicodeString(&sidString);
        LocalFree(keyString.Buffer);
        return NULL;
    }
    RtlFreeUnicodeString(&sidString);
    RASAUTO_TRACE1(
      "GetHkeyCurrentUser: HKEY_CURRENT_USER is %S",
      keyString.Buffer);
    //
    // Initialize the object attributes.
    //
    InitializeObjectAttributes(
      &objectAttributes,
      &keyString,
      OBJ_CASE_INSENSITIVE,
      NULL,
      NULL);
    //
    // Open the registry key.
    //
    if (NtOpenKey(
          &hkey,
          MAXIMUM_ALLOWED,
          &objectAttributes) != STATUS_SUCCESS)
    {
        RASAUTO_TRACE1(
          "GetHkeyCurrentUser: NtOpenKey failed (error=%d)",
          GetLastError());
        LocalFree(keyString.Buffer);
        return NULL;
    }

    LocalFree(keyString.Buffer);
    return hkey;
} // GetHkeyCurrentUser



BOOLEAN
RegGetValue(
    IN HKEY hkey,
    IN LPTSTR pszKey,
    OUT PVOID *ppvData,
    OUT LPDWORD pdwcbData,
    OUT LPDWORD pdwType
    )
{
    DWORD dwError, dwType, dwSize;
    PVOID pvData;

    //
    // Get the length of the string.
    //
    dwSize = 0;
    dwError = RegQueryValueEx(
                hkey,
                pszKey,
                NULL,
                &dwType,
                NULL,
                &dwSize);
    if (dwError != ERROR_SUCCESS)
        return FALSE;
    pvData = LocalAlloc(LPTR, dwSize);
    if (pvData == NULL) {
        RASAUTO_TRACE("RegGetValue: LocalAlloc failed");
        return FALSE;
    }
    //
    // Read the value for real this time.
    //
    dwError = RegQueryValueEx(
                hkey,
                pszKey,
                NULL,
                NULL,
                (LPBYTE)pvData,
                &dwSize);
    if (dwError != ERROR_SUCCESS) {
        LocalFree(pvData);
        return FALSE;
    }

    if(NULL != pdwType)
    {
        *pdwType = dwType;
    }

    *ppvData = pvData;
    if (pdwcbData != NULL)
        *pdwcbData = dwSize;
    return TRUE;
} // RegGetValue



BOOLEAN
RegGetDword(
    IN HKEY hkey,
    IN LPTSTR pszKey,
    OUT LPDWORD pdwValue
    )
{
    DWORD dwError, dwType, dwSize = sizeof (DWORD);

    dwError = RegQueryValueEx(
                hkey,
                pszKey,
                NULL,
                &dwType,
                (LPBYTE)pdwValue,
                &dwSize);
    if (dwError != ERROR_SUCCESS || dwType != REG_DWORD)
        return FALSE;

    return TRUE;
} // RegGetDword
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\reg.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    reg.h

ABSTRACT
    Header file for registry routines for the
    automatic connection DLL.

AUTHOR
    Anthony Discolo (adiscolo) 20-Mar-1995

REVISION HISTORY
    Original version from Gurdeep

--*/

//
// RAS registry keys.
//
#define RAS_REGBASE     L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\RemoteAccess"
#define RAS_USEPBKEY    L"UsePersonalPhonebook"
#define RAS_PBKEY       L"PersonalPhonebookPath"

//
// Registry key/value for default shell.
//
#define SHELL_REGKEY    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHELL_REGVAL    L"Shell"
#define DEFAULT_SHELL   L"explorer.exe"

//
// Autodial address registry key
//
#define AUTODIAL_REGADDRESSBASE         L"Software\\Microsoft\\RAS AutoDial\\Addresses"
#define AUTODIAL_REGTAGVALUE            L"Tag"
#define AUTODIAL_REGMTIMEVALUE          L"LastModified"

//
// Autodial disabled addresses registry key
//
#define AUTODIAL_REGCONTROLBASE       L"Software\\Microsoft\\RAS Autodial\\Control"
#define AUTODIAL_REGDISABLEDADDRVALUE L"DisabledAddresses"


HKEY
GetHkeyCurrentUser(
    HANDLE hToken
    );

BOOLEAN
RegGetValue(
    IN HKEY hkey,
    IN LPTSTR pszKey,
    OUT PVOID *ppvData,
    OUT LPDWORD pdwcbData,
    OUT LPDWORD pdwType
    );

BOOLEAN
RegGetDword(
    IN HKEY hkey,
    IN LPTSTR pszKey,
    OUT LPDWORD pdwValue
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\service.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    service.c

ABSTRACT
    Service controller procedures for the automatic connection service.

AUTHOR
    Anthony Discolo (adiscolo) 08-May-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include <npapi.h>
#include <ipexport.h>
#include <acd.h>

#include "init.h"
#include "reg.h"
#include "misc.h"
#include "table.h"
#include "addrmap.h"
#include "imperson.h"

#include "rtutils.h"


extern HANDLE hNewFusG;

//
// Global variables
//
DWORD Checkpoint = 1;

SERVICE_STATUS_HANDLE hService;

//
// Imported routines
//
VOID AcsDoService();

DWORD
WINAPI
ServiceHandlerEx(
    DWORD                 fdwControl,
    DWORD                 fdwEventType,
    LPVOID                lpEventData,
    LPVOID                lpContext)
{
    SERVICE_STATUS status;
    DWORD dwRetCode =  ERROR_SUCCESS;
    WTSSESSION_NOTIFICATION * pNotify;

    RASAUTO_TRACE2(
        "ServiceHandlerEx enter.  ctrl=%d type=%d", 
        fdwControl, 
        fdwEventType);

    ZeroMemory (&status, sizeof(status));
    status.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;

    switch (fdwControl)
    {
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
            RASAUTO_TRACE("ServiceHandlerEx: pause/cont/interrogate");
            status.dwCurrentState       = SERVICE_RUNNING;
            status.dwControlsAccepted   = SERVICE_ACCEPT_STOP |
                                          SERVICE_ACCEPT_SHUTDOWN |
                                          SERVICE_ACCEPT_POWEREVENT |
                                          SERVICE_ACCEPT_SESSIONCHANGE;
            status.dwCheckPoint         = Checkpoint++;
            SetServiceStatus(hService, &status);
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            RASAUTO_TRACE("ServiceHandlerEx: stop/shutdown");
            status.dwCurrentState = SERVICE_STOP_PENDING;
            SetServiceStatus(hService, &status);
            //
            // Stop the service.
            //
            AcsTerminate();
            break;

        case SERVICE_CONTROL_SESSIONCHANGE:
            RASAUTO_TRACE1("ServiceHandlerEx: Session Change %d", fdwEventType);
            if (fdwEventType == WTS_CONSOLE_CONNECT)
            {
                pNotify = (WTSSESSION_NOTIFICATION*)lpEventData;
                if (pNotify)
                {
                    SetCurrentLoginSession(pNotify->dwSessionId);
                    SetEvent(hNewFusG);
                }                    
            }
            break;
        
        case SERVICE_CONTROL_POWEREVENT:
        {
            RASAUTO_TRACE("ServiceHandlerEx: power event");
            switch(fdwEventType)
            {
                case PBT_APMRESUMESTANDBY:
                case PBT_APMRESUMESUSPEND:
                case PBT_APMRESUMECRITICAL:
                case PBT_APMRESUMEAUTOMATIC:
                {
                    //
                    // When the machine is resuming from hibernation
                    // clear the disabled addresses
                    //
                    ResetDisabledAddresses();
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
        break;

    }

    return ERROR_SUCCESS;
    
} // ServiceHandler


VOID
ServiceMain(
    DWORD dwArgc,
    LPWSTR *lpszArgv
    )

/*++

DESCRIPTION
    Perform initialization and start the main loop for ics.dll.

ARGUMENTS
    hService: the service handle created for us by rasman.exe

    pStatus: a pointer to the service status descriptor initialize
        for us by rasman.exe

    dwArgc: ignored

    lpszArgv: ignored

RETURN VALUE
    None.

--*/

{
    SERVICE_STATUS status;
    DWORD dwError;

    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(lpszArgv);

    ZeroMemory (&status, sizeof(status));
    status.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;

    // Register the control request handler.
    //
    hService = RegisterServiceCtrlHandlerEx(TEXT("rasauto"),
                                          ServiceHandlerEx,
                                          NULL);
    if (hService)
    {
        status.dwCurrentState = SERVICE_START_PENDING;
        SetServiceStatus(hService, &status);

        //
        // Perform initialization.
        //
        dwError = AcsInitialize();
        if (dwError == ERROR_SUCCESS) {
            //
            // Initialization succeeded.  Update status.
            //
            status.dwControlsAccepted = SERVICE_ACCEPT_STOP
                                      | SERVICE_ACCEPT_POWEREVENT
                                      | SERVICE_ACCEPT_SESSIONCHANGE;
            status.dwCurrentState     = SERVICE_RUNNING;
            SetServiceStatus(hService, &status);

            //
            // This is where the real work gets done.
            // It will return only after the service
            // is stopped.
            //
            AcsDoService();

            //
            // Update return code status.
            //
            status.dwWin32ExitCode = NO_ERROR;
            status.dwServiceSpecificExitCode = 0;
        }
        else {
            //
            // Initialization failed.  Update status.
            //
            status.dwWin32ExitCode = dwError;
        }

        status.dwControlsAccepted = 0;
        status.dwCurrentState     = SERVICE_STOPPED;
        SetServiceStatus(hService, &status);
    }
} // ServiceMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\table.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.c

ABSTRACT
    Generic hash table manipulation routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <acd.h>
#include <debug.h>

#include "table.h"
#include "misc.h"

//
// Generic hash table entry.
//
typedef struct _HASH_ENTRY {
    LIST_ENTRY ListEntry;
    LPTSTR pszKey;
    PVOID pData;
} HASH_ENTRY, *PHASH_ENTRY;



PHASH_TABLE
NewTable()
{
    PHASH_TABLE pTable;
    INT i;

    pTable = LocalAlloc(LPTR, sizeof (HASH_TABLE));
    if (pTable == NULL) {
        RASAUTO_TRACE("NewTable: LocalAlloc failed");
        return NULL;
    }
    for (i = 0; i < NBUCKETS; i++)
        InitializeListHead(&pTable->ListEntry[i]);
    pTable->ulSize = 0;

    return pTable;
} // NewTable



VOID
FreeHashTableEntry(
    IN PHASH_ENTRY pHashEntry
    )
{
    LocalFree(pHashEntry->pszKey);
    if (pHashEntry->pData != NULL)
        LocalFree(pHashEntry->pData);
    LocalFree(pHashEntry);
} // FreeHashTableEntry



VOID
ClearTable(
    IN PHASH_TABLE pTable
    )
{
    INT i;
    PLIST_ENTRY pHead;
    PHASH_ENTRY pHashEntry;

    for (i = 0; i < NBUCKETS; i++) {
        while (!IsListEmpty(&pTable->ListEntry[i])) {
            pHead = RemoveHeadList(&pTable->ListEntry[i]);
            pHashEntry = CONTAINING_RECORD(pHead, HASH_ENTRY, ListEntry);

            FreeHashTableEntry(pHashEntry);
        }
    }
    pTable->ulSize = 0;
} // ClearTable



VOID
EnumTable(
    IN PHASH_TABLE pTable,
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    )
{
    INT i;
    PLIST_ENTRY pEntry, pNextEntry;
    PHASH_ENTRY pHashEntry;

    for (i = 0; i < NBUCKETS; i++) {
        pEntry = pTable->ListEntry[i].Flink;
        while (pEntry != &pTable->ListEntry[i]) {
            pHashEntry = CONTAINING_RECORD(pEntry, HASH_ENTRY, ListEntry);

            //
            // Get the next entry before calling
            // the enumerator procedure to allow
            // it to call DeleteTableEntry().
            //
            pNextEntry = pEntry->Flink;
            //
            // If the enumerator procedure
            // returns FALSE, terminate the
            // enumeration.
            //
            if (!pProc(pArg, pHashEntry->pszKey, pHashEntry->pData))
                return;
            pEntry = pNextEntry;
        }
    }
} // EnumTable


VOID
FreeTable(
    IN PHASH_TABLE pTable
    )
{
    ClearTable(pTable);
    LocalFree(pTable);
} // FreeTable



INT
HashString(
    IN LPTSTR pszKey
    )
{
    CHAR ch;
    DWORD dwHashValue = 0;
    LPTSTR p = pszKey;

    while (*p != L'\0') {
        ch = (CHAR)tolower(*p);
        dwHashValue += (INT)ch * (INT)ch;
        p++;
    }

    return (INT)(dwHashValue % NBUCKETS);
} // HashString



PHASH_ENTRY
GetTableEntryCommon(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey
    )
{
    INT nBucket = HashString(pszKey);
    PLIST_ENTRY pEntry;
    PHASH_ENTRY pHashEntry;

    for (pEntry = pTable->ListEntry[nBucket].Flink;
         pEntry != &pTable->ListEntry[nBucket];
         pEntry = pEntry->Flink)
    {
        pHashEntry = CONTAINING_RECORD(pEntry, HASH_ENTRY, ListEntry);

        if (!_wcsicmp(pHashEntry->pszKey, pszKey))
            return pHashEntry;
    }

    return NULL;
} // GetTableEntryCommon



BOOLEAN
GetTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey,
    OUT PVOID *pData
    )
{
    PHASH_ENTRY pHashEntry;

    pHashEntry = GetTableEntryCommon(pTable, pszKey);
    if (pHashEntry != NULL) {
        if (pData != NULL)
            *pData = pHashEntry->pData;
        return TRUE;
    }

    return FALSE;
} // GetTableEntry



BOOLEAN
PutTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey,
    IN PVOID pData
    )
{
    INT nBucket = HashString(pszKey);
    PHASH_ENTRY pHashEntry;


    pHashEntry = GetTableEntryCommon(pTable, pszKey);
    if (pHashEntry == NULL) {
        pHashEntry = LocalAlloc(LPTR, sizeof (HASH_ENTRY));
        if (pHashEntry == NULL) {
            RASAUTO_TRACE("PutTableEntry: LocalAlloc failed");
            return FALSE;
        }
        pHashEntry->pszKey = CopyString(pszKey);
        if (pHashEntry->pszKey == NULL) {
            RASAUTO_TRACE("PutTableEntry: LocalAlloc failed");
            LocalFree(pHashEntry);
            return FALSE;
        }
        InsertHeadList(
          &pTable->ListEntry[nBucket],
          &pHashEntry->ListEntry);
        pTable->ulSize++;
    }
    else {
        if (pHashEntry->pData != pData)
            LocalFree(pHashEntry->pData);
    }
    pHashEntry->pData = pData;

    return TRUE;
} // PutTableEntry



BOOLEAN
DeleteTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey
    )
{
    PHASH_ENTRY pHashEntry;

    pHashEntry = GetTableEntryCommon(pTable, pszKey);
    if (pHashEntry != NULL) {
        RemoveEntryList(&pHashEntry->ListEntry);
        FreeHashTableEntry(pHashEntry);
        pTable->ulSize--;
    }

    return (pHashEntry != NULL);
} // DeleteTableEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\table.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    table.h

ABSTRACT
    Header file for generic hash table routines.

AUTHOR
    Anthony Discolo (adiscolo) 28-Jul-1995

REVISION HISTORY

--*/

//
// Number of hash table buckets.
//
#define NBUCKETS   13

//
// Generic hash table structure.
//
typedef struct _HASH_TABLE {
    LIST_ENTRY ListEntry[NBUCKETS]; // the hash buckets
    ULONG ulSize;                   // number of total entries
} HASH_TABLE, *PHASH_TABLE;

//
// Hash table enumerator procedure.
// Returns TRUE to continue enumeration,
// FALSE to terminate enumeration.
//
typedef BOOLEAN (*PHASH_TABLE_ENUM_PROC)(PVOID, LPTSTR, PVOID);


PHASH_TABLE
NewTable();

VOID
ClearTable(
    IN PHASH_TABLE pTable
    );

VOID
FreeTable(
    IN PHASH_TABLE pTable
    );

ULONG
TableSize(
    IN PHASH_TABLE pTable
    );

VOID
EnumTable(
    IN PHASH_TABLE pTable,
    IN PHASH_TABLE_ENUM_PROC pProc,
    IN PVOID pArg
    );

BOOLEAN
GetTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey,
    OUT PVOID *pData
    );

BOOLEAN
PutTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey,
    IN PVOID pData
    );

BOOLEAN
DeleteTableEntry(
    IN PHASH_TABLE pTable,
    IN LPTSTR pszKey
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\tapiproc.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tapiproc.c

ABSTRACT
    TAPI utility routines

AUTHOR
    Anthony Discolo (adiscolo) 12-Dec-1995

REVISION HISTORY

--*/

#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <npapi.h>
#include <tapi.h>
#include <debug.h>

#include "imperson.h"
#include "radebug.h"
#include "rasman.h"

//
// TAPI version
//
#define TAPIVERSION     0x00020000

//
// Global variables
//
HLINEAPP hlineAppG;
DWORD dwDialingLocationErrorG;
DWORD dwDialingLocationIdG;
CRITICAL_SECTION csTapiG;
HANDLE hTapiChangeG;

extern DWORD g_dwCritSecFlags;

//
// External variables
//
extern HINSTANCE hinstDllG;
extern IMPERSONATION_INFO ImpersonationInfoG;


DWORD
TapiGetDialingLocation(
    OUT LPDWORD lpdwLocationID
    )
{
    DWORD dwErr, dwCurrentLocationID;
    LINETRANSLATECAPS caps;
    LINETRANSLATECAPS *pCaps;

    //
    // Get the dialing location from TAPI.
    //
    RtlZeroMemory(&caps, sizeof (LINETRANSLATECAPS));
    caps.dwTotalSize = sizeof (LINETRANSLATECAPS);
    dwErr = lineGetTranslateCaps(hlineAppG, TAPIVERSION, &caps);
    if (dwErr) {
        RASAUTO_TRACE1(
          "TapiGetDialingLocation: lineGetTranslateCaps failed (dwErr=%d)",
          dwErr);
        return dwErr;
    }
    pCaps = (LINETRANSLATECAPS *)LocalAlloc(LPTR, caps.dwNeededSize);
    if (pCaps == NULL) {
        RASAUTO_TRACE("TapiGetDialingLocation: LocalAlloc failed");
        return dwErr;
    }
    RtlZeroMemory(pCaps, sizeof (LINETRANSLATECAPS));
    pCaps->dwTotalSize = caps.dwNeededSize;
    dwErr = lineGetTranslateCaps(hlineAppG, TAPIVERSION, pCaps);
    if (dwErr) {
        RASAUTO_TRACE1(
          "TapiGetDialingLocation: lineTranslateCaps failed (dwErr=%d)",
          dwErr);
        LocalFree(pCaps);
        return dwErr;
    }
    dwCurrentLocationID = pCaps->dwCurrentLocationID;
    LocalFree(pCaps);

    RASAUTO_TRACE1(
      "TapiGetDialingLocation: current dialing location is %d",
      dwCurrentLocationID);
    *lpdwLocationID = dwCurrentLocationID;
    return dwErr;
} // TapiGetDialingLocation



DWORD
TapiCurrentDialingLocation(
    OUT LPDWORD lpdwLocationID
    )
{
    DWORD dwErr;

    EnterCriticalSection(&csTapiG);
    dwErr = dwDialingLocationErrorG;
    if (!dwErr)
        *lpdwLocationID = dwDialingLocationIdG;
    LeaveCriticalSection(&csTapiG);

    return dwErr;
} // TapiCurrentDialingLocation



VOID
ProcessTapiChangeEvent(VOID)
{
    DWORD dwErr;
    LINEMESSAGE msg;

    dwErr = lineGetMessage(hlineAppG, &msg, 0);
    if (dwErr) {
        RASAUTO_TRACE1(
          "ProcessTapiChangeEvent: lineGetMessage failed (dwErr=0x%x)",
          dwErr);
        return;
    }
    RASAUTO_TRACE2(
      "ProcessTapiChangeEvent: dwMessageID=%d, dwParam1=%d",
      msg.dwMessageID,
      msg.dwParam1);
    //
    // Reset TAPI dialing location.
    //
    if (msg.dwMessageID == LINE_LINEDEVSTATE &&
        msg.dwParam1 == LINEDEVSTATE_TRANSLATECHANGE)
    {
        EnterCriticalSection(&csTapiG);
        dwDialingLocationErrorG =
          TapiGetDialingLocation(&dwDialingLocationIdG);
        LeaveCriticalSection(&csTapiG);
    }
} // ProcessTapiChangeEvent



DWORD
TapiInitialize(VOID)
{
    DWORD dwErr, dwcDevices, dwAPIVersion, dwDisp;
    LINEINITIALIZEEXPARAMS lineParams;

    //
    // Create a mutex to serialize access
    // to the dialing location variable.
    //
    RasInitializeCriticalSection(&csTapiG, &dwErr);

    if(dwErr != ERROR_SUCCESS)
    {
        return dwErr;
    }   

    g_dwCritSecFlags |= RASAUTO_CRITSEC_TAPI;
    
    //
    // Initialize TAPI.
    //
    dwAPIVersion = TAPIVERSION;
    RtlZeroMemory(&lineParams, sizeof (lineParams));
    lineParams.dwTotalSize = sizeof (lineParams);
    lineParams.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;
    dwErr = lineInitializeEx(
              &hlineAppG,
              hinstDllG,
              NULL,
              TEXT("rasauto.dll"),
              &dwcDevices,
              &dwAPIVersion,
              &lineParams);
    if (dwErr) {
        RASAUTO_TRACE1(
          "TapiInitalize: lineInitializeEx failed (dwErr=0x%x)",
          dwErr);

        DeleteCriticalSection(&csTapiG);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_TAPI);
          
        return dwErr;
    }
    //
    // Save the event returned from TAPI that
    // will get signaled on state changes.
    //
    hTapiChangeG = lineParams.Handles.hEvent;
    //
    // Get the current dialing location.
    //
    dwDialingLocationErrorG = TapiGetDialingLocation(&dwDialingLocationIdG);
    RASAUTO_TRACE("TapiInitialize: initialization done");

    return 0;
} // TapiInitialilze



VOID
TapiShutdown(VOID)
{
    DWORD dwErr;

    //
    // Shutdown TAPI.
    //
    dwErr = lineShutdown(hlineAppG);
    if (dwErr) {
        RASAUTO_TRACE1(
          "TapiMessageLoopThread: lineShutdown failed (dwErr=%d)",
          dwErr);
    }

    if(g_dwCritSecFlags & RASAUTO_CRITSEC_TAPI)
    {
        DeleteCriticalSection(&csTapiG);
        g_dwCritSecFlags &= ~(RASAUTO_CRITSEC_TAPI);
    }
    
    RASAUTO_TRACE("TapiShutdown: shutting down");
} // TapiShutdown

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasauto\tapiproc.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tapiproc.h

ABSTRACT
    Header file for TAPI utility routines.

AUTHOR
    Anthony Discolo (adiscolo) 12-Dec-1995

REVISION HISTORY

--*/

DWORD
TapiCurrentDialingLocation(
    OUT LPDWORD lpdwLocationID
    );

VOID
ProcessTapiChangeEvent(VOID);

DWORD
TapiInitialize(VOID);

VOID
TapiShutdown(VOID);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\adminapi.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    adminapi.c
//
// Description: Contains code to respond to DDM admin. requests.
//
// History:     May 11,1995	    NarenG		Created original version.
//
#include "ddm.h"
#include <lmmsg.h>
#include "objects.h"
#include "handlers.h"
#include "rasapiif.h"
#include "routerif.h"
#include "util.h"
#include <dimsvc.h>     // Generated by MIDL
#include <string.h>
#include <stdlib.h>
#include <mprapip.h>

//**
//
// Call:        DDMAdminInterfaceConnect
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminInterfaceConnect(
    IN      HANDLE      hDimInterface,
    IN      HANDLE      hEvent,
    IN      BOOL        fBlocking,
    IN      DWORD       dwCallersProcessId
)
{
    HANDLE                      hClientProcess       = NULL;
    DWORD                       dwRetCode            = NO_ERROR;
    ROUTER_INTERFACE_OBJECT*    pIfObject            = NULL;
    HANDLE                      hEventToBeDuplicated = NULL;
    DWORD                       fReturn              = FALSE;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        if ( ( pIfObject = IfObjectGetPointer((HANDLE)hDimInterface) ) == NULL )
        {
            dwRetCode = ERROR_INVALID_HANDLE;
            break;
        }

        if ( pIfObject->State == RISTATE_CONNECTED )
        {
            dwRetCode = NO_ERROR;
            fReturn = TRUE;
            break;
        }

        if ( pIfObject->State == RISTATE_CONNECTING )
        {
            dwRetCode = ERROR_ALREADY_CONNECTING;
            fReturn = TRUE;
            break;
        }

        if ( ( hEvent == NULL ) && ( fBlocking ) )
        {
            //
            // This call is to be synchrnonous, create an event and block on
            // it.
            //

            hEventToBeDuplicated = CreateEvent( NULL, FALSE, FALSE, NULL );

            if ( hEventToBeDuplicated == NULL )
            {
                dwRetCode = GetLastError();

                break;
            }

            dwCallersProcessId = GetCurrentProcessId();
        }
        else
        {
            hEventToBeDuplicated = hEvent;
        }

        if ( hEventToBeDuplicated != NULL )
        {
            //
            //
            // Get process handle of the caller of this API
            //

            hClientProcess = OpenProcess(
                            STANDARD_RIGHTS_REQUIRED | SPECIFIC_RIGHTS_ALL,
                            FALSE,
                            dwCallersProcessId);

            if ( hClientProcess == NULL )
            {
                dwRetCode = GetLastError();

                break;
            }

            //
            // Duplicate the handle to the event
            //

            if ( !DuplicateHandle(
                                hClientProcess,
                                hEventToBeDuplicated,
                                GetCurrentProcess(),
                                &(pIfObject->hEventNotifyCaller),
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS ) )
            {
                CloseHandle( hClientProcess );

                dwRetCode = GetLastError();

                break;
            }

            CloseHandle( hClientProcess );
        }
        else
        {
            pIfObject->hEventNotifyCaller = INVALID_HANDLE_VALUE;
        }

        //
        // Initiate a connection
        //

        dwRetCode = RasConnectionInitiate( pIfObject, FALSE );

        if ( dwRetCode != NO_ERROR )
        {
            CloseHandle( pIfObject->hEventNotifyCaller );

            pIfObject->hEventNotifyCaller = INVALID_HANDLE_VALUE;
        }
        else
        {
            dwRetCode = PENDING;
        }

        DDM_PRINT(  gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	                "RasConnectionInitiate: To %ws dwRetCode=%d",
                    pIfObject->lpwsInterfaceName, dwRetCode );
    }
    while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    //
    // If we are or already connecting or connected then simply return
    //

    if ( fReturn )
    {
        return( dwRetCode );
    }

    //
    // This is a synchronous call, we need to wait till compeletion
    //

    if ( ( hEvent == NULL ) && ( fBlocking ) )
    {
        if ( dwRetCode == PENDING )
        {
            if ( WaitForSingleObject( hEventToBeDuplicated, INFINITE )
                                                                == WAIT_FAILED )
            {
                CloseHandle( hEventToBeDuplicated );

                return( GetLastError() );
            }

            EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

            if ( ( pIfObject = IfObjectGetPointer((HANDLE)hDimInterface) )
                                                                    == NULL )
            {
                dwRetCode = ERROR_INVALID_HANDLE;
            }
            else
            {
                dwRetCode = pIfObject->dwLastError;
            }

            LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
        }

        if ( hEventToBeDuplicated != NULL )
        {
            CloseHandle( hEventToBeDuplicated );
        }
    }

    return( dwRetCode );
}

//**
//
// Call:        DDMAdminInterfaceDisconnect
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminInterfaceDisconnect(
    IN      HANDLE      hDimInterface
)
{
    DWORD   dwRetCode           = NO_ERROR;
    DWORD   dwTransportIndex    = -1;

    if ( gblDDMConfigInfo.dwNumRouterManagers > 0 )
    {
        for ( dwTransportIndex = 0;
              dwTransportIndex < gblDDMConfigInfo.dwNumRouterManagers;
              dwTransportIndex++ )
        {
            dwRetCode =
              DDMDisconnectInterface(
                 hDimInterface,
                 gblRouterManagers[dwTransportIndex].DdmRouterIf.dwProtocolId );

            if ( dwRetCode != NO_ERROR )
            {
                return( dwRetCode );
            }
        }
    }
    else
    {
        //
        // [old comment] If no router managers are installed then we are a AMB 
        // or NBF only client connection, simply call disconnect interface
        //

        // [new comment]
        //
        // AMB and NBF have been removed from the project but this path is 
        // being kept since logically, you should be able to disconnect an
        // interface regardless of whether any router managers exist.
        // 
        // This philosphy is in spirit with the work we'll do 
        // to merge rasman, dim, and ddm.  Then it will be possible for 
        // code paths like this to execute without any router managers being
        // loaded.
        //

        dwRetCode =  DDMDisconnectInterface( hDimInterface, -1 );
    }

    return( dwRetCode );
}

//**
//
// Call:        DDMAdminServerGetInfo
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminServerGetInfo(
    IN OUT  PVOID  pServerInfo,
    IN      DWORD  dwLevel
)
{
    MPR_SERVER_0* pServerInfo0;

    if ( dwLevel == 0 )
    {
        pServerInfo0 = (MPR_SERVER_0*)pServerInfo;

        pServerInfo0->fLanOnlyMode = FALSE;
    }
    else
    {
        return( ERROR_NOT_SUPPORTED );
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    //
    // Copy server info
    //

    pServerInfo0->dwTotalPorts = gblDeviceTable.NumDeviceNodes;
    pServerInfo0->dwPortsInUse = gblDeviceTable.NumDevicesInUse;

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        DDMAdminConnectionEnum
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminConnectionEnum(
    IN OUT  PDIM_INFORMATION_CONTAINER  pInfoStruct,
    IN      DWORD                       dwLevel,
    IN      DWORD                       dwPreferedMaximumLength,
    IN      LPDWORD                     lpdwEntriesRead,
    IN      LPDWORD                     lpdwTotalEntries,
    IN OUT  LPDWORD                     lpdwResumeHandle    OPTIONAL
)
{
    PRASI_CONNECTION_0   pRasConnection0 = NULL;
    PRASI_CONNECTION_1   pRasConnection1 = NULL;
    PRASI_CONNECTION_2   pRasConnection2 = NULL;
    PCONNECTION_OBJECT  pConnObj        = NULL;
    DWORD               dwBucketIndex   = 0;
    DWORD               dwConnObjIndex  = 0;
    DWORD               dwConnInfoSize  = 0;
    DWORD               dwStartIndex    = ( lpdwResumeHandle == NULL )
                                          ? 0
                                          : *lpdwResumeHandle;

    // Calculate the connection info size
    switch (dwLevel) {
        case 0:
            dwConnInfoSize = sizeof( RASI_CONNECTION_0 );
            break;
        case 1:
            dwConnInfoSize = sizeof( RASI_CONNECTION_1 );
            break;
        case 2:
            dwConnInfoSize = sizeof( RASI_CONNECTION_2 );
            break;
        default:
            return ERROR_NOT_SUPPORTED;
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    if ( gblDeviceTable.NumConnectionNodes < dwStartIndex )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        return( ERROR_NO_MORE_ITEMS );
    }

    *lpdwTotalEntries = gblDeviceTable.NumConnectionNodes - dwStartIndex;

    if ( dwPreferedMaximumLength != -1 )
    {
        *lpdwEntriesRead = dwPreferedMaximumLength / dwConnInfoSize;

        if ( *lpdwEntriesRead > *lpdwTotalEntries )
        {
            *lpdwEntriesRead = *lpdwTotalEntries;
        }
    }
    else
    {
        *lpdwEntriesRead = *lpdwTotalEntries;
    }

    pInfoStruct->dwBufferSize = *lpdwEntriesRead * dwConnInfoSize;
    pInfoStruct->pBuffer = MIDL_user_allocate( pInfoStruct->dwBufferSize );

    if ( pInfoStruct->pBuffer == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        pInfoStruct->dwBufferSize = 0;

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if (dwLevel == 0)
        pRasConnection0 = (PRASI_CONNECTION_0)pInfoStruct->pBuffer;
    else if (dwLevel == 1)
        pRasConnection1 = (PRASI_CONNECTION_1)pInfoStruct->pBuffer;
    else
        pRasConnection2 = (PRASI_CONNECTION_2)pInfoStruct->pBuffer;

    for ( dwBucketIndex = 0;
          dwBucketIndex < gblDeviceTable.NumDeviceBuckets;
          dwBucketIndex++ )
    {
        for( pConnObj = gblDeviceTable.ConnectionBucket[dwBucketIndex];
             pConnObj != (CONNECTION_OBJECT *)NULL;
             pConnObj = pConnObj->pNext )
        {
            //
            // Check if this connection object is within the range we need to
            // copy from.
            //

            if ( ( dwConnObjIndex >= dwStartIndex ) &&
                 ( dwConnObjIndex < (dwStartIndex+*lpdwEntriesRead)))
            {
                //
                // Copy the info
                //

                if (dwLevel == 0) {
                    GetRasiConnection0Data( pConnObj, pRasConnection0 );
                    pRasConnection0++;
                }
                else if (dwLevel == 1) {
                    GetRasiConnection1Data( pConnObj, pRasConnection1 );
                    pRasConnection1++;
                }
                else {
                    GetRasiConnection2Data( pConnObj, pRasConnection2 );
                    pRasConnection2++;
                }

            }
            else if (dwConnObjIndex>=(dwStartIndex+*lpdwEntriesRead))
            {
                //
                // Beyond the range so exit
                //

                if ( lpdwResumeHandle != NULL )
                {
                    *lpdwResumeHandle = dwConnObjIndex;
                }

                LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                return( ERROR_MORE_DATA );
            }

            dwConnObjIndex++;
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        DDMAdminConnectionGetInfo
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminConnectionGetInfo(
    IN      HANDLE                      hConnection,
    IN OUT  PDIM_INFORMATION_CONTAINER  pInfoStruct,
    IN      DWORD                       dwLevel
)
{
    DWORD                       dwRetCode = NO_ERROR;
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    CONNECTION_OBJECT *         pConnObj;

    if ( dwLevel > 2 )
    {
        return( ERROR_NOT_SUPPORTED );
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    switch( dwLevel )
    {
    case 0:

        pInfoStruct->dwBufferSize = sizeof( RASI_CONNECTION_0 );
        break;

    case 1:

        pInfoStruct->dwBufferSize = sizeof( RASI_CONNECTION_1 );
        break;

    case 2:

        pInfoStruct->dwBufferSize = sizeof( RASI_CONNECTION_2 );
        break;
    }

    pInfoStruct->pBuffer = MIDL_user_allocate( pInfoStruct->dwBufferSize );

    if ( pInfoStruct->pBuffer == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Copy Connection info
    //

    do
    {
        pConnObj = ConnObjGetPointer( (HCONN)hConnection );

        if ( pConnObj == (CONNECTION_OBJECT *)NULL )
        {
            dwRetCode = ERROR_INTERFACE_NOT_CONNECTED;

            break;
        }

        switch( dwLevel )
        {
        case 0:

            dwRetCode = GetRasiConnection0Data(
                                    pConnObj,
                                    (PRASI_CONNECTION_0)pInfoStruct->pBuffer );
            break;

        case 1:

            dwRetCode = GetRasiConnection1Data(
                                    pConnObj,
                                    (PRASI_CONNECTION_1)pInfoStruct->pBuffer );
            break;

        case 2:

            dwRetCode = GetRasiConnection2Data(
                                    pConnObj,
                                    (PRASI_CONNECTION_2)pInfoStruct->pBuffer );
            break;
        }


    }while( FALSE );

    if ( dwRetCode != NO_ERROR )
    {
        MIDL_user_free( pInfoStruct->pBuffer );

        pInfoStruct->pBuffer = NULL;

        pInfoStruct->dwBufferSize = 0;
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( dwRetCode );
}

//**
//
// Call:        DDMAdminConnectionClearStats
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminConnectionClearStats(
    IN      HANDLE              hConnection
)
{
    return( RasBundleClearStatisticsEx(NULL, (HCONN)hConnection ) );
}

//**
//
// Call:        DDMAdminPortEnum
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminPortEnum(
    IN OUT  PDIM_INFORMATION_CONTAINER  pInfoStruct,
    IN      HANDLE                      hConnection,
    IN      DWORD                       dwLevel,
    IN      DWORD                       dwPreferedMaximumLength,
    IN      LPDWORD                     lpdwEntriesRead,
    IN      LPDWORD                     lpdwTotalEntries,
    IN OUT  LPDWORD                     lpdwResumeHandle    OPTIONAL
)
{
    PRASI_PORT_0        pRasPort0       = NULL;
    PDEVICE_OBJECT      pDevObj         = NULL;
    PCONNECTION_OBJECT  pConnObj        = NULL;
    DWORD               dwIndex         = 0;
    DWORD               dwBucketIndex   = 0;
    DWORD               dwDevObjIndex   = 0;
    DWORD               dwStartIndex    = ( lpdwResumeHandle == NULL )
                                            ? 0
                                            : *lpdwResumeHandle;

    if ( dwLevel != 0 )
    {
        return( ERROR_NOT_SUPPORTED );
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    if ( hConnection != INVALID_HANDLE_VALUE )
    {
        if ( ( pConnObj = ConnObjGetPointer( (HCONN)hConnection ) ) == NULL )
        {
            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

            return( ERROR_INVALID_HANDLE );
        }

        if ( pConnObj->cActiveDevices < dwStartIndex )
        {
            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

            return( ERROR_NO_MORE_ITEMS );
        }

        *lpdwTotalEntries = pConnObj->cActiveDevices - dwStartIndex;
    }
    else
    {
        if ( gblDeviceTable.NumDeviceNodes < dwStartIndex )
        {
            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

            return( ERROR_NO_MORE_ITEMS );
        }

        *lpdwTotalEntries = gblDeviceTable.NumDeviceNodes - dwStartIndex;
    }

    if ( dwPreferedMaximumLength != -1 )
    {
        *lpdwEntriesRead = dwPreferedMaximumLength / sizeof( RAS_PORT_0 );

        if ( *lpdwEntriesRead > *lpdwTotalEntries )
        {
            *lpdwEntriesRead = *lpdwTotalEntries;
        }
    }
    else
    {
        *lpdwEntriesRead = *lpdwTotalEntries;
    }

    pInfoStruct->dwBufferSize = *lpdwEntriesRead * sizeof( RASI_PORT_0 );
    pInfoStruct->pBuffer      = MIDL_user_allocate( pInfoStruct->dwBufferSize );

    if ( pInfoStruct->pBuffer == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        pInfoStruct->dwBufferSize = 0;

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    pRasPort0 = (PRASI_PORT_0)pInfoStruct->pBuffer;

    if ( hConnection == INVALID_HANDLE_VALUE )
    {
        for ( dwBucketIndex = 0;
              dwBucketIndex < gblDeviceTable.NumDeviceBuckets;
              dwBucketIndex++ )
        {
            for( pDevObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
                 pDevObj != (DEVICE_OBJECT *)NULL;
                 pDevObj = pDevObj->pNext )
            {
                //
                // Check if this port is within the range we need to copy
                // from.
                //

                if ( ( dwDevObjIndex >= dwStartIndex ) &&
                     ( dwDevObjIndex < (dwStartIndex+*lpdwEntriesRead)))
                {
                    //
                    // Copy the info
                    //

                    GetRasiPort0Data( pDevObj, pRasPort0 );

                    pRasPort0++;
                }
                else if (dwDevObjIndex>=(dwStartIndex+*lpdwEntriesRead))
                {
                    //
                    // Beyond the range so exit
                    //

                    if ( lpdwResumeHandle != NULL )
                    {
                        *lpdwResumeHandle = dwDevObjIndex;
                    }

                    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                    return( ERROR_MORE_DATA );
                }

                dwDevObjIndex++;
            }
        }
    }
    else
    {
        for ( dwIndex = 0; dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
        {
            if ( pConnObj->pDeviceList[dwIndex] != NULL )
            {
                //
                // Check if this port is within the range we need to copy
                // from.
                //

                if ( ( dwDevObjIndex >= dwStartIndex ) &&
                     ( dwDevObjIndex < (dwStartIndex+*lpdwEntriesRead)))
                {
                    //
                    // Copy the info
                    //

                    GetRasiPort0Data(pConnObj->pDeviceList[dwIndex], pRasPort0);

                    pRasPort0++;
                }
                else if (dwDevObjIndex>=(dwStartIndex+*lpdwEntriesRead))
                {
                    //
                    // Beyond the range so exit
                    //

                    if ( lpdwResumeHandle != NULL )
                    {
                        *lpdwResumeHandle = dwDevObjIndex;
                    }

                    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                    return( NO_ERROR );
                }

                dwDevObjIndex++;
            }
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        DDMAdminPortGetInfo
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminPortGetInfo(
    IN      HANDLE                      hPort,
    IN OUT  PDIM_INFORMATION_CONTAINER  pInfoStruct,
    IN      DWORD                       dwLevel
)
{
    DEVICE_OBJECT * pDevObj;
    DWORD           dwRetCode;

    if ( dwLevel > 1 )
    {
        return( ERROR_NOT_SUPPORTED );
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pInfoStruct->dwBufferSize = ( dwLevel == 0 )
                                ? sizeof( RAS_PORT_0 )
                                : sizeof( RAS_PORT_1 );

    pInfoStruct->pBuffer = MIDL_user_allocate( pInfoStruct->dwBufferSize );

    if ( pInfoStruct->pBuffer == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Copy port info
    //

    do
    {
        pDevObj = DeviceObjGetPointer( (HPORT)hPort );

        if ( pDevObj == (HPORT)NULL )
        {
            dwRetCode = ERROR_INVALID_PORT_HANDLE;

            break;
        }

        if ( dwLevel == 0 )
        {
            dwRetCode = GetRasiPort0Data( pDevObj,
                                        (PRASI_PORT_0)pInfoStruct->pBuffer );
        }
        else
        {
            dwRetCode = GetRasiPort1Data( pDevObj,
                                        (PRASI_PORT_1)pInfoStruct->pBuffer );
        }
    }
    while( FALSE );

    if ( dwRetCode != NO_ERROR )
    {
        MIDL_user_free( pInfoStruct->pBuffer );

        pInfoStruct->pBuffer = NULL;

        pInfoStruct->dwBufferSize = 0;
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( dwRetCode );
}

//**
//
// Call:        DDMAdminPortClearStats
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminPortClearStats(
    IN      HANDLE          hPort
)
{
    PDEVICE_OBJECT pDevObj = NULL;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    if ( ( pDevObj = DeviceObjGetPointer( (HPORT)hPort ) ) == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

        return( ERROR_INVALID_HANDLE );
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( RasPortClearStatistics(NULL, (HPORT)hPort ) );
}

//**
//
// Call:        DDMAdminPortReset
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMAdminPortReset(
    IN      HANDLE          hPort
)
{
    return( NO_ERROR );
}

//**
//
// Call:        DDMAdminPortDisconnect
//
// Returns:     NO_ERROR - Success
//
// Description: Disconnect the client port.
//
DWORD
DDMAdminPortDisconnect(
    IN      HANDLE          hPort
)
{
    DEVICE_OBJECT * pDevObj;
    DWORD           dwRetCode = NO_ERROR;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    do
    {
        if ( ( pDevObj = DeviceObjGetPointer( (HPORT)hPort ) ) == NULL )
        {
            dwRetCode = ERROR_INVALID_HANDLE;

            break;
        }

        if ( pDevObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
        {
            RasApiCleanUpPort( pDevObj );
        }
        else
        {
            if ( pDevObj->fFlags & DEV_OBJ_PPP_IS_ACTIVE )
            {
                PppDdmStop( (HPORT)pDevObj->hPort, NO_ERROR );
            }
            else
            {
                DevStartClosing( pDevObj );
            }
        }
    }
    while( FALSE );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( dwRetCode );
}

//**
//
// Call:        DDMRegisterConnectionNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will insert or remove and event from the notification list
//
DWORD
DDMRegisterConnectionNotification(
    IN BOOL     fRegister,
    IN HANDLE   hEventClient,
    IN HANDLE   hEventRouter
)
{
    DWORD                   dwRetCode           = NO_ERROR;
    NOTIFICATION_EVENT *    pNotificationEvent  = NULL;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    if ( fRegister )
    {
        //
        // Insert event in notification list
        //

        pNotificationEvent = (NOTIFICATION_EVENT *)
                                        LOCAL_ALLOC(
                                                LPTR,
                                                sizeof(NOTIFICATION_EVENT) );
        if ( pNotificationEvent == NULL )
        {
            dwRetCode = GetLastError();
        }
        else
        {
            pNotificationEvent->hEventClient = hEventClient;
            pNotificationEvent->hEventRouter = hEventRouter;

            InsertHeadList(
                (LIST_ENTRY *)&(gblDDMConfigInfo.NotificationEventListHead),
                (LIST_ENTRY*)pNotificationEvent );
        }
    }
    else
    {
        //
        // Remove event from notification list
        //

        for( pNotificationEvent = (NOTIFICATION_EVENT *)
                            (gblDDMConfigInfo.NotificationEventListHead.Flink);
             pNotificationEvent != (NOTIFICATION_EVENT *)
                            &(gblDDMConfigInfo.NotificationEventListHead);
             pNotificationEvent = (NOTIFICATION_EVENT *)
                            (pNotificationEvent->ListEntry.Flink) )
        {
            if ( pNotificationEvent->hEventClient == hEventClient )
            {
                RemoveEntryList( (LIST_ENTRY *)pNotificationEvent );

                CloseHandle( pNotificationEvent->hEventClient );

                CloseHandle( pNotificationEvent->hEventRouter );

                LOCAL_FREE( pNotificationEvent );

                break;
            }
        }
    }

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    return( dwRetCode );
}

//**
//
// Call:        DDMSendUserMessage
//
// Returns:     NO_ERROR - Success
//
// Description:
//
DWORD
DDMSendUserMessage(
    IN  HANDLE      hConnection,
    IN  LPWSTR      lpwszMessage
)
{

    PCONNECTION_OBJECT  pConnObj            = NULL;
    DWORD               dwRetCode           = NO_ERROR;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    do
    {
        pConnObj = ConnObjGetPointer( (HCONN)hConnection );

        if ( pConnObj == (CONNECTION_OBJECT *)NULL )
        {
            dwRetCode = ERROR_INTERFACE_NOT_CONNECTED;

            break;
        }

        if ( pConnObj->fFlags & CONN_OBJ_MESSENGER_PRESENT )
        {
            WCHAR wszRemoteComputer[CNLEN+1];

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 pConnObj->bComputerName,
                                 -1,
                                 wszRemoteComputer,
                                 CNLEN+1 );

            dwRetCode = NetMessageBufferSend(
                                NULL,
                                wszRemoteComputer,
                                NULL,
                                (BYTE*)lpwszMessage,
                                (wcslen(lpwszMessage)+1) * sizeof(WCHAR));
        }

    } while( FALSE );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return(dwRetCode);
}

DWORD
DDMAdminRemoveQuarantine(
    IN HANDLE hConnection,
    IN BOOL fIsIpAddress)
{
    DWORD dwBucketIndex;
    CONNECTION_OBJECT *pConnObj = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fFound = FALSE;

    EnterCriticalSection(&gblDeviceTable.CriticalSection);

    if(fIsIpAddress)
    {
        for ( dwBucketIndex = 0;
              dwBucketIndex < gblDeviceTable.NumDeviceBuckets;
              dwBucketIndex++ )
        {
            for( pConnObj = gblDeviceTable.ConnectionBucket[dwBucketIndex];
                 pConnObj != (CONNECTION_OBJECT *)NULL;
                 pConnObj = pConnObj->pNext )
            {
                if(pConnObj->PppProjectionResult.ip.dwRemoteAddress == 
                                         HandleToUlong(hConnection))
                {
                    fFound = TRUE;
                    break;
                }
            }

            if(fFound)
            {
                break;
            }
        }
    }
    else
    {
        pConnObj = ConnObjGetPointer((HCONN) hConnection);
    }

    if(NULL != pConnObj)
    {
        //
        // If we have a valid connection object, Remove quarantine
        // on the connection object.
        //
        dwErr = RemoveQuarantineOnConnection(pConnObj);
    }
    else
    {
        dwErr = ERROR_INTERFACE_NOT_CONNECTED;
    }

    LeaveCriticalSection(&gblDeviceTable.CriticalSection);

    return dwErr;    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\closehnd.c ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	closehnd.c
//
// Description: This module contains auxiliary procedures for the
//		supervisor's procedure-driven state machine that
//              handles device closing events.
//
// Author:	Stefan Solomon (stefans)    June 1, 1992.
//
//***
#include "ddm.h"
#include "handlers.h"
#include "objects.h"
#include <raserror.h>
#include <ddmif.h>
#include <util.h>
#include "rasmanif.h"
#include "isdn.h"
#include "timer.h"
#include <ntlsapi.h>
#include <stdio.h>
#include <stdlib.h>

//***
//
// Function:	DevStartClosing
//
// Descr:
//
//***
VOID
DevStartClosing(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    PCONNECTION_OBJECT pConnObj;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "DevStartClosing: Entered, hPort=%d", pDeviceObj->hPort);

    //
    // Was this a failure for a BAP callback?
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_BAP_CALLBACK )
    {
        PppDdmBapCallbackResult( pDeviceObj->hBapConnection,
                                  ERROR_PORT_DISCONNECTED );

        pDeviceObj->fFlags &= ~DEV_OBJ_BAP_CALLBACK;
    }

    //
    // If not disconnected, disconnect the line.
    //

    if( pDeviceObj->ConnectionState != DISCONNECTED )
    {
        if(( gblDDMConfigInfo.pServiceStatus->dwCurrentState ==
                                            SERVICE_STOP_PENDING) &&
                                            (!IsPortOwned(pDeviceObj)))
        {
           //
           // RAS service is stopping and we do not own the port
           // so just mark the state as DISCONNECTED
           //

           pDeviceObj->ConnectionState = DISCONNECTED;

           DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                      "DevStartClosing:Disconnect not posted for biplx port%d",
                    pDeviceObj->hPort);
        }
        else
        {
            RmDisconnect( pDeviceObj );
        }
    }

    //
    // If we are doing security dialog.
    //

    if ( pDeviceObj->SecurityState == DEV_OBJ_SECURITY_DIALOG_ACTIVE )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "DevStartClosing:Notifying sec. dll to Disconnect");

        //
        // If this fails then we assume that this port has been cleaned up
        //

        if ( (*gblDDMConfigInfo.lpfnRasEndSecurityDialog)( pDeviceObj->hPort )
             != NO_ERROR )
        {
            pDeviceObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_INACTIVE;
        }
        else
        {
            pDeviceObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_STOPPING;
        }
    }

    //
    // If authentication is active, stop it
    //
    pDeviceObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);

    if ( ( pConnObj = ConnObjGetPointer( pDeviceObj->hConnection ) ) != NULL )
    {
        //
        // If our previous state has been active, get the time the user has been
        // active and log the result.
        //

        if (pDeviceObj->DeviceState == DEV_OBJ_ACTIVE)
        {
            LogConnectionEvent( pConnObj, pDeviceObj );
        }
    }

    //
    // If receive frame was active, stop it.
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_RECEIVE_ACTIVE )
    {
        pDeviceObj->fFlags &= (~DEV_OBJ_RECEIVE_ACTIVE );
    }

    //
    // Stop timers. If no timer active, StopTimer still returns OK
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvDiscTimeout );

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvSecurityTimeout );

    //
    // Finally, change the state to closing
    //

    pDeviceObj->DeviceState = DEV_OBJ_CLOSING;

    //
    // If any any resources are still active, closing will have to wait
    // until all resources are released.
    // Check if everything has closed
    //

    DevCloseComplete( pDeviceObj );
}

//***
//
// Function:    DevCloseComplete
//
// Description: Checks if there are still resources allocated.
//	            If all cleaned up goes to next state
//
//***
VOID
DevCloseComplete(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    BOOL                fAuthClosed        = FALSE;
    BOOL                fRecvClosed        = FALSE;
    BOOL                fConnClosed        = FALSE;
    BOOL                fSecurityClosed    = FALSE;
    BOOL                fPppClosed         = FALSE;
    PCONNECTION_OBJECT  pConnObj = ConnObjGetPointer( pDeviceObj->hConnection );

    if ( !( pDeviceObj->fFlags & DEV_OBJ_AUTH_ACTIVE ) )
    {
        fAuthClosed = TRUE;
    }

    if ( !( pDeviceObj->fFlags & DEV_OBJ_RECEIVE_ACTIVE ) )
    {
        fRecvClosed = TRUE;
    }

    if ( !( pDeviceObj->fFlags & DEV_OBJ_PPP_IS_ACTIVE ) )
    {
        fPppClosed = TRUE;
    }

    //
    // Was this is the last link in the connection
    //

    if (pDeviceObj->ConnectionState == DISCONNECTED )
    {
        fConnClosed = TRUE;
    }

    if (pDeviceObj->SecurityState == DEV_OBJ_SECURITY_DIALOG_INACTIVE )
    {
        fSecurityClosed = TRUE;
    }

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
    "DevCloseComplete:hPort=%d,Auth=%d,Rcv=%d,Conn=%d %d,Sec=%d %d,Ppp=%d",
            pDeviceObj->hPort, 
            !fAuthClosed, 
            !fRecvClosed,
            pConnObj ? 0 : 1,
            !fConnClosed, 
            pDeviceObj->ConnectionState, 
            pDeviceObj->SecurityState,
            !fPppClosed );

    if ( fAuthClosed            &&
         fRecvClosed            &&
         fConnClosed            &&
         fSecurityClosed        &&
         fPppClosed )
    {
        //
        // Was this the last link in the bundle? If it was we clean up
        //

        if ( pConnObj != NULL )
        {
            HPORT hPortConnected;

            //
            // Remove this link from the connection
            //

            ConnObjRemoveLink( pDeviceObj->hConnection, pDeviceObj );

            //
            // If admin module is loaded, notify it of a link disconnection
            //

            if ( pDeviceObj->fFlags & DEV_OBJ_NOTIFY_OF_DISCONNECTION )
            {
                RAS_PORT_0 RasPort0;
                RAS_PORT_1 RasPort1;
                VOID (*MprAdminLinkHangupNotification)(RAS_PORT_0 *,
                                                       RAS_PORT_1*);

                if ((GetRasPort0Data(pDeviceObj,&RasPort0) == NO_ERROR)
                     &&
                    (GetRasPort1Data(pDeviceObj,&RasPort1) == NO_ERROR))
                {
                    DWORD i;
        
                    for (i=0;  i<gblDDMConfigInfo.NumAdminDlls;  i++)
                    {
                        PADMIN_DLL_CALLBACKS AdminDllCallbacks = &gblDDMConfigInfo.AdminDllCallbacks[i];

                        if (AdminDllCallbacks->lpfnRasAdminLinkHangupNotification != NULL)
                        {
                            MprAdminLinkHangupNotification =
                                (VOID (*)( RAS_PORT_0 *, RAS_PORT_1 * ))
                                    AdminDllCallbacks->lpfnRasAdminLinkHangupNotification;

                            MprAdminLinkHangupNotification( &RasPort0, &RasPort1 );
                        }
                    }
                }
            }

            //
            // Confirm with RASMAN that there are no more ports in this
            // bundle. It may be that there is one but DDM has not gotten
            // a NewLink message from PPP yet.
            //

            if ( ( RasBundleGetPort( NULL, pConnObj->hConnection,
                                     &hPortConnected ) != NO_ERROR ) &&
                 ( pConnObj->cActiveDevices == 0 ) )
            {
                //
                // If admin module is loaded, notify it of disconnection
                //

                if ( pConnObj->fFlags & CONN_OBJ_NOTIFY_OF_DISCONNECTION )
                {
                    ConnectionHangupNotification( pConnObj );
                }

                //
                // Remove the interface object if it is not a full router.
                //

                if ( pConnObj->hDIMInterface != INVALID_HANDLE_VALUE )
                {
                    ROUTER_INTERFACE_OBJECT * pIfObject;

                    EnterCriticalSection(
                                    &(gblpInterfaceTable->CriticalSection));

                    pIfObject = IfObjectGetPointer( pConnObj->hDIMInterface );

                    if ( pIfObject != NULL )
                    {
                        IfObjectDisconnected( pIfObject );

                        if ( pIfObject->IfType != ROUTER_IF_TYPE_FULL_ROUTER )
                        {
                            IfObjectDeleteInterface( pIfObject );

                            IfObjectRemove( pConnObj->hDIMInterface );
                        }
                    }

                    LeaveCriticalSection(
                                        &(gblpInterfaceTable->CriticalSection));
                }

                //
                // Remove the Connection Object
                //

                ConnObjRemoveAndDeAllocate( pDeviceObj->hConnection );
            }
        }

        //
        // Release the media (if any) used by this port
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE )
        {
            pDeviceObj->fFlags &= ~DEV_OBJ_MARKED_AS_INUSE;

            gblDeviceTable.NumDevicesInUse--;

            //
            // Increase media count for this device
            //

            if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
            {
                MediaObjAddToTable( pDeviceObj->wchDeviceType );
            }

            //
            // Possibly need to notify router managers of reachability
            // change
            //

            EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

            IfObjectNotifyAllOfReachabilityChange( TRUE,
                                                   INTERFACE_OUT_OF_RESOURCES );

            LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
        }

        //
        // Release any RasMan buffers if we have allocated them
        //

        if ( pDeviceObj->pRasmanSendBuffer != NULL )
        {
            RasFreeBuffer( pDeviceObj->pRasmanSendBuffer );
            pDeviceObj->pRasmanSendBuffer = NULL;
        }

        if ( pDeviceObj->pRasmanRecvBuffer != NULL )
        {
            RasFreeBuffer( pDeviceObj->pRasmanRecvBuffer );
            pDeviceObj->pRasmanRecvBuffer = NULL;
        }

        RasSetRouterUsage( pDeviceObj->hPort, FALSE );

        //
        // If we have gotten a PnP remove message, then discard this port
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_PNP_DELETE )
        {
            //
            // We do this in a worker thread since this thread may be
            // walking the device list, hence we cannot modify it here.
            //

            RtlQueueWorkItem( DeviceObjRemoveFromTable,
                              pDeviceObj->hPort,
                              WT_EXECUTEDEFAULT );
            return;
        }
        else
        {
            //
            // Reset fields in this port device
            //

            pDeviceObj->hConnection             = (HCONN)INVALID_HANDLE_VALUE;
            pDeviceObj->wchUserName[0]          = (WCHAR)NULL;
            pDeviceObj->wchDomainName[0]        = (WCHAR)NULL;
            pDeviceObj->wchCallbackNumber[0]    = (WCHAR)NULL;
            pDeviceObj->fFlags                  &= (~DEV_OBJ_IS_PPP);
            pDeviceObj->dwDisconnectReason      = 0;
        }

        //
        // switch to next state (based on the present service state)
        //

        switch ( gblDDMConfigInfo.pServiceStatus->dwCurrentState )
        {
            case SERVICE_RUNNING:
            case SERVICE_START_PENDING:

                //
                // post a listen on the device
                //

                pDeviceObj->DeviceState = DEV_OBJ_LISTENING;
                RmListen(pDeviceObj);
                break;

            case SERVICE_PAUSED:

                //
                // wait for the service to be running again
                //

                pDeviceObj->DeviceState = DEV_OBJ_CLOSED;
                break;

            case SERVICE_STOP_PENDING:

                //
                // this device has terminated. Announce the closure to
                // the central stop service coordinator
                //

                pDeviceObj->DeviceState = DEV_OBJ_CLOSED;
                DDMServiceStopComplete();
                break;

            default:

                RTASSERT(FALSE);
                break;
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\connobj.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    connobj.c
//
// Description: Routines to manipulate CONNECTION_OBJECTs
//
// History:     May 11,1995	    NarenG		Created original version.
//
#include "ddm.h"
#include "handlers.h"
#include "objects.h"
#include <raserror.h>
#include <dimif.h>
#include "rasmanif.h"
#include <objbase.h>
#include <stdlib.h>

//**
//
// Call:        ConnObjAllocateAndInit
//
// Returns:     CONNECTION_OBJECT *   - Success
//              NULL                  - Failure
//
// Description: Allocates and initializes a CONNECTION_OBJECT structure
//
CONNECTION_OBJECT *
ConnObjAllocateAndInit(
    IN HANDLE  hDIMInterface,
    IN HCONN   hConnection
)
{
    CONNECTION_OBJECT * pConnObj;

    pConnObj = (CONNECTION_OBJECT *)LOCAL_ALLOC( LPTR,
                                                sizeof( CONNECTION_OBJECT ) );

    if ( pConnObj == (CONNECTION_OBJECT *)NULL )
    {
        return( (CONNECTION_OBJECT *)NULL );
    }

    pConnObj->hConnection           = hConnection;
    pConnObj->hDIMInterface         = hDIMInterface;

    pConnObj->cDeviceListSize = 5;

    pConnObj->pDeviceList = (PDEVICE_OBJECT *)LOCAL_ALLOC( LPTR,
                                                pConnObj->cDeviceListSize
                                                * sizeof( PDEVICE_OBJECT ) );

    if ( pConnObj->pDeviceList == (PDEVICE_OBJECT *)NULL )
    {
        LOCAL_FREE( pConnObj );

        return( (CONNECTION_OBJECT *)NULL );
    }

    pConnObj->PppProjectionResult.ip.dwError =ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pConnObj->PppProjectionResult.ipx.dwError=ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pConnObj->PppProjectionResult.nbf.dwError=ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pConnObj->PppProjectionResult.ccp.dwError=ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    pConnObj->PppProjectionResult.at.dwError =ERROR_PPP_NO_PROTOCOLS_CONFIGURED;

    if(S_OK != CoCreateGuid( &(pConnObj->guid) ))
    {
        LOCAL_FREE(pConnObj->pDeviceList);
        LOCAL_FREE(pConnObj);
        pConnObj = NULL;
    }

    return( pConnObj );
}

//**
//
// Call:        ConnObjInsertInTable
//
// Returns:     None
//
// Description: Will insert a connection object into the connection object
//              hash table.
//
VOID
ConnObjInsertInTable(
    IN CONNECTION_OBJECT * pConnObj
)
{
    DWORD dwBucketIndex = ConnObjHashConnHandleToBucket(pConnObj->hConnection);

    pConnObj->pNext = gblDeviceTable.ConnectionBucket[dwBucketIndex];

    gblDeviceTable.ConnectionBucket[dwBucketIndex] = pConnObj;

    gblDeviceTable.NumConnectionNodes++;
}

//**
//
// Call:        ConnObjGetPointer
//
// Returns:     Pointer to the required Connection Object.
//
// Description: Will look up the connection hash table and return a pointer
//              to the connection object with the passed in connection handle.
//
CONNECTION_OBJECT *
ConnObjGetPointer(
    IN HCONN hConnection
)
{
    DWORD               dwBucketIndex;
    CONNECTION_OBJECT * pConnObj;

    dwBucketIndex = ConnObjHashConnHandleToBucket( hConnection );

    for( pConnObj = gblDeviceTable.ConnectionBucket[dwBucketIndex];
         pConnObj != (CONNECTION_OBJECT *)NULL;
         pConnObj = pConnObj->pNext )
    {
        if ( pConnObj->hConnection == hConnection )
        {
            return( pConnObj );
        }
    }

    return( (CONNECTION_OBJECT *)NULL );
}

//**
//
// Call:        ConnObjHashConnHandleToBucket
//
// Returns:     Will return the bucket number that the connection handle
//              hashes to. Starting from 0.
//
// Description: Will hash a connection handle to a bucket in the connection
//              object hash table.
//
DWORD
ConnObjHashConnHandleToBucket(
    IN HCONN hConnection
)
{
    return( ((DWORD)HandleToUlong(hConnection)) % gblDeviceTable.NumConnectionBuckets );
}

//**
//
// Call:        ConnObjRemove
//
// Returns:     Pointer to the CONNECTION_OBJECT that is removed from the
//              table - Success
//              NULL  - Failure
//
// Description: Will remove a connection object from the connection hash table.
//              The object is not freed.
//
PCONNECTION_OBJECT
ConnObjRemove(
    IN HCONN hConnection
)
{
    DWORD               dwBucketIndex;
    CONNECTION_OBJECT * pConnObj;
    CONNECTION_OBJECT * pConnObjPrev;

    dwBucketIndex = ConnObjHashConnHandleToBucket( hConnection );

    pConnObj     = gblDeviceTable.ConnectionBucket[dwBucketIndex];
    pConnObjPrev = pConnObj;

    while( pConnObj != (CONNECTION_OBJECT *)NULL )
    {
        if ( pConnObj->hConnection == hConnection )
        {
            if ( gblDeviceTable.ConnectionBucket[dwBucketIndex] == pConnObj )
            {
                gblDeviceTable.ConnectionBucket[dwBucketIndex]=pConnObj->pNext;
            }
            else
            {
                pConnObjPrev->pNext = pConnObj->pNext;
            }

            gblDeviceTable.NumConnectionNodes--;

            return( pConnObj );
        }

        pConnObjPrev = pConnObj;
        pConnObj     = pConnObj->pNext;
    }

    return( NULL );
}

//**
//
// Call:        ConnObjRemoveAndDeAllocate
//
// Returns:     None
//
// Description: Will remove a connection object from the connection hash table
//              and free it.
//
VOID
ConnObjRemoveAndDeAllocate(
    IN HCONN hConnection
)
{
    CONNECTION_OBJECT * pConnObj = ConnObjRemove( hConnection );

    if ( pConnObj != (CONNECTION_OBJECT *)NULL )
    {
        if ( pConnObj->pDeviceList != (PDEVICE_OBJECT *)NULL )
        {
            LOCAL_FREE( pConnObj->pDeviceList );
        }

        if(pConnObj->pQuarantineFilter != NULL)
        {
            MprInfoDelete(pConnObj->pQuarantineFilter);
        }

        if(pConnObj->pFilter != NULL)
        {
            MprInfoDelete(pConnObj->pFilter);
        }

        LOCAL_FREE( pConnObj );
    }
}

//**
//
// Call:        ConnObjAddLink
//
// Returns:     NO_ERROR                - Success
//              ERROR_NOT_ENOUGH_MEMORY - Failure
//
// Description: Will add a link to the connection object
//
DWORD
ConnObjAddLink(
    IN CONNECTION_OBJECT * pConnObj,
    IN DEVICE_OBJECT *     pDeviceObj
)
{
    DWORD dwIndex;

    //
    // First check to see if the link is not already added
    //

    for ( dwIndex = 0; dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
    {
        if ( pConnObj->pDeviceList[dwIndex] == pDeviceObj )
        {
            return( NO_ERROR );
        }
    }

    //
    // A connection object for this handle exists, try to insert the link
    //

    for ( dwIndex = 0; dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
    {
        if ( pConnObj->pDeviceList[dwIndex] == (DEVICE_OBJECT *)NULL )
        {
            pConnObj->pDeviceList[dwIndex] = pDeviceObj;
            break;
        }
    }

    //
    // No space for the new link so allocate more memory.
    //

    if ( dwIndex == pConnObj->cDeviceListSize )
    {
        LPVOID Tmp = pConnObj->pDeviceList;
        
        pConnObj->cDeviceListSize += 5;

        Tmp = (PDEVICE_OBJECT *)LOCAL_REALLOC(
                                                pConnObj->pDeviceList,
                                                pConnObj->cDeviceListSize
                                                * sizeof( PDEVICE_OBJECT ) );

        if ( Tmp  == (PDEVICE_OBJECT *)NULL )
        {
            if (pConnObj->pDeviceList)
            {
                LOCAL_FREE(pConnObj->pDeviceList);
            }
            return( ERROR_NOT_ENOUGH_MEMORY );
        }
        else
        {
            pConnObj->pDeviceList = Tmp;
        }
        
        pConnObj->pDeviceList[pConnObj->cDeviceListSize-5] = pDeviceObj;
    }

    pConnObj->cActiveDevices++;

    return( NO_ERROR );

}

//**
//
// Call:        ConnObjRemoveLink
//
// Returns:     None
//
// Description: Will remove a link from the connection object.
//
VOID
ConnObjRemoveLink(
    IN HCONN            hConnection,
    IN DEVICE_OBJECT *  pDeviceObj
)
{
    CONNECTION_OBJECT * pConnObj;
    DWORD               dwIndex;

    //
    // If there is no such connection object
    //

    if ( ( pConnObj = ConnObjGetPointer( hConnection ) ) == NULL )
    {
        return;
    }

    //
    // A connection object for this handle exists, try to find and remove
    // the link
    //

    for ( dwIndex = 0; dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
    {
        if ( pConnObj->pDeviceList[dwIndex] == pDeviceObj )
        {
            pConnObj->pDeviceList[dwIndex] = (DEVICE_OBJECT *)NULL;

            pConnObj->cActiveDevices--;

            return;
        }
    }

    return;
}

//**
//
// Call:        ConnObjDisconnect
//
// Returns:     None
//
// Description: Will initiate a disconnect for all the devices or links in this
//              connection.
//
VOID
ConnObjDisconnect(
    IN  CONNECTION_OBJECT * pConnObj
)
{
    DWORD   dwIndex;
    DWORD   cActiveDevices = pConnObj->cActiveDevices;

    RTASSERT( pConnObj != NULL );

    //
    // Bring down all the individual links
    //

    for ( dwIndex = 0;  dwIndex < pConnObj->cDeviceListSize; dwIndex++ )
    {
        DEVICE_OBJECT * pDeviceObj = pConnObj->pDeviceList[dwIndex];

        if ( pDeviceObj != (DEVICE_OBJECT *)NULL )
        {
            if ( pDeviceObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
            {
                RasApiCleanUpPort( pDeviceObj );
            }
            else
            {
                if ( pDeviceObj->fFlags & DEV_OBJ_PPP_IS_ACTIVE )
                {
                    PppDdmStop( (HPORT)pDeviceObj->hPort, NO_ERROR );
                }
                else
                {
                    DevStartClosing( pDeviceObj );
                }
            }

            if ( --cActiveDevices == 0 )
            {
                break;
            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\ddm.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    ddm.h
//
// Description: This module contains the definitions for Demand Dial Manager
//              component.
//
// History:     May 11,1995	    NarenG      Created original version.
//

#ifndef _DDM_
#define _DDM_

#include <nt.h>
#include <ntrtl.h>      // For ASSERT
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>    // Win32 base API's
#include <rtutils.h>
#include <lmcons.h>
#include <ras.h>        // For HRASCONN
#include <rasman.h>     // For HPORT
#include <rasppp.h>     // For PPP_INTERFACE_INFO
#include <dim.h>
#include <mprlog.h>
#include <raserror.h>
#include <mprerror.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <string.h>
#include <dimif.h>
#include <nb30.h>
#include <rasppp.h>     // For PPP_PROJECTION_INFO
#include <pppcp.h>
#include <srvauth.h>
#include <sechost.h>    // RASSECURITYPROC
#include <iprtrmib.h>
#include <mprapip.h>


typedef
DWORD
(*ALLOCATEANDGETIFTABLEFROMSTACK)(
    OUT MIB_IFTABLE **ppIfTable,
    IN  BOOL        bOrder,
    IN  HANDLE      hHeap,
    IN  DWORD       dwFlags,
    IN  BOOL        bForceUpdate
    );

typedef
DWORD
(*ALLOCATEANDGETIPADDRTABLEFROMSTACK)(
    OUT MIB_IPADDRTABLE   **ppIpAddrTable,
    IN  BOOL              bOrder,
    IN  HANDLE            hHeap,
    IN  DWORD             dwFlags
    );


//
// Macros for DDM
//

#define DDMLogError( LogId, NumStrings, lpwsSubStringArray, dwRetCode )     \
    if ( gblDDMConfigInfo.dwLoggingLevel > 0 ) {                            \
        RouterLogError( gblDDMConfigInfo.hLogEvents, LogId,                 \
                        NumStrings, lpwsSubStringArray, dwRetCode ); }

#define DDMLogWarning( LogId, NumStrings, lpwsSubStringArray )              \
    if ( gblDDMConfigInfo.dwLoggingLevel > 1 ) {                            \
        RouterLogWarning( gblDDMConfigInfo.hLogEvents, LogId,               \
                      NumStrings, lpwsSubStringArray, 0 ); }

#define DDMLogInformation( LogId, NumStrings, lpwsSubStringArray )          \
    if ( gblDDMConfigInfo.dwLoggingLevel > 2 ) {                            \
        RouterLogInformation( gblDDMConfigInfo.hLogEvents,                  \
                          LogId, NumStrings, lpwsSubStringArray, 0 ); }

#define DDMLogErrorString(LogId,NumStrings,lpwsSubStringArray,dwRetCode,    \
                          dwPos )                                           \
    if ( gblDDMConfigInfo.dwLoggingLevel > 0 ) {                            \
        RouterLogErrorString( gblDDMConfigInfo.hLogEvents, LogId,           \
                              NumStrings, lpwsSubStringArray, dwRetCode,    \
                              dwPos ); }

#define DDMLogWarningString( LogId,NumStrings,lpwsSubStringArray,dwRetCode, \
                            dwPos )                                         \
    if ( gblDDMConfigInfo.dwLoggingLevel > 1 ) {                            \
        RouterLogWarningString( gblDDMConfigInfo.hLogEvents, LogId,         \
                                NumStrings, lpwsSubStringArray, dwRetCode,  \
                                dwPos ); }

#define DDMLogInformationString( LogId, NumStrings, lpwsSubStringArray,     \
                                 dwRetCode, dwPos )                         \
    if ( gblDDMConfigInfo.dwLoggingLevel > 2 ) {                            \
        RouterLogInformationString( gblDDMConfigInfo.hLogEvents, LogId,     \
                                    NumStrings, lpwsSubStringArray,         \
                                    dwRetCode,dwPos ); }

#define DDM_PRINT                   TracePrintfExA

#define DDMTRACE(a)            \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a )

#define DDMTRACE1(a,b)         \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b )

#define DDMTRACE2(a,b,c)       \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b,c )

#define DDMTRACE3(a,b,c,d)     \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b,c,d )

#define DDMTRACE4(a,b,c,d,e)   \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b,c,d,e)

#define DDMTRACE5(a,b,c,d,e,f)       \
    TracePrintfExA(gblDDMConfigInfo.dwTraceId, TRACE_FSM, a,b,c,d,e,f )

//
// Constant defines for DDM
//

#define MAX_PROTOCOLS               2   // IP, IPX

#define HW_FAILURE_WAIT_TIME        10  // Waiting time (sec) before reposting
                                        // listen

#define INIT_GATEWAY_TIMEOUT    10000   //Gateway initialization timeout(msec)

#define MIN_DEVICE_TABLE_SIZE       5   // Smallest device hash table size

#define MAX_DEVICE_TABLE_SIZE       17  // Largest device hash table size

#define HW_FAILURE_CNT	            6   //nr of consecutive times a hw failure
                                        //may occur before being reported

#define DISC_TIMEOUT_CALLBACK       10

#define DISC_TIMEOUT_AUTHFAILURE    3

#define ANNOUNCE_PRESENCE_TIMEOUT   120L

#define DDM_HEAP_INITIAL_SIZE       20000       // approx 20K

#define DDM_HEAP_MAX_SIZE           0           // Not limited


//
// DDM Events Definitions
//

#define NUM_DDM_EVENTS              9   // All DDM events other than RASMAN

enum
{
    DDM_EVENT_SVC   = 0,
    DDM_EVENT_SVC_TERMINATED,
    DDM_EVENT_SECURITY_DLL,
    DDM_EVENT_PPP,
    DDM_EVENT_TIMER,
    DDM_EVENT_CHANGE_NOTIFICATION,
    DDM_EVENT_CHANGE_NOTIFICATION1,
    DDM_EVENT_CHANGE_NOTIFICATION2
};

//
//  Device Object FSM states definitions
//

typedef enum _DEV_OBJ_STATE
{
    DEV_OBJ_LISTENING,		        // waiting for a connection
    DEV_OBJ_LISTEN_COMPLETE,	    // Listen completed but not connected.
    DEV_OBJ_RECEIVING_FRAME,	    // waiting for a frame from the Rasman
    DEV_OBJ_HW_FAILURE,		        // waiting to repost a listen
    DEV_OBJ_AUTH_IS_ACTIVE,	        // auth started
    DEV_OBJ_ACTIVE,		            // connected and auth done
    DEV_OBJ_CALLBACK_DISCONNECTING, // wait for disconnect
    DEV_OBJ_CALLBACK_DISCONNECTED,  // wait for callback TO before reconn.
    DEV_OBJ_CALLBACK_CONNECTING,    // wait for reconnection
    DEV_OBJ_CLOSING,		        // wait for closing to complete
    DEV_OBJ_CLOSED		            // staying idle, waiting for service to
                                    // resume or to stop
}DEV_OBJ_STATE;

//
//  3rd party security dialog state
//

typedef enum _SECURITY_STATE
{
    DEV_OBJ_SECURITY_DIALOG_ACTIVE,
    DEV_OBJ_SECURITY_DIALOG_STOPPING,
    DEV_OBJ_SECURITY_DIALOG_INACTIVE

} SECURITY_STATE;

//
// Connection object flags
//

#define CONN_OBJ_IS_PPP                     0x00000001
#define CONN_OBJ_MESSENGER_PRESENT          0x00000004
#define CONN_OBJ_PROJECTIONS_NOTIFIED       0x00000008
#define CONN_OBJ_NOTIFY_OF_DISCONNECTION    0x00000010
#define CONN_OBJ_DISCONNECT_INITIATED       0x00000020
#define CONN_OBJ_QUARANTINE_PRESENT         0x00000040

//
// Device object flags
//

#define DEV_OBJ_IS_ADVANCED_SERVER          0x00000001
#define DEV_OBJ_IS_PPP                      0x00000002
#define DEV_OBJ_OPENED_FOR_DIALOUT          0x00000004
#define DEV_OBJ_MARKED_AS_INUSE             0x00000008
#define DEV_OBJ_NOTIFY_OF_DISCONNECTION     0x00000020
#define DEV_OBJ_ALLOW_ROUTERS               0x00000040
#define DEV_OBJ_ALLOW_CLIENTS               0x00000080
#define DEV_OBJ_BAP_CALLBACK                0x00000200
#define DEV_OBJ_PNP_DELETE                  0x00000400
#define DEV_OBJ_SECURITY_DLL_USED           0x00000800
#define DEV_OBJ_PPP_IS_ACTIVE               0x00001000
#define DEV_OBJ_RECEIVE_ACTIVE              0x00002000
#define DEV_OBJ_AUTH_ACTIVE                 0x00004000
#define DEV_OBJ_IPSEC_ERROR_LOGGED          0x00008000

//
// Global DDM config flags
//

#define DDM_USING_RADIUS_AUTHENTICATION     0x00000001
#define DDM_USING_RADIUS_ACCOUNTING         0x00000002
#define DDM_USING_NT_AUTHENTICATION         0x00000004
#define DDM_NO_CERTIFICATE_LOGGED           0x00000008

//
// Global DDM disconnect reasons
//
#define DDM_IDLE_DISCONNECT                 4
#define DDM_SESSION_TIMEOUT                 5

//
// ******************** Data structure definitions for DDM ********************
//

//
// Table of Event Numbers and Event Handlers
//

typedef VOID (*EVENTHANDLER)( VOID );

typedef struct _EVENT_HANDLER
{
    DWORD        EventId;
    EVENTHANDLER EventHandler;

} EVENT_HANDLER, *PEVENT_HANDLER;

typedef struct _NOTIFICATION_EVENT
{
    LIST_ENTRY          ListEntry;

    HANDLE              hEventClient;

    HANDLE              hEventRouter;

} NOTIFICATION_EVENT, *PNOTIFICATION_EVENT;

//
// Callbacks provided by extension admin dlls
//

typedef struct _ADMIN_DLL_CALLBACKS
{
    HINSTANCE       hInstAdminModule;

    LPVOID          lpfnMprAdminGetIpAddressForUser;

    LPVOID          lpfnMprAdminReleaseIpAddress;

    LPVOID          lpfnRasAdminAcceptNewConnection;

    LPVOID          lpfnRasAdminAcceptNewConnection2;

    LPVOID          lpfnRasAdminAcceptNewLink;

    LPVOID          lpfnRasAdminConnectionHangupNotification;

    LPVOID          lpfnRasAdminConnectionHangupNotification2;

    LPVOID          lpfnRasAdminLinkHangupNotification;

    LPVOID          lpfnRasAdminTerminateDll;

} ADMIN_DLL_CALLBACKS, *PADMIN_DLL_CALLBACKS;


//
// Configuration information for DDM
//

typedef struct _DDM_CONFIG_INFO
{
    DWORD           dwAuthenticateTime;

    DWORD           dwCallbackTime;

    DWORD           dwAutoDisconnectTime;

    DWORD           dwSecurityTime;

    DWORD           dwSystemTime;

    DWORD           dwAuthenticateRetries;

    DWORD           dwClientsPerProc;

    DWORD           dwCallbackRetries;

    DWORD           fFlags;

    DWORD           dwLoggingLevel;

    BOOL            fArapAllowed;

    BOOL            fRemoteListen;

    DWORD           dwServerFlags;

    DWORD           dwNumRouterManagers;

    DWORD           dwAnnouncePresenceTimer;

    SERVICE_STATUS* pServiceStatus;

    DWORD           dwTraceId;

    HANDLE          hHeap;

    HINSTANCE       hInstSecurityModule;

    BOOL            fRasSrvrInitialized;

    HANDLE          hIpHlpApi;

    ALLOCATEANDGETIFTABLEFROMSTACK      lpfnAllocateAndGetIfTableFromStack;

    ALLOCATEANDGETIPADDRTABLEFROMSTACK  lpfnAllocateAndGetIpAddrTableFromStack;

    HANDLE          hLogEvents;

    HKEY            hkeyParameters;

    HKEY            hkeyAccounting;

    HKEY            hkeyAuthentication;

    LPDWORD         lpdwNumThreadsRunning;

    LPVOID          lpfnIfObjectAllocateAndInit;

    LPVOID          lpfnIfObjectGetPointerByName;

    LPVOID          lpfnIfObjectGetPointer;

    LPVOID          lpfnIfObjectRemove;

    LPVOID          lpfnIfObjectInsertInTable;

    LPVOID          lpfnIfObjectWANDeviceInstalled;

    PADMIN_DLL_CALLBACKS AdminDllCallbacks;
    DWORD           NumAdminDlls;

    LPVOID          lpfnRouterIdentityObjectUpdate;

    DWORD           (*lpfnRasAuthProviderTerminate)( VOID );

    HINSTANCE       hinstAuthModule;

    DWORD           (*lpfnRasAcctProviderTerminate)( VOID );

    HINSTANCE       hinstAcctModule;

    DWORD           (*lpfnRasAcctConfigChangeNotification)( DWORD );

    DWORD           (*lpfnRasAuthConfigChangeNotification)( DWORD );

    CRITICAL_SECTION    CSAccountingSessionId;

    DWORD           dwAccountingSessionId;

    RASSECURITYPROC lpfnRasBeginSecurityDialog;

    RASSECURITYPROC lpfnRasEndSecurityDialog;

    LIST_ENTRY      NotificationEventListHead;

    DWORD           dwIndex;

    DWORD           cAnalogIPAddresses;

    LPWSTR          *apAnalogIPAddresses;

    DWORD           cDigitalIPAddresses;

    LPWSTR          *apDigitalIPAddresses;

    BOOL            fRasmanReferenced;

} DDM_CONFIG_INFO, *PDDM_CONFIG_INFO;



//
// The represents a device in the DDM
//

typedef struct _DEVICE_OBJECT
{
    struct _DEVICE_OBJECT * pNext;

    HPORT	        hPort;          // port handle returned by Ras Manager

    HRASCONN        hRasConn;       // Handle to an outgoing call

    HCONN           hConnection;    // Handle to the connection bundle

    HCONN           hBapConnection; // Used to notify BAP of callback failure

    DEV_OBJ_STATE   DeviceState;	// DCB FSM states

    RASMAN_STATE    ConnectionState;// state of connection, used by rasman if

    SECURITY_STATE  SecurityState;  // state of 3rd party security dialog

    DWORD           fFlags;

    DWORD           dwDeviceType;

    BYTE *          pRasmanSendBuffer; //RasMan buffer used for 3rd party secdll

    BYTE *	        pRasmanRecvBuffer; //RasMan buffer used for RasPortReceive

    DWORD	        dwRecvBufferLen;

    DWORD	        dwHwErrorSignalCount; // used in signaling hw error

    DWORD	        dwCallbackDelay;

    DWORD           dwCallbackRetries;

    DWORD           dwTotalNumberOfCalls;

    DWORD           dwIndex; // used for FEP processing in vpn case

    DWORD           dwDisconnectReason;

    SYSTEMTIME	    ConnectionTime;

    ULARGE_INTEGER	qwActiveTime;

    ULARGE_INTEGER  qwTotalConnectionTime;

    ULARGE_INTEGER  qwTotalBytesSent;

    ULARGE_INTEGER  qwTotalBytesReceived;

    ULARGE_INTEGER  qwTotalFramesSent;

    ULARGE_INTEGER  qwTotalFramesReceived;

    WCHAR	        wchUserName[UNLEN+1];   // Username and domain name in
                                            // this structure are used for 3rd
    WCHAR	        wchDomainName[DNLEN+1]; // party authentication and logging.

    WCHAR	        wchPortName[MAX_PORT_NAME+1];

    WCHAR	        wchMediaName[MAX_MEDIA_NAME+1];

    WCHAR	        wchDeviceType[MAX_DEVICETYPE_NAME+1];

    WCHAR	        wchDeviceName[MAX_DEVICE_NAME+1];

    WCHAR	        wchCallbackNumber[MAX_PHONE_NUMBER_LEN + 1];

}DEVICE_OBJECT, *PDEVICE_OBJECT;

//
// The represents a port bundle in the DDM
//

typedef struct _CONNECTION_OBJECT
{
    struct _CONNECTION_OBJECT   *pNext;

    HCONN           hConnection;

    HPORT           hPort;              
                                        
    HANDLE          hDIMInterface;      // Handle to the interface

    DWORD           fFlags;

    ULARGE_INTEGER	qwActiveTime;

    DWORD           cActiveDevices;     // Count of active devices in this list

    DWORD           cDeviceListSize;    // Size of devices list.

    PDEVICE_OBJECT* pDeviceList;        // List of connected devices

    PBYTE           pQuarantineFilter;

    PBYTE           pFilter;

    ROUTER_INTERFACE_TYPE InterfaceType;

    GUID            guid;

    WCHAR           wchInterfaceName[MAX_INTERFACE_NAME_LEN+1];

    WCHAR	        wchUserName[UNLEN+1];

    WCHAR	        wchDomainName[DNLEN+1];

    BYTE	        bComputerName[NCBNAMSZ];

    PPP_PROJECTION_RESULT PppProjectionResult;

} CONNECTION_OBJECT, *PCONNECTION_OBJECT;

//
// Hash table for devices and connections.
//

typedef struct _DEVICE_TABLE
{
    PDEVICE_OBJECT*     DeviceBucket;       // Array of device buckets.

    PCONNECTION_OBJECT* ConnectionBucket;   // Array of bundle buckets.

    DWORD               NumDeviceBuckets;   // # of device buckets in array

    DWORD               NumDeviceNodes;     // Total # of devices in the table

    DWORD               NumDevicesInUse;    // Total # of devices in use

    DWORD               NumConnectionBuckets;// Size of connection Hash Table

    DWORD               NumConnectionNodes; // # of active connections

    CRITICAL_SECTION    CriticalSection;    // Mutex around this table

} DEVICE_TABLE, *PDEVICE_TABLE;

typedef struct _MEDIA_OBJECT
{
    WCHAR               wchMediaName[MAX_MEDIA_NAME+1];

    DWORD               dwNumAvailable;

} MEDIA_OBJECT, *PMEDIA_OBJECT;

typedef struct _MEDIA_TABLE
{
    BOOL                fCheckInterfaces;

    DWORD               cMediaListSize;     // In number of entries

    MEDIA_OBJECT *      pMediaList;

    CRITICAL_SECTION    CriticalSection;

} MEDIA_TABLE;

//
// ********************** Globals variables for DDM **************************
//

#ifdef _ALLOCATE_DDM_GLOBALS_

#define DDM_EXTERN

#else

#define DDM_EXTERN extern

#endif

DDM_EXTERN
DDM_CONFIG_INFO         gblDDMConfigInfo;

DDM_EXTERN
DEVICE_TABLE            gblDeviceTable;     // Hash table of Devices

DDM_EXTERN
MEDIA_TABLE             gblMediaTable;      // Table of resources available

DDM_EXTERN
ROUTER_MANAGER_OBJECT * gblRouterManagers;  // List of Router Managers.

DDM_EXTERN
ROUTER_INTERFACE_TABLE* gblpInterfaceTable; // Hash table of Router Interfaces

DDM_EXTERN
HANDLE *                gblSupervisorEvents; // Array of supervisor events

DDM_EXTERN
HANDLE *                gblphEventDDMServiceState;  //Notifys DDM of DIM change

DDM_EXTERN
HANDLE *                gblphEventDDMTerminated;    //Notifys DIM of termination

DDM_EXTERN
EVENT_HANDLER           gblEventHandlerTable[NUM_DDM_EVENTS];

DDM_EXTERN
LPWSTR                  gblpRouterPhoneBook;

DDM_EXTERN
LPWSTR                  gblpszAdminRequest;

DDM_EXTERN
LPWSTR                  gblpszUserRequest;

DDM_EXTERN
LPWSTR                  gblpszHardwareFailure;

DDM_EXTERN
LPWSTR                  gblpszUnknownReason;

DDM_EXTERN
LPWSTR                  gblpszPm;

DDM_EXTERN
LPWSTR                  gblpszAm;

DDM_EXTERN
LPWSTR                  gblpszUnknown;

DDM_EXTERN
LPWSTR                  gblpszIdleDisconnect;

DDM_EXTERN
LPWSTR                  gblpszSessionTimeout;

#ifdef MEM_LEAK_CHECK

#define DDM_MEM_TABLE_SIZE 100

PVOID DdmMemTable[DDM_MEM_TABLE_SIZE];

#define LOCAL_ALLOC     DebugAlloc
#define LOCAL_FREE      DebugFree
#define LOCAL_REALLOC   DebugReAlloc

LPVOID
DebugAlloc( DWORD Flags, DWORD dwSize );

BOOL
DebugFree( PVOID pMem );

LPVOID
DebugReAlloc( PVOID pMem, DWORD dwSize );

#else

#define LOCAL_ALLOC(Flags,dwSize)   HeapAlloc( gblDDMConfigInfo.hHeap,  \
                                               HEAP_ZERO_MEMORY, dwSize )

#define LOCAL_FREE(hMem)            HeapFree( gblDDMConfigInfo.hHeap, 0, hMem )

#define LOCAL_REALLOC(hMem,dwSize)  HeapReAlloc( gblDDMConfigInfo.hHeap,  \
                                                 HEAP_ZERO_MEMORY,hMem,dwSize)
#endif

//
// ************************* Function Prototypes for DDM ********************
//

VOID
SignalHwError(
    IN PDEVICE_OBJECT
);

DWORD
LoadDDMParameters(
    IN  HKEY     hkeyParameters,
    IN  BOOL *   pfIpAllowed
);

DWORD
LoadSecurityModule(
    VOID
);

DWORD
LoadAdminModule(
    VOID
);

DWORD
LoadAndInitAuthOrAcctProvider(
    IN  BOOL        fAuthenticationProvider,
    IN  DWORD       dwNASIpAddress,
    OUT DWORD  *    lpdwStartAccountingSessionId,
    OUT LPVOID *    plpfnRasAuthProviderAuthenticateUser,
    OUT LPVOID *    plpfnRasAuthProviderFreeAttributes,
    OUT LPVOID *    plpfnRasAuthConfigChangeNotification,
    OUT LPVOID *    plpfnRasAcctProviderStartAccounting,
    OUT LPVOID *    plpfnRasAcctProviderInterimAccounting,
    OUT LPVOID *    plpfnRasAcctProviderStopAccounting,
    OUT LPVOID *    plpfnRasAcctProviderFreeAttributes,
    OUT LPVOID *    plpfnRasAcctConfigChangeNotification
);

DWORD
DdmFindBoundProtocols(
    OUT BOOL * pfBoundToIp,
    OUT BOOL * pfBoundToIpx,
    OUT BOOL * pfBoundToATalk
);

VOID
AnnouncePresence(
    VOID
);

VOID
InitializeMessageQs(
    IN HANDLE hEventSecurity,
    IN HANDLE hEventPPP
);

VOID
DeleteMessageQs(
    VOID
);

DWORD
AddressPoolInit(
    VOID
);

DWORD
lProtocolEnabled(
    IN HKEY            hKey,
    IN DWORD           dwPid,
    IN BOOL            fRasSrv,
    IN BOOL            fRouter,
    IN BOOL *          pfEnabled
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\arapif.c ===
/*******************************************************************/
/*	      Copyright(c)  1996 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	arapif.c
//
// Description: This module contains the procedures for the
//		        DDM-Arap interface
//
// Author:	    Shirish Koti    Sep 9, 1996
//
// Revision History:
//
//***

#include "ddm.h"
#include "util.h"
#include "isdn.h"
#include "objects.h"
#include "rasmanif.h"
#include "handlers.h"
#include <ddmif.h>
#include "arapif.h"

#include <timer.h>
#include <ctype.h>
#include <memory.h>
#include <string.h>


//
// prototypes for functions used in this file
//

VOID
ArapDDMAuthenticated(
    IN PDEVICE_OBJECT        pDeviceObj,
    IN ARAPDDM_AUTH_RESULT * pAuthResult
);

VOID
ArapDDMCallbackRequest(
    IN PDEVICE_OBJECT             pDeviceObj,
    IN ARAPDDM_CALLBACK_REQUEST  *pCbReq
);

VOID
ArapDDMDone(
    IN PDEVICE_OBJECT           pDeviceObj,
    IN DWORD                    NetAddress,
    IN DWORD                    SessTimeOut
);

VOID
ArapDDMFailure(
    IN PDEVICE_OBJECT       pDeviceObj,
    IN ARAPDDM_DISCONNECT  *pFailInfo
);


VOID
ArapDDMTimeOut(
    IN HANDLE hObject
);


//***
//
// Function:    ArapEventHandler
//              Waits for a message from Arap and depending on the message
//              type, executes the appropriate routine Loads Arap.dll and
//              gets all the entry points
//
// Parameters:  None
//
// Return:      Nothing
//
//
//***$


VOID
ArapEventHandler(
    IN VOID
)
{
    ARAP_MESSAGE    ArapMsg;
    PDEVICE_OBJECT  pDevObj;
    LPWSTR  portnamep;

    //
    // loop to get all messages
    //

    while( ServerReceiveMessage( MESSAGEQ_ID_ARAP, (BYTE *)&ArapMsg) )
    {

        EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

        //
	    // identify the message recipient
        //

        if ( ( pDevObj = DeviceObjGetPointer( ArapMsg.hPort ) ) == NULL )
        {
            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

	        return;
	    }

        //
	    // action on the message type
        //

	    switch( ArapMsg.dwMsgId )
        {

    	    case ARAPDDMMSG_Authenticated:

                ArapDDMAuthenticated(
                            pDevObj,
                            &ArapMsg.ExtraInfo.AuthResult);
	            break;

    	    case ARAPDDMMSG_CallbackRequest:

                ArapDDMCallbackRequest(
                            pDevObj,
                            &ArapMsg.ExtraInfo.CallbackRequest);
	            break;

	        case ARAPDDMMSG_Done:

                pDevObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);
                ArapDDMDone(pDevObj,
                            ArapMsg.ExtraInfo.Done.NetAddress,
                            ArapMsg.ExtraInfo.Done.SessTimeOut);
	            break;

            case ARAPDDMMSG_Inactive:

                //
                // Client has been inactive on all protocols for time
                // specified in the registry.  We disconnect the client.
                //

                portnamep = pDevObj->wchPortName;

                DDMLogInformation( ROUTERLOG_AUTODISCONNECT, 1, &portnamep );

                // break intentionally omitted here

            case ARAPDDMMSG_Disconnected:

                // in case we had this puppy sitting in the timer queue
                TimerQRemove( (HANDLE)pDevObj->hPort, ArapDDMTimeOut);

                DevStartClosing(pDevObj);

                break;

	        case ARAPDDMMSG_Failure:

                pDevObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);
                ArapDDMFailure(pDevObj, &ArapMsg.ExtraInfo.FailureInfo);
	            break;

    	    default:

    	        RTASSERT(FALSE);
	            break;
	        }

        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
    }

}



//***
//
// Function:    ArapDDMAuthenticated
//              Retrieves username and domain from the message and stores it
//              in the dcb.
//
// Parameters:  pDeviceObj - the dcb for this connection
//              pAuthResult - info for the user who is authenticated
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMAuthenticated(
    IN PDEVICE_OBJECT        pDeviceObj,
    IN ARAPDDM_AUTH_RESULT * pAuthResult
)
{
    DWORD   dwRetCode;
    WCHAR   wchUserName[UNLEN+1];
    PCONNECTION_OBJECT  pConnObj;


    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "ArapDDMAuthenticated: Entered, hPort=%d", pDeviceObj->hPort);

    if ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE )
    {
	    return;
    }

    pConnObj = ConnObjGetPointer( pDeviceObj->hConnection );

    RTASSERT( pConnObj != NULL );

    // this shouldn't happen, but if it does, just ignore this call
    if (pConnObj == NULL)
    {
        return;
    }

    //
    // Stop authentication timer
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    //
    // devObj: copy the user name, domain name
    //

    if ( wcslen( pAuthResult->wchUserName ) > 0 )
    {
        wcscpy(wchUserName, pAuthResult->wchUserName);
    }
    else
    {
        wcscpy( wchUserName, gblpszUnknown );
    }

    wcscpy( pDeviceObj->wchUserName, wchUserName );
    wcscpy( pDeviceObj->wchDomainName, pAuthResult->wchLogonDomain );

    //
    // connObj: copy the user name, domain name, etc.
    //

    wcscpy( pConnObj->wchUserName, wchUserName );
    wcscpy( pConnObj->wchDomainName, pAuthResult->wchLogonDomain );
    wcscpy( pConnObj->wchInterfaceName, pDeviceObj->wchUserName );
    pConnObj->hPort = pDeviceObj->hPort;

}



//***
//
// Function:    ArapDDMCallbackRequest
//              Disconnects the connection, setting it up for a callback
//
// Parameters:  pDeviceObj - the dcb for this connection
//              pCbReq - call back info
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMCallbackRequest(
    IN PDEVICE_OBJECT             pDeviceObj,
    IN ARAPDDM_CALLBACK_REQUEST  *pCbReq
)
{

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "ArapDDMCallbackRequest: Entered, hPort = %d\n",
               pDeviceObj->hPort);

    //
    // check the state
    //

    if (pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE)
    {
	    return;
    }

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    //
    // copy relevant fields in our dcb
    //

    if (pCbReq->fUseCallbackDelay)
    {
	    pDeviceObj->dwCallbackDelay = pCbReq->dwCallbackDelay;
    }
    else
    {
	    pDeviceObj->dwCallbackDelay = gblDDMConfigInfo.dwCallbackTime;
    }

    mbstowcs(pDeviceObj->wchCallbackNumber, pCbReq->szCallbackNumber,
             MAX_PHONE_NUMBER_LEN + 1 );

    //
    // Disconnect the line and change the state
    //

    pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTING;

    //
    // Wait to enable the client to get the message
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvDiscTimeout );

    TimerQInsert( (HANDLE)pDeviceObj->hPort,
                  DISC_TIMEOUT_CALLBACK, SvDiscTimeout );
}


//***
//
// Function:    ArapDDMDone
//              Logs an event, marks the state
//
// Parameters:  pDeviceObj - the dcb for this connection
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMDone(
    IN PDEVICE_OBJECT           pDeviceObj,
    IN DWORD                    NetAddress,
    IN DWORD                    SessTimeOut
)
{
    LPWSTR                      lpstrAudit[2];
    PCONNECTION_OBJECT          pConnObj;
    WCHAR                       wchFullUserName[UNLEN+DNLEN+2];
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwRetCode;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "ArapDDMDone: Entered, hPort=%d", pDeviceObj->hPort);

    if ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE )
    {
	    return;
    }

    //
    // Get connection object for this connection
    //

    pConnObj = ConnObjGetPointer( pDeviceObj->hConnection );

    RTASSERT( pConnObj != NULL );

    // this shouldn't happen, but if it does, just ignore this call
    if (pConnObj == NULL)
    {
        return;
    }

    pConnObj->PppProjectionResult.at.dwError = NO_ERROR;
    pConnObj->PppProjectionResult.at.dwRemoteAddress = NetAddress;

    //
    // Create client interface object for this connection
    //

    pIfObject = IfObjectAllocateAndInit( pConnObj->wchUserName,
                                         RISTATE_CONNECTED,
                                         ROUTER_IF_TYPE_CLIENT,
                                         pConnObj->hConnection,
                                         TRUE,
                                         0,
                                         0,
                                         NULL,
                                         NULL);

    if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
    {
        //
        // Error log this and stop the connection.
        //

        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 1, NULL, GetLastError() );

        DevStartClosing( pDeviceObj );

        return;
    }

    //
    // Insert in table now
    //

    dwRetCode = IfObjectInsertInTable( pIfObject );

    if ( dwRetCode != NO_ERROR )
    {
        LOCAL_FREE( pIfObject );

        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 1, NULL, dwRetCode );

        DevStartClosing( pDeviceObj );

        return;
    }

    pConnObj->hDIMInterface = pIfObject->hDIMInterface;

    //
    // Reduce the media count for this device
    //

    if ( !(pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE) )
    {
        if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
        {
            MediaObjRemoveFromTable( pDeviceObj->wchDeviceType );
        }

        pDeviceObj->fFlags |= DEV_OBJ_MARKED_AS_INUSE;

        gblDeviceTable.NumDevicesInUse++;

        //
        // Possibly need to notify the router managers of unreachability
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( FALSE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    }

    //
    // Stop authentication timer (this will be running in case of callback)
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    //
    // if a session timeout is specified in the policy, put this connection on
    // the timer queue so the user gets kicked off after the session timeout
    //
    if (SessTimeOut != (DWORD)-1)
    {
        TimerQInsert( (HANDLE)pDeviceObj->hPort, SessTimeOut, ArapDDMTimeOut);
    }

    //
    // log authentication success
    //

    if ( pDeviceObj->wchDomainName[0] != TEXT('\0') )
    {
        wcscpy( wchFullUserName, pDeviceObj->wchDomainName );
        wcscat( wchFullUserName, TEXT("\\") );
        wcscat( wchFullUserName, pDeviceObj->wchUserName );
    }
    else
    {
        wcscpy( wchFullUserName, pDeviceObj->wchUserName );
    }

    lpstrAudit[0] = wchFullUserName;
    lpstrAudit[1] = pDeviceObj->wchPortName;


    DDMLogInformation( ROUTERLOG_AUTH_SUCCESS, 2, lpstrAudit);

    //
    // and finaly go to ACTIVE state
    //

    pDeviceObj->DeviceState = DEV_OBJ_ACTIVE;

    pDeviceObj->dwTotalNumberOfCalls++;

    //
    // and initialize the active time
    //

    GetSystemTimeAsFileTime( (FILETIME*)&(pConnObj->qwActiveTime) );

    GetSystemTimeAsFileTime( (FILETIME*)&(pDeviceObj->qwActiveTime) );

    return;
}




//***
//
// Function:    ArapDDMFailure
//              Closes the dcb, and logs an event depending on why connection failed
//
// Parameters:  pDeviceObj - the dcb for this connection
//              pFailInfo - info about who disconnected and how (or why)
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMFailure(
    IN PDEVICE_OBJECT       pDeviceObj,
    IN ARAPDDM_DISCONNECT  *pFailInfo
)
{
    LPWSTR auditstrp[3];
    WCHAR  wchErrorString[256+1];
    WCHAR  wchUserName[UNLEN+1];
    WCHAR  wchDomainName[DNLEN+1];
    DWORD dwRetCode;


    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "ArapDDMFailure: Entered, hPort=%d\n", pDeviceObj->hPort);

    //
    // ignore the DeviceState here: disconnect can happen at any time during
    // the connection
    //

    switch( pFailInfo->dwError )
    {
        case ERROR_AUTHENTICATION_FAILURE:

            wcscpy( wchUserName, pFailInfo->wchUserName );

            auditstrp[0] = wchUserName;
            auditstrp[1] = pDeviceObj->wchPortName;
            DDMLogWarning(ROUTERLOG_AUTH_FAILURE,2,auditstrp );
            break;

        case ERROR_PASSWD_EXPIRED:

            wcscpy( wchUserName, pFailInfo->wchUserName );
            wcscpy( wchDomainName, pFailInfo->wchLogonDomain );

            auditstrp[0] = wchDomainName;
            auditstrp[1] = wchUserName;
            auditstrp[2] = pDeviceObj->wchPortName;

            DDMLogWarning( ROUTERLOG_PASSWORD_EXPIRED,3,auditstrp );
            break;

        case ERROR_ACCT_EXPIRED:

            wcscpy( wchUserName, pFailInfo->wchUserName );
            wcscpy( wchDomainName, pFailInfo->wchLogonDomain );

            auditstrp[0] = wchDomainName;
            auditstrp[1] = wchUserName;
            auditstrp[2] = pDeviceObj->wchPortName;

            DDMLogWarning( ROUTERLOG_ACCT_EXPIRED, 3, auditstrp );
            break;

        case ERROR_NO_DIALIN_PERMISSION:

            wcscpy( wchUserName, pFailInfo->wchUserName );
            wcscpy( wchDomainName, pFailInfo->wchLogonDomain );

            auditstrp[0] = wchDomainName;
            auditstrp[1] = wchUserName;
            auditstrp[2] = pDeviceObj->wchPortName;

            DDMLogWarning( ROUTERLOG_NO_DIALIN_PRIVILEGE,3,auditstrp );
            break;

        default:

            auditstrp[0] = pDeviceObj->wchPortName;
            auditstrp[1] = wchErrorString;

            DDMLogErrorString( ROUTERLOG_ARAP_FAILURE, 2, auditstrp,
                               pFailInfo->dwError, 2 );
            break;
    }

    DevStartClosing( pDeviceObj );
}



//***
//
// Function:    ArapDDMTimeOut
//              Closes the connection when the timeout specified in policy elapses
//
// Parameters:  hPort
//
// Return:      Nothing
//
//
//***$

VOID
ArapDDMTimeOut(
    IN HANDLE hPort
)
{
    PDEVICE_OBJECT       pDeviceObj;


    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hPort );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    ArapDisconnect((HPORT)pDeviceObj->hPort);

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

}



//
// The following two structures (and the RasSetDevConfig call) copied from
// ras\ui\common\nouiutil\rasman.c, courtesy SteveC
//
/* These types are described in MSDN and appear in Win95's unimdm.h private
** header (complete with typo) but not in any SDK headers.
*/

typedef struct tagDEVCFGGDR
{
    DWORD dwSize;
    DWORD dwVersion;
    WORD  fwOptions;
    WORD  wWaitBong;
}DEVCFGHDR;

typedef struct tagDEVCFG
{
    DEVCFGHDR  dfgHdr;
    COMMCONFIG commconfig;
} DEVCFG;



VOID
ArapSetModemParms(
    IN PVOID        pDevObjPtr,
    IN BOOLEAN      TurnItOff
)
{

    DWORD               dwErr;
    DWORD               dwBlobSize=0;
    RAS_DEVCONFIG      *pRasDevCfg;
    PDEVICE_OBJECT      pDeviceObj;
    MODEMSETTINGS      *pModemSettings;
    DEVCFG              *pDevCfg;



    pDeviceObj = (PDEVICE_OBJECT)pDevObjPtr;

    //
    // if this was not a callback case, we never messed with modem settings:
    // don't do anything here
    //
    if (pDeviceObj->wchCallbackNumber[0] == 0)
    {
        return;
    }

    dwErr = RasGetDevConfig(NULL, pDeviceObj->hPort,"modem",NULL,&dwBlobSize);

    if (dwErr != ERROR_BUFFER_TOO_SMALL)
    {
        // what else can we do here?  callback will faile, that's about it
        DbgPrint("ArapSetModemParms: RasGetDevConfig failed with %ld\n",dwErr);
        return;
    }

    pRasDevCfg = (RAS_DEVCONFIG *)LOCAL_ALLOC(LPTR,dwBlobSize);
    if (pRasDevCfg == NULL)
    {
        // what else can we do here?  callback will faile, that's about it
        DbgPrint("ArapSetModemParms: alloc failed\n");
        return;
    }

    dwErr = RasGetDevConfig(NULL, pDeviceObj->hPort,"modem",(PBYTE)pRasDevCfg,&dwBlobSize);
    if (dwErr != 0)
    {
        // what else can we do here?  callback will faile, that's about it
        DbgPrint("ArapSetModemParms: RasGetDevConfig failed with %ld\n",dwErr);
        LOCAL_FREE((PBYTE)pRasDevCfg);
        return;
    }

    pDevCfg = (DEVCFG *) ((PBYTE) pRasDevCfg + pRasDevCfg->dwOffsetofModemSettings);

    pModemSettings = (MODEMSETTINGS* )(((PBYTE)&pDevCfg->commconfig)
                    + pDevCfg->commconfig.dwProviderOffset);

    //
    // is this routine called to turn the compression and errorcontrol off?
    //
    if (TurnItOff)
    {
        //
        // turn error-control and compression off if it's on
        //
        pModemSettings->dwPreferredModemOptions &=
                ~(MDM_COMPRESSION | MDM_ERROR_CONTROL);
    }

    //
    // no, it's called to turn it back on: just do it
    //
    else
    {
        pModemSettings->dwPreferredModemOptions |=
                (MDM_COMPRESSION | MDM_ERROR_CONTROL);
    }

    RasSetDevConfig(pDeviceObj->hPort,"modem",(PBYTE)pRasDevCfg,dwBlobSize);

    LOCAL_FREE((PBYTE)pRasDevCfg);

}






=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\autodial\rasautou\rasautou.c ===
#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <npapi.h>
#include <winsock.h>
#include <wsnetbs.h>
#include <ras.h>
#include <raserror.h>
#include <rasdlg.h>
#include <tapi.h>
#include <commctrl.h> // added to be "Fusionized"
#include <shfusion.h> // added to be "Fusionized"
#include "process.h"

#include "rasuip.h"

//
// Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized" for
// UI conistency w/Connections Folder
//
HANDLE g_hModule = NULL;

BOOL g_UninitializeRas = FALSE;

//
// All projection types.  Used to
// determine if a connection was
// completed.
//
#define MAX_PROJECTIONS 5
struct RASPROJECTIONINFO {
    DWORD dwTag;
    DWORD dwSize;
} projections[MAX_PROJECTIONS] = {
    RASP_Amb,       sizeof (RASAMB),
    RASP_PppNbf,    sizeof (RASPPPNBF),
    RASP_PppIpx,    sizeof (RASPPPIPX),
    RASP_PppIp,     sizeof (RASPPPIP),
    RASP_PppLcp,    sizeof (RASPPPLCP)
};

//
// Timer thread information.
//
typedef struct _TIMER_INFO {
    HANDLE hEvent;
    DWORD dwTimeout;
} TIMER_INFO, *PTIMER_INFO;

//
// Private rasdlg functions.
//
DWORD
RasAutodialQueryDlgW(
    IN HWND hwnd,
    IN PWCHAR pszAddress,
    IN PWCHAR pszEntry,
    IN DWORD dwTimeout,
    OUT PWCHAR pszEntrySelectedByUser
    );

BOOLEAN
RasAutodialDisableDlgW(
    HWND hwnd
    );



PSYSTEM_PROCESS_INFORMATION
GetSystemProcessInfo()

/*++

DESCRIPTION
    Return a block containing information about all processes
    currently running in the system.

ARGUMENTS
    None.

RETURN VALUE
    A pointer to the system process information or NULL if it could
    not be allocated or retrieved.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PUCHAR pLargeBuffer;
    ULONG ulcbLargeBuffer = 64 * 1024;

    //
    // Get the process list.
    //
    for (;;) {
        pLargeBuffer = VirtualAlloc(
                         NULL,
                         ulcbLargeBuffer, MEM_COMMIT, PAGE_READWRITE);
        if (pLargeBuffer == NULL) {
            printf(
              "GetSystemProcessInfo: VirtualAlloc failed (status=0x%x)\n",
              status);
            return NULL;
        }

        status = NtQuerySystemInformation(
                   SystemProcessInformation,
                   pLargeBuffer,
                   ulcbLargeBuffer,
                   NULL);
        if (status == STATUS_SUCCESS) break;
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            VirtualFree(pLargeBuffer, 0, MEM_RELEASE);
            ulcbLargeBuffer += 8192;
        }
    }

    return (PSYSTEM_PROCESS_INFORMATION)pLargeBuffer;
} // GetSystemProcessInfo



PSYSTEM_PROCESS_INFORMATION
FindProcessByName(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN LPWSTR lpExeName
    )

/*++

DESCRIPTION
    Given a pointer returned by GetSystemProcessInfo(), find
    a process by name.

ARGUMENTS
    pProcessInfo: a pointer returned by GetSystemProcessInfo().

    lpExeName: a pointer to a Unicode string containing the
        process to be found.

RETURN VALUE
    A pointer to the process information for the supplied
    process or NULL if it could not be found.

--*/

{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    ULONG ulTotalOffset = 0;

    //
    // Look in the process list for lpExeName.
    //
    for (;;) {
        if (pProcessInfo->ImageName.Buffer != NULL) {
            if (!_wcsicmp(pProcessInfo->ImageName.Buffer, lpExeName))
                return pProcessInfo;
        }
        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
            break;
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    return NULL;
} // FindProcessByName


VOID
FreeSystemProcessInfo(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo
    )

/*++

DESCRIPTION
    Free a buffer returned by GetSystemProcessInfo().

ARGUMENTS
    pProcessInfo: the pointer returned by GetSystemProcessInfo().

RETURN VALUE
    None.

--*/

{
    VirtualFree((PUCHAR)pProcessInfo, 0, MEM_RELEASE);
} // FreeSystemProcessInfo



DWORD
ActiveConnections()
{
    DWORD dwErr, dwcbConnections = 0, dwcConnections = 0;
    DWORD i, j, dwTmp, dwSize;
    RASCONN rasconn;
    LPRASCONN lpRasCon = &rasconn;
    RASCONNSTATUS rasconnstatus;

    //
    // Determine how much memory we
    // need to allocate.
    //
    lpRasCon->dwSize = sizeof (RASCONN);
    dwErr = RasEnumConnections(lpRasCon, &dwcbConnections, &dwcConnections);
    if (dwErr == ERROR_BUFFER_TOO_SMALL) {
        lpRasCon = LocalAlloc(LPTR, dwcbConnections);
        if (lpRasCon == NULL)
            return 0;
        //
        // Call again to fill the buffer.
        //
        lpRasCon->dwSize = sizeof (RASCONN);
        dwErr = RasEnumConnections(lpRasCon, &dwcbConnections, &dwcConnections);
    }
    if (dwErr)
        goto done;

    dwTmp = dwcConnections;
    for (i = 0; i < dwTmp; i++) {
        rasconnstatus.dwSize = sizeof (RASCONNSTATUS);
        dwErr = RasGetConnectStatus(
                  lpRasCon[i].hrasconn,
                  &rasconnstatus);
        if (dwErr || rasconnstatus.rasconnstate != RASCS_Connected)
            dwcConnections--;
    }

done:
    if (lpRasCon != &rasconn)
        LocalFree(lpRasCon);
    return dwErr ? 0 : dwcConnections;
} // ActiveConnections




void
TapiLineCallback(
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN ULONG_PTR dwInstance,
    IN ULONG_PTR dwParam1,
    IN ULONG_PTR dwParam2,
    IN ULONG_PTR dwParam3
    )
{
} // TapiLineCallback



DWORD
GetCurrentDialingLocation()
{
    DWORD dwErr, dwcDevices, dwLocationID;
    HLINEAPP hlineApp;
    LINETRANSLATECAPS caps;
    LINETRANSLATECAPS *pCaps;

    //
    // Initialize TAPI.
    //
    dwErr = lineInitialize(
              &hlineApp,
              GetModuleHandle(NULL),
              TapiLineCallback,
              NULL,
              &dwcDevices);
    if (dwErr)
        return 0;
    //
    // Get the dialing location from TAPI.
    //
    RtlZeroMemory(&caps, sizeof (LINETRANSLATECAPS));
    caps.dwTotalSize = sizeof (LINETRANSLATECAPS);
    dwErr = lineGetTranslateCaps(hlineApp, 0x10004, &caps);
    if (dwErr)
        return 0;
    pCaps = (LINETRANSLATECAPS *)LocalAlloc(LPTR, caps.dwNeededSize);
    if (pCaps == NULL)
        return 0;
    RtlZeroMemory(pCaps, sizeof (LINETRANSLATECAPS));
    pCaps->dwTotalSize = caps.dwNeededSize;
    dwErr = lineGetTranslateCaps(hlineApp, 0x10004, pCaps);
    if (dwErr) {
        LocalFree(pCaps);
        return 0;
    }
    dwLocationID = pCaps->dwCurrentLocationID;
    LocalFree(pCaps);
    //
    // Shutdown TAPI.
    //
    dwErr = lineShutdown(hlineApp);

    return dwLocationID;
} // GetCurrentDialingLocation



DWORD
TimerThread(
    LPVOID lpArg
    )
{
    NTSTATUS status;
    PTIMER_INFO pTimerInfo = (PTIMER_INFO)lpArg;
    HANDLE hEvent = pTimerInfo->hEvent;
    DWORD dwTimeout = pTimerInfo->dwTimeout;

    LocalFree(pTimerInfo);
    //
    // Wait for the timeout period.  If hEvent
    // gets signaled before the timeout period
    // expires, then the user has addressed the
    // dialog and we return.  Otherwise, we simply
    // exit.
    //
    if (WaitForSingleObject(hEvent, dwTimeout * 1000) == WAIT_TIMEOUT)
        exit(1);

    return 0;
} // TimerThread

DWORD
DisplayRasDialog(
    IN LPTSTR pszPhonebook,
    IN LPTSTR pszEntry,
    IN LPTSTR pszAddress,
    IN BOOLEAN fRedialMode,
    IN BOOLEAN fQuiet
    )
{
    NTSTATUS status;
    DWORD dwErr = 0, dwSize, dwCount = 0;
    DWORD dwcConnections, dwfDisableConnectionQuery;
    DWORD dwPreDialingLocation, dwPostDialingLocation;
    DWORD dwConnectionQueryTimeout;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_PROCESS_INFORMATION pSystemInfo;
    BOOLEAN fCancelled;
    LPRASAUTODIALENTRY pAutodialEntries = NULL;
    DWORD dwcbAutodialEntries = 0, dwcAutodialEntries = 0;
    WCHAR pszNewEntry[RAS_MaxEntryName + 1];

    wcscpy(pszNewEntry, L"\0");

    //
    // Check to see if the user has disabled
    // the Autodial query dialog when the
    // phonebook entry to dial is known.
    //
    if (fRedialMode || fQuiet)
        dwfDisableConnectionQuery = TRUE;
    else {
        dwSize = sizeof (DWORD);
        (void)RasGetAutodialParam(
          RASADP_DisableConnectionQuery,
          &dwfDisableConnectionQuery,
          &dwSize);
    }
    //
    // Ask the user if he wants to dial if either the
    // phonebook entry is not known or the user has
    // not disabled the "always ask me before dialing"
    // parameter.
    //
    // If RasDialDlg() returns FALSE, the user didn't
    // want to dial.
    //
    if (pszEntry == NULL || !dwfDisableConnectionQuery) {
        dwSize = sizeof (DWORD);
        (void)RasGetAutodialParam(
          RASADP_ConnectionQueryTimeout,
          &dwConnectionQueryTimeout,
          &dwSize);
        //
        // Save the current dialing location to
        // see if the user changed it inside the
        // dialog.
        //
        dwPreDialingLocation = GetCurrentDialingLocation();
        dwErr = RasAutodialQueryDlgW(
            NULL, pszAddress, pszEntry, dwConnectionQueryTimeout, pszNewEntry);

        // Whistler: 255816
        //
        // Only disable the address if an error occurs.
        // If the user simply types 'no' then CANCEL is 
        // returned from rasdlg, but we'll return NO_ERROR to the
        // rasauto service so that the address remains enabled.
        //
        if (dwErr == ERROR_CANCELLED)
        {
            return NO_ERROR;
        }
        else if (dwErr != NO_ERROR)
        {
            return ERROR_CANCELLED;
        }
        
        dwPostDialingLocation = GetCurrentDialingLocation();
        //
        // If the user changed the dialing location
        // within the dialog, then get the new entry.
        //
        if (dwPreDialingLocation != dwPostDialingLocation) {
            pszEntry = NULL;
            dwErr = RasGetAutodialAddress(
                      pszAddress,
                      NULL,
                      NULL,
                      &dwcbAutodialEntries,
                      &dwcAutodialEntries);
            if (dwErr == ERROR_BUFFER_TOO_SMALL && dwcAutodialEntries)
                pAutodialEntries = LocalAlloc(LPTR, dwcbAutodialEntries);
            if (dwcAutodialEntries && pAutodialEntries != NULL) {
                pAutodialEntries[0].dwSize = sizeof (RASAUTODIALENTRY);
                dwErr = RasGetAutodialAddress(
                          pszAddress,
                          NULL,
                          pAutodialEntries,
                          &dwcbAutodialEntries,
                          &dwcAutodialEntries);
                if (!dwErr) {
                    DWORD i;

                    for (i = 0; i < dwcAutodialEntries; i++) {
                        if (pAutodialEntries[i].dwDialingLocation ==
                              dwPostDialingLocation)
                        {
                            pszEntry = pAutodialEntries[i].szEntry;
                            break;
                        }
                    }
                }
            }
        }

        // Whistler: new autodial UI
        //
        // The connection that the user wants to dial will be in  
        // pszNewEntry.
        //
        else
        {
            if (*pszNewEntry)
            {
                pszEntry = pszNewEntry;
            }            
        }

    }

    if (pszEntry)
    {
        RASDIALDLG info;

        ZeroMemory( &info, sizeof(info) );
        info.dwSize = sizeof(info);

        //
        // Prevent the DialerDialog to come up only if the
        // user has checked the don't query before dialing
        // checkbox. Otherwise we bringup the dialog.
        //
        if(dwfDisableConnectionQuery)
        {
            info.dwFlags |= RASDDFLAG_NoPrompt;
        }

        if (fRedialMode)
        {
            /* Set this flag to tell RasDialDlg to popup the "reconnect
            ** pending" countdown dialog before redialing.
            */
            info.dwFlags |= RASDDFLAG_LinkFailure;
        }

        /* Popup the "Dial-Up Networking" dialing dialogs.
        */
        fCancelled = !RasDialDlg( pszPhonebook, pszEntry, NULL, &info );
        
        g_UninitializeRas = TRUE;

    }
    else if (!fQuiet)
    {
        RASPBDLG info;

        ZeroMemory( &info, sizeof(info) );
        info.dwSize = sizeof(info);
        info.dwFlags = RASPBDFLAG_ForceCloseOnDial;

        /* Popup the main "Dial-Up Networking" dialog.
        */
        fCancelled = !RasPhonebookDlg( pszPhonebook, NULL, &info );

        g_UninitializeRas = TRUE;

    }

    if (!fRedialMode && !fQuiet && fCancelled)
    {
        /* User did not make a connection.  Ask him if he wants to nix
        ** auto-dial for this location.
        */
        // if (RasAutodialDisableDlgW( NULL ))
        //    RasSetAutodialEnable( GetCurrentDialingLocation(), FALSE );
    }

    if (pAutodialEntries != NULL)
        LocalFree(pAutodialEntries);

    return 0;
} // DisplayRasDialog

DWORD
GetExpandedDllPath(LPTSTR pszDllPath,
                   LPTSTR *ppszExpandedDllPath)
{
    DWORD   dwErr = 0;
    DWORD   dwSize = 0;

    //
    // find the size of the expanded string
    //
    if (0 == (dwSize = 
              ExpandEnvironmentStrings(pszDllPath,
                                       NULL,
                                       0)))
    {
        dwErr = GetLastError();
        goto done;
    }

    *ppszExpandedDllPath = LocalAlloc(
                                LPTR,
                                dwSize * sizeof (TCHAR));
                                
    if (NULL == *ppszExpandedDllPath)
    {
        dwErr = GetLastError();
        goto done;
    }

    //
    // Get the expanded string
    //
    if (0 == ExpandEnvironmentStrings(
                                pszDllPath, 
                                *ppszExpandedDllPath,
                                dwSize))
    {
        dwErr = GetLastError();
    }

done:
    return dwErr;
    
}


LPWSTR
ConvertToUnicodeString(
    LPSTR psz
    )

    // Modified to use code from nouiutil
{
    WCHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, NULL, 0 );
        ASSERT(cb);

        pszNew = LocalAlloc( LPTR, (cb + 1) * sizeof(TCHAR) );
        if (!pszNew)
        {
            printf("rasautou: LocalAlloc failed\n");
            return NULL;
        }

        cb = MultiByteToWideChar( CP_ACP, 0, psz, -1, pszNew, cb );
        if (cb == 0)
        {
            LocalFree( pszNew );
            printf("rasautou: multibyte string conversion failed\n");
            return NULL;
        }
    }

    return pszNew;
} // ConvertToUnicodeString

LPSTR
ConvertToAnsiString(
    PWCHAR psz
    )

    // Modified to use code from nouiutil
{
    CHAR* pszNew = NULL;

    if (psz)
    {
        DWORD cb;

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL );
        ASSERT(cb);

        pszNew = (CHAR* )LocalAlloc( LPTR, cb + 1 );
        if (!pszNew)
        {
            printf("rasautou: LocalAlloc failed");
            return NULL;
        }

        cb = WideCharToMultiByte( CP_ACP, 0, psz, -1, pszNew, cb, NULL, NULL );
        if (cb == 0)
        {
            LocalFree( pszNew );
            printf("rasautou: wide-character string conversion failed");
            return NULL;
        }
    }

    return pszNew;
} // ConvertToUnicodeString

DWORD
DisplayCustomDialog(
    IN LPTSTR pszDll,
    IN LPTSTR pszFunc,
    IN LPTSTR pszPhonebook,
    IN LPTSTR pszEntry,
    IN LPTSTR pszAddress
    )
{
    DWORD dwErr, dwRetCode;
    HINSTANCE hLibrary;
    CHAR szFuncNew[64], szFuncOld[64], *pszOldFunc = NULL;
    ORASADFUNC pfnOldStyleFunc;
    RASADFUNC pfnFunc;
    RASADPARAMS params;
    LPTSTR pszExpandedPath = NULL;
    CHAR * pszEntryA = NULL;

    dwErr = GetExpandedDllPath(pszDll,
                               &pszExpandedPath);

    if(ERROR_SUCCESS != dwErr)                               
    {
        return dwErr;
    }

    //
    // Load the library.
    //
    hLibrary = LoadLibrary(pszExpandedPath);
    if (hLibrary == NULL) {
        dwErr = GetLastError();
        printf(
          "rasdlui: %S: AutoDial DLL cannot be loaded (dwErr=%d)\n",
          pszDll,
          dwErr);

        LocalFree(pszExpandedPath);
        return dwErr;
    }
    //
    // Get the procedure address.  First,
    // we check for a new-style entry point,
    // and then check for an old-style entry
    // point if the new-style one doesn't exist.
    //
#ifdef UNICODE
    sprintf(szFuncNew, "%SW", pszFunc);
    pszOldFunc = ConvertToAnsiString(pszFunc);
    pszEntryA = ConvertToAnsiString(pszEntry);

    if (!pszOldFunc || !pszEntryA)
    {
        printf("rasautou: Allocation failed.  Exiting\n");
        exit(1);
    }
#else
    sprintf(szFuncNew, "%sA", pszFunc);
    strcpy(szFuncOld, pszFunc);
    pszOldFunc = szFuncOld;
    pszEntryA = pszEntry;
#endif

    pfnFunc = (RASADFUNC)GetProcAddress(hLibrary, szFuncNew);
    if (pfnFunc != NULL) 
    {
        //
        // Initialize the param block.
        //
        params.hwndOwner = NULL;
        params.dwFlags = 0;
        params.xDlg = params.yDlg = 0;
        //params.dwCallbackId = 0;
        //params.pCallback = NULL;
        //
        // Call the procedure.
        //
        (*pfnFunc)(pszPhonebook, pszEntry, &params, &dwRetCode);
    }
    else
    {
        pfnOldStyleFunc = (ORASADFUNC)GetProcAddress(hLibrary, pszOldFunc);
        if (pfnOldStyleFunc != NULL)
        {
            (*pfnOldStyleFunc)(NULL, pszEntryA, 0, &dwRetCode);
        }           
        else
        {
#ifdef UNICODE    
            printf(
              "rasautou: %S: Function cannot be loaded from AutoDial DLL %S\n",
              pszDll,
              pszFunc);
#else          
            printf(
              "rasautou: %s: Function cannot be loaded from AutoDial DLL %s\n",
              pszDll,
              pszFunc);
#endif          
            exit(1);
        }
    }        
    //
    // Clean up.
    //
    FreeLibrary(hLibrary);

#ifdef UNICODE
    if (pszOldFunc)
    {
        LocalFree(pszOldFunc);
    }
    
    if (pszEntryA)
    {
        LocalFree(pszOldFunc);
    }
#endif    
    
    LocalFree(pszExpandedPath);
    return dwRetCode;
} // DisplayCustomDialog



VOID
FreeConvertedString(
    IN LPWSTR pwsz
    )
{
    if (pwsz != NULL)
        LocalFree(pwsz);
} // FreeConvertedString



BOOLEAN
RegGetValueA(
    IN HKEY hkey,
    IN LPSTR pszKey,
    OUT PVOID *ppvData,
    OUT LPDWORD pdwcbData
    )
{
    DWORD dwError, dwType, dwSize;
    PVOID pvData;

    //
    // Get the length of the string.
    //
    dwError = RegQueryValueExA(
                hkey,
                pszKey,
                NULL,
                &dwType,
                NULL,
                &dwSize);
    if (dwError != ERROR_SUCCESS)
        return FALSE;
    pvData = LocalAlloc(LPTR, dwSize);
    if (pvData == NULL) {
        DbgPrint("RegGetValueA: LocalAlloc failed\n");
        return FALSE;
    }
    //
    // Read the value for real this time.
    //
    dwError = RegQueryValueExA(
                hkey,
                pszKey,
                NULL,
                NULL,
                (LPBYTE)pvData,
                &dwSize);
    if (dwError != ERROR_SUCCESS) {
        LocalFree(pvData);
        return FALSE;
    }

    *ppvData = pvData;
    if (pdwcbData != NULL)
        *pdwcbData = dwSize;
    return TRUE;
} // RegGetValueA



VOID
NetworkConnected()

/*++

DESCRIPTION
    Determine whether there exists some network connection.

    Note: This code was stolen from sockit.c courtesy of ArnoldM.

ARGUMENTS
    None

RETURN VALUE
    TRUE if one exists, FALSE otherwise.

--*/

{
    typedef struct _LANA_MAP {
        BOOLEAN fEnum;
        UCHAR bLana;
    } LANA_MAP, *PLANA_MAP;
    BOOLEAN fNetworkPresent = FALSE;
    HKEY hKey;
    PLANA_MAP pLanaMap = NULL, pLana;
    DWORD dwError, dwcbLanaMap;
    PCHAR pMultiSzLanasA = NULL, paszTemp;
    DWORD dwcBindings, dwcMaxLanas, i, dwcbLanas;
    LONG iLana;
    DWORD dwZero = 0;
    PCHAR *paszLanas = NULL;
    SOCKET s;
    SOCKADDR_NB nbaddress, nbsendto;
    NTSTATUS status;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES attributes;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    PWCHAR pwsz;

    dwError = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services\\Netbios\\Linkage",
                0,
                KEY_READ,
                &hKey);
    if (dwError != ERROR_SUCCESS) {
        printf(
          "NetworkConnected: RegKeyOpenEx failed (dwError=%d)\n",
          GetLastError());
        return;
    }
    //
    // Read in the LanaMap.
    //
    if (!RegGetValueA(hKey, "LanaMap", &pLanaMap, &dwcbLanaMap)) {
        printf("NetworkConnected: RegGetValueA(LanaMap) failed\n");
        goto done;
    }
    dwcBindings = dwcbLanaMap / sizeof (LANA_MAP);
    //
    // Read in the bindings.
    //
    if (!RegGetValueA(hKey, "bind", &pMultiSzLanasA, &dwcbLanas)) {
        printf("NetworkConnected: RegGetValueA(bind) failed\n");
        goto done;
    }
    //
    // Allocate a buffer for the binding array.
    //
    paszLanas = LocalAlloc(LPTR, (dwcBindings+1) * sizeof (PCHAR));
    if (paszLanas == NULL) {
        printf("NetworkConnected: LocalAlloc failed\n");
        goto done;
    }
    //
    // Parse the bindings into an array of strings.
    //
    for (dwcMaxLanas = 0, paszTemp = pMultiSzLanasA; *paszTemp; paszTemp++) {
        paszLanas[dwcMaxLanas++] = paszTemp;
        while(*++paszTemp);
    }
    //
    // Finally enumerate the bindings and
    // attempt to create a socket on each.
    //
    nbaddress.snb_family = AF_NETBIOS;
    nbaddress.snb_type = 0;
    memcpy(nbaddress.snb_name, "yahooyahoo      ", 16);
    nbsendto.snb_family = AF_NETBIOS;
    nbsendto.snb_type = 0;
    memcpy(nbsendto.snb_name, "billybob        ", 16);

    for (iLana = 0, pLana = pLanaMap; dwcBindings--; iLana++, pLana++) {
        int iLanaMap = (int)pLana->bLana;

        if (pLana->fEnum && (DWORD)iLana < dwcMaxLanas) {
            int iError;

            if (!_stricmp(paszLanas[iLana], "\\Device\\NwlnkNb") ||
                strstr(paszLanas[iLana], "_NdisWan") != NULL)
            {
                printf("NetworkConnected: ignoring %s\n", paszLanas[iLana]);
                continue;
            }

#ifdef notdef
            s = socket(AF_NETBIOS, SOCK_DGRAM, -iLanaMap);
            if (s == INVALID_SOCKET) {
                printf(
                  "NetworkConnected: socket(%s, %d) failed (error=%d)\n",
                  paszLanas[iLana],
                  iLana,
                  WSAGetLastError());
                continue;
            }
//printf("s=0x%x, iLana=%d, %s\n", s, iLana, paszLanas[iLana]);
            iError = ioctlsocket(s, FIONBIO, &dwZero);
            if (iError == SOCKET_ERROR) {
                printf(
                  "NetworkConnected: ioctlsocket(%s) failed (error=%d)\n",
                  paszLanas[iLana],
                  iLana,
                  WSAGetLastError());
                goto cleanup;
            }
            iError = bind(
                       s,
                       (struct sockaddr *)&nbaddress,
                       sizeof(nbaddress));
            if (iError == SOCKET_ERROR) {
                printf(
                  "NetworkConnected: bind(%s, %d) failed (error=%d)\n",
                  paszLanas[iLana],
                  iLana,
                  WSAGetLastError());
                goto cleanup;
            }
            iError = sendto(
                       s,
                       (PCHAR)&nbsendto,
                       sizeof (nbsendto),
                       0,
                       (struct sockaddr *)&nbsendto,
                       sizeof (nbsendto));
            if (iError == SOCKET_ERROR) {
                printf(
                  "NetworkConnected: sendto(%s, %d) failed (error=%d)\n",
                  paszLanas[iLana],
                  iLana,
                  WSAGetLastError());
            }
cleanup:
            closesocket(s);
            if (iError != SOCKET_ERROR) {
                printf("NetworkConnected: network (%s, %d) is up\n",
                  paszLanas[iLana],
                  iLana);
                fNetworkPresent = TRUE;
                break;
            }
#else
            pwsz = ConvertToUnicodeString(paszLanas[iLana]);
            RtlInitUnicodeString(&deviceName, pwsz);
            InitializeObjectAttributes(
              &attributes,
              &deviceName,
              OBJ_CASE_INSENSITIVE,
              NULL,
              NULL);
            status = NtOpenFile(&handle, READ_CONTROL, &attributes, &iosb, 0, 0);
            NtClose(handle);

            LocalFree(pwsz);

            if (NT_SUCCESS(status)) {
                printf(
                  "NetworkConnected: network (%s, %d) is up\n",
                  paszLanas[iLana],
                  iLana);
                fNetworkPresent = TRUE;
                break;
            }
            else {
                printf(
                  "NetworkConnected: NtOpenFile on %s failed (status=0x%x)\n",
                  paszLanas[iLana],
                  status);
            }
#endif
        }
    }
    //
    // Free resources.
    //
done:
    if (paszLanas != NULL)
        LocalFree(paszLanas);
    if (pMultiSzLanasA != NULL)
        LocalFree(pMultiSzLanasA);
    if (pLanaMap != NULL)
        LocalFree(pLanaMap);
    RegCloseKey(hKey);
} // NetworkConnected



VOID
DumpAutoDialAddresses()
{
    DWORD dwErr, i, dwcb, dwcAddresses;
    LPTSTR *lppAddresses = NULL;

    dwErr = RasEnumAutodialAddresses(NULL, &dwcb, &dwcAddresses);
    if (dwErr && dwErr != ERROR_BUFFER_TOO_SMALL) {
        printf("RasEnumAutodialAddresses failed (dwErr=%d)\n", dwErr);
        return;
    }
    if (dwcAddresses) {
        lppAddresses = (LPTSTR *)LocalAlloc(LPTR, dwcb);
        if (lppAddresses == NULL) {
            printf("LocalAlloc failed\n");
            return;
        }
        dwErr = RasEnumAutodialAddresses(lppAddresses, &dwcb, &dwcAddresses);
        if (dwErr) {
            printf("RasEnumAutodialAddresses failed (dwErr=%d)\n", dwErr);
            LocalFree(lppAddresses);
            return;
        }
    }
    printf("There are %d Autodial addresses:\n", dwcAddresses);
    for (i = 0; i < dwcAddresses; i++)
#ifdef UNICODE
    printf("%S\n", lppAddresses[i]);
#else
    printf("%s\n", lppAddresses[i]);
#endif
    if (lppAddresses != NULL)
        LocalFree(lppAddresses);
} // DumpAutoDialAddresses



VOID
DumpStatus()
{
    DWORD dwErr;
    WSADATA wsaData;

    //
    // Initialize winsock.
    //
    dwErr = WSAStartup(MAKEWORD(2,0), &wsaData);
    if (dwErr) {
        DbgPrint("AcsInitialize: WSAStartup failed (dwErr=%d)\n", dwErr);
        return;
    }
    //
    // Display network connectivity.
    //
    printf("Checking netcard bindings...\n");
    NetworkConnected();
    //
    // Display AutoDial address table.
    //
    printf("\nEnumerating AutoDial addresses...\n");
    DumpAutoDialAddresses();
} // DumpStatus

// Returns true if a redial-on-link-failure process is 
// active.
//
BOOL
OtherRasautouExists(
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo)
{
    PUCHAR pLargeBuffer = (PUCHAR)pProcessInfo;
    ULONG ulTotalOffset = 0;
    DWORD dwProcId, dwSessId = 0;
    BOOL fValidSessId = FALSE;

    dwProcId = GetCurrentProcessId();
    fValidSessId = ProcessIdToSessionId(dwProcId, &dwSessId);

    //printf(
    //    "ProcId=%d, SessId=%d, ValSess=%d\n", dwProcId, dwSessId, fValidSessId);

    //
    // Look in the process list for lpExeName.
    //
    for (;;) 
    {
        if (pProcessInfo->ImageName.Buffer != NULL) 
        {
            // If
            // 1. The process is in our session
            // 2. It is not us
            // 3. It is rasautou
            // 
            // Then another rasautou is already active -- we should 
            // return success so that no ui is raised.
            //

            //printf(
            //    "id=%-2d, sess=%-4d, %S\n", 
            //    PtrToUlong(pProcessInfo->UniqueProcessId),
            //    pProcessInfo->SessionId,
            //    pProcessInfo->ImageName.Buffer);
            
            if (
                ((dwSessId == pProcessInfo->SessionId) || (!fValidSessId)) &&
                (PtrToUlong(pProcessInfo->UniqueProcessId) != dwProcId)    &&
                (_wcsicmp(pProcessInfo->ImageName.Buffer, L"rasautou.exe") == 0)
                )
            {
                // 
                // We could actually check that 
                // 4.  That rasautou function is started with the -r flag 
                // 
                // However, it doesn't hurt to return if this is any rasautou 
                // prompt.
                //
                return TRUE;
            }                
        }
        //
        // Increment offset to next process information block.
        //
        if (!pProcessInfo->NextEntryOffset)
        {
            break;
        }
        
        ulTotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pLargeBuffer[ulTotalOffset];
    }

    return FALSE;
} // FindProcessByName


// 
// Determines whether any redial on link failure prompts are
// currently active.
//
BOOL 
OtherRasautouActive()
{
    BOOL bRet = FALSE;
    PSYSTEM_PROCESS_INFORMATION pSysInfo = NULL;
    
    do
    {
        // Discover the processes on the system
        //
        pSysInfo = GetSystemProcessInfo();
        if (pSysInfo == NULL)
        {
            break;
        }

        // Find out if any rasautou processes are active
        //
        bRet = OtherRasautouExists(pSysInfo);
    
    } while (FALSE);


    // Cleanup
    //
    {
        if (pSysInfo)
        {
            FreeSystemProcessInfo(pSysInfo);
        }
    }

    //printf("OtherRasautouActive() returned %s", (bRet) ? "true" : "false");

    return bRet;
}  


VOID _cdecl
wmain(
    INT argc,
    WCHAR **argv
    )
{
    DWORD dwErr = 0;
    BOOLEAN fStatusFlag = FALSE, fRedialFlag = FALSE, fQuiet = FALSE;
    PWCHAR pszPhonebookArg, pszEntryArg, pszDllArg, pszFuncArg, pszAddressArg;
    LPTSTR pszPhonebook, pszEntry, pszDll, pszFunc, pszAddress;

    //
    // Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized"
    // for UI conistency w/Connections Folder
    //
    if (g_hModule = GetModuleHandle( NULL )) {
        SHFusionInitializeFromModule( g_hModule );
    }
    
    if (argc < 2) {
usage:
        printf(
          "Usage: rasautou [-f phonebook] [-d dll -p proc] [-a address] [-e entry] [-s]\n");
        exit(1);
    }
    //
    // Initialize the command line argument pointers.
    //
    pszPhonebookArg = NULL;
    pszEntryArg = NULL;
    pszDllArg = NULL;
    pszFuncArg = NULL;
    pszAddressArg = NULL;

    //
    // Crack command line parameters.
    //
    while (--argc && argv++) {
        if (**argv != L'-')
            break;
        switch ((*argv)[1]) {
        case L'a':
            argc--;
            if (!argc)
                goto usage;
            pszAddressArg = *(++argv);
            break;
        case L'd':
            argc--;
            if (!argc)
                goto usage;
            pszDllArg = *(++argv);
            break;
        case L'e':
            argc--;
            if (!argc)
                goto usage;
            pszEntryArg = *(++argv);
            break;
        case L'f':
            argc--;
            if (!argc)
                goto usage;
            pszPhonebookArg = *(++argv);
            break;
        case L'p':
            argc--;
            if (!argc)
                goto usage;
            pszFuncArg = *(++argv);
            break;
        case L'q':
            fQuiet = TRUE;
            break;
        case L'r':
            fRedialFlag = TRUE;
            break;
        case L's':
            fStatusFlag = TRUE;
            break;
        default:
            goto usage;
        }
    }
    //
    // If either the DLL name or the function
    // name is missing, then display usage.
    //
    if ((pszDllArg == NULL) != (pszFuncArg == NULL) && !fStatusFlag)
        goto usage;
    //
    // We can't dial an entry unless we
    // know which one!
    //
    if (pszDllArg != NULL && pszFuncArg != NULL && pszEntryArg == NULL &&
        !fStatusFlag)
    {
        goto usage;
    }
    if (fStatusFlag)
        DumpStatus();
    else {
        //
        // Convert to Unicode, if necessary.
        //
#ifdef UNICODE
        pszPhonebook = pszPhonebookArg;
        pszEntry = pszEntryArg;
        pszDll = pszDllArg;
        pszFunc = pszFuncArg;
        pszAddress = pszAddressArg;
#else
        pszPhonebook = ConvertToAnsiString(pszPhonebookArg);
        pszEntry = ConvertToAnsiString(pszEntryArg);
        pszDll = ConvertToAnsiString(pszDllArg);
        pszFunc = ConvertToAnsiString(pszFuncArg);
        pszAddress = ConvertToAnsiString(pszAddressArg);
#endif

        // XP 394237
        //
        // Supress the autodial prompt if a redial-on-link-failure
        // prompt is already active
        //
        if ((fRedialFlag) || (fQuiet) || (!OtherRasautouActive()))
        {
            //
            // Call the appropriate DLL entrypoint.
            //
            if ((pszDll == NULL && pszFunc == NULL) || fRedialFlag)
            {
                dwErr = DisplayRasDialog(
                          pszPhonebook,
                          pszEntry,
                          pszAddress,
                          fRedialFlag,
                          fQuiet);
            }                          
            else 
            {
                dwErr = DisplayCustomDialog(
                          pszDll,
                          pszFunc,
                          pszPhonebook,
                          pszEntry,
                          pszAddress);
            }
        }
#ifndef UNICODE
        FreeConvertedString(pszPhonebook);
        FreeConvertedString(pszEntry);
        FreeConvertedString(pszDll);
        FreeConvertedString(pszFunc);
        FreeConvertedString(pszAddress);
#endif
    }
    //
    // Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized"
    // for UI conistency w/Connections Folder
    //
    if (g_hModule)
    {
        SHFusionUninitialize();
    }

    if(g_UninitializeRas)
    {
        DwRasUninitialize();
    }
    
    //
    // Return status.
    //
    exit(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\ddmif.c ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	ddmif.c
//
// Description: message based communication code
//
// Author:	Stefan Solomon (stefans)    June 24, 1992.
//
// Revision History:
//
//***
#include "ddm.h"
#include <ddmif.h>
#include <string.h>
#include <raserror.h>
#include <rasppp.h>

//
// Message element definition
//

typedef struct _MESSAGE_Q_OBJECT
{
    struct _MESSAGE_Q_OBJECT *  pNext;

    MESSAGE	                    MsgBuffer;

} MESSAGE_Q_OBJECT, *PMESSAGE_Q_OBJECT;

//
// Message queue header definition
//

typedef struct _MESSAGE_Q
{
    MESSAGE_Q_OBJECT *  pQHead;

    MESSAGE_Q_OBJECT *  pQTail;

    HANDLE              hEvent;     // Signaled when enqueueing a new message

    DWORD               dwLength;   // size of message data for each node in Q

    CRITICAL_SECTION    CriticalSection;     // Mutex around this Q

} MESSAGE_Q, *PMESSAGE_Q;

BOOL gfMessageQueueInitialized = FALSE;

//
// Message queue table
//

static MESSAGE_Q MessageQ[MAX_MSG_QUEUES];


VOID
SendPppMessageToDDM(
    IN PPP_MESSAGE *  pPppMsg
)
{
    ServerSendMessage( MESSAGEQ_ID_PPP, (PBYTE)pPppMsg );
}

VOID
RasSecurityDialogComplete(
    IN SECURITY_MESSAGE *pSecurityMessage
)
{
    ServerSendMessage( MESSAGEQ_ID_SECURITY, (PBYTE)pSecurityMessage );
}

//*** Message Debug Printing Tables ***

typedef struct _MSGDBG
{
    WORD  id;
    LPSTR txtp;

} MSGDBG, *PMSGDBG;

enum
{
    MSG_SEND,
    MSG_RECEIVE
};

MSGDBG  dstsrc[] =
{
    { MESSAGEQ_ID_SECURITY,     "Security" },
    { MESSAGEQ_ID_PPP,          "PPP" },
    { 0xffff,                   NULL }
};


MSGDBG  authmsgid[] =
{
    { AUTH_DONE,                "AUTH_DONE" },
    { AUTH_FAILURE,             "AUTH_FAILURE" },
    { AUTH_STOP_COMPLETED,      "AUTH_STOP_COMPLETED" },
    { AUTH_PROJECTION_REQUEST,  "AUTH_PROJECTION_REQUEST" },
    { AUTH_CALLBACK_REQUEST,    "AUTH_CALLBACK_REQUEST" },
    { AUTH_ACCT_OK,             "AUTH_ACCT_OK" },
    { 0xffff,                   NULL }
};


MSGDBG  pppmsgid[] =
{
    { PPPMSG_Stopped,               "PPPMSG_Stopped" },
    { PPPDDMMSG_PppDone,            "PPPDDMMSG_PppDone" },
    { PPPDDMMSG_PppFailure,         "PPPDDMMSG_PppFailure" },
    { PPPDDMMSG_CallbackRequest,    "PPPDDMMSG_CallbackRequest" },
    { PPPDDMMSG_Authenticated,      "PPPDDMMSG_Authenticated" },
    { PPPDDMMSG_Stopped,            "PPPDDMMSG_Stopped" },
    { PPPDDMMSG_NewLink,            "PPPDDMMSG_NewLink" },
    { PPPDDMMSG_NewBundle,          "PPPDDMMSG_NewBundle" },
    { PPPDDMMSG_NewBapLinkUp,       "PPPDDMMSG_NewBapLinkUp" },
    { PPPDDMMSG_BapCallbackRequest, "PPPDDMMSG_BapCallbackRequest" },
    { PPPDDMMSG_PnPNotification,    "PPPDDMMSG_PnPNotification" },
    { PPPDDMMSG_PortCleanedUp,      "PPPDDMMSG_PortCleanedUp" },
    { 0xffff,                        NULL }
};

MSGDBG  opcodestr[] =
{
    { MSG_SEND,          "ServerSendMessage" },
    { MSG_RECEIVE,       "ServerReceiveMessage" },
    { 0xffff,            NULL }
};

MSGDBG  securitymsgid[] =
{
    { SECURITYMSG_SUCCESS,  "SECURITYMSG_SUCCESS" },
    { SECURITYMSG_FAILURE,  "SECURITYMSG_FAILURE" },
    { SECURITYMSG_ERROR,    "SECURITYMSG_ERROR" },
    { 0xffff,               NULL }
};

char *
getstring(
    IN WORD id,
    IN PMSGDBG msgdbgp
)
{
    char *strp;
    PMSGDBG mdp;

    for (mdp = msgdbgp; mdp->id != 0xffff; mdp++)
    {
        if (mdp->id == id)
        {
            strp = mdp->txtp;
            return(strp);
        }
    }

    RTASSERT(FALSE);
    return(NULL);
}

//***
//
// Function:    msgdbgprint
//
// Descr:   prints each message passing through the message module
//
//***

VOID
msgdbgprint(
    IN WORD opcode,
    IN WORD src,
    IN BYTE *buffp
)
{
    char  *srcsp, *msgidsp, *operation;
    HPORT hport = 0;

    //
    // identify message source. This gives us the clue on the message
    // structure.
    //

    switch (src)
    {
    case MESSAGEQ_ID_SECURITY:
        msgidsp = getstring((WORD)((SECURITY_MESSAGE *) buffp)->dwMsgId,
                                 securitymsgid);
        hport = ((SECURITY_MESSAGE *) buffp)->hPort;
        break;

    case MESSAGEQ_ID_PPP:
        msgidsp = getstring((WORD)((PPP_MESSAGE *) buffp)->dwMsgId, pppmsgid );
        hport = ((PPP_MESSAGE *) buffp)->hPort;
        break;

    default:

        RTASSERT(FALSE);
    }

    srcsp = getstring(src, dstsrc);
    operation = getstring(opcode, opcodestr);

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_MESSAGES,
               "%s on port/connection: %x from: %s Message: %s",
               operation, hport, srcsp, msgidsp);

}

//***
//
//  Function:   InitializeMessageQs
//
//  Returns:    None
//
//  Description:Initializes the message queue headers
//
//***
VOID
InitializeMessageQs(
    IN HANDLE hEventSecurity,
    IN HANDLE hEventPPP
)
{
    DWORD dwIndex;

    MessageQ[MESSAGEQ_ID_SECURITY].hEvent   = hEventSecurity;
    MessageQ[MESSAGEQ_ID_PPP].hEvent        = hEventPPP;


    MessageQ[MESSAGEQ_ID_SECURITY].dwLength = sizeof(SECURITY_MESSAGE);
    MessageQ[MESSAGEQ_ID_PPP].dwLength      = sizeof(PPP_MESSAGE);

    for ( dwIndex = 0; dwIndex < MAX_MSG_QUEUES; dwIndex++ )
    {
        MessageQ[dwIndex].pQHead = NULL;
        MessageQ[dwIndex].pQTail = NULL;

        InitializeCriticalSection( &(MessageQ[dwIndex].CriticalSection) );
    }

    gfMessageQueueInitialized = TRUE;
}

//***
//
//  Function:   DeleteMessageQs
//
//  Returns:    None
//
//  Description:DeInitializes the message queue headers
//
//***
VOID
DeleteMessageQs(
    VOID
)
{
    DWORD       dwIndex;
    IN BYTE *   pMessage;

    if(!gfMessageQueueInitialized)
    {
        return;
    }

    //
    // Flush the queues
    //

    for ( dwIndex = 0; dwIndex < MAX_MSG_QUEUES; dwIndex++ )
    {
        DeleteCriticalSection( &(MessageQ[dwIndex].CriticalSection) );
    }

    gfMessageQueueInitialized = FALSE;
}

//***
//
//  Function:	ServerSendMessage
//
//  Descr:	    Sends message from specified server component
//		        source to server component dst.
//
//  Returns:	NO_ERROR  - success
//		        else      - failure
//
//***
DWORD
ServerSendMessage(
    IN MESSAGEQ_ID  MsgQId,
    IN BYTE *       pMessage
)
{
    MESSAGE_Q_OBJECT * pMsgQObj;

    //
    // Make sure DDM is running before accessing any data structure
    //

    if ( gblDDMConfigInfo.pServiceStatus == NULL )
    {
        return( ERROR_DDM_NOT_RUNNING );
    }

    switch( gblDDMConfigInfo.pServiceStatus->dwCurrentState )
    {
    case SERVICE_STOP_PENDING:

        //
        // Allow only PPP stopping messages
        //

        if ( MsgQId == MESSAGEQ_ID_PPP )
        {
            if ((((PPP_MESSAGE *)pMessage)->dwMsgId == PPPDDMMSG_Stopped )  ||
                (((PPP_MESSAGE *)pMessage)->dwMsgId == PPPDDMMSG_PppFailure)||
                (((PPP_MESSAGE *)pMessage)->dwMsgId == PPPDDMMSG_PortCleanedUp))
            {
                break;
            }
        }

        //
        // Otherwise fall thru
        //

    case SERVICE_START_PENDING:
    case SERVICE_STOPPED:

        return( ERROR_DDM_NOT_RUNNING );

    default:
        break;
    }

    EnterCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

    //
    // allocate a message structure
    //

    pMsgQObj = (MESSAGE_Q_OBJECT *)LOCAL_ALLOC( LPTR, sizeof(MESSAGE_Q_OBJECT));

    if ( pMsgQObj == (MESSAGE_Q_OBJECT *)NULL )
    {
        //
	    // can't allocate message buffer
        //

	    RTASSERT(FALSE);

        LeaveCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

	    return( GetLastError() );
    }

    //
    // copy the message
    //

    CopyMemory( &(pMsgQObj->MsgBuffer), pMessage, MessageQ[MsgQId].dwLength );

    //
    // Insert it in the Q
    //

    if ( MessageQ[MsgQId].pQHead == (MESSAGE_Q_OBJECT *)NULL )
    {
        MessageQ[MsgQId].pQHead = pMsgQObj;
    }
    else
    {
        MessageQ[MsgQId].pQTail->pNext = pMsgQObj;
    }

    MessageQ[MsgQId].pQTail = pMsgQObj;
    pMsgQObj->pNext         = NULL;

    //
    // and set appropriate event
    //

    SetEvent( MessageQ[MsgQId].hEvent );

    msgdbgprint( MSG_SEND, (WORD)MsgQId, pMessage );

    LeaveCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

    return( NO_ERROR );
}

//***
//
//  Function:	ServerReceiveMessage
//
//  Descr:	    Gets one message from the specified message queue
//
//  Returns:    TRUE  - message fetched
//		        FALSE - queue empty
//
//***
BOOL
ServerReceiveMessage(
    IN MESSAGEQ_ID  MsgQId,
    IN BYTE *       pMessage
)
{
    MESSAGE_Q_OBJECT * pMsgQObj;
    HLOCAL      err;

    EnterCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

    if ( MessageQ[MsgQId].pQHead == (MESSAGE_Q_OBJECT *)NULL )
    {
        //
	    // queue is empty
        //

        LeaveCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

	    return( FALSE );
    }

    pMsgQObj = MessageQ[MsgQId].pQHead;

    MessageQ[MsgQId].pQHead = pMsgQObj->pNext;

    if ( MessageQ[MsgQId].pQHead == (MESSAGE_Q_OBJECT *)NULL )
    {
        MessageQ[MsgQId].pQTail = (MESSAGE_Q_OBJECT *)NULL;
    }

    //
    // copy the message in the caller's buffer
    //

    CopyMemory( pMessage, &(pMsgQObj->MsgBuffer), MessageQ[MsgQId].dwLength );

    //
    // free the message buffer
    //

    LOCAL_FREE( pMsgQObj );

    msgdbgprint( MSG_RECEIVE, (WORD)MsgQId, pMessage );

    LeaveCriticalSection( &(MessageQ[MsgQId].CriticalSection) );

    return( TRUE );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\devobj.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.           **/
/********************************************************************/

//***
//
// Filename:    devobj.c
//
// Description: All procedures in devices.
//
// History:     May 11,1995        NarenG        Created original version.
//
#include "ddm.h"
#include <winsvc.h>
#include "objects.h"
#include "handlers.h"
#include <raserror.h>
#include <dimif.h>
#include "rasmanif.h"
#include <stdlib.h>

//**
//
// Call:        DeviceObjIterator
//
// Returns:
//
// Description: Will iterate through all the devices and will call the
//              ProcessFunction for each one
//
DWORD
DeviceObjIterator(
    IN DWORD (*pProcessFunction)(   IN DEVICE_OBJECT *,
                                    IN LPVOID,
                                    IN DWORD,
                                    IN DWORD ),
    IN BOOL  fReturnOnError,
    IN PVOID Parameter
)
{
    DEVICE_OBJECT * pDeviceObj;
    DWORD           dwRetCode;
    DWORD           dwDeviceIndex = 0;
    DWORD           dwBucketIndex = 0;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    //
    // Iterate through the device table
    //

    for ( dwBucketIndex = 0;
          dwBucketIndex < gblDeviceTable.NumDeviceBuckets;
          dwBucketIndex++ )
    {
        for ( pDeviceObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
              pDeviceObj != NULL;
              pDeviceObj = pDeviceObj->pNext )
        {
            dwRetCode = (*pProcessFunction)( pDeviceObj,
                                             Parameter,
                                             dwBucketIndex,
                                             dwDeviceIndex++ );

            if ( fReturnOnError && ( dwRetCode != NO_ERROR ) )
            {
                LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                return( dwRetCode );
            }
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjInsertInTable
//
// Returns:     None
//
// Description  Will insert a given device into the device table
//
VOID
DeviceObjInsertInTable(
    IN DEVICE_OBJECT  * pDeviceObj
)
{
    DWORD dwBucketIndex = DeviceObjHashPortToBucket( pDeviceObj->hPort );

    pDeviceObj->pNext = gblDeviceTable.DeviceBucket[dwBucketIndex];

    gblDeviceTable.DeviceBucket[dwBucketIndex] = pDeviceObj;

    gblDeviceTable.NumDeviceNodes++;

    //
    // Increase the count for this media type for routers only
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
    {
        MediaObjAddToTable( pDeviceObj->wchDeviceType );
    }
}

//**
//
// Call:        DeviceObjRemoveFromTable
//
// Returns:     None
//
// Description  Will remove a given device from the device table
//
VOID
DeviceObjRemoveFromTable(
    IN HPORT    hPort
)
{
    DWORD               dwBucketIndex;
    DEVICE_OBJECT *     pDeviceObj ;
    DEVICE_OBJECT *     pDeviceObjPrev;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    dwBucketIndex   = DeviceObjHashPortToBucket( hPort );
    pDeviceObj      = gblDeviceTable.DeviceBucket[dwBucketIndex];
    pDeviceObjPrev  = pDeviceObj;

    while( pDeviceObj != (DEVICE_OBJECT *)NULL )
    {
        if ( pDeviceObj->hPort == hPort )
        {
            BOOL fWANDeviceInstalled = FALSE;

            if ( gblDeviceTable.DeviceBucket[dwBucketIndex] == pDeviceObj )
            {
                gblDeviceTable.DeviceBucket[dwBucketIndex] = pDeviceObj->pNext;
            }
            else
            {
                pDeviceObjPrev->pNext = pDeviceObj->pNext;
            }

            gblDeviceTable.NumDeviceNodes--;

            RasServerPortClose ( hPort );

            if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
            {
                 MediaObjRemoveFromTable( pDeviceObj->wchDeviceType );
            }

            LOCAL_FREE( pDeviceObj );

            //
            // Possibly need to notify router managers of reachability
            // change
            //

            EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

            IfObjectNotifyAllOfReachabilityChange( FALSE,
                                                   INTERFACE_OUT_OF_RESOURCES );

            LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );


            //
            // Tell DIM to update router identity object
            //

            ((VOID(*)(VOID))gblDDMConfigInfo.lpfnRouterIdentityObjectUpdate)();

            DeviceObjIterator(DeviceObjIsWANDevice,FALSE,&fWANDeviceInstalled);

            //
            // Tell DIM that a WAN device has been deinstalled and that it
            // should stop advertizing it's presence
            //

            ((VOID(*)( BOOL ))
                    gblDDMConfigInfo.lpfnIfObjectWANDeviceInstalled)(
                                                         fWANDeviceInstalled );
            break;
        }

        pDeviceObjPrev  = pDeviceObj;
        pDeviceObj      = pDeviceObj->pNext;
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return;
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjHashPortToBucket(
    IN HPORT hPort
)
{
    return( ((DWORD)HandleToUlong(hPort)) % gblDeviceTable.NumDeviceBuckets );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DEVICE_OBJECT  *
DeviceObjGetPointer(
    IN HPORT hPort
)
{
    DEVICE_OBJECT * pDeviceObj;
    DWORD           dwBucketIndex = DeviceObjHashPortToBucket( hPort );

    for ( pDeviceObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
          pDeviceObj != NULL;
          pDeviceObj = pDeviceObj->pNext )
    {
        if ( pDeviceObj->hPort == hPort )
        {
            return( pDeviceObj );
        }
    }

    return( (DEVICE_OBJECT *)NULL );
}

//**
//
// Call:        DeviceObjAllocAndInitialize
//
// Returns:     DEVICE_OBJECT * - Success
//              NULL            - Failure
//
// Description: Will allocate and initialize a device object
//
DEVICE_OBJECT *
DeviceObjAllocAndInitialize(
    IN HPORT            hPort,
    IN RASMAN_PORT*     pRasmanPort
)
{
    DEVICE_OBJECT * pDeviceObj = NULL;
    RASMAN_INFO     RasmanInfo;
    DWORD           dwRetCode = RasGetInfo( NULL, hPort, &RasmanInfo );

    if( dwRetCode != NO_ERROR )
    {
        SetLastError( dwRetCode );

        return( NULL );
    }

    //
    // Allocate and initialize a Device CB
    //

    pDeviceObj = (DEVICE_OBJECT *)LOCAL_ALLOC( LPTR, sizeof(DEVICE_OBJECT) );

    if ( pDeviceObj == (DEVICE_OBJECT *)NULL )
    {
        return( NULL );
    }

    pDeviceObj->hPort                   = hPort;
    pDeviceObj->pNext                   = (DEVICE_OBJECT *)NULL;
    pDeviceObj->hConnection             = (HCONN)INVALID_HANDLE_VALUE;
    pDeviceObj->DeviceState             = DEV_OBJ_CLOSED;
    pDeviceObj->ConnectionState         = DISCONNECTED;
    pDeviceObj->SecurityState           = DEV_OBJ_SECURITY_DIALOG_INACTIVE;
    pDeviceObj->dwCallbackDelay         = gblDDMConfigInfo.dwCallbackTime;
    pDeviceObj->fFlags                  = 0;
    pDeviceObj->dwHwErrorSignalCount    = HW_FAILURE_CNT;
    pDeviceObj->wchCallbackNumber[0]    = TEXT('\0');
    pDeviceObj->hRasConn                = NULL;
    pDeviceObj->dwDeviceType            = RasmanInfo.RI_rdtDeviceType;

    //
    // copy the port name,device type and device name in the dcb
    //

    MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_PortName,
                    -1,
                    pDeviceObj->wchPortName,
                    MAX_PORT_NAME+1 );

    MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_MediaName,
                    -1,
                    pDeviceObj->wchMediaName,
                    MAX_MEDIA_NAME+1 );

    if(ERROR_SUCCESS != RasGetUnicodeDeviceName(
                            pRasmanPort->P_Handle,
                            pDeviceObj->wchDeviceName))
    {                            

        DDMTRACE( "DeviceObjAllocAndInitialize GetUnicodeDviceName failed ******");
        MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_DeviceName,
                    -1,
                    pDeviceObj->wchDeviceName,
                    MAX_DEVICE_NAME+1 );
    }                    

    MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_DeviceType,
                    -1,
                    pDeviceObj->wchDeviceType,
                    MAX_DEVICETYPE_NAME+1 );

    if ( pRasmanPort->P_ConfiguredUsage & (CALL_IN | CALL_IN_ONLY))
    {
        pDeviceObj->fFlags |= DEV_OBJ_ALLOW_CLIENTS;
    }

    if ( pRasmanPort->P_ConfiguredUsage & 
        (CALL_ROUTER | CALL_OUTBOUND_ROUTER) )
    {
        pDeviceObj->fFlags |= DEV_OBJ_ALLOW_ROUTERS;
    }

    return( pDeviceObj );
}

//**
//
// Call:        DeviceObjStartClosing
//
// Returns:     NO_ERROR
//
// Description: Close all active devices; if no devices have been initialized
//              and opened then this part is skipped.
//
DWORD
DeviceObjStartClosing(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( pDeviceObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
    {
        RasApiCleanUpPort( pDeviceObj );
    }

    if ( ( pDeviceObj->DeviceState != DEV_OBJ_CLOSED  ) &&
         ( pDeviceObj->DeviceState != DEV_OBJ_CLOSING ) )
    {
        if ( pDeviceObj->fFlags & DEV_OBJ_PPP_IS_ACTIVE )
        {
            PppDdmStop( (HPORT)pDeviceObj->hPort, NO_ERROR );
        }
        else
        {
            DevStartClosing( pDeviceObj );
        }
    }

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjPostListen
//
// Returns:
//
// Description:
//
DWORD
DeviceObjPostListen(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    DWORD Type;
    //UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if(NULL != Parameter)
    {
       Type  = *((DWORD *) (Parameter));
       
        if(RAS_DEVICE_TYPE(pDeviceObj->dwDeviceType) != Type)
        {
            return NO_ERROR;
        }
    }

    pDeviceObj->DeviceState = DEV_OBJ_LISTENING;

    RmListen( pDeviceObj );

    return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjIsClosed(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( pDeviceObj->DeviceState != DEV_OBJ_CLOSED )
    {
        return( ERROR_DEVICE_NOT_READY );
    }

    return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjCopyhPort(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    HPORT * phPort = (HPORT *)Parameter;

    UNREFERENCED_PARAMETER( Parameter );

    phPort[dwDeviceIndex] = pDeviceObj->hPort;

    return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjCloseListening(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( pDeviceObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
    {
        return( NO_ERROR );
    }

    switch( pDeviceObj->DeviceState )
    {

    case DEV_OBJ_HW_FAILURE:
    case DEV_OBJ_LISTENING:

        DevStartClosing( pDeviceObj );
        break;

    default:

        break;
    }

    return( NO_ERROR );

}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjResumeListening(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( pDeviceObj->DeviceState == DEV_OBJ_CLOSED )
    {
        DevCloseComplete( pDeviceObj );
    }

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjRequestNotification
//
// Returns:     NO_ERROR - Success
//              non-zero return from RasRequestNotification - Failure
//
// Description: Will register each of the bucket events with RasMan for
//              RasMan event notification.
//
DWORD
DeviceObjRequestNotification(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    return ( RasRequestNotification(
                            pDeviceObj->hPort,
                            gblSupervisorEvents[dwBucketIndex+NUM_DDM_EVENTS]));
}

//**
//
// Call:        DeviceObjClose
//
// Returns:
//
// Description: Closes opened ports
//
DWORD
DeviceObjClose(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwDeviceIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    RasServerPortClose( pDevObj->hPort );

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjIsWANDevice
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
DeviceObjIsWANDevice(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    BOOL * pfWANDeviceInstalled = (BOOL *)Parameter;

    *pfWANDeviceInstalled = FALSE;

    if ( RAS_DEVICE_CLASS( pDevObj->dwDeviceType ) != RDT_Direct )
    {
        *pfWANDeviceInstalled = TRUE;
    }

    return( NO_ERROR );
}

//**
//
// Call:        DDMServicePostListens
//
// Returns:     None
//
// Description: Exported call to DIM to post listens after interfaces have
//              been loaded
//
VOID
DDMServicePostListens(
    VOID *pVoid
)
{
    //
    // Post listen for each dcb
    //

    DeviceObjIterator( DeviceObjPostListen, FALSE, pVoid);
}

//**
//
// Call:        DeviceObjGetType
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
DeviceObjGetType(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    DWORD dwVendorId = 311;
    DWORD dwType     = 6;
    DWORD dwValue    = (DWORD)-1;
    DWORD dwIndex    = 0;
    ROUTER_IDENTITY_ATTRIBUTE * pRouterIdAttributes =
                                        (ROUTER_IDENTITY_ATTRIBUTE * )Parameter;

    switch( RAS_DEVICE_TYPE( pDevObj->dwDeviceType ) )
    {
    case RDT_Modem:
        dwValue = 706;
        break;

    case RDT_X25:
        dwValue = 710;
        break;

    case RDT_Isdn:
        dwValue = 705;
        break;

    case RDT_Serial:
        dwValue = 713;
        break;

    case RDT_FrameRelay:
        dwValue = 703;
        break;

    case RDT_Atm:
        dwValue = 704;
        break;

    case RDT_Sonet:
        dwValue = 707;
        break;

    case RDT_Sw56:
        dwValue = 708;
        break;

    case RDT_Tunnel_Pptp:
        dwValue = 701;
        break;

    case RDT_Tunnel_L2tp:
        dwValue = 702;
        break;

    case RDT_Irda:
        dwValue = 709;
        break;

    case RDT_Parallel:
        dwValue = 714;
        break;

    case RDT_Other:
    default:

        //
        // unknown so set to generic WAN
        //

        dwValue = 711;
        break;
    }

    for( dwIndex = 0;
         pRouterIdAttributes[dwIndex].dwVendorId != -1;
         dwIndex++ )
    {
        //
        // Check if already set
        //

        if ( ( pRouterIdAttributes[dwIndex].dwVendorId == 311 )     &&
             ( pRouterIdAttributes[dwIndex].dwType     == 6 )       &&
             ( pRouterIdAttributes[dwIndex].dwValue    == dwValue ) )
        {
            return( NO_ERROR );
        }
    }

    //
    // Now set so set it here
    //

    pRouterIdAttributes[dwIndex].dwVendorId = 311;
    pRouterIdAttributes[dwIndex].dwType     = 6;
    pRouterIdAttributes[dwIndex].dwValue    = dwValue;

    //
    // Terminate the array
    //

    dwIndex++;

    pRouterIdAttributes[dwIndex].dwVendorId = (DWORD)-1;
    pRouterIdAttributes[dwIndex].dwType     = (DWORD)-1;
    pRouterIdAttributes[dwIndex].dwValue    = (DWORD)-1;

    return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
DeviceObjForceIpSec(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
)
{
    DWORD   dwRetCode;

    UNREFERENCED_PARAMETER( Parameter );
    UNREFERENCED_PARAMETER( dwBucketIndex );
    UNREFERENCED_PARAMETER( dwDeviceIndex );

    if ( RAS_DEVICE_TYPE( pDeviceObj->dwDeviceType ) != RDT_Tunnel_L2tp )
    {
        return( NO_ERROR );
    }

    if ( pDeviceObj->ConnectionState != LISTENING )
    {
        return( NO_ERROR );
    }

    //
    // If this is an L2TP tunnel port type and we have to use
    // IPSEC, then go ahead and set/unset the filter
    //

    dwRetCode = RasEnableIpSec(
                    pDeviceObj->hPort,
                    //gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireIPSEC,
                    TRUE,
                    TRUE,
                    (gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireIPSEC)
                    ? RAS_L2TP_REQUIRE_ENCRYPTION
                    : RAS_L2TP_OPTIONAL_ENCRYPTION);

    DDMTRACE2( "Enabled IPSec on port %d, dwRetCode = %d",
                pDeviceObj->hPort, dwRetCode );

    //
    // Log the non certificate errorlog only once
    //

    if ( dwRetCode == ERROR_NO_CERTIFICATE )
    {
        if ( !( gblDDMConfigInfo.fFlags & DDM_NO_CERTIFICATE_LOGGED ) )
        {
            DDMLogWarning( ROUTERLOG_NO_IPSEC_CERT, 0, NULL );

            gblDDMConfigInfo.fFlags |= DDM_NO_CERTIFICATE_LOGGED;
        }

        return( dwRetCode );
    }

    if( (dwRetCode != NO_ERROR) && !(pDeviceObj->fFlags & DEV_OBJ_IPSEC_ERROR_LOGGED) )
    {
        WCHAR       wchPortName[MAX_PORT_NAME+1];
        LPWSTR      lpwsAuditStr[1];
        RASMAN_INFO rInfo;
        DWORD       rc;

        // DevStartClosing(pDeviceObj);

        ZeroMemory(&rInfo, sizeof(RASMAN_INFO));

        rc = RasGetInfo(NULL, pDeviceObj->hPort, &rInfo);

        if(rc != NO_ERROR)
        {
            return (NO_ERROR);
        }

        MultiByteToWideChar( CP_ACP,
                             0,
                             rInfo.RI_szPortName,
                             -1,
                             wchPortName,
                             MAX_PORT_NAME+1 );

        lpwsAuditStr[0] = wchPortName;

        DDMLogWarningString(ROUTERLOG_IPSEC_FILTER_FAILURE, 1, lpwsAuditStr, dwRetCode,1);

        pDeviceObj->fFlags |= DEV_OBJ_IPSEC_ERROR_LOGGED;
    }
    else
    {
        //
        // Clear the flag so that if we hit this error again
        // we do an eventlog
        //
        pDeviceObj->fFlags &= ~DEV_OBJ_IPSEC_ERROR_LOGGED;
    }

    return( NO_ERROR );
}

//**
//
// Call:        DeviceObjAdd
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
DeviceObjAdd(
    IN RASMAN_PORT * pRasmanPort
)
{
    DWORD           dwRetCode;
    HPORT           hPort;
    DEVICE_OBJECT * pDevObj = DeviceObjGetPointer( pRasmanPort->P_Handle );

    //
    // Make sure we do not already have this device
    //

    if ( pDevObj != NULL )
    {
        DDMTRACE1("Error:Recvd add new port notification for existing port %d",
                   pRasmanPort->P_Handle );
        return;
    }

    DDMTRACE1( "Adding new port hPort=%d", pRasmanPort->P_Handle );

    dwRetCode = RasPortOpen( pRasmanPort->P_PortName, &hPort, NULL );

    if ( dwRetCode != NO_ERROR )
    {
        WCHAR  wchPortName[MAX_PORT_NAME+1];
        LPWSTR lpwsAuditStr[1];

        MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pRasmanPort->P_PortName, 
                    -1,
                    wchPortName,
                    MAX_PORT_NAME+1 );
        //
        // Log an error
        //

        lpwsAuditStr[0] = wchPortName;

        DDMLogErrorString( ROUTERLOG_UNABLE_TO_OPEN_PORT, 1,
                           lpwsAuditStr, dwRetCode, 1 );
    }
    else
    {
        pDevObj = DeviceObjAllocAndInitialize( hPort, pRasmanPort );

        if ( pDevObj == (DEVICE_OBJECT *)NULL )
        {
            dwRetCode = GetLastError();

            DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY,0, NULL,dwRetCode);

            return;
        }

        //
        // Insert into the device hash table
        //

        DeviceObjInsertInTable( pDevObj );

        //
        // Possibly need to notify router managers of reachability
        // change
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( TRUE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        //
        // Tell DIM to update router identity object
        //

        ((VOID(*)(VOID))gblDDMConfigInfo.lpfnRouterIdentityObjectUpdate)();

        if ( RAS_DEVICE_CLASS( pDevObj->dwDeviceType ) != RDT_Direct )
        {
            //
            // Tell DIM that a WAN device has been installed and that it
            // should start advertizing it's presence
            //

            ((VOID(*)( BOOL ))
                    gblDDMConfigInfo.lpfnIfObjectWANDeviceInstalled)( TRUE );
        }

        //
        // Post a listen
        //

        if ( RAS_DEVICE_TYPE( pDevObj->dwDeviceType ) != RDT_PPPoE )
        {
            DeviceObjPostListen( pDevObj, NULL, 0, 0 );
        }
    }
}

//**
//
// Call:        DeviceObjRemove
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
DeviceObjRemove(
    IN RASMAN_PORT * pRasmanPort
)
{
    DEVICE_OBJECT * pDevObj = DeviceObjGetPointer( pRasmanPort->P_Handle );

    if ( pDevObj == NULL )
    {
        DDMTRACE1("Error:Recvd remove port notification for existing port %d",
                   pRasmanPort->P_Handle );
        return;
    }

    DDMTRACE1( "Removing port hPort=%d", pRasmanPort->P_Handle );

    if ( pDevObj->fFlags & DEV_OBJ_MARKED_AS_INUSE )
    {
        //
        // If the device is busy, then just set the flag to discard
        // the port after disconnection,
        //

        pDevObj->fFlags |= DEV_OBJ_PNP_DELETE;
    }
    else
    {
        //
        // Otherwise remove the port
        //

        DeviceObjRemoveFromTable( pRasmanPort->P_Handle );

    }
}

//**
//
// Call:        DeviceObjUsageChange
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
DeviceObjUsageChange(
    IN RASMAN_PORT * pRasmanPort
)
{
    DEVICE_OBJECT * pDevObj = DeviceObjGetPointer( pRasmanPort->P_Handle );

    if ( pDevObj == NULL )
    {
        if ( pRasmanPort->P_ConfiguredUsage & 
            ( CALL_IN | CALL_ROUTER | CALL_OUTBOUND_ROUTER ) )
        {
            DeviceObjAdd( pRasmanPort );
        }

        return;
    }

    if ( !( pRasmanPort->P_ConfiguredUsage & 
            ( CALL_IN | CALL_ROUTER | CALL_OUTBOUND_ROUTER ) ) )
    {
        DeviceObjRemove( pRasmanPort );

        return;
    }

    DDMTRACE1("Changing usage for port %d", pRasmanPort->P_Handle );

    //
    // Modify the media table and usage accordingly
    //

    if ( ( pDevObj->fFlags & DEV_OBJ_ALLOW_ROUTERS ) &&
         ( !( pRasmanPort->P_ConfiguredUsage & 
                ( CALL_ROUTER | CALL_OUTBOUND_ROUTER ) ) ) )
    {
        //
        // If it was a router port but is no longer then we
        // remove the media from the media table
        //

        MediaObjRemoveFromTable( pDevObj->wchDeviceType );

        //
        // Possibly need to notify router managers of reachability
        // change
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( FALSE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    }

    if ( ( !( pDevObj->fFlags & DEV_OBJ_ALLOW_ROUTERS ) ) &&
         ( pRasmanPort->P_ConfiguredUsage & 
            ( CALL_ROUTER | CALL_OUTBOUND_ROUTER ) ) )
    {
        //
        // If it was not a router port but is now, then we
        // add the media to the media table
        //

        MediaObjAddToTable( pDevObj->wchDeviceType );

        //
        // Possibly need to notify router managers of reachability
        // change
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( TRUE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    }

    if ( pRasmanPort->P_ConfiguredUsage & CALL_IN  )
    {
        pDevObj->fFlags |= DEV_OBJ_ALLOW_CLIENTS;
    }
    else
    {
        pDevObj->fFlags &= ~DEV_OBJ_ALLOW_CLIENTS;
    }

    if ( pRasmanPort->P_ConfiguredUsage & 
        (CALL_ROUTER | CALL_OUTBOUND_ROUTER) )
    {
        pDevObj->fFlags |= DEV_OBJ_ALLOW_ROUTERS;
    }
    else
    {
        pDevObj->fFlags &= ~DEV_OBJ_ALLOW_ROUTERS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\evdsptch.c ===
/********************************************************************/
/*	      Copyright(c)  1995 Microsoft Corporation		            */
/********************************************************************/

//***
//
// Filename:	evdsptch.c
//
// Description: This module contains the event dispatcher for the
//		        DDM's procedure-driven state machine
//
// Author:	    Stefan Solomon (stefans)    June 9, 1992.
//
//***
#include "ddm.h"
#include "handlers.h"
#include "objects.h"
#include "timer.h"
#include "util.h"
#include <raserror.h>
#include <ddmif.h>
#include <sechost.h>
#include <stdlib.h>
#include "rasmanif.h"

//***
//
// Function:	EventDispatcher
//
// Descr:	    Waits for events to be signaled and invokes the proper
//		        event handler. Returns when DDM has terminated.
//
//***
DWORD
EventDispatcher(
    IN LPVOID arg
)
{
    EVENT_HANDLER * pEventHandler;
    DWORD           dwSignaledEvent;

    //
    // Indicate that this thread is running
    //

    InterlockedIncrement( gblDDMConfigInfo.lpdwNumThreadsRunning );

    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyParameters,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION],
                             TRUE );
    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyAccounting,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION1],
                             TRUE );

    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyAuthentication,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION2],
                             TRUE );
    while( TRUE )
    {
        dwSignaledEvent = WaitForMultipleObjectsEx( 
                            NUM_DDM_EVENTS
                            + ( gblDeviceTable.NumDeviceBuckets * 3 ),
                            gblSupervisorEvents,
                            FALSE, 
                            INFINITE,
                            TRUE);

        if ( ( dwSignaledEvent == 0xFFFFFFFF ) || 
             ( dwSignaledEvent == WAIT_TIMEOUT ) )
        {
            DDMTRACE2("WaitForMultipleObjectsEx returned %d, GetLastError=%d",
                       dwSignaledEvent, GetLastError() );

            continue;
        }

        //
        // DDM has terminated so return
        //

        if ( dwSignaledEvent == DDM_EVENT_SVC_TERMINATED )
        {
            LPDWORD lpdwNumThreadsRunning = 
                                    gblDDMConfigInfo.lpdwNumThreadsRunning;

            //
            // If we were running and we are now shutting down, clean up
            // gracefully
            //

            if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState 
                                                    == SERVICE_STOP_PENDING )
            {
                DDMCleanUp();
            }

            //
            // Decrease the count for this thread
            //

            InterlockedDecrement( lpdwNumThreadsRunning );

            return( NO_ERROR );
        }

        //
        // invoke the handler associated with the signaled event
        //

        if ( dwSignaledEvent < NUM_DDM_EVENTS ) 
        {
            //
            // Some DDM event
            //

            gblEventHandlerTable[dwSignaledEvent].EventHandler();
        }
        else if ( dwSignaledEvent < ( NUM_DDM_EVENTS 
                                     + gblDeviceTable.NumDeviceBuckets ) )
        {
            //
            // The event was a RASMAN event
            //

            RmEventHandler( dwSignaledEvent );
        }
        else if ( dwSignaledEvent < ( NUM_DDM_EVENTS 
                                      + gblDeviceTable.NumDeviceBuckets * 2 ) )
        {
            //
            // A frame was received on a port
            //

            RmRecvFrameEventHandler( dwSignaledEvent );
        }
        else if ( dwSignaledEvent != WAIT_IO_COMPLETION )
        {
            //
            // We got a disconnect on a dialed out port
            //

            RasApiDisconnectHandler( dwSignaledEvent );
        }
    }

    return( NO_ERROR );
}

//***
//
//  Function:	SecurityDllEventHandler
//
//  Descr:	    This will handle all events from the 3rd party security Dll.
//		        Either the security dialog with the client completed 
//              successfully, in which case we continue on with the connection,
//              or we log the error and bring down the line.
//
//***

VOID 
SecurityDllEventHandler(
    VOID
)
{
    LPWSTR              auditstrp[3];
    SECURITY_MESSAGE    message;
    PDEVICE_OBJECT      pDevObj;
    DWORD               dwBucketIndex;
    WCHAR               wchUserName[UNLEN+1];

    //
    // loop to get all messages
    //

    while( ServerReceiveMessage( MESSAGEQ_ID_SECURITY, (BYTE *) &message ) )
    {

        EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

        //
	    // identify the message recipient
        //

        if ( ( pDevObj = DeviceObjGetPointer( message.hPort ) ) == NULL )
        {

            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

	        return;
	    }

        //
        // action on the message type
        //

        switch( message.dwMsgId )
        {

        case SECURITYMSG_SUCCESS:

            //
            // Stop timer for 3rd party security
            //

            TimerQRemove( (HANDLE)pDevObj->hPort, SvSecurityTimeout );

            if ( pDevObj->pRasmanSendBuffer != NULL )
            {
                RasFreeBuffer( pDevObj->pRasmanSendBuffer );

                pDevObj->pRasmanSendBuffer = NULL;
            }

            //
            // copy the user name
            //

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 message.UserName, 
                                -1,
                                 pDevObj->wchUserName, 
                                 UNLEN+1 );

            //
            // copy the domain name
            //

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 message.Domain, 
                                 -1,
                                 pDevObj->wchDomainName, 
                                 DNLEN+1 );

            pDevObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_INACTIVE;

            //
            // Change RASMAN state to CONNECTED from LISTENCOMPLETE and signal
            // RmEventHandler
            //

	        RasPortConnectComplete(pDevObj->hPort);

            dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

            SetEvent( gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex] );

            DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
	               "SecurityDllEventHandler: Security DLL success \n" );

            break;

        case SECURITYMSG_FAILURE:

            //
            // Log the fact that the use failed to pass 3rd party security.
            //

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 message.UserName, 
                                 -1,
                                 wchUserName, 
                                 UNLEN+1 );

            auditstrp[0] = wchUserName;
            auditstrp[1] = pDevObj->wchPortName;

            DDMLogError( ROUTERLOG_SEC_AUTH_FAILURE, 2, auditstrp, NO_ERROR );

            //
            // Hang up the line
            //

            DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
	               "SecurityDllEventHandler:Security DLL failure %s\n",
                    message.UserName );

            if ( pDevObj->SecurityState == DEV_OBJ_SECURITY_DIALOG_ACTIVE )
            {
                DevStartClosing(pDevObj);
            }
            else if ( pDevObj->SecurityState==DEV_OBJ_SECURITY_DIALOG_STOPPING )
            {
                pDevObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_INACTIVE;

                DevCloseComplete(pDevObj);
            }

            break;

        case SECURITYMSG_ERROR:

            auditstrp[0] = pDevObj->wchPortName;

	        DDMLogErrorString( ROUTERLOG_SEC_AUTH_INTERNAL_ERROR, 1, auditstrp, 
                               message.dwError, 1);

            DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
                   "SecurityDllEventHandler:Security DLL failure %x\n",
                    message.dwError );

            if ( pDevObj->SecurityState == DEV_OBJ_SECURITY_DIALOG_ACTIVE )
            {
                DevStartClosing(pDevObj);
            }
            else if ( pDevObj->SecurityState==DEV_OBJ_SECURITY_DIALOG_STOPPING )
            {
                pDevObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_INACTIVE;

                DevCloseComplete(pDevObj);
            }

            break;

        default:

	        RTASSERT(FALSE);
	        break;
        }

        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\ifobject.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    ifobject.c
//
// Description: Routines to manipulate ROUTER_INTERFACE_OBJECTs
//
// History:     May 11,1995	    NarenG		Created original version.
//
#include "ddm.h"
#include "objects.h"
#include "handlers.h"
#include "timer.h"
#include <util.h>
#include <rasapiif.h>
#include <ras.h>

typedef struct _DDM_SUBENTRY_ENUMCONTEXT
{
    ROUTER_INTERFACE_OBJECT *pIfObject;
    BOOL fAtLeastOneDeviceAvailable;
} DDM_SUBENTRY_ENUMCONTEXT;

//
// This actually lives in rasapi.dll
//
DWORD
DDMGetPhonebookInfo(
    LPWSTR  lpwsPhonebookName,
    LPWSTR  lpwsPhonebookEntry,
    LPDWORD lpdwNumSubEntries,
    LPDWORD lpdwNumRedialAttempts,
    LPDWORD lpdwNumSecondsBetweenAttempts,
    BOOL *  lpfRedialOnLinkFailure,
    CHAR *  szzParameters,
    LPDWORD lpdwDialMode,
    PVOID * ppvContext,
    PVOID   pvSubEntryEnumHandler,
    PVOID   pvSubEntryEnumHandlerContext
);

VOID
DDMFreePhonebookContext(
    VOID *pvContext
);

VOID
DDMEnumerateSubEntries(
               PVOID pvContext,
               LPWSTR pwsInterfaceName,
               FARPROC IfObjectSubEntryEnumHandler,
               VOID *pvEnumContext
);


RASEVENT *
DDMGetRasEvent(HCONN hConnection)
{
    CONNECTION_OBJECT *pConn = NULL;
    RASEVENT *pEvent;
    
    pEvent = (RASEVENT *) LOCAL_ALLOC(LPTR, sizeof(RASEVENT));
    if(pEvent != NULL)
    {
        pConn = ConnObjGetPointer(hConnection);

        if(pConn != NULL)
        {
            if( pConn->pDeviceList &&
               pConn->pDeviceList[0])
            {
                pEvent->rDeviceType = 
                    pConn->pDeviceList[0]->dwDeviceType;
            }
            CopyMemory(&pEvent->guidId, &pConn->guid,
                        sizeof(GUID));
            pEvent->hConnection = hConnection;                        
        }            
    }
    return pEvent;
    
}


//**
//
// Call:        IfObjectAllocateAndInit
//
// Returns:     ROUTER_INTERFACE_OBJECT *   - Success
//              NULL                        - Failure
//
// Description: Allocates and initializes a ROUTER_INTERFACE_OBJECT structure
//
ROUTER_INTERFACE_OBJECT *
IfObjectAllocateAndInit(
    IN  LPWSTR                  lpwstrName,
    IN  ROUTER_INTERFACE_STATE  State,
    IN  ROUTER_INTERFACE_TYPE   IfType,
    IN  HCONN                   hConnection,
    IN  BOOL                    fEnabled,
    IN  DWORD                   dwMinUnreachabilityInterval,
    IN  DWORD                   dwMaxUnreachabilityInterval,
    IN  LPWSTR                  lpwsDialoutHours,
    IN OUT PVOID *              ppvContext
)
{
    return( ( (ROUTER_INTERFACE_OBJECT*(*)( 
                    LPWSTR,
                    ROUTER_INTERFACE_STATE,
                    ROUTER_INTERFACE_TYPE,
                    HCONN,
                    BOOL,
                    DWORD,
                    DWORD,
                    LPWSTR,
                    PVOID *))gblDDMConfigInfo.lpfnIfObjectAllocateAndInit)(   
                                    lpwstrName,
                                    State,
                                    IfType,
                                    hConnection,
                                    fEnabled,
                                    dwMinUnreachabilityInterval,
                                    dwMaxUnreachabilityInterval,
                                    lpwsDialoutHours,
                                    NULL));

}

//**
//
// Call:        IfObjectAreAllTransportsDisconnected
//
// Returns:     TRUE
//              FALSE
//
// Description: Checks to see if all the transports for an interface are 
//              disconnected.
//
BOOL
IfObjectAreAllTransportsDisconnected(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    DWORD dwTransportIndex;

    for ( dwTransportIndex = 0; 
          dwTransportIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwTransportIndex++ )
    {
        if ( pIfObject->Transport[dwTransportIndex].fState 
             & RITRANSPORT_CONNECTED )
        {
            return( FALSE );
        }
    }

    return( TRUE );
}

//**
//
// Call:        IfObjectGetPointerByName
//
// Returns:     ROUTER_INTERFACE_OBJECT * - Pointer to the interface object
//              structure with the given name, if it exists.
//              NULL - if it doesn't exist.
//
// Description: Simply calls the DIM entry point to do the work.
//
ROUTER_INTERFACE_OBJECT * 
IfObjectGetPointerByName(
    IN LPWSTR   lpwstrName,
    IN BOOL     fIncludeClientInterfaces
)
{
    return(((ROUTER_INTERFACE_OBJECT*(*)( LPWSTR, BOOL ))
                    gblDDMConfigInfo.lpfnIfObjectGetPointerByName)(
                                                    lpwstrName,
                                                    fIncludeClientInterfaces));
}

//**
//
// Call:        IfObjectGetPointer
//
// Returns:     ROUTER_INTERFACE_OBJECT * - Pointer to the interface object
//              structure with the given handle, if it exists.
//              NULL - if it doesn't exist.
//
// Description: Simply calls the DIM entry point to do the work.
//
ROUTER_INTERFACE_OBJECT *
IfObjectGetPointer(
    IN HANDLE hDIMInterface
)
{
    return(((ROUTER_INTERFACE_OBJECT*(*)( HANDLE ))
                    gblDDMConfigInfo.lpfnIfObjectGetPointer)( hDIMInterface ));
}

//**
//
// Call:        IfObjectRemove
//
// Returns:     None
//
// Description: Simply calls the DIM entrypoint to remove the interface object
//              from the table. The object is DeAllocated.
//
VOID
IfObjectRemove(
    IN HANDLE hDIMInterface
)
{
    ((VOID(*)( HANDLE ))gblDDMConfigInfo.lpfnIfObjectRemove)( hDIMInterface );
}

//**
//
// Call:        IfObjectDisconnected    
//
// Returns:     None
//
// Description: Sets this interface to the disconnected state
//
VOID
IfObjectDisconnected(
    ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    DWORD   dwIndex;
    BOOL    fReachable = TRUE;
    HANDLE  hConnection;

    //
    // If already disconnected, then simply return
    //

    if ( pIfObject->State == RISTATE_DISCONNECTED )
    {
        return;
    }

    //
    // If this interface is persistent then we do not want to connect
    // again because the local admin or router managers initiated the 
    // disconnect
    //

    if ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) 
    {
        pIfObject->dwNumOfReConnectAttemptsCounter = 0;

        TimerQRemove( pIfObject->hDIMInterface, ReConnectInterface );

        TimerQRemove( pIfObject->hDIMInterface, ReConnectPersistentInterface );
    }

    hConnection = pIfObject->hConnection;
    
    pIfObject->State        = RISTATE_DISCONNECTED;
    pIfObject->hConnection  = (HCONN)INVALID_HANDLE_VALUE;
    pIfObject->fFlags       &= ~IFFLAG_LOCALLY_INITIATED;
    pIfObject->hRasConn     = (HRASCONN)NULL;

    //
    // If we are not unreachable due to connection failure
    //

    if ( !( pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE ) )
    {
        //
        // Check reachability state
        //

        DWORD dwUnreachabilityReason;

        if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
        {
            dwUnreachabilityReason = INTERFACE_OUT_OF_RESOURCES;
            fReachable             = FALSE;
        }
        else if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState
                                                            == SERVICE_PAUSED )
        {
            dwUnreachabilityReason = INTERFACE_SERVICE_IS_PAUSED;
            fReachable             = FALSE;
        }
        else if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
        {
            dwUnreachabilityReason = INTERFACE_DISABLED;
            fReachable             = FALSE;
        }
        else if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
        {
            dwUnreachabilityReason = INTERFACE_DIALOUT_HOURS_RESTRICTION;
            fReachable             = FALSE;
        }

        //
        // Notify the router manager that this interface is disabled if the
        // admin has disabled it or the service is paused, now that the 
        // interface is disconnected.
        //

        for ( dwIndex = 0; 
              dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
              dwIndex++ )
        {
            pIfObject->Transport[dwIndex].fState &= ~RITRANSPORT_CONNECTED;

            if ( !fReachable )
            {
                if (pIfObject->Transport[dwIndex].hInterface ==
                                                        INVALID_HANDLE_VALUE)
                {
                    continue;
                }

                gblRouterManagers[dwIndex].DdmRouterIf.InterfaceNotReachable(
                            pIfObject->Transport[dwIndex].hInterface,
                            dwUnreachabilityReason );
                            
            }
        }

        if ( !fReachable )
        {
            if ( pIfObject->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
            {
                LogUnreachabilityEvent( dwUnreachabilityReason, 
                                        pIfObject->lpwsInterfaceName );
            }
        }

        //
        // If this interface is marked as persistent then try to reconnect 
        // only if the admin did not disconnect the interface 
        //

        if ( ( fReachable )                                             &&
             ( pIfObject->fFlags & IFFLAG_PERSISTENT )                  &&
             ( !( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) ) )
        {
            TimerQInsert( pIfObject->hDIMInterface, 
                          1,
                          ReConnectPersistentInterface );
        }

        //
        // Notify that this connection has been disconnected
        //

        IfObjectConnectionChangeNotification();

        {
            //
            // Notify netman that a connection went down.
            //
            
            DWORD retcode;
            RASEVENT *pRasEvent = NULL;
            CONNECTION_OBJECT *pConn = NULL;

            pRasEvent = DDMGetRasEvent(hConnection);

            if(pRasEvent != NULL)
            {
                pRasEvent->Type = INCOMING_DISCONNECTED;
                retcode = RasSendNotification(pRasEvent);

                DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                          "RasSendNotification(INCOMING_DISCONNETED rc=0x%x",
                          retcode);

                LOCAL_FREE(pRasEvent);                          
            }                      
            
        }

    }
}

//**
//
// Call:        IfObjectConnected
//
// Returns:     None
//
// Description: Sets this interface to the CONNECTED state and notifies the
//              router managers, if any, about unreachable transports.
//
DWORD
IfObjectConnected(
    IN HANDLE                   hDDMInterface,
    IN HCONN                    hConnection,
    IN PPP_PROJECTION_RESULT   *pProjectionResult
)
{
    DWORD                     dwIndex;
    ROUTER_INTERFACE_OBJECT * pIfObject; 
    BOOL                      fXportConnected = FALSE;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    pIfObject = IfObjectGetPointer( hDDMInterface );

    if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
    {
        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        return( ERROR_INVALID_HANDLE );
    }

    if ( pIfObject->State == RISTATE_CONNECTED )
    {
        //
        // Already connected
        //

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        return( NO_ERROR );
    }

    pIfObject->hConnection  = hConnection;
    pIfObject->State        = RISTATE_CONNECTED;
    pIfObject->fFlags       &= ~IFFLAG_CONNECTION_FAILURE; 

    //
    // If we are connected and we initiated the connection then reset the
    // unreachability interval
    //

    if ( pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED )
    {
        pIfObject->dwReachableAfterSeconds 
                                    = pIfObject->dwReachableAfterSecondsMin;
    }

    //
    // Remove any reconnect calls that may be on the timer queue
    //

    TimerQRemove( pIfObject->hDIMInterface, ReConnectInterface );
    TimerQRemove( pIfObject->hDIMInterface, ReConnectPersistentInterface );

    for ( dwIndex = 0; 
          dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwIndex++ )
    {
        fXportConnected = FALSE;

        switch( gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId )
        {
        case PID_IPX:

            if ( pProjectionResult->ipx.dwError == NO_ERROR )
            {
                fXportConnected = TRUE;

            }

            break;

        case PID_IP:

            if ( pProjectionResult->ip.dwError == NO_ERROR )
            {
                fXportConnected = TRUE;
            }

            break;

        default:

            break;
        }

        if ( pIfObject->Transport[dwIndex].hInterface == INVALID_HANDLE_VALUE )
        {
            continue;
        }

        if ( fXportConnected )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "Notifying Protocol = 0x%x,Interface=%ws is Connected",
                    gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId,
                    pIfObject->lpwsInterfaceName );

            pIfObject->Transport[dwIndex].fState |= RITRANSPORT_CONNECTED;

            gblRouterManagers[dwIndex].DdmRouterIf.InterfaceConnected(
                                    pIfObject->Transport[dwIndex].hInterface,
                                    NULL,
                                    pProjectionResult );
        }
        else
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "Notifying Protocol = 0x%x,Interface=%ws is UnReachable=%d",
                    gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId,
                    pIfObject->lpwsInterfaceName,
                    INTERFACE_CONNECTION_FAILURE );

            gblRouterManagers[dwIndex].DdmRouterIf.InterfaceNotReachable(
                            pIfObject->Transport[dwIndex].hInterface,
                            INTERFACE_CONNECTION_FAILURE );
        }
    }

    IfObjectConnectionChangeNotification();

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    
    {
        DWORD retcode;
        
        RASEVENT *pRasEvent = NULL;
        CONNECTION_OBJECT *pConn = NULL;

        //
        // Get the device type
        //
        EnterCriticalSection(&(gblDeviceTable.CriticalSection));    
        pRasEvent = DDMGetRasEvent(hConnection);
        LeaveCriticalSection(&(gblDeviceTable.CriticalSection));

        if(pRasEvent != NULL)
        {
            //
            // Notify netman of the connection
            //
            pRasEvent->Type = INCOMING_CONNECTED;
            retcode = RasSendNotification(pRasEvent);

            DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                      "RasSendNotification(ENTRY_CONNECTED) rc=0x%x",
                      retcode);

            LOCAL_FREE(pRasEvent);                      
        }                  
        
    }


    return( NO_ERROR );
}

//**
//
// Call:        IfObjectComputeReachableDelay
//
// Returns:     The delay
//
// Description: Computes the next reachability delay based on the 
//              current one. Following is the sequenced used:
//              
//                  min, 10, 20, 35, 50, 65, 90, 120, 120, 120, ...
//
//              The reachability delay is used to govern when to
//              re-attempt to connect an interface that in the 
//              past was unable to connect (presumably because of
//              an error on the other side).
//
//              In Win2k, the sequence was x0=min, xi = (xi-1 * 2)
//              This sequence was found to be problematic because
//              the increase was so steep that it was common in 
//              installations with many interfaces to find interfaces
//              that wouldn't be retried for days.
//
//              The new sequence is designed to max out at two hours.
//              If an interface is expected to be unreachable for more 
//              than two hours at a time, then a dialout hours restriction
//              should be used to achieve the desired effect.
//
DWORD
IfObjectComputeReachableDelay(
    IN ROUTER_INTERFACE_OBJECT * pIfObject)
{
    DWORD dwSeconds = 0;

    if (pIfObject->dwReachableAfterSeconds == 
        pIfObject->dwReachableAfterSecondsMin)
    {
        dwSeconds = 600;
    }

    switch (pIfObject->dwReachableAfterSeconds)
    {
        case 10*60:
            dwSeconds =  20*60;
            break;
            
        case 20*60:
            dwSeconds =  35*60;
            break;
        
        case 35*60:
            dwSeconds =  50*60;
            break;
        
        case 50*60:
            dwSeconds =  65*60;
            break;
        
        case 65*60:
            dwSeconds =  90*60;
            break;
        
        case 90*60:
        case 120*60:
            dwSeconds =  120*60;
            break;
    }

    return dwSeconds;
}

//**
//
// Call:        IfObjectNotifyOfReachabilityChange
//
// Returns:     None
//
// Description: Notifies the object of change in reachablity status.
//
//
VOID
IfObjectNotifyOfReachabilityChange(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN BOOL                      fReachable,
    IN UNREACHABILITY_REASON     dwReason
)
{
    DWORD   dwIndex;

    if ( pIfObject->IfType != ROUTER_IF_TYPE_FULL_ROUTER )
    {
        return;
    }

    if ( pIfObject->State != RISTATE_DISCONNECTED ) 
    {
        return;
    }
    
    switch( dwReason )
    {
    case INTERFACE_SERVICE_IS_PAUSED:

        //
        // Check if we are unreachable due to other reasons as well, if we
        // are, then no need to notify this object of (un)reachability.
        //

        if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
        {
            return;
        }

        if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
        {
            return;
        }

        break;

    case INTERFACE_CONNECTION_FAILURE:

        //
        // If we are marking this interface as not reachable due to connection
        // failure then we will mark as reachable after dwReachableAfterSeconds
        //

        if ( !fReachable )
        {
            //
            // Don't do this if the admin disconnected the interface
            //

            if ( !( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) )
            {
                DWORD dwDelay, dwTime, dwDelta, dwCur;

                dwCur = pIfObject->dwReachableAfterSeconds;
                dwDelay = IfObjectComputeReachableDelay(pIfObject);
                dwDelta = (dwDelay > dwCur) ? dwDelay - dwCur : 0;

                if (dwDelta != 0)
                {
                    dwTime = dwCur + (GetTickCount() % dwDelta);
                }
                else
                {
                    dwTime = dwCur;
                }

                DDMTRACE2( 
                    "Will mark interface %ws as reachable after %d seconds",
                    pIfObject->lpwsInterfaceName, dwTime );

                TimerQInsert(
                    pIfObject->hDIMInterface, 
                    dwTime, 
                    MarkInterfaceAsReachable);

                if (dwDelay < pIfObject->dwReachableAfterSecondsMax)
                {
                    pIfObject->dwReachableAfterSeconds = dwDelay;
                }
            }
        }
        else
        {
            //
            // Notify of reachability only if the interface is reachable
            //

            if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
            {
                return;
            }

            if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState 
                                                            == SERVICE_PAUSED )
            {
                return;
            }

            if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
            {
                return;
            }

            if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
            {
                return;
            }
        }

        break;

    case INTERFACE_DISABLED:

        if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
        {
            return;
        }

        if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
        {
            return;
        }

        if (  pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
        {
            return;
        }
        
        break;

    case INTERFACE_OUT_OF_RESOURCES:

        if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
        {
            return;
        }

        if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
        {
            return;
        }

        if (  pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION )
        {
            return;
        }

        break;

    case INTERFACE_DIALOUT_HOURS_RESTRICTION:
    
        if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
        {
            return;
        }

        if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
        {
            return;
        }

        if (  pIfObject->fFlags & IFFLAG_CONNECTION_FAILURE )
        {
            return;
        }

        if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
        {
            return;
        }

        break;
    
    default:
        
        RTASSERT( FALSE );

        break;
    }

    for ( dwIndex = 0; 
          dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwIndex++ )
    {
        if ( pIfObject->Transport[dwIndex].hInterface == INVALID_HANDLE_VALUE )
        {
            continue;
        }

        if ( fReachable )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "Notifying Protocol = 0x%x, Interface=%ws is Reachable",
                    gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId,
                    pIfObject->lpwsInterfaceName );

            gblRouterManagers[dwIndex].DdmRouterIf.InterfaceReachable(
                                    pIfObject->Transport[dwIndex].hInterface );

        }
        else
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "Notifying Protocol = 0x%x,Interface=%ws is UnReachable=%d",
               gblRouterManagers[dwIndex].DdmRouterIf.dwProtocolId,
               pIfObject->lpwsInterfaceName,
               dwReason );

            gblRouterManagers[dwIndex].DdmRouterIf.InterfaceNotReachable(
                                    pIfObject->Transport[dwIndex].hInterface,
                                    dwReason );
        }
    }

    if ( pIfObject->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
    {
        if ( fReachable )
        {
            DDMLogInformation(ROUTERLOG_IF_REACHABLE,1,&(pIfObject->lpwsInterfaceName));
        }
        else
        {
            LogUnreachabilityEvent( dwReason, pIfObject->lpwsInterfaceName );
        }
    }

    //
    // If this interface is reachable, and it is persistent and it has not
    // been disconnected by the administrator, then attempt to reconnect now
    //

    if ( ( pIfObject->fFlags & IFFLAG_PERSISTENT )  && 
         ( fReachable )                             &&
         ( !( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) ) )
    {
        TimerQInsert(pIfObject->hDIMInterface,1,ReConnectPersistentInterface);
    }
}

//**
//
// Call:        IfObjectNotifyAllOfReachabilityChange
//
// Returns:     None
//
// Description: Check to see if need to run through all the interfaces and 
//              notify the ones that are not un\reachable now.
//
//
VOID
IfObjectNotifyAllOfReachabilityChange(
    IN BOOL                      fReachable,
    IN UNREACHABILITY_REASON     dwReason
)
{
    DWORD                     dwBucketIndex;
    ROUTER_INTERFACE_OBJECT * pIfObject;
    DWORD                     fAvailableMedia;
    BOOL                      fNotify;

    if ( dwReason == INTERFACE_OUT_OF_RESOURCES )
    {
        //
        // No need to notify
        //

        if ( !gblMediaTable.fCheckInterfaces )
        {
            return;
        }

        gblMediaTable.fCheckInterfaces = FALSE;

        MediaObjGetAvailableMediaBits( &fAvailableMedia );
    }

    for ( dwBucketIndex = 0; dwBucketIndex < NUM_IF_BUCKETS; dwBucketIndex++ )
    {
        for( pIfObject = gblpInterfaceTable->IfBucket[dwBucketIndex];
             pIfObject != (ROUTER_INTERFACE_OBJECT *)NULL;
             pIfObject = pIfObject->pNext )
        {
            fNotify = TRUE;

            if ( dwReason == INTERFACE_OUT_OF_RESOURCES )
            {
                fNotify = FALSE;

                if ((pIfObject->fMediaUsed & fAvailableMedia) && fReachable )
                {
                    //
                    // If previously unreachable, mark as reachable
                    //

                    if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
                    {
                        pIfObject->fFlags &= ~IFFLAG_OUT_OF_RESOURCES;

                        fNotify = TRUE;
                    }
                }

                if ((!(pIfObject->fMediaUsed & fAvailableMedia)) && !fReachable)
                {
                    //
                    // If previously reachable and currently disconnected,
                    // mark as unreachable
                    //

                    if ( ( !( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES ) )
                         && ( pIfObject->State == RISTATE_DISCONNECTED ) )
                    {
                        pIfObject->fFlags |= IFFLAG_OUT_OF_RESOURCES;

                        fNotify = TRUE;
                    }
                }
            }

            if ( fNotify )
            {
                IfObjectNotifyOfReachabilityChange( pIfObject, 
                                                    fReachable,
                                                    dwReason );
            }
        }
    }
}

//**
//
// Call:        IfObjectAddClientInterface
//
// Returns:     None
//
// Description: Add this client interface with all the router managers.
//
//
DWORD
IfObjectAddClientInterface(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN PBYTE                     pClientStaticRoutes
)
{
    DWORD                   dwIndex;
    DIM_ROUTER_INTERFACE *  pDdmRouterIf;
    DWORD                   dwRetCode = NO_ERROR;

    for ( dwIndex = 0;
          dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwIndex++ )
    {
        pDdmRouterIf=&(gblRouterManagers[dwIndex].DdmRouterIf);

        if ( ( pDdmRouterIf->dwProtocolId == PID_IP ) &&
             ( pClientStaticRoutes != NULL ) )
        {
            dwRetCode = pDdmRouterIf->AddInterface(
                        pIfObject->lpwsInterfaceName,
                        pClientStaticRoutes,
                        pIfObject->IfType,
                        pIfObject->hDIMInterface,
                        &(pIfObject->Transport[dwIndex].hInterface));
        }
        else
        {
            dwRetCode = pDdmRouterIf->AddInterface( 
                        pIfObject->lpwsInterfaceName,
                        gblRouterManagers[dwIndex].pDefaultClientInterface,
                        pIfObject->IfType,
                        pIfObject->hDIMInterface,
                        &(pIfObject->Transport[dwIndex].hInterface));
        }

        if ( dwRetCode != NO_ERROR )
        {
            LPWSTR lpwsInsertStrings[2];
            
            lpwsInsertStrings[0] = pIfObject->lpwsInterfaceName;
            lpwsInsertStrings[1] = ( pDdmRouterIf->dwProtocolId == PID_IP )
                                    ? L"IP" : L"IPX";
            
            DDMLogErrorString( ROUTERLOG_COULDNT_ADD_INTERFACE, 2,  
                               lpwsInsertStrings, dwRetCode, 2 );

            pIfObject->Transport[dwIndex].hInterface = INVALID_HANDLE_VALUE;

            break;
        }
    }

    if ( dwRetCode != NO_ERROR )
    {
        //
        // Unload this interface for all the router managers that we loaded.
        //

        while ( dwIndex-- > 0 ) 
        {
            pDdmRouterIf=&(gblRouterManagers[dwIndex].DdmRouterIf);

            pDdmRouterIf->DeleteInterface( 
                                    pIfObject->Transport[dwIndex].hInterface );

            pIfObject->Transport[dwIndex].hInterface = INVALID_HANDLE_VALUE;
        }
    }

    return( dwRetCode );
}

//**
//
// Call:        IfObjectDeleteInterface
//
// Returns:     None
//
// Description: Delete this interface with all the router managers.
//
//
VOID
IfObjectDeleteInterface(
    ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    DWORD                   dwIndex;
    DIM_ROUTER_INTERFACE *  pDdmRouterIf;
    DWORD                   dwRetCode;

    for ( dwIndex = 0;
          dwIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwIndex++ )
    {
        if ( pIfObject->Transport[dwIndex].hInterface == INVALID_HANDLE_VALUE )
        {
            continue;
        }

        pDdmRouterIf=&(gblRouterManagers[dwIndex].DdmRouterIf);

        dwRetCode = pDdmRouterIf->DeleteInterface( 
                                    pIfObject->Transport[dwIndex].hInterface );

        if ( dwRetCode != NO_ERROR )
        {
            LPWSTR lpwsInsertStrings[2];

            lpwsInsertStrings[0] = pIfObject->lpwsInterfaceName;
            lpwsInsertStrings[1] = ( pDdmRouterIf->dwProtocolId == PID_IP )
                                    ? L"IP" : L"IPX";

            DDMLogErrorString( ROUTERLOG_COULDNT_REMOVE_INTERFACE, 2,
                               lpwsInsertStrings, dwRetCode, 2 );

        }
    }
}

//**
//
// Call:        IfObjectInsertInTable
//
// Returns:     None
//
// Description: Simply calls the DIM entrypoint to insert an interface object
//              into the interfaec table.
//
DWORD
IfObjectInsertInTable(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    return( ((DWORD(*)(ROUTER_INTERFACE_OBJECT *))
                    gblDDMConfigInfo.lpfnIfObjectInsertInTable)( pIfObject ) );
}

VOID
IfObjectSubEntryEnumHandler(PVOID pvContext, WCHAR *pszDeviceType)
{
    DDM_SUBENTRY_ENUMCONTEXT *pContext = 
                (DDM_SUBENTRY_ENUMCONTEXT *)pvContext;
    
    DWORD dwRetCode;
    
    if(NULL == pContext)
    {
        return;
    }

    dwRetCode = MediaObjSetMediaBit(pszDeviceType,
                                     &(pContext->pIfObject->fMediaUsed));

    if ( dwRetCode == NO_ERROR )
    {
        pContext->fAtLeastOneDeviceAvailable = TRUE;
    }
    
}

VOID
IfObjectFreePhonebookContext(IN VOID *pvContext)
{
    DDMFreePhonebookContext(pvContext);
}


//**
//
// Call:        IfObjectLoadPhonebookInfo
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will read the phonebook entry for this interface and set
//              bits for a device type used and all other phonebook information
//              used.
//
DWORD
IfObjectLoadPhonebookInfo(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN OUT PVOID *ppvContext
)
{
    LPRASENTRY          pRasEntry       = NULL;
    LPRASSUBENTRY       pRasSubEntry    = NULL;
    DWORD               dwRetCode       = NO_ERROR;
    DWORD               dwIndex;
    DWORD               dwSize;
    DWORD               dwDummy;
    BOOL                fRedialOnLinkFailure;
    BOOL                fAtLeastOneDeviceAvailable = FALSE;
    DWORD               dwDialMode = RASEDM_DialAll;
    VOID *              pvSubEntryHandlerContext = NULL;
    VOID *              pvSubEntryHandler = NULL;
    DDM_SUBENTRY_ENUMCONTEXT EnumContext;

    EnumContext.pIfObject = pIfObject;
    EnumContext.fAtLeastOneDeviceAvailable = FALSE;
    pvSubEntryHandlerContext = &EnumContext;
    pvSubEntryHandler = (VOID *)IfObjectSubEntryEnumHandler;

    dwRetCode = DDMGetPhonebookInfo(    
                                gblpRouterPhoneBook,
                                pIfObject->lpwsInterfaceName,
                                &(pIfObject->dwNumSubEntries),
                                &(pIfObject->dwNumOfReConnectAttempts),
                                &(pIfObject->dwSecondsBetweenReConnectAttempts),
                                &fRedialOnLinkFailure, 
                                pIfObject->PppInterfaceInfo.szzParameters,
                                &dwDialMode,
                                ppvContext,
                                pvSubEntryHandler,
                                pvSubEntryHandlerContext
                                );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    if ( fRedialOnLinkFailure )
    {
        pIfObject->fFlags |= IFFLAG_PERSISTENT;
    }
    else
    {
        pIfObject->fFlags &= ~IFFLAG_PERSISTENT;
    }

    if( RASEDM_DialAsNeeded == dwDialMode)
    {
        pIfObject->fFlags |= IFFLAG_DIALMODE_DIALASNEEDED;
    }
    else
    {
        pIfObject->fFlags &= ~(IFFLAG_DIALMODE_DIALASNEEDED);
    }

    if( RASEDM_DialAll == dwDialMode )
    {
        pIfObject->fFlags |= IFFLAG_DIALMODE_DIALALL;
    }
    else
    {
        pIfObject->fFlags &= ~(IFFLAG_DIALMODE_DIALALL);
    }


    fAtLeastOneDeviceAvailable =
                EnumContext.fAtLeastOneDeviceAvailable;        

#if 0    
    else
    {
        //
        // Iterate through all the subentries - fall back to the
        // slow algorithm - we don't have the context
        //

        for( dwIndex = 1; dwIndex <= pIfObject->dwNumSubEntries; dwIndex++ )
        {
            //
            // Get the device type
            //

            dwSize = 0;

            dwRetCode = RasGetSubEntryProperties(   
                                            gblpRouterPhoneBook,
                                            pIfObject->lpwsInterfaceName,
                                            dwIndex,
                                            NULL,
                                            &dwSize,
                                            (LPBYTE)&dwDummy,
                                            &dwDummy );

            if ( dwRetCode != ERROR_BUFFER_TOO_SMALL )
            {
                return ( dwRetCode );
            }

            pRasSubEntry = LOCAL_ALLOC( LPTR, dwSize );
            if ( pRasSubEntry == NULL ) 
            {
                return ( GetLastError() );
            }

            ZeroMemory( pRasSubEntry, dwSize );
            pRasSubEntry->dwSize = sizeof( RASSUBENTRY );

            dwRetCode = RasGetSubEntryProperties(   
                                            gblpRouterPhoneBook,
                                            pIfObject->lpwsInterfaceName,
                                            dwIndex,
                                            pRasSubEntry,
                                            &dwSize,
                                            (LPBYTE)&dwDummy,
                                            &dwDummy );

            if ( dwRetCode != NO_ERROR )
            {
                LOCAL_FREE( pRasSubEntry );
                return( dwRetCode );
            }

            //
            // Set the bit for this media
            //

            dwRetCode = MediaObjSetMediaBit( pRasSubEntry->szDeviceType,
                                             &(pIfObject->fMediaUsed) );

            LOCAL_FREE( pRasSubEntry );

            if ( dwRetCode == NO_ERROR )
            {
                fAtLeastOneDeviceAvailable = TRUE;
            }
        }
    }
#endif    

    if ( !fAtLeastOneDeviceAvailable )
    {
        return( ERROR_INTERFACE_HAS_NO_DEVICES );
    }

    return( NO_ERROR );
}

//**
//
// Call:        IfObjectInitiatePersistentConnections
//
// Returns:     None
//
// Description: Will initiate connections for all demand dial interfaces that 
//              are marked as persistent
//
VOID
IfObjectInitiatePersistentConnections(
    VOID
)
{
    DWORD                       dwBucketIndex;
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwRetCode;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    for ( dwBucketIndex = 0; dwBucketIndex < NUM_IF_BUCKETS; dwBucketIndex++ )
    {
        for( pIfObject = gblpInterfaceTable->IfBucket[dwBucketIndex];
             pIfObject != (ROUTER_INTERFACE_OBJECT *)NULL;
             pIfObject = pIfObject->pNext )
        {
        
            if ( pIfObject->IfType == ROUTER_IF_TYPE_FULL_ROUTER )
            {
                if ( pIfObject->fFlags & IFFLAG_PERSISTENT )
                {
                    dwRetCode = RasConnectionInitiate( pIfObject, FALSE );

                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	                    "Initiated persistent connection to %ws,dwRetCode=%d\n",
                        pIfObject->lpwsInterfaceName, dwRetCode );

                    if ( dwRetCode != NO_ERROR )
                    {
                        LPWSTR  lpwsAudit[1];

		                lpwsAudit[0] = pIfObject->lpwsInterfaceName;

		                DDMLogErrorString( 
                                       ROUTERLOG_PERSISTENT_CONNECTION_FAILURE, 
                                       1, lpwsAudit, dwRetCode, 1 );
                    }
                }
                else
                {
                    //
                    // Otherwise set dialout hours restrictions, if any
                    //

                    IfObjectSetDialoutHoursRestriction( pIfObject );
                }
            }
        }
    }

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
}

//**
//
// Call:        IfObjectDisconnectInterfaces
//
// Returns:     None
//
// Description: Will disconnect all interfaces that are connected or in the 
//              process of connecting.
//
VOID
IfObjectDisconnectInterfaces(
    VOID
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwBucketIndex;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    for ( dwBucketIndex = 0; dwBucketIndex < NUM_IF_BUCKETS; dwBucketIndex++ )
    {
        for( pIfObject = gblpInterfaceTable->IfBucket[dwBucketIndex];
             pIfObject != (ROUTER_INTERFACE_OBJECT *)NULL;
             pIfObject = pIfObject->pNext )
        {
            if ( ( pIfObject->State != RISTATE_DISCONNECTED ) &&
                 ( pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED ) )
            {
                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "IfObjectDisconnectInterfaces: hanging up 0x%x",
                        pIfObject->hRasConn);
                RasHangUp( pIfObject->hRasConn );
            }
        }
    }

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
}

//**
//
// Call:        IfObjectConnectionChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
IfObjectConnectionChangeNotification(
    VOID
)
{
    NOTIFICATION_EVENT * pNotificationEvent;

    for( pNotificationEvent = (NOTIFICATION_EVENT *)
                            (gblDDMConfigInfo.NotificationEventListHead.Flink);
         pNotificationEvent != (NOTIFICATION_EVENT *)
                            &(gblDDMConfigInfo.NotificationEventListHead);
         pNotificationEvent = (NOTIFICATION_EVENT *)
                            (pNotificationEvent->ListEntry.Flink) )
    {
        SetEvent( pNotificationEvent->hEventRouter );
    }
}

//**
//
// Call:        IfObjectSetDialoutHoursRestriction
//
// Returns:     NONE
//
// Description: Called from ifapi.c from DIM to initiate dialout hours 
//              restriction for this interface.
//
VOID
IfObjectSetDialoutHoursRestriction(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
)
{
    TimerQRemove( pIfObject->hDIMInterface, SetDialoutHoursRestriction );

    SetDialoutHoursRestriction( pIfObject->hDIMInterface );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\mediaobj.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    mediaobj.c
//
// Description: 
//
// History:     May 11,1995	    NarenG		Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include "ddm.h"
#include "objects.h"
#include <raserror.h>
#include "rasmanif.h"
#include <stdlib.h>

//**
//
// Call:        MediaObjInitializeTable
//
// Returns:     NO_ERROR - success
//              else     - failure
//
// Description: Allocates and initializes the media table
//
DWORD
MediaObjInitializeTable(
    VOID
)
{
    gblMediaTable.cMediaListSize = 5;

    gblMediaTable.pMediaList = (MEDIA_OBJECT *)LOCAL_ALLOC( 
                                                LPTR,
                                                gblMediaTable.cMediaListSize
                                                * sizeof( MEDIA_OBJECT ));

    if ( gblMediaTable.pMediaList == (MEDIA_OBJECT *)NULL )
    {
        return( GetLastError() );
    }

    return( NO_ERROR );
}

//**
//
// Call:        MediaObjAddToTable
//
// Returns:     NO_ERROR - success
//              ERROR_NOT_ENOUGH_MEMORY - Failure
//
// Description: Will increment the number of available resources for the
//              specified media.
//
DWORD
MediaObjAddToTable(
    IN LPWSTR   lpwsMedia
)
{
    DWORD           dwIndex;
    MEDIA_OBJECT *  pFreeEntry = NULL;

    //
    // Iterate through the media table
    //

    EnterCriticalSection( &(gblMediaTable.CriticalSection) );

    for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
    {
        if ( _wcsicmp( gblMediaTable.pMediaList[dwIndex].wchMediaName,    
                      lpwsMedia ) == 0 )
        {
            //
            // If there was no device available and there is now we need to
            // notify the interfaces.
            //

            if ( gblMediaTable.pMediaList[dwIndex].dwNumAvailable == 0 )
            {
                gblMediaTable.fCheckInterfaces = TRUE;
            }

            gblMediaTable.pMediaList[dwIndex].dwNumAvailable++;

            DDMTRACE1( "Added instance of %ws media to media table",
                        lpwsMedia );

            LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

            return( NO_ERROR );
        }
        else if ( gblMediaTable.pMediaList[dwIndex].wchMediaName[0]==(WCHAR)0 ) 
        {
            if ( pFreeEntry == (MEDIA_OBJECT *)NULL )
            {
                pFreeEntry = &(gblMediaTable.pMediaList[dwIndex]);
            }
        }
    }

    //
    // If we couldn't find this media in the table we need to add it to the 
    // table. Check if there is space for it
    //

    if ( dwIndex == gblMediaTable.cMediaListSize )
    {
        if ( pFreeEntry == (MEDIA_OBJECT *)NULL )
        {
            PVOID pTemp;

            //  
            // We need to expand the table
            //

            gblMediaTable.cMediaListSize += 5;

            pTemp = LOCAL_REALLOC( gblMediaTable.pMediaList,
                                   gblMediaTable.cMediaListSize 
                                   * sizeof( MEDIA_OBJECT ) );

            if ( pTemp == NULL )
            {
                LOCAL_FREE( gblMediaTable.pMediaList );

                gblMediaTable.pMediaList = NULL;

                LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

                return( GetLastError() );
            }
            else
            {
                gblMediaTable.pMediaList = pTemp;
            }

            pFreeEntry = 
                    &(gblMediaTable.pMediaList[gblMediaTable.cMediaListSize-5]);
        }
    }

    //
    // Add the new media
    //

    wcscpy( pFreeEntry->wchMediaName, lpwsMedia );

    pFreeEntry->dwNumAvailable++;

    gblMediaTable.fCheckInterfaces = TRUE;

    DDMTRACE1( "Added %ws to available media table", lpwsMedia );

    LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        MediaObjRemoveFromTable
//
// Returns:     None
//
// Description: Will decrement the number of avaialble resources of this 
//              media type.
//
VOID
MediaObjRemoveFromTable(
    IN LPWSTR lpwsMedia
)
{
    DWORD dwIndex;

    EnterCriticalSection( &(gblMediaTable.CriticalSection) );

    //
    // Iterate through the media table
    //

    for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
    {
        if ( _wcsicmp( gblMediaTable.pMediaList[dwIndex].wchMediaName,
                      lpwsMedia ) == 0 )
        {
            //
            // If there was device available and there are none now we need to
            // notify the interfaces.
            //

            if ( gblMediaTable.pMediaList[dwIndex].dwNumAvailable > 0 )
            {
                gblMediaTable.pMediaList[dwIndex].dwNumAvailable--;

                DDMTRACE1( "Removed instance of %ws media from media table",
                           lpwsMedia );

                if ( gblMediaTable.pMediaList[dwIndex].dwNumAvailable == 0 )
                {
                    gblMediaTable.fCheckInterfaces = TRUE;

                    DDMTRACE1( "Removed %ws from available media table", 
                               lpwsMedia );
                }
            }
        }
    }

    LeaveCriticalSection( &(gblMediaTable.CriticalSection) );
}

//**
//
// Call:        MediaObjGetAvailableMediaBits
//
// Returns:     None
//
// Description: Will retrieve a DWORD of bits, each of which represent a 
//              media od which resources are still available.
//
VOID
MediaObjGetAvailableMediaBits(
    DWORD * pfAvailableMedia
)
{
    DWORD   dwIndex;

    *pfAvailableMedia = 0;

    EnterCriticalSection( &(gblMediaTable.CriticalSection) );

    //
    // Iterate through the media table
    //

    if (gblMediaTable.pMediaList != NULL)
    {
        for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
        {
            if ( gblMediaTable.pMediaList[dwIndex].wchMediaName[0] != (WCHAR)0 )
            {
                if ( gblMediaTable.pMediaList[dwIndex].dwNumAvailable > 0 )
                {
                    *pfAvailableMedia |= ( 1 << dwIndex );
                }
            }
        }
    }
    
    LeaveCriticalSection( &(gblMediaTable.CriticalSection) );
}

//**
//
// Call:        MediaObjSetMediaBit
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Sets the appropriate bit for the given media
//
DWORD
MediaObjSetMediaBit(
    IN LPWSTR  lpwsMedia,
    IN DWORD * pfMedia
)
{
    DWORD   dwIndex;
    DWORD   dwRetCode = NO_ERROR;

    //
    // Iterate through the media table
    //

    EnterCriticalSection( &(gblMediaTable.CriticalSection) );

    for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
    {
        if ( _wcsicmp( gblMediaTable.pMediaList[dwIndex].wchMediaName, lpwsMedia ) == 0 )
        {
            *pfMedia |= ( 1 << dwIndex );

            LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

            return( NO_ERROR );
        }
    }

    //
    // If we get here that means that we do not have this media in the table so add it
    //

    MediaObjAddToTable( lpwsMedia );

    //
    // Now set the correct bit.
    //

    for ( dwIndex = 0; dwIndex < gblMediaTable.cMediaListSize; dwIndex++ )
    {
        if ( _wcsicmp( gblMediaTable.pMediaList[dwIndex].wchMediaName, lpwsMedia ) == 0 )
        {
            *pfMedia |= ( 1 << dwIndex );

            LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

            //
            // Let the caller know that there is no such device
            //

            return( ERROR_DEVICETYPE_DOES_NOT_EXIST );
        }
    }

    LeaveCriticalSection( &(gblMediaTable.CriticalSection) );

    return( ERROR_DEVICETYPE_DOES_NOT_EXIST );
}

//**
//
// Call:        MediaObjFreeTable
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Cleans up the media object table
//
VOID
MediaObjFreeTable(
    VOID
)
{
    DeleteCriticalSection( &(gblMediaTable.CriticalSection) );

    if ( gblMediaTable.pMediaList != NULL ) 
    {
        LOCAL_FREE( gblMediaTable.pMediaList );

        gblMediaTable.pMediaList = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\rasapihd.c ===
/*********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.          **/
/*********************************************************************/

//***
//
// Filename:    rasapihd.c
//
// Description: Handler for RASAPI32 disconnect events
//
// History:     May 11,1996     NarenG      Created original version.
//
#include "ddm.h"
#include "objects.h"
#include "handlers.h"

//**
//
// Call:        RasApiCleanUpPort
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will cleanup a locally initiated disconnected port.
//
VOID
RasApiCleanUpPort( 
    IN PDEVICE_OBJECT      pDeviceObj
)
{
    PCONNECTION_OBJECT  pConnObj = NULL;

    //
    // If already cleaned up, then simply return
    //

    if (  pDeviceObj->hRasConn == NULL )
    {
        return;
    }

    pConnObj = ConnObjGetPointer(pDeviceObj->hConnection);

    if( (NULL != pConnObj) &&
        (0 == (pConnObj->fFlags & CONN_OBJ_DISCONNECT_INITIATED)))
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
            "RasApiCleanUpPort: hanging up 0x%x",
                pDeviceObj->hRasConn);
                
        RasHangUp( pDeviceObj->hRasConn );
    }

    ConnObjRemoveLink( pDeviceObj->hConnection, pDeviceObj );

    DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	"RasApiDisconnectHandler:Cleaning up locally initiated connection hPort=%d",
    pDeviceObj->hPort );

    //
    // Was this the last link in the connection
    //

    if ( ( pConnObj != NULL ) && ( pConnObj->cActiveDevices == 0 ) )
    {
        if ( pConnObj->hDIMInterface != INVALID_HANDLE_VALUE )
        {
            ROUTER_INTERFACE_OBJECT * pIfObject;

            EnterCriticalSection( &(gblpInterfaceTable->CriticalSection));

            pIfObject = IfObjectGetPointer( pConnObj->hDIMInterface );

            if ( pIfObject != NULL )
            {
                IfObjectDisconnected( pIfObject );
            }

            LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection));
        }

        //
        // Remove the Connection Object
        //

        ConnObjRemoveAndDeAllocate( pDeviceObj->hConnection );
    }

    //
    // Increase media for this port if we were previously connected.
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE )
    {
        pDeviceObj->fFlags &= ~DEV_OBJ_MARKED_AS_INUSE;

        gblDeviceTable.NumDevicesInUse--;

        //
        // Increase media count for this device
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
        {
            MediaObjAddToTable( pDeviceObj->wchDeviceType );
        }

        //
        // Possibly need to notify router managers of reachability 
        // change
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange(TRUE,INTERFACE_OUT_OF_RESOURCES);

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    }

    pDeviceObj->fFlags                  &= ~DEV_OBJ_OPENED_FOR_DIALOUT;
    pDeviceObj->hConnection             = (HCONN)INVALID_HANDLE_VALUE; 
    pDeviceObj->wchUserName[0]          = (WCHAR)NULL;
    pDeviceObj->wchDomainName[0]        = (WCHAR)NULL;
    pDeviceObj->wchCallbackNumber[0]    = (WCHAR)NULL;
    pDeviceObj->hRasConn                = NULL;

    //
    // If the service was paused while we were dialed out
    //

    if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
    {
        DeviceObjCloseListening( pDeviceObj, NULL, 0, 0 );
    }

    RasSetRouterUsage( pDeviceObj->hPort, FALSE );

    //
    // If we have gotten a PnP remove message, then discard this port
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_PNP_DELETE )
    {
        //
        // We do this in a worker thread since this thread may be
        // walking the device list, hence we cannot modify it here.
        //

        RtlQueueWorkItem( DeviceObjRemoveFromTable,
                          pDeviceObj->hPort,
                          WT_EXECUTEDEFAULT );
    }
}

//**
//
// Call:        RasApiDisconnectHandler
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Handles a disconnect notification for a port on which a 
//              dialout was initiated by the router. We made this a separate
//              handler with a separate event because otherwise we would have 
//              problems with race conditions between rasman setting this event
//              and rasapi32 setting this event.
//
VOID
RasApiDisconnectHandler( 
    IN DWORD dwEventIndex
)
{
    PDEVICE_OBJECT      pDeviceObj;
    DWORD               dwRetCode = NO_ERROR;
    RASCONNSTATUS       RasConnectionStatus;
    DWORD               dwBucketIndex = dwEventIndex 
                                        - NUM_DDM_EVENTS 
                                        - (gblDeviceTable.NumDeviceBuckets*2);

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	            "RasApiDisconnectHandler: Entered");

    for ( pDeviceObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
          pDeviceObj != (DEVICE_OBJECT *)NULL;
          pDeviceObj = pDeviceObj->pNext )
    {
        //
        // If locally initiated, then this event means that the port is now
        // disconnected
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
        {
            ZeroMemory( &RasConnectionStatus, sizeof( RasConnectionStatus ) );

            RasConnectionStatus.dwSize = sizeof( RasConnectionStatus );

            dwRetCode = RasGetConnectStatus( pDeviceObj->hRasConn, &RasConnectionStatus );

            if ( ( dwRetCode != NO_ERROR ) || 
                 ( ( dwRetCode == NO_ERROR ) && 
                   ( RasConnectionStatus.rasconnstate == RASCS_Disconnected ) ) )
            {
                RasApiCleanUpPort( pDeviceObj );
            }
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\handlers.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    handlers.h
//
// Description: Funtion and procedure prototypes for all event handlers
//
// History:     May 11,1995	    NarenG		Created original version.
//


VOID
SecurityDllEventHandler(
    VOID
);

//
// rmhand.c function prototypes
//

VOID
RmRecvFrameEventHandler(
    DWORD dwEventIndex
);

VOID
RmEventHandler(
    IN DWORD dwEventIndex
);

VOID
SvDevDisconnected(
    IN PDEVICE_OBJECT pDeviceObj
);

//
// timehand.c function prototypes
//

VOID
TimerHandler(
    VOID
);

VOID
SvHwErrDelayCompleted(
    IN HANDLE   hObject
);

VOID
AnnouncePresenceHandler(
    IN HANDLE   hObject
);

VOID
SvCbDelayCompleted(
    IN HANDLE   hObject
);

VOID
SvAuthTimeout(
    IN HANDLE   hObject
);

VOID
SvDiscTimeout(
    IN HANDLE   hObject
);

VOID
SvSecurityTimeout(
    IN HANDLE   hObject
);

VOID
ReConnectInterface(
    IN HANDLE hObject
);

VOID
MarkInterfaceAsReachable(
    IN HANDLE hObject
);

VOID
ReConnectPersistentInterface(
    IN HANDLE hObject
);

VOID
SetDialoutHoursRestriction(
    IN HANDLE hObject
);

//
// ppphand.c function prototypes
//

VOID
PppEventHandler(
    VOID
);

//
// closehand.c function prototypes
//


VOID
DevStartClosing(
    IN PDEVICE_OBJECT       pDeviceObj
);

VOID
DevCloseComplete(
    IN PDEVICE_OBJECT       pDeviceObj
);

//
// svchand.c function prototypes
//

VOID
SvcEventHandler(
    VOID
);

VOID
DDMServicePause(
    VOID
);

VOID
DDMServiceResume(
    VOID
);

VOID
DDMServiceStopComplete(
    VOID
);

VOID
DDMServiceTerminate(
    VOID
);

//
// rasapihd.c
//

VOID
RasApiDisconnectHandler(
    IN DWORD                dwEventIndex
);

VOID
RasApiCleanUpPort(
    IN PDEVICE_OBJECT       pDeviceObj
);

//
// pnphand.c
//

DWORD
DdmDevicePnpHandler(
    IN HANDLE            ppnpEvent
);

VOID
ChangeNotificationEventHandler(
    VOID
);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\pnphand.c ===
/********************************************************************/
/**          Copyright(c) 1985-1997 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    pnphand.c
//
// Description: Will receive and handle pnp notifications to add/remove devices
//
// History:     May 11,1997	    NarenG		Created original version.
//
#include "ddm.h"
#include "timer.h"
#include "handlers.h"
#include "objects.h"
#include "util.h"
#include "routerif.h"
#include <raserror.h>
#include <rassrvr.h>
#include <rasppp.h>
#include <ddmif.h>
#include <serial.h>
#include <string.h>
#include <stdlib.h>
#include <memory.h>

//**
//
// Call:        DdmDevicePnpHandler
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will handle and act upon a device addition or removal.
//
DWORD
DdmDevicePnpHandler(
    HANDLE pdwArg
)
{
    PNP_EVENT_NOTIF * ppnpEvent = ( PPNP_EVENT_NOTIF )pdwArg;
    PPP_MESSAGE       PppMessage;

    ZeroMemory( &PppMessage, sizeof( PppMessage ) );
    
    PppMessage.dwMsgId = PPPDDMMSG_PnPNotification;

    PppMessage.ExtraInfo.DdmPnPNotification.PnPNotification = *ppnpEvent;

    SendPppMessageToDDM( &PppMessage );

    LocalFree( ppnpEvent );

    return( NO_ERROR );
}

//**
//
// Call:        ChangeNotificationEventHandler
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
ChangeNotificationEventHandler(
    VOID
)
{
    DWORD   dwRetCode;
    BOOL    fIpAllowed      = FALSE;

    DDMTRACE( "ChangeNotificationEventHandler called" );

    dwRetCode = LoadDDMParameters( gblDDMConfigInfo.hkeyParameters,
                                   &fIpAllowed ); 

    DeviceObjIterator( DeviceObjForceIpSec, FALSE, NULL );

    if ( fIpAllowed && ( !gblDDMConfigInfo.fRasSrvrInitialized ) )
    {
        DWORD i;
        BOOL bCalled = FALSE;
        
        for (i=0;  i<gblDDMConfigInfo.NumAdminDlls;  i++)
        {
            PADMIN_DLL_CALLBACKS AdminDllCallbacks = &gblDDMConfigInfo.AdminDllCallbacks[i];
            if (AdminDllCallbacks[i].lpfnMprAdminGetIpAddressForUser!=NULL)
            {
                dwRetCode = RasSrvrInitialize(
                            AdminDllCallbacks[i].lpfnMprAdminGetIpAddressForUser,
                            AdminDllCallbacks[i].lpfnMprAdminReleaseIpAddress );

                bCalled = TRUE;
                break;
            }
        }
        if (!bCalled)
        {
            dwRetCode = RasSrvrInitialize(NULL, NULL);
        }
        
        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString( ROUTERLOG_CANT_INITIALIZE_IP_SERVER,
                               0, NULL, dwRetCode, 0 );
        }
        else
        {
            gblDDMConfigInfo.fRasSrvrInitialized = TRUE;
        }
    }

    if ( NULL != gblDDMConfigInfo.lpfnRasAuthConfigChangeNotification )
    {
        gblDDMConfigInfo.lpfnRasAuthConfigChangeNotification( 
            gblDDMConfigInfo.dwLoggingLevel );
    }

    if ( NULL != gblDDMConfigInfo.lpfnRasAcctConfigChangeNotification )
    {
        gblDDMConfigInfo.lpfnRasAcctConfigChangeNotification( 
            gblDDMConfigInfo.dwLoggingLevel );
    }

    PppDdmChangeNotification( gblDDMConfigInfo.dwServerFlags,
                              gblDDMConfigInfo.dwLoggingLevel );

    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyParameters,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION],
                             TRUE );
    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyAccounting,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION1],
                             TRUE );

    RegNotifyChangeKeyValue( gblDDMConfigInfo.hkeyAuthentication,
                             TRUE,
                             REG_NOTIFY_CHANGE_LAST_SET,
                             gblSupervisorEvents[DDM_EVENT_CHANGE_NOTIFICATION2],
                             TRUE );
}

//**
//
// Call:        DDMTransportCreate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
DDMTransportCreate(
    IN DWORD dwTransportId
)
{
    static const TCHAR c_szRegKeyRemoteAccessParams[] 
            = TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters");
    DWORD   dwRetCode   = NO_ERROR;
    BOOL    fEnabled    = FALSE;
    HKEY    hKey        = NULL;

    DDMTRACE1( "DDMTransportCreate called for Transport Id = %d", dwTransportId );

    //
    // Find out if this transport is set to allow for dialin clients
    //

    dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE, c_szRegKeyRemoteAccessParams, &hKey );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    dwRetCode = lProtocolEnabled( hKey, dwTransportId, TRUE, FALSE, &fEnabled );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    RegCloseKey( hKey );

    //
    // Not enabled for dialin so we are done
    //

    if ( !fEnabled )
    {
        return( NO_ERROR );
    }

    if ( ( dwTransportId == PID_IP ) && ( !gblDDMConfigInfo.fRasSrvrInitialized ) )
    {
        DWORD i;
        BOOL bCalled = FALSE;
        
        for (i=0;  i<gblDDMConfigInfo.NumAdminDlls;  i++)
        {
            PADMIN_DLL_CALLBACKS AdminDllCallbacks = &gblDDMConfigInfo.AdminDllCallbacks[i];
            if (AdminDllCallbacks[i].lpfnMprAdminGetIpAddressForUser!=NULL)
            {
                dwRetCode = RasSrvrInitialize(
                            AdminDllCallbacks[i].lpfnMprAdminGetIpAddressForUser,
                            AdminDllCallbacks[i].lpfnMprAdminReleaseIpAddress );

                bCalled = TRUE;
                break;
            }
        }
        if (!bCalled)
        {
            dwRetCode = RasSrvrInitialize(NULL, NULL);
        }

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString( ROUTERLOG_CANT_INITIALIZE_IP_SERVER,
                               0, NULL, dwRetCode, 0 );
        }
        else
        {
            gblDDMConfigInfo.fRasSrvrInitialized = TRUE;
        }
    }

    //
    // Insert allowed protocols in the ServerFlags which will be sent to PPP engine
    //

    switch( dwTransportId )
    {
    case PID_IP:
        gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectIp;
        break;

    case PID_IPX:
        gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectIpx;
        break;

    case PID_ATALK:
        gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectAt;
        break;

    default:
        break;
    }

    PppDdmChangeNotification( gblDDMConfigInfo.dwServerFlags,
                              gblDDMConfigInfo.dwLoggingLevel );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\rasapiif.c ===
/*********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	        **/
/*********************************************************************/

//***
//
// Filename:    rasapiif.c
//
// Description: Handles all the RASAPI32 calls
//
// History:     May 11,1996     NarenG      Created original version.
//
#include "ddm.h"
#include "util.h"
#include "objects.h"
#include "rasmanif.h"
#include "rasapiif.h"
#include "handlers.h"
#include "timer.h"
#include <time.h>
#include <mprapi.h>
#include <mprapip.h>

HPORT
RasGetHport( 
    IN HRASCONN hRasConnSubEntry 
);

DWORD
RasPortConnected( 
    IN HRASCONN         hRasConn,
    IN HRASCONN         hRasConnSubEntry,
    IN DEVICE_OBJECT *  pDevObj,
    IN HANDLE           hDIMInterface
)
{
    CONNECTION_OBJECT *         pConnObj;
    DWORD                       dwRetCode;
    ROUTER_INTERFACE_OBJECT *   pIfObject;

    //
    // Set this port to be notified by rasapi32 on disconnect.
    //

    dwRetCode = RasConnectionNotification( 
                                hRasConnSubEntry,
                                gblSupervisorEvents[NUM_DDM_EVENTS
                                   + (gblDeviceTable.NumDeviceBuckets*2)
                                   + DeviceObjHashPortToBucket(pDevObj->hPort)],
                                RASCN_Disconnection );

    if ( dwRetCode != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasConnectionNotification returned %d", dwRetCode );

        return( dwRetCode );
    }

    //
    // Get handle to the connection or bundle for this link
    //

    dwRetCode = RasPortGetBundle(NULL, pDevObj->hPort, &(pDevObj->hConnection));

    if ( dwRetCode != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortGetBundle returned %d", dwRetCode );

        return( dwRetCode );
    }

    do 
    {
        pIfObject = IfObjectGetPointer( hDIMInterface );

        if ( pIfObject == NULL )
        {
            RTASSERT( FALSE );
            dwRetCode = ERROR_NO_SUCH_INTERFACE;
            break;
        }
    
        //
        // If this interface was disconnected by DDMDisconnectInterface,
        // then do not let this device through.
        //

        if ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED )
        {
            dwRetCode = ERROR_PORT_DISCONNECTED;

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "RasPortConnected: Admin disconnected port" );
            break;
        }

        //
        // Allocate a connection object if it does not exist yet
        //

        pConnObj = ConnObjGetPointer( pDevObj->hConnection );

        if ( pConnObj == (CONNECTION_OBJECT *)NULL )
        {
            RASPPPIP    RasPppIp;
            RASPPPIPX   RasPppIpx;
            DWORD       dwSize;

            pConnObj = ConnObjAllocateAndInit(  hDIMInterface,
                                                pDevObj->hConnection );

            if ( pConnObj == (CONNECTION_OBJECT *)NULL )
            {
                dwRetCode = GetLastError();
                break;
            }   

            ConnObjInsertInTable( pConnObj );

            //
            // First get the projection info, make sure IP or IPX
            // were negotiated
            //

            dwSize              = sizeof( RasPppIpx );
            RasPppIpx.dwSize    = sizeof( RasPppIpx );

            dwRetCode = RasGetProjectionInfo( 
                                          hRasConn,
                                          RASP_PppIpx,
                                          &RasPppIpx,
                                          &dwSize );
            if ( dwRetCode != NO_ERROR )
            {
                pConnObj->PppProjectionResult.ipx.dwError = dwRetCode; 
            }
            else
            {
                pConnObj->PppProjectionResult.ipx.dwError = RasPppIpx.dwError; 

                ConvertStringToIpxAddress( 
                            RasPppIpx.szIpxAddress,
                            pConnObj->PppProjectionResult.ipx.bLocalAddress);

            }

            dwSize          = sizeof( RasPppIp );
            RasPppIp.dwSize = sizeof( RasPppIp );

            dwRetCode = RasGetProjectionInfo( 
                                            hRasConn,
                                            RASP_PppIp,
                                            &RasPppIp,
                                            &dwSize );
            if ( dwRetCode != NO_ERROR )
            {
                pConnObj->PppProjectionResult.ip.dwError =  dwRetCode;
            }
            else
            {
                pConnObj->PppProjectionResult.ip.dwError = RasPppIp.dwError; 

                ConvertStringToIpAddress( 
                            RasPppIp.szIpAddress,
                            &(pConnObj->PppProjectionResult.ip.dwLocalAddress));

                ConvertStringToIpAddress( 
                           RasPppIp.szServerIpAddress,
                           &(pConnObj->PppProjectionResult.ip.dwRemoteAddress));
            }

            if ((pConnObj->PppProjectionResult.ipx.dwError!=NO_ERROR )
                &&
                (pConnObj->PppProjectionResult.ip.dwError!=NO_ERROR ))
            {
                dwRetCode = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
                break;
            }

            pConnObj->fFlags    = CONN_OBJ_IS_PPP;
            pConnObj->hPort     = pDevObj->hPort;
        }
        else
        {
            //
            // Make sure that we are adding a link to a connection for the
            // same interface that initiated the connection.
            //
    
            if ( hDIMInterface != pConnObj->hDIMInterface )
            {
                dwRetCode = ERROR_INTERFACE_CONFIGURATION;

                break;
            }
        }

        pDevObj->hRasConn       = hRasConnSubEntry;
        GetSystemTimeAsFileTime( (FILETIME*)&(pDevObj->qwActiveTime) );

        //
        // Add this link to the connection block.
        //

        if ((dwRetCode = ConnObjAddLink(pConnObj, pDevObj)) != NO_ERROR)
        {
            break;
        }

        //
        // Notify router managers that we are connected if we have 
        // not done so already.
        //

        if ( !( pConnObj->fFlags & CONN_OBJ_PROJECTIONS_NOTIFIED ) )
        {
            RASDIALPARAMS   RasDialParams;
            BOOL            fPassword;

            dwRetCode = IfObjectConnected( 
                                        hDIMInterface, 
                                        (HCONN)pDevObj->hConnection,
                                        &(pConnObj->PppProjectionResult) );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            pConnObj->fFlags |= CONN_OBJ_PROJECTIONS_NOTIFIED;

            //
            // Get username and domain name
            //

            ZeroMemory( &RasDialParams, sizeof( RasDialParams ) );
            RasDialParams.dwSize = sizeof( RasDialParams );
            wcscpy( RasDialParams.szEntryName, pIfObject->lpwsInterfaceName );

            dwRetCode = RasGetEntryDialParams(  gblpRouterPhoneBook, 
                                                &RasDialParams, 
                                                &fPassword);

            if ( dwRetCode == NO_ERROR )
            {
                wcscpy( pConnObj->wchUserName, RasDialParams.szUserName );
                wcscpy( pConnObj->wchDomainName, RasDialParams.szDomain );  
                ZeroMemory( &RasDialParams, sizeof( RasDialParams ) );
            }
            else
            {
                dwRetCode = NO_ERROR;
            }

            wcscpy( pConnObj->wchInterfaceName,  pIfObject->lpwsInterfaceName );

            GetSystemTimeAsFileTime( (FILETIME*)&(pDevObj->qwActiveTime) ); 
            pConnObj->qwActiveTime  = pDevObj->qwActiveTime; 
            pConnObj->InterfaceType = pIfObject->IfType;

            pIfObject->dwLastError = NO_ERROR;

            //
            // If this was initiated by an admin api. Let the caller
            // know that we are connected.
            //

            if (pIfObject->hEventNotifyCaller != INVALID_HANDLE_VALUE)
            {
                SetEvent( pIfObject->hEventNotifyCaller );

                CloseHandle( pIfObject->hEventNotifyCaller );

                pIfObject->hEventNotifyCaller = INVALID_HANDLE_VALUE;
            }
        }

        //
        // Reduce the media count for this device
        //

        if ( !(pDevObj->fFlags & DEV_OBJ_MARKED_AS_INUSE) )
        {
            if ( pDevObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
            {
                MediaObjRemoveFromTable( pDevObj->wchDeviceType );
            }

            pDevObj->fFlags |= DEV_OBJ_MARKED_AS_INUSE;

            gblDeviceTable.NumDevicesInUse++;

            //
            // Possibly need to notify the router managers of
            // unreachability
            //

            IfObjectNotifyAllOfReachabilityChange( FALSE, 
                                                   INTERFACE_OUT_OF_RESOURCES );
        }

        RasSetRouterUsage( pDevObj->hPort, TRUE );

    }while( FALSE );

    if ( dwRetCode != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortConnected: Cleaning up hPort=%d, error %d",
                    pDevObj->hPort, dwRetCode );

        RasApiCleanUpPort( pDevObj );

        return( dwRetCode );
    }

    return( NO_ERROR );
}

//**
//
// Call:        RasConnectCallback
//
// Returns:     None
//
// Description: Callback function that will be called by RASAPI32 for any
//              state change.
//
BOOL
RasConnectCallback(
    IN DWORD        dwCallbackId,
    IN DWORD        dwSubEntryId,
    IN HRASCONN     hRasConn,  
    IN DWORD        dwMsg, 
    IN RASCONNSTATE RasConnState,
    IN DWORD        dwError, 
    IN DWORD        dwExtendedError
)
{
    DWORD                       dwIndex;
    ROUTER_INTERFACE_OBJECT *   pIfObject       = NULL;
    DEVICE_OBJECT *             pDevObj         = NULL;
    HANDLE                      hDIMInterface   = (HANDLE)UlongToPtr(dwCallbackId);
    HRASCONN                    hRasConnSubEntry;
    DWORD                       dwRetCode;
    HPORT                       hPort;
    LPWSTR                      lpwsAudit[2];

    if ( dwMsg != WM_RASDIALEVENT )
    {
        RTASSERT( dwMsg == WM_RASDIALEVENT );
        return( TRUE );
    }

    switch( RasConnState )
    {

    case RASCS_Connected:
    case RASCS_SubEntryConnected:
    case RASCS_SubEntryDisconnected:
    case RASCS_Disconnected: 
    case RASCS_PortOpened:
        break;

    default:

        if ( dwError != NO_ERROR )
        {
            break;
        }
        else
        {
            //
            // Ignore these intermediate events
            //

            return( TRUE );
        }
    }

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        //  
        // Get pointer to device object and hRasConn of the device
        //

        dwRetCode = RasGetSubEntryHandle(   hRasConn,
                                            dwSubEntryId,
                                            &hRasConnSubEntry );

        if ( dwRetCode != NO_ERROR )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "RasGetSubEntryHandle( 0x%x, 0x%x, 0x%x ) = %d",
                        hRasConn, dwSubEntryId, &hRasConnSubEntry, dwRetCode );

            if ( dwError == NO_ERROR )
            {
                dwError = dwRetCode;
            }
        }
        else
        {
            hPort = RasGetHport( hRasConnSubEntry );

            if ( hPort == (HPORT)INVALID_HANDLE_VALUE )
            {
                RTASSERT( FALSE );

                dwRetCode = ERROR_INVALID_PORT_HANDLE;

                if ( dwError == NO_ERROR )
                {
                    dwError = dwRetCode;
                }
            }
            else
            {
                if ( ( pDevObj = DeviceObjGetPointer( hPort ) ) == NULL )
                {
                    dwRetCode = ERROR_NOT_ROUTER_PORT;
                }
                else
                {
                    if ( !( pDevObj->fFlags & DEV_OBJ_ALLOW_ROUTERS ) )
                    {
                        dwRetCode = ERROR_NOT_ROUTER_PORT;
                    }
                    else
                    {
                        dwRetCode = NO_ERROR;
                    }
                }

                if ( dwError == NO_ERROR )
                {
                    dwError = dwRetCode;
                }
            }
        }

        if ( dwError == NO_ERROR )
        {
            switch( RasConnState )
            {
            case RASCS_PortOpened:

                pDevObj->fFlags         |= DEV_OBJ_OPENED_FOR_DIALOUT;
                pDevObj->hRasConn       = hRasConnSubEntry;
                break;

            case RASCS_Connected:
            case RASCS_SubEntryConnected:

                DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	                "RasConnectCallback:PortConnected,dwSubEntryId=%d,hPort=%d",
                    dwSubEntryId, hPort );

                dwError = RasPortConnected( hRasConn,
                                            hRasConnSubEntry,
                                            pDevObj,
                                            hDIMInterface );
                break;

            case RASCS_SubEntryDisconnected:
            case RASCS_Disconnected: 

                pDevObj->fFlags     &= ~DEV_OBJ_OPENED_FOR_DIALOUT;
                pDevObj->hRasConn   = (HRASCONN)NULL;

                break;

            default:

                RTASSERT( FALSE );
                break;
            }

            if ( ( RasConnState == RASCS_Connected )        ||
                 ( RasConnState == RASCS_SubEntryConnected )||
                 ( RasConnState == RASCS_PortOpened ) )
            {
                if ( dwError == NO_ERROR )
                {
                    break;
                }
            }
        }
        else
        {
            if ( pDevObj != NULL )
            {
                pDevObj->fFlags     &= ~DEV_OBJ_OPENED_FOR_DIALOUT;
                pDevObj->hRasConn   = (HRASCONN)NULL;
            }
        }

        DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "RasConnectCallback:Could not connect to SubEntry %d,dwError=%d",
               dwSubEntryId, dwError );

        //
        // Has the bundle failed to connect?
        //

        pIfObject = IfObjectGetPointer( hDIMInterface );

        if ( pIfObject == NULL )
        {
            RTASSERT( FALSE );
            dwError = ERROR_NO_SUCH_INTERFACE;
            break;
        }

        --pIfObject->dwNumSubEntriesCounter;

        if ( ( pIfObject->dwNumSubEntriesCounter == 0 ) ||
             ( RasConnState == RASCS_Disconnected ) ||
             !(pIfObject->fFlags & IFFLAG_DIALMODE_DIALALL))
        {
            if ( pIfObject->State == RISTATE_CONNECTED )
            {
                //
                // Interface is already connected so it doesn't matter if this
                // device failed.
                //

                break;
            }

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "RasConnectCallback:Could not connect to interface %ws",
                       pIfObject->lpwsInterfaceName );

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "RasConnectCallback: hanging up 0x%x", pIfObject->hRasConn);
            RasHangUp( pIfObject->hRasConn );

            pIfObject->hRasConn = (HRASCONN)NULL;

            //
            // If the admin as initiated a disconnect or we are out of 
            // retries
            //

            if ( ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) ||
                 ( pIfObject->dwNumOfReConnectAttemptsCounter == 0 ) )
            {
                //
                // Mark as unreachable due to connection failure the admin did
                // not disconnect.
                //

                if ( !( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED ) )
                {
                    pIfObject->fFlags |= IFFLAG_CONNECTION_FAILURE;
                }

                IfObjectDisconnected( pIfObject );

                IfObjectNotifyOfReachabilityChange(     
                                                pIfObject,
                                                FALSE,
                                                INTERFACE_CONNECTION_FAILURE );

                //
                // If we were disconnected by the admin then we should
                // immediately go to the reachable state.
                //

                if ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED )
                {
                    IfObjectNotifyOfReachabilityChange(     
                                                pIfObject,
                                                TRUE,
                                                INTERFACE_CONNECTION_FAILURE );
                }

                pIfObject->dwLastError = dwError;

                if ( pDevObj != NULL )
                {
		            lpwsAudit[0] = pIfObject->lpwsInterfaceName;
		            lpwsAudit[1] = pDevObj->wchPortName;

		            DDMLogErrorString( ROUTERLOG_CONNECTION_ATTEMPT_FAILED, 
                                       2, lpwsAudit, dwError, 2 );
                }

                //
                // If this was initiated by an admin api. Let the caller
                // know that we are not connected.
                //

                if (pIfObject->hEventNotifyCaller != INVALID_HANDLE_VALUE)
                {
                    SetEvent( pIfObject->hEventNotifyCaller );

                    CloseHandle( pIfObject->hEventNotifyCaller );

                    pIfObject->hEventNotifyCaller = INVALID_HANDLE_VALUE;
                }
            }
            else
            {
                //
                // Otherwise we try again
                //

                pIfObject->dwNumOfReConnectAttemptsCounter--;

                //
                // Stagger the reconnectime randomly between 0 and twice the
                // configured reconnect time.   
                //

                srand( (unsigned)time( NULL ) );
            
                TimerQInsert( 
                    pIfObject->hDIMInterface,
                    rand()%((pIfObject->dwSecondsBetweenReConnectAttempts*2)+1),
                    ReConnectInterface );

            }
        }
    }
    while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    return( TRUE );
}

//**
//
// Call:        RasConnectionInitiate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to initiate a demand-dial connection
//
DWORD
RasConnectionInitiate( 
    IN ROUTER_INTERFACE_OBJECT *    pIfObject,
    IN BOOL                         fRedialAttempt
) 
{
    RASDIALEXTENSIONS   RasDialExtensions;
    RASDIALPARAMS       RasDialParams;
    DWORD               dwXportIndex;
    DWORD               dwRetCode;
    RASENTRY            re;
    DWORD               dwSize;
    RASEAPUSERIDENTITY* pRasEapUserIdentity = NULL;

    //
    // Do not try to connect if the interface is disabled or out of resources
    // or the service is paused or the interface is marked as unreachable due
    // to connection failure.
    //

    if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
    {
        return( ERROR_INTERFACE_DISABLED );
    }

    if ( pIfObject->fFlags & IFFLAG_OUT_OF_RESOURCES )
    {
        return( ERROR_INTERFACE_HAS_NO_DEVICES );
    }

    if ( gblDDMConfigInfo.pServiceStatus->dwCurrentState == SERVICE_PAUSED )
    {
        return( ERROR_SERVICE_IS_PAUSED );
    }

    //
    // If this is not a redial attempt then we reset the reconnect attempts
    // counter and unset the admin disconnected flag if it was set.
    //

    if ( !fRedialAttempt )
    {
        pIfObject->dwNumOfReConnectAttemptsCounter = 
                                        pIfObject->dwNumOfReConnectAttempts;

        pIfObject->fFlags &= ~IFFLAG_DISCONNECT_INITIATED;
    } 
    else
    {
        //
        // Do not allow the reconnect attempt to go thru if the admin has 
        // disconnected this interface.
        //

        if ( pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED )
        {
            return( ERROR_INTERFACE_DISCONNECTED );
        }
    }

    //
    // Build PppInterfaceInfo structure to pass down to RasDial that will pass
    // it on to PPP.
    //

    for ( dwXportIndex = 0;
          dwXportIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwXportIndex++ )
    {
        switch( gblRouterManagers[dwXportIndex].DdmRouterIf.dwProtocolId )
        {
        case PID_IPX:


            if (pIfObject->Transport[dwXportIndex].fState & RITRANSPORT_ENABLED)
            {
                pIfObject->PppInterfaceInfo.hIPXInterface =
                                pIfObject->Transport[dwXportIndex].hInterface;
            }
            else
            {
                pIfObject->PppInterfaceInfo.hIPXInterface=INVALID_HANDLE_VALUE;
            }

            break;

        case PID_IP:

            if (pIfObject->Transport[dwXportIndex].fState & RITRANSPORT_ENABLED)
            {
                pIfObject->PppInterfaceInfo.hIPInterface =
                                pIfObject->Transport[dwXportIndex].hInterface;
            }
            else
            {
                pIfObject->PppInterfaceInfo.hIPInterface = INVALID_HANDLE_VALUE;
            }

            break;

        default:

            RTASSERT( FALSE );
            break;
        }
    }

    pIfObject->PppInterfaceInfo.IfType  = pIfObject->IfType;
    pIfObject->dwNumSubEntriesCounter   = pIfObject->dwNumSubEntries;
    
    //
    // Initiate the connection
    //

    ZeroMemory( &RasDialExtensions, sizeof( RasDialExtensions ) );
    RasDialExtensions.dwSize     = sizeof( RasDialExtensions );
    RasDialExtensions.dwfOptions = RDEOPT_Router;
    RasDialExtensions.reserved   = (ULONG_PTR)&(pIfObject->PppInterfaceInfo);

    ZeroMemory( &RasDialParams, sizeof( RasDialParams ) );

    RasDialParams.dwSize        = sizeof( RasDialParams );
    RasDialParams.dwCallbackId  = PtrToUlong(pIfObject->hDIMInterface);
    RasDialParams.dwSubEntry    = 0;

    wcscpy( RasDialParams.szCallbackNumber, TEXT("*") );
    wcscpy( RasDialParams.szEntryName,      pIfObject->lpwsInterfaceName );

    //
    // Do we need to call RasEapGetIdentity?
    //

    dwRetCode = RasGetEapUserIdentity(
                            gblpRouterPhoneBook,
                            pIfObject->lpwsInterfaceName,
                            RASEAPF_NonInteractive,
                            NULL,
                            &pRasEapUserIdentity);

    if ( ERROR_INVALID_FUNCTION_FOR_ENTRY == dwRetCode )
    {
        //
        // This entry does not require RasEapGetIdentity. Get its credentials.
        //

        dwRetCode = MprAdminInterfaceGetCredentialsInternal(  
                                        NULL,
                                        pIfObject->lpwsInterfaceName,
                                        (LPWSTR)&(RasDialParams.szUserName), 
                                        (LPWSTR)&(RasDialParams.szPassword), 
                                        (LPWSTR)&(RasDialParams.szDomain) );

        if ( dwRetCode != NO_ERROR )
        {
            return( ERROR_NO_INTERFACE_CREDENTIALS_SET );
        }
    }
    else if ( NO_ERROR != dwRetCode )
    {
        if ( ERROR_INTERACTIVE_MODE == dwRetCode )
        {
            dwRetCode = ERROR_NO_INTERFACE_CREDENTIALS_SET;
        }

        return( dwRetCode );
    }
    else
    {
        wcscpy( RasDialParams.szUserName, pRasEapUserIdentity->szUserName );

        RasDialExtensions.RasEapInfo.dwSizeofEapInfo =
                                pRasEapUserIdentity->dwSizeofEapInfo;
        RasDialExtensions.RasEapInfo.pbEapInfo =
                                pRasEapUserIdentity->pbEapInfo;
    }

    if(     (0 != gblDDMConfigInfo.cDigitalIPAddresses)
        ||  (0 != gblDDMConfigInfo.cAnalogIPAddresses))
    {        

        ZeroMemory(&re, sizeof(RASENTRY));

        re.dwSize = sizeof(RASENTRY);

        dwSize = sizeof(RASENTRY);

        if(ERROR_SUCCESS == (dwRetCode = RasGetEntryProperties(
                                            gblpRouterPhoneBook,
                                            pIfObject->lpwsInterfaceName,
                                            &re,
                                            &dwSize,
                                            NULL,
                                            NULL)))
        {   
            if(RASET_Vpn == re.dwType)
            {
                char *pszMungedPhoneNumber = NULL;
                char szPhoneNumber[RAS_MaxPhoneNumber + 1];
                WCHAR wszMungedPhoneNumber[RAS_MaxPhoneNumber + 1];

                //
                // Convert the phonenumber to ansi
                //

                WideCharToMultiByte(
                                CP_ACP,
                                0,
                                re.szLocalPhoneNumber,
                                -1,
                                szPhoneNumber,
                                sizeof( szPhoneNumber ),
                                NULL,
                                NULL );

                //
                // Munge the phonenumber
                //

                dwRetCode = MungePhoneNumber(
                                    szPhoneNumber,
                                    gblDDMConfigInfo.dwIndex,
                                    &dwSize,
                                    &pszMungedPhoneNumber);

                if(ERROR_SUCCESS == dwRetCode)
                {
                    //
                    // Change the munged phonenumber to widechar
                    //

                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         pszMungedPhoneNumber,
                                         -1,
                                         wszMungedPhoneNumber,
                                         RAS_MaxPhoneNumber + 1);

                    if ( wcslen( wszMungedPhoneNumber ) <= RAS_MaxPhoneNumber)
                    {
                        wcscpy( RasDialParams.szPhoneNumber, 
                                wszMungedPhoneNumber );

                        DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                                  "Munged Phone Number=%ws",
                                  RasDialParams.szPhoneNumber);

                        //
                        // Increase the index so that we try the
                        // next FEP the next time this is dialed.
                        //

                        gblDDMConfigInfo.dwIndex += 1;

                        LocalFree( pszMungedPhoneNumber );
                    }            
                }
            }
        }
    }

    dwRetCode = RasDial( &RasDialExtensions,
                         gblpRouterPhoneBook,
                         &RasDialParams, 
                         2,
                         RasConnectCallback,
                         &(pIfObject->hRasConn) );

    //
    // Zero out these since they contained sensitive password information
    //

    ZeroMemory( &RasDialParams, sizeof( RasDialParams ) );

    RasFreeEapUserIdentity( pRasEapUserIdentity );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    pIfObject->State = RISTATE_CONNECTING;

    pIfObject->fFlags |= IFFLAG_LOCALLY_INITIATED;

    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\objects.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    objects.h
//
// Description: Prototypes for all routines and procedures that manipulate
//              the various objects.
//
// History:     May 11,1995	    NarenG		Created original version.
//

//
// Conneciton object prototypes
//

CONNECTION_OBJECT * 
ConnObjAllocateAndInit(
    IN HANDLE hDDMInterface,
    IN HCONN  hConnection
);

VOID
ConnObjInsertInTable(
    IN CONNECTION_OBJECT * pConnObj
);

CONNECTION_OBJECT * 
ConnObjGetPointer(
    IN HCONN hConnection 
);

DWORD 
ConnObjHashConnHandleToBucket( 
    IN HCONN hConnection
);

PCONNECTION_OBJECT
ConnObjRemove(
    IN HCONN hConnection
);

VOID
ConnObjRemoveAndDeAllocate(
    IN HCONN hConnection
);

DWORD
ConnObjAddLink(
    IN CONNECTION_OBJECT * pConnObj,
    IN DEVICE_OBJECT *     pDeviceObj
);

VOID
ConnObjRemoveLink(
    IN HCONN            hConnection,
    IN DEVICE_OBJECT *  pDeviceObj
);

VOID
ConnObjDisconnect( 
    IN  CONNECTION_OBJECT * pConnObj
);

//
// Router Interface object prototypes
//

BOOL
IfObjectAreAllTransportsDisconnected(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

VOID
IfObjectDisconnected(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

DWORD
IfObjectConnected(
    IN HANDLE                   hDDMInterface,
    IN HCONN                    hConnection,
    IN PPP_PROJECTION_RESULT   *pProjectionResult
);

VOID
IfObjectNotifyOfReachabilityChange(
    IN ROUTER_INTERFACE_OBJECT *pIfObject,
    IN BOOL                     fReachable,
    IN UNREACHABILITY_REASON    dwReason
);

VOID
IfObjectNotifyAllOfReachabilityChange(
    IN BOOL                     fReachable,
    IN UNREACHABILITY_REASON    dwReason
);

DWORD
IfObjectAddClientInterface(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN PBYTE                     pClientInterface
);

VOID
IfObjectDeleteInterface(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

DWORD
IfObjectLoadPhonebookInfo(
    IN ROUTER_INTERFACE_OBJECT * pIfObject,
    IN OUT PVOID *ppvContext
);

VOID
IfObjectInitiatePersistentConnections(
    VOID
);

VOID
IfObjectDisconnectInterfaces(
    VOID
);

VOID
IfObjectConnectionChangeNotification(
    VOID
);

VOID
IfObjectSetDialoutHoursRestriction(
    IN ROUTER_INTERFACE_OBJECT * pIfObject
);

//
// Media object prototypes
//

VOID
MediaObjRemoveFromTable(
    LPWSTR lpwsMedia
);

DWORD
MediaObjAddToTable(
    LPWSTR lpwsMedia
);

DWORD
MediaObjInitializeTable(
    VOID
);

VOID
MediaObjGetAvailableMediaBits(
    DWORD * pfAvailableMedia
);

DWORD
MediaObjSetMediaBit(
    LPWSTR  lpwsMedia,
    DWORD * pfMedia
);

VOID
MediaObjFreeTable(
    VOID
);

//
// Device object prototypes
//

DWORD
DeviceObjIterator(
    IN DWORD (*pProcessFunction)(   IN DEVICE_OBJECT *, 
                                    IN LPVOID, 
                                    IN DWORD, 
                                    IN DWORD ),
    IN BOOL  fReturnOnError,
    IN PVOID Parameter
);

DWORD
DeviceObjHashPortToBucket(
    IN HPORT hPort
);

DEVICE_OBJECT *
DeviceObjGetPointer(
    IN HPORT hPort
);

VOID
DeviceObjInsertInTable( 
    IN DEVICE_OBJECT * pDeviceObj 
);

VOID
DeviceObjRemoveFromTable( 
    IN HPORT    hPort
);

DEVICE_OBJECT * 
DeviceObjAllocAndInitialize(
    IN HPORT           hPort,
    IN RASMAN_PORT*    pRasmanPort
);

DWORD
DeviceObjStartClosing(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjPostListen(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjIsClosed(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjCopyhPort(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjCloseListening(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjResumeListening(
    IN DEVICE_OBJECT *  pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjRequestNotification(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjClose(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjGetType(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjForceIpSec(
    IN DEVICE_OBJECT  * pDeviceObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

DWORD
DeviceObjIsWANDevice(
    IN DEVICE_OBJECT *  pDevObj,
    IN PVOID            Parameter,
    IN DWORD            dwBucketIndex,
    IN DWORD            dwDeviceIndex
);

VOID
DeviceObjAdd(
    IN RASMAN_PORT *    pRasmanPort 
);

VOID
DeviceObjRemove(
    IN RASMAN_PORT *    pRasmanPort 
);

VOID
DeviceObjUsageChange(
    IN RASMAN_PORT *    pRasmanPort 
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\rasapiif.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    rasapiif.h
//
// Description: Prototypes of procedures in rasapiif.c
//
// History:     May 11,1996	    NarenG		Created original version.
//

DWORD
RasConnectionInitiate( 
    IN ROUTER_INTERFACE_OBJECT *    pIfObject,
    IN BOOL                         fRedialAttempt
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\ppphand.c ===
/*******************************************************************/
/*          Copyright(c)  1992 Microsoft Corporation           */
/*******************************************************************/

//***
//
// Filename:    ppphand.c
//
// Description: This module contains the procedures for the
//        supervisor's procedure-driven state machine
//              that handle PPP events.
//
// Author:    Stefan Solomon (stefans)    May 26, 1992.
//
//***
#include "ddm.h"
#include "timer.h"
#include "handlers.h"
#include "objects.h"
#include "util.h"
#include "routerif.h"
#include <raserror.h>
#include <rasppp.h>
#include <ddmif.h>
#include <serial.h>
#include "rasmanif.h"
#include <string.h>
#include <stdlib.h>
#include <memory.h>

//
// This lives in rasapi32.dll
//

DWORD
DDMGetPppParameters(
    LPWSTR  lpwsPhonebookName,
    LPWSTR  lpwsPhonebookEntry,
    CHAR *  szzPppParameters
);

//***
//
// Function:    SvPppSendInterfaceInfo
//
// Description: Ppp engine wants to get the interface handles for this 
//              connection.
//
VOID
SvPppSendInterfaceInfo( 
    IN PDEVICE_OBJECT pDeviceObj
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    PPP_INTERFACE_INFO          PppInterfaceInfo;
    DWORD                       dwXportIndex;
    PCONNECTION_OBJECT          pConnObj;

    DDM_PRINT(gblDDMConfigInfo.dwTraceId, TRACE_FSM,
              "SvPppSendInterfaceHandles: Entered, hPort=%d",pDeviceObj->hPort);

    ZeroMemory( &PppInterfaceInfo, sizeof( PppInterfaceInfo ) );

    if ( ( pConnObj = ConnObjGetPointer( pDeviceObj->hConnection ) ) == NULL )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "No ConnObj" );
        
        return;
    }

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    if ( ( pIfObject = IfObjectGetPointer( pConnObj->hDIMInterface ) ) == NULL )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "No IfObject" );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        return;
    }

    //
    // Get handles to this interface for each transport and notify PPP.
    //

    for ( dwXportIndex = 0;
          dwXportIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwXportIndex++ )
    {
        switch( gblRouterManagers[dwXportIndex].DdmRouterIf.dwProtocolId )
        {
        case PID_IPX:

            if (pIfObject->Transport[dwXportIndex].fState & RITRANSPORT_ENABLED)
            {
                PppInterfaceInfo.hIPXInterface =  
                                pIfObject->Transport[dwXportIndex].hInterface;
            }
            else
            {
                PppInterfaceInfo.hIPXInterface = INVALID_HANDLE_VALUE; 
            }

            break;

        case PID_IP:

            if (pIfObject->Transport[dwXportIndex].fState & RITRANSPORT_ENABLED)
            {
                PppInterfaceInfo.hIPInterface =  
                                pIfObject->Transport[dwXportIndex].hInterface;

                CopyMemory( PppInterfaceInfo.szzParameters,
                            pIfObject->PppInterfaceInfo.szzParameters,
                            sizeof( PppInterfaceInfo.szzParameters ) );
            }
            else
            {
                PppInterfaceInfo.hIPInterface = INVALID_HANDLE_VALUE; 
            }

            break;

        default:

            break;
        }
    }

    PppInterfaceInfo.IfType = pIfObject->IfType;

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
        
    PppDdmSendInterfaceInfo( pDeviceObj->hConnection, &PppInterfaceInfo );
}

//***
//
// Function:    SvPppUserOK
//
// Description: User has passed security verification and entered the
//                configuration conversation phase. Stops auth timer and
//                logs the user.
//
//***
VOID 
SvPppUserOK(
    IN PDEVICE_OBJECT       pDeviceObj,
    IN PPPDDM_AUTH_RESULT * pAuthResult  
)
{
    LPWSTR                      lpstrAudit[2];
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    PCONNECTION_OBJECT          pConnObj;
    DWORD                       dwRetCode = NO_ERROR;
    WCHAR                       wchUserName[UNLEN+1];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppUserOK: Entered, hPort=%d", pDeviceObj->hPort);

    if ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "Auth not started" );

        return;
    }

    //
    // Stop authentication timer
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    if ( strlen( pAuthResult->szUserName ) > 0 )
    {
        MultiByteToWideChar( CP_ACP, 
                             0, 
                             pAuthResult->szUserName, 
                             -1, 
                             wchUserName, 
                             UNLEN+1 );
    }
    else
    {
        wcscpy( wchUserName, gblpszUnknown );
    }

    //
    // Check to see if the username and domain are the same if the 3rd party
    // security DLL is installed..
    //

    if ( ( gblDDMConfigInfo.lpfnRasBeginSecurityDialog != NULL ) &&
         ( gblDDMConfigInfo.lpfnRasEndSecurityDialog   != NULL ) &&
         ( pDeviceObj->fFlags & DEV_OBJ_SECURITY_DLL_USED ) )
    {
        //
        // If there is no match then hangup the line
        //

        if ( _wcsicmp( pDeviceObj->wchUserName, wchUserName ) != 0 )
        {
            lpstrAudit[0] = pDeviceObj->wchUserName;
            lpstrAudit[1] = wchUserName;

            DDMLogWarning( ROUTERLOG_AUTH_DIFFUSER_FAILURE, 2, lpstrAudit );

            PppDdmStop( pDeviceObj->hPort, ERROR_ACCESS_DENIED );

            return;
        }
    }

    //
    // copy the user name
    //

    wcscpy( pDeviceObj->wchUserName, wchUserName );

    //
    // copy the domain name
    //

    MultiByteToWideChar( CP_ACP,
                         0,
                         pAuthResult->szLogonDomain,
                         -1,
                         pDeviceObj->wchDomainName, 
                         DNLEN+1 );

    //
    // copy the advanced server flag
    //

    if ( pAuthResult->fAdvancedServer )
    {
        pDeviceObj->fFlags |= DEV_OBJ_IS_ADVANCED_SERVER;
    }

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do 
    {
        //
        // Check to see if there are any non-client intefaces with this
        // name.
        //

        pIfObject = IfObjectGetPointerByName( pDeviceObj->wchUserName, FALSE );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            //
            // If this is a client dialing in and clients are not allowed
            // to dialin to this port, then disconnect them.
            //

            if ( !( pDeviceObj->fFlags & DEV_OBJ_ALLOW_CLIENTS ) )
            {
                dwRetCode = ERROR_NOT_CLIENT_PORT;

                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "A client tried to connect on a router only port=%d",
                        pDeviceObj->hPort);

                break;
            }
        }
        else
        {
            //
            // If a call came in for an interface that is not dynamic
            // then do not accept the line
            //

            if ( ( pIfObject->IfType == ROUTER_IF_TYPE_DEDICATED ) ||
                 ( pIfObject->IfType == ROUTER_IF_TYPE_INTERNAL ) )
            {
                //
                // Notify PPP not to accept the connection
                //

                dwRetCode = ERROR_ALREADY_CONNECTED;

                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "The interface %ws is already connected port=%d",
                        pIfObject->lpwsInterfaceName, pDeviceObj->hPort );

                break;
            }

            //
            // Allow the connection only if the interface is enabled
            //

            if ( !( pIfObject->fFlags & IFFLAG_ENABLED ) )
            {
                dwRetCode = ERROR_INTERFACE_DISABLED;

                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "The interface %ws is disabled",
                        pIfObject->lpwsInterfaceName );

                break;
            }

            if ( !( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS ) )
            {
                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "A router tried to connect on a client only port=%d",
                        pDeviceObj->hPort);

                dwRetCode = ERROR_NOT_ROUTER_PORT;

                break;
            }

            //
            // Set current usage in rasman to ROUTER
            //

            RasSetRouterUsage( pDeviceObj->hPort, TRUE );
        }

    } while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    if ( dwRetCode != NO_ERROR )
    {
        lpstrAudit[0] = pDeviceObj->wchUserName;
        lpstrAudit[1] = pDeviceObj->wchPortName;

        DDMLogWarningString( ROUTERLOG_CONNECTION_ATTEMPT_FAILURE,
                             2,
                             lpstrAudit,
                             dwRetCode,
                             2 );

        PppDdmStop( pDeviceObj->hPort, dwRetCode );
    }

    return;
}

//***
//
// Function:    SvPppNewLinkOrBundle
//
// Description: User has passed security verification and entered the
//                configuration conversation phase. Stops auth timer and
//                logs the user.
//
//***
VOID 
SvPppNewLinkOrBundle(
    IN PDEVICE_OBJECT       pDeviceObj,
    IN BOOL                 fNewBundle,
    IN PBYTE                pClientInterface,
    IN PBYTE                pQuarantineIPFilter,
    IN PBYTE                pFilter,
    IN BOOL                 fQuarantinePresent
)
{
    LPWSTR                      lpstrAudit[2];
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    PCONNECTION_OBJECT          pConnObj;
    DWORD                       dwRetCode = NO_ERROR;
    WCHAR                       wchUserName[UNLEN+1];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppNewLinkOrBundle: Entered, hPort=%d", pDeviceObj->hPort);

    if ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "Auth not started" );

        return;
    }

    //
    // Get handle to the connection or bundle for this link
    //

    if ( ( dwRetCode = RasPortGetBundle( NULL, pDeviceObj->hPort, 
                           &(pDeviceObj->hConnection) ) ) != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortGetBundle failed: %d", dwRetCode );

        PppDdmStop( pDeviceObj->hPort, dwRetCode );

        return;
    }

    //
    // Allocate a connection object if it does not exist yet
    //

    pConnObj = ConnObjGetPointer( pDeviceObj->hConnection );

    if ( pConnObj == (CONNECTION_OBJECT *)NULL )
    {
        pConnObj = ConnObjAllocateAndInit( INVALID_HANDLE_VALUE,
                                           pDeviceObj->hConnection );

        if ( pConnObj == (CONNECTION_OBJECT *)NULL )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "ConnObjAllocateAndInit failed" );

            PppDdmStop( pDeviceObj->hPort, ERROR_NOT_ENOUGH_MEMORY );

            return;
        }

        pConnObj->fFlags    = CONN_OBJ_IS_PPP;
        pConnObj->hPort     = pDeviceObj->hPort;
        pConnObj->pQuarantineFilter = pQuarantineIPFilter;
        pConnObj->pFilter = pFilter;

        wcscpy( pConnObj->wchInterfaceName, pDeviceObj->wchUserName );

        //
        // copy the user name
        //

        wcscpy( pConnObj->wchUserName, pDeviceObj->wchUserName );

        //
        // copy the domain name
        //

        wcscpy( pConnObj->wchDomainName, pDeviceObj->wchDomainName );

        // 
        // If it is a router, check to see if we have an interface for this 
        // router, otherwise reject this connection. 
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        do 
        {
            //
            // Check to see if there are any non-client intefaces with this
            // name.
            //

            pIfObject = IfObjectGetPointerByName( pConnObj->wchInterfaceName,
                                                  FALSE );

            //
            // We do not have this interface in our database so assume that
            // this is a client so we need to create and interface and add it
            // to all the router managers. Also if this interface exists but
            // is for a client we need to add this interface again.
            //

            if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL ) 
            {
                pIfObject = IfObjectAllocateAndInit(
                                                pConnObj->wchUserName,
                                                RISTATE_CONNECTING,
                                                ROUTER_IF_TYPE_CLIENT,
                                                pConnObj->hConnection,
                                                TRUE,
                                                0,
                                                0,
                                                NULL,
                                                NULL);

                if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
                {
                    //
                    // Error log this and stop the connection.
                    //

                    dwRetCode = GetLastError();

                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                               "IfObjectAllocateAndInit failed: %d", dwRetCode);

                    break;
                }


                //
                // Add interfaces to router managers, insert in table now
                // because of the table lookup within the InterfaceEnabled
                // call made in the context of AddInterface.
                //

                dwRetCode = IfObjectInsertInTable( pIfObject );

                if ( dwRetCode != NO_ERROR )
                {
                    LOCAL_FREE( pIfObject );

                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                               "IfObjectInsertInTable failed: %d", dwRetCode );

                    break;
                }

                dwRetCode = IfObjectAddClientInterface( pIfObject, 
                                                        pClientInterface );

                if ( dwRetCode != NO_ERROR )
                {
                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                               "IfObjectAddClientInterface failed: %d",
                               dwRetCode );

                    IfObjectRemove( pIfObject->hDIMInterface );

                    break;
                }
                
                if(fQuarantinePresent)
                {
                    pConnObj->fFlags |= CONN_OBJ_QUARANTINE_PRESENT;
                }
            }
            else
            {
                //
                // If the interface is already connecting or connected
                // and this is a new bundle then we need to reject this
                // connection.
                //

                if ( pIfObject->State != RISTATE_DISCONNECTED )
                {
                    //
                    // Notify PPP not to accept the connection
                    //

                    dwRetCode = ERROR_ALREADY_CONNECTED;

                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                        "The interface %ws is already connected port=%d",
                        pIfObject->lpwsInterfaceName, pDeviceObj->hPort );

                    break;
                }
            }

            ConnObjInsertInTable( pConnObj );

            pIfObject->State = RISTATE_CONNECTING;

            pConnObj->hDIMInterface = pIfObject->hDIMInterface;
            pConnObj->InterfaceType = pIfObject->IfType;

        } while( FALSE );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        if ( dwRetCode != NO_ERROR )
        {
            PppDdmStop( pDeviceObj->hPort, dwRetCode );

            LOCAL_FREE( pConnObj );

            return;
        }

    }
    //
    // Since this is a new bundle also send the interface handles
    //

    if ( fNewBundle )
    {
        SvPppSendInterfaceInfo( pDeviceObj );
    }


    //
    // Add this link to the connection block.
    //

    if ( ( dwRetCode = ConnObjAddLink( pConnObj, pDeviceObj ) ) != NO_ERROR )
    {
        PppDdmStop( pDeviceObj->hPort, ERROR_NOT_ENOUGH_MEMORY );

        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );

        return;
    }
}

//***
//
// Function: SvPppFailure
//
// Descr:    Ppp will let us know of any failure while active on a port.
//           An error message is sent to us and we merely log it and
//           disconnect the port.
//
//***
VOID 
SvPppFailure(
    IN PDEVICE_OBJECT pDeviceObj,
    IN PPPDDM_FAILURE *afp
)
{
    LPWSTR auditstrp[3];
    WCHAR  wchErrorString[256+1];
    WCHAR  wchUserName[UNLEN+DNLEN+1];
    WCHAR  wchDomainName[DNLEN+1];
    DWORD  dwRetCode;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppFailure: Entered, hPort=%d, Error=%d", 
                pDeviceObj->hPort, afp->dwError );

    //
    // Was this a failure for a BAP callback?
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_BAP_CALLBACK )
    {
        PppDdmBapCallbackResult( pDeviceObj->hBapConnection, afp->dwError );

        pDeviceObj->fFlags &= ~DEV_OBJ_BAP_CALLBACK;
    }

    if ( afp->szUserName[0] != (CHAR)NULL )
    {
        MultiByteToWideChar( CP_ACP, 0, afp->szUserName, -1, wchUserName, UNLEN+1 );
    }
    else
    {
        wcscpy( wchUserName, gblpszUnknown );
    }

    //
    // We ignore the DeviceState here because a Ppp failure can occur at
    // any time during the connection.
    //

    switch( afp->dwError )
    {
    case ERROR_AUTHENTICATION_FAILURE:

        auditstrp[0] = wchUserName;
        auditstrp[1] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_AUTH_FAILURE,2,auditstrp );

        break;

    case ERROR_PASSWD_EXPIRED:

        MultiByteToWideChar( CP_ACP, 0, afp->szLogonDomain, -1, wchDomainName, DNLEN+1 );

        auditstrp[0] = wchDomainName;
        auditstrp[1] = wchUserName;
        auditstrp[2] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_PASSWORD_EXPIRED, 3, auditstrp );

        break;

    case ERROR_ACCT_EXPIRED:
    case ERROR_ACCOUNT_EXPIRED:

        MultiByteToWideChar( CP_ACP, 0, afp->szLogonDomain, -1, wchDomainName, DNLEN+1 );

        auditstrp[0] = wchDomainName;
        auditstrp[1] = wchUserName;
        auditstrp[2] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_ACCT_EXPIRED, 3, auditstrp );
          
        break;

    case ERROR_NO_DIALIN_PERMISSION:

        MultiByteToWideChar( CP_ACP, 0, afp->szLogonDomain, -1, wchDomainName, DNLEN+1 );

        auditstrp[0] = wchDomainName;
        auditstrp[1] = wchUserName;
        auditstrp[2] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_NO_DIALIN_PRIVILEGE, 3, auditstrp );

        break;


    case ERROR_REQ_NOT_ACCEP:

        auditstrp[0] = pDeviceObj->wchPortName;

        DDMLogWarning( ROUTERLOG_LICENSE_LIMIT_EXCEEDED, 1, auditstrp );

        break;

    case ERROR_BAP_DISCONNECTED:
    case ERROR_BAP_REQUIRED:

        auditstrp[0] = wchUserName;
        auditstrp[1] = pDeviceObj->wchPortName;

        DDMLogWarningString( ROUTERLOG_BAP_DISCONNECT, 2, auditstrp,
                afp->dwError, 2 );

        break;

    case ERROR_PORT_NOT_CONNECTED:
    case ERROR_PPP_TIMEOUT:
    case ERROR_PPP_LCP_TERMINATED:
    case ERROR_NOT_CONNECTED:

        //
        // Ignore this error
        //

        break;

    case ERROR_PPP_NOT_CONVERGING:
    default:

        if ( afp->szUserName[0] != (CHAR)NULL )
        {
            if ( afp->szLogonDomain[0] != (CHAR)NULL )
            {
                MultiByteToWideChar(CP_ACP,0,afp->szLogonDomain,-1,wchUserName,UNLEN+1);
                wcscat( wchUserName, L"\\" );

                MultiByteToWideChar(CP_ACP,0,afp->szUserName,-1,wchDomainName,DNLEN+1);
                wcscat( wchUserName, wchDomainName );
            }
            else
            {
                MultiByteToWideChar(CP_ACP,0,afp->szUserName,-1,wchUserName,UNLEN+1);
            }
        }
        else if ( pDeviceObj->wchUserName[0] != (WCHAR)NULL )
        {
            if ( pDeviceObj->wchDomainName[0] != (WCHAR)NULL )
            {
                wcscpy( wchUserName, pDeviceObj->wchDomainName );
                wcscat( wchUserName, L"\\" );
                wcscat( wchUserName, pDeviceObj->wchUserName );
            }
            else
            {
                wcscpy( wchUserName, pDeviceObj->wchUserName );
            }
        }
        else
        {
            wcscpy( wchUserName, gblpszUnknown );
        }

        auditstrp[0] = pDeviceObj->wchPortName;
        auditstrp[1] = wchUserName;

        DDMLogErrorString(ROUTERLOG_PPP_FAILURE, 2, auditstrp, afp->dwError, 2);

        break;
    }
}

//***
//
// Function:    SvPppCallbackRequest
//
// Description:
//
//***
VOID 
SvPppCallbackRequest(
    IN PDEVICE_OBJECT           pDeviceObj,
    IN PPPDDM_CALLBACK_REQUEST  *cbrp
)
{
    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppCallbackRequest: Entered, hPort = %d\n",pDeviceObj->hPort);

    //
    // check the state
    //

    if (pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE)
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "Auth not started" );

        return;
    }

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

    //
    // copy relevant fields in our dcb
    //

    if (cbrp->fUseCallbackDelay)
    {
        pDeviceObj->dwCallbackDelay = cbrp->dwCallbackDelay;
    }
    else
    {
        pDeviceObj->dwCallbackDelay = gblDDMConfigInfo.dwCallbackTime;
    }

    MultiByteToWideChar( CP_ACP,
                         0,
                         cbrp->szCallbackNumber,    
                         -1,
                         pDeviceObj->wchCallbackNumber, 
                         MAX_PHONE_NUMBER_LEN + 1 );

    //
    // Disconnect the line and change the state
    //

    pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTING;

    //
    // Wait to enable the client to get the message
    //

    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvDiscTimeout );

    TimerQInsert( (HANDLE)pDeviceObj->hPort, 
                  DISC_TIMEOUT_CALLBACK, SvDiscTimeout );
}


//***
//
// Function:    SvPppDone
//
// Description: Activates all allocated bindings.
//
//***
VOID 
SvPppDone(
    IN PDEVICE_OBJECT           pDeviceObj,
    IN PPP_PROJECTION_RESULT    *pProjectionResult
)
{
    LPWSTR                      lpstrAudit[3];
    DWORD                       dwRetCode;
    DWORD                       dwNumActivatedProjections = 0;
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    CONNECTION_OBJECT *         pConnObj;
    WCHAR                       wchFullUserName[UNLEN+DNLEN+2];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvPppDone: Entered, hPort=%d", pDeviceObj->hPort);

    //
    // If we are not authenicating and not been authenticated then we ignore
    // this message.
    //

    if ( ( pDeviceObj->DeviceState != DEV_OBJ_AUTH_IS_ACTIVE ) &&
         ( pDeviceObj->DeviceState != DEV_OBJ_ACTIVE ) )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "We are not authenicating and not been authenticated" );

        return;
    }

    //
    // Get pointer to connection object. If we cannot find it that means we
    // have gotten a PPP message for a device who's connection does not exist.
    // Simply ignore it.
    //

    if ( ( pConnObj = ConnObjGetPointer( pDeviceObj->hConnection ) ) == NULL )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "No ConnObj" );

        return;
    }

    //
    // If we are getting a projection info structure again, we just update it
    // and return.
    //

    if ( pDeviceObj->DeviceState == DEV_OBJ_ACTIVE )
    {
        pConnObj->PppProjectionResult = *pProjectionResult;

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "Updated projection info structure" );

        return;
    }

    if ( pConnObj->wchDomainName[0] != TEXT('\0') )
    {
        wcscpy( wchFullUserName, pConnObj->wchDomainName );
        wcscat( wchFullUserName, TEXT("\\") );
        wcscat( wchFullUserName, pConnObj->wchUserName );
    }
    else
    {
        wcscpy( wchFullUserName, pConnObj->wchUserName );
    }

    lpstrAudit[0] = wchFullUserName;
    lpstrAudit[1] = pDeviceObj->wchPortName;

    //
    // If we have not yet been notifyied of projections for this connection.
    //

    if ( !(pConnObj->fFlags & CONN_OBJ_PROJECTIONS_NOTIFIED) )
    {
        if ( pProjectionResult->ip.dwError == NO_ERROR )
        {
            dwNumActivatedProjections++;
        }

        if ( pProjectionResult->ipx.dwError == NO_ERROR )
        {
            dwNumActivatedProjections++;
        }

        if ( pProjectionResult->at.dwError == NO_ERROR )
        {
            dwNumActivatedProjections++;
        }

        //
        // We couldn't activate any projection due to some error error log 
        // and bring the link down
        //

        if ( dwNumActivatedProjections == 0 ) 
        {
            DDMLogError(ROUTERLOG_AUTH_NO_PROJECTIONS, 2, lpstrAudit, NO_ERROR);

            PppDdmStop( pDeviceObj->hPort, NO_ERROR );

            return;
        }
        else
        {
            //
            // Even though NBF was removed from the product, we can 
            // still get the computer namefrom the nbf projection result 
            // (PPP Engine dummied it in there). 
            //
            // If the computer name ends with 0x03, that tells us
            // the messenger service is running on the remote computer.
            //

            pConnObj->fFlags &= ~CONN_OBJ_MESSENGER_PRESENT;

            pConnObj->bComputerName[0] = (CHAR)NULL;

            if ( pProjectionResult->nbf.wszWksta[0] != (WCHAR)NULL )
            {
                WideCharToMultiByte(
                                CP_ACP,
                                0,
                                pProjectionResult->nbf.wszWksta,
                                -1,
                                pConnObj->bComputerName,
                                sizeof( pConnObj->bComputerName ),
                                NULL,
                                NULL );

                if (pConnObj->bComputerName[NCBNAMSZ-1] == (WCHAR) 0x03)
                {
                    pConnObj->fFlags |= CONN_OBJ_MESSENGER_PRESENT;
                }
                
                pConnObj->bComputerName[NCBNAMSZ-1] = (WCHAR)NULL;
            }
        }

        //
        // Projections Activated OK 
        //

        pConnObj->PppProjectionResult = *pProjectionResult;

        pConnObj->fFlags |= CONN_OBJ_PROJECTIONS_NOTIFIED;

        //
        // Set this interface to connected if it is not already connected
        //

        dwRetCode = IfObjectConnected( 
                                    pConnObj->hDIMInterface, 
                                    pConnObj->hConnection, 
                                    &(pConnObj->PppProjectionResult) );
    
        //
        // If the interface does not exist anymore bring down this connection
        //

        if ( dwRetCode != NO_ERROR )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "Interface does not exist anymore" );

            PppDdmStop( pDeviceObj->hPort, NO_ERROR );

            ConnObjDisconnect( pConnObj );

            return;
        }

        GetSystemTimeAsFileTime( (FILETIME*)&(pConnObj->qwActiveTime) );

        if ( !AcceptNewConnection( pDeviceObj, pConnObj ) )
        {
            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "ERROR_ACCESS_DENIED" );

            PppDdmStop( pDeviceObj->hPort, ERROR_ACCESS_DENIED );

            ConnObjDisconnect( pConnObj );

            return;
        }
    }

    if ( !AcceptNewLink( pDeviceObj, pConnObj ) )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "ERROR_ACCESS_DENIED" );

        PppDdmStop( pDeviceObj->hPort, ERROR_ACCESS_DENIED );

        return;
    }

    //
    // Reduce the media count for this device
    //

    if ( !(pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE) )
    {
        if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
        {
            MediaObjRemoveFromTable( pDeviceObj->wchDeviceType );
        }

        pDeviceObj->fFlags |= DEV_OBJ_MARKED_AS_INUSE;
    
        gblDeviceTable.NumDevicesInUse++;

        //
        // Possibly need to notify the router managers of unreachability
        //

        EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

        IfObjectNotifyAllOfReachabilityChange( FALSE,
                                               INTERFACE_OUT_OF_RESOURCES );

        LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    }

    //
    // log authentication success, 18 is MSPPC
    //

    if ( ( pConnObj->PppProjectionResult.ccp.dwSendProtocol == 18 ) &&
         ( pConnObj->PppProjectionResult.ccp.dwReceiveProtocol == 18 ) )
    {
        if ( ( pConnObj->PppProjectionResult.ccp.dwReceiveProtocolData & 
                                            ( MSTYPE_ENCRYPTION_40  |
                                              MSTYPE_ENCRYPTION_40F |
                                              MSTYPE_ENCRYPTION_56  |
                                              MSTYPE_ENCRYPTION_128 ) ) &&
             ( pConnObj->PppProjectionResult.ccp.dwSendProtocolData & 
                                            ( MSTYPE_ENCRYPTION_40  |
                                              MSTYPE_ENCRYPTION_40F |
                                              MSTYPE_ENCRYPTION_56  |
                                              MSTYPE_ENCRYPTION_128 ) ) )
        {
            if ( ( pConnObj->PppProjectionResult.ccp.dwSendProtocolData & 
                                                    MSTYPE_ENCRYPTION_128 ) && 
                 ( pConnObj->PppProjectionResult.ccp.dwReceiveProtocolData & 
                                                    MSTYPE_ENCRYPTION_128 ) )
            {
                DDMLogInformation(ROUTERLOG_AUTH_SUCCESS_STRONG_ENCRYPTION,2,
                                  lpstrAudit);
            }
            else
            {
                DDMLogInformation(ROUTERLOG_AUTH_SUCCESS_ENCRYPTION,2,
                                  lpstrAudit);
            }
        }
        else
        {
            DDMLogInformation( ROUTERLOG_AUTH_SUCCESS, 2, lpstrAudit );
        }

        if(pProjectionResult->ip.dwError == ERROR_SUCCESS)
        {
            WCHAR  *pszIpAddress = 
                GetIpAddress(pProjectionResult->ip.dwRemoteAddress);

            if(NULL != pszIpAddress)
            {
                lpstrAudit[2] = pszIpAddress;
                DDMLogInformation(ROUTERLOG_IP_USER_CONNECTED, 3, lpstrAudit);
                LocalFree(pszIpAddress);
            }
        }
    }
    else
    {
        DDMLogInformation( ROUTERLOG_AUTH_SUCCESS, 2, lpstrAudit );

        if(pProjectionResult->ip.dwError == ERROR_SUCCESS)
        {
            WCHAR *pszIpAddress = GetIpAddress(
                            pProjectionResult->ip.dwRemoteAddress);
                            
            if(NULL != pszIpAddress)
            {
                lpstrAudit[2] = pszIpAddress;
                DDMLogInformation(ROUTERLOG_IP_USER_CONNECTED, 3, lpstrAudit);
                LocalFree(pszIpAddress);
            }
        }
    }

    //
    // and finaly go to ACTIVE state
    //

    pDeviceObj->DeviceState = DEV_OBJ_ACTIVE;

    pDeviceObj->dwTotalNumberOfCalls++;

    pDeviceObj->fFlags |= DEV_OBJ_PPP_IS_ACTIVE;

    //
    // and initialize the active time
    //

    GetSystemTimeAsFileTime( (FILETIME*)&(pDeviceObj->qwActiveTime) );

    //
    // Was this a connection for a BAP callback?
    //

    if ( pDeviceObj->fFlags & DEV_OBJ_BAP_CALLBACK )
    {
        PppDdmBapCallbackResult( pDeviceObj->hBapConnection, NO_ERROR );

        pDeviceObj->fFlags &= ~DEV_OBJ_BAP_CALLBACK;
    }


    return;
}

//**
//
// Call:        SvAddLinkToConnection
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called to actually add a new link that BAP has brought up.
//
VOID
SvAddLinkToConnection( 
    IN PDEVICE_OBJECT   pDeviceObj,
    IN HRASCONN         hRasConn
)
{
    CONNECTION_OBJECT * pConnObj;
    DWORD               dwRetCode;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvAddLinkToConnection: Entered, hPort=%d", pDeviceObj->hPort );

    //
    // Set this port to be notified by rasapi32 on disconnect.
    //

    dwRetCode = RasConnectionNotification(
                            hRasConn,
                            gblSupervisorEvents[NUM_DDM_EVENTS
                                + (gblDeviceTable.NumDeviceBuckets*2)
                                + DeviceObjHashPortToBucket(pDeviceObj->hPort)],
                            RASCN_Disconnection );

    if ( dwRetCode != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasConnectionNotification failed: %d", dwRetCode );

        return;
    }

    //
    // Get the HCONN bundle handle for this port
    //
                
    if ( RasPortGetBundle( NULL, 
                           pDeviceObj->hPort, 
                           &(pDeviceObj->hConnection) ) )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortGetBundle failed" );

        return;
    }

    if ( ( pConnObj = ConnObjGetPointer( pDeviceObj->hConnection ) ) == NULL )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "No ConnObj" );

        return;
    }
    
    if ( ( dwRetCode = ConnObjAddLink( pConnObj, pDeviceObj ) ) != NO_ERROR )
    {
        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );

        return;
    }

    //
    // Reduce the media count for this device
    //

    if ( !(pDeviceObj->fFlags & DEV_OBJ_MARKED_AS_INUSE) )
    {
        if ( pDeviceObj->fFlags & DEV_OBJ_ALLOW_ROUTERS )
        {
            MediaObjRemoveFromTable( pDeviceObj->wchDeviceType );
        }

        pDeviceObj->fFlags |= DEV_OBJ_MARKED_AS_INUSE;

        gblDeviceTable.NumDevicesInUse++;

        //
        // Possibly need to notify the router managers of unreachability
        //

        IfObjectNotifyAllOfReachabilityChange(FALSE,INTERFACE_OUT_OF_RESOURCES);
    }

    pDeviceObj->fFlags   |= DEV_OBJ_OPENED_FOR_DIALOUT;
    pDeviceObj->hRasConn = hRasConn;

    if ( pConnObj->InterfaceType == ROUTER_IF_TYPE_FULL_ROUTER )
    {
        RasSetRouterUsage( pDeviceObj->hPort, TRUE );
    }
}                      

//**
//
// Call:        SvDoBapCallbackRequest
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Called by BAP to initiate a callback to the remote peer
//
VOID
SvDoBapCallbackRequest( 
    IN PDEVICE_OBJECT   pDevObj,
    IN HCONN            hConnection,
    IN CHAR *           szCallbackNumber
)
{
    DWORD   dwRetCode;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "SvDoBapCallbackRequest: Entered, hPort=%d", pDevObj->hPort );

    //
    // Check to see if the device is available
    //

    if ( ( pDevObj->DeviceState != DEV_OBJ_LISTENING ) ||
         ( pDevObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT ) )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "Device not available" );

        PppDdmBapCallbackResult( hConnection, ERROR_PORT_NOT_AVAILABLE );

        return;
    }

    pDevObj->fFlags |= DEV_OBJ_IS_PPP;

    pDevObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTING;

    MultiByteToWideChar( CP_ACP,
                         0,
                         szCallbackNumber,
                         -1,
                         pDevObj->wchCallbackNumber,
                         MAX_PHONE_NUMBER_LEN + 1 );

    pDevObj->dwCallbackDelay = 10;

    pDevObj->hBapConnection = hConnection;

    pDevObj->fFlags |= DEV_OBJ_BAP_CALLBACK;

    RmDisconnect( pDevObj );
}

//***
//
//  Function:        PppEventHandler
//
//  Description:    receives the ppp messages and invokes the apropriate
//                    procedures in fsm.
//
//***
VOID 
PppEventHandler(
    VOID
)
{
    PPP_MESSAGE         PppMsg;
    PDEVICE_OBJECT      pDevObj;
    PCONNECTION_OBJECT  pConnObj;

    //
    // loop to get all messages
    //

    while( ServerReceiveMessage( MESSAGEQ_ID_PPP, (BYTE *)&PppMsg) )
    {
        EnterCriticalSection( &(gblDeviceTable.CriticalSection) );
            
        if ( PppMsg.dwMsgId == PPPDDMMSG_PnPNotification )
        {
            //
            // Port add/removal/change usage or protocol addition/removal
            // notifications.
            //

            DWORD dwPnPEvent = 
                 PppMsg.ExtraInfo.DdmPnPNotification.PnPNotification.dwEvent;

            RASMAN_PORT * pRasmanPort = 
                 &(PppMsg.ExtraInfo.DdmPnPNotification.PnPNotification.RasPort);

            switch( dwPnPEvent )
            {
            case PNPNOTIFEVENT_CREATE:
                if(pRasmanPort->P_ConfiguredUsage &
                    (CALL_IN | CALL_ROUTER | CALL_OUTBOUND_ROUTER))
                {                    
                    DeviceObjAdd( pRasmanPort );
                }
                break;

            case PNPNOTIFEVENT_REMOVE:
                DeviceObjRemove( pRasmanPort );
                break;

            case PNPNOTIFEVENT_USAGE:
                DeviceObjUsageChange( pRasmanPort );
                break;
            }

            LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

            continue;
        }
        else
        {
            //
            // Otherwise identify the port for which this event is received.
            //

            if ( ( pDevObj = DeviceObjGetPointer( PppMsg.hPort ) ) == NULL )
            {
                RTASSERT( pDevObj != NULL );

                LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

                continue;
            }
        }

        //
        // action on the message type
        //

        switch( PppMsg.dwMsgId )
        {
        case PPPDDMMSG_BapCallbackRequest:

            SvDoBapCallbackRequest( 
                        pDevObj,
                        PppMsg.ExtraInfo.BapCallbackRequest.hConnection,
                        PppMsg.ExtraInfo.BapCallbackRequest.szCallbackNumber );
        
            break;

        case PPPDDMMSG_PppDone:

            pDevObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);

            SvPppDone(pDevObj, &PppMsg.ExtraInfo.ProjectionResult);

            break;

        case PPPDDMMSG_CallbackRequest:

            SvPppCallbackRequest(pDevObj,&PppMsg.ExtraInfo.CallbackRequest);

            break;

        case PPPDDMMSG_Authenticated:

            SvPppUserOK(pDevObj, &PppMsg.ExtraInfo.AuthResult);

            break;

        case PPPDDMMSG_NewLink:

            SvPppNewLinkOrBundle( pDevObj, FALSE, NULL, NULL, NULL, FALSE );

            break;
            
        case PPPDDMMSG_NewBundle:

            if(NULL != IfObjectGetPointerByName(
                    pDevObj->wchUserName, FALSE))
            {
                MprInfoDelete(PppMsg.ExtraInfo.DdmNewBundle.pClientInterface);
                PppMsg.ExtraInfo.DdmNewBundle.pClientInterface = NULL;
                MprInfoDelete(PppMsg.ExtraInfo.DdmNewBundle.pQuarantineIPFilter);
                PppMsg.ExtraInfo.DdmNewBundle.pQuarantineIPFilter = NULL;
                MprInfoDelete(PppMsg.ExtraInfo.DdmNewBundle.pFilter);
                PppMsg.ExtraInfo.DdmNewBundle.pFilter = NULL;
                PppMsg.ExtraInfo.DdmNewBundle.fQuarantinePresent = FALSE;
            }

            SvPppNewLinkOrBundle( 
                        pDevObj, 
                        TRUE, 
                        PppMsg.ExtraInfo.DdmNewBundle.pClientInterface,
                        PppMsg.ExtraInfo.DdmNewBundle.pQuarantineIPFilter,
                        PppMsg.ExtraInfo.DdmNewBundle.pFilter,
                        PppMsg.ExtraInfo.DdmNewBundle.fQuarantinePresent);

            if ( PppMsg.ExtraInfo.DdmNewBundle.pClientInterface != NULL )
            {
                MprInfoDelete( PppMsg.ExtraInfo.DdmNewBundle.pClientInterface );
            }

            break;

        case PPPDDMMSG_PppFailure: 

            pDevObj->fFlags &= (~DEV_OBJ_AUTH_ACTIVE);

            switch( PppMsg.ExtraInfo.DdmFailure.dwError )
            {
            case NO_ERROR:
            case ERROR_IDLE_DISCONNECTED:
                pDevObj->dwDisconnectReason = DDM_IDLE_DISCONNECT;
                break;
            case ERROR_PPP_SESSION_TIMEOUT:
                pDevObj->dwDisconnectReason = DDM_SESSION_TIMEOUT;
                break;

            default:
                pDevObj->dwDisconnectReason = 0;
                SvPppFailure( pDevObj, &PppMsg.ExtraInfo.DdmFailure );
            }

            PppDdmStop( pDevObj->hPort, PppMsg.ExtraInfo.DdmFailure.dwError );

            break;

        case PPPDDMMSG_Stopped:

            if ( ( pDevObj->DeviceState != DEV_OBJ_CLOSING ) &&
                 ( pDevObj->DeviceState != DEV_OBJ_LISTENING ) )
            {
                DevStartClosing( pDevObj );
            }

            break;

        case PPPDDMMSG_PortCleanedUp:

            if ( pDevObj->DeviceState != DEV_OBJ_LISTENING )
            {
                pDevObj->fFlags &= (~DEV_OBJ_PPP_IS_ACTIVE); 

                if ( pDevObj->DeviceState != DEV_OBJ_CLOSING )
                {
                    DevStartClosing( pDevObj );
                }
                else
                {
                    DevCloseComplete( pDevObj );
                }
            }

            break;

        case PPPDDMMSG_NewBapLinkUp:

            SvAddLinkToConnection( pDevObj, 
                                   PppMsg.ExtraInfo.BapNewLinkUp.hRasConn );

            break;         

        default:

            RTASSERT(FALSE);
            break;
        }

        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\rasmanif.c ===
/********************************************************************/
/*          Copyright(c)  1992 Microsoft Corporation                    */
/********************************************************************/

//***
//
// Filename:    rasmanif.c
//
// Description: This module contains the i/f procedures with the
//                RasManager
//
// Author:    Stefan Solomon (stefans)    May 26, 1992.
//
// Revision History:
//
//***
#include "ddm.h"
#include "util.h"
#include "objects.h"
#include <raserror.h>
#include <ddmif.h>
#include <string.h>
#include <rasmxs.h>
#include "rasmanif.h"
#include "handlers.h"

//***
//
//  Function:        RmInit
//
//  Description:    Called only at service start time.
//                    Does RasPortEnum, allocates global memory for the
//                  Device Table, opens every dialin port and copies the port
//                  handle and port name into the dcb struct.
//                  Finally, deallocates the buffers (for port enum) and returns.
//
//  Returns:        NO_ERROR - Success
//                  otherwise - Failure
//
//***
DWORD
RmInit(
    OUT BOOL * pfWANDeviceInstalled
)
{
    DWORD           dwIndex;
    DWORD           dwRetCode;
    HPORT           hPort;
    PDEVICE_OBJECT  pDevObj;
    BYTE *          pBuffer     = NULL;
    DWORD           dwBufferSize = 0;
    DWORD           dwNumEntries = 0;
    RASMAN_PORT*    pRasmanPort;

    *pfWANDeviceInstalled = FALSE;

    do
    {
        //
        // get the buffer size needed for RasPortEnum
        //

        dwRetCode = RasPortEnum( NULL, NULL, &dwBufferSize, &dwNumEntries );

        if ( dwRetCode == ERROR_BUFFER_TOO_SMALL )
        {
            //
            // If there are ports installed, allocate buffer to get them
            //

            if (( pBuffer = (BYTE *)LOCAL_ALLOC( LPTR, dwBufferSize ) ) == NULL)
            {
                //
                // can't allocate the enum buffer
                //

                dwRetCode = GetLastError();

                DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);

                break;
            }

            //
            // get the real enum data
            //

            dwRetCode = RasPortEnum( NULL,
                                     pBuffer,
                                     &dwBufferSize,
                                     &dwNumEntries );

            if ( dwRetCode != NO_ERROR )
            {
                //
                // can't enumerate ports
                //

                DDMLogErrorString(ROUTERLOG_CANT_ENUM_PORTS,0,NULL,dwRetCode,0);

                break;
            }
        }
        else if ( dwRetCode == NO_ERROR )
        {
            //
            // Otherwise there were no ports installed
            //

            dwNumEntries = 0;
        }
        else
        {
            DDMLogErrorString(ROUTERLOG_CANT_ENUM_PORTS,0,NULL,dwRetCode,0);

            break;
        }

        //
        // Allocate device hash table
        //

        if ( dwNumEntries < MIN_DEVICE_TABLE_SIZE )
        {
            gblDeviceTable.NumDeviceBuckets = MIN_DEVICE_TABLE_SIZE;
        }
        else if ( dwNumEntries > MAX_DEVICE_TABLE_SIZE )
        {
            gblDeviceTable.NumDeviceBuckets = MAX_DEVICE_TABLE_SIZE;
        }
        else
        {
            gblDeviceTable.NumDeviceBuckets = dwNumEntries;
        }

        gblDeviceTable.DeviceBucket = (PDEVICE_OBJECT *)LOCAL_ALLOC( LPTR,
                                        gblDeviceTable.NumDeviceBuckets
                                        * sizeof( PDEVICE_OBJECT ) );

        if ( gblDeviceTable.DeviceBucket == (PDEVICE_OBJECT *)NULL )
        {
            dwRetCode = GetLastError();

            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);

            break;
        }

        //
        // Set number of connection buckets to number of device buckets.
        // Since Number of devices >= Number of connections.
        //

        gblDeviceTable.NumConnectionBuckets = gblDeviceTable.NumDeviceBuckets;

        //
        // Allocate bundle or connection table
        //

        gblDeviceTable.ConnectionBucket = (PCONNECTION_OBJECT*)LOCAL_ALLOC(LPTR,
                                          gblDeviceTable.NumConnectionBuckets
                                          * sizeof( PCONNECTION_OBJECT ) );

        if ( gblDeviceTable.ConnectionBucket == (PCONNECTION_OBJECT *)NULL )
        {
            dwRetCode = GetLastError();

            DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);

            break;
        }

        //
        // For each device object, try to open the port.
        // If port can't be opened, skip and go to next port.
        //

        for ( dwIndex = 0, pRasmanPort = (RASMAN_PORT *)pBuffer;
              dwIndex < dwNumEntries;
              dwIndex++, pRasmanPort++)
        {
            //
            // only ports enabled for incoming or router connections
            // are added to the device table
            //
            
            if (pRasmanPort->P_ConfiguredUsage & 
                (CALL_IN | CALL_ROUTER | CALL_IN_ONLY | 
                    CALL_OUTBOUND_ROUTER))
            {
                dwRetCode = RasPortOpen(pRasmanPort->P_PortName, &hPort, NULL);

                if ( dwRetCode != NO_ERROR )
                {
                    //
                    // Failed to open an port on which incoming 
                    // connections are enabled.  Log an error and
                    // continue to the next port
                    //
                    
                    WCHAR  wchPortName[MAX_PORT_NAME+1];
                    LPWSTR lpwsAuditStr[1];

                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         pRasmanPort->P_PortName,
                                         -1,
                                         wchPortName, 
                                         MAX_PORT_NAME+1 );

                    //
                    // Log an error
                    //

                    lpwsAuditStr[0] = wchPortName;

                    DDMLogErrorString( ROUTERLOG_UNABLE_TO_OPEN_PORT, 1,
                                       lpwsAuditStr, dwRetCode, 1 );

                    dwRetCode = NO_ERROR;                                       

                    continue;
                }

                //
                // Don't insert the device into the hash table if the device
                // doesn't support incoming/router calls.
                //
                // Note:
                //  Per DCR 349087 we need to enable outbound-only DoD on 
                //  PPPoE connections.  These ports are identified as
                //  having usage CALL_OUTBOUND_ROUTER.
                //

                if ((pRasmanPort->P_ConfiguredUsage & 
                    (CALL_IN | CALL_ROUTER | CALL_OUTBOUND_ROUTER)))
                {
                    pDevObj = DeviceObjAllocAndInitialize( hPort, pRasmanPort );

                    if ( pDevObj == (DEVICE_OBJECT *)NULL )
                    {
                        dwRetCode = GetLastError();

                        DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY,0,
                                    NULL,dwRetCode);

                        break;
                    }

                    //
                    // Insert into the device hash table
                    //

                    DeviceObjInsertInTable( pDevObj );

                    if (RAS_DEVICE_CLASS( pDevObj->dwDeviceType ) != RDT_Direct)
                    {
                        *pfWANDeviceInstalled = TRUE;
                    }
                }
            }
        }

    } while ( FALSE );

    if ( pBuffer != NULL )
    {
        LOCAL_FREE( pBuffer );
    }

    return( dwRetCode );
}

//***
//
//  Function:    RmReceiveFrame
//
//  Descr:
//
//***

DWORD
RmReceiveFrame(
    IN PDEVICE_OBJECT pDevObj
)
{
    DWORD    dwRetCode;
    DWORD   dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

    RTASSERT( pDevObj->pRasmanRecvBuffer != NULL );

    dwRetCode = RasPortReceive(
                    pDevObj->hPort,
                    pDevObj->pRasmanRecvBuffer ,
                    &(pDevObj->dwRecvBufferLen),
                    0L,               //no timeout
                    gblSupervisorEvents[NUM_DDM_EVENTS
                                        + gblDeviceTable.NumDeviceBuckets
                                        + dwBucketIndex] );

    if ( ( dwRetCode == NO_ERROR ) || ( dwRetCode == PENDING ) )
    {
        pDevObj->fFlags |= DEV_OBJ_RECEIVE_ACTIVE;

        dwRetCode = NO_ERROR;
    }

    return( dwRetCode );
}

//***
//
//  Function:    RmListen
//
//  Descr:
//
//***
DWORD
RmListen(
    IN PDEVICE_OBJECT pDevObj
)
{
    DWORD dwRetCode     = NO_ERROR;
    DWORD dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

    //RTASSERT(pDevObj->ConnectionState == DISCONNECTED);

    //
    // If this is an L2TP tunnel port type and we have to use
    // IPSEC, then go ahead and set the filter
    //

    if ( RAS_DEVICE_TYPE( pDevObj->dwDeviceType ) == RDT_Tunnel_L2tp )
    {
        dwRetCode = RasEnableIpSec( 
                pDevObj->hPort,
                TRUE,
                TRUE, 
                (gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireIPSEC)
                ? RAS_L2TP_REQUIRE_ENCRYPTION
                : RAS_L2TP_OPTIONAL_ENCRYPTION);

        // RTASSERT( dwRetCode == NO_ERROR );

        DDMTRACE2( "Enabled IPSec on port %d, dwRetCode = %d",
                   pDevObj->hPort, dwRetCode );

        //
        // Log the non certificate errorlog only once
        //
        
        if ( dwRetCode == ERROR_NO_CERTIFICATE )
        {
            if ( !( gblDDMConfigInfo.fFlags & DDM_NO_CERTIFICATE_LOGGED ) )
            {
                DDMLogWarning( ROUTERLOG_NO_IPSEC_CERT, 0, NULL );

                gblDDMConfigInfo.fFlags |= DDM_NO_CERTIFICATE_LOGGED;
            }

            return( dwRetCode );
        }

        if(     (dwRetCode != NO_ERROR)
            &&  !(pDevObj->fFlags & DEV_OBJ_IPSEC_ERROR_LOGGED))
        {
            WCHAR       wchPortName[MAX_PORT_NAME+1];
            LPWSTR      lpwsAuditStr[1];
            RASMAN_INFO rInfo;
            DWORD       rc;

            ZeroMemory(&rInfo, sizeof(RASMAN_INFO));

            rc = RasGetInfo(NULL, pDevObj->hPort, &rInfo);

            if(rc != NO_ERROR)
            {
                return (NO_ERROR);
            }   

            MultiByteToWideChar( CP_ACP,
                                 0,
                                 rInfo.RI_szPortName, 
                                 -1,
                                 wchPortName,
                                 MAX_PORT_NAME+1 );

            lpwsAuditStr[0] = wchPortName;
            
            DDMLogWarningString(ROUTERLOG_IPSEC_FILTER_FAILURE, 
                                1, lpwsAuditStr, dwRetCode, 1);

            pDevObj->fFlags |= DEV_OBJ_IPSEC_ERROR_LOGGED;                        
        }
        else
        {
            //
            // Clear the flag so that if we hit this error again
            // we do an eventlog
            //
            pDevObj->fFlags &= ~DEV_OBJ_IPSEC_ERROR_LOGGED;
        }
    }

    if (( dwRetCode == NO_ERROR ) &&
        (( RAS_DEVICE_TYPE( pDevObj->dwDeviceType ) != RDT_PPPoE ) ||
          (RAS_DEVICE_TYPE(pDevObj->dwDeviceType) == RDT_PPPoE) &&
          (pDevObj->fFlags & DEV_OBJ_ALLOW_CLIENTS))
          )
    {
        pDevObj->ConnectionState = LISTENING;

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RmListen: Listen posted on port %d", pDevObj->hPort);

        dwRetCode = RasPortListen(
                        pDevObj->hPort,
                        INFINITE,
                        gblSupervisorEvents[NUM_DDM_EVENTS + dwBucketIndex] );

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                   "RasPortListen dwRetCode=%d", dwRetCode);

        RTASSERT((dwRetCode == SUCCESS) || (dwRetCode == PENDING));

        if ( dwRetCode == PENDING )
        {
            dwRetCode = NO_ERROR;
        }
    }
    else if ((dwRetCode == NO_ERROR) &&
            (RAS_DEVICE_TYPE(pDevObj->dwDeviceType) == RDT_PPPoE))
    {
        pDevObj->DeviceState = DEV_OBJ_CLOSED;
    }

    return( dwRetCode );
}

//***
//
//  Function:    RmConnect
//
//  Descr:
//
//***

DWORD
RmConnect(
    IN PDEVICE_OBJECT pDevObj,
    IN char *cbphno      // callback number
    )
{
    RASMAN_DEVICEINFO    devinfo;
    RAS_PARAMS            *paramp;
    char            *phnokeyname;
    DWORD            rc;
    DWORD           dwBucketIndex;
    CHAR            chDeviceType[MAX_DEVICETYPE_NAME+1];
    CHAR            chDeviceName[MAX_DEVICE_NAME+1];
    CHAR            *pszMungedPhNo = NULL;
    DWORD           dwSizeofMungedPhNo;

    WideCharToMultiByte( CP_ACP,
                         0,
                         pDevObj->wchDeviceType, 
                         -1,
                         chDeviceType, 
                         sizeof( chDeviceType ),
                         NULL,
                         NULL );

    WideCharToMultiByte( CP_ACP,
                         0,
                         pDevObj->wchDeviceName, 
                         -1,
                         chDeviceName, 
                         sizeof( chDeviceName ), 
                         NULL,
                         NULL );

    dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

    phnokeyname = MXS_PHONENUMBER_KEY;

    RTASSERT(pDevObj->ConnectionState == DISCONNECTED);

    pDevObj->ConnectionState = CONNECTING;

    // set up the deviceinfo structure for callback
    devinfo.DI_NumOfParams = 1;
    paramp = &devinfo.DI_Params[0];
    strcpy(paramp->P_Key, phnokeyname);
    paramp->P_Type = String;
    paramp->P_Attributes = 0;

    pszMungedPhNo = cbphno;
    dwSizeofMungedPhNo = strlen(cbphno) + 1;
    
    //
    // Munge the phonenumber if required
    //
    if(     (RDT_Tunnel == RAS_DEVICE_CLASS(pDevObj->dwDeviceType))
        &&  (   (0 != gblDDMConfigInfo.cDigitalIPAddresses)
            ||  (0 != gblDDMConfigInfo.cAnalogIPAddresses)))
    {
        //
        // Munge cbphno
        //
        rc = MungePhoneNumber(
                cbphno,
                pDevObj->dwIndex,
                &dwSizeofMungedPhNo,
                &pszMungedPhNo);

        if(ERROR_SUCCESS != rc)
        {
            //
            // fall back to whatever was passed
            //
            pszMungedPhNo = cbphno;
            dwSizeofMungedPhNo = strlen(cbphno);
        }        
    }
    else if(RDT_Modem == RAS_DEVICE_TYPE(pDevObj->dwDeviceType))
    {
        BOOL fPulse = FALSE;
        
        //
        // Check to see if we need to pulsedial. Error returned
        // can be ignored - theres nothing much we can do anyway.
        // We default to Tone.
        //
        (void) RasIsPulseDial(pDevObj->hPort, &fPulse);

        if(fPulse)
        {
            //
            // +2 is for '\0' and 'P'
            //
            dwSizeofMungedPhNo = strlen(cbphno) + 2;
            pszMungedPhNo = LocalAlloc(LPTR, dwSizeofMungedPhNo);
            if(NULL == pszMungedPhNo)
            {
                rc = GetLastError();
                return rc;
            }
            
            sprintf(pszMungedPhNo, "P%s", cbphno);
        }
    }
    
    paramp->P_Value.String.Length = dwSizeofMungedPhNo;
    paramp->P_Value.String.Data = pszMungedPhNo;

    rc = RasDeviceSetInfo(pDevObj->hPort, chDeviceType, chDeviceName, &devinfo);

    if(pszMungedPhNo != cbphno)
    {
        LocalFree(pszMungedPhNo);
    }
    
    if ( rc != SUCCESS )
    {
        RTASSERT( FALSE );

        return( rc );
    }

#if 0
    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "RmConnect:Connecting to %s, size %d", 
               pszMungedPhNo,
               dwSizeofMungedPhNo);
#endif


    rc = RasDeviceConnect(
            pDevObj->hPort,
            chDeviceType,
            chDeviceName,
            120,
            gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex]
            );

    RTASSERT ((rc == PENDING) || (rc == SUCCESS));

    if ( rc == PENDING )
    {
        rc = NO_ERROR;
    }

    return( rc );
}

//***
//
//  Function:    RmDisconnect
//
//  Descr:
//
//***
DWORD
RmDisconnect(
    IN PDEVICE_OBJECT pDevObj
)
{
    DWORD dwRetCode;
    DWORD dwBucketIndex = DeviceObjHashPortToBucket( pDevObj->hPort );

    if (pDevObj->ConnectionState == DISCONNECTED)
    {
        return(0);
    }
    else
    {
        pDevObj->ConnectionState = DISCONNECTING;
    }

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "RmDisconnect:Disconnect posted on port %d", pDevObj->hPort);

    dwRetCode = RasPortDisconnect(
                            pDevObj->hPort,
                            gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex] );

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "RasPortDisconnect rc=%li", dwRetCode );

    if ((dwRetCode != PENDING) && (dwRetCode != SUCCESS))
    {
        // DbgPrint("RmDisconnect: dwRetCode = 0x%lx\n",dwRetCode);
    }

    if ( dwRetCode == PENDING )
    {
        dwRetCode = NO_ERROR;
    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\rasmanif.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	rasmanif.h
//
// Description: This module contains the definitions for
//		the ras manager interface module.
//
// Author:	Stefan Solomon (stefans)    June 1, 1992.
//
// Revision History:
//
//***

#ifndef _RASMANIF_
#define _RASMANIF_


//*** maximum size of received frame requested ***

#define MAX_FRAME_SIZE		1514



//*** Ras Manager Interface Exported Prototypes ***

DWORD 
RmInit(
    OUT BOOL * pfWANDeviceInstalled
);

DWORD 
RmReceiveFrame(
    IN PDEVICE_OBJECT pDeviceCB
);

DWORD 
RmListen(
    IN PDEVICE_OBJECT pDeviceCB
);

DWORD 
RmConnect(
    IN PDEVICE_OBJECT pDeviceCB,
    IN char *
);

DWORD 
RmDisconnect(
    IN PDEVICE_OBJECT   pDevObj
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\routerif.c ===
/*********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	        **/
/*********************************************************************/

//***
//
// Filename:    routerif.c
//
// Description: Handles calls to/from the router managers. 
//
// History:     May 11,1995     NarenG      Created original version.
//
#include "ddm.h"
#include "util.h"
#include "objects.h"
#include "routerif.h"
#include "rasapiif.h"

//**
//
// Call:        DDMConnectInterface
//
// Returns:     NO_ERROR    - Already connected
//              PENDING     - Connection initiated successfully
//              error code  - Connection initiation failure
//
// Description: Called by a router manager to intiate a connection.
//
DWORD
DDMConnectInterface(
    IN  HANDLE  hDDMInterface,
    IN  DWORD   dwProtocolId  
)
{
    DWORD                     dwRetCode = NO_ERROR;
    ROUTER_INTERFACE_OBJECT * pIfObject; 
    DWORD                     dwTransportIndex=GetTransportIndex(dwProtocolId);

    RTASSERT( dwTransportIndex != (DWORD)-1 );

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hDDMInterface );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            dwRetCode = ERROR_INVALID_HANDLE;

            break;
        }

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	       "DDMConnectInterface:Called by protocol=0x%x,State=%d,Interface=%ws",
            dwProtocolId, pIfObject->State, pIfObject->lpwsInterfaceName );

        switch( pIfObject->State )
        {
        case RISTATE_CONNECTED:

            if ( pIfObject->Transport[dwTransportIndex].fState &
                                                        RITRANSPORT_CONNECTED )
            {
                dwRetCode = ERROR_ALREADY_CONNECTED;
            }
            else
            {
                dwRetCode = ERROR_PROTOCOL_NOT_CONFIGURED;
            }

            break;

        case RISTATE_CONNECTING:

            dwRetCode = PENDING;

            break;

        case RISTATE_DISCONNECTED:

            //
            // Initiate a connection
            //

            dwRetCode = RasConnectionInitiate( pIfObject, FALSE );

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	                   "RasConnectionInitiate: To %ws dwRetCode=%d",
                        pIfObject->lpwsInterfaceName, dwRetCode );
            
            if ( dwRetCode == NO_ERROR )
            {
                dwRetCode = PENDING;
            }
            else
            {
                LPWSTR  lpwsAudit[1];

		        lpwsAudit[0] = pIfObject->lpwsInterfaceName;

		        DDMLogErrorString( ROUTERLOG_CONNECTION_FAILURE, 
                                   1, lpwsAudit, dwRetCode, 1 );

            }

            break;
        }

    } while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "DDMConnectInterface: dwRetCode=%d", dwRetCode );

    return( dwRetCode );
}

//**
//
// Call:        DDMDisconnectInterface
//
// Returns:     NO_ERROR    - Already disconnected
//              PENDING     - Disconnection initiated successfully
//              error code  - Disconnection initiation failure
//
// Description: Called by a router manager to intiate a disconnection.
//
DWORD
DDMDisconnectInterface(
    IN  HANDLE  hDDMInterface,
    IN  DWORD   dwProtocolId 
)
{
    DWORD                      dwRetCode = NO_ERROR;
    ROUTER_INTERFACE_OBJECT *  pIfObject; 
    HCONN                      hConnection;
    DWORD                      dwTransportIndex=GetTransportIndex(dwProtocolId);
    PCONNECTION_OBJECT         pConnObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hDDMInterface );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            dwRetCode = ERROR_INVALID_HANDLE;

            break;
        }

        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	    "DDMDisconnectInterface:Called by protocol=0x%x,State=%d,Interface=%ws",
        dwProtocolId, pIfObject->State, pIfObject->lpwsInterfaceName );

        if ( dwTransportIndex != -1 )
        {
            pIfObject->Transport[dwTransportIndex].fState &=
                                                        ~RITRANSPORT_CONNECTED;
        }

        switch( pIfObject->State )
        {

        case RISTATE_DISCONNECTED:

            //
            // Already disconnected
            //

            dwRetCode = NO_ERROR;

            break;

        case RISTATE_CONNECTING:
            
            //
            // Disconnect only if all transports are disconnected
            //

            if ( !IfObjectAreAllTransportsDisconnected( pIfObject ) )
            {
                break;
            }

            //
            // Abort locally initiated connections
            //

            if ( pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED )
            {
                pIfObject->fFlags |= IFFLAG_DISCONNECT_INITIATED;

                if ( pIfObject->hRasConn != (HRASCONN)NULL )
                {
                    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                    "DDMDisconnectInterface: %d hanging up 0x%x",
                    __LINE__,
                    pIfObject->hRasConn);
                    RasHangUp( pIfObject->hRasConn );
                }

                IfObjectDisconnected( pIfObject );

                //
                // We need to notify router managers that the connection has
                // failed since the administrator has cancelled the connection
                // while in connecting state. This is usually called in the
                // RasConnectCallback routine, but we my not be actually 
                // connecting at this time so we cannot rely on the callback
                // to do this.
                //

                IfObjectNotifyOfReachabilityChange(     
                                                pIfObject,
                                                FALSE,
                                                INTERFACE_CONNECTION_FAILURE );

                //
                // Immediately go back to reachable state since it was the
                // admin that disconnected the line
                //

                IfObjectNotifyOfReachabilityChange(     
                                                pIfObject,
                                                TRUE,
                                                INTERFACE_CONNECTION_FAILURE );
            }
            else
            {
                //
                // Not yet connected, we do not support abort
                //

                dwRetCode = ERROR_INTERFACE_NOT_CONNECTED;
            }

            break;

        case RISTATE_CONNECTED:

            //
            // Initiate a disconnection if all other routers are disconnected
            //

            if ( !IfObjectAreAllTransportsDisconnected( pIfObject ) )
            {
                break;
            }

            if ( pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED )
            {
                pIfObject->fFlags |= IFFLAG_DISCONNECT_INITIATED;

                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                "DDMDisconnectInterface: %d disconnecting 0x%x",
                __LINE__, pIfObject->hRasConn);
                
                RasHangUp( pIfObject->hRasConn );
            }

            pConnObj = ConnObjGetPointer( pIfObject->hConnection );

            if ( pConnObj != (PCONNECTION_OBJECT)NULL )
            {
                if((pIfObject->fFlags & IFFLAG_DISCONNECT_INITIATED) &&
                   (pIfObject->fFlags & IFFLAG_LOCALLY_INITIATED))
                {
                    pConnObj->fFlags |= CONN_OBJ_DISCONNECT_INITIATED;
                }
                
                DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                "DDMDisconnectInterface: disconnecting connobj");
                
                ConnObjDisconnect( pConnObj );
            }

            break;
        }

    } while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "DDMDisconnectInterface: dwRetCode=%d", dwRetCode );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\rmhand.c ===
/*******************************************************************/
/*	      Copyright(c)  1995 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	rmhand.c
//
// Description: This module contains the procedures for the
//		        DDM's procedure-driven state machine
//              that handles RasMan events.
//
//              NOTE:Rasman should be modified to set a flag when a frame is
//                   received or and state change has occurred. This will save
//                   DDM from getting info for all the ports.
//
// Author:	    Stefan Solomon (stefans)    May 26, 1992.
//
//***
#include "ddm.h"
#include "timer.h"
#include "handlers.h"
#include "objects.h"
#include "util.h"
#include "routerif.h"
#include <raserror.h>
#include <rasppp.h>
#include <ddmif.h>
#include <serial.h>
#include "rasmanif.h"
#include <ras.h>
#include <string.h>
#include <stdlib.h>
#include <memory.h>

//***
//
//  Function:       SvDevConnected
//
//  Description:	Handles the device transition to connected state
//
//***
VOID
SvDevConnected(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    PCONNECTION_OBJECT  pConnObj;
    HCONN               hConnection;
    DWORD               dwRetCode;
    LPWSTR              auditstrp[3];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "SvDevConnected: Entered, hPort=%d", pDeviceObj->hPort);

    //
    // Get handle to the connection or bundle for this link
    //

    if ( RasPortGetBundle( NULL,
                           pDeviceObj->hPort,
                           &hConnection ) != NO_ERROR )
    {
	    DevStartClosing(pDeviceObj);

        return;
    }


    switch (pDeviceObj->DeviceState)
    {
	case DEV_OBJ_LISTEN_COMPLETE:

        pDeviceObj->hConnection = hConnection;

        //
	    // reset the H/W Error signal state
        //

	    pDeviceObj->dwHwErrorSignalCount = HW_FAILURE_CNT;

        //
	    // get the system time for this connection
        //

	    GetLocalTime( &pDeviceObj->ConnectionTime );

        //
	    // get the frame broadcasted by the client
        //

	    if ( ( dwRetCode = RmReceiveFrame( pDeviceObj ) ) != NO_ERROR )
        {
            //
		    // can't get the broadcast frame. This is a fatal error
		    // Log the error
            //

		    auditstrp[0] = pDeviceObj->wchPortName;

		    DDMLogErrorString( ROUTERLOG_CANT_RECEIVE_FRAME, 1, auditstrp,
                               dwRetCode, 1);

		    DevStartClosing( pDeviceObj );
	    }
	    else
	    {
            //
		    // switch to frame receiving state
            //

		    pDeviceObj->DeviceState = DEV_OBJ_RECEIVING_FRAME;

            if ( RAS_DEVICE_TYPE( pDeviceObj->dwDeviceType ) != RDT_Atm )
            {
                //
		        // start authentication timer
                //

		        TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

		        TimerQInsert( (HANDLE)pDeviceObj->hPort,
                              gblDDMConfigInfo.dwAuthenticateTime,
                              SvAuthTimeout );
            }
	    }

	    break;

	case DEV_OBJ_CALLBACK_CONNECTING:

        {

        //
        // log on the client disconnection
        //

        WCHAR   wchFullUserName[UNLEN+DNLEN+2];

        if ( pDeviceObj->wchDomainName[0] != TEXT('\0') )
        {
            wcscpy( wchFullUserName, pDeviceObj->wchDomainName );
            wcscat( wchFullUserName, TEXT("\\") );
            wcscat( wchFullUserName, pDeviceObj->wchUserName );
        }
        else
        {
            wcscpy( wchFullUserName, pDeviceObj->wchUserName );
        }

        auditstrp[0] = wchFullUserName;
        auditstrp[1] = pDeviceObj->wchPortName;
        auditstrp[2] = pDeviceObj->wchCallbackNumber;

        DDMLogInformation( ROUTERLOG_CLIENT_CALLED_BACK, 3, auditstrp);

        }

        //
	    // set up the new state
        //

	    pDeviceObj->DeviceState = DEV_OBJ_AUTH_IS_ACTIVE;

        //
	    // start authentication timer
        //

	    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvAuthTimeout );

	    TimerQInsert( (HANDLE)pDeviceObj->hPort,
                      gblDDMConfigInfo.dwAuthenticateTime,
                      SvAuthTimeout );

        //
	    // and tell auth to restart conversation
        //

        if ( pDeviceObj->fFlags & DEV_OBJ_IS_PPP )
        {
            //
            // Need to set framing to PPP to make callback over ISDN
            // work.
            //

            RAS_FRAMING_INFO RasFramingInfo;

            ZeroMemory( &RasFramingInfo, sizeof( RasFramingInfo ) );

            //
            // Default ACCM for PPP is 0xFFFFFFFF
            //

            RasFramingInfo.RFI_RecvACCM         = 0xFFFFFFFF;
            RasFramingInfo.RFI_SendACCM         = 0xFFFFFFFF;
            RasFramingInfo.RFI_MaxSendFrameSize = 1500;
            RasFramingInfo.RFI_MaxRecvFrameSize = 1500;
            RasFramingInfo.RFI_SendFramingBits  = PPP_FRAMING;
            RasFramingInfo.RFI_RecvFramingBits  = PPP_FRAMING;

            RasPortSetFramingEx( pDeviceObj->hPort, &RasFramingInfo );

            pDeviceObj->hConnection = hConnection;

            PppDdmCallbackDone(pDeviceObj->hPort, pDeviceObj->wchCallbackNumber);
        }
        else
        {
            // We only suport PPP framing in the server
            //
            
            RTASSERT(FALSE);
        }

	    break;

	default:

	    break;
    }
}

//***
//
//  Function:	SvDevDisconnected
//
//  Descr:	Handles the device transition to disconnected state
//
//***

VOID
SvDevDisconnected(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "SvDevDisconnected:Entered, hPort=%d",pDeviceObj->hPort);

    switch (pDeviceObj->DeviceState)
    {
	case DEV_OBJ_LISTENING:

        //
	    // h/w error; start h/w error timer
        //

	    pDeviceObj->DeviceState = DEV_OBJ_HW_FAILURE;

	    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvHwErrDelayCompleted );

	    TimerQInsert( (HANDLE)pDeviceObj->hPort, HW_FAILURE_WAIT_TIME,
                      SvHwErrDelayCompleted );

        //
	    // if hw error has not been signaled for this port,
	    // decrement the counter and signal when 0
        //

	    if(pDeviceObj->dwHwErrorSignalCount)
        {
		    pDeviceObj->dwHwErrorSignalCount--;

		    if(pDeviceObj->dwHwErrorSignalCount == 0)
            {
		        SignalHwError(pDeviceObj);
		    }
	    }

	    break;

	case DEV_OBJ_CALLBACK_DISCONNECTING:

        //
	    // disconnection done; can start waiting the callback delay
        //

	    pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTED;

	    TimerQRemove( (HANDLE)pDeviceObj->hPort, SvCbDelayCompleted );

	    TimerQInsert( (HANDLE)pDeviceObj->hPort, pDeviceObj->dwCallbackDelay,
                          SvCbDelayCompleted);

	    break;

	case DEV_OBJ_CALLBACK_CONNECTING:

        if (gblDDMConfigInfo.dwCallbackRetries > pDeviceObj->dwCallbackRetries)
        {
            DDMTRACE( "Callback failed, retrying" );

            pDeviceObj->dwCallbackRetries++;

            pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_DISCONNECTED;

            TimerQRemove( (HANDLE)pDeviceObj->hPort, SvCbDelayCompleted );

            TimerQInsert( (HANDLE)pDeviceObj->hPort,
                          pDeviceObj->dwCallbackDelay,
                          SvCbDelayCompleted );
            break;
        }

    case DEV_OBJ_LISTEN_COMPLETE:
	case DEV_OBJ_RECEIVING_FRAME:
	case DEV_OBJ_AUTH_IS_ACTIVE:

        //
	    // accidental disconnection; clean-up and restart on this device
        //

	    DevStartClosing( pDeviceObj );

	    break;

	case DEV_OBJ_ACTIVE:

	    DevStartClosing(pDeviceObj);

	    break;

	case DEV_OBJ_CLOSING:

	    DevCloseComplete(pDeviceObj);
	    break;

	default:

	    break;
    }
}

VOID
SvDevListenComplete(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    LPWSTR  auditstrp[1];
    DWORD   dwLength;
    DWORD   dwRetCode;
    DWORD   dwBucketIndex = DeviceObjHashPortToBucket( pDeviceObj->hPort );

    //
    // We reset these values here is case they were set for dialout and the
    // dialout failed, we may have not been able to clean up in
    // the RasConnectCallback routine in rasapiif.c since the
    // RasGetSubEntryHandle may have failed and we hence do not get a
    // pointer to the port so we could not cleanup.
    //

    pDeviceObj->DeviceState             = DEV_OBJ_LISTEN_COMPLETE;
    pDeviceObj->fFlags                  &= ~DEV_OBJ_OPENED_FOR_DIALOUT;
    pDeviceObj->fFlags                  &= ~DEV_OBJ_SECURITY_DLL_USED;
    pDeviceObj->hConnection             = (HCONN)INVALID_HANDLE_VALUE;
    pDeviceObj->wchUserName[0]          = (WCHAR)NULL;
    pDeviceObj->wchDomainName[0]        = (WCHAR)NULL;
    pDeviceObj->wchCallbackNumber[0]    = (WCHAR)NULL;
    pDeviceObj->hRasConn                = (HRASCONN)NULL;
    pDeviceObj->pRasmanSendBuffer       = NULL;
    pDeviceObj->pRasmanRecvBuffer       = NULL;
    pDeviceObj->dwCallbackRetries       = 0;

	pDeviceObj->dwRecvBufferLen = 1500;

    dwRetCode = RasGetBuffer((CHAR**)&pDeviceObj->pRasmanRecvBuffer,
                             &((pDeviceObj->dwRecvBufferLen)) );

    if ( dwRetCode != NO_ERROR )
    {
        auditstrp[0] = pDeviceObj->wchPortName;

	    DDMLogErrorString( ROUTERLOG_CANT_RECEIVE_BYTES, 1, auditstrp,
                           dwRetCode, 1);

        DevStartClosing(pDeviceObj);

        return;
    }

    //
    // If the security DLL is not loaded or we are not serial, simply
    // change the state
    //

    if ( ( gblDDMConfigInfo.lpfnRasBeginSecurityDialog == NULL ) ||
         ( gblDDMConfigInfo.lpfnRasEndSecurityDialog   == NULL ) ||
         (RAS_DEVICE_TYPE(pDeviceObj->dwDeviceType) != RDT_Modem) )
    {
        //
        // Change RASMAN state to CONNECTED from LISTENCOMPLETE and signal
        // RmEventHandler
        //

        if ( RasPortConnectComplete(pDeviceObj->hPort) != NO_ERROR )
        {
            DevStartClosing(pDeviceObj);
            return;
        }

        SetEvent( gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex] );
    }
    else
    {
        // Otherwise call the security dll ordinal to begin the 3rd party
        // security dialog with the client

        dwLength = 1500;

        dwRetCode = RasGetBuffer((CHAR**)&pDeviceObj->pRasmanSendBuffer,
                                 &dwLength );

        if ( dwRetCode != NO_ERROR )
        {
            auditstrp[0] = pDeviceObj->wchPortName;

	        DDMLogErrorString( ROUTERLOG_CANT_RECEIVE_BYTES, 1, auditstrp,
                           dwRetCode, 1);

            DevStartClosing(pDeviceObj);

            return;
        }


        //
        // Make sure that this device type supports raw mode.
        //

        if ( RasPortSend( pDeviceObj->hPort,
                          (CHAR*)pDeviceObj->pRasmanSendBuffer,
                          0 ) != NO_ERROR )
        {
            RasFreeBuffer( pDeviceObj->pRasmanSendBuffer );

            pDeviceObj->pRasmanSendBuffer = NULL;

            //
            // Change RASMAN state to CONNECTED from LISTENCOMPLETE and signal
            // RmEventHandler
            //

            if ( RasPortConnectComplete( pDeviceObj->hPort ) != NO_ERROR )
            {
                DevStartClosing(pDeviceObj);
                return;
            }

            SetEvent( gblSupervisorEvents[NUM_DDM_EVENTS+dwBucketIndex] );

            return;
        }

        dwRetCode = (*gblDDMConfigInfo.lpfnRasBeginSecurityDialog)(
                                                pDeviceObj->hPort,
                                                pDeviceObj->pRasmanSendBuffer ,
                                                dwLength,
                                                pDeviceObj->pRasmanRecvBuffer,
		                                        pDeviceObj->dwRecvBufferLen,
                                                RasSecurityDialogComplete );

        if ( dwRetCode != NO_ERROR )
        {
            //
            // Audit failure due to error and hangup the line
            //

            auditstrp[0] = pDeviceObj->wchPortName;

	        DDMLogErrorString( ROUTERLOG_SEC_AUTH_INTERNAL_ERROR,1,auditstrp,
                               dwRetCode, 1);

            DevStartClosing(pDeviceObj);

            return;
        }
        else
        {
            pDeviceObj->SecurityState = DEV_OBJ_SECURITY_DIALOG_ACTIVE;

            pDeviceObj->fFlags |= DEV_OBJ_SECURITY_DLL_USED;

            //
            // Start timer for 3rd party security
            //

	        TimerQRemove( (HANDLE)pDeviceObj->hPort, SvSecurityTimeout );

	        TimerQInsert( (HANDLE)pDeviceObj->hPort,
                          gblDDMConfigInfo.dwSecurityTime,
                          SvSecurityTimeout);
        }
    }

    return;
}

//
//*** Array of previous connection state/ current connection state
//    used to select the Ras Manager signaled event handler
//

typedef VOID  (* RMEVHDLR)(PDEVICE_OBJECT);

typedef struct _RMEHNODE
{
    RASMAN_STATE previous_state;
    RASMAN_STATE current_state;
    RMEVHDLR rmevhandler;

} RMEHNODE, *PRMEHNODE;


RMEHNODE rmehtab[] =
{
    //	 Transition
    // Previous --> Current

    { CONNECTING,       CONNECTED,	            SvDevConnected },
    { LISTENING,        LISTENCOMPLETED,        SvDevListenComplete },
    { LISTENCOMPLETED,  CONNECTED,              SvDevConnected },
    { LISTENCOMPLETED,  DISCONNECTED,           SvDevDisconnected },
    { LISTENING,        DISCONNECTED,           SvDevDisconnected },
    { CONNECTED,        DISCONNECTED,           SvDevDisconnected },
    { DISCONNECTING,	DISCONNECTED,		    SvDevDisconnected },
    { CONNECTED,	    CONNECTING,		        SvDevDisconnected },
    { 0xffff,           0xffff,                 NULL }// Table Guard
};

VOID
RmEventHandler(
    DWORD dwEventIndex
)
{
    RASMAN_INFO     RasPortInfo;
    PDEVICE_OBJECT  pDevObj;
    PRMEHNODE       ehnp;
    DWORD           dwRetCode;
    DWORD           dwBucketIndex = dwEventIndex - NUM_DDM_EVENTS;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    //
    // for each port in this bucket
    //

    for ( pDevObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
          pDevObj != (DEVICE_OBJECT *)NULL;
          pDevObj = pDevObj->pNext )
    {
        //
	    // get the port state
        //

        dwRetCode = RasGetInfo( NULL, pDevObj->hPort, &RasPortInfo );

        if ( dwRetCode != NO_ERROR )
        {
            SetLastError( dwRetCode );

            DDMTRACE3( "RasGetInfo( 0x%x, 0x%x ) = %d",
                       pDevObj->hPort, &RasPortInfo, dwRetCode );

            //
            // Assume the the port is disconnected
            //

            pDevObj->ConnectionState = DISCONNECTED;

            SvDevDisconnected( pDevObj );

            continue;
        }

        //
	    // check if we own the port now
        //

	    if (!RasPortInfo.RI_OwnershipFlag)
        {
            //
	        // skip biplexed ports used by other processes
            //

	        continue;
	    }

        //
	    // switch on our private connection state
        //

	    switch (pDevObj->ConnectionState)
        {
	    case CONNECTING:

            if (RasPortInfo.RI_ConnState == CONNECTING)
            {
	            switch (RasPortInfo.RI_LastError)
                {
	            case SUCCESS:

                    RasPortConnectComplete(pDevObj->hPort);

                    //
		            // force current state to connected.
                    //

	                RasPortInfo.RI_ConnState = CONNECTED;

		            break;

                case PENDING:

                    //
                    // no action
                    //

	                break;

                default:

                    //
	                // error occured -> force state to disconnecting
                    //

		            pDevObj->ConnectionState = DISCONNECTING;

                    DDM_PRINT(
                        gblDDMConfigInfo.dwTraceId,
                        TRACE_FSM,
                        "RmEventHandler: RI_LastError indicates error when");
                    DDM_PRINT(
                        gblDDMConfigInfo.dwTraceId,
                        TRACE_FSM,
                        " CONNECTING on port %d !!!\n", pDevObj->hPort );
                    DDM_PRINT(
                        gblDDMConfigInfo.dwTraceId,
                        TRACE_FSM,
	                    "RmEventHandler:RasPortDisconnect posted on port%d\n",
                        pDevObj->hPort);

	                if ( pDevObj->DeviceState == DEV_OBJ_CALLBACK_CONNECTING )
                    {
                        LPWSTR Parms[3];
                        WCHAR  wchFullUserName[UNLEN+DNLEN+2];

                        if ( pDevObj->wchDomainName[0] != TEXT('\0') )
                        {
                            wcscpy( wchFullUserName, pDevObj->wchDomainName);
                            wcscat( wchFullUserName, TEXT("\\") );
                            wcscat( wchFullUserName, pDevObj->wchUserName );
                        }
                        else
                        {
                            wcscpy( wchFullUserName, pDevObj->wchUserName );
                        }

                        Parms[0] = wchFullUserName;
                        Parms[1] = pDevObj->wchPortName;
                        Parms[2] = pDevObj->wchCallbackNumber;

                        DDMLogErrorString(ROUTERLOG_CALLBACK_FAILURE, 3, Parms,
                                          RasPortInfo.RI_LastError, 3 );
                    }

	                dwRetCode = RasPortDisconnect(
                                        pDevObj->hPort,
                                        gblSupervisorEvents[NUM_DDM_EVENTS +
                                                            dwBucketIndex ] );

	                RTASSERT((dwRetCode == PENDING) || (dwRetCode == SUCCESS));

		            break;
                }
            }

            break;

	    case LISTENING:

	        if (RasPortInfo.RI_ConnState != LISTENING)
            {
                break;
            }

	        switch (RasPortInfo.RI_LastError)
            {
	        case PENDING:

                //
                // no action
                //

	            break;

            default:

                //
                // error occured -> force state to disconnecting
                //

                pDevObj->ConnectionState = DISCONNECTING;

                DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
                   "RmEventHandler: RI_LastError indicates error %d when",
                    RasPortInfo.RI_LastError );
                DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
                   " LISTENING on port %d !!!\n", pDevObj->hPort );
                DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
                   "RmEventHandler:RasPortDisconnect posted on port%d\n",
                   pDevObj->hPort);

                dwRetCode = RasPortDisconnect(
                                        pDevObj->hPort,
                                        gblSupervisorEvents[NUM_DDM_EVENTS +
                                                            dwBucketIndex ] );

                RTASSERT((dwRetCode == PENDING) || (dwRetCode == SUCCESS));

                break;
            }

            break;

	    default:

            break;

	    }

        //
	    // try to find the table element with the matching previous and
	    // current connection states
        //

	    for (ehnp=rmehtab; ehnp->rmevhandler != NULL; ehnp++)
        {
	        if ((ehnp->previous_state == pDevObj->ConnectionState) &&
	            (ehnp->current_state == RasPortInfo.RI_ConnState))
            {
		        //
		        //*** Match ***
		        //

                DDM_PRINT(
                   gblDDMConfigInfo.dwTraceId,
                   TRACE_FSM,
	               "Rasman state change received from port %d, %d->%d",
                   pDevObj->hPort, ehnp->previous_state, ehnp->current_state );

                //
		        // change the dcb conn state (previous state) with the
		        // current state
                //

		        pDevObj->ConnectionState = RasPortInfo.RI_ConnState;

                //
		        // invoke the handler
                //

		        (*ehnp->rmevhandler)(pDevObj);

		        break;
	        }
	    }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
//  Function:	SvFrameReceived
//
//  Descr:	starts authentication
//
//***
VOID
SvFrameReceived(
    IN PDEVICE_OBJECT   pDeviceObj,
    IN CHAR             *framep,  // pointer to the received frame
    IN DWORD            framelen,
    IN DWORD            dwBucketIndex
)
{
    DWORD               dwRetCode;
    DWORD               FrameType;
    LPWSTR              portnamep;
    PCONNECTION_OBJECT  pConnObj;
    BYTE                RecvBuffer[1500];

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	           "SvFrameReceived: Entered, hPort: %d", pDeviceObj->hPort);

    if ( framelen > sizeof( RecvBuffer ) )
    {
        DDMTRACE2( "Illegal frame length of %d received for port %d", 
                    framelen, pDeviceObj->hPort );

        RTASSERT( FALSE );

        //
        // Frame length is illegal so truncate it
        //

        framelen = sizeof( RecvBuffer );
    }

    memcpy( RecvBuffer, framep, framelen);

    switch (pDeviceObj->DeviceState)
    {
	case DEV_OBJ_RECEIVING_FRAME:

	    if ( !DDMRecognizeFrame( RecvBuffer, (WORD)framelen, &FrameType) )
        {
            portnamep = pDeviceObj->wchPortName;

            DDMLogError(ROUTERLOG_UNRECOGNIZABLE_FRAME_RECVD, 1, &portnamep, 0);

            DevStartClosing(pDeviceObj);

            return;
        }

        //
	    // check first with our authentication module
        //

	    switch( FrameType )
        {

        case PPP_LCP_PROTOCOL:

            pDeviceObj->fFlags |= DEV_OBJ_IS_PPP;

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "SvFrameReceived: PPP frame on port %d",
                       pDeviceObj->hPort);

            dwRetCode = PppDdmStart( pDeviceObj->hPort,
                                     pDeviceObj->wchPortName,
                                     RecvBuffer,
                                     framelen,
                                     gblDDMConfigInfo.dwAuthenticateRetries
                                   );

            if ( dwRetCode != NO_ERROR )
            {
                portnamep = pDeviceObj->wchPortName;

                DDMLogErrorString( ROUTERLOG_CANT_START_PPP, 1, &portnamep,
                                   dwRetCode,1);

                DevStartClosing(pDeviceObj);

                return;
            }

            break;

        case APPLETALK:

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "SvFrameReceived: protocol not supported! %d",
                       pDeviceObj->hPort);

            RTASSERT( FALSE );


            break;

        default:

            break;
        }

        //
        // auth has started OK. Update state
        // start auth timer
        //

        pDeviceObj->DeviceState = DEV_OBJ_AUTH_IS_ACTIVE;
        pDeviceObj->fFlags |= DEV_OBJ_AUTH_ACTIVE;

	    break;

	case DEV_OBJ_CLOSING:

	    DevCloseComplete(pDeviceObj);

	    break;

	default:

	    break;
    }
}

//***
//
//  Function:	    RmRecvFrameEventHandler
//
//  Description:	Scans the set of opened ports and detects the ports where
//		            RasPortReceive has completed. Invokes the FSM handling
//		            procedure for each detected port and frees the receive
//		            buffer.
//
//***
VOID
RmRecvFrameEventHandler(
    DWORD dwEventIndex
)
{
    PDEVICE_OBJECT      pDevObj;
    RASMAN_INFO         RasPortInfo;
    DWORD               dwRetCode;
    DWORD               dwBucketIndex = dwEventIndex
                                        - NUM_DDM_EVENTS
                                        - gblDeviceTable.NumDeviceBuckets;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    //
    // for each port in this bucket
    //

    for ( pDevObj = gblDeviceTable.DeviceBucket[dwBucketIndex];
          pDevObj != (DEVICE_OBJECT *)NULL;
          pDevObj = pDevObj->pNext )
    {
        //
	    // get the port state
        //

        dwRetCode = RasGetInfo( NULL, pDevObj->hPort, &RasPortInfo );

        if ( dwRetCode != NO_ERROR )
        {
            //
            // Assume port is disconncted, so clean up
            //

            DevStartClosing(pDevObj);

            continue;
        }

        //
	    // check if we own the port now
        //

	    if (!RasPortInfo.RI_OwnershipFlag)
        {
            //
	        // skip biplexed ports used by other processes
            //

	        continue;
	    }

        if ( ( pDevObj->fFlags & DEV_OBJ_RECEIVE_ACTIVE ) &&
             ( RasPortInfo.RI_LastError != PENDING ) )
        {
            //
            // recv frame API has completed
            //

            pDevObj->fFlags &= (~DEV_OBJ_RECEIVE_ACTIVE );

            if ( RasPortInfo.RI_LastError != ERROR_PORT_DISCONNECTED )
            {
               LPBYTE lpBuffer = LocalAlloc(LPTR,RasPortInfo.RI_BytesReceived);

               if ( lpBuffer == NULL )
               {
                   DevStartClosing(pDevObj);

                   continue;
               }

               memcpy( lpBuffer,
                       pDevObj->pRasmanRecvBuffer,
                       RasPortInfo.RI_BytesReceived );

               RasFreeBuffer(pDevObj->pRasmanRecvBuffer);

               pDevObj->pRasmanRecvBuffer = NULL;

               //
               // call the FSM handler
               //

               SvFrameReceived( pDevObj,
                                lpBuffer,
                                RasPortInfo.RI_BytesReceived,
                                dwBucketIndex);

               LocalFree( lpBuffer );
            }

            if ( pDevObj->pRasmanRecvBuffer != NULL )
            {
                RasFreeBuffer(pDevObj->pRasmanRecvBuffer);

                pDevObj->pRasmanRecvBuffer = NULL;
            }
        }
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\svchand.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:	svchand.c
//
// Description: This module contains procedures to handle DDM service state
//              changes and startup initialization.
//
// History:     May 11,1995	    NarenG		Created original version.
//

#define _ALLOCATE_DDM_GLOBALS_
#include "ddm.h"
#include "objects.h"
#include "handlers.h"
#include "rasmanif.h"
#include "util.h"
#include <ddmif.h>
#include <ddmparms.h>
#include "timer.h"
#include "rassrvr.h"

DWORD
EventDispatcher(
    IN LPVOID arg
);

//***
//
// Function:	DDMServiceStopComplete
//
// Descr:	called by each device which has closed. Checks if all devices
//		are closed and if true signals the event dispatcher to
//		exit the "forever" loop and return.
//
//***

VOID
DDMServiceStopComplete(
    VOID
)
{
    //
    // check if all devices have been stopped
    //

    if ( DeviceObjIterator( DeviceObjIsClosed, TRUE, NULL ) != NO_ERROR )
    {
        DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
	               "ServiceStopComplete:there are device pending close");

        //
	    // there are still unclosed devices
        //

        return;
    }

    //
    //*** All Devices Are Closed at the Supervisor Level ***
    //

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
               "ServiceStopComplete: ALL devices closed");

    //
    // Notify connections that the service has stopped.
    //
    {
        RASEVENT RasEvent;

        ZeroMemory((PBYTE) &RasEvent, sizeof(RASEVENT));

        RasEvent.Type = SERVICE_EVENT;
        RasEvent.Event   = RAS_SERVICE_STOPPED;
        RasEvent.Service = REMOTEACCESS;

        (void) RasSendNotification(&RasEvent);
    }

    //
    // notify the DIM that DDM has terminated. This will also cause the
    // event dispatcher and timer threads to die.
    //

    SetEvent( gblSupervisorEvents[DDM_EVENT_SVC_TERMINATED] );
}

//***
//
//  Function:	DDMServiceTerminate
//
//  Descr:	deallocates all resources and closes all dialin devices
//
//***

VOID
DDMServiceTerminate(
    VOID
)
{
    //
    // Disconnect all connected DDM interfaces
    //

    IfObjectDisconnectInterfaces();

    //
    // Wait for all disconenct notificaions to be processed
    //

    Sleep( 2000L );

    DeviceObjIterator( DeviceObjStartClosing, FALSE, NULL );

    //
    // UnRegister the notifier form rasman
    //
    (void) RasRegisterPnPHandler( (PAPCFUNC) DdmDevicePnpHandler,
                                   NULL,
                                   FALSE);

    //
    // check if all devices are closed and terminate if true
    //

    DDMServiceStopComplete();
}

//***
//
// Function:	DDMServicePause
//
// Descr:	disables listening on any active listenning ports. Sets
//		service global state to RAS_SERVICE_PAUSED. No new listen
//		will be posted when a client terminates.
//
//***

VOID
DDMServicePause(
    VOID
)
{
    WORD i;
    PDEVICE_OBJECT pDeviceObj;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,"SvServicePause: Entered");

    //
    // Close all active listenning ports
    //

    DeviceObjIterator( DeviceObjCloseListening, FALSE, NULL );

    //
    // Notify all interfaces that they are not reachable
    //

    IfObjectNotifyAllOfReachabilityChange( FALSE, INTERFACE_SERVICE_IS_PAUSED );
}

//***
//
// Function:	DDMServiceResume
//
// Descr:	resumes listening on all ports.
//
//***
VOID
DDMServiceResume(
    VOID
)
{
    WORD i;
    PDEVICE_OBJECT pDeviceObj;

    DDM_PRINT(gblDDMConfigInfo.dwTraceId,TRACE_FSM,"SvServiceResume: Entered");

    //
    // resume listening on all closed devices
    //

    DeviceObjIterator( DeviceObjResumeListening, FALSE, NULL );

    //
    // Notify all interfaces that they are reachable now.
    //

    IfObjectNotifyAllOfReachabilityChange( TRUE, INTERFACE_SERVICE_IS_PAUSED );
}

//***
//
//  Function:	    DDMServiceInitialize
//
//  Descrption:	    It does init work as follows:
//		                Loads the configuration parameters
//                      Loads the security module if there is one.
//		                Creates the event flags
//		                Initializes the message DLL
//		                Opens all dialin devices
//		                Initializes the DCBs
//		                Initializes the authentication DLL
//		                Posts listen on all opened dialin devices
//
//                  NOTE: Also changing the working set size for this process
//                        will change it for all the services in this process.
//                        Is this OK?
//                        What do we do about the security check call?
//
//  Returns:	    NO_ERROR - Sucess
//                  non-zero - Failure
//
//***
DWORD
DDMServiceInitialize(
    IN DIM_INFO * DimInfo
)
{
    DWORD           dwIndex;
    DWORD           ThreadId;
    QUOTA_LIMITS    ql;
    NTSTATUS        ntStatus                                = STATUS_SUCCESS;
    DWORD           dwRetCode                               = NO_ERROR;
    HANDLE          hEventDispatcher                        = NULL;
    DEVICE_OBJECT * pDeviceObj                              = NULL;
    HPORT *         phPorts                                 = NULL;
    BOOL            fIpAllowed                              = FALSE;
    LPVOID          lpfnRasAuthProviderFreeAttributes       = NULL;
    LPVOID          lpfnRasAuthProviderAuthenticateUser     = NULL;
    LPVOID          lpfnRasAuthConfigChangeNotification     = NULL;
    LPVOID          lpfnRasAcctProviderStartAccounting      = NULL;
    LPVOID          lpfnRasAcctProviderInterimAccounting    = NULL;
    LPVOID          lpfnRasAcctProviderStopAccounting       = NULL;
    LPVOID          lpfnRasAcctProviderFreeAttributes       = NULL;
    LPVOID          lpfnRasAcctConfigChangeNotification     = NULL;
    DWORD           dwLocalIpAddress                        = 0;
    DWORD           dwCSFlags                               = 0;

#define TIMERQCS_INITIALIZED            0x00000001
#define DEVICETABLECS_INITIALIZED       0x00000002
#define ACCOUNTINGSESSIONCS_INITIALIZED 0x00000004
#define MEDIATABLECS_INITIALIZED        0x00000008


    ZeroMemory( &gblDDMConfigInfo,      sizeof( gblDDMConfigInfo ) );
    gblDDMConfigInfo.fRasSrvrInitialized                    = FALSE;
    gblDDMConfigInfo.hIpHlpApi                              = NULL;
    gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack     = NULL;
    gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack = NULL;
    gblDDMConfigInfo.dwNumRouterManagers    = DimInfo->dwNumRouterManagers;
    gblRouterManagers                       = DimInfo->pRouterManagers;
    gblpInterfaceTable                      = DimInfo->pInterfaceTable;
    gblDDMConfigInfo.pServiceStatus         = DimInfo->pServiceStatus;
    gblDDMConfigInfo.dwTraceId              = DimInfo->dwTraceId;
    gblDDMConfigInfo.hLogEvents             = DimInfo->hLogEvents;
    gblphEventDDMServiceState               = DimInfo->phEventDDMServiceState;
    gblphEventDDMTerminated                 = DimInfo->phEventDDMTerminated;
    gblDDMConfigInfo.lpdwNumThreadsRunning  = DimInfo->lpdwNumThreadsRunning;
    gblDDMConfigInfo.lpfnIfObjectRemove     = DimInfo->lpfnIfObjectRemove;
    gblDDMConfigInfo.lpfnIfObjectGetPointer = DimInfo->lpfnIfObjectGetPointer;
    gblDDMConfigInfo.lpfnIfObjectInsertInTable =
                                        DimInfo->lpfnIfObjectInsertInTable;
    gblDDMConfigInfo.lpfnIfObjectAllocateAndInit =
                                        DimInfo->lpfnIfObjectAllocateAndInit;
    gblDDMConfigInfo.lpfnIfObjectGetPointerByName =
                                        DimInfo->lpfnIfObjectGetPointerByName;
    gblDDMConfigInfo.lpfnIfObjectWANDeviceInstalled =
                                        DimInfo->lpfnIfObjectWANDeviceInstalled;
    gblDDMConfigInfo.lpfnRouterIdentityObjectUpdate =
                                        DimInfo->lpfnRouterIdentityObjectUpdate;

    gblDDMConfigInfo.fRasmanReferenced = FALSE;

    DimInfo->fWANDeviceInstalled = FALSE;

    try 
    {
        (VOID) TimerQInitialize();
        dwCSFlags |= TIMERQCS_INITIALIZED;
        
        InitializeCriticalSection( 
            &(gblDeviceTable.CriticalSection) );
        dwCSFlags |= DEVICETABLECS_INITIALIZED;

        InitializeCriticalSection( &(gblMediaTable.CriticalSection) );
        dwCSFlags |= MEDIATABLECS_INITIALIZED;
        
        InitializeCriticalSection( 
            &(gblDDMConfigInfo.CSAccountingSessionId) );
        dwCSFlags |= ACCOUNTINGSESSIONCS_INITIALIZED;            
                    
    }
    except (EXCEPTION_EXECUTE_HANDLER) 
    {
        dwRetCode = GetExceptionCode();

        if(dwCSFlags & TIMERQCS_INITIALIZED)
        {
            TimerQDelete();
        }

        if(dwCSFlags & DEVICETABLECS_INITIALIZED)
        {
            DeleteCriticalSection(
                &gblDeviceTable.CriticalSection);
        }

        if(dwCSFlags & MEDIATABLECS_INITIALIZED)
        {
            DeleteCriticalSection(
                &gblMediaTable.CriticalSection);
        }
        
        return dwRetCode;
    }

    do
    {
        //
        // Create DDM private heap
        //

        gblDDMConfigInfo.hHeap = HeapCreate( 0, DDM_HEAP_INITIAL_SIZE,
                                                DDM_HEAP_MAX_SIZE );

        if ( gblDDMConfigInfo.hHeap == NULL )
        {
            dwRetCode = GetLastError();
            break;
        }

        //
        // Allocate and initialize the media object table.
        //

        if ( ( dwRetCode = MediaObjInitializeTable() ) != NO_ERROR )
        {
            DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );
            break;
        }


        //
        // initialize the rasman module
        //

        if ( ( dwRetCode = RasInitialize() ) != NO_ERROR )
        {
            //
            // can't start rasman
            //

            DDMLogErrorString( ROUTERLOG_RASMAN_NOT_AVAILABLE,
                               0, NULL, dwRetCode, 0 );

            break;
        }

        //
        // Increase rasman's reference count since we are in the same process
        // this does not happen automatically
        //

        if ( dwRetCode = RasReferenceRasman( TRUE ) )
        {
            //
            // can't start rasman
            //

            DDMLogErrorString( ROUTERLOG_RASMAN_NOT_AVAILABLE,
                               0, NULL, dwRetCode, 0 );

            break;
        }

        gblDDMConfigInfo.fRasmanReferenced = TRUE;

        //
        // Check if there is any security agent on the network.  If there is,
        // we check with it if we can start up or not.
        //

/*
        if ( SecurityCheck() )
        {
            dwRetCode = ERROR_SERVICE_DISABLED;
            break;
        }
*/

        if ( ( dwRetCode = GetRouterPhoneBook() ) != NO_ERROR )
        {
            break;
        }

        if ( ( dwRetCode = LoadStrings() ) != NO_ERROR )
        {
            break;
        }

        //
        // get handle to the supervisor parameters key
        //

        if ( dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE,
                                     DDM_PARAMETERS_KEY_PATH,
                                     &(gblDDMConfigInfo.hkeyParameters) ))
        {
            WCHAR * pwChar = DDM_PARAMETERS_KEY_PATH;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &pwChar, dwRetCode);

            break;
        }

        if ( dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE,
                                     DDM_ACCOUNTING_KEY_PATH,
                                     &(gblDDMConfigInfo.hkeyAccounting) ))
        {
            WCHAR * pwChar = DDM_ACCOUNTING_KEY_PATH;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &pwChar, dwRetCode);

            break;
        }

        if ( dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE,
                                     DDM_AUTHENTICATION_KEY_PATH,
                                     &(gblDDMConfigInfo.hkeyAuthentication) ))
        {
            WCHAR * pwChar = DDM_AUTHENTICATION_KEY_PATH;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &pwChar, dwRetCode);

            break;
        }

        if ( ( dwRetCode = LoadDDMParameters( gblDDMConfigInfo.hkeyParameters,
                                              &fIpAllowed) )
                                      != NO_ERROR )
        {
            //
	        // error loading parameters
            //

            break;
        }

        //
        // Load the secuirity module if there is one.
        //

        if ( ( dwRetCode = LoadSecurityModule() ) != NO_ERROR )
        {
            //
	        // error loading security dll
            //

            break;
        }

        //
        // Load the third party admin module if there is one
        //

        if ( ( dwRetCode = LoadAdminModule() ) != NO_ERROR )
        {
            //
	        // error loading admin module dll
            //

            break;
        }


        //
        // This call allocates memory for all enumed devices with dialin
        // capability, opens each device and updates the port handle and
        // the port name in the DCB.
        //

        if ((dwRetCode = RmInit(&(DimInfo->fWANDeviceInstalled))) != NO_ERROR)
        {
            break;
        }

        //
        // Allocate the supervisor events array, 2 per device bucket since there
        // are 2 rasman events per device, state change and frame received.
        //

        gblSupervisorEvents = (HANDLE *)LOCAL_ALLOC( LPTR,
                        (NUM_DDM_EVENTS + (gblDeviceTable.NumDeviceBuckets * 3))
                        * sizeof( HANDLE )  );

        if ( gblSupervisorEvents == (HANDLE *)NULL )
        {
            dwRetCode = GetLastError();

	        DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );

            break;
        }

        //
        // Create the DDM Events
        //

        for ( dwIndex = 0;
              dwIndex < (NUM_DDM_EVENTS+(gblDeviceTable.NumDeviceBuckets * 3));
              dwIndex ++ )
        {
            switch( dwIndex )
            {
            case DDM_EVENT_SVC:

                gblSupervisorEvents[dwIndex]=*gblphEventDDMServiceState;
                gblEventHandlerTable[dwIndex].EventHandler = SvcEventHandler;
                break;

            case DDM_EVENT_SVC_TERMINATED:

                gblSupervisorEvents[dwIndex]=*gblphEventDDMTerminated;
                break;

            case DDM_EVENT_TIMER:

                gblSupervisorEvents[dwIndex]=CreateWaitableTimer( NULL,
                                                                  FALSE,
                                                                  NULL );
                gblEventHandlerTable[dwIndex].EventHandler = TimerHandler;
                break;

            case DDM_EVENT_SECURITY_DLL:

                gblSupervisorEvents[dwIndex]=CreateEvent(NULL,FALSE,FALSE,NULL);
                gblEventHandlerTable[dwIndex].EventHandler =
                                                    SecurityDllEventHandler;
                break;

            case DDM_EVENT_PPP:

                gblSupervisorEvents[dwIndex]=CreateEvent(NULL,FALSE,FALSE,NULL);
                gblEventHandlerTable[dwIndex].EventHandler = PppEventHandler;
                break;

            case DDM_EVENT_CHANGE_NOTIFICATION:
            case DDM_EVENT_CHANGE_NOTIFICATION1:
            case DDM_EVENT_CHANGE_NOTIFICATION2:

                gblSupervisorEvents[dwIndex]=CreateEvent(NULL,FALSE,FALSE,NULL);
                gblEventHandlerTable[dwIndex].EventHandler =
                                                ChangeNotificationEventHandler;
                break;

            default:

                //
                // RasMan events
                //

                gblSupervisorEvents[dwIndex]=CreateEvent(NULL,FALSE,FALSE,NULL);
                break;
            }

	        if ( gblSupervisorEvents[dwIndex] == NULL )
            {
                dwRetCode = GetLastError();

                break;
	        }
        }

        //
        // Initialize the Message Mechanism
        //

        InitializeMessageQs(    gblSupervisorEvents[DDM_EVENT_SECURITY_DLL],
                                gblSupervisorEvents[DDM_EVENT_PPP] );

        //
        // Register the device hEvents with RasMan
        //

        dwRetCode = DeviceObjIterator(DeviceObjRequestNotification,TRUE,NULL);

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        if ( fIpAllowed )
        {
            //
            // GetLocalNASIpAddress tries to load iphlpapi.dll. iphlpapi.dll
            // tries to load dhcpcsvc.dll. The latter fails unless TCP/IP is
            // installed and a popup appears.
            //

            dwLocalIpAddress = GetLocalNASIpAddress();
        }

        //
        // Load the configured authentication provider
        //

        dwRetCode = LoadAndInitAuthOrAcctProvider(
                                TRUE,
                                dwLocalIpAddress,
                                NULL,
                                &lpfnRasAuthProviderAuthenticateUser,
                                &lpfnRasAuthProviderFreeAttributes,
                                &lpfnRasAuthConfigChangeNotification,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL );


        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString(  ROUTERLOG_AUTHPROVIDER_FAILED_INIT,
                                0, NULL, dwRetCode, 0);
            break;
        }

        gblDDMConfigInfo.lpfnRasAuthConfigChangeNotification = (DWORD(*)(DWORD))
            lpfnRasAuthConfigChangeNotification;

        //
        // Load the configured accounting provider
        //

        dwRetCode = LoadAndInitAuthOrAcctProvider(
                                FALSE,
                                dwLocalIpAddress,
                                &(gblDDMConfigInfo.dwAccountingSessionId),
                                NULL,
                                NULL,
                                NULL,
                                &lpfnRasAcctProviderStartAccounting,
                                &lpfnRasAcctProviderInterimAccounting,
                                &lpfnRasAcctProviderStopAccounting,
                                &lpfnRasAcctProviderFreeAttributes,
                                &lpfnRasAcctConfigChangeNotification );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString(  ROUTERLOG_ACCTPROVIDER_FAILED_INIT,
                                0, NULL, dwRetCode, 0);
            break;
        }

        gblDDMConfigInfo.lpfnRasAcctConfigChangeNotification =  (DWORD(*)(DWORD))
            lpfnRasAcctConfigChangeNotification;

        
        //
        // Initialize PPP RASIPHLP DLL
        //

        if ( fIpAllowed )
        {
            DWORD i;
            BOOL bCalled = FALSE;
            
            for (i=0;  i<gblDDMConfigInfo.NumAdminDlls;  i++)
            {
                PADMIN_DLL_CALLBACKS AdminDllCallbacks = &gblDDMConfigInfo.AdminDllCallbacks[i];
                if (AdminDllCallbacks[i].lpfnMprAdminGetIpAddressForUser!=NULL)
                {
                    dwRetCode = RasSrvrInitialize(
                                AdminDllCallbacks[i].lpfnMprAdminGetIpAddressForUser,
                                AdminDllCallbacks[i].lpfnMprAdminReleaseIpAddress );

                    bCalled = TRUE;
                    break;
                }
            }
            if (!bCalled)
            {
                dwRetCode = RasSrvrInitialize(NULL, NULL);
            }
            
            if ( dwRetCode != NO_ERROR )
            {
                DDMLogErrorString( ROUTERLOG_CANT_INITIALIZE_IP_SERVER,
                                   0, NULL, dwRetCode, 0 );

                break;
            }

            gblDDMConfigInfo.fRasSrvrInitialized = TRUE;
        }


        //
        // Start the timer
        //

        {
            LARGE_INTEGER DueTime;

            DueTime.QuadPart = Int32x32To64((LONG)1000, -10000);

            if ( !SetWaitableTimer( gblSupervisorEvents[DDM_EVENT_TIMER],
                                    &DueTime, 1000, NULL, NULL, FALSE) )
            {
                dwRetCode = GetLastError();
                break;
            }
        }


        //
        // Initialize PPP engine DLL
        //

        dwRetCode = PppDdmInit(
                        SendPppMessageToDDM,
                        gblDDMConfigInfo.dwServerFlags,
                        gblDDMConfigInfo.dwLoggingLevel,
                        dwLocalIpAddress,
                        gblDDMConfigInfo.fFlags&DDM_USING_RADIUS_AUTHENTICATION,
                        lpfnRasAuthProviderAuthenticateUser,
                        lpfnRasAuthProviderFreeAttributes,
                        lpfnRasAcctProviderStartAccounting,
                        lpfnRasAcctProviderInterimAccounting,
                        lpfnRasAcctProviderStopAccounting,
                        lpfnRasAcctProviderFreeAttributes,
                        (LPVOID)GetNextAccountingSessionId );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogErrorString(ROUTERLOG_PPP_INIT_FAILED, 0, NULL, dwRetCode, 0);

            break;
        }

        //
        // Create the Event dispatcher thread
        //

        if ( ( hEventDispatcher = CreateThread( NULL, 0, EventDispatcher,
                                                NULL, 0, &ThreadId)) == 0 )
        {
            //
            // cannot create event dispatcher thread
            //

            dwRetCode = GetLastError();

            break;
        }

        //
        // Register for plug and play notifications with RASMAN
        //

        dwRetCode = RasRegisterPnPHandler( (PAPCFUNC) DdmDevicePnpHandler,
                                                       hEventDispatcher,
                                                       TRUE);

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        //
        // Initialize notification event list
        //

        InitializeListHead( &(gblDDMConfigInfo.NotificationEventListHead) );

        //
        // Initialize the array of Analog/Digital Ip Addresses.
        //
        dwRetCode = AddressPoolInit();

        if( dwRetCode != NO_ERROR )
        {
            break;
        }

        gblDDMConfigInfo.dwIndex = 0;

/*
        TimerQInsert( NULL,
                      gblDDMConfigInfo.dwAnnouncePresenceTimer,
                      AnnouncePresenceHandler );
*/

        //
        // Send notification to the connections folder that ddm
        // has started.
        //
        {
            RASEVENT RasEvent;

            ZeroMemory((PBYTE) &RasEvent, sizeof(RASEVENT));

            RasEvent.Type = SERVICE_EVENT;
            RasEvent.Event   = RAS_SERVICE_STARTED;
            RasEvent.Service = REMOTEACCESS;

            (void) RasSendNotification(&RasEvent);
        }

        return( NO_ERROR );

    } while ( FALSE );


    //
    // We call DDMCleanUp before setting the gblphEventDDMTerminated because
    // otherwise the DIM dll will be unloaded while DDMCleanUp is being
    // executed
    //

    DDMCleanUp();

    //
    // Will terminate the event dispatcher thread if it started
    // and will notify DIM that the service is terminated.
    //
    if(NULL != gblphEventDDMTerminated)
    {
        SetEvent( *gblphEventDDMTerminated );
    }

    gblphEventDDMTerminated = NULL;

    return( dwRetCode );
}

//***
//
//  Function:	SvcEventHandler
//
//  Descrption:	Invoked following the event signaled by the handler registered
//		        with the service controller. Replaces old service state with
//		        the new state and calls the appropriate handler.
//
//***
VOID
SvcEventHandler(
    VOID
)
{
    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    switch ( gblDDMConfigInfo.pServiceStatus->dwCurrentState )
    {
    case SERVICE_RUNNING:
        DDMServiceResume();
        break;

    case SERVICE_PAUSED:
        DDMServicePause();
        break;

    case SERVICE_STOP_PENDING:
        DDMServiceTerminate();
        break;

    default:
        RTASSERT(FALSE);
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\routerif.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    routerif.h
//
// Description: Prototypes of procedures in routerif.c
//
// History:     May 11,1995	    NarenG		Created original version.
//

DWORD
DDMConnectInterface(
    IN  HANDLE  hDDMInterface,
    IN  DWORD   dwProtocolId  
);

DWORD
DDMDisconnectInterface(
    IN  HANDLE  hDDMInterface,
    IN  DWORD   dwProtocolId 
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\registry.c ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	registry.c
//
// Description: This module contains the code for DDM parameters
//		        initialization and loading from the registry.
//
// Author:	Stefan Solomon (stefans)    May 18, 1992.
//
//***
#include "ddm.h"
#include <string.h>
#include <stdlib.h>
#include <ddmparms.h>
#include <rasauth.h>
#include <util.h>

typedef struct _DDM_REGISTRY_PARAMS
{
    LPWSTR      pszValueName;
    DWORD *     pValue;
    DWORD       dwDefValue;
    DWORD       Min;
    DWORD       Max;

} DDM_REGISTRY_PARAMS, *PDDM_REGISTRY_PARAMS;

//
// DDM parameter descriptor table
//

DDM_REGISTRY_PARAMS  DDMRegParams[] =
{
    // authenticateretries

    DDM_VALNAME_AUTHENTICATERETRIES,
    &gblDDMConfigInfo.dwAuthenticateRetries,
    DEF_AUTHENTICATERETRIES,
    MIN_AUTHENTICATERETRIES,
    MAX_AUTHENTICATERETRIES,

    // authenticatetime

    DDM_VALNAME_AUTHENTICATETIME,
    &gblDDMConfigInfo.dwAuthenticateTime,
    DEF_AUTHENTICATETIME,
    MIN_AUTHENTICATETIME,
    MAX_AUTHENTICATETIME,

    // callbacktime

    DDM_VALNAME_CALLBACKTIME,
    &gblDDMConfigInfo.dwCallbackTime,
    DEF_CALLBACKTIME,
    MIN_CALLBACKTIME,
    MAX_CALLBACKTIME,

    // Autodisconnect Time

    DDM_VALNAME_AUTODISCONNECTTIME,
    &gblDDMConfigInfo.dwAutoDisconnectTime,
    DEF_AUTODISCONNECTTIME,
    MIN_AUTODISCONNECTTIME,
    MAX_AUTODISCONNECTTIME,

    // Clients per process

    DDM_VALNAME_CLIENTSPERPROC,
    &gblDDMConfigInfo.dwClientsPerProc,
    DEF_CLIENTSPERPROC,
    MIN_CLIENTSPERPROC,
    MAX_CLIENTSPERPROC,

    // Time for 3rd party security DLL to complete

    DDM_VALNAME_SECURITYTIME,
    &gblDDMConfigInfo.dwSecurityTime,
    DEF_SECURITYTIME,
    MIN_SECURITYTIME,
    MAX_SECURITYTIME,

    // Logging level

    DDM_VALNAME_LOGGING_LEVEL,
    &gblDDMConfigInfo.dwLoggingLevel,
    DEF_LOGGINGLEVEL,
    MIN_LOGGINGLEVEL,
    MAX_LOGGINGLEVEL,

    // Number of callback retries 

    DDM_VALNAME_NUM_CALLBACK_RETRIES,
    &gblDDMConfigInfo.dwCallbackRetries,
    DEF_NUMCALLBACKRETRIES,
    MIN_NUMCALLBACKRETRIES,
    MAX_NUMCALLBACKRETRIES,

    DDM_VALNAME_SERVERFLAGS,
    &gblDDMConfigInfo.dwServerFlags,
    DEF_SERVERFLAGS,
    0,
    0xFFFFFFFF,

    // End

    NULL, NULL, 0, 0, 0
};

//***
//
// Function:    GetKeyMax
//
// Descr:   returns the nr of values in this key and the maximum
//      size of the value data.
//
//***

DWORD
GetKeyMax(
    IN  HKEY    hKey,
    OUT LPDWORD MaxValNameSize_ptr,   // longest valuename
    OUT LPDWORD NumValues_ptr,        // nr of values
    OUT LPDWORD MaxValueDataSize_ptr  // max size of data
)
{
    DWORD       NumSubKeys;
    DWORD       MaxSubKeySize;
    DWORD       dwRetCode;

    dwRetCode = RegQueryInfoKey( hKey, NULL, NULL, NULL, &NumSubKeys,
                                 &MaxSubKeySize, NULL, NumValues_ptr,
                                 MaxValNameSize_ptr, MaxValueDataSize_ptr,
                                 NULL, NULL );

    (*MaxValNameSize_ptr)++;

    return( dwRetCode );
}

//***
//
// Function:	LoadDDMParameters
//
// Descr:	Opens the registry, reads and sets specified supervisor
//		    parameters. If fatal error reading parameters writes the
//		    error log.
//
// Returns:	NO_ERROR - success
//		    else     - fatal error.
//
//***
DWORD
LoadDDMParameters(
    IN  HKEY    hkeyParameters,
    OUT BOOL*   pfIpAllowed
)
{
    DWORD       dwIndex;
    DWORD       dwRetCode;
    DWORD       cbValueBuf;
    DWORD       dwType;
    DWORD       fIpxAllowed;

    //
    // Initialize Global values
    //

    gblDDMConfigInfo.fRemoteListen           = TRUE;
    gblDDMConfigInfo.dwAnnouncePresenceTimer = ANNOUNCE_PRESENCE_TIMEOUT;

    //
    // Let us not allow any protocol if DdmFindBoundProtocols fails.
    //

    gblDDMConfigInfo.dwServerFlags &=
                                ~( PPPCFG_ProjectNbf    |
                                   PPPCFG_ProjectIp     |
                                   PPPCFG_ProjectIpx    |
                                   PPPCFG_ProjectAt     );

    dwRetCode =  DdmFindBoundProtocols( pfIpAllowed,
                                        &fIpxAllowed,
                                        &gblDDMConfigInfo.fArapAllowed );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    if ( !*pfIpAllowed && !fIpxAllowed && !gblDDMConfigInfo.fArapAllowed )
    {
        DDMLogError( ROUTERLOG_NO_PROTOCOLS_CONFIGURED, 0, NULL, 0 );

        return( dwRetCode );
    }

    //
    // Run through and get all the DDM values
    //

    for ( dwIndex = 0; DDMRegParams[dwIndex].pszValueName != NULL; dwIndex++ )
    {
        cbValueBuf = sizeof( DWORD );

        dwRetCode = RegQueryValueEx(
			                    hkeyParameters,
                                DDMRegParams[dwIndex].pszValueName,
                                NULL,
                                &dwType,
                                (LPBYTE)(DDMRegParams[dwIndex].pValue),
                                &cbValueBuf
                                );

        if ((dwRetCode != NO_ERROR) && (dwRetCode != ERROR_FILE_NOT_FOUND))
        {
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        if ( dwRetCode == ERROR_FILE_NOT_FOUND )
        {
            *(DDMRegParams[dwIndex].pValue) = DDMRegParams[dwIndex].dwDefValue;

            dwRetCode = NO_ERROR;
        }
        else
        {
            if ( ( dwType != REG_DWORD )
                 ||(*(DDMRegParams[dwIndex].pValue) > DDMRegParams[dwIndex].Max)
                 ||( *(DDMRegParams[dwIndex].pValue)<DDMRegParams[dwIndex].Min))
            {
                WCHAR * pChar = DDMRegParams[dwIndex].pszValueName;

                DDMLogWarning( ROUTERLOG_REGVALUE_OVERIDDEN,1,&pChar);

                *(DDMRegParams[dwIndex].pValue) =
                                        DDMRegParams[dwIndex].dwDefValue;
            }
        }
    }

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }
    else
    {
        // 
        // Insert allowed protocols in the ServerFlags which will be sent to
        // PPP engine
        //

        if ( *pfIpAllowed )
        {
            gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectIp;
        }

        if ( fIpxAllowed )
        {
            gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectIpx;
        }

        if ( gblDDMConfigInfo.fArapAllowed )
        {
            gblDDMConfigInfo.dwServerFlags |= PPPCFG_ProjectAt;
        }

        if ( gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireStrongEncryption )
        {
            ModifyDefPolicyToForceEncryption( TRUE );
        }
        else if ( gblDDMConfigInfo.dwServerFlags & PPPCFG_RequireEncryption )
        {
            ModifyDefPolicyToForceEncryption( FALSE );
        }

        gblDDMConfigInfo.dwServerFlags &= ~PPPCFG_RequireStrongEncryption;
        gblDDMConfigInfo.dwServerFlags &= ~PPPCFG_RequireEncryption;
    }

    return( NO_ERROR );
}

//***
//
// Function:	LoadSecurityModule
//
// Descr:	Opens the registry, reads and sets specified supervisor
//		parameters for the secuirity module. If fatal error reading
//              parameters writes the error log.
//
// Returns:	NO_ERROR  - success
//		otherwise - fatal error.
//
//***

DWORD
LoadSecurityModule(
    VOID
)
{
    HKEY        hKey;
    DWORD	    dwRetCode = NO_ERROR;
    DWORD	    MaxValueDataSize;
    DWORD	    MaxValNameSize;
    DWORD       NumValues;
    DWORD       dwType;
    WCHAR *     pDllPath = NULL;
    WCHAR *     pDllExpandedPath = NULL;
    DWORD       cbSize;

    //
    // get handle to the RAS key
    //

    dwRetCode = RegOpenKey( HKEY_LOCAL_MACHINE, DDM_SEC_KEY_PATH, &hKey);

    if ( dwRetCode == ERROR_FILE_NOT_FOUND )
    {
        return( NO_ERROR );
    }
    else if ( dwRetCode != NO_ERROR )
    {
	    DDMLogErrorString( ROUTERLOG_CANT_OPEN_SECMODULE_KEY, 0,
                           NULL, dwRetCode, 0);

	    return ( dwRetCode );
    }

    do
    {
        //
        // get the length of the path.
        //

        if (( dwRetCode = GetKeyMax(    hKey,
                                        &MaxValNameSize,
			                            &NumValues,
			                            &MaxValueDataSize)))
        {
	        DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode);

            break;
        }

        if ((pDllPath = LOCAL_ALLOC(LPTR,MaxValueDataSize+sizeof(WCHAR)))==NULL)
        {
            dwRetCode = GetLastError();

	        DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);

            break;
        }

        //
        // Read in the path
        //

        dwRetCode = RegQueryValueEx(
                                    hKey,
                                    DDM_VALNAME_DLLPATH,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)pDllPath,
                                    &MaxValueDataSize );

        if ( dwRetCode != NO_ERROR )
        {
	        DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode);

            break;
        }

        if ( ( dwType != REG_EXPAND_SZ ) && ( dwType != REG_SZ ) )
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;

            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;

        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings( pDllPath, NULL, 0 );

        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        pDllExpandedPath = (LPWSTR)LOCAL_ALLOC( LPTR, cbSize*sizeof(WCHAR) );

        if ( pDllExpandedPath == (LPWSTR)NULL )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode );
            break;
        }

        cbSize = ExpandEnvironmentStrings(
                                pDllPath,
                                pDllExpandedPath,
                                cbSize );
        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        gblDDMConfigInfo.hInstSecurityModule = LoadLibrary( pDllExpandedPath );

        if ( gblDDMConfigInfo.hInstSecurityModule == (HINSTANCE)NULL )
        {
            dwRetCode = GetLastError();
            
            if(     (ERROR_INVALID_EXE_SIGNATURE == dwRetCode)
                ||  (ERROR_BAD_EXE_FORMAT == dwRetCode)
                ||  (ERROR_EXE_MARKED_INVALID == dwRetCode))
            {
                DDMLogError(ROUTERLOG_CANT_LOAD_SECDLL_EXPLICIT,
                            1, &pDllExpandedPath, 0);
            }
            else
            {
                DDMLogErrorString(ROUTERLOG_CANT_LOAD_SECDLL, 
                            0, NULL, dwRetCode,0);
            }
            break;
        }

        gblDDMConfigInfo.lpfnRasBeginSecurityDialog =
                            (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstSecurityModule,
                                        "RasSecurityDialogBegin" );

        if ( gblDDMConfigInfo.lpfnRasBeginSecurityDialog == NULL )
        {
            dwRetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_SECDLL,0,NULL,dwRetCode,0);
            break;

        }

        gblDDMConfigInfo.lpfnRasEndSecurityDialog =
                            (PVOID)GetProcAddress(
                                        gblDDMConfigInfo.hInstSecurityModule,
                                        "RasSecurityDialogEnd" );

        if ( gblDDMConfigInfo.lpfnRasEndSecurityDialog == NULL )
        {
            dwRetCode = GetLastError();
            DDMLogErrorString(ROUTERLOG_CANT_LOAD_SECDLL,0,NULL,dwRetCode,0);
            break;

        }

    }while(FALSE);

    if ( pDllPath != NULL )
    {
        LOCAL_FREE( pDllPath );
    }

    if ( pDllExpandedPath != NULL )
    {
        LOCAL_FREE( pDllExpandedPath );
    }

    RegCloseKey( hKey );

    return( dwRetCode );
}

//***
//
// Function:    LoadAdminModule
//
// Descr:       Opens the registry, reads and sets specified supervisor
//              parameters for the admin module. If fatal error reading
//              parameters writes the error log.
//
// Returns:     NO_ERROR  - success
//              otherwise - fatal error.
//
//***
DWORD
LoadAdminModule(
    VOID
)
{
    DWORD               RetCode = NO_ERROR;
    DWORD               MaxValueDataSize;
    DWORD               MaxValNameSize;
    DWORD               NumValues;
    DWORD               dwType;
    WCHAR *             pDllPath = NULL;
    WCHAR *             pDllExpandedPath = NULL;
    DWORD               cbSize;
    HKEY                hKey;
    DWORD               (*lpfnRasAdminInitializeDll)();
    WCHAR               *pDelimiter, *pStartDllPath, *pEndDllPath;
    DWORD               NumAdminDlls;
    BOOL                bDone;
    HANDLE              hAdminDll=NULL;
    
    gblDDMConfigInfo.NumAdminDlls = 0;

    
    // get handle to the RAS key

    RetCode = RegOpenKey( HKEY_LOCAL_MACHINE, DDM_ADMIN_KEY_PATH, &hKey);

    if ( RetCode == ERROR_FILE_NOT_FOUND )
    {
        return( NO_ERROR );
    }
    else if ( RetCode != NO_ERROR )
    {
        DDMLogErrorString(ROUTERLOG_CANT_OPEN_ADMINMODULE_KEY,0,NULL,RetCode,0);
        return ( RetCode );
    }

    do {

        // get the length of the path.

        if (( RetCode = GetKeyMax(hKey,
                                  &MaxValNameSize,
                                  &NumValues,
                                  &MaxValueDataSize)))
        {

            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode);
            break;
        }

        if (( pDllPath = LOCAL_ALLOC(LPTR,MaxValueDataSize+sizeof(WCHAR)))
                                                                        == NULL)
        {
            DDMLogError(ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, 0);
            break;
        }

        //
        // Read in the path
        //

        RetCode = RegQueryValueEx(  hKey,
                                    DDM_VALNAME_DLLPATH,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)pDllPath,
                                    &MaxValueDataSize );

        // min size should be greater than 2 (2 for null)
        if (MaxValueDataSize <= 2)
            return NO_ERROR;
            
        if ( RetCode != NO_ERROR )
        {
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode);
            break;
        }

        if ( ( dwType != REG_EXPAND_SZ ) && ( dwType != REG_SZ ) )
        {
            RetCode = ERROR_REGISTRY_CORRUPT;
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode );
            break;
        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings( pDllPath, NULL, 0 );

        if ( cbSize == 0 )
        {
            RetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode );
            break;
        }

        pDllExpandedPath = (LPWSTR)LOCAL_ALLOC( LPTR, cbSize*sizeof(WCHAR) );

        if ( pDllExpandedPath == (LPWSTR)NULL )
        {
            RetCode = GetLastError();
            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, RetCode );
            break;
        }

        cbSize = ExpandEnvironmentStrings(
                                pDllPath,
                                pDllExpandedPath,
                                cbSize );
        if ( cbSize == 0 )
        {
            RetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, RetCode );
            break;
        }


        //
        // locate each dll and load its callbacks
        //

        // get number of dlls. NumAdminDlls can be more by 1 if ending in ';'
        
        pStartDllPath = pDllExpandedPath;
        pEndDllPath = pDllExpandedPath + cbSize - 1;
        for (NumAdminDlls=1;  NULL!=(pDelimiter = wcschr(pStartDllPath, L';'));  
            NumAdminDlls++, pStartDllPath=pDelimiter+1);
        pStartDllPath = pDllExpandedPath;


        // allocate array for all Dlls' callbacks
        
        gblDDMConfigInfo.AdminDllCallbacks = (PADMIN_DLL_CALLBACKS)
            LOCAL_ALLOC(LPTR, sizeof(ADMIN_DLL_CALLBACKS)*NumAdminDlls);
            
        if (gblDDMConfigInfo.AdminDllCallbacks == NULL)
        {
            RetCode = GetLastError();

                DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, RetCode);

            break;
        }

        bDone = FALSE;
        
        while (TRUE) {

            PADMIN_DLL_CALLBACKS AdminDllCallbacks = 
                &gblDDMConfigInfo.AdminDllCallbacks[gblDDMConfigInfo.NumAdminDlls];

            hAdminDll = NULL;
            pDelimiter = wcschr(pStartDllPath, L';');

            if (pDelimiter)
                *pDelimiter = L'\0';
            else
                bDone = TRUE;

            if (*pStartDllPath == L' ')
                break;
                
            // load the dll
            
            AdminDllCallbacks->hInstAdminModule = hAdminDll = LoadLibrary( pStartDllPath );
            if ( AdminDllCallbacks->hInstAdminModule == (HINSTANCE)NULL )
            {
                RetCode = GetLastError();
                
                if(     (ERROR_INVALID_EXE_SIGNATURE == RetCode)
                    ||  (ERROR_BAD_EXE_FORMAT == RetCode)
                    ||  (ERROR_EXE_MARKED_INVALID == RetCode))
                {
                    DDMLogError(ROUTERLOG_CANT_LOAD_ADMINDLL_EXPLICIT,
                                1, &pDllExpandedPath, 0);
                }
                else
                {
                    DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL, 
                                0, NULL, RetCode,0);
                }

                break;
            }

            lpfnRasAdminInitializeDll = (DWORD(*)(VOID))GetProcAddress(
                                            AdminDllCallbacks->hInstAdminModule,
                                            "MprAdminInitializeDll" );

            AdminDllCallbacks->lpfnRasAdminTerminateDll =
                                    (PVOID)GetProcAddress(
                                            AdminDllCallbacks->hInstAdminModule,
                                            "MprAdminTerminateDll" );

            AdminDllCallbacks->lpfnRasAdminAcceptNewConnection =
                                    (PVOID)GetProcAddress(
                                            AdminDllCallbacks->hInstAdminModule,
                                            "MprAdminAcceptNewConnection" );

            AdminDllCallbacks->lpfnRasAdminAcceptNewConnection2 =
                                    (PVOID)GetProcAddress(
                                            AdminDllCallbacks->hInstAdminModule,
                                            "MprAdminAcceptNewConnection2" );

            //
            // At least one of these 2 must be available
            //

            if ( ( AdminDllCallbacks->lpfnRasAdminAcceptNewConnection == NULL ) &&
                 ( AdminDllCallbacks->lpfnRasAdminAcceptNewConnection2 == NULL ) ) 
            {
                RetCode = GetLastError();
                DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
                break;
            }

            AdminDllCallbacks->lpfnRasAdminAcceptNewLink =
                                    (PVOID)GetProcAddress(
                                            AdminDllCallbacks->hInstAdminModule,
                                            "MprAdminAcceptNewLink" );

            if ( AdminDllCallbacks->lpfnRasAdminAcceptNewLink == NULL )
            {
                RetCode = GetLastError();
                DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
                break;
            }

            AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification =
                            (PVOID)GetProcAddress(
                                    AdminDllCallbacks->hInstAdminModule,
                                    "MprAdminConnectionHangupNotification" );

            AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification2 =
                            (PVOID)GetProcAddress(
                                    AdminDllCallbacks->hInstAdminModule,
                                    "MprAdminConnectionHangupNotification2" );

            //
            // At least one of these 2 entrypoints must be available
            //

            if ( (AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification==NULL)
                 &&
                 (AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification2==NULL))
            {
                RetCode = GetLastError();
                DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
                break;
            }

            if ( lpfnRasAdminInitializeDll != NULL )
            {
                RetCode = (*lpfnRasAdminInitializeDll)();

                if(ERROR_SUCCESS != RetCode)
                {
                        DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,
                                            0,NULL,RetCode,0);
                        break;
                }
            }
            AdminDllCallbacks->lpfnRasAdminLinkHangupNotification =
                                    (PVOID)GetProcAddress(
                                            AdminDllCallbacks->hInstAdminModule,
                                            "MprAdminLinkHangupNotification" );

            if ( AdminDllCallbacks->lpfnRasAdminLinkHangupNotification == NULL )
            {
                RetCode = GetLastError();
                DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
                break;
            }

            AdminDllCallbacks->lpfnMprAdminGetIpAddressForUser =
                                    (PVOID)GetProcAddress(
                                            AdminDllCallbacks->hInstAdminModule,
                                            "MprAdminGetIpAddressForUser" );

            AdminDllCallbacks->lpfnMprAdminReleaseIpAddress =
                                    (PVOID)GetProcAddress(
                                            AdminDllCallbacks->hInstAdminModule,
                                            "MprAdminReleaseIpAddress" );

            if ( ( (AdminDllCallbacks->lpfnMprAdminGetIpAddressForUser != NULL)
                && ( AdminDllCallbacks->lpfnMprAdminReleaseIpAddress == NULL ))
                || ( (AdminDllCallbacks->lpfnMprAdminGetIpAddressForUser == NULL)
                && ( AdminDllCallbacks->lpfnMprAdminReleaseIpAddress != NULL )) )
            {
                RetCode = GetLastError();
                DDMLogErrorString(ROUTERLOG_CANT_LOAD_ADMINDLL,0,NULL,RetCode,0);
                break;
            }

            if(ERROR_SUCCESS != RetCode)
                break;

            // one more admin dll successfully loaded
            gblDDMConfigInfo.NumAdminDlls++;
            
            if (bDone) {
                break;
            }
            
            pStartDllPath = pDelimiter + 1;
            if (pStartDllPath >= pEndDllPath)
                break;
        }

        if ( (ERROR_SUCCESS != RetCode) && (hAdminDll!=NULL) )
        {
            FreeLibrary(hAdminDll);
        }
        
    }while(FALSE); //breakout block

    if ( pDllPath != NULL )
    {
        LOCAL_FREE( pDllPath );
    }

    if ( pDllExpandedPath != NULL )
    {
        LOCAL_FREE( pDllExpandedPath );
    }

    RegCloseKey( hKey );

    return( RetCode );
}

//**
//
// Call:        LoadAndInitAuthOrAcctProvider
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD
LoadAndInitAuthOrAcctProvider( 
    IN  BOOL        fAuthenticationProvider,
    IN  DWORD       dwNASIpAddress,
    OUT DWORD  *    lpdwStartAccountingSessionId,
    OUT LPVOID *    plpfnRasAuthProviderAuthenticateUser,
    OUT LPVOID *    plpfnRasAuthProviderFreeAttributes,
    OUT LPVOID *    plpfnRasAuthConfigChangeNotification,
    OUT LPVOID *    plpfnRasAcctProviderStartAccounting,
    OUT LPVOID *    plpfnRasAcctProviderInterimAccounting,
    OUT LPVOID *    plpfnRasAcctProviderStopAccounting,
    OUT LPVOID *    plpfnRasAcctProviderFreeAttributes,
    OUT LPVOID *    plpfnRasAcctConfigChangeNotification
)
{
    HKEY        hKeyProviders       = NULL;
    HKEY        hKeyCurrentProvider = NULL;
    LPWSTR      pDllPath            = (LPWSTR)NULL;
    LPWSTR      pDllExpandedPath    = (LPWSTR)NULL;
    LPWSTR      pProviderName       = (LPWSTR)NULL;
    HINSTANCE   hinstProviderModule = NULL;
    DWORD       dwRetCode;
    WCHAR       chSubKeyName[100];
    DWORD       cbSubKeyName;
    DWORD       dwNumSubKeys;
    DWORD       dwMaxSubKeySize;
    DWORD       dwNumValues;
    DWORD       cbMaxValNameLen;
    DWORD       cbMaxValueDataSize;
    DWORD       cbSize;
    DWORD       dwType;
    CHAR        chComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    RAS_AUTH_ATTRIBUTE  ServerAttributes[3];
    CHAR  szAcctSessionId[20];

    do
    {

        dwRetCode = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                fAuthenticationProvider 
                                    ? RAS_AUTHPROVIDER_REGISTRY_LOCATION
                                    : RAS_ACCTPROVIDER_REGISTRY_LOCATION,
                                0,
                                KEY_READ,
                                &hKeyProviders );


        if ( dwRetCode != NO_ERROR ) 
        {
            LPWSTR lpStr = fAuthenticationProvider 
                                    ? RAS_AUTHPROVIDER_REGISTRY_LOCATION
                                    : RAS_ACCTPROVIDER_REGISTRY_LOCATION;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &lpStr, dwRetCode );

            break;
        }

        //
        // Find out the size of the provider value
        //

        dwRetCode = RegQueryInfoKey(
                                hKeyProviders,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubKeys,
                                &dwMaxSubKeySize,
                                NULL,
                                &dwNumValues,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL
                                );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;
        }

        //
        // One extra for the NULL terminator
        //

        cbMaxValueDataSize += sizeof(WCHAR);

        pProviderName = (LPWSTR)LOCAL_ALLOC( LPTR, cbMaxValueDataSize );

        if ( pProviderName == NULL )
        {
            dwRetCode = GetLastError();

            break;
        }

        //
        // Find out the provider to use
        //

        dwRetCode = RegQueryValueEx(
                                hKeyProviders,
                                RAS_VALNAME_ACTIVEPROVIDER,
                                NULL,
                                &dwType,
                                (BYTE*)pProviderName,
                                &cbMaxValueDataSize
                                );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;
        }

        if ( dwType != REG_SZ )
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;

            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;
        }

        if ( wcslen( pProviderName ) == 0 )
        {
            dwRetCode = fAuthenticationProvider 
                            ? ERROR_REGISTRY_CORRUPT : NO_ERROR;
            break;
        }
        else
        {
            if ( !fAuthenticationProvider )
            {
                HKEY hKeyAccounting;

                dwRetCode = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                RAS_KEYPATH_ACCOUNTING,
                                0,
                                KEY_READ,
                                &hKeyAccounting );

                if ( dwRetCode == NO_ERROR )
                {
                    cbMaxValueDataSize = sizeof( DWORD );

                    dwRetCode = 
                            RegQueryValueEx(
                                hKeyAccounting,
                                RAS_VALNAME_ACCTSESSIONID,
                                NULL,
                                &dwType,
                                (BYTE*)lpdwStartAccountingSessionId,
                                &cbMaxValueDataSize );

                    if ( ( dwRetCode != NO_ERROR ) || ( dwType != REG_DWORD ) )
                    {
                        *lpdwStartAccountingSessionId = 0;
                    }
                    
                    RegCloseKey( hKeyAccounting );
                }

                if ( wcscmp( pProviderName,    
                             TEXT("{1AA7F840-C7F5-11D0-A376-00C04FC9DA04}") ) 
                                                                          == 0 )
                {
                    gblDDMConfigInfo.fFlags |= DDM_USING_RADIUS_ACCOUNTING;
                }
            }
            else
            {
                if ( wcscmp( pProviderName,    
                             TEXT("{1AA7F83F-C7F5-11D0-A376-00C04FC9DA04}") ) 
                                                                          == 0 )
                {
                    gblDDMConfigInfo.fFlags |= DDM_USING_RADIUS_AUTHENTICATION;
                }
                else if ( wcscmp( 
                            pProviderName,    
                            TEXT("{1AA7F841-C7F5-11D0-A376-00C04FC9DA04}") ) 
                                                                          == 0 )
                {
                    gblDDMConfigInfo.fFlags |= DDM_USING_NT_AUTHENTICATION;
                }

            }
        }

        dwRetCode = RegOpenKeyEx(
                                hKeyProviders,
                                pProviderName,
                                0,
                                KEY_READ,
                                &hKeyCurrentProvider );


        if ( dwRetCode != NO_ERROR )
        {
            LPWSTR lpStr = RAS_ACCTPROVIDER_REGISTRY_LOCATION;

            DDMLogError( ROUTERLOG_CANT_OPEN_REGKEY, 1, &lpStr, dwRetCode );

            break;
        }

        //
        // Find out the size of the path value.
        //

        dwRetCode = RegQueryInfoKey(
                                hKeyCurrentProvider,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubKeys,
                                &dwMaxSubKeySize,
                                NULL,
                                &dwNumValues,
                                &cbMaxValNameLen,
                                &cbMaxValueDataSize,
                                NULL,
                                NULL
                                );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );

            break;
        }

        //
        // Allocate space for path and add one for NULL terminator
        //

        cbMaxValueDataSize += sizeof(WCHAR);

        pDllPath = (LPWSTR)LOCAL_ALLOC( LPTR, cbMaxValueDataSize );

        if ( pDllPath == (LPWSTR)NULL )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        //
        // Read in the path
        //

        dwRetCode = RegQueryValueEx(
                                hKeyCurrentProvider,
                                RAS_PROVIDER_VALUENAME_PATH,
                                NULL,
                                &dwType,
                                (PBYTE)pDllPath,
                                &cbMaxValueDataSize
                                );

        if ( dwRetCode != NO_ERROR )
        {
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        if ( ( dwType != REG_EXPAND_SZ ) && ( dwType != REG_SZ ) )
        {
            dwRetCode = ERROR_REGISTRY_CORRUPT;
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        //
        // Replace the %SystemRoot% with the actual path.
        //

        cbSize = ExpandEnvironmentStrings( pDllPath, NULL, 0 );

        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_CANT_GET_REGKEYVALUES, 0, NULL, dwRetCode );
            break;
        }

        cbSize *= sizeof( WCHAR );

        pDllExpandedPath = (LPWSTR)LOCAL_ALLOC( LPTR, cbSize );

        if ( pDllExpandedPath == (LPWSTR)NULL )
        {
            dwRetCode = GetLastError();
            DDMLogError( ROUTERLOG_NOT_ENOUGH_MEMORY, 0, NULL, dwRetCode);
            break;
        }

        cbSize = ExpandEnvironmentStrings(
                                pDllPath,
                                pDllExpandedPath,
                                cbSize );
        if ( cbSize == 0 )
        {
            dwRetCode = GetLastError();
            DDMLogError(ROUTERLOG_CANT_GET_REGKEYVALUES,0,NULL,dwRetCode);
            break;
        }

        hinstProviderModule = LoadLibrary( pDllExpandedPath );

        if ( hinstProviderModule == (HINSTANCE)NULL )
        {
            dwRetCode = GetLastError();
            break;
        }

        //
        // Get server attributes that will be used to initialize authentication
        // and accounting providers
        //

        if ( dwNASIpAddress == 0 )
        {
            DWORD dwComputerNameLen = sizeof( chComputerName);

            //
            // Failed to get the LOCAL IP address, use computer name instead.
            //

            if ( !GetComputerNameA( chComputerName, &dwComputerNameLen ) )
            {
                dwRetCode = GetLastError();
                break;
            }

            ServerAttributes[0].raaType     = raatNASIdentifier;
            ServerAttributes[0].dwLength    = strlen(chComputerName);
            ServerAttributes[0].Value       = chComputerName;
        }
        else
        {
            ServerAttributes[0].raaType     = raatNASIPAddress;
            ServerAttributes[0].dwLength    = 4;
            ServerAttributes[0].Value       = UlongToPtr(dwNASIpAddress);
        }

        if ( !fAuthenticationProvider )
        {

            ZeroMemory( szAcctSessionId, sizeof( szAcctSessionId ) );

            _itoa( (*lpdwStartAccountingSessionId)++, szAcctSessionId, 10 );

            ServerAttributes[1].raaType     = raatAcctSessionId;
            ServerAttributes[1].dwLength    = strlen( szAcctSessionId );
            ServerAttributes[1].Value       = (PVOID)szAcctSessionId;

            ServerAttributes[2].raaType     = raatMinimum;
            ServerAttributes[2].dwLength    = 0;
            ServerAttributes[2].Value       = NULL;
        }
        else
        {
            ServerAttributes[1].raaType     = raatMinimum;
            ServerAttributes[1].dwLength    = 0;
            ServerAttributes[1].Value       = NULL;
        }

        if ( fAuthenticationProvider )
        {
            DWORD (*RasAuthProviderInitialize)( RAS_AUTH_ATTRIBUTE *, HANDLE, DWORD );

            gblDDMConfigInfo.hinstAuthModule = hinstProviderModule;

            RasAuthProviderInitialize =
                                (DWORD(*)(RAS_AUTH_ATTRIBUTE*, HANDLE, DWORD))
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAuthProviderInitialize" );

            if ( RasAuthProviderInitialize == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            dwRetCode = RasAuthProviderInitialize(
                                    (RAS_AUTH_ATTRIBUTE *)ServerAttributes,
                                    gblDDMConfigInfo.hLogEvents,
                                    gblDDMConfigInfo.dwLoggingLevel );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            gblDDMConfigInfo.lpfnRasAuthProviderTerminate = (DWORD(*)(VOID))
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAuthProviderTerminate" );

            if ( gblDDMConfigInfo.lpfnRasAuthProviderTerminate == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAuthProviderAuthenticateUser = 
                                    GetProcAddress(
                                        hinstProviderModule,
                                        "RasAuthProviderAuthenticateUser" );

            if ( *plpfnRasAuthProviderAuthenticateUser == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAuthProviderFreeAttributes =
                                        GetProcAddress(
                                            hinstProviderModule,
                                          "RasAuthProviderFreeAttributes" );

            if ( *plpfnRasAuthProviderFreeAttributes == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAuthConfigChangeNotification =
                                        GetProcAddress(
                                            hinstProviderModule,
                                          "RasAuthConfigChangeNotification" );

            if ( *plpfnRasAuthConfigChangeNotification == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }
        }
        else
        {
            DWORD (*RasAcctProviderInitialize)( RAS_AUTH_ATTRIBUTE *, HANDLE, DWORD );

            gblDDMConfigInfo.hinstAcctModule = hinstProviderModule;
        
            RasAcctProviderInitialize = 
                                (DWORD(*)(RAS_AUTH_ATTRIBUTE*, HANDLE, DWORD))
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderInitialize" );

            if ( RasAcctProviderInitialize == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            dwRetCode = RasAcctProviderInitialize(
                                    (RAS_AUTH_ATTRIBUTE *)ServerAttributes,
                                    gblDDMConfigInfo.hLogEvents,
                                    gblDDMConfigInfo.dwLoggingLevel );

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            gblDDMConfigInfo.lpfnRasAcctProviderTerminate = (DWORD(*)(VOID))
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderTerminate" );

            if ( gblDDMConfigInfo.lpfnRasAcctProviderTerminate == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctProviderStartAccounting = 
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderStartAccounting" );

            if ( *plpfnRasAcctProviderStartAccounting == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctProviderStopAccounting = 
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderStopAccounting" );

            if ( *plpfnRasAcctProviderStopAccounting == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctProviderInterimAccounting =
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderInterimAccounting");

            if ( *plpfnRasAcctProviderInterimAccounting == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctProviderFreeAttributes = 
                                        GetProcAddress(
                                            hinstProviderModule,
                                            "RasAcctProviderFreeAttributes" );

            if ( *plpfnRasAcctProviderFreeAttributes == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }

            *plpfnRasAcctConfigChangeNotification =
                                        GetProcAddress(
                                            hinstProviderModule,
                                          "RasAcctConfigChangeNotification" );

            if ( *plpfnRasAcctConfigChangeNotification == NULL )
            {
                dwRetCode = GetLastError();
                break;
            }
        }

    }while( FALSE );

    if ( hKeyProviders != NULL )
    {
        RegCloseKey( hKeyProviders );
    }

    if ( hKeyCurrentProvider != NULL )
    {
        RegCloseKey( hKeyCurrentProvider );
    }

    if ( pDllPath != NULL )
    {
        LOCAL_FREE( pDllPath );
    }

    if ( pDllExpandedPath != NULL )
    {
        LOCAL_FREE( pDllExpandedPath );
    }

    if ( pProviderName != NULL )
    {
        LOCAL_FREE( pProviderName );
    }

    return( dwRetCode );
}

LONG
RegQueryDword (HKEY hkey, LPCTSTR szValueName, LPDWORD pdwValue)
{
    // Get the value.
    //
    DWORD dwType;
    DWORD cbData = sizeof(DWORD);
    LONG  lr = RegQueryValueEx (hkey, szValueName, NULL, &dwType,
                                (LPBYTE)pdwValue, &cbData);

    // It's type should be REG_DWORD. (duh).
    //
    if ((ERROR_SUCCESS == lr) && (REG_DWORD != dwType))
    {
        lr = ERROR_INVALID_DATATYPE;
    }

    // Make sure we initialize the output value on error.
    // (We don't know for sure that RegQueryValueEx does this.)
    //
    if (ERROR_SUCCESS != lr)
    {
        *pdwValue = 0;
    }

    return lr;
}

DWORD
lProtocolEnabled(
    IN HKEY            hKey,
    IN DWORD           dwPid,
    IN BOOL            fRasSrv,
    IN BOOL            fRouter, 
    IN BOOL *          pfEnabled
)
{
    static const TCHAR c_szRegValEnableIn[]     = TEXT("EnableIn");
    static const TCHAR c_szRegValEnableRoute[]  = TEXT("EnableRoute");
    static const TCHAR c_szRegSubkeyIp[]        = TEXT("Ip");
    static const TCHAR c_szRegSubkeyIpx[]       = TEXT("Ipx");
    static const TCHAR c_szRegSubkeyATalk[]     = TEXT("AppleTalk");

    DWORD               dwValue;
    DWORD               lr;
    HKEY                hkeyProtocol = NULL;
    const TCHAR *       pszSubkey;

    switch ( dwPid )
    {
    case PID_IP:
        pszSubkey = c_szRegSubkeyIp;
        break;

    case PID_IPX:
        pszSubkey = c_szRegSubkeyIpx;
        break;

    case PID_ATALK:
        pszSubkey = c_szRegSubkeyATalk;
        break;

    default:
        return( FALSE );
    }

    *pfEnabled = FALSE;

    lr = RegOpenKey( hKey, pszSubkey, &hkeyProtocol );
                
    if ( 0 != lr )
    {
        goto done;
    }

    if (fRasSrv)
    {
        lr = RegQueryDword(hkeyProtocol, c_szRegValEnableIn, &dwValue);
        
        if (    (ERROR_FILE_NOT_FOUND == lr) 
            ||  ((ERROR_SUCCESS == lr) && (dwValue != 0)))
        {
            lr = ERROR_SUCCESS;
            *pfEnabled = TRUE;
            goto done;
        }
    }

    if (fRouter)
    {
        lr = RegQueryDword(hkeyProtocol, c_szRegValEnableRoute, &dwValue);
        
        if (    (ERROR_FILE_NOT_FOUND == lr) 
            ||  ((ERROR_SUCCESS == lr) && (dwValue != 0)))
        {
            lr = ERROR_SUCCESS;
            *pfEnabled = TRUE;
            goto done;
        }
    }

done:

    if(NULL != hkeyProtocol)
    {
        RegCloseKey ( hkeyProtocol );
    }

    return lr;
}

DWORD 
DdmFindBoundProtocols( 
    OUT BOOL * pfBoundToIp, 
    OUT BOOL * pfBoundToIpx,
    OUT BOOL * pfBoundToATalk
)
{
    static const TCHAR c_szRegKeyRemoteAccessParams[] 
      = TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters");
    RASMAN_GET_PROTOCOL_INFO InstalledProtocols;
    LONG                     lResult = 0;
    HKEY                     hKey = NULL;
    DWORD                    i;

    *pfBoundToIp    = FALSE;
    *pfBoundToIpx   = FALSE;
    *pfBoundToATalk = FALSE;
    
    lResult = RasGetProtocolInfo( NULL, &InstalledProtocols );

    if ( lResult != NO_ERROR )
    {
        goto done;
    }

    lResult = RegOpenKey( HKEY_LOCAL_MACHINE, c_szRegKeyRemoteAccessParams, &hKey );

    if ( 0 != lResult )
    {
        goto done;
    }

    for ( i = 0; i < InstalledProtocols.ulNumProtocols; i++ )
    {
        switch( InstalledProtocols.ProtocolInfo[i].ProtocolType )
        {

        case IPX:     
#if (WINVER < 0x0501)
            lResult=lProtocolEnabled( hKey,
                                      PID_IPX,
                                      TRUE,
                                      FALSE,
                                      pfBoundToIpx);
#endif
            break;

        case IP:      

            lResult=lProtocolEnabled( hKey,
                                      PID_IP,
                                      TRUE,
                                      FALSE,
                                      pfBoundToIp );
            break;

        case APPLETALK:

            lResult=lProtocolEnabled( hKey,
                                      PID_ATALK,
                                      TRUE, 
                                      FALSE, 
                                      pfBoundToATalk);
            break;

        default:

            break;
        }
    }

    RegCloseKey( hKey );

done:

    return ( DWORD ) lResult;
}

DWORD
GetArrayOfIpAddresses(PWSTR pwszIpAddresses,
                      DWORD *pcNumValues,
                      PWSTR **papwstrValues)
{
    DWORD cValues       = 0;
    PWSTR psz           = pwszIpAddresses;
    DWORD dwErr         = ERROR_SUCCESS;
    DWORD i;
    PWSTR *apwstrValues = NULL;

    do
    {
        for(; TEXT('\0') != *psz; cValues++)
        {
            psz += (wcslen(psz) + 1);
        }

        apwstrValues = LocalAlloc(LPTR, cValues * sizeof(PWSTR));
    
        if(NULL == apwstrValues)
        {
            dwErr = GetLastError();
            break;
        }

        psz = pwszIpAddresses;
        
        for(i = 0; TEXT('\0') != *psz; i++)
        {
            apwstrValues[i] = psz;
            psz += (wcslen(psz) + 1);    
        }

    } while (FALSE);

    *pcNumValues = cValues;
    *papwstrValues = apwstrValues;

    return dwErr;
    
}

DWORD
GetIPAddressPoolFromRegistry(
                    HKEY  hkey,
                    PWSTR pszValueName,
                    DWORD *pcNumValues,
                    PWSTR **papwstrValues
                    )
{
    DWORD dwErr             = ERROR_SUCCESS;
    DWORD dwType;
    DWORD dwSize            = 0;
    PWSTR pwszIpAddresses   = NULL;

    do
    {
        if(     (NULL == papwstrValues)
            ||  (NULL == pcNumValues)
            ||  (NULL == pszValueName)
            ||  (NULL == hkey))
        {
            dwErr = ERROR_INVALID_HANDLE;
            break;
        }

        *pcNumValues = 0;
        *papwstrValues = NULL;

        //
        // Find the size of the MULTI_SZ
        //
        dwErr = RegQueryValueEx(
                            hkey,
                            pszValueName,
                            NULL,
                            &dwType,
                            NULL,
                            &dwSize);

        if(     (ERROR_SUCCESS != dwErr)
            ||  (REG_MULTI_SZ != dwType)
            ||  (0 == dwSize))
        {
            //
            // Trace out that failed to read the information
            // and bail.
            //
            break;
        }

        //
        // Allocate the bufffer
        //
        pwszIpAddresses = LocalAlloc(LPTR, dwSize);

        if(NULL == pwszIpAddresses)
        {
            dwErr = GetLastError();
            break;
        }

        //
        // Get the strings
        //
        dwErr = RegQueryValueEx(
                            hkey,
                            pszValueName,
                            NULL,
                            &dwType,
                            (LPBYTE) pwszIpAddresses,
                            &dwSize);


        if(ERROR_SUCCESS != dwErr)
        {
            //
            // Trace
            //
            break;
        }

        //
        // Construct the array of IPAddresses
        //
        dwErr = GetArrayOfIpAddresses(pwszIpAddresses,
                                      pcNumValues,
                                      papwstrValues);
        
        
    } while (FALSE);

    return dwErr;
}

DWORD
AddressPoolInit(
            VOID
            )
{
    HKEY hkey = NULL;
    DWORD dwErr = ERROR_SUCCESS;

    gblDDMConfigInfo.cAnalogIPAddresses   = 0;
    gblDDMConfigInfo.apAnalogIPAddresses  = NULL;
    gblDDMConfigInfo.cDigitalIPAddresses  = 0;
    gblDDMConfigInfo.apDigitalIPAddresses = NULL;

    do
    {
        dwErr = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("System\\CurrentControlSet\\Services\\PptpProtocol\\Parameters"),
                    0,
                    KEY_READ,
                    &hkey);

        if(ERROR_SUCCESS != dwErr)
        {
            break;
        }

        //
        // Get Analog IP Address Pool
        //
        dwErr = GetIPAddressPoolFromRegistry(
                            hkey,
                            TEXT("AnalogIPAddressPool"),
                            &gblDDMConfigInfo.cAnalogIPAddresses,
                            &gblDDMConfigInfo.apAnalogIPAddresses);

        //
        // Trace out the errors here
        //

        //
        // Get Digital IP Address Pool
        //
        dwErr = GetIPAddressPoolFromRegistry(
                            hkey,
                            TEXT("DigitalIPAddressPool"),
                            &gblDDMConfigInfo.cDigitalIPAddresses,
                            &gblDDMConfigInfo.apDigitalIPAddresses);


        //
        // Trace out the errors here
        //

                            
    } while(FALSE);    

    if(NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    if(ERROR_FILE_NOT_FOUND == dwErr)
    {
        dwErr = ERROR_SUCCESS;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\timer.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	timer.c
//
// Description: All timer queue related funtions live here.
//
// History:
//	Nov 11,1993.	NarenG		Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>     // needed for winbase.h
#include <windows.h>    // Win32 base API's
#include "ddm.h"
#include "timer.h"
#include <rasppp.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

//
//
// Timer queue item
//

typedef struct _TIMER_EVENT_OBJECT
{
    struct _TIMER_EVENT_OBJECT * pNext;

    struct _TIMER_EVENT_OBJECT * pPrev;
        
    TIMEOUT_HANDLER              pfuncTimeoutHandler;

    HANDLE                       hObject;

    DWORD                        dwDelta; // # of secs. to wait after prev. item

} TIMER_EVENT_OBJECT, *PTIMER_EVENT_OBJECT;

//
// Head of timer queue.
//

typedef struct _TIMER_Q 
{
    TIMER_EVENT_OBJECT * pQHead;

    CRITICAL_SECTION     CriticalSection; // Mutual exclusion around timer Q

} TIMER_Q, *PTIMER_Q;


static TIMER_Q gblTimerQ;          // Timer Queue

//**
//
// Call:        TimerQInitialize
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Initializes the gblTimerQ structure
//
DWORD
TimerQInitialize(
    VOID 
)
{
    //
    // Initialize the global timer queue
    //

    InitializeCriticalSection( &(gblTimerQ.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:        TimerQDelete
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Deinitializes the TimerQ
//
VOID
TimerQDelete(
    VOID
)
{
    DeleteCriticalSection( &(gblTimerQ.CriticalSection) );

    ZeroMemory( &gblTimerQ, sizeof( gblTimerQ ) );
}

//**
//
// Call:	TimerQTick
//
// Returns:	None.
//
// Description: Called each second if there are elements in the timeout queue.
//
VOID
TimerQTick(
    VOID
)
{
    TIMER_EVENT_OBJECT * pTimerEvent;
    TIMER_EVENT_OBJECT * pTimerEventTmp;

    //
    // **** Exclusion Begin ****
    //

    EnterCriticalSection( &(gblTimerQ.CriticalSection) );


    if ( ( pTimerEvent = gblTimerQ.pQHead ) == (TIMER_EVENT_OBJECT*)NULL ) 
    {
	    //
	    // *** Exclusion End ***
	    //

        LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

	    return;
    }

    //
    // Decrement time on the first element 
    //

    if ( pTimerEvent->dwDelta > 0 )
    {
        (pTimerEvent->dwDelta)--; 

	    //
	    // *** Exclusion End ***
	    //

        LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

	    return;
    }

    //
    // Now run through and remove all completed (delta 0) elements.
    //

    while ( ( pTimerEvent != (TIMER_EVENT_OBJECT*)NULL ) && 
            ( pTimerEvent->dwDelta == 0 ) ) 
    {
	    pTimerEvent = pTimerEvent->pNext;
    }

    if ( pTimerEvent == (TIMER_EVENT_OBJECT*)NULL )
    {
	    pTimerEvent = gblTimerQ.pQHead;

        gblTimerQ.pQHead = (TIMER_EVENT_OBJECT*)NULL;

    }
    else
    {
	    pTimerEvent->pPrev->pNext = (TIMER_EVENT_OBJECT*)NULL;

	    pTimerEvent->pPrev = (TIMER_EVENT_OBJECT*)NULL;

        pTimerEventTmp     = gblTimerQ.pQHead;

        gblTimerQ.pQHead   = pTimerEvent;

        pTimerEvent        = pTimerEventTmp;
    }

    //
    // *** Exclusion End ***
    //

    LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

    //
    // Process all the timeout event objects items with delta == 0
    //

    while( pTimerEvent != (TIMER_EVENT_OBJECT*)NULL )
    {
        pTimerEvent->pfuncTimeoutHandler( pTimerEvent->hObject );

        if ( pTimerEvent->pNext == (TIMER_EVENT_OBJECT *)NULL )
        {
            LOCAL_FREE( pTimerEvent );

            pTimerEvent = (TIMER_EVENT_OBJECT*)NULL;
        }
        else
        {
            pTimerEvent = pTimerEvent->pNext;

            LOCAL_FREE( pTimerEvent->pPrev );
        }
    }
}

//**
//
// Call:	    TimerQInsert
//
// Returns:	    NO_ERROR			        - Success
//		        return from GetLastError() 	- Failure
//
// Description: Adds a timeout element into the delta queue. If the Timer is not
//	            started it is started. Since there is a LocalAlloc() call here -
//	            this may fail in which case it will simply not insert it in the
//	            queue and the request will never timeout.
//
DWORD
TimerQInsert(
    IN HANDLE           hObject,
    IN DWORD            dwTimeout,
    IN TIMEOUT_HANDLER  pfuncTimeoutHandler
)
{
    TIMER_EVENT_OBJECT * pLastEvent;
    TIMER_EVENT_OBJECT * pTimerEventWalker;
    TIMER_EVENT_OBJECT * pTimerEvent;
				
    pTimerEvent = (TIMER_EVENT_OBJECT *)LOCAL_ALLOC( LPTR,  
                                               sizeof(TIMER_EVENT_OBJECT));

    if ( pTimerEvent == (TIMER_EVENT_OBJECT *)NULL )
    {
	    return( GetLastError() );
    }

    pTimerEvent->hObject             = hObject;
    pTimerEvent->pfuncTimeoutHandler = pfuncTimeoutHandler;
	
    //
    // **** Exclusion Begin ****
    //

    EnterCriticalSection( &(gblTimerQ.CriticalSection) );

    for ( pTimerEventWalker = gblTimerQ.pQHead,
	      pLastEvent        = pTimerEventWalker;

	      ( pTimerEventWalker != NULL ) && 
	      ( pTimerEventWalker->dwDelta < dwTimeout );

   	      pLastEvent        = pTimerEventWalker,
	      pTimerEventWalker = pTimerEventWalker->pNext 
	)
    {
	    dwTimeout -= pTimerEventWalker->dwDelta;
    }

    //
    // Insert before pTimerEventWalker. If pTimerEventWalker is NULL then 
    // we insert at the end of the list.
    //
    
    if ( pTimerEventWalker == (TIMER_EVENT_OBJECT*)NULL )
    {
	    //
	    // If the list was empty
	    //

	    if ( gblTimerQ.pQHead == (TIMER_EVENT_OBJECT*)NULL )
	    {
	        gblTimerQ.pQHead   = pTimerEvent;
	        pTimerEvent->pNext = (TIMER_EVENT_OBJECT *)NULL;
	        pTimerEvent->pPrev = (TIMER_EVENT_OBJECT *)NULL;

	    }
	    else
	    {
	        pLastEvent->pNext  = pTimerEvent;
	        pTimerEvent->pPrev = pLastEvent;
	        pTimerEvent->pNext = (TIMER_EVENT_OBJECT*)NULL;
	    }
    }
    else if ( pTimerEventWalker == gblTimerQ.pQHead )
    {
	    //
	    // Insert before the first element
	    //

	    pTimerEvent->pNext          = gblTimerQ.pQHead;
	    gblTimerQ.pQHead->pPrev     = pTimerEvent;
	    gblTimerQ.pQHead->dwDelta   -= dwTimeout;
	    pTimerEvent->pPrev          = (TIMER_EVENT_OBJECT*)NULL;
	    gblTimerQ.pQHead  	        = pTimerEvent;
    }
    else
    {

	    //
	    // Insert middle element
	    //

	    pTimerEvent->pNext 	        = pLastEvent->pNext;
	    pLastEvent->pNext  	        = pTimerEvent;
	    pTimerEvent->pPrev 	        = pLastEvent;
	    pTimerEventWalker->pPrev    = pTimerEvent;
	    pTimerEventWalker->dwDelta  -= dwTimeout;
    }

    pTimerEvent->dwDelta = dwTimeout;

    //
    // *** Exclusion End ***
    //

    LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

    return( NO_ERROR );
}

//**
//
// Call:	TimerQRemove
//
// Returns:	None.
//
// Description: Will remove a timeout event for a certain Id,hPort combination
//		        from the delta Q.
//
VOID
TimerQRemove(
    IN HANDLE           hObject,
    IN TIMEOUT_HANDLER  pfuncTimeoutHandler
)
{
    TIMER_EVENT_OBJECT * pTimerEvent;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_TIMER,
               "TimerQRemove called");

    //
    // **** Exclusion Begin ****
    //

    EnterCriticalSection( &(gblTimerQ.CriticalSection) );

    for ( pTimerEvent = gblTimerQ.pQHead;

	    ( pTimerEvent != (TIMER_EVENT_OBJECT *)NULL ) &&
          ( ( pTimerEvent->pfuncTimeoutHandler != pfuncTimeoutHandler ) ||
	        ( pTimerEvent->hObject != hObject ) );
	
	    pTimerEvent = pTimerEvent->pNext
	);

    //
    // If event was not found simply return.
    //

    if ( pTimerEvent == (TIMER_EVENT_OBJECT *)NULL )
    {
    	//
    	// *** Exclusion End ***
    	//

        LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

	    return;
    }

    //
    // If this is the first element to be removed
    //

    if ( pTimerEvent == gblTimerQ.pQHead )
    {
	    gblTimerQ.pQHead = pTimerEvent->pNext;

	    if ( gblTimerQ.pQHead != (TIMER_EVENT_OBJECT *)NULL )
	    {   
	        gblTimerQ.pQHead->pPrev     = (TIMER_EVENT_OBJECT*)NULL;
	        gblTimerQ.pQHead->dwDelta   += pTimerEvent->dwDelta;
	    }
    }
    else if ( pTimerEvent->pNext == (TIMER_EVENT_OBJECT*)NULL )
    {
	    //
	    // If this was the last element to be removed
	    //

	    pTimerEvent->pPrev->pNext = (TIMER_EVENT_OBJECT*)NULL;
    }
    else
    {
        pTimerEvent->pNext->dwDelta += pTimerEvent->dwDelta;
        pTimerEvent->pPrev->pNext   = pTimerEvent->pNext;
        pTimerEvent->pNext->pPrev   = pTimerEvent->pPrev;
    }

    //
    // *** Exclusion End ***
    //

    LeaveCriticalSection( &(gblTimerQ.CriticalSection) );

    LOCAL_FREE( pTimerEvent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\timehand.c ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	timehand.c
//
// Description: This module contains the procedures for the supervisor's
//              procedure-driven state machine that handles timer events.
//
// Author:	    Stefan Solomon (stefans)    May 26, 1992.
//
//
//***
#include "ddm.h"
#include "handlers.h"
#include "timer.h"
#include "objects.h"
#include "util.h"
#include "routerif.h"
#include "rasapiif.h"
#include <raserror.h>
#include <serial.h>
#include "rasmanif.h"
#include <string.h>
#include <stdlib.h>
#include <memory.h>

//
// Defines a list of blocks of time.
//
// The time block is expressed as a pair as follows:
//      <offset from midnight sunday, length>
//
// For example, the block of time from 7:00a to 8:30a on Monday
// would be
//      <24*60+7*60, 90> or <1860, 90>
//
//
typedef struct _MPR_TIME_BLOCK
{
    DWORD dwTime;       // Time of day expressed as # of mins since 12:00a
    DWORD dwLen;        // # of minutes in this time block
} MPR_TIME_BLOCK;

//
// Amount by which resizable array grows in TbCreateList
//
#define TB_GROW 30
#define TBDIGIT(_x) ((_x) - L'0')

//
// Local prototypes
//
PVOID
TbAlloc(
    IN DWORD dwSize,
    IN BOOL bZero);

VOID
TbFree(
    IN PVOID pvData);

DWORD
TbCreateList(
    IN  PWCHAR pszBlocks,
    OUT MPR_TIME_BLOCK** ppBlocks,
    OUT LPDWORD lpdwCount);

DWORD
TbCleanupList(
    IN MPR_TIME_BLOCK* pList);

DWORD
TbBlockFromString(
    IN  PWCHAR pszBlock,
    IN  DWORD dwDay,
    OUT MPR_TIME_BLOCK* pBlock);

DWORD
TbPrintBlock(
    IN MPR_TIME_BLOCK* pBlock);

//
// Common allocation for Tb* functions.  Will zero
// memory if bZero is set.
//
PVOID
TbAlloc(
    IN DWORD dwSize,
    IN BOOL bZero)
{
    return LOCAL_ALLOC(0, dwSize);
}

//
// Common free for Tb* functions
//
VOID
TbFree(
    IN PVOID pvData)
{
    LOCAL_FREE(pvData);
}

//
// Translates a multi-sz string containing time blocks into
// a MPR_TIME_BLOCK_LIST
//
DWORD
TbCreateList(
    IN  PWCHAR pszBlocks,
    OUT MPR_TIME_BLOCK** ppBlocks,
    OUT LPDWORD lpdwCount)
{
    DWORD dwErr = NO_ERROR, dwDay = 0, i = 0, dwTot = 0;
    MPR_TIME_BLOCK* pBlocks = NULL, *pTemp = NULL;
    PWCHAR pszCurBlock = NULL, pszStart, pszEnd;

    // Initialze
    //
    *ppBlocks = NULL;
    *lpdwCount = 0;
    pszCurBlock = pszBlocks;

    while (pszCurBlock && *pszCurBlock)
    {
        // Calculate the day indicated in the current block
        //
        // pszCurBlock = "d hh:mm-hh:mm hh:mm-hh:mm ..."
        //
        if (! iswdigit(*pszCurBlock))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
        dwDay = *pszCurBlock - L'0';

        // Advance past the day portion of the line to the
        // timeblock portion
        //
        if (pszStart = wcsstr(pszCurBlock, L" "))
        {
            pszStart++;

            // Loop through the blocks in this line (separated by spaces).
            //
            // pszStart = "hh:mm-hh:mm hh:mm-hh:mm ..."
            //
            while (TRUE)
            {
                // Parse out the current time block
                // hh:mm-hh:mm
                //
                pszEnd = wcsstr(pszStart, L" ");
                if (pszEnd)
                {
                    *pszEnd = L'\0';
                }

                // Resize the array if needed
                //
                if (i >= dwTot)
                {
                    dwTot += TB_GROW;
                    pTemp = (MPR_TIME_BLOCK*)
                        TbAlloc(dwTot * sizeof(MPR_TIME_BLOCK), TRUE);
                    if (pTemp == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    if (dwTot - TB_GROW != 0 && (pBlocks!=NULL) )
                    {
                        CopyMemory(
                            pTemp,
                            pBlocks,
                            sizeof(MPR_TIME_BLOCK) * (dwTot - TB_GROW));
                    }
             
                    if (pBlocks!=NULL)
                        TbFree(pBlocks);

                    pBlocks = pTemp;
                }

                // Generate the current time block
                //
                dwErr = TbBlockFromString(pszStart, dwDay, &pBlocks[i++]);
                if (dwErr != NO_ERROR)
                {
                    break;
                }

                // Undo any changes made to the string and
                // advance to the next time block
                //
                if (pszEnd)
                {
                    *pszEnd = L' ';
                    pszStart = pszEnd + 1;
                }
                else
                {
                    // Exit the loop successfully
                    break;
                }
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Increment the block of time in the multi-sz
        //
        pszCurBlock += wcslen(pszCurBlock) + 1;
    }

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            TbCleanupList(*ppBlocks);
            *ppBlocks = NULL;
        }
        else
        {
            *ppBlocks = pBlocks;
            *lpdwCount = i;
        }
    }

    return dwErr;
}

//
// Cleans up the given series of time blocks.
//
DWORD
TbCleanupList(
    IN MPR_TIME_BLOCK* pList)
{
    TbFree(pList);

    return NO_ERROR;
}

//
// Creates a time block based on a string which must
// be in the form "hh:mm-hh:mm".
//
DWORD
TbBlockFromString(
    IN  PWCHAR pszBlock,
    IN  DWORD dwDay,
    OUT MPR_TIME_BLOCK* pBlock)
{
    DWORD dwErr = NO_ERROR, dwEndTime = 0;

    // Block must be in format:
    //   "hh:mm-hh:mm"
    //
    if ((wcslen(pszBlock) != 11)  ||
        (! iswdigit(pszBlock[0])) ||
        (! iswdigit(pszBlock[1])) ||
        (pszBlock[2]  != L':')    ||
        (! iswdigit(pszBlock[3])) ||
        (! iswdigit(pszBlock[4])) ||
        (pszBlock[5]  != L'-')    ||
        (! iswdigit(pszBlock[6])) ||
        (! iswdigit(pszBlock[7])) ||
        (pszBlock[8]  != L':')    ||
        (! iswdigit(pszBlock[9])) ||
        (! iswdigit(pszBlock[10]))
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Assign the time values to the block
    //
    pBlock->dwTime =
        (((TBDIGIT(pszBlock[0]) * 10) + TBDIGIT(pszBlock[1])) * 60) +  // hrs
        ((TBDIGIT(pszBlock[3]) * 10) + TBDIGIT(pszBlock[4]))        +  // mns
        (dwDay * 24 * 60);                                             // dys

    dwEndTime =
        (((TBDIGIT(pszBlock[6]) * 10) + TBDIGIT(pszBlock[7])) * 60) +  // hrs
        ((TBDIGIT(pszBlock[9]) * 10) + TBDIGIT(pszBlock[10]))       +  // mns
        (dwDay * 24 * 60);                                             // dys

    pBlock ->dwLen = dwEndTime - pBlock->dwTime;

    return dwErr;
}

//
// Finds a time block that matches the given time.
//
// Parameters:
//      pList   = list of time blocks to search
//      dwTime  = time to search for (mins since midnight sunday)
//      ppBlock = the block that matched
//      pbFound = returned TRUE if dwTime lies within ppBlock.
//                returned FALSE if ppBlock is the next time block in pList
//                that occurs after dwTime.
//
DWORD
TbSearchList(
    IN  MPR_TIME_BLOCK* pList,
    IN  DWORD dwCount,
    IN  DWORD dwTime,
    OUT MPR_TIME_BLOCK** ppBlock,
    OUT PBOOL pbFound)
{
    DWORD dwErr = NO_ERROR;
    DWORD i = 0;

    // Initialize
    //
    *pbFound = FALSE;
    *ppBlock = NULL;

    // Loop through the list looking for a block with
    // a time less than ours.
    //
    for (i = 0; (i < dwCount) && (dwTime >= pList[i].dwTime); i++);
    i--;

    // If we fall within the current block then we're
    // done.
    //
    if ((dwTime >= pList[i].dwTime) &&
        (dwTime - pList[i].dwTime <= pList[i].dwLen))
    {
        *pbFound = TRUE;
        *ppBlock = &pList[i];
    }

    // Otherwise, we don't fall within any block.  Show the next block
    // that we qualify for (wrapping around as needed)
    //
    else
    {
        *pbFound = FALSE;
        *ppBlock = &pList[(i == dwCount-1) ? 0 : i+1];
    }

    return dwErr;
}

//
// Traces a block for debugging purposes
//
DWORD
TbTraceBlock(
    IN MPR_TIME_BLOCK* pBlock)
{
    DWORD dwTime, dwDay;

    dwDay = pBlock->dwTime / (24*60);
    dwTime = pBlock->dwTime - (dwDay * (24*60));
    DDMTRACE5(
        "Time Block:  %d, %02d:%02d-%02d:%02d\n",
        dwDay,
        dwTime / 60,
        dwTime % 60,
        (dwTime + pBlock->dwLen) / 60,
        (dwTime + pBlock->dwLen) % 60);

    return NO_ERROR;
}



//***
//
//  Function:   TimerHandler
//
//  Descr:
//
//***
VOID
TimerHandler(
    VOID
)
{
    //
    // call our timer
    //

    TimerQTick();

    //
    // increment the system timer
    //

    gblDDMConfigInfo.dwSystemTime++;
}

//**
//
// Call:        AnnouncePresenceHandler
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
/*
VOID
AnnouncePresenceHandler(
    IN HANDLE hObject
)
{
    AnnouncePresence();

    TimerQInsert( NULL,
                  gblDDMConfigInfo.dwAnnouncePresenceTimer,
                  AnnouncePresenceHandler );
}
*/

//***
//
// Function: SvHwErrDelayCompleted
//
// Descr:    Tries to repost a listen on the specified port.
//
//***
VOID
SvHwErrDelayCompleted(
    IN HANDLE hObject
)
{
    PDEVICE_OBJECT pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    if (pDeviceObj->DeviceState == DEV_OBJ_HW_FAILURE)
    {
        DDMTRACE1( "SvHwErrDelayCompleted: reposting listen for hPort%d\n",
		           pDeviceObj->hPort);

	    pDeviceObj->DeviceState = DEV_OBJ_LISTENING;

	    RmListen(pDeviceObj);
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function: SvCbDelayCompleted
//
// Descr:    Tries to connect on the specified port.
//
//***
VOID
SvCbDelayCompleted(
    IN HANDLE hObject
)
{
	CHAR chCallbackNumber[MAX_PHONE_NUMBER_LEN+1];
    PDEVICE_OBJECT pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    WideCharToMultiByte( CP_ACP,
                         0,
                         pDeviceObj->wchCallbackNumber,
                         -1,
                         chCallbackNumber,
                         sizeof( chCallbackNumber ),
                         NULL,
                         NULL );

    DDMTRACE1( "SvCbDelayCmpleted:Entered, hPort=%d\n",pDeviceObj->hPort );

    if (pDeviceObj->DeviceState == DEV_OBJ_CALLBACK_DISCONNECTED)
    {
	    pDeviceObj->DeviceState = DEV_OBJ_CALLBACK_CONNECTING;
	    RmConnect(pDeviceObj, chCallbackNumber);
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function: SvAuthTimeout
//
// Descr:    Disconnects the remote client and stops the authentication
//
//
VOID
SvAuthTimeout(
    IN HANDLE hObject
)
{
    LPWSTR          portnamep;
    PDEVICE_OBJECT  pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    DDMTRACE1( "SvAuthTimeout: Entered, hPort=%d", pDeviceObj->hPort);

    portnamep = pDeviceObj->wchPortName;

    DDMLogWarning( ROUTERLOG_AUTH_TIMEOUT, 1, &portnamep );

    //
    // stop everything and go closing
    //

    DevStartClosing( pDeviceObj );

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function:	SvDiscTimeout
//
// Descr:	disconnects remote client if it has not done it itself
//
//
VOID
SvDiscTimeout(
    IN HANDLE hObject
)
{
    PDEVICE_OBJECT pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    DDMTRACE1( "SvDiscTimeout: Entered, hPort=%d", pDeviceObj->hPort );

    switch (pDeviceObj->DeviceState)
    {
	case DEV_OBJ_CALLBACK_DISCONNECTING:

	    RmDisconnect(pDeviceObj);
	    break;

	case DEV_OBJ_AUTH_IS_ACTIVE:

	    DevStartClosing(pDeviceObj);
	    break;

	default:

	    break;
    }

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function:	SvSecurityTimeout
//
// Descr:	disconnects the connection because the 3rd party security DLL
//              did not complete in time.
//
//***
VOID
SvSecurityTimeout(
    IN HANDLE hObject
)
{
    LPWSTR          portnamep;
    PDEVICE_OBJECT pDeviceObj;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    pDeviceObj = DeviceObjGetPointer( (HPORT)hObject );

    if ( pDeviceObj == NULL )
    {
        LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
        return;
    }

    DDMTRACE1( "SvSecurityTimeout: Entered,hPort=%d",pDeviceObj->hPort);

    portnamep = pDeviceObj->wchPortName;

    DDMLogWarning( ROUTERLOG_AUTH_TIMEOUT, 1, &portnamep );

    //
    // stop everything and go closing
    //

    DevStartClosing(pDeviceObj);

    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );
}

//***
//
// Function:	ReConnectInterface
//
// Description:	Will try to reconnect an interface.
//
//***
VOID
ReConnectInterface(
    IN HANDLE hObject
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwRetCode = NO_ERROR;

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );
    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hObject );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            break;
        }

        if ( pIfObject->State != RISTATE_CONNECTING )
        {
            break;
        }

        dwRetCode = RasConnectionInitiate( pIfObject, TRUE );

        DDMTRACE2( "ReConnectInterface: To interface %ws returned %d",
                    pIfObject->lpwsInterfaceName, dwRetCode );

        if ( dwRetCode != NO_ERROR )
        {
            IfObjectDisconnected( pIfObject );
        }

    }while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
    LeaveCriticalSection( &(gblDeviceTable.CriticalSection) );

    if ( dwRetCode != NO_ERROR )
    {
        LPWSTR  lpwsAudit[1];

        lpwsAudit[0] = pIfObject->lpwsInterfaceName;

        DDMLogErrorString(ROUTERLOG_CONNECTION_FAILURE,1,lpwsAudit,dwRetCode,1);
    }

}

//***
//
// Function:    MarkInterfaceAsReachable
//
// Description: Will mark an interface as reachable.
//
//***
VOID
MarkInterfaceAsReachable(
    IN HANDLE hObject
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hObject );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            break;
        }

        pIfObject->fFlags &= ~IFFLAG_CONNECTION_FAILURE;

        IfObjectNotifyOfReachabilityChange( pIfObject,
                                            TRUE,
                                            INTERFACE_CONNECTION_FAILURE );

        pIfObject->dwLastError = NO_ERROR;

    }while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
}

//**
//
// Call:        ReConnectPersistentInterface
//
// Returns:     None
//
// Description: Will insert an event in the timer Q that will reconnect this
//              interface.
//
VOID
ReConnectPersistentInterface(
    IN HANDLE hObject
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    DWORD                       dwRetCode;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hObject );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            break;
        }

        if ( pIfObject->State != RISTATE_DISCONNECTED )
        {
            break;
        }

        dwRetCode = RasConnectionInitiate( pIfObject, FALSE );

        DDMTRACE2( "ReConnect to persistent interface %ws returned %d",
                    pIfObject->lpwsInterfaceName, dwRetCode );

    }while( FALSE );

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );
}

//**
//
// Call:        SetDialoutHoursRestriction
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
SetDialoutHoursRestriction(
    IN HANDLE hObject
)
{
    ROUTER_INTERFACE_OBJECT *   pIfObject;
    SYSTEMTIME                  CurrentTime;
    MPR_TIME_BLOCK*             pBlocks = NULL, *pTimeBlock = NULL;
    DWORD                       dwRetCode = NO_ERROR, dwCount, dwTime;
    DWORD                       dwTimer, dwBlDay;
    BOOL                        bFound = FALSE;

    EnterCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    do
    {
        pIfObject = IfObjectGetPointer( hObject );

        if ( pIfObject == (ROUTER_INTERFACE_OBJECT *)NULL )
        {
            dwRetCode = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        //
        // Null dialout hours restriction is interpreted as
        // 'always allow'.
        //

        if (pIfObject->lpwsDialoutHoursRestriction == NULL)
        {
            pIfObject->fFlags &= ~IFFLAG_DIALOUT_HOURS_RESTRICTION;
            DDMTRACE("Dialout hours restriction off forever.");
            dwRetCode = NO_ERROR;
            break;
        }

        //
        // Generate the list of time blocks based on the current
        // multisz
        //

        dwRetCode = TbCreateList(
                        pIfObject->lpwsDialoutHoursRestriction,
                        &pBlocks,
                        &dwCount);
        if (dwRetCode != NO_ERROR)
        {
            break;
        }

        //
        // If an empty list was created, then all hours were
        // specified as deny.  Mark the interface unreachable
        // and set ourselves to wake up and check things later.
        //

        if ((dwCount == 0) || (pBlocks == NULL))
        {
            pIfObject->fFlags |= IFFLAG_DIALOUT_HOURS_RESTRICTION;
            DDMTRACE("Dialout hours restriction on forever.");
            dwRetCode = NO_ERROR;
            break;
        }

        //
        // Get the current time
        //

        GetLocalTime( &CurrentTime );

        //
        // Convert the current time into an offset in
        // minutes from midnight, sunday.
        //

        dwTime = (DWORD)
            ( ( CurrentTime.wDayOfWeek * 24 * 60 ) +
              ( CurrentTime.wHour * 60 )           +
              CurrentTime.wMinute );

        //
        // Search for the current time in the list of available times.
        //

        dwRetCode = TbSearchList(
                        pBlocks,
                        dwCount,
                        dwTime,
                        &pTimeBlock,
                        &bFound);
        if (dwRetCode != NO_ERROR)
        {
            break;
        }

        //
        // If we fell within one of the blocks, set the timer
        // to go off after this block completes.
        //

        if (bFound)
        {
            dwTimer = ((pTimeBlock->dwTime + pTimeBlock->dwLen) - dwTime) + 1;

            pIfObject->fFlags &= ~IFFLAG_DIALOUT_HOURS_RESTRICTION;

            DDMTRACE1("Dialout hours restriction off for %d mins", dwTimer);
            TbTraceBlock(pTimeBlock);
        }

        //
        // If we didn't fall within one of the blocks, set the timer
        // to go off when the next block begins
        //

        else
        {
            //
            // Check for week wrap around (i.e. today is saturday, next
            // block is sunday).
            //

            dwBlDay = (pTimeBlock->dwTime / (24*60));

            //
            // If there's no week wrap around, calculation of timer
            // is trivial.
            //

            if ((DWORD)CurrentTime.wDayOfWeek <= dwBlDay)
            {
                dwTimer = pTimeBlock->dwTime - dwTime;
            }

            //
            // Otherwise, calculate the timer by adding one week to the
            // start of the next time block.
            //

            else
            {
                dwTimer = (pTimeBlock->dwTime + (7*24*60)) - dwTime;
            }

            pIfObject->fFlags |= IFFLAG_DIALOUT_HOURS_RESTRICTION;

            DDMTRACE1("Dialout hours restriction on for %d mins", dwTimer);
            TbTraceBlock(pTimeBlock);
        }

        //
        // Set the timer
        //

        TimerQInsert(
            pIfObject->hDIMInterface,
            dwTimer * 60,
            SetDialoutHoursRestriction );

    } while (FALSE);

    if (pIfObject)
    {
        if ( dwRetCode != NO_ERROR )
        {
            //
            // Do not set any restriction if the string is invalid
            //

            pIfObject->fFlags &= ~IFFLAG_DIALOUT_HOURS_RESTRICTION;
        }

        IfObjectNotifyOfReachabilityChange(
                        pIfObject,
                        !( pIfObject->fFlags & IFFLAG_DIALOUT_HOURS_RESTRICTION ),
                        INTERFACE_DIALOUT_HOURS_RESTRICTION );
    }

    LeaveCriticalSection( &(gblpInterfaceTable->CriticalSection) );

    // Cleanup
    if (pBlocks)
    {
        TbCleanupList(pBlocks);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\util.c ===
/*****************************************************************************/
/**			 Microsoft LAN Manager				    **/
/**		   Copyright (C) Microsoft Corp., 1992			    **/
/*****************************************************************************/

//***
//	File Name:  util.c
//
//	Function:   miscellaneous supervisor support procedures
//
//	History:
//
//	    05/21/92	Stefan Solomon	- Original Version 1.0
//***

#include "ddm.h"
#include "util.h"
#include "isdn.h"
#include "objects.h"
#include "rasmanif.h"
#include "handlers.h"
#include <ddmif.h>
#include <timer.h>
#include <ctype.h>
#include <memory.h>
#include <ddmparms.h>
#define INCL_HOSTWIRE
#include <ppputil.h>
#include "rassrvr.h"
#include "raserror.h"
#include "winsock2.h"
#include "rtinfo.h"

#define net_long(x) (((((unsigned long)(x))&0xffL)<<24) | \
                     ((((unsigned long)(x))&0xff00L)<<8) | \
                     ((((unsigned long)(x))&0xff0000L)>>8) | \
                     ((((unsigned long)(x))&0xff000000L)>>24))
//**
//
// Call:        ConvertStringToIpxAddress
//
// Returns:     None
//
// Description:
//
VOID
ConvertStringToIpxAddress(
    IN  WCHAR* pwchIpxAddress,
    OUT BYTE * bIpxAddress
)
{
    DWORD i;
    WCHAR wChar[3];

    for(i=0; i<4; i++)
    {
        wChar[0] = pwchIpxAddress[i*2];
        wChar[1] = pwchIpxAddress[(i*2)+1];
        wChar[2] = (WCHAR)NULL;
        bIpxAddress[i] = (BYTE)wcstol( wChar, NULL, 16 );
    }

    //
    // Skip over the .
    //

    for(i=4; i<10; i++)
    {
        wChar[0] = pwchIpxAddress[(i*2)+1];
        wChar[1] = pwchIpxAddress[(i*2)+2];
        wChar[2] = (WCHAR)NULL;
        bIpxAddress[i] = (BYTE)wcstol( wChar, NULL, 16 );
    }
}

//**
//
// Call:        ConvertStringToIpAddress
//
// Returns:     None
//
// Description: Convert caller's a.b.c.d IP address string to the
//              big-endian (Motorola format) numeric equivalent.
//
VOID
ConvertStringToIpAddress(
    IN WCHAR  * pwchIpAddress,
    OUT DWORD * lpdwIpAddress
)
{
    INT    i;
    LONG   lResult = 0;
    WCHAR* pwch = pwchIpAddress;

    *lpdwIpAddress = 0;

    for (i = 1; i <= 4; ++i)
    {
        LONG lField = _wtol( pwch );

        if (lField > 255)
            return;

        lResult = (lResult << 8) + lField;

        while (*pwch >= L'0' && *pwch <= L'9')
            pwch++;

        if (i < 4 && *pwch != L'.')
            return;

        pwch++;
    }

    *lpdwIpAddress =  net_long(lResult);
}

//**
//
// Call:        ConvertIpAddressToString
//
// Returns:     None
//
// Description: Converts 'ipaddr' to a string in the a.b.c.d form and
//              returns same in caller's 'pwszIpAddress' buffer.
//              The buffer should be at least 16 wide characters long.
//
VOID
ConvertIpAddressToString(
    IN DWORD    dwIpAddress,
    IN LPWSTR   pwszIpAddress
)
{
    WCHAR wszBuf[ 3 + 1 ];
    LONG  lNetIpaddr = net_long( dwIpAddress );

    LONG lA = (lNetIpaddr & 0xFF000000) >> 24;
    LONG lB = (lNetIpaddr & 0x00FF0000) >> 16;
    LONG lC = (lNetIpaddr & 0x0000FF00) >> 8;
    LONG lD = (lNetIpaddr & 0x000000FF);

    _ltow( lA, wszBuf, 10 );
    wcscpy( pwszIpAddress, wszBuf );
    wcscat( pwszIpAddress, L"." );
    _ltow( lB, wszBuf, 10 );
    wcscat( pwszIpAddress, wszBuf );
    wcscat( pwszIpAddress, L"." );
    _ltow( lC, wszBuf, 10 );
    wcscat( pwszIpAddress, wszBuf );
    wcscat( pwszIpAddress, L"." );
    _ltow( lD, wszBuf, 10 );
    wcscat( pwszIpAddress, wszBuf );
}

//**
//
// Call:        ConvertIpxAddressToString
//
// Returns:     None
//
// Description:
//
VOID
ConvertIpxAddressToString(
    IN PBYTE    bIpxAddress,
    IN LPWSTR   pwszIpxAddress
)
{
    wsprintf( pwszIpxAddress,
              TEXT("%2.2X%2.2X%2.2X%2.2X.%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X"),
              bIpxAddress[0],bIpxAddress[1],bIpxAddress[2],bIpxAddress[3],
              bIpxAddress[4],bIpxAddress[5],bIpxAddress[6],bIpxAddress[7],
              bIpxAddress[8],bIpxAddress[9] );
}

//**
//
// Call:        ConvertAtAddressToString
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
ConvertAtAddressToString(
    IN DWORD    dwAtAddress,
    IN LPWSTR   pwszAtAddress
)
{
    WCHAR wszBuf[ 5 + 1 ];

    LONG lA = (dwAtAddress & 0xFFFF0000) >> 16;
    LONG lB = (dwAtAddress & 0x0000FFFF);

    _ltow( lA, wszBuf, 10 );
    wcscpy( pwszAtAddress, wszBuf );
    wcscat( pwszAtAddress, L"." );
    _ltow( lB, wszBuf, 10 );
    wcscat( pwszAtAddress, wszBuf );

    return;
}

//**
//
// Call:        GetRasConnection0Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a CONNECTION_OBJECT structure will extract
//              all relevent information and insert it into a RAS_CONNECTION_0
//              structure.
//
DWORD
GetRasiConnection0Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_0      pRasConnection0
)
{
    pRasConnection0->dwConnection       = PtrToUlong(pConnObj->hConnection);
    pRasConnection0->dwInterface        = PtrToUlong(pConnObj->hDIMInterface);
    pRasConnection0->dwInterfaceType    = pConnObj->InterfaceType;
    wcscpy( pRasConnection0->wszInterfaceName,  pConnObj->wchInterfaceName );
    wcscpy( pRasConnection0->wszUserName,       pConnObj->wchUserName );
    wcscpy( pRasConnection0->wszLogonDomain,    pConnObj->wchDomainName );
    MultiByteToWideChar( CP_ACP,
                         0,
                         pConnObj->bComputerName,
                         -1,
                         pRasConnection0->wszRemoteComputer,
                         NETBIOS_NAME_LEN+1 );
    pRasConnection0->dwConnectDuration =
                        GetActiveTimeInSeconds( &(pConnObj->qwActiveTime) );
    pRasConnection0->dwConnectionFlags =
                        ( pConnObj->fFlags & CONN_OBJ_MESSENGER_PRESENT )
                                    ? RAS_FLAGS_MESSENGER_PRESENT : 0;
                                    
    if ( pConnObj->fFlags & CONN_OBJ_IS_PPP )
    {
        pRasConnection0->dwConnectionFlags |= RAS_FLAGS_PPP_CONNECTION;
    }

    if(pConnObj->fFlags & CONN_OBJ_QUARANTINE_PRESENT)
    {
        pRasConnection0->dwConnectionFlags |= RAS_FLAGS_QUARANTINE_PRESENT;
    }

    return( NO_ERROR );
}

//**
//
// Call:        GetRasConnection1Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a CONNECTION_OBJECT structure will extract
//              all relevent information and insert it into a RAS_CONNECTION_1
//              structure.
//
DWORD
GetRasiConnection1Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_1      pRasConnection1
)
{
    BYTE buffer[sizeof(RAS_STATISTICS) + (MAX_STATISTICS_EX * sizeof (ULONG))];
    RAS_STATISTICS *pStats = (RAS_STATISTICS *)buffer;
    DWORD           dwSize = sizeof (buffer);
    DWORD           dwRetCode;

    pRasConnection1->dwConnection       = PtrToUlong(pConnObj->hConnection);
    pRasConnection1->dwInterface        = PtrToUlong(pConnObj->hDIMInterface);

    dwRetCode = RasBundleGetStatisticsEx(NULL, (HPORT)pConnObj->hPort,
                                        (PBYTE)pStats, &dwSize );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    pRasConnection1->PppInfo.nbf.dwError =
                            pConnObj->PppProjectionResult.nbf.dwError;

    if ( pRasConnection1->PppInfo.nbf.dwError == NO_ERROR )
    {
        wcscpy( pRasConnection1->PppInfo.nbf.wszWksta,
                            pConnObj->PppProjectionResult.nbf.wszWksta );
    }
    else
    {
        pRasConnection1->PppInfo.nbf.wszWksta[0] = (WCHAR)NULL;
    }

    pRasConnection1->PppInfo.ip.dwError =
                            pConnObj->PppProjectionResult.ip.dwError;

    if ( pRasConnection1->PppInfo.ip.dwError == NO_ERROR )
    {
        ConvertIpAddressToString(
                            pConnObj->PppProjectionResult.ip.dwLocalAddress,
                            pRasConnection1->PppInfo.ip.wszAddress );

        ConvertIpAddressToString(
                            pConnObj->PppProjectionResult.ip.dwRemoteAddress,
                            pRasConnection1->PppInfo.ip.wszRemoteAddress );
    }
    else
    {
        pRasConnection1->PppInfo.ip.wszAddress[0]       = (WCHAR)NULL;
        pRasConnection1->PppInfo.ip.wszRemoteAddress[0] = (WCHAR)NULL;
    }

    pRasConnection1->PppInfo.ipx.dwError =
                            pConnObj->PppProjectionResult.ipx.dwError;

    if ( pRasConnection1->PppInfo.ipx.dwError == NO_ERROR )
    {
        ConvertIpxAddressToString(
                            ( pConnObj->InterfaceType == ROUTER_IF_TYPE_CLIENT )
                            ? pConnObj->PppProjectionResult.ipx.bRemoteAddress
                            : pConnObj->PppProjectionResult.ipx.bLocalAddress,
                            pRasConnection1->PppInfo.ipx.wszAddress );
    }
    else
    {
        pRasConnection1->PppInfo.ipx.wszAddress[0]      = (WCHAR)NULL;
    }

    pRasConnection1->PppInfo.at.dwError =
                            pConnObj->PppProjectionResult.at.dwError;

    if ( pRasConnection1->PppInfo.at.dwError == NO_ERROR )
    {
        ConvertAtAddressToString(
                            ( pConnObj->InterfaceType == ROUTER_IF_TYPE_CLIENT )
                            ? pConnObj->PppProjectionResult.at.dwRemoteAddress
                            : pConnObj->PppProjectionResult.at.dwLocalAddress,
                              pRasConnection1->PppInfo.at.wszAddress );
    }
    else
    {
        pRasConnection1->PppInfo.at.wszAddress[0]      = (WCHAR)NULL;
    }

    pRasConnection1->dwBytesXmited  = pStats->S_Statistics[BYTES_XMITED];
    pRasConnection1->dwBytesRcved   = pStats->S_Statistics[BYTES_RCVED];
    pRasConnection1->dwFramesXmited = pStats->S_Statistics[FRAMES_XMITED];
    pRasConnection1->dwFramesRcved  = pStats->S_Statistics[FRAMES_RCVED];
    pRasConnection1->dwCrcErr       = pStats->S_Statistics[CRC_ERR];
    pRasConnection1->dwTimeoutErr   = pStats->S_Statistics[TIMEOUT_ERR];
    pRasConnection1->dwAlignmentErr = pStats->S_Statistics[ALIGNMENT_ERR];
    pRasConnection1->dwFramingErr   = pStats->S_Statistics[FRAMING_ERR];
    pRasConnection1->dwHardwareOverrunErr
                            = pStats->S_Statistics[HARDWARE_OVERRUN_ERR];
    pRasConnection1->dwBufferOverrunErr
                            = pStats->S_Statistics[BUFFER_OVERRUN_ERR];

    pRasConnection1->dwCompressionRatioIn
                            = pStats->S_Statistics[COMPRESSION_RATIO_IN];
    pRasConnection1->dwCompressionRatioOut
                            = pStats->S_Statistics[COMPRESSION_RATIO_OUT];

    return( NO_ERROR );
}

//**
//
// Call:        GetRasConnection2Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a CONNECTION_OBJECT structure will extract
//              all relevent information and insert it into a RAS_CONNECTION_2
//              structure.
//
DWORD
GetRasiConnection2Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_2      pRasConnection2
)
{
    pRasConnection2->dwConnection        = PtrToUlong(pConnObj->hConnection);
    pRasConnection2->guid               = pConnObj->guid;
    pRasConnection2->dwInterfaceType    = pConnObj->InterfaceType;
    wcscpy( pRasConnection2->wszUserName, pConnObj->wchUserName );

    pRasConnection2->PppInfo2.nbf.dwError =
                            pConnObj->PppProjectionResult.nbf.dwError;

    if ( pRasConnection2->PppInfo2.nbf.dwError == NO_ERROR )
    {
        wcscpy( pRasConnection2->PppInfo2.nbf.wszWksta,
                            pConnObj->PppProjectionResult.nbf.wszWksta );
    }
    else
    {
        pRasConnection2->PppInfo2.nbf.wszWksta[0] = (WCHAR)NULL;
    }

    pRasConnection2->PppInfo2.ip.dwError =
                            pConnObj->PppProjectionResult.ip.dwError;

    if ( pRasConnection2->PppInfo2.ip.dwError == NO_ERROR )
    {
        ConvertIpAddressToString(
                            pConnObj->PppProjectionResult.ip.dwLocalAddress,
                            pRasConnection2->PppInfo2.ip.wszAddress );

        ConvertIpAddressToString(
                            pConnObj->PppProjectionResult.ip.dwRemoteAddress,
                            pRasConnection2->PppInfo2.ip.wszRemoteAddress );

        pRasConnection2->PppInfo2.ip.dwOptions       = 0;
        pRasConnection2->PppInfo2.ip.dwRemoteOptions = 0;

        if ( pConnObj->PppProjectionResult.ip.fSendVJHCompression )
        {
            pRasConnection2->PppInfo2.ip.dwOptions |= PPP_IPCP_VJ;
        }

        if ( pConnObj->PppProjectionResult.ip.fReceiveVJHCompression )
        {
            pRasConnection2->PppInfo2.ip.dwRemoteOptions |= PPP_IPCP_VJ;
        }
    }
    else
    {
        pRasConnection2->PppInfo2.ip.wszAddress[0]       = (WCHAR)NULL;
        pRasConnection2->PppInfo2.ip.wszRemoteAddress[0] = (WCHAR)NULL;
    }

    pRasConnection2->PppInfo2.ipx.dwError =
                            pConnObj->PppProjectionResult.ipx.dwError;

    if ( pRasConnection2->PppInfo2.ipx.dwError == NO_ERROR )
    {
        ConvertIpxAddressToString(
                            ( pConnObj->InterfaceType == ROUTER_IF_TYPE_CLIENT )
                            ? pConnObj->PppProjectionResult.ipx.bRemoteAddress
                            : pConnObj->PppProjectionResult.ipx.bLocalAddress,
                            pRasConnection2->PppInfo2.ipx.wszAddress );
    }
    else
    {
        pRasConnection2->PppInfo2.ipx.wszAddress[0]      = (WCHAR)NULL;
    }

    pRasConnection2->PppInfo2.at.dwError =
                            pConnObj->PppProjectionResult.at.dwError;

    if ( pRasConnection2->PppInfo2.at.dwError == NO_ERROR )
    {
        ConvertAtAddressToString(
                            ( pConnObj->InterfaceType == ROUTER_IF_TYPE_CLIENT )
                            ? pConnObj->PppProjectionResult.at.dwRemoteAddress
                            : pConnObj->PppProjectionResult.at.dwLocalAddress,
                              pRasConnection2->PppInfo2.at.wszAddress );
    }
    else
    {
        pRasConnection2->PppInfo2.at.wszAddress[0]      = (WCHAR)NULL;
    }

    pRasConnection2->PppInfo2.ccp.dwError =
                            pConnObj->PppProjectionResult.ccp.dwError;

    if ( pRasConnection2->PppInfo2.ccp.dwError == NO_ERROR )
    {
        pRasConnection2->PppInfo2.ccp.dwCompressionAlgorithm = 0;

        if ( pConnObj->PppProjectionResult.ccp.dwSendProtocol == 0x12 )
        {
            pRasConnection2->PppInfo2.ccp.dwCompressionAlgorithm = RASCCPCA_MPPC;
        }

        pRasConnection2->PppInfo2.ccp.dwOptions = 
                        pConnObj->PppProjectionResult.ccp.dwSendProtocolData;

        pRasConnection2->PppInfo2.ccp.dwRemoteCompressionAlgorithm = 0;

        if ( pConnObj->PppProjectionResult.ccp.dwReceiveProtocol == 0x12 )
        {
            pRasConnection2->PppInfo2.ccp.dwRemoteCompressionAlgorithm = RASCCPCA_MPPC;
        }

        pRasConnection2->PppInfo2.ccp.dwRemoteOptions =     
                        pConnObj->PppProjectionResult.ccp.dwReceiveProtocolData;
    }

    pRasConnection2->PppInfo2.lcp.dwError = NO_ERROR;

    pRasConnection2->PppInfo2.lcp.dwAuthenticationProtocol =
                    pConnObj->PppProjectionResult.lcp.dwLocalAuthProtocol;

    pRasConnection2->PppInfo2.lcp.dwAuthenticationData =
                    pConnObj->PppProjectionResult.lcp.dwLocalAuthProtocolData;

    pRasConnection2->PppInfo2.lcp.dwEapTypeId =
                    pConnObj->PppProjectionResult.lcp.dwLocalEapTypeId;

    pRasConnection2->PppInfo2.lcp.dwTerminateReason = NO_ERROR;

    pRasConnection2->PppInfo2.lcp.dwOptions = 0;

    if ( pConnObj->PppProjectionResult.lcp.dwLocalFramingType & PPP_MULTILINK_FRAMING )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_MULTILINK_FRAMING;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_PFC )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_PFC;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_ACFC )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_ACFC;
    } 

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_SSHF )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_SSHF;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_DES_56 )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_DES_56;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwLocalOptions & PPPLCPO_3_DES )
    {
        pRasConnection2->PppInfo2.lcp.dwOptions |= PPP_LCP_3_DES;
    }

    pRasConnection2->PppInfo2.lcp.dwRemoteAuthenticationProtocol =
                    pConnObj->PppProjectionResult.lcp.dwRemoteAuthProtocol;

    pRasConnection2->PppInfo2.lcp.dwRemoteAuthenticationData =
                    pConnObj->PppProjectionResult.lcp.dwRemoteAuthProtocolData;

    pRasConnection2->PppInfo2.lcp.dwRemoteEapTypeId =
                    pConnObj->PppProjectionResult.lcp.dwRemoteEapTypeId;

    pRasConnection2->PppInfo2.lcp.dwRemoteTerminateReason = NO_ERROR;

    pRasConnection2->PppInfo2.lcp.dwRemoteOptions = 0;

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteFramingType & PPP_MULTILINK_FRAMING )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_MULTILINK_FRAMING;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_PFC )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_PFC;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_ACFC )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_ACFC;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_SSHF )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_SSHF;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_DES_56 )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_DES_56;
    }

    if ( pConnObj->PppProjectionResult.lcp.dwRemoteOptions & PPPLCPO_3_DES )
    {
        pRasConnection2->PppInfo2.lcp.dwRemoteOptions |= PPP_LCP_3_DES;
    }

    return( NO_ERROR );
}

DWORD
GetRasConnection0Data(
    IN  PCONNECTION_OBJECT  pConnObj,
    OUT PRAS_CONNECTION_0   pRasConn0
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_CONNECTION_0     RasiConn0;

    dwErr = GetRasiConnection0Data(pConnObj, &RasiConn0);
    if (dwErr == NO_ERROR)
    {
        pRasConn0->hConnection         = UlongToPtr(RasiConn0.dwConnection);
        pRasConn0->hInterface          = UlongToPtr(RasiConn0.dwInterface);
        pRasConn0->dwConnectDuration   = RasiConn0.dwConnectDuration;
        pRasConn0->dwInterfaceType     = RasiConn0.dwInterfaceType;
        pRasConn0->dwConnectionFlags   = RasiConn0.dwConnectionFlags;
        
        wcscpy(pRasConn0->wszInterfaceName, RasiConn0.wszInterfaceName);
        wcscpy(pRasConn0->wszUserName,      RasiConn0.wszUserName);
        wcscpy(pRasConn0->wszLogonDomain,   RasiConn0.wszLogonDomain);
        wcscpy(pRasConn0->wszRemoteComputer,RasiConn0.wszRemoteComputer);        
    }

    return dwErr;                
    
#else

    return GetRasiConnection0Data(pConnObj, (PRASI_CONNECTION_0)pRasConn0);

#endif
}

DWORD
GetRasConnection1Data(
    IN  PCONNECTION_OBJECT  pConnObj,
    OUT PRAS_CONNECTION_1   pRasConn1
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_CONNECTION_1     RasiConn1;

    dwErr = GetRasiConnection1Data(pConnObj, &RasiConn1);
    if (dwErr == NO_ERROR)
    {
        pRasConn1->hConnection          = UlongToPtr(RasiConn1.dwConnection);
        pRasConn1->hInterface           = UlongToPtr(RasiConn1.dwInterface);
        pRasConn1->PppInfo              = RasiConn1.PppInfo;
        pRasConn1->dwBytesXmited        = RasiConn1.dwBytesXmited;
        pRasConn1->dwBytesRcved         = RasiConn1.dwBytesRcved;
        pRasConn1->dwFramesXmited       = RasiConn1.dwFramesXmited;
        pRasConn1->dwFramesRcved        = RasiConn1.dwFramesRcved;
        pRasConn1->dwCrcErr             = RasiConn1.dwCrcErr;
        pRasConn1->dwTimeoutErr         = RasiConn1.dwTimeoutErr;
        pRasConn1->dwAlignmentErr       = RasiConn1.dwAlignmentErr;
        pRasConn1->dwHardwareOverrunErr = RasiConn1.dwHardwareOverrunErr;
        pRasConn1->dwFramingErr         = RasiConn1.dwFramingErr;
        pRasConn1->dwBufferOverrunErr   = RasiConn1.dwBufferOverrunErr;
        pRasConn1->dwCompressionRatioIn = RasiConn1.dwCompressionRatioIn;
        pRasConn1->dwCompressionRatioOut= RasiConn1.dwCompressionRatioOut;
    }

    return dwErr;                
    
#else

    return GetRasiConnection1Data(pConnObj, (PRASI_CONNECTION_1)pRasConn1);
    
#endif    
}

DWORD
GetRasConnection2Data(
    IN  PCONNECTION_OBJECT  pConnObj,
    OUT PRAS_CONNECTION_2   pRasConn2
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_CONNECTION_2     RasiConn2;

    dwErr = GetRasiConnection2Data(pConnObj, &RasiConn2);
    if (dwErr == NO_ERROR)
    {
        pRasConn2->hConnection     = UlongToPtr(RasiConn2.dwConnection);
        pRasConn2->dwInterfaceType = RasiConn2.dwInterfaceType;
        pRasConn2->guid            = RasiConn2.guid;
        pRasConn2->PppInfo2        = RasiConn2.PppInfo2;

        wcscpy(pRasConn2->wszUserName,  RasiConn2.wszUserName);
    }

    return dwErr;                
    
#else

    return GetRasiConnection2Data(pConnObj, (PRASI_CONNECTION_2)pRasConn2);
    
#endif    
}
//**
//
// Call:        GetRasiPort0Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a DEVICE_OBJECT structure will extract all
//              relevent information and insert it into a RAS_PORT_0 structure.
//
DWORD
GetRasiPort0Data(
    IN  PDEVICE_OBJECT      pDevObj,
    OUT PRASI_PORT_0        pRasPort0
)
{

    pRasPort0->dwPort               = PtrToUlong(pDevObj->hPort);
    pRasPort0->dwConnection         = PtrToUlong(pDevObj->hConnection);
    pRasPort0->dwTotalNumberOfCalls = pDevObj->dwTotalNumberOfCalls;
    pRasPort0->dwConnectDuration    = 0;
    wcscpy( pRasPort0->wszPortName,     pDevObj->wchPortName );
    wcscpy( pRasPort0->wszMediaName,    pDevObj->wchMediaName );
    wcscpy( pRasPort0->wszDeviceName,   pDevObj->wchDeviceName );
    wcscpy( pRasPort0->wszDeviceType,   pDevObj->wchDeviceType );


    if ( pDevObj->fFlags & DEV_OBJ_OPENED_FOR_DIALOUT )
    {
        RASCONNSTATUS ConnectionStatus;

        ConnectionStatus.dwSize = sizeof( RASCONNSTATUS );

        if ( RasGetConnectStatus( pDevObj->hRasConn, &ConnectionStatus ) )
        {
            //
            // On any error we assume the port is disconnected and closed.
            //

            pRasPort0->dwPortCondition = RAS_PORT_LISTENING;

            return( NO_ERROR );
        }

        switch( ConnectionStatus.rasconnstate )
        {
        case RASCS_OpenPort:
        case RASCS_PortOpened:
        case RASCS_ConnectDevice:
        case RASCS_DeviceConnected:
        case RASCS_AllDevicesConnected:
        case RASCS_Authenticate:
        case RASCS_AuthNotify:
        case RASCS_AuthRetry:
        case RASCS_AuthChangePassword:
        case RASCS_AuthLinkSpeed:
        case RASCS_AuthAck:
        case RASCS_ReAuthenticate:
        case RASCS_AuthProject:
        case RASCS_StartAuthentication:
        case RASCS_LogonNetwork:
        case RASCS_RetryAuthentication:
        case RASCS_CallbackComplete:
        case RASCS_PasswordExpired:
            pRasPort0->dwPortCondition = RAS_PORT_AUTHENTICATING;
            break;

        case RASCS_CallbackSetByCaller:
        case RASCS_AuthCallback:
        case RASCS_PrepareForCallback:
        case RASCS_WaitForModemReset:
        case RASCS_WaitForCallback:
            pRasPort0->dwPortCondition = RAS_PORT_LISTENING;
            break;

        case RASCS_Projected:
        case RASCS_Authenticated:
            pRasPort0->dwPortCondition = RAS_PORT_AUTHENTICATED;
            break;

        case RASCS_SubEntryConnected:
        case RASCS_Connected:
            pRasPort0->dwPortCondition = RAS_PORT_AUTHENTICATED;
            pRasPort0->dwConnectDuration =
                        GetActiveTimeInSeconds( &(pDevObj->qwActiveTime) );
            break;

        case RASCS_Disconnected:
        case RASCS_SubEntryDisconnected:
            pRasPort0->dwPortCondition = RAS_PORT_DISCONNECTED;
            break;

        case RASCS_Interactive:
        default:
            pRasPort0->dwPortCondition = RAS_PORT_DISCONNECTED;
            break;
        }

        return( NO_ERROR );
    }

    switch( pDevObj->DeviceState )
    {
    case DEV_OBJ_LISTENING:
        pRasPort0->dwPortCondition   = RAS_PORT_LISTENING;
        break;

    case DEV_OBJ_HW_FAILURE:
        pRasPort0->dwPortCondition   = RAS_PORT_NON_OPERATIONAL;
        break;

    case DEV_OBJ_RECEIVING_FRAME:
    case DEV_OBJ_LISTEN_COMPLETE:
    case DEV_OBJ_AUTH_IS_ACTIVE:
        pRasPort0->dwPortCondition   = RAS_PORT_AUTHENTICATING;
        break;

    case DEV_OBJ_ACTIVE:
        pRasPort0->dwPortCondition   = RAS_PORT_AUTHENTICATED;
        pRasPort0->dwConnectDuration =
                        GetActiveTimeInSeconds( &(pDevObj->qwActiveTime) );
        break;

    case DEV_OBJ_CALLBACK_DISCONNECTING:
    case DEV_OBJ_CALLBACK_DISCONNECTED:
    case DEV_OBJ_CALLBACK_CONNECTING:
        pRasPort0->dwPortCondition   = RAS_PORT_CALLING_BACK;
        break;

    case DEV_OBJ_CLOSED:
    case DEV_OBJ_CLOSING:
        pRasPort0->dwPortCondition   = RAS_PORT_DISCONNECTED;
        break;

    default:
        ASSERT( FALSE );
    }

    return( NO_ERROR );
}

//**
//
// Call:        GetRasiPort1Data
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Given a pointer to a DEVICE_OBJECT structure will extract all
//              relevent information and insert it into a RAS_PORT_0 structure.
//
DWORD
GetRasiPort1Data(
    IN  PDEVICE_OBJECT      pDevObj,
    OUT PRASI_PORT_1        pRasPort1
)
{
    BYTE buffer[sizeof(RAS_STATISTICS) + (MAX_STATISTICS * sizeof (ULONG))];
    RAS_STATISTICS  *pStats = (RAS_STATISTICS *)buffer;
    DWORD           dwSize = sizeof (buffer);
    DWORD           dwRetCode;
    RASMAN_INFO     RasManInfo;

    pRasPort1->dwPort               = PtrToUlong(pDevObj->hPort);
    pRasPort1->dwConnection         = PtrToUlong(pDevObj->hConnection);
    pRasPort1->dwHardwareCondition =
                    ( pDevObj->DeviceState == DEV_OBJ_HW_FAILURE )
                    ? RAS_HARDWARE_FAILURE
                    : RAS_HARDWARE_OPERATIONAL;

    dwRetCode = RasGetInfo( NULL, (HPORT)pDevObj->hPort, &RasManInfo );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    pRasPort1->dwLineSpeed = RasManInfo.RI_LinkSpeed;

    dwRetCode = RasPortGetStatisticsEx(NULL, (HPORT)pDevObj->hPort,
                                      (PBYTE)pStats, &dwSize );

    if ( dwRetCode != NO_ERROR )
    {
        return( dwRetCode );
    }

    pRasPort1->dwLineSpeed      = RasManInfo.RI_LinkSpeed;
    pRasPort1->dwBytesXmited    = pStats->S_Statistics[BYTES_XMITED];
    pRasPort1->dwBytesRcved     = pStats->S_Statistics[BYTES_RCVED];
    pRasPort1->dwFramesXmited   = pStats->S_Statistics[FRAMES_XMITED];
    pRasPort1->dwFramesRcved    = pStats->S_Statistics[FRAMES_RCVED];
    pRasPort1->dwCrcErr         = pStats->S_Statistics[CRC_ERR];
    pRasPort1->dwTimeoutErr     = pStats->S_Statistics[TIMEOUT_ERR];
    pRasPort1->dwAlignmentErr   = pStats->S_Statistics[ALIGNMENT_ERR];
    pRasPort1->dwFramingErr     = pStats->S_Statistics[FRAMING_ERR];
    pRasPort1->dwHardwareOverrunErr
                            = pStats->S_Statistics[HARDWARE_OVERRUN_ERR];
    pRasPort1->dwBufferOverrunErr
                            = pStats->S_Statistics[BUFFER_OVERRUN_ERR];
    pRasPort1->dwCompressionRatioIn
                            = pStats->S_Statistics[ COMPRESSION_RATIO_IN ];
    pRasPort1->dwCompressionRatioOut
                            = pStats->S_Statistics[ COMPRESSION_RATIO_OUT ];

    return( NO_ERROR );
}

DWORD
GetRasPort0Data(
    IN  PDEVICE_OBJECT      pDevObj,
    OUT PRAS_PORT_0        pRasPort0
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_PORT_0     RasiPort0;

    dwErr = GetRasiPort0Data(pDevObj, &RasiPort0);
    if (dwErr == NO_ERROR)
    {
        pRasPort0->hPort                = UlongToPtr(RasiPort0.dwPort);
        pRasPort0->hConnection          = UlongToPtr(RasiPort0.dwConnection);
        pRasPort0->dwPortCondition      = RasiPort0.dwPortCondition;
        pRasPort0->dwTotalNumberOfCalls = RasiPort0.dwTotalNumberOfCalls;
        pRasPort0->dwConnectDuration    = RasiPort0.dwConnectDuration;
        wcscpy(pRasPort0->wszPortName,   RasiPort0.wszPortName);
        wcscpy(pRasPort0->wszMediaName,  RasiPort0.wszMediaName);
        wcscpy(pRasPort0->wszDeviceName, RasiPort0.wszDeviceName);
        wcscpy(pRasPort0->wszDeviceType, RasiPort0.wszDeviceType);
    }

    return dwErr;                
    
#else

    return GetRasiPort0Data(pDevObj, (PRASI_PORT_0)pRasPort0);

#endif
}

DWORD
GetRasPort1Data(
    IN  PDEVICE_OBJECT      pDevObj,
    OUT PRAS_PORT_1        pRasPort1
)
{
#ifdef _WIN64

    DWORD dwErr;
    RASI_PORT_1     RasiPort1;

    dwErr = GetRasiPort1Data(pDevObj, &RasiPort1);
    if (dwErr == NO_ERROR)
    {
        pRasPort1->hPort                = UlongToPtr(RasiPort1.dwPort);
        pRasPort1->hConnection          = UlongToPtr(RasiPort1.dwConnection);
        pRasPort1->dwHardwareCondition  = RasiPort1.dwHardwareCondition;
        pRasPort1->dwLineSpeed          = RasiPort1.dwLineSpeed;
        pRasPort1->dwBytesXmited        = RasiPort1.dwBytesXmited;
        pRasPort1->dwBytesRcved         = RasiPort1.dwBytesRcved;
        pRasPort1->dwFramesXmited       = RasiPort1.dwFramesXmited;
        pRasPort1->dwFramesRcved        = RasiPort1.dwFramesRcved;
        pRasPort1->dwCrcErr             = RasiPort1.dwCrcErr;
        pRasPort1->dwTimeoutErr         = RasiPort1.dwTimeoutErr;
        pRasPort1->dwAlignmentErr       = RasiPort1.dwAlignmentErr;
        pRasPort1->dwHardwareOverrunErr = RasiPort1.dwHardwareOverrunErr;
        pRasPort1->dwFramingErr         = RasiPort1.dwFramingErr;
        pRasPort1->dwBufferOverrunErr   = RasiPort1.dwBufferOverrunErr;
        pRasPort1->dwCompressionRatioIn = RasiPort1.dwCompressionRatioIn;
        pRasPort1->dwCompressionRatioOut= RasiPort1.dwCompressionRatioOut;
    }

    return dwErr;                
    
#else

    return GetRasiPort1Data(pDevObj, (PRASI_PORT_1)pRasPort1);
    
#endif    
}

//***
//
// Function:	SignalHwError
//
// Descr:
//
//***
VOID
SignalHwError(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    LPWSTR	portnamep;

    DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM, "SignalHwErr: Entered");

    portnamep = pDeviceObj->wchPortName;

    DDMLogError( ROUTERLOG_DEV_HW_ERROR, 1, &portnamep, 0 );
}

DWORD
MapAuthCodeToLogId(
    IN WORD Code
)
{
    switch (Code)
    {
        case AUTH_ALL_PROJECTIONS_FAILED:
            return (ROUTERLOG_AUTH_NO_PROJECTIONS);
        case AUTH_PASSWORD_EXPIRED:
            return(ROUTERLOG_PASSWORD_EXPIRED);
        case AUTH_ACCT_EXPIRED:
            return(ROUTERLOG_ACCT_EXPIRED);
        case AUTH_NO_DIALIN_PRIVILEGE:
            return(ROUTERLOG_NO_DIALIN_PRIVILEGE);
        case AUTH_UNSUPPORTED_VERSION:
            return(ROUTERLOG_UNSUPPORTED_VERSION);
        case AUTH_ENCRYPTION_REQUIRED:
            return(ROUTERLOG_ENCRYPTION_REQUIRED);
    }

    return(0);
}

BOOL
IsPortOwned(
    IN PDEVICE_OBJECT pDeviceObj
)
{
    RASMAN_INFO	rasinfo;

    //
    // get the current port state
    //

    if ( RasGetInfo( NULL, pDeviceObj->hPort, &rasinfo ) != NO_ERROR )
    {
        return( FALSE );
    }

    return( rasinfo.RI_OwnershipFlag );
}

VOID
GetLoggingInfo(
    IN PDEVICE_OBJECT pDeviceObj,
    OUT PDWORD BaudRate,
    OUT PDWORD BytesSent,
    OUT PDWORD BytesRecv,
    OUT RASMAN_DISCONNECT_REASON *Reason,
    OUT SYSTEMTIME *Time
)
{
    RASMAN_INFO RasmanInfo;
    BYTE buffer[sizeof(RAS_STATISTICS) + (MAX_STATISTICS * sizeof (ULONG))];
    RAS_STATISTICS  *PortStats = (RAS_STATISTICS *)buffer;
    DWORD PortStatsSize = sizeof (buffer);

    *Reason = 3L;

    //
    // Time is a piece of cake
    //

    GetLocalTime(Time);


    //
    // Now the statistics
    //

    *BytesSent = 0L;
    *BytesRecv = 0L;

    if (RasPortGetStatisticsEx( NULL, 
                                pDeviceObj->hPort, 
                                (PBYTE)PortStats,
                                &PortStatsSize))
    {
        return;
    }

    *BytesRecv = PortStats->S_Statistics[BYTES_RCVED];
    *BytesSent = PortStats->S_Statistics[BYTES_XMITED];

    //
    // And finally the disconnect reason (local or remote) and baud rate
    //

    if (RasGetInfo(NULL, pDeviceObj->hPort, &RasmanInfo))
    {
        return;
    }

    *Reason = RasmanInfo.RI_DisconnectReason;
    *BaudRate = GetLineSpeed(pDeviceObj->hPort);

    //
    // If we have a disconnect reason - will have one
    // when disconnect is happening because of a ppp
    // reason, use that one instead.
    //
    if(pDeviceObj->dwDisconnectReason)
    {
        *Reason = pDeviceObj->dwDisconnectReason;
    }

    return;
}

DWORD
GetLineSpeed(
    IN HPORT hPort
)
{
   RASMAN_INFO RasManInfo;

   if (RasGetInfo(NULL, hPort, &RasManInfo))
   {
      return 0;
   }

   return (RasManInfo.RI_LinkSpeed);
}


VOID
LogConnectionEvent(
    IN PCONNECTION_OBJECT pConnObj,
    IN PDEVICE_OBJECT     pDeviceObj
)
{
    DWORD BaudRate = 0;
    DWORD BytesSent;
    DWORD BytesRecv;
    RASMAN_DISCONNECT_REASON Reason;
    SYSTEMTIME DiscTime;
    LPWSTR auditstrp[12];
    WCHAR *ReasonStr;
    WCHAR BytesRecvStr[20];
    WCHAR BytesSentStr[20];
    WCHAR BaudRateStr[20];
    WCHAR DateConnected[64];
    WCHAR DateDisconnected[64];
    WCHAR TimeConnected[64];
    WCHAR TimeDisconnected[64];
    DWORD active_time;
    WCHAR minutes[20];
    WCHAR seconds[4];
    WCHAR wchFullUserName[UNLEN+DNLEN+2];

    WCHAR *DiscReasons[] =
    {
        gblpszAdminRequest,
        gblpszUserRequest,
        gblpszHardwareFailure,
        gblpszUnknownReason,
        gblpszIdleDisconnect,
        gblpszSessionTimeout
    };

    GetLoggingInfo( pDeviceObj, &BaudRate, &BytesSent,
                    &BytesRecv, &Reason, &DiscTime);

    wcscpy(TimeConnected, L"");
    wcscpy(DateConnected, L"");
    wcscpy(TimeDisconnected, L"");
    wcscpy(DateDisconnected, L"");

    GetTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        TIME_NOSECONDS,
        &pDeviceObj->ConnectionTime,
        NULL,
        TimeConnected,
        sizeof(TimeConnected)/sizeof(WCHAR));
        
    GetDateFormat(
        LOCALE_SYSTEM_DEFAULT,
        DATE_SHORTDATE,
        &pDeviceObj->ConnectionTime,
        NULL,
        DateConnected,
        sizeof(DateConnected)/sizeof(WCHAR));
        
    GetTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        TIME_NOSECONDS,
        &DiscTime,
        NULL,
        TimeDisconnected,
        sizeof(TimeDisconnected)/sizeof(WCHAR));
        
    GetDateFormat(
        LOCALE_SYSTEM_DEFAULT,
        DATE_SHORTDATE,
        &DiscTime,
        NULL,
        DateDisconnected,
        sizeof(DateDisconnected)/sizeof(WCHAR));
        
    active_time = GetActiveTimeInSeconds( &(pDeviceObj->qwActiveTime) );

    DDM_PRINT(  gblDDMConfigInfo.dwTraceId,  TRACE_FSM,
                    "CLIENT ACTIVE FOR %li SECONDS", active_time);

    _itow(active_time / 60, minutes, 10);
    _itow(active_time % 60, seconds, 10);

    wsprintf(BytesSentStr, TEXT("%u"), BytesSent);
    wsprintf(BytesRecvStr, TEXT("%u"), BytesRecv);
    wsprintf(BaudRateStr, TEXT("%i"), BaudRate);
    ReasonStr = DiscReasons[Reason];

    if ( pConnObj->wchDomainName[0] != TEXT('\0') )
    {
        wcscpy( wchFullUserName, pConnObj->wchDomainName );
        wcscat( wchFullUserName, TEXT("\\") );
        wcscat( wchFullUserName, pConnObj->wchUserName );
    }
    else
    {
        wcscpy( wchFullUserName, pConnObj->wchUserName );
    }

    auditstrp[0]    = wchFullUserName;
    auditstrp[1]    = pDeviceObj->wchPortName;
    auditstrp[2]    = DateConnected;
    auditstrp[3]    = TimeConnected;
    auditstrp[4]    = DateDisconnected;
    auditstrp[5]    = TimeDisconnected;
    auditstrp[6]    = minutes;
    auditstrp[7]    = seconds;
    auditstrp[8]    = BytesSentStr;
    auditstrp[9]    = BytesRecvStr;

    if(RAS_DEVICE_CLASS(pDeviceObj->dwDeviceType) == RDT_Tunnel)
    {
        auditstrp[10]   = DiscReasons[Reason];
        auditstrp[11]   = NULL;
        DDMLogInformation( ROUTERLOG_USER_ACTIVE_TIME_VPN, 11, auditstrp );
    }
    else
    {
        auditstrp[10]   = BaudRateStr;
        auditstrp[11]   = DiscReasons[Reason];
        DDMLogInformation( ROUTERLOG_USER_ACTIVE_TIME, 12, auditstrp );
    }

    if(pConnObj->PppProjectionResult.ip.dwError == NO_ERROR)
    {
        WCHAR *pszAddress = GetIpAddress(
                pConnObj->PppProjectionResult.ip.dwRemoteAddress);
                
        auditstrp[0] = pszAddress;

        DDMLogInformation( ROUTERLOG_IP_USER_DISCONNECTED, 1, auditstrp);
        LocalFree(pszAddress);
    }
}

//**
//
// Call:        GetTransportIndex
//
// Returns:     Index of the tansport entry in the interface object
//
// Description: Given the id of a protocol return an index.
//
DWORD
GetTransportIndex(
    IN DWORD dwProtocolId
)
{
    DWORD dwTransportIndex;

    for ( dwTransportIndex = 0;
          dwTransportIndex < gblDDMConfigInfo.dwNumRouterManagers;
          dwTransportIndex++ )
    {
        if ( gblRouterManagers[dwTransportIndex].DdmRouterIf.dwProtocolId
                                                            == dwProtocolId )
        {
            return( dwTransportIndex );
        }
    }

    return( (DWORD)-1 );
}

VOID
DDMPostCleanup(
    VOID
)
{
    if ( gblDDMConfigInfo.hinstAcctModule != NULL )
    {
        DWORD dwRetCode;
        HKEY  hKeyAccounting;

        if ( gblDDMConfigInfo.lpfnRasAcctProviderTerminate != NULL )
        {
            gblDDMConfigInfo.lpfnRasAcctProviderTerminate();
        }

        //
        // Write back the AccntSessionId value
        //

        dwRetCode = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        RAS_KEYPATH_ACCOUNTING,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKeyAccounting );

        if ( dwRetCode == NO_ERROR )
        {
            RegSetValueEx(
                        hKeyAccounting,
                        RAS_VALNAME_ACCTSESSIONID,
                        0,
                        REG_DWORD,
                        (BYTE *)(&gblDDMConfigInfo.dwAccountingSessionId),
                        4 );

            RegCloseKey( hKeyAccounting );
        }

        FreeLibrary( gblDDMConfigInfo.hinstAcctModule );

        gblDDMConfigInfo.hinstAcctModule = NULL;
    }

    DeleteCriticalSection( &(gblDDMConfigInfo.CSAccountingSessionId) );
        
    if ( gblDDMConfigInfo.hinstAuthModule != NULL )
    {
        if ( gblDDMConfigInfo.lpfnRasAuthProviderTerminate != NULL )
        {
            gblDDMConfigInfo.lpfnRasAuthProviderTerminate();
        }

        FreeLibrary( gblDDMConfigInfo.hinstAuthModule );

        gblDDMConfigInfo.hinstAuthModule = NULL;
    }
}


//**
//
// Call:        DDMCleanUp
//
// Returns:     None
//
// Description: Will clean up all DDM allocations
//
VOID
DDMCleanUp(
    VOID
)
{
    DWORD   dwIndex;

    if ( gblDDMConfigInfo.hIpHlpApi != NULL )
    {
        FreeLibrary( gblDDMConfigInfo.hIpHlpApi );
        gblDDMConfigInfo.hIpHlpApi = NULL;
        gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack = NULL;
        gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack = NULL;
    }

    if ( gblDDMConfigInfo.fRasSrvrInitialized )
    {
        RasSrvrUninitialize();
        gblDDMConfigInfo.fRasSrvrInitialized = FALSE;
    }

    PppDdmDeInit();


    if ( gblDDMConfigInfo.hkeyParameters != NULL )
    {
        RegCloseKey( gblDDMConfigInfo.hkeyParameters );

        gblDDMConfigInfo.hkeyParameters = NULL;
    }

    if ( gblDDMConfigInfo.hkeyAccounting != NULL )
    {
        RegCloseKey( gblDDMConfigInfo.hkeyParameters );

        gblDDMConfigInfo.hkeyParameters = NULL;
    }

    if ( gblDDMConfigInfo.hkeyAuthentication != NULL )
    {
        RegCloseKey( gblDDMConfigInfo.hkeyParameters );

        gblDDMConfigInfo.hkeyParameters = NULL;
    }

    {
        DWORD i;

        for (i=0;  i<gblDDMConfigInfo.NumAdminDlls;  i++)
        {
            PADMIN_DLL_CALLBACKS AdminDllCallbacks = &gblDDMConfigInfo.AdminDllCallbacks[i];

            if ( AdminDllCallbacks->hInstAdminModule != NULL )
            {        
                if ( AdminDllCallbacks->lpfnRasAdminTerminateDll != NULL )
                {
                    DWORD (*TerminateAdminDll)() =
                        (DWORD(*)(VOID))AdminDllCallbacks->lpfnRasAdminTerminateDll;

                    TerminateAdminDll();
                }

                FreeLibrary( AdminDllCallbacks->hInstAdminModule );
            }
        }
    }

    if ( gblDDMConfigInfo.AdminDllCallbacks != NULL )
    {
        LOCAL_FREE( gblDDMConfigInfo.AdminDllCallbacks );
    }

    if ( gblDDMConfigInfo.hInstSecurityModule != NULL )
    {
        FreeLibrary( gblDDMConfigInfo.hInstSecurityModule );
    }

    if ( gblpRouterPhoneBook != NULL )
    {
        LOCAL_FREE( gblpRouterPhoneBook );
    }

    if ( gblpszAdminRequest != NULL )
    {
        LOCAL_FREE( gblpszAdminRequest );
    }

    if ( gblpszUserRequest != NULL )
    {
        LOCAL_FREE( gblpszUserRequest );
    }

    if ( gblpszHardwareFailure != NULL )
    {
        LOCAL_FREE( gblpszHardwareFailure );
    }

    if ( gblpszUnknownReason != NULL )
    {
        LOCAL_FREE( gblpszUnknownReason );
    }

    if ( gblpszPm != NULL )
    {
        LOCAL_FREE( gblpszPm );
    }

    if ( gblpszAm  != NULL )
    {
        LOCAL_FREE( gblpszAm  );
    }

    if ( gblpszIdleDisconnect != NULL )
    {
        LOCAL_FREE( gblpszIdleDisconnect );
    }

    if( gblpszSessionTimeout != NULL )
    {
        LOCAL_FREE( gblpszSessionTimeout );
    }

    if( gblDDMConfigInfo.apAnalogIPAddresses != NULL )
    {
        LocalFree( gblDDMConfigInfo.apAnalogIPAddresses[0] );
        LocalFree( gblDDMConfigInfo.apAnalogIPAddresses );

        gblDDMConfigInfo.apAnalogIPAddresses = NULL;
        gblDDMConfigInfo.cAnalogIPAddresses  = 0;
    }

    if( gblDDMConfigInfo.apDigitalIPAddresses != NULL )
    {
        LocalFree( gblDDMConfigInfo.apDigitalIPAddresses[0] );
        LocalFree( gblDDMConfigInfo.apDigitalIPAddresses );

        gblDDMConfigInfo.apDigitalIPAddresses = NULL;
        gblDDMConfigInfo.cDigitalIPAddresses  = 0;
    }

    gblDDMConfigInfo.dwIndex = 0;

    if ( gblDeviceTable.DeviceBucket != NULL )
    {
        //
        // close all opened devices
        //

        DeviceObjIterator( DeviceObjClose, FALSE, NULL );
    }

    if(gblDDMConfigInfo.fRasmanReferenced)
    {
        //
        // Decerement rasman's refrence count. This does not happen
        // automatically since we are in the same process as rasman.
        //

        RasReferenceRasman( FALSE );
    }

    if ( gblSupervisorEvents != (HANDLE *)NULL )
    {
        DeleteMessageQs();

        for ( dwIndex = 0;
              dwIndex < NUM_DDM_EVENTS +
                        gblDeviceTable.NumDeviceBuckets +
                        gblDeviceTable.NumConnectionBuckets;
              dwIndex ++ )
        {
            if ( gblSupervisorEvents[dwIndex] != NULL )
            {
                switch( dwIndex )
                {
                case DDM_EVENT_SVC_TERMINATED:
                case DDM_EVENT_SVC:
                    break;

                default:
                    CloseHandle( gblSupervisorEvents[dwIndex] );
                    break;
                }

                gblSupervisorEvents[dwIndex] = NULL;
            }
        }
    }

    //
    // Wait for this to be released
    //

    EnterCriticalSection( &(gblDeviceTable.CriticalSection) );

    DeleteCriticalSection( &(gblDeviceTable.CriticalSection) );

    TimerQDelete();

    //
    // Release all notification events
    //

    if ( gblDDMConfigInfo.NotificationEventListHead.Flink != NULL )
    {
        while( !IsListEmpty( &(gblDDMConfigInfo.NotificationEventListHead ) ) )
        {
            NOTIFICATION_EVENT * pNotificationEvent = (NOTIFICATION_EVENT *)
               RemoveHeadList( &(gblDDMConfigInfo.NotificationEventListHead) );

            CloseHandle( pNotificationEvent->hEventClient );

            CloseHandle( pNotificationEvent->hEventRouter );

            LOCAL_FREE( pNotificationEvent );
        }
    }

    MediaObjFreeTable();

    //
    // Destroy private heap
    //

    if ( gblDDMConfigInfo.hHeap != NULL )
    {
        HeapDestroy( gblDDMConfigInfo.hHeap );
    }

    //
    // Zero out globals
    //

    ZeroMemory( &gblDeviceTable,        sizeof( gblDeviceTable ) );
    ZeroMemory( &gblMediaTable,         sizeof( gblMediaTable ) );
    ZeroMemory( gblEventHandlerTable,   sizeof( gblEventHandlerTable ) );
    //ZeroMemory( &gblDDMConfigInfo,      sizeof( gblDDMConfigInfo ) );
    gblRouterManagers           = NULL;
    gblpInterfaceTable          = NULL;
    gblSupervisorEvents         = NULL;
    gblphEventDDMServiceState   = NULL;
    gblpRouterPhoneBook         = NULL;
    gblpszAdminRequest          = NULL;
    gblpszUserRequest           = NULL;
    gblpszHardwareFailure       = NULL;
    gblpszUnknownReason         = NULL;
    gblpszPm                    = NULL;
    gblpszAm                    = NULL;
    gblpszIdleDisconnect        = NULL;
    gblpszSessionTimeout        = NULL;

}

//**
//
// Call:        GetRouterPhoneBook
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will set the gblpRouterPhoneBook global to point to the
//              full path of the router phonebook.
//
DWORD
GetRouterPhoneBook(
    VOID
)
{
    DWORD dwSize;
    DWORD cchDir = GetWindowsDirectory( NULL, 0 );

    if ( cchDir == 0 )
    {
        return( GetLastError() );
    }

    dwSize=(cchDir+wcslen(TEXT("\\SYSTEM32\\RAS\\ROUTER.PBK"))+1)*sizeof(WCHAR);

    if ( ( gblpRouterPhoneBook = LOCAL_ALLOC( LPTR, dwSize ) ) == NULL )
    {
        return( GetLastError() );
    }

    if ( GetWindowsDirectory( gblpRouterPhoneBook, cchDir ) == 0 )
    {
        return( GetLastError() );
    }

    if ( gblpRouterPhoneBook[cchDir-1] != TEXT('\\') )
    {
        wcscat( gblpRouterPhoneBook, TEXT("\\") );
    }

    wcscat( gblpRouterPhoneBook, TEXT("SYSTEM32\\RAS\\ROUTER.PBK") );

    return( NO_ERROR );

}

//**
//
// Call:        LoadStrings
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Loads all localizable strings from the resource table
//
DWORD
LoadStrings(
    VOID
)
{
    #define MAX_XLATE_STRING 40
    LPWSTR  lpwsModuleName = TEXT("MPRDDM.DLL");

    //
    // Load strings from resource file
    //

    gblpszAdminRequest     = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszUserRequest      = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszHardwareFailure  = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszUnknownReason    = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszPm               = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszAm               = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszUnknown          = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszIdleDisconnect   = LOCAL_ALLOC(LPTR,  MAX_XLATE_STRING*sizeof(WCHAR));
    gblpszSessionTimeout   = LOCAL_ALLOC( LPTR, MAX_XLATE_STRING*sizeof(WCHAR));


    if ( ( gblpszAdminRequest       == NULL ) ||
         ( gblpszUserRequest        == NULL ) ||
         ( gblpszHardwareFailure    == NULL ) ||
         ( gblpszUnknownReason      == NULL ) ||
         ( gblpszUnknown            == NULL ) ||
         ( gblpszPm                 == NULL ) ||
         ( gblpszAm                 == NULL ) ||
         ( gblpszIdleDisconnect     == NULL ) ||
         ( gblpszSessionTimeout     == NULL ))
    {
        return( GetLastError() );
    }

    if (( !LoadString( GetModuleHandle( lpwsModuleName ), 1,
                       gblpszAdminRequest, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName ), 2,
                       gblpszUserRequest, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName ), 3,
                       gblpszHardwareFailure, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName ), 4,
                       gblpszUnknownReason, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName) , 5,
                       gblpszAm, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName ), 6,
                       gblpszPm, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName) , 7,
                       gblpszUnknown, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName) , 8,
                        gblpszIdleDisconnect, MAX_XLATE_STRING ))
        ||
        ( !LoadString( GetModuleHandle( lpwsModuleName), 9,
                        gblpszSessionTimeout, MAX_XLATE_STRING)))
    {
        return( GetLastError() );
    }

    return( NO_ERROR );

}

//**
//
// Call:        AcceptNewLink
//
// Returns:     TRUE  - Continue with link processing
//              FALSE - Abort link processing
//
// Description:
//
BOOL
AcceptNewLink(
    IN DEVICE_OBJECT *      pDeviceObj,
    IN CONNECTION_OBJECT *  pConnObj
)
{
    DWORD i;
    BOOL bFirstLoop, bReturnFalse;
    RAS_PORT_0 RasPort0;
    RAS_PORT_1 RasPort1;
    BOOL (*MprAdminAcceptNewLink)( RAS_PORT_0 *, RAS_PORT_1 * );

    //
    // return TRUE only if no one says FALSE
    //

    
    for (i=0,bFirstLoop=TRUE,bReturnFalse=FALSE;  
            (i<gblDDMConfigInfo.NumAdminDlls) && !bReturnFalse;  i++)
    {
        PADMIN_DLL_CALLBACKS AdminDllCallbacks = &gblDDMConfigInfo.AdminDllCallbacks[i];
        
        //
        // If admin module is loaded, notify it of a new link
        //

        if ( AdminDllCallbacks->lpfnRasAdminAcceptNewLink != NULL )
        {
            if (bFirstLoop)
            {
                bFirstLoop = FALSE;
                
                if ((GetRasPort0Data(pDeviceObj,&RasPort0) != NO_ERROR)
                     ||
                    (GetRasPort1Data(pDeviceObj,&RasPort1) != NO_ERROR))
                {
                    DevStartClosing( pDeviceObj );

                    return( FALSE );
                }

                pDeviceObj->fFlags &= (~DEV_OBJ_NOTIFY_OF_DISCONNECTION);
            }

            MprAdminAcceptNewLink =
                    (BOOL (*)( RAS_PORT_0 *, RAS_PORT_1 * ))
                                AdminDllCallbacks->lpfnRasAdminAcceptNewLink;

            if ( !MprAdminAcceptNewLink( &RasPort0, &RasPort1 ) )
            {
                DevStartClosing( pDeviceObj );

                bReturnFalse = TRUE;
                break;
            }
        }
    }

    if (bReturnFalse)
    {
        DWORD j;
        
        for (j=0;  j<i;  j++)
        {
            PADMIN_DLL_CALLBACKS AdminDllCallbacks = &gblDDMConfigInfo.AdminDllCallbacks[j];
            VOID (*MprAdminLinkHangupNotification)(RAS_PORT_0 *,
                                                   RAS_PORT_1*);
                                                   
            if (AdminDllCallbacks->lpfnRasAdminLinkHangupNotification != NULL)
            {
                MprAdminLinkHangupNotification =
                    (VOID (*)( RAS_PORT_0 *, RAS_PORT_1 * ))
                        AdminDllCallbacks->lpfnRasAdminLinkHangupNotification;

                MprAdminLinkHangupNotification( &RasPort0, &RasPort1 );
            }
        }
        
        return FALSE;
        
    } //return false

    pDeviceObj->fFlags |= DEV_OBJ_NOTIFY_OF_DISCONNECTION;
    
    return( TRUE );
}

//**
//
// Call:        AcceptNewConnection
//
// Returns:     TRUE  - Continue with connection processing
//              FALSE - Abort connection processing
//
// Description:
//
BOOL
AcceptNewConnection(
    IN DEVICE_OBJECT *      pDeviceObj,
    IN CONNECTION_OBJECT *  pConnObj
)
{
    DWORD i;
    BOOL  bFirstLoop, bReturnFalse;
    RAS_CONNECTION_0 RasConnection0;
    RAS_CONNECTION_1 RasConnection1;
    RAS_CONNECTION_2 RasConnection2;

    
    //
    // return TRUE only if no one says FALSE
    //

    
    for (i=0,bFirstLoop=TRUE,bReturnFalse=FALSE; 
            (i<gblDDMConfigInfo.NumAdminDlls) && !bReturnFalse;  i++)
    {
        PADMIN_DLL_CALLBACKS AdminDllCallbacks = &gblDDMConfigInfo.AdminDllCallbacks[i];
        
        //
        // If admin module is loaded, notify it of a new connection
        //

        if ( ( AdminDllCallbacks->lpfnRasAdminAcceptNewConnection != NULL ) ||
             ( AdminDllCallbacks->lpfnRasAdminAcceptNewConnection2 != NULL ) )
        {
            if (bFirstLoop)
            {
                bFirstLoop = FALSE;
                
                if ((GetRasConnection0Data(pConnObj,&RasConnection0) != NO_ERROR)
                     ||
                    (GetRasConnection1Data(pConnObj,&RasConnection1) != NO_ERROR)
                     ||
                    (GetRasConnection2Data(pConnObj,&RasConnection2) != NO_ERROR))
                {
                    ConnObjDisconnect( pConnObj );

                    return( FALSE );
                }

                //
                // Let callout DLL know that we do not have a username for this user
                //

                if ( _wcsicmp( RasConnection0.wszUserName, gblpszUnknown ) == 0 )
                {
                    RasConnection0.wszUserName[0] = (WCHAR)NULL;
                }

                pConnObj->fFlags &= (~CONN_OBJ_NOTIFY_OF_DISCONNECTION);
            }
            
            if ( AdminDllCallbacks->lpfnRasAdminAcceptNewConnection2 != NULL )
            {
                BOOL (*MprAdminAcceptNewConnection2)(
                                    RAS_CONNECTION_0 *,
                                    RAS_CONNECTION_1 *,
                                    RAS_CONNECTION_2 * );

                MprAdminAcceptNewConnection2 =
                    (BOOL (*)(
                            RAS_CONNECTION_0 *,
                            RAS_CONNECTION_1 * ,
                            RAS_CONNECTION_2 * ))
                                AdminDllCallbacks->lpfnRasAdminAcceptNewConnection2;

                if ( !MprAdminAcceptNewConnection2( &RasConnection0,
                                                   &RasConnection1,
                                                   &RasConnection2 ) )
                {
                    ConnObjDisconnect( pConnObj );

                    bReturnFalse = TRUE;
                    break;
                }
            }
            else
            {

                BOOL (*MprAdminAcceptNewConnection)(
                                    RAS_CONNECTION_0 *,
                                    RAS_CONNECTION_1 * );

                MprAdminAcceptNewConnection =
                    (BOOL (*)(
                            RAS_CONNECTION_0 *,
                            RAS_CONNECTION_1 * ))
                                AdminDllCallbacks->lpfnRasAdminAcceptNewConnection;

                if ( !MprAdminAcceptNewConnection( &RasConnection0,
                                               &RasConnection1 ) )
                {
                    ConnObjDisconnect( pConnObj );

                    bReturnFalse = TRUE;
                    break;
                }
            }
        }
    }

    if (bReturnFalse)
    {
        DWORD j;

        for (j=0;  j<i;  j++)
        {
            PADMIN_DLL_CALLBACKS AdminDllCallbacks = 
                                &gblDDMConfigInfo.AdminDllCallbacks[j];


            if ( AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification2 != NULL)
            {
                VOID (*MprAdminConnectionHangupNotification2)( RAS_CONNECTION_0 *,
                                                               RAS_CONNECTION_1 *,
                                                               RAS_CONNECTION_2 * );
                MprAdminConnectionHangupNotification2 =
                    (VOID (*)( RAS_CONNECTION_0 *,
                               RAS_CONNECTION_1 *,
                               RAS_CONNECTION_2 * ))
                         AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification2;

                MprAdminConnectionHangupNotification2( &RasConnection0,
                                                       &RasConnection1,
                                                       &RasConnection2 );
            }
            else if ( AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification != NULL)
            {
                VOID (*MprAdminConnectionHangupNotification)( RAS_CONNECTION_0 *,
                                                              RAS_CONNECTION_1 * );
                MprAdminConnectionHangupNotification =
                    (VOID (*)( RAS_CONNECTION_0 *,
                               RAS_CONNECTION_1 * ))
                          AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification;

                MprAdminConnectionHangupNotification( &RasConnection0,
                                                      &RasConnection1 );
            }
        } //for
        
        return( FALSE );
    }


    pConnObj->fFlags |= CONN_OBJ_NOTIFY_OF_DISCONNECTION;
    
    return( TRUE );
}

//**
//
// Call:        ConnectionHangupNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
ConnectionHangupNotification(
    IN CONNECTION_OBJECT *  pConnObj
)
{
    RAS_CONNECTION_0 RasConnection0;
    RAS_CONNECTION_1 RasConnection1;
    RAS_CONNECTION_2 RasConnection2;


    if ((GetRasConnection0Data(pConnObj,&RasConnection0) == NO_ERROR) &&
        (GetRasConnection1Data(pConnObj,&RasConnection1) == NO_ERROR) &&
        (GetRasConnection2Data(pConnObj,&RasConnection2) == NO_ERROR))
    {
        DWORD i;
        
        for (i=0;  i<gblDDMConfigInfo.NumAdminDlls;  i++)
        {
            PADMIN_DLL_CALLBACKS AdminDllCallbacks = &gblDDMConfigInfo.AdminDllCallbacks[i];

                
            if ( AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification2 != NULL)
            {
                VOID (*MprAdminConnectionHangupNotification2)( RAS_CONNECTION_0 *,
                                                               RAS_CONNECTION_1 *,
                                                               RAS_CONNECTION_2 * );
                MprAdminConnectionHangupNotification2 =
                    (VOID (*)( RAS_CONNECTION_0 *,
                               RAS_CONNECTION_1 *,
                               RAS_CONNECTION_2 * ))
                         AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification2;

                MprAdminConnectionHangupNotification2( &RasConnection0,
                                                       &RasConnection1,
                                                       &RasConnection2 );
            }
            else
            {
                VOID (*MprAdminConnectionHangupNotification)( RAS_CONNECTION_0 *,
                                                              RAS_CONNECTION_1 * );
                MprAdminConnectionHangupNotification =
                    (VOID (*)( RAS_CONNECTION_0 *,
                               RAS_CONNECTION_1 * ))
                          AdminDllCallbacks->lpfnRasAdminConnectionHangupNotification;

                MprAdminConnectionHangupNotification( &RasConnection0,
                                                      &RasConnection1 );
            }
        } //for
    }
}

//**
//
// Call:        GetActiveTimeInSeconds
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will return the difference, in seconds, between then time the
//              current time and the time represented by the argument passed in.
//
DWORD
GetActiveTimeInSeconds(
    IN ULARGE_INTEGER * pqwActiveTime
)
{
    ULARGE_INTEGER  qwCurrentTime;
    ULARGE_INTEGER  qwUpTime;
    DWORD           dwRemainder;

    if ( pqwActiveTime->QuadPart == 0 )
    {
        return( 0 );
    }

    GetSystemTimeAsFileTime( (FILETIME*)&qwCurrentTime );

    if ( pqwActiveTime->QuadPart > qwCurrentTime.QuadPart )
    {
        return( 0 );
    }

    qwUpTime.QuadPart = qwCurrentTime.QuadPart - pqwActiveTime->QuadPart;

    return( RtlEnlargedUnsignedDivide(qwUpTime,(DWORD)10000000,&dwRemainder));

}

//**
//
// Call:        DDMRecognizeFrame
//
// Returns:     TRUE  - Recognized
//              FALSE - Unrecognized
//
// Description: Returns whether a received packet has a recognized format
//              by the RAS server (i.e. is in the format of a data-link layer
//              protocol that is supported by RAS).
//          
//              Up though Windows 2000, this api would return true for AMB
//              or PPP packets.  
//
//              Now, only PPP packets are supported.
//
BOOL
DDMRecognizeFrame(
    IN PVOID    pvFrameBuf,         // pointer to the frame
    IN WORD     wFrameLen,          // Length in bytes of the frame
    OUT DWORD   *pProtocol          // xport id - valid only if recognized
)
{
    PBYTE   pb;
    WORD    FrameType;

    if ( wFrameLen < 16 )
    {
        DDMTRACE( "Initial frame length is less than 16, frame not recognized");
        //ASSERT( FALSE );
        return( FALSE );
    }

    //
    // Check PPP 
    //

    pb = ((PBYTE) pvFrameBuf) + 12;

    GET_USHORT(&FrameType, pb);

    switch( FrameType )
    {
    case PPP_LCP_PROTOCOL:
    case PPP_PAP_PROTOCOL:
    case PPP_CBCP_PROTOCOL:
    case PPP_BACP_PROTOCOL:
    case PPP_BAP_PROTOCOL:
    case PPP_CHAP_PROTOCOL:
    case PPP_IPCP_PROTOCOL:
    case PPP_ATCP_PROTOCOL:
    case PPP_IPXCP_PROTOCOL:
    case PPP_CCP_PROTOCOL:
    case PPP_SPAP_NEW_PROTOCOL:
    case PPP_EAP_PROTOCOL:

        *pProtocol = PPP_LCP_PROTOCOL;
        return( TRUE );

    default:

        DDMTRACE1("Initial frame has unknown header %x, frame unrecognized",
                   FrameType );
        //ASSERT( FALSE );
        break;
    }

    return( FALSE );
}

//**
//
// Call:        DDMGetIdentityAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will gather all identity attributes and return them to
//              DIM to be plumbed into the DS
//
DWORD
DDMGetIdentityAttributes(
    IN OUT ROUTER_IDENTITY_ATTRIBUTE * pRouterIdAttributes
)
{
    DWORD dwIndex;

    //
    // Get all media types used
    //

    DeviceObjIterator( DeviceObjGetType, FALSE, pRouterIdAttributes );

    for( dwIndex = 0;
         pRouterIdAttributes[dwIndex].dwVendorId != (DWORD)-1;
         dwIndex++ );

    //
    // Find out the authentication/accounting providers
    //

    if ( gblDDMConfigInfo.fFlags & DDM_USING_NT_AUTHENTICATION )
    {
        pRouterIdAttributes[dwIndex].dwVendorId = 311;
        pRouterIdAttributes[dwIndex].dwType     = 6;
        pRouterIdAttributes[dwIndex].dwValue    = 801;

        dwIndex++;
    }
    else if ( gblDDMConfigInfo.fFlags & DDM_USING_RADIUS_AUTHENTICATION )
    {
        pRouterIdAttributes[dwIndex].dwVendorId = 311;
        pRouterIdAttributes[dwIndex].dwType     = 6;
        pRouterIdAttributes[dwIndex].dwValue    = 802;

        dwIndex++;
    }

    if ( gblDDMConfigInfo.fFlags & DDM_USING_RADIUS_ACCOUNTING )
    {
        pRouterIdAttributes[dwIndex].dwVendorId = 311;
        pRouterIdAttributes[dwIndex].dwType     = 6;
        pRouterIdAttributes[dwIndex].dwValue    = 803;

        dwIndex++;
    }

    if ( gblDDMConfigInfo.fArapAllowed )
    {
        // AppleTalkRAS(ATCP): Vendor= MS, TypeMajor= 6, TypeMinor= 504
        //
        pRouterIdAttributes[dwIndex].dwVendorId = 311;
        pRouterIdAttributes[dwIndex].dwType     = 6;
        pRouterIdAttributes[dwIndex].dwValue    = 504;

        dwIndex++;
    }

    //
    // Terminate the array
    //

    pRouterIdAttributes[dwIndex].dwVendorId = (DWORD)-1;
    pRouterIdAttributes[dwIndex].dwType     = (DWORD)-1;
    pRouterIdAttributes[dwIndex].dwValue    = (DWORD)-1;

    return( NO_ERROR );
}

//**
//
// Call:        GetNextAccountingSessionId
//
// Returns:     Next Accounting session Id to use
//
// Description: Called by PPP to get the next accounting session ID
//              to use the next accouting request sent to the accounting
//              provider.
//
DWORD
GetNextAccountingSessionId(
    VOID
)
{
    DWORD  dwAccountingSessionId;

    EnterCriticalSection( &(gblDDMConfigInfo.CSAccountingSessionId) );

    dwAccountingSessionId = (gblDDMConfigInfo.dwAccountingSessionId++);

    LeaveCriticalSection( &(gblDDMConfigInfo.CSAccountingSessionId) );

    return( dwAccountingSessionId );
}

//**
//
// Call:        LoadIpHlpApiDll
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Loads iphlpapi.dll and gets the proc addresses of
//              AllocateAndGetIfTableFromStack and
//              AllocateAndGetIpAddrTableFromStack. These values are stored in
//              gblDDMConfigInfo. If anything fails, the variables in
//              gblDDMConfigInfo remain NULL, and no cleanup is necessary.
//
DWORD
LoadIpHlpApiDll(
    VOID
)
{
    DWORD   dwResult    = NO_ERROR;

    if ( gblDDMConfigInfo.hIpHlpApi != NULL )
    {
        RTASSERT( gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack != NULL );
        RTASSERT( gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack !=
                  NULL );

        return ( NO_ERROR );
    }

    do
    {
        gblDDMConfigInfo.hIpHlpApi = LoadLibrary(TEXT("iphlpapi.dll"));

        if ( gblDDMConfigInfo.hIpHlpApi == NULL )
        {
            dwResult = GetLastError();

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "LoadLibrary(iphlpapi.dll) failed: %d", dwResult);

            break;
        }

        gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack =
            (ALLOCATEANDGETIFTABLEFROMSTACK)
            GetProcAddress( gblDDMConfigInfo.hIpHlpApi,
                            "AllocateAndGetIfTableFromStack" );

        if ( gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack == NULL )
        {
            dwResult = GetLastError();

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "GetProcAddress( AllocateAndGetIfTableFromStack ) "
                       "failed: %d", dwResult);

            break;
        }

        gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack =
            (ALLOCATEANDGETIPADDRTABLEFROMSTACK)
            GetProcAddress( gblDDMConfigInfo.hIpHlpApi,
                            "AllocateAndGetIpAddrTableFromStack" );

        if ( gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack == NULL )
        {
            dwResult = GetLastError();

            DDM_PRINT( gblDDMConfigInfo.dwTraceId, TRACE_FSM,
                       "GetProcAddress( AllocateAndGetIpAddrTableFromStack ) "
                       "failed: %d", dwResult);

            break;
        }

    }
    while ( FALSE );

    if ( dwResult != NO_ERROR )
    {
        gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack = NULL;
        gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack = NULL;

        if ( gblDDMConfigInfo.hIpHlpApi != NULL )
        {
            FreeLibrary( gblDDMConfigInfo.hIpHlpApi );
            gblDDMConfigInfo.hIpHlpApi = NULL;
        }
    }

    return( dwResult );
}

//**
//
// Call:        LogUnreachabilityEvent
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
VOID
LogUnreachabilityEvent(
    IN DWORD    dwReason,
    IN LPWSTR   lpwsInterfaceName
)
{
    DWORD dwEventLogId = 0;

    switch( dwReason )
    {
    case INTERFACE_OUT_OF_RESOURCES:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON1;
        break;
    case INTERFACE_CONNECTION_FAILURE:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON2;
        break;
    case INTERFACE_DISABLED:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON3;
        break;
    case INTERFACE_SERVICE_IS_PAUSED:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON4;
        break;
    case INTERFACE_DIALOUT_HOURS_RESTRICTION:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON5;
        break;
    case INTERFACE_NO_MEDIA_SENSE:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON6;
        break;
    case INTERFACE_NO_DEVICE:
        dwEventLogId = ROUTERLOG_IF_UNREACHABLE_REASON7;
        break;
    default:
        dwEventLogId = 0;
        break;
    }

    if ( dwEventLogId != 0 )
    {
        DDMLogInformation( dwEventLogId, 1, &lpwsInterfaceName );
    }
}

//**
//
// Call:        GetLocalNASIpAddress
//
// Returns:     IP address of Local Machine - Success
//              0                           - Failure
//
// Description: Will get the IP address of this NAS to be sent to the back-end
//              authentication module, if IP is installed on the local machine,
//              otherwise it will
//
DWORD
GetLocalNASIpAddress(
    VOID
)
{
    DWORD               dwResult, i, j, dwSize;
    DWORD               dwIpAddress;
    PMIB_IFTABLE        pIfTable;
    PMIB_IPADDRTABLE    pIpAddrTable;

    dwResult = LoadIpHlpApiDll();

    if ( dwResult != NO_ERROR )
    {
        return( 0 );
    }

    dwSize = 0;

    dwResult = gblDDMConfigInfo.lpfnAllocateAndGetIfTableFromStack(
                    &pIfTable,
                    FALSE,
                    GetProcessHeap(),
                    HEAP_ZERO_MEMORY,
                    TRUE);

    if ( dwResult != NO_ERROR )
    {
        return( 0 );
    }

    if( pIfTable->dwNumEntries == 0 )
    {
        LocalFree( pIfTable );

        return( 0 );
    }

    //
    // Ok so now we have the IF Table, get the corresponding IP Address table
    //

    dwResult = gblDDMConfigInfo.lpfnAllocateAndGetIpAddrTableFromStack(
                    &pIpAddrTable,
                    FALSE,
                    GetProcessHeap(),
                    HEAP_ZERO_MEMORY);

    if ( dwResult != NO_ERROR )
    {
        LocalFree( pIfTable );

        return( 0 );
    }

    if ( pIpAddrTable->dwNumEntries == 0 )
    {
        LocalFree( pIfTable );

        LocalFree( pIpAddrTable );

        return( 0 );
    }

    for ( i = 0; i < pIfTable->dwNumEntries; i++ )
    {
        //
        // Go through the interface trying to find a good one
        //

        if((pIfTable->table[i].dwType == MIB_IF_TYPE_PPP)  ||
           (pIfTable->table[i].dwType == MIB_IF_TYPE_SLIP) ||
           (pIfTable->table[i].dwType == MIB_IF_TYPE_LOOPBACK))
        {
            //
            // Dont want any of these
            //

            continue;
        }

        for ( j = 0; j < pIpAddrTable->dwNumEntries; j++ )
        {
            if( pIpAddrTable->table[j].dwIndex == pIfTable->table[i].dwIndex )
            {
                if( pIpAddrTable->table[j].dwAddr == 0x00000000 )
                {
                    //
                    // An invalid address
                    //

                    continue;
                }

                LocalFree( pIfTable );

                dwIpAddress = WireToHostFormat32(
                                       (CHAR*)&(pIpAddrTable->table[j].dwAddr));

                LocalFree( pIpAddrTable );

                return( dwIpAddress );
            }
        }
    }

    LocalFree( pIfTable );

    LocalFree( pIpAddrTable );

    return( 0 );
}

DWORD
ModifyDefPolicyToForceEncryption(
    IN BOOL bStrong)
{
    HANDLE hServer = NULL;
    DWORD dwErr = NO_ERROR, dwType, dwSize, dwFlags = 0;
    HKEY hkFlags = NULL;

    do
    {
        dwErr = MprAdminUserServerConnect(NULL, TRUE, &hServer);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        dwErr = MprAdminUserWriteProfFlags(
                    hServer,
                    (bStrong) ? MPR_USER_PROF_FLAG_FORCE_STRONG_ENCRYPTION
                              : MPR_USER_PROF_FLAG_FORCE_ENCRYPTION);

        // DISP_E_MEMBERNOTFOUND returned from MprAdminUserWriteProfFlags means that
        // there is no default policy either because there are no policies or because
        // there are more than one.
        //
        // If there is no default policy, then we should continue on this function
        // to clear the bits.
        //
        if ((dwErr != DISP_E_MEMBERNOTFOUND) && (dwErr != NO_ERROR))
        {
            break;
        }

        dwErr = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters",
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkFlags);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);
        dwErr = RegQueryValueExW(
                    hkFlags,
                    L"ServerFlags",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwFlags,
                    &dwSize);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        dwFlags &= ~PPPCFG_RequireEncryption;
        dwFlags &= ~PPPCFG_RequireStrongEncryption;

        dwErr = RegSetValueExW(
                    hkFlags,
                    L"ServerFlags",
                    0,
                    dwType,
                    (CONST BYTE*)&dwFlags,
                    dwSize);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }


    } while (FALSE);

    // Cleanup
    {
        if (hServer)
        {
            MprAdminUserServerDisconnect(hServer);
        }
        if (hkFlags)
        {
            RegCloseKey(hkFlags);
        }
    }

    return dwErr;
}

DWORD
MungePhoneNumber(
    char  *cbphno,
    DWORD dwIndex,
    DWORD *pdwSizeofMungedPhNo,
    char  **ppszMungedPhNo
    )
{
    DWORD dwErr         = ERROR_SUCCESS;
    BOOL  fDigital      = FALSE;
    WCHAR *pwszAddress;
    char  *pszMungedPhNo;
    DWORD dwSizeofMungedPhNo;

    *ppszMungedPhNo = cbphno;
    *pdwSizeofMungedPhNo = strlen(cbphno);

    do
    {
        if(     (NULL == cbphno)
            ||  ('\0' == cbphno[0])
            ||  ('\0' == cbphno[1]))
        {
            break;
        }

        //
        // find out if the cbphno is digital or analog
        //
        if(     (   ('D' == cbphno[0])
                ||  ('d' == cbphno[0]))
            &&  (':' == cbphno[1]))
        {
            fDigital = TRUE;
        }

        if(fDigital)
        {
            if(0 == gblDDMConfigInfo.cDigitalIPAddresses)
            {
                break;
            }

            dwIndex = (dwIndex % gblDDMConfigInfo.cDigitalIPAddresses);
            pwszAddress = gblDDMConfigInfo.apDigitalIPAddresses[dwIndex];
        }
        else
        {
            if(0 == gblDDMConfigInfo.cAnalogIPAddresses)
            {
                break;
            }

            dwIndex = (dwIndex % gblDDMConfigInfo.cAnalogIPAddresses);
            pwszAddress = gblDDMConfigInfo.apAnalogIPAddresses[dwIndex];
        }

        dwSizeofMungedPhNo = strlen(cbphno)
                             + wcslen(pwszAddress)
                             + 2;  // +2 is for a space and terminating NULL;

        pszMungedPhNo = LocalAlloc(
                                LPTR,
                                dwSizeofMungedPhNo);

        if(NULL == pszMungedPhNo)
        {
            dwErr = GetLastError();
            break;
        }

        sprintf(pszMungedPhNo, "%ws %s", pwszAddress, cbphno);

        *ppszMungedPhNo = pszMungedPhNo;
        *pdwSizeofMungedPhNo = dwSizeofMungedPhNo;

    } while (FALSE);

    return dwErr;
}

WCHAR *
GetIpAddress(DWORD dwIpAddress)
{
    struct in_addr ipaddr;
    CHAR    *pszaddr;
    WCHAR   *pwszaddr = NULL;

    ipaddr.s_addr = dwIpAddress;
    
    pszaddr = inet_ntoa(ipaddr);

    if(NULL != pszaddr)
    {
        DWORD cb;
        
        cb = MultiByteToWideChar(
                    CP_ACP, 0, pszaddr, -1, NULL, 0);
                    
        pwszaddr = LocalAlloc(LPTR, cb * sizeof(WCHAR));
        
        if (pwszaddr == NULL) 
        {
            return NULL;
        }

        cb = MultiByteToWideChar(
                    CP_ACP, 0, pszaddr, -1, pwszaddr, cb);
                    
        if (!cb) 
        {
            LocalFree(pwszaddr);
            return NULL;
        }
    }

    return pwszaddr;
}

//**
//
// Call:        RemoveQuarantineOnConnection
//
// Returns:     ERROR_SUCCESS if function succeeded.
//
// Description: Will remove any quarantine filters if
// they had been plumbed and will plumb regular filters
// if available. Then it will queue a workitem to ppp's
// worker thread to give it a chance to remove quarantine-
// session-timer. NOTE: gblDeviceTable's lock should be
// held before calling this function.
//

DWORD
RemoveQuarantineOnConnection(CONNECTION_OBJECT *pConnObj)
{
    DWORD dwErr = ERROR_SUCCESS;
    ROUTER_INTERFACE_OBJECT *pIfObject;
    BOOL fLocked = FALSE;
    PRTR_INFO_BLOCK_HEADER pClientInterface = NULL;

    //
    // Do the work here to remove the quarantine filters
    // and to add the actual filters. Then delete the 
    // filters maintained in the connection object.
    //
    if(NULL != pConnObj->pQuarantineFilter)
    {
        DWORD dwIndex;
        DIM_ROUTER_INTERFACE *pDdmRouterIf = NULL;
        DWORD dwTransportIndex;
        DWORD dwInfoSize;
        PRTR_INFO_BLOCK_HEADER pFilter;
        DWORD i;
        PRTR_INFO_BLOCK_HEADER pTempClientInterface;

        EnterCriticalSection(&gblpInterfaceTable->CriticalSection);
        
        fLocked = TRUE;


        dwTransportIndex = GetTransportIndex(PID_IP);

        if((DWORD) -1 == dwTransportIndex)
        {
            dwErr = ERROR_NO_SUCH_INTERFACE;
            goto done;
        }
        
        pIfObject = IfObjectGetPointer(pConnObj->hDIMInterface);

        if(NULL == pIfObject)
        {
            dwErr = ERROR_NO_SUCH_INTERFACE;
            goto done;
        }

        //
        // Now run through the quarantine filters and remove them from
        // the blob.
        //
        pClientInterface = (PRTR_INFO_BLOCK_HEADER) 
                                pConnObj->pQuarantineFilter;

        pFilter = (PRTR_INFO_BLOCK_HEADER) pConnObj->pFilter;
        
        for(i = 0; i < pClientInterface->TocEntriesCount; i++)
        {
            //
            // Set the QuarantineFilters size to 0 only if its
            // not present in the regular filters because then
            // we want to delete the filter. Otherwisewe only
            // change the filter.
            //
            if(     (NULL == pFilter)
                ||  (!MprInfoBlockExists(pFilter,
                     pClientInterface->TocEntry[i].InfoType)))
            {                                        
                pClientInterface->TocEntry[i].InfoSize = 0;
            }
        }

        if(NULL != pFilter)
        {
            //
            // Now run through the regular filters and add them
            //
            for(i = 0; i < pFilter->TocEntriesCount; i++)
            {
                //
                // Remove the block if its present note we would not
                // have zero'd out the size of the filter is present
                // in the pFilter.
                // 
                dwErr = MprInfoBlockRemove(pClientInterface,
                                   pFilter->TocEntry[i].InfoType,
                                   &pTempClientInterface);

                if(NO_ERROR == dwErr)
                {
                    MprInfoDelete(pClientInterface);
                    pClientInterface = pTempClientInterface;
                }
                
                dwErr = MprInfoBlockAdd(
                        pClientInterface,
                        pFilter->TocEntry[i].InfoType,
                        pFilter->TocEntry[i].InfoSize,
                        pFilter->TocEntry[i].Count,
                        GetInfoFromTocEntry(pFilter, &pFilter->TocEntry[i]),
                        &pTempClientInterface);

                if(dwErr != ERROR_SUCCESS)
                {   
                    goto done;
                }

                MprInfoDelete(pClientInterface);
                pClientInterface = pTempClientInterface;
                pTempClientInterface = NULL;
            }
        }
        
        //
        // Now set the modified info on the interface
        //
        dwErr = 
            gblRouterManagers[dwTransportIndex].DdmRouterIf.SetInterfaceInfo(
                        pIfObject->Transport[dwTransportIndex].hInterface,
                        pClientInterface);

        if(dwErr != ERROR_SUCCESS)
        {
            goto done;
        }
    }

    if(!(pConnObj->fFlags & CONN_OBJ_QUARANTINE_PRESENT))
    {
        dwErr = ERROR_NOT_FOUND;
        goto done;
    }
    
done:

    //
    // Queue a message to ppp to remove quarantine if we have
    // a valid connection.
    //
    if(NULL != pConnObj)
    {
        //
        // Send message to ppp to remove the session timer
        // if any. The following function will just queue
        // a work item to ppp's thread and return.
        //
        (VOID) PppDdmRemoveQuarantine(pConnObj->hConnection);

        pConnObj->fFlags &= (~CONN_OBJ_QUARANTINE_PRESENT);
    }
        
    if(NULL != pClientInterface)
    {
        MprInfoDelete(pClientInterface);
    }

    if(NULL != pConnObj->pQuarantineFilter)
    {
        pConnObj->pQuarantineFilter = NULL;
    }

    if(NULL != pConnObj->pFilter)
    {
        MprInfoDelete(pConnObj->pFilter);
        pConnObj->pFilter = NULL;
    }

    if(fLocked)
    {
        LeaveCriticalSection(&gblpInterfaceTable->CriticalSection);
    }

    return dwErr;
}




#ifdef MEM_LEAK_CHECK
//**
//
// Call:        DebugAlloc
//
// Returns:     return from HeapAlloc
//
// Description: Will use the memory table to store the pointer returned by
//              LocalAlloc
//
LPVOID
DebugAlloc(
    IN DWORD Flags,
    IN DWORD dwSize
)
{
    DWORD Index;
    LPBYTE pMem = (LPBYTE)HeapAlloc( gblDDMConfigInfo.hHeap,
                                     HEAP_ZERO_MEMORY,dwSize+8);

    if ( pMem == NULL )
        return( pMem );

    for( Index=0; Index < DDM_MEM_TABLE_SIZE; Index++ )
    {
        if ( DdmMemTable[Index] == NULL )
        {
            DdmMemTable[Index] = pMem;
            break;
        }
    }


    *((LPDWORD)pMem) = dwSize;

    pMem += 4;

    //
    // Our signature
    //

    *(pMem+dwSize)   = 0x0F;
    *(pMem+dwSize+1) = 0x0E;
    *(pMem+dwSize+2) = 0x0A;
    *(pMem+dwSize+3) = 0x0B;

    RTASSERT( Index != DDM_MEM_TABLE_SIZE );

    return( (LPVOID)pMem );
}

//**
//
// Call:        DebugFree
//
// Returns:     return from HeapFree
//
// Description: Will remove the pointer from the memory table before freeing
//              the memory block
//
BOOL
DebugFree(
    IN LPVOID pMem
)
{
    DWORD Index;

    pMem = ((LPBYTE)pMem) - 4;

    for( Index=0; Index < DDM_MEM_TABLE_SIZE; Index++ )
    {
        if ( DdmMemTable[Index] == pMem )
        {
            DdmMemTable[Index] = NULL;
            break;
        }
    }

    RTASSERT( Index != DDM_MEM_TABLE_SIZE );

    return( HeapFree( gblDDMConfigInfo.hHeap, 0, pMem ) );
}

//**
//
// Call:        DebugReAlloc
//
// Returns:     return from HeapReAlloc
//
// Description: Will change the value of the realloced pointer.
//
LPVOID
DebugReAlloc( PVOID pMem, DWORD dwSize )
{
    DWORD Index;

    if ( pMem == NULL )
    {
        RTASSERT(FALSE);
    }

    for( Index=0; Index < DDM_MEM_TABLE_SIZE; Index++ )
    {
        if ( DdmMemTable[Index] == pMem )
        {
            DdmMemTable[Index] = HeapReAlloc( gblDDMConfigInfo.hHeap,
                                              HEAP_ZERO_MEMORY,
                                              pMem, dwSize+8 );

            pMem = DdmMemTable[Index];

            *((LPDWORD)pMem) = dwSize;

            ((LPBYTE)pMem) += 4;

            //
            // Our signature
            //

            *(((LPBYTE)pMem)+dwSize)   = 0x0F;
            *(((LPBYTE)pMem)+dwSize+1) = 0x0E;
            *(((LPBYTE)pMem)+dwSize+2) = 0x0A;
            *(((LPBYTE)pMem)+dwSize+3) = 0x0B;

            break;
        }
    }

    RTASSERT( Index != DDM_MEM_TABLE_SIZE );

    return( (LPVOID)pMem );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\util.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    util.h
//
// Description: Prototypes of various DDM utility functions.
//
// History:     May 11,1995	    NarenG		Created original version.
//

#define GET_USHORT(DstPtr, SrcPtr)               \
    *(unsigned short *)(DstPtr) =               \
        ((*((unsigned char *)(SrcPtr)+1)) +     \
         (*((unsigned char *)(SrcPtr)+0) << 8))

DWORD
GetRasiConnection0Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_0      pRasConnection0
);

DWORD
GetRasiConnection1Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_1      pRasConnection1
);

DWORD
GetRasiConnection2Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRASI_CONNECTION_2      pRasConnection2
);

DWORD
GetRasConnection0Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRAS_CONNECTION_0       pRasConnection0
);

DWORD
GetRasConnection1Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRAS_CONNECTION_1       pRasConnection1
);

DWORD
GetRasConnection2Data(
    IN  PCONNECTION_OBJECT      pConnObj,
    OUT PRAS_CONNECTION_2       pRasConnection2
);

DWORD
GetRasiPort0Data(
    IN  PDEVICE_OBJECT          pDevObj,
    OUT PRASI_PORT_0            pRasPort0
);

DWORD
GetRasiPort1Data(
    IN  PDEVICE_OBJECT          pDevObj,
    OUT PRASI_PORT_1            pRasPort1
);

DWORD
GetRasPort0Data(
    IN  PDEVICE_OBJECT          pDevObj,
    OUT PRAS_PORT_0             pRasPort0
);

DWORD
GetRasPort1Data(
    IN  PDEVICE_OBJECT          pDevObj,
    OUT PRAS_PORT_1             pRasPort1
);

DWORD
LoadStrings(
    VOID
);

DWORD
GetRouterPhoneBook(
    VOID
); 

DWORD
MapAuthCodeToLogId(
    IN WORD Code
);

BOOL
IsPortOwned(
    IN PDEVICE_OBJECT pDeviceObj
);

VOID
GetLoggingInfo(
    IN PDEVICE_OBJECT pDeviceObj,
    OUT PDWORD BaudRate,
    OUT PDWORD BytesSent,
    OUT PDWORD BytesRecv,
    OUT RASMAN_DISCONNECT_REASON *Reason,
    OUT SYSTEMTIME *Time
);

DWORD
GetLineSpeed(
    IN HPORT hPort
);

VOID
LogConnectionEvent(
    IN PCONNECTION_OBJECT   pConnObj,
    IN PDEVICE_OBJECT       pDeviceObj
);

DWORD
GetTransportIndex(
    IN DWORD dwProtocolId
);

VOID
DDMCleanUp(
    VOID
);

BOOL
AcceptNewConnection( 
    IN DEVICE_OBJECT *      pDeviceObj,
    IN CONNECTION_OBJECT *  pConnObj
);

VOID
ConnectionHangupNotification(
    IN CONNECTION_OBJECT *  pConnObj
);

BOOL
AcceptNewLink( 
    IN DEVICE_OBJECT *      pDeviceObj, 
    IN CONNECTION_OBJECT *  pConnObj
);

VOID
ConvertStringToIpAddress(
    IN  WCHAR * pwchIpAddress,
    OUT DWORD * lpdwIpAddress
);

VOID
ConvertStringToIpxAddress(
    IN  WCHAR * pwchIpAddress,
    OUT BYTE *  bIpxAddress
);

DWORD
GetActiveTimeInSeconds( 
    IN ULARGE_INTEGER * pqwActiveTime
);

BOOL
DDMRecognizeFrame(
    IN  PVOID    pvFrameBuf,
    IN  WORD     wFrameLen, 
    OUT DWORD   *pProtocol  
);

DWORD
GetNextAccountingSessionId(
    VOID
);

DWORD
GetLocalNASIpAddress(
    VOID
);

DWORD
MungePhoneNumber(
    char  *cbphno,
    DWORD dwIndex,
    DWORD *pdwSizeofMungedPhNo,
    char  **ppszMungedPhNo
);

WCHAR *
GetIpAddress(DWORD dwIpAddress);

VOID
LogUnreachabilityEvent(
    IN DWORD    dwReason,
    IN LPWSTR   lpwsInterfaceName
);

DWORD
ModifyDefPolicyToForceEncryption(
    IN BOOL bStrong
);

DWORD
RemoveQuarantineOnConnection(
    IN CONNECTION_OBJECT *pConnObj
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\arapif.h ===
/********************************************************************/
/**               Copyright(c) 1996 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    arapif.h
//
// Description: Contains structures and definitions for components that
//              interface directly or indirectly with the Arap module
//              These componenets are Arap and DDM
//
// History:     Sep 9, 1996    Shirish Koti		Created original version.
//
//***

#ifndef _ARAPIF_
#define _ARAPIF_

//#include <ras.h>
//#include <mprapi.h>


typedef struct _ARAPCONFIGINFO
{
    DWORD   dwNumPorts;         // total number of ports configured
    PVOID   FnMsgDispatch;      // function that Arap should use to send msgs to DDM
    DWORD   NASIpAddress;       // ipaddress of the system
    PVOID   FnAuthProvider;     // function that Arap should use to call AuthProvider
    PVOID   FnAuthFreeAttrib;
    PVOID   FnAcctStartAccounting;
    PVOID   FnAcctInterimAccounting;
    PVOID   FnAcctStopAccounting;
    PVOID   FnAcctFreeAttrib;
    DWORD   dwAuthRetries;      // retries for Authentication

} ARAPCONFIGINFO;

//
// Authentication info sent to DDM by Arap
//
typedef struct _ARAPDDM_AUTH_RESULT
{
    WCHAR    wchUserName[ UNLEN + 1 ];
    WCHAR    wchLogonDomain[ DNLEN + 1 ];
} ARAPDDM_AUTH_RESULT;

//
// Callback info sent to DDM by Arap
//
typedef struct _ARAPDDM_CALLBACK_REQUEST
{
    BOOL  fUseCallbackDelay;
    DWORD dwCallbackDelay;
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
} ARAPDDM_CALLBACK_REQUEST;


//
// ARAP error notification
//
typedef struct _ARAPDDM_DISCONNECT
{
    DWORD dwError;
    WCHAR  wchUserName[ UNLEN + 1 ];
    WCHAR  wchLogonDomain[ DNLEN + 1 ];
} ARAPDDM_DISCONNECT;


typedef struct _ARAPDDM_DONE
{
    DWORD   NetAddress;
    DWORD   SessTimeOut;
} ARAPDDM_DONE;

//
// Message used for Arap/DDM notification
//
typedef struct _ARAP_MESSAGE
{
    struct _ARAP_MESSAGE * pNext;
    DWORD   dwError;
    DWORD   dwMsgId;
    HPORT   hPort;

    union
    {
        ARAPDDM_AUTH_RESULT         AuthResult;        // dwMsgId = ARAPDDMMSG_Authenticated

        ARAPDDM_CALLBACK_REQUEST    CallbackRequest;   // dwMsgId = ARAPDDMMSG_CallbackRequest

        ARAPDDM_DONE                Done;              // dwMsgId = ARAPDDMMSG_Done

        ARAPDDM_DISCONNECT          FailureInfo;       // dwMsgId = ARAPDDMMSG_Failure

    } ExtraInfo;

} ARAP_MESSAGE;


//
// ARAP_MESSAGE dwMsgId codes.
//
typedef enum _ARAP_MSG_ID
{
    ARAPDDMMSG_Started,             // ARAP engine has started (response to ArapStartup)
    ARAPDDMMSG_Authenticated,       // Client has been authenticated.
    ARAPDDMMSG_CallbackRequest,     // Callback client now.
    ARAPDDMMSG_Done,                // ARAP negotiated successfully and connection is up
    ARAPDDMMSG_Failure,             // Client has been authenticated.
    ARAPDDMMSG_Disconnected,        // Client has been authenticated.
    ARAPDDMMSG_Inactive,            // Client is inactive
    ARAPDDMMSG_Stopped,             // ARAP engine has stopped (response to ArapShutdown)

} ARAP_MSG_ID;

typedef DWORD (* ARAPPROC1)(ARAP_MESSAGE  *pArapMsg);

//
// prototypes for Arap functions
//

DWORD
ArapDDMLoadModule(
    IN VOID
);

VOID
ArapEventHandler(
    IN VOID
);

VOID
ArapSetModemParms(
    IN PVOID        pDevObjPtr,
    IN BOOLEAN      TurnItOff
);


//
// exports from rasarap.lib
//

DWORD
ArapStartup(
    IN  ARAPCONFIGINFO  *pArapConfig
);


DWORD
ArapAcceptConnection(
    IN  HPORT   hPort,
    IN  HANDLE  hConnection,
    IN  PCHAR   Frame,
    IN  DWORD   FrameLen
);


DWORD
ArapDisconnect(
    IN  HPORT   hPort
);


DWORD
ArapCallBackDone(
    IN  HPORT   hPort
);


DWORD
ArapSendUserMsg(
    IN  HPORT   hPort,
    IN  PCHAR   MsgBuf,
    IN  DWORD   MsgBufLen
);


DWORD
ArapForcePwdChange(
    IN  HPORT   hPort,
    IN  DWORD   Reason
);


DWORD
ArapShutdown(
    IN  VOID
);


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ddm\timer.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    timer.h
//
// Description: Prototypes of procedures in timer.c
//
// History:     May 11,1995	    NarenG		Created original version.
//

//
// Timeout function handler type
//

typedef VOID (* TIMEOUT_HANDLER)(LPVOID lpObject);


DWORD
TimerQInitialize(
    VOID 
);

VOID
TimerQDelete(
    VOID 
);

DWORD
TimerQThread(
    IN LPVOID arg
);

VOID
TimerQTick(
    VOID
);

DWORD
TimerQInsert(
    IN HANDLE           hObject,
    IN DWORD            dwTimeout,
    IN TIMEOUT_HANDLER  pfuncTimeoutHandler
);

VOID
TimerQRemove(
    IN HANDLE           hObject,
    IN TIMEOUT_HANDLER  pfuncTimeoutHandler
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\clauth.h ===
/*****************************************************************************/
/**                      Microsoft LAN Manager                              **/
/**                Copyright (C) 1992-1993 Microsoft Corp.                  **/
/*****************************************************************************/

//***
//    File Name:
//       CLAUTH.H
//
//    Function:
//        Contains header information for Win32 Client and Client
//        Authentication Transport module
//
//    History:
//        05/18/92 - Michael Salamone (MikeSa) - Original Version 1.0
//***

#ifndef _CLAUTH_
#define _CLAUTH_


/* This flag enables the NT31/WFW311 RAS compression support re-added for the
** NT-PPC release.
*/
#define RASCOMPRESSION 1


#include <lmcons.h>


#ifndef MAX_PHONE_NUMBER_LEN
#define MAX_PHONE_NUMBER_LEN    48
#endif

#ifndef MAX_INIT_NAMES
#define MAX_INIT_NAMES          16
#endif


//
// Used for establishing session with RAS netbios server
//
#define AUTH_NETBIOS_NAME    "DIALIN_GATEWAY  "


//
// Used for passing NetBIOS projection info to Supervisor
//
typedef struct _NAME_STRUCT 
{
    BYTE NBName[NETBIOS_NAME_LEN]; // NetBIOS name
    WORD wType;                    // GROUP, UNIQUE, COMPUTER
} NAME_STRUCT, *PNAME_STRUCT;


//
// Configuration info supplied by UI to auth transport
//
#define INVALID_NET_HANDLE    0xFFFFFFFFL

typedef struct _AUTH_CONFIGURATION_INFO
{
    RAS_PROTOCOLTYPE Protocol;
    DWORD NetHandle;
    WORD CallbackDelay;
    BOOL fUseCallbackDelay;
    BOOL fUseSoftwareCompression;
    BOOL fForceDataEncryption;
    BOOL fProjectIp;
    BOOL fProjectIpx;
    BOOL fProjectNbf;
} AUTH_CONFIGURATION_INFO, *PAUTH_CONFIGURATION_INFO;


typedef struct _AUTH_SUCCESS_INFO
{
    BOOL fPppCapable;
} AUTH_SUCCESS_INFO, *PAUTH_SUCCESS_INFO;


//
// Error codes for AUTH_FAILURE_INFO are found in raserror.h
//

typedef struct _AUTH_FAILURE_INFO
{
    DWORD Result;
    DWORD ExtraInfo;    // Only valid if non-zero
} AUTH_FAILURE_INFO, *PAUTH_FAILURE_INFO;


//
// Projection result info must be copied into this structure.
//

typedef struct _NETBIOS_PROJECTION_RESULT
{
    DWORD Result;
    char achName[NETBIOS_NAME_LEN + 1];   // this will be NULL-terminated
} NETBIOS_PROJECTION_RESULT, *PNETBIOS_PROJECTION_RESULT;


typedef struct _AUTH_PROJECTION_RESULT
{
    BOOL IpProjected;
    BOOL IpxProjected;
    BOOL NbProjected;
    NETBIOS_PROJECTION_RESULT NbInfo;
} AUTH_PROJECTION_RESULT, *PAUTH_PROJECTION_RESULT;


//
// These are possible values for wInfoType field in AUTH_RESULT struct below.
//
#define AUTH_DONE                       1
#define AUTH_RETRY_NOTIFY               2
#define AUTH_FAILURE                    3
#define AUTH_PROJ_RESULT                4
#define AUTH_REQUEST_CALLBACK_DATA      5
#define AUTH_CALLBACK_NOTIFY            6
#define AUTH_CHANGE_PASSWORD_NOTIFY     7
#define AUTH_PROJECTING_NOTIFY          8
#define AUTH_LINK_SPEED_NOTIFY          9
#define AUTH_STOP_COMPLETED            10


//
// This is structure returned by AuthGetInfo API
//
typedef struct _AUTH_CLIENT_INFO
{
    WORD wInfoType;
    union
    {
        AUTH_SUCCESS_INFO DoneInfo;
        AUTH_PROJECTION_RESULT ProjResult;
        AUTH_FAILURE_INFO FailureInfo;
    };
} AUTH_CLIENT_INFO, *PAUTH_CLIENT_INFO;


//
// Interface exported to Client UI follows
//

//
// Used by Client UI to supply Auth Xport w/callback number
//
DWORD AuthCallback(
    IN HPORT,
    IN PCHAR      // pszCallbackNumber
    );


DWORD AuthChangePassword(
    IN HPORT,
    IN PCHAR,     // pszUserName
    IN PCHAR,     // pszPassword
    IN PCHAR      // pszNewPassword
    );


//
// Called by UI to tell authentication it has completed processing the
// last authentication event.  Called after AUTH_PROJECTION_RESULT and
// AUTH_CALLBACK_NOTIFY authentication events.
//
DWORD AuthContinue(
    IN HPORT
    );


//
// Used by Client UI to get completion info from Auth Xport module
//
DWORD AuthGetInfo(
    IN HPORT,
    OUT PAUTH_CLIENT_INFO
    );


//
// To allow UI to provide a new username and/or password for authenticating
// on.  Called in response to AUTH_RETRY_NOTIFY event (indicating previous
// username/password combination failed authentication).
//
DWORD AuthRetry(
    IN HPORT,
    IN PCHAR,    // Username
    IN PCHAR,    // Password
    IN PCHAR     // Domain
    );


//
// To kick off an Authentication thread for the given port.  Used to
// 1) initiate authentication; 2) retry authentication when invalid
// account info supplied; 3) resume authentication after callback..
//
DWORD AuthStart(
    IN HPORT,
    IN PCHAR OPTIONAL,    // Username
    IN PCHAR OPTIONAL,    // Password
    IN PCHAR,             // Domain
    IN PAUTH_CONFIGURATION_INFO,
    IN HANDLE             // Event Handle
    );


//
// Used by Client UI to tell Auth Xport module to halt authentication
// processing on the given port.
//
DWORD AuthStop(
    IN HPORT hPort
    );


//
// Returned by AuthStop
//
#define AUTH_STOP_PENDING          1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\eaptypeid.h ===
/*

Copyright (c) 1999, Microsoft Corporation, all rights reserved

File:
    eaptypeid.h

Description:
    This header defines the type IDs of various EAPs implemented in rasppp.dll

History:
    6 Jan 1999: Vijay Baliga created original version.

*/

#ifndef _EAPTYPEID_H_
#define _EAPTYPEID_H_

//
// Various EAP type IDs
//

#define PPP_EAP_CHAP            4       // MD5-Challenge
#define PPP_EAP_TLS             13      // Smartcard or other certificate (TLS)
#define PPP_EAP_PEAP            25      // PEAP
#define PPP_EAP_MSCHAPv2        26      // EAP Mschapv2

#endif // #ifndef _EAPTYPEID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\ddmif.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	ddmif.h
//
// Description: This file contains the definitions for
//		        the data structures used in the message communication with DDM.
//
// Author:	    Stefan Solomon (stefans)    June 24, 1992.
//
// Revision History:
//
//***

#ifndef _DDMIF_
#define _DDMIF_

#include <ras.h>
#include <dim.h>
#include <rasman.h>
#include <srvauth.h>
#include <sechost.h>
#include <nbfcpif.h>
#include <nbgtwyif.h>
#include <rasppp.h>
#include <dimif.h>

typedef struct _DIM_INFO
{
    IN  ROUTER_INTERFACE_TABLE *    pInterfaceTable;
    IN  ROUTER_MANAGER_OBJECT *     pRouterManagers;
    IN  DWORD                       dwNumRouterManagers;
    IN  SERVICE_STATUS*             pServiceStatus;
    IN  HANDLE *                    phEventDDMServiceState;
    IN  HANDLE *                    phEventDDMTerminated;
    IN  LPDWORD                     lpdwNumThreadsRunning;
    IN  DWORD                       dwTraceId;
    IN  HANDLE                      hLogEvents;
    IN  LPVOID                      lpfnIfObjectAllocateAndInit;
    IN  LPVOID                      lpfnIfObjectGetPointerByName;
    IN  LPVOID                      lpfnIfObjectGetPointer;
    IN  LPVOID                      lpfnIfObjectRemove;
    IN  LPVOID                      lpfnIfObjectInsertInTable;
    IN  LPVOID                      lpfnIfObjectWANDeviceInstalled;
    IN  LPVOID                      lpfnRouterIdentityObjectUpdate;
    OUT BOOL                        fWANDeviceInstalled;

} DIM_INFO, *PDIM_INFO;

//
// Called be DIM to initialize DDM
//

DWORD
DDMServiceInitialize(
    IN DIM_INFO * pDimInfo
);

//
// Message Queues IDs
//

typedef enum _MESSAGEQ_ID
{
    MESSAGEQ_ID_SECURITY,       //queue of messages sent by 3rd party sec.dll
    MESSAGEQ_ID_PPP,            //queue of messages sent by PPP engine.

} MESSAGEQ_ID, *PMESSAGEQ_ID;

#define MAX_MSG_QUEUES          3


//
//*** Common Message Type ***
//

typedef union _MESSAGE
{
    AUTH_MESSAGE        authmsg;
    NBG_MESSAGE         nbgmsg;
    NBFCP_MESSAGE       nbfcpmsg;
    SECURITY_MESSAGE    securitymsg;
    PPP_MESSAGE         PppMsg;

} MESSAGE, *PMESSAGE;

//
// Message Functions
//

VOID
SendPppMessageToDDM(
    IN PPP_MESSAGE *  pPppMsg
);

DWORD
ServerSendMessage(
    IN MESSAGEQ_ID  MsgQId,
    IN BYTE*        pMessage
);

BOOL
ServerReceiveMessage(
    IN MESSAGEQ_ID  MsgQId,
    IN BYTE*        pMessage
);

typedef DWORD (* PMSGFUNCTION)(DWORD, BYTE *);


#endif   // _DDMIF_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\device.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: device.h
//
//  Revision History:
//
//  Aug 11, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains function prototypes and typedefs
//               used by the interface between RAS Manager and the
//               device DLLs, such as RASMXS.DLL.  This header file
//               will be used by RASMAN.
//
//****************************************************************************


#ifndef _RASDEVICEDLL_
#define _RASDEVICEDLL_


//*  RASMXS API Prototypes  **************************************************
//
//   Apps should define RASMXS_STATIC_LINK to get the appropriate function
//   prototypes for linking statically with the RASMXS DLL.
//
//   Apps should define RASMXS_DYNAMIC_LINK to get the appropriate function
//   typedefs for linking dynamically with the RASMXS DLL.
//

#ifdef RASMXS_STATIC_LINK

DWORD APIENTRY DeviceEnum(char  *pszDeviceType,
                          DWORD  *pcEntries,
                          BYTE  *pBuffer,
                          DWORD  *pdwSize);


DWORD APIENTRY DeviceGetInfo(HANDLE  hIOPort,
                             char    *pszDeviceType,
                             char    *pszDeviceName,
                             BYTE    *pInfo,
                             DWORD   *pdwSize);


DWORD APIENTRY DeviceSetInfo(HANDLE      hIOPort,
                             char        *pszDeviceType,
                             char        *pszDeviceName,
                             DEVICEINFO  *pInfo);


DWORD APIENTRY DeviceConnect(HANDLE  hIOPort,
                             char    *pszDeviceType,
                             char    *pszDeviceName,
                             HANDLE  hNotifier);


DWORD APIENTRY DeviceListen(HANDLE  hIOPort,
                            char    *pszDeviceType,
                            char    *pszDeviceName,
                            HANDLE  hNotifier);


 VOID APIENTRY DeviceDone(HANDLE  hIOPort);


DWORD APIENTRY DeviceWork(HANDLE  hIOPort,
                          HANDLE  hNotifier);

#endif // RASMXS_STATIC_LINK




#ifdef RASMXS_DYNAMIC_LINK

typedef DWORD (APIENTRY * DeviceEnum_t)(char*, DWORD*, BYTE*, DWORD*);

typedef DWORD (APIENTRY * DeviceGetInfo_t)(HANDLE, char*, char*, BYTE*, DWORD*);

typedef DWORD (APIENTRY * DeviceSetInfo_t)(HANDLE, char*, char*,
                                           RASMAN_DEVICEINFO*);

typedef DWORD (APIENTRY * DeviceConnect_t)(HANDLE, char*, char*);

typedef DWORD (APIENTRY * DeviceListen_t)(HANDLE, char*, char*);

typedef DWORD (APIENTRY * DeviceDone_t)(HANDLE);

typedef DWORD (APIENTRY * DeviceWork_t)(HANDLE);

// OPTIONAL

typedef DWORD (APIENTRY * DeviceSetDevConfig_t)(HANDLE, PBYTE, DWORD);

typedef DWORD (APIENTRY * DeviceGetDevConfig_t)(char *, PBYTE, DWORD*);

#endif // RASMXS_DYNAMIC_LINK




#endif // _RASDEVICEDLL_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Imports.h

Abstract:

    This file allows us to include standard system header files in the
    regrpc.idl file.  The regrpc.idl file imports a file called
    imports.idl.  This allows the regrpc.idl file to use the types defined
    in these header files.  It also causes the following line to be added
    in the MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    David J. Gilman (davegi) 28-Jan-1992

--*/

#include <windef.h>
#include <ras.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\ddmparms.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	ddmparms.h
//
// Description: This module contains the definitions for loading
//		        DDM parameters from the registry. This lives in the inc dir.
//              because it is also used by RASNBFCP
//
// Author:	    Stefan Solomon (stefans)    May 18, 1992.
//
// Revision     History:
//
//***

#ifndef _DDMPARMS_
#define _DDMPARMS_

//
//  Names of DDM registry keys
//

#define DDM_PARAMETERS_KEY_PATH TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters")

#define DDM_ACCOUNTING_KEY_PATH TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Accounting")

#define DDM_AUTHENTICATION_KEY_PATH TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication")

#define DDM_SEC_KEY_PATH        TEXT("Software\\Microsoft\\RAS\\SecurityHost")

#define DDM_PARAMETERS_NBF_KEY_PATH TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Nbf")

#define DDM_PROTOCOLS_KEY_PATH  TEXT("Software\\Microsoft\\RAS\\Protocols")

#define DDM_ADMIN_KEY_PATH      TEXT("Software\\Microsoft\\RAS\\AdminDll")

#define RAS_KEYPATH_ACCOUNTING      \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Accounting")

//
//  Names of DDM registry parameters
//

#define DDM_VALNAME_AUTHENTICATERETRIES     TEXT("AuthenticateRetries")
#define DDM_VALNAME_AUTHENTICATETIME        TEXT("AuthenticateTime")
#define DDM_VALNAME_CALLBACKTIME            TEXT("CallbackTime")
#define DDM_VALNAME_ALLOWNETWORKACCESS      TEXT("AllowNetworkAccess")
#define DDM_VALNAME_AUTODISCONNECTTIME      TEXT("Autodisconnect")
#define DDM_VALNAME_CLIENTSPERPROC          TEXT("ClientsPerProcess")
#define DDM_VALNAME_SECURITYTIME            TEXT("SecurityHostTime")
#define DDM_VALNAME_NETBEUIALLOWED          TEXT("fNetBeuiAllowed")
#define DDM_VALNAME_IPALLOWED               TEXT("fTcpIpAllowed")
#define DDM_VALNAME_IPXALLOWED              TEXT("fIpxAllowed")
#define DDM_VALNAME_DLLPATH                 TEXT("DllPath")
#define DDM_VALNAME_LOGGING_LEVEL           TEXT("LoggingFlags")
#define DDM_VALNAME_NUM_CALLBACK_RETRIES    TEXT("CallbackRetries")
#define DDM_VALNAME_SERVERFLAGS             TEXT("ServerFlags")
#define RAS_VALNAME_ACTIVEPROVIDER          TEXT("ActiveProvider")
#define RAS_VALNAME_ACCTSESSIONID           TEXT("AccountSessionIdStart")

#define DEF_SERVERFLAGS                 PPPCFG_UseSwCompression      |   \
                                        PPPCFG_NegotiateSPAP         |   \
                                        PPPCFG_NegotiateMSCHAP       |   \
                                        PPPCFG_UseLcpExtensions      |   \
                                        PPPCFG_NegotiateMultilink    |   \
                                        PPPCFG_NegotiateBacp         |   \
                                        PPPCFG_NegotiateEAP          |   \
                                        PPPCFG_NegotiatePAP          |   \
                                        PPPCFG_NegotiateMD5CHAP

// Number of callback retries to be made

#define DEF_NUMCALLBACKRETRIES      0
#define MIN_NUMCALLBACKRETRIES      0
#define MAX_NUMCALLBACKRETRIES      0xFFFFFFFF


//  Authentication retries

#define DEF_AUTHENTICATERETRIES 	2
#define MIN_AUTHENTICATERETRIES 	0
#define MAX_AUTHENTICATERETRIES 	10

//  Authentication time

#define DEF_AUTHENTICATETIME		120
#define MIN_AUTHENTICATETIME		20
#define MAX_AUTHENTICATETIME		600

// Audit

#define DEF_ENABLEAUDIT 		1
#define MIN_ENABLEAUDIT 		0
#define MAX_ENABLEAUDIT			1

//  Callback time

#define DEF_CALLBACKTIME		2
#define MIN_CALLBACKTIME		2
#define MAX_CALLBACKTIME		12


//  Autodisconnect time

#define DEF_AUTODISCONNECTTIME          0
#define MIN_AUTODISCONNECTTIME          0
#define MAX_AUTODISCONNECTTIME          0xFFFFFFFF

//  Third party security time

#define DEF_SECURITYTIME                120
#define MIN_SECURITYTIME                20
#define MAX_SECURITYTIME                600


// Clients per process

#define DEF_CLIENTSPERPROC              32
#define MIN_CLIENTSPERPROC              1
#define MAX_CLIENTSPERPROC              64

// Logging level

#define DEF_LOGGINGLEVEL                3
#define MIN_LOGGINGLEVEL                0
#define MAX_LOGGINGLEVEL                3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\interror.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//                     Copyright 1992-93
//
//
//  Revision History:
//
//  Jul  9, 1992   J. Perry Hannah   Created.
//
//
//  Description: Contains internal error codes which are common
//               to the entire RAS project.
//
//****************************************************************************


#ifndef _INTERROR_
#define _INTERROR_



//*  Internal Error Codes  ***************************************************
//
//  The follow is recommended form for component internal header files.
//
//  #define BASE  RAS_INTERNAL_ERROR_BASE + REIB_YOURCOMPONENT
//
//  #define ERROR_NO_CLUE           BASE + 1
//  #define ERROR_NEXT_BAD_THING    BASE + 2
//
//

#define  RAS_INTERNAL_ERROR_BASE  13000           // 0x32C8

#define  RIEB_RASMAN                100
#define  RIEB_MXSDLL                200
#define  RIEB_ASYNCMEDIADLL         300
#define  RIEB_INFFILEAPI            400
#define  RIEB_RASFILE               500
#define  RIEB_RASHUB                600
#define  RIEB_ASYMAC                700
#define  RIEB_SUPERVISOR            800






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\isdn.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//                     Copyright 1992-93
//
//  Filename: isdn.h
//
//  Revision History:
//
//  Feb 28, 1993	Gurdeep Pall Created
//
//
//  Description: This file contains all the device and media DLL interface
//		 information specific to ISDN.
//
//****************************************************************************


#ifndef _ISDNINCLUDE_
#define _ISDNINCLUDE_

#define ISDN_TXT "isdn"

// ISDN Media Parameter
//
#define ISDN_LINETYPE_KEY	"LineType"	// Param type NUMBER
#define ISDN_LINETYPE_VALUE_64DATA	0
#define ISDN_LINETYPE_VALUE_56DATA	1
#define ISDN_LINETYPE_VALUE_56VOICE	2
#define ISDN_LINETYPE_STRING_64DATA	"0"
#define ISDN_LINETYPE_STRING_56DATA	"1"
#define ISDN_LINETYPE_STRING_56VOICE	"2"


#define ISDN_FALLBACK_KEY	"Fallback"	// Param type NUMBER
#define ISDN_FALLBACK_VALUE_ON		1
#define ISDN_FALLBACK_VALUE_OFF 	0
#define ISDN_FALLBACK_STRING_ON		"1"
#define ISDN_FALLBACK_STRING_OFF	"0"



#define ISDN_COMPRESSION_KEY	"EnableCompression" // Param type NUMBER
#define ISDN_COMPRESSION_VALUE_ON	1
#define ISDN_COMPRESSION_VALUE_OFF	0
#define ISDN_COMPRESSION_STRING_ON	"1"
#define ISDN_COMPRESSION_STRING_OFF	"0"


#define ISDN_CHANNEL_AGG_KEY	"ChannelAggregation"// Param type NUMBER


// ISDN Device Parameter
//
#define ISDN_PHONENUMBER_KEY	"PhoneNumber"	// Param type STRING
#define MAX_PHONENUMBER_LEN	255

#define CONNECTBPS_KEY		"ConnectBPS"	// Param type STRING


//  Statistics information and indices.
//
#define NUM_ISDN_STATS		10

#define BYTES_XMITED		0	// Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR 		4	// Isdn Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#endif // _ISDNINCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\media.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//
//  Revision History:
//
//  Jul 22, 1992   J. Perry Hannah   Created
//  Aug 11, 1992   Gurdeep Pall      Added Media data structures
//
//  Description: This file contains function prototypes and structures
//               used by the interface between RAS Manager and the
//               Media DLLs.
//
//****************************************************************************


#ifndef _MEDIADLLHEADER_
#define _MEDIADLLHEADER_



//  General Defines  *********************************************************
//

#define SS_HARDWAREFAILURE  0x00000001
#define SS_LINKDROPPED      0x00000002



//*  Data Structures  ********************************************************
//

#define MAC_NAME_SIZE	32

struct PortMediaInfo {
    CHAR            PMI_Name [MAX_PORT_NAME] ;
    CHAR            PMI_MacBindingName[MAC_NAME_SIZE] ;
    RASMAN_USAGE    PMI_Usage ;
    CHAR            PMI_DeviceType [MAX_DEVICETYPE_NAME] ;
    CHAR	        PMI_DeviceName [MAX_DEVICE_NAME] ;
    DWORD	        PMI_LineDeviceId ;	// Valid for TAPI devices only
    DWORD	        PMI_AddressId ;	    // Valid for TAPI devices only
    DeviceInfo     *PMI_pDeviceInfo;    // valid for non unimodem devices only.
} ;


typedef struct PortMediaInfo PortMediaInfo ;




//*  API References  *********************************************************
//

typedef  DWORD (APIENTRY * PortEnum_t)(BYTE *, DWORD *, DWORD *);

typedef  DWORD (APIENTRY * PortOpen_t)(char *, HANDLE *, HANDLE, ULONG);

typedef  DWORD (APIENTRY * PortClose_t)(HANDLE);

typedef  DWORD (APIENTRY * PortGetInfo_t)(HANDLE, TCHAR *, BYTE *, DWORD *);

typedef  DWORD (APIENTRY * PortSetInfo_t)(HANDLE, RASMAN_PORTINFO *);

typedef  DWORD (APIENTRY * PortTestSignalState_t)(HANDLE, DWORD *);

typedef  DWORD (APIENTRY * PortConnect_t)(HANDLE, BOOL, HANDLE *) ;

typedef  DWORD (APIENTRY * PortDisconnect_t)(HANDLE);

typedef  DWORD (APIENTRY * PortInit_t)(HANDLE);

typedef  DWORD (APIENTRY * PortCompressionSetInfo_t)(HANDLE) ;

typedef  DWORD (APIENTRY * PortSend_t)(HANDLE, BYTE *, DWORD);

typedef  DWORD (APIENTRY * PortReceive_t)(HANDLE, BYTE *, DWORD, DWORD);

typedef  DWORD (APIENTRY * PortGetStatistics_t)(HANDLE, RAS_STATISTICS *);

typedef  DWORD (APIENTRY * PortClearStatistics_t)(HANDLE);

typedef  DWORD (APIENTRY * PortGetPortState_t)(BYTE *, DWORD *);

typedef  DWORD (APIENTRY * PortChangeCallback_t)(HANDLE);

typedef  DWORD (APIENTRY * PortReceiveComplete_t)(HANDLE, DWORD *);

typedef  DWORD (APIENTRY * PortSetFraming_t)(HANDLE, DWORD, DWORD, DWORD, DWORD);

typedef  DWORD (APIENTRY * PortGetIOHandle_t)(HANDLE, HANDLE*);

typedef  DWORD (APIENTRY * PortSetIoCompletionPort_t)(HANDLE);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\nbgparms.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	nbgparms.h
//
// Description: This module contains the definitions for loading
//		        the netbios gateway parameters from the registry. This lives
//              in the inc directory because it is also used by NBFCP
//
// Author:	Stefan Solomon (stefans)    July 15, 1992.
//
// Revision History:
//
//***

#ifndef _NBGPARMS_
#define _NBGPARMS_

#define MAX_NB_NAMES    28

#define NCBQUICKADDNAME     0x75    

//
//  Names of Netbios Gateway registry keys
//

#define RAS_NBG_PARAMETERS_KEY_PATH "System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\Nbf"

//
//  Names of Netbios Gateway registry parameters
//

#define RAS_NBG_VALNAME_AVAILABLELANNETS	    "AvailableLanNets"
#define RAS_NBG_VALNAME_ENABLEBROADCAST 	    "EnableBroadcast"
#define RAS_NBG_VALNAME_MAXDYNMEM		    "MaxDynMem"
#define RAS_NBG_VALNAME_MAXNAMES		    "MaxNames"
#define RAS_NBG_VALNAME_MAXSESSIONS		    "MaxSessions"
#define RAS_NBG_VALNAME_MULTICASTFORWARDRATE	    "MulticastForwardRate"
#define RAS_NBG_VALNAME_SIZWORKBUF		    "SizWorkbuf"
#define RAS_NBG_VALNAME_REMOTELISTEN		    "RemoteListen"
#define RAS_NBG_VALNAME_NAMEUPDATETIME		    "NameUpdateTime"
#define RAS_NBG_VALNAME_MAXDGBUFFEREDPERGROUPNAME   "MaxDgBufferedPerGroupName"
#define RAS_NBG_VALNAME_RCVDGSUBMITTEDPERGROUPNAME  "RcvDgSubmittedPerGroupName"
#define RAS_NBG_VALNAME_DISMCASTWHENSESSTRAFFIC     "DisableMcastFwdWhenSessionTraffic"
#define RAS_NBG_VALNAME_MAXBCASTDGBUFFERED	    "MaxBcastDgBuffered"
#define RAS_NBG_VALNAME_NUMRECVQUERYINDICATIONS     "NumRecvQueryIndications"
#define RAS_NBG_VALNAME_ENABLENBSESSIONSAUDITING    "EnableNetbiosSessionsAuditing"

typedef struct _NB_REG_PARMS
{
    DWORD MaxNames;
    DWORD MaxSessions;
    DWORD SmallBuffSize;
    DWORD MaxDynMem;
    DWORD MulticastForwardRate;
    DWORD RemoteListen;
    DWORD BcastEnabled;
    DWORD NameUpdateTime;
    DWORD MaxDgBufferedPerGn;
    DWORD RcvDgSubmittedPerGn;
    DWORD DisMcastWhenSessTraffic;
    DWORD MaxBcastDgBuffered;
    DWORD NumRecvQryIndications;
    DWORD EnableSessAuditing;
    DWORD MaxLanNets;            // nr of available lan nets
} NB_REG_PARMS, *PNB_REG_PARMS;

//
// Parameter descriptor
//
typedef struct _NB_PARAM_DESCRIPTOR
{
    LPSTR p_namep;
    LPDWORD p_valuep;
    DWORD p_default;
    DWORD p_min;
    DWORD p_max;
} NB_PARAM_DESCRIPTOR, *PNB_PARAM_DESCRIPTOR;


#define DEF_ENABLEBROADCAST		0
#define MIN_ENABLEBROADCAST		0
#define MAX_ENABLEBROADCAST		1

#define DEF_MAXDYNMEM			655350
#define MIN_MAXDYNMEM			131072
#define MAX_MAXDYNMEM			0xFFFFFFFF

#define DEF_MAXNAMES			0xFF
#define MIN_MAXNAMES			1
#define MAX_MAXNAMES			0xFF

#define DEF_MAXSESSIONS			0xFF
#define MIN_MAXSESSIONS 		1
#define MAX_MAXSESSIONS 		0xFF

#define DEF_MULTICASTFORWARDRATE	5
#define MIN_MULTICASTFORWARDRATE	0
#define MAX_MULTICASTFORWARDRATE	0xFFFFFFFF

#define DEF_SIZWORKBUF			4500
#define MIN_SIZWORKBUF			1024
#define MAX_SIZWORKBUF			65536

#define LISTEN_NONE			0
#define LISTEN_MESSAGES 		1
#define LISTEN_ALL			2

#define DEF_REMOTELISTEN		LISTEN_MESSAGES
#define MIN_REMOTELISTEN		LISTEN_NONE
#define MAX_REMOTELISTEN		LISTEN_ALL

#define DEF_NAMEUPDATETIME		120
#define MIN_NAMEUPDATETIME		10
#define MAX_NAMEUPDATETIME		3600

#define DEF_MAXDGBUFFEREDPERGROUPNAME	10
#define MIN_MAXDGBUFFEREDPERGROUPNAME	1
#define MAX_MAXDGBUFFEREDPERGROUPNAME	0xFF

#define DEF_RCVDGSUBMITTEDPERGROUPNAME	3
#define MIN_RCVDGSUBMITTEDPERGROUPNAME	1
#define MAX_RCVDGSUBMITTEDPERGROUPNAME	32

#define DEF_DISMCASTWHENSESSTRAFFIC	1
#define MIN_DISMCASTWHENSESSTRAFFIC	0
#define MAX_DISMCASTWHENSESSTRAFFIC	1

#define DEF_MAXBCASTDGBUFFERED		32
#define MIN_MAXBCASTDGBUFFERED		16
#define MAX_MAXBCASTDGBUFFERED		0xFF

#define DEF_NUMRECVQUERYINDICATIONS     3
#define MIN_NUMRECVQUERYINDICATIONS     1
#define MAX_NUMRECVQUERYINDICATIONS     32

#define DEF_ENABLENBSESSIONSAUDITING	0
#define MIN_ENABLENBSESSIONSAUDITING	0
#define MAX_ENABLENBSESSIONSAUDITING	1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\nbgtwyif.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    nbgtwyif.h
//
// Description: Contains structures and definitions for components that 
//              interface directly or indirectly with the NetBios gateway. 
//              These componenets are NBFCP and DDM
//
// History:     May 11,1995	    NarenG		Created original version.
//
#ifndef _NBGTWYIF_
#define _NBGTWYIF_

#include <nbfcpif.h>


//
// Netbios Gateway -> DDM Message Ids and definitions
//

enum
{
    NBG_PROJECTION_RESULT,  // proj result. If fatal error, gtwy function
			                //  is terminated on this client
    NBG_CLIENT_STOPPED,     // gtwy function on this client has terminated
			                //  following a stop command
    NBG_DISCONNECT_REQUEST, // gtwy function on this client has terminated
			                //  due to an internal exception
    NBG_LAST_ACTIVITY       // to report time of last session activity
};

typedef struct _NBG_MESSAGE
{
    WORD  MsgId;
    HPORT hPort;                // This is really an hConnection. Change this.

    union
    {
        DWORD LastActivity;        // in minutes
        NBFCP_SERVER_CONFIGURATION config_result;
    };

} NBG_MESSAGE;

typedef WORD (* NBGATEWAYPROC)();

extern NBGATEWAYPROC FpNbGatewayStart;
extern NBGATEWAYPROC FpNbGatewayProjectClient;
extern NBGATEWAYPROC FpNbGatewayStartClient;
extern NBGATEWAYPROC FpNbGatewayStopClient;
extern NBGATEWAYPROC FpNbGatewayRemoteListen;
extern NBGATEWAYPROC FpNbGatewayTimer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\pipemsg.h ===
#ifndef _PIPEMSG_
#define _PIPEMSG_

#include <lm.h>
#include <nbgparms.h>
#include <srvauth.h>


#define RASIPCNAME    "\\\\.\\pipe\\RAS_SERVICE_IPC_READ"

typedef enum _PIPE_MESSAGE_ID
{
    START_GATEWAY,
    PROJECT_CLIENT,
    START_CLIENT,
    STOP_CLIENT,
    SWITCH_PORTS,
    TERMINATE
} PIPE_MESSAGE_ID, *PPIPE_MESSAGE_ID;


typedef struct _PIPE_MSG_START_GATEWAY
{
    DWORD MaxClients;
    NB_REG_PARMS RegParms;
    UCHAR LanNet[MAX_LAN_NETS];  // array of lana nums for the lan nets
    HANDLE hLogFile;
} PIPE_MSG_START_GATEWAY, *PPIPE_MSG_START_GATEWAY;


typedef struct _PIPE_MSG_PROJECT_CLIENT
{
    HPORT hPort;
    CHAR PortName[MAX_PORT_NAME];
    NBFCP_SERVER_CONFIGURATION ServerConfig;
} PIPE_MSG_PROJECT_CLIENT, *PPIPE_MSG_PROJECT_CLIENT;


typedef struct _PIPE_MSG_START_CLIENT
{
    HPORT hPort;
    UCHAR lana;
    CHAR UserName[UNLEN + 1];
} PIPE_MSG_START_CLIENT, *PPIPE_MSG_START_CLIENT;


typedef struct _PIPE_MSG_STOP_CLIENT
{
    HPORT hPort;
} PIPE_MSG_STOP_CLIENT, *PPIPE_MSG_STOP_CLIENT;

//
// No info needed for REMOTE_LISTEN and TERMINATE messages
//


typedef struct _PIPE_MESSAGE
{
    PIPE_MESSAGE_ID MsgId;

    union Msg
    {
        PIPE_MSG_START_GATEWAY StartGateway;
        PIPE_MSG_PROJECT_CLIENT ProjectClient;
        PIPE_MSG_START_CLIENT StartClient;
        PIPE_MSG_STOP_CLIENT StopClient;
//      PIPE_MSG_REMOTE_LISTEN RemoteListen;
//      PIPE_MSG_TERMINATE Terminate;
    };
} PIPE_MESSAGE, *PPIPE_MESSAGE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\mxsint.h ===
//***************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: mxsint.h
//
//  Revision History:
//
//  Jun  8, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains defines and enums that are used
//               by RAS components that share things in common with
//               RASMXS DLL.
//
//               Header File  Used by
//               -----------  -------
//               rasmxs.h     UIs and other external applicaions
//               device.h     RASMAN.DLL (shared by all device DLLs)
//               mxsint.h     other internal RAS components
//               raspriv.h    RASMXS.DLL only
//
//****************************************************************************


#ifndef _MXSINT_
#define _MXSINT_


//  General Defines  *********************************************************
//

#define  MAX_CMD_BUF_LEN            256
#define  MAX_RCV_BUF_LEN            256
#define  MAX_CMDTYPE_SUFFIX_LEN     8

#define  RESPONSES_SECTION_NAME     "Responses"




//  Data Structures shared with wrapmxs.c  ***********************************
//

typedef struct MXT_ENTRY MXT_ENTRY;

struct MXT_ENTRY
{
  TCHAR         E_MacroName[MAX_PARAM_KEY_SIZE + 1];
  RAS_PARAMS    *E_Param;
};



typedef struct MACROXLATIONTABLE MACROXLATIONTABLE;

struct MACROXLATIONTABLE
{
  WORD      MXT_NumOfEntries;
  MXT_ENTRY MXT_Entry[1];
};




//*  Function Prototypes shared with wrapmxs.c  ******************************
//

DWORD UpdateParamString(RAS_PARAMS *pParam, TCHAR *psStr, DWORD dwStrLen);




//*  Enumeration Types  ******************************************************
//

enum RCVSTATE                           // ReceiveStateMachine() State
{
  GETECHO              = 0,
  GETNUMBYTESECHOD     = 1,
  CHECKECHO            = 2,
  GETFIRSTCHAR         = 3,
  GETNUMBYTESFIRSTCHAR = 4,
  GETRECEIVESTR        = 5,
  GETNUMBYTESRCVD      = 6,
  CHECKRESPONSE        = 7
};

typedef enum RCVSTATE RCVSTATE;


enum NEXTACTION                         // DeviceStateMachine() State
{
  SEND    = 0,
  RECEIVE = 1,
  DONE    = 2
};

typedef enum NEXTACTION NEXTACTION;


enum CMDTYPE                            // Used by DeviceStateMachine()
{
  CT_UNKNOWN   = 0,
  CT_GENERIC   = 1,
  CT_INIT      = 2,
  CT_DIAL      = 3,
  CT_LISTEN    = 4
};

typedef enum CMDTYPE CMDTYPE;


enum DEVICETYPE                         // Used by DeviceConnect()
{
  DT_UNKNOWN  = 0,
  DT_NULL     = 1,
  DT_MODEM    = 2,
  DT_PAD      = 3,
  DT_SWITCH   = 4
};

typedef enum DEVICETYPE DEVICETYPE;


enum INFOTYPE                           // Used by BinarySuffix()
{
  UNKNOWN_INFOTYPE  = 0,
  VARIABLE          = 1,
  UNARYMACRO        = 2,
  BINARYMACRO       = 3
};

typedef enum INFOTYPE INFOTYPE;



//*  Wrapper Errors  *********************************************************
//
//  These are error codes returned from mxswrap.c to rasmxs dll, and which
//  are used only by rasmxs dll and are not passed up to rasman dll.
//

#define  WRAP_BASE  13200

#define  ERROR_END_OF_SECTION                   WRAP_BASE + 7

// RasDevGetCommand() found the end of a section instead of a command.


#define  ERROR_PARTIAL_RESPONSE                 WRAP_BASE + 8

// RasDevCheckResponse() matched just the first part of a response
// containing an <append> macro.

#endif // _MXSINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\nbfcpif.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    nbfcpif.h
//
// Description: Contains structures and id definitions for componenets that
//              directly or indireclty interface with NBFCP. The 2 components
//              that do this are DDM and the NetBios gateqway
//
// History:     May 11,1995	    NarenG		Created original version.
//

#ifndef _NBFCPIF_
#define _NBFCPIF_

#include <nb30.h>
#include <nbgparms.h>


//
// Configuration Options
//
#define NBFCP_MAX_NAMES_IN_OPTION    14
#define NBFCP_UNIQUE_NAME            1
#define NBFCP_GROUP_NAME             2

typedef struct _NBFCP_NETBIOS_NAME_INFO
{
    BYTE Name[NCBNAMSZ];
    BYTE Code;
} NBFCP_NETBIOS_NAME_INFO, *PNBFCP_NETBIOS_NAME_INFO;

typedef struct _NBFCP_MULTICAST_FILTER
{
    BYTE Period[2];
    BYTE Priority;
} NBFCP_MULTICAST_FILTER, *PNBFCP_MULTICAST_FILTER;


//
// Peer classes
//
#define MSFT_PPP_NB_GTWY_SERVER           1
#define GENERIC_PPP_NB_GTWY_SERVER        2
#define MSFT_PPP_LOCAL_ACCESS_SERVER      3
#define GENERIC_PPP_LOCAL_ACCESS_SERVER   4
#define RESERVED                          5
#define GENERIC_PPP_NBF_BRIDGE            6
#define MSFT_PPP_CLIENT                   7
#define GENERIC_PPP_CLIENT                8


//
// Our version numbers
//
#define NBFCP_MAJOR_VERSION_NUMBER        1
#define NBFCP_MINOR_VERSION_NUMBER        0

typedef struct _NBFCP_PEER_INFORMATION
{
    BYTE Class[2];
    BYTE MajorVersion[2];
    BYTE MinorVersion[2];
    BYTE Name[MAX_COMPUTERNAME_LENGTH + 1];
} NBFCP_PEER_INFORMATION, *PNBFCP_PEER_INFORMATION;

//
// Server Info
//

typedef struct _NBFCP_SERVER_CONFIGURATION
{
    NBFCP_PEER_INFORMATION PeerInformation;
    NBFCP_MULTICAST_FILTER MulticastFilter;
    WORD NumNetbiosNames;
    DWORD NetbiosResult;
    NBFCP_NETBIOS_NAME_INFO NetbiosNameInfo[MAX_NB_NAMES];
} NBFCP_SERVER_CONFIGURATION, *PNBFCP_SERVER_CONFIGURATION;

//
// NBFCP<->DDM Message Ids and definitions.
//

#define NBFCP_CONFIGURATION_REQUEST    1
#define NBFCP_TIME_SINCE_LAST_ACTIVITY 2

typedef struct _NBFCP_MESSAGE
{
    WORD    MsgId;
    HCONN   hConnection;

    union
    {
        DWORD TimeSinceLastActivity;
        NBFCP_SERVER_CONFIGURATION ServerConfig;
    };

} NBFCP_MESSAGE, *PNBFCP_MESSAGE;

DWORD
SendMessageToNbfCp(
    IN NBFCP_MESSAGE * pMsg
);

typedef VOID (*FUNCNBFCPDDMMSG)( IN NBFCP_MESSAGE * pNbfCpMsg );

VOID
InitNbfCp(
    FUNCNBFCPDDMMSG pFuncSendNbfCpMessageToDDM
);

#endif _NBFCPIF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\nbgutils.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    nbgutils.h
//
// Description: Contains utility routines for the NetBios gateway related
//              components
//
// History:     May 11,1995	    NarenG		Created original version.
//

#ifndef _NBGUTILS_
#define _NBGUTILS_

DWORD
LoadNbGateway(
    VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\pppcp.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	pppcp.h
//
// Description: This header defines function prototypes, structures and 
//		related constants used in the interface between the PPP 
//		engine and the various CPs
//
// History:
//	Nov 5,1993.	NarenG		Created original version.
//

#ifndef _PPPCP_
#define _PPPCP_

#include <mprapi.h>
#include <rasppp.h>
#include <rasauth.h>

//
// Maximum number of CPs that can live in a single DLL
//

#define PPPCP_MAXCPSPERDLL 	20

//
// Various control protocol IDs
//

#define PPP_LCP_PROTOCOL        0xC021  // Link Control Protocol 
#define PPP_PAP_PROTOCOL        0xC023  // Password Authentication Protocol 
#define PPP_CBCP_PROTOCOL	    0xC029  // Callback Control Protocol
#define PPP_BACP_PROTOCOL       0xC02B  // Bandwidth Allocation Control Protocol
#define PPP_BAP_PROTOCOL        0xc02D  // Bandwidth Allocation Protocol
#define PPP_CHAP_PROTOCOL	    0xC223  // Challenge Handshake Auth. Protocol
#define PPP_IPCP_PROTOCOL       0x8021  // Internet Protocol Control Protocol 
#define PPP_ATCP_PROTOCOL	    0x8029  // Appletalk Control Protocol 
#define PPP_IPXCP_PROTOCOL	    0x802B  // Novel IPX Control Procotol 
#define PPP_NBFCP_PROTOCOL	    0x803F  // NetBIOS Framing Control Protocol 
#define PPP_CCP_PROTOCOL	    0x80FD  // Compression Control Protocol
#define PPP_SPAP_NEW_PROTOCOL	0xC027  // Shiva PAP new protocol
#define PPP_EAP_PROTOCOL	    0xC227  // Extensible Authentication Protocol

//
// CHAP Digest codes
//
#define PPP_CHAP_DIGEST_MD5        0x05 // PPP standard MD5
#define PPP_CHAP_DIGEST_MSEXT      0x80 // Microsoft extended CHAP (nonstandard)
#define PPP_CHAP_DIGEST_MSEXT_NEW  0x81 // Microsoft extended CHAP (nonstandard)

//
// Config Codes
//

#define CONFIG_REQ              1
#define CONFIG_ACK              2
#define CONFIG_NAK              3
#define CONFIG_REJ              4
#define TERM_REQ                5
#define TERM_ACK                6
#define CODE_REJ                7
#define PROT_REJ                8
#define ECHO_REQ                9
#define ECHO_REPLY              10
#define DISCARD_REQ             11
#define IDENTIFICATION          12
#define TIME_REMAINING          13

typedef struct _PPP_CONFIG 
{
    BYTE	Code;		// Config code 
  
    BYTE	Id;		    // ID of this config packet.  CPs and APs need
                        // not muck with this.  The engine handles it.

    BYTE	Length[2];	// Length of this packet 

    BYTE	Data[1];	// Data 

}PPP_CONFIG, *PPPP_CONFIG;

#define PPP_CONFIG_HDR_LEN 	( sizeof( PPP_CONFIG ) - 1 )

typedef struct _BAP_RESPONSE
{
    BYTE    Type;       // BAP packet type
  
    BYTE    Id;         // ID of this packet

    BYTE    Length[2];  // Length of this packet

    BYTE    ResponseCode; // BAP_RESPONSE_ACK, etc

    BYTE    Data[1];    // Data 

} BAP_RESPONSE, *PBAP_RESPONSE;

#define BAP_RESPONSE_HDR_LEN    ( sizeof( BAP_RESPONSE ) - 1 )

//
// Option header structure
//

typedef struct _PPP_OPTION 
{
    BYTE	Type;		// Option Code 

    BYTE	Length;		// Length of this option packet 

    BYTE	Data[1];	// Data 

}PPP_OPTION, *PPPP_OPTION;

#define PPP_OPTION_HDR_LEN 	( sizeof( PPP_OPTION ) - 1 )


//
// Vendor-Type ids for MS VSAs - taken from rfc 2548
//
#define MS_VSA_CHAP_RESPONSE                1
#define MS_VSA_CHAP_Error                   2
#define MS_VSA_CHAP_CPW1                    3
#define MS_VSA_CHAP_CPW2                    4
#define MS_VSA_CHAP_LM_Enc_PW               5
#define MS_VSA_CHAP_NT_Enc_PW               6
#define MS_VSA_MPPE_Encryption_Policy       7
#define MS_VSA_MPPE_Encryption_Type         8
#define MS_VSA_RAS_Vendor                   9
#define MS_VSA_CHAP_Domain                  10
#define MS_VSA_CHAP_Challenge               11
#define MS_VSA_CHAP_MPPE_Keys               12
#define MS_VSA_BAP_Usage                    13
#define MS_VSA_Link_Utilization_Threshold   14
#define MS_VSA_Link_Drop_Time_Limit         15
#define MS_VSA_MPPE_Send_Key                16
#define MS_VSA_MPPE_Recv_Key                17
#define MS_VSA_RAS_Version                  18
#define MS_VSA_Old_ARAP_Password            19
#define MS_VSA_New_ARAP_Password            20
#define MS_VSA_ARAP_PW_Change_Reason        21
#define MS_VSA_Filter                       22
#define MS_VSA_Acct_Auth_Type               23
#define MS_VSA_Acct_EAP_Type                24
#define MS_VSA_CHAP2_Response               25
#define MS_VSA_CHAP2_Success                26
#define MS_VSA_CHAP2_CPW                    27
#define MS_VSA_Primary_DNS_Server           28
#define MS_VSA_Secondary_DNS_Server         29
#define MS_VSA_Primary_NBNS_Server          30
#define MS_VSA_Secondary_NBNS_Server        31
#define MS_VSA_ARAP_Challenge               33
#define MS_VSA_RAS_Client_Name              34
#define MS_VSA_RAS_Client_Version           35
#define MS_VSA_Quarantine_IP_Filter         36
#define MS_VSA_Quarantine_Session_Timeout   37
#define MS_VSA_Local_Magic_Number           38
#define MS_VSA_Remote_Magic_Number          39


//
// defines for terminate-cause radius attribute
//

#define TERMINATE_CAUSE_USER_REQUEST        1
#define TERMINATE_CAUSE_LOST_CARRIER        2
#define TERMINATE_CAUSE_LOST_SERVICE        3
#define TERMINATE_CAUSE_IDLE_TIMEOUT        4
#define TERMINATE_CAUSE_SESSION_TIMEOUT     5
#define TERMINATE_CAUSE_ADMIN_RESET         6
#define TERMINATE_CAUSE_ADMIN_REBOOT        7
#define TERMINATE_CAUSE_PORT_ERROR          8
#define TERMINATE_CAUSE_NAS_ERROR           9
#define TERMINATE_CAUSE_NAS_REQUEST         10
#define TERMINATE_CAUSE_NAS_REBOOT          11
#define TERMINATE_CAUSE_PORT_UNNEEDED       12
#define TERMINATE_CAUSE_PORT_PREEMPTED      13
#define TERMINATE_CAUSE_PORT_SUSPENDED      14
#define TERMINATE_CAUSE_SERVICE_UNAVAILABLE 15
#define TERMINATE_CAUSE_CALLBACK            16
#define TERMINATE_CAUSE_USER_ERROR          17
#define TERMINATE_CAUSE_HOST_REQUEST        18


//
// Interface structure between the engine and APs. This is passed to the
// AP's via the RasCpBegin call. 
//

typedef struct _PPPAP_INPUT
{
    HPORT 	    hPort;	        // Handle to Ras Port for this connection.

    BOOL 	    fServer;	    // Is this server side authentication?

    BOOL        fRouter;

    DWORD       fConfigInfo;

    CHAR *      pszUserName;    // Client's account ID.

    CHAR *      pszPassword;    // Client's account password.

    CHAR *      pszDomain;      // Client's account domain.

    CHAR *      pszOldPassword; // Client's old account password.  This is set
                                // only for change password processing.

    LUID	    Luid;           // Used by LSA.  Must get it in user's context
                                // which is why it must be passed down.

    DWORD       dwRetries;      // Retries allowed by the server.

    DWORD       APDataSize;     // Size in bytes of the data pointed to by
                                // pAPData

    PBYTE       pAPData;        // Pointer to the data that was received along
                                // with the authentication option during LCP
                                // negotiation. Data is in wire format.

    DWORD       dwInitialPacketId;

    //
    // Passed in by the server when a call comes in. Identifies the port used,
    // etc.
    //

    RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // Indicates that the authenticator has completed the request, if an
    // authenticator was used. Ignore this field otherwise.
    //

    BOOL        fAuthenticationComplete;

    //
    // Indicates an error condition during the process of authentication if
    // value is non-zero. Valid only when the field above is TRUE.
    //

    DWORD       dwAuthError;

    //
    // Result of the authentication process. NO_ERROR indicates success, 
    // otherwise is a value from winerror.h, raserror.h or mprerror.h 
    // indicating failure reason. Valid only when the field above is NO_ERROR.
    //

    DWORD       dwAuthResultCode;

    //
    // When the fAuthenticationComplete flag is TRUE this will point to 
    // attributes returned by the authenticator, if the authentication was
    // successful. ie. dwAuthResultCode and dwAuthError are both NO_ERROR.
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pAttributesFromAuthenticator;

    //
    // Used for EAP only
    //

    HANDLE                  hTokenImpersonateUser;

    PRAS_CUSTOM_AUTH_DATA   pCustomAuthConnData;

    PRAS_CUSTOM_AUTH_DATA   pCustomAuthUserData;

    BOOL                fLogon; // pCustomAuthUserData comes from WinLogon

    BOOL                fThisIsACallback;

    BOOL                fPortWillBeBundled;

    BOOL                fNonInteractive;

    BOOL                fSuccessPacketReceived;

    BOOL                fEapUIDataReceived;

    PPP_EAP_UI_DATA     EapUIData;

    DWORD               dwEapTypeToBeUsed;

}PPPAP_INPUT, *PPPPAP_INPUT;

typedef enum _PPPAP_ACTION
{
    //
    // These actions are provided by the AP as output from the
    // RasApMakeMessage API.  They tell the PPP engine what action (if any) to
    // take on the APs behalf, and eventually inform the engine that the AP
    // has finished authentication.
    //

    APA_NoAction,        // Be passive, i.e. listen without timeout (default)
    APA_Done,            // End authentication session, dwError gives result
    APA_SendAndDone,     // As above but send message without timeout first
    APA_Send,            // Send message, don't timeout waiting for reply
    APA_SendWithTimeout, // Send message, timeout if reply not received
    APA_SendWithTimeout2,// As above, but don't increment retry count
    APA_Authenticate     // Authenticate using specified credentials.

} PPPAP_ACTION;

typedef struct _PPPAP_RESULT
{
    PPPAP_ACTION    Action;

    //
    // The packet ID which will cause the timeout for this send to be removed
    // from the timer queue.  Otherwise, the timer queue is not touched.  The
    // packet received is returned to the AP regardless of whether the timer
    // queue is changed.
    //

    BYTE            bIdExpected;

    //
    // dwError is valid only with an Action code of Done or SendAndDone.  0
    // indicates succesful authentication.  Non-0 indicates unsuccessful
    // authentication with the value indicating the error that occurred.
    //

    DWORD	        dwError;

    //
    // Valid only when dwError is non-0.  Indicates whether client is allowed
    // to retry without restarting authentication.  (Will be true in MS
    // extended CHAP only)
    //

    BOOL            fRetry;

    CHAR            szUserName[ UNLEN + 1 ];

    //
    // Set to attributes to be used for this user. If this is NULL, attributes 
    // from the authenticator will be used for this user. It is upto the
    // allocater of this memory to free it. Must be freed during the RasCpEnd 
    // call. 
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // Used by MS-CHAP to pass the challenge used during the authentication
    // protocol. These 8 bytes are used as the variant for the 128 bit
    // encryption keys.
    //

    BYTE                            abChallenge[MAX_CHALLENGE_SIZE];

    BYTE                            abResponse[MAX_RESPONSE_SIZE];

    //
    // Used only by EAP
    //

    BOOL                            fInvokeEapUI;

    PPP_INVOKE_EAP_UI               InvokeEapUIData;

    DWORD                           dwEapTypeId;

    BOOL                            fSaveUserData;
    
    BYTE *                          pUserData;

    DWORD                           dwSizeOfUserData;

    BOOL                            fSaveConnectionData;

    PPP_SET_CUSTOM_AUTH_DATA        SetCustomAuthData;

    CHAR *                          szReplyMessage;
  
}PPPAP_RESULT;

//
// Interface structure between the engine and the callback control protocol. 
// This is passed to the CBCP via the RasCpBegin call. 
//

typedef struct _PPPCB_INPUT
{
    BOOL            fServer;

    BYTE            bfCallbackPrivilege;    

    DWORD           CallbackDelay;          

    CHAR *          pszCallbackNumber;     

} PPPCB_INPUT, *PPPPCB_INPUT;

typedef struct _PPPCB_RESULT
{
    PPPAP_ACTION    Action;

    BYTE            bIdExpected;

    CHAR            szCallbackNumber[ MAX_CALLBACKNUMBER_SIZE + 1 ];

    BYTE            bfCallbackPrivilege;    

    DWORD           CallbackDelay;

    BOOL            fGetCallbackNumberFromUser;

} PPPCB_RESULT, *PPPPCB_RESULT;


typedef struct _PPPCP_INIT
{
    BOOL                    fServer;

    HPORT                   hPort;

    DWORD                   dwDeviceType;

    VOID (*CompletionRoutine)(
                            HCONN         hPortOrBundle,
                            DWORD         Protocol,
                            PPP_CONFIG *  pSendConfig, 
                            DWORD         dwError );

    CHAR*                   pszzParameters;

    BOOL                    fThisIsACallback;

    BOOL                    fDisableNetbt;

    PPP_CONFIG_INFO         PppConfigInfo;

    CHAR *                  pszUserName;

    CHAR *                  pszPortName;

    HCONN                   hConnection;

    HANDLE                  hInterface;

    ROUTER_INTERFACE_TYPE   IfType;

    RAS_AUTH_ATTRIBUTE *    pAttributes;

} PPPCP_INIT, *PPPPCP_INIT;

//
// This structure is passed by the engine to the CP via RasCpGetInfo call.
// The Cp will fill up this structure.
//

typedef struct _PPPCP_INFO
{
    DWORD	Protocol;	// Protocol number for this CP

    CHAR    SzProtocolName[10]; // The name of this protocol

    // All Config codes upto (not including) this value are valid.  

    DWORD	Recognize;

    // Called to initialize/uninitialize this CP. In the former case,
    // fInitialize will be TRUE; in the latter case, it will be FALSE.
    // Even if RasCpInit(TRUE) returns FALSE, RasCpInit(FALSE) will be called.

    DWORD   (*RasCpInit)(   IN  BOOL        fInitialize );

    // Called to get the workbuffer for this CP and pass info if requred.
    // This will be called before any negotiation takes place.

    DWORD	(*RasCpBegin)(  OUT VOID ** ppWorkBuffer, 
			                IN  VOID *  pInfo );

    // Called to free the workbuffer for this CP. Called after negotiation
    // is completed successfully or not.

    DWORD	(*RasCpEnd)(    IN VOID * pWorkBuffer );

    // Called to notify the CP dll to (re)initiaize its option values.
    // This will be called at least once, right after RasCpBegin

    DWORD	(*RasCpReset)(  IN VOID * pWorkBuffer );

    // When leaving Initial or Stopped states. May be NULL.

    DWORD 	(*RasCpThisLayerStarted)( 
                            IN VOID * pWorkBuffer );    

    // When entering Closed or Stopped states. May be NULL

    DWORD 	(*RasCpThisLayerFinished)( 
                            IN VOID * pWorkBuffer );    

    // When entering the Opened state. May be NULL. 

    DWORD 	(*RasCpThisLayerUp)( 
                            IN VOID * pWorkBuffer );    

    // When leaving the Opened state. May be NULL. 

    DWORD 	(*RasCpThisLayerDown)( 
                            IN VOID * pWorkBuffer );
 
    // Just before the line goes down. May be NULL. 

    DWORD 	(*RasCpPreDisconnectCleanup)( 
                            IN VOID * pWorkBuffer );

    // Called to make a configure request.

    DWORD	(*RasCpMakeConfigRequest)( 
                            IN  VOID * 	    pWorkBuffer,
					        OUT PPP_CONFIG* pRequestBufffer,
					        IN  DWORD	    cbRequestBuffer );

    // Called when configure request is received and a result packet 
    // Ack/Nak/Reject needs to be sent

    DWORD	(*RasCpMakeConfigResult)( 
                            IN  VOID * 	        pWorkBuffer,
					        IN  PPP_CONFIG *    pReceiveBufffer,
					        OUT PPP_CONFIG *    pResultBufffer,
					        IN  DWORD	        cbResultBuffer,
					        IN  BOOL 	        fRejectNaks );

    // Called to process an Ack that was received.

    DWORD	(*RasCpConfigAckReceived)( 
                            IN VOID *       pWorkBuffer, 
					        IN PPP_CONFIG * pReceiveBuffer );

    // Called to process a Nak that was received.

    DWORD	(*RasCpConfigNakReceived)( 
                            IN VOID *       pWorkBuffer,
					        IN PPP_CONFIG * pReceiveBuffer );

    // Called to process a Rej that was received.

    DWORD	(*RasCpConfigRejReceived)( 
                            IN VOID *       pWorkBuffer,
					        IN PPP_CONFIG * pReceiveBuffer );

    // Called to get the network address from configured protocols.

    DWORD	(*RasCpGetNegotiatedInfo)( 
                            IN      VOID *  pWorkBuffer,
                            OUT     VOID *  pInfo );

    // Called after all CPs have completed their negotiation, successfully or
    // not, to notify each CP of the projection result. May be NULL.
    // To access information, cast pProjectionInfo to PPP_PROJECTION_RESULT*

    DWORD	(*RasCpProjectionNotification)( 
				            IN  VOID * pWorkBuffer,
				            IN  PVOID  pProjectionResult );

    DWORD   (*RasCpChangeNotification)( VOID );

    //
    // This entry point only applies to Authentication protocols.
    // MUST BE NULL FOR CONTROL PROTOCOLS.

    DWORD  	(*RasApMakeMessage)( 
                            IN  VOID*         pWorkBuf,
				            IN  PPP_CONFIG*   pReceiveBuf,
    				        OUT PPP_CONFIG*   pSendBuf,
    				        IN  DWORD         cbSendBuf,
    				        OUT PPPAP_RESULT* pResult,
                            IN  PPPAP_INPUT*  pInput );

} PPPCP_INFO, *PPPPCP_INFO;

#define PPPCP_FLAG_INIT_CALLED  0x00000001  // RasCpInit has been called
#define PPPCP_FLAG_AVAILABLE    0x00000002  // The protocol can be used

//
// The information that PPP needs to keep about each CP.
//

typedef struct _PPPCP_ENTRY
{
    PPPCP_INFO  CpInfo;

    DWORD       fFlags;

} PPPCP_ENTRY;

// 
// Used to get result from NBFCP via the RasCpGetResult call
//

typedef struct _PPPCP_NBFCP_RESULT
{

    DWORD dwNetBiosError;
    CHAR  szName[ NETBIOS_NAME_LEN + 1 ];

} PPPCP_NBFCP_RESULT;

//
// Function prototypes.
//

DWORD APIENTRY
RasCpGetInfo(
    IN  DWORD 	    dwProtocolId,
    OUT PPPCP_INFO* pCpInfo
);

DWORD APIENTRY
RasCpEnumProtocolIds(
    OUT    DWORD * pdwProtocolIds,
    IN OUT DWORD * pcProtocolIds
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\rasndis.h ===
#include <ntddndis.h>

//
// definition of the basic spin lock structure
//

typedef struct _NDIS_SPIN_LOCK {
    KSPIN_LOCK SpinLock;
    KIRQL OldIrql;
} NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;

typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

typedef int NDIS_STATUS, *PNDIS_STATUS; // note default size

//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS; // windbgkd

typedef PHYSICAL_ADDRESS NDIS_PHYSICAL_ADDRESS, *PNDIS_PHYSICAL_ADDRESS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\rasmxs.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: rasmxs.h
//
//  Revision History:
//
//  Jun 24, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains name strings for standard macros and
//               variables found in modem.inf, pad.inf, and switch.inf.
//               This header file will be needed by all users.
//
//****************************************************************************


#ifndef _RASMXS_
#define _RASMXS_


//  General Defines  *********************************************************
//

#include <rasfile.h>


#define  MAX_PHONE_NUMBER_LENGTH    RAS_MAXLINEBUFLEN

#define  MXS_PAD_TXT                "pad"
#define  MXS_MODEM_TXT              "modem"
#define  MXS_SWITCH_TXT             "switch"
#define  MXS_NULL_TXT               "null"

#define  ATTRIB_VARIABLE            0x08
#define  ATTRIB_BINARYMACRO         0x04
#define  ATTRIB_USERSETTABLE        0x02
#define  ATTRIB_ENABLED             0x01


//  Unary Macros  ************************************************************
//
                                                                    //Used in:

#define  MXS_PHONENUMBER_KEY        "PhoneNumber"                   //modem.inf
#define  MXS_CARRIERBPS_KEY         "CarrierBps"                    //modem.inf
#define  MXS_CONNECTBPS_KEY         "ConnectBps"                    //modem.inf

#define  MXS_X25PAD_KEY             "X25Pad"                        //pad.inf
#define  MXS_X25ADDRESS_KEY         "X25Address"                    //pad.inf
#define  MXS_DIAGNOSTICS_KEY        "Diagnostics"                   //pad.inf
#define  MXS_USERDATA_KEY           "UserData"                      //pad.inf
#define  MXS_FACILITIES_KEY         "Facilities"                    //pad.inf

#define  MXS_MESSAGE_KEY	    "Message"			    //all

#define  MXS_USERNAME_KEY	    "UserName"			    //all
#define  MXS_PASSWORD_KEY	    "Password"			    // all


//  Binary Macros  ***********************************************************
//

#define  MXS_SPEAKER_KEY            "Speaker"                       //modem.inf
#define  MXS_HDWFLOWCONTROL_KEY     "HwFlowControl"                 //modem.inf
#define  MXS_PROTOCOL_KEY           "Protocol"                      //modem.inf
#define  MXS_COMPRESSION_KEY        "Compression"                   //modem.inf
#define  MXS_AUTODIAL_KEY           "AutoDial"                      //modem.inf


//  Binary Macro Suffixes  ***************************************************
//

#define  MXS_ON_SUFX                "_on"                           //all
#define  MXS_OFF_SUFX               "_off"                          //all


//  INF File Variables  ******************************************************
//

#define  MXS_DEFAULTOFF_KEY         "DEFAULTOFF"                    //modem.inf
#define  MXS_CALLBACKTIME_KEY       "CALLBACKTIME"                  //modem.inf
#define  MXS_MAXCARRIERBPS_KEY      "MAXCARRIERBPS"                 //modem.inf
#define  MXS_MAXCONNECTBPS_KEY      "MAXCONNECTBPS"                 //modem.inf


//  Keywork Prefixes  ********************************************************
//

#define  MXS_COMMAND_PRFX           "COMMAND"                       //all
#define  MXS_CONNECT_PRFX           "CONNECT"                       //all
#define  MXS_ERROR_PRFX             "ERROR"                         //all
#define  MXS_OK_PRFX                "OK"                            //all


//  Modem Command Keywords  **************************************************
//

#define  MXS_GENERIC_COMMAND        "COMMAND"
#define  MXS_INIT_COMMAND           "COMMAND_INIT"
#define  MXS_DIAL_COMMAND           "COMMAND_DIAL"
#define  MXS_LISTEN_COMMAND         "COMMAND_LISTEN"


//  Modem Response Keywords  *************************************************
//

#define  MXS_OK_KEY                 "OK"

#define  MXS_CONNECT_KEY            "CONNECT"
#define  MXS_CONNECT_EC_KEY         "CONNECT_EC"

#define  MXS_ERROR_KEY              "ERROR"
#define  MXS_ERROR_BUSY_KEY         "ERROR_BUSY"
#define  MXS_ERROR_NO_ANSWER_KEY    "ERROR_NO_ANSWER"
#define  MXS_ERROR_VOICE_KEY        "ERROR_VOICE"
#define  MXS_ERROR_NO_CARRIER_KEY   "ERROR_NO_CARRIER"
#define  MXS_ERROR_NO_DIALTONE_KEY  "ERROR_NO_DIALTONE"
#define  MXS_ERROR_DIAGNOSTICS_KEY  "ERROR_DIAGNOSTICS"

#define  MXS_NORESPONSE             "NoResponse"
#define  MXS_NOECHO                 "NoEcho"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\rasfile.h ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rasfile.h
**
** Revision History :
**      July 10, 1992   David Kays      Created
**      Dec  12, 1992   Ram Cherala     Added RFM_KEEPDISKFILEOPEN
**
** Description :
**      Rasfile file export include file.
******************************************************************************/

#ifndef _RASFILE_
#define _RASFILE_

//
// RASFILE load modes
//
#define RFM_SYSFORMAT           0x01    // DOS config.sys style file
#define RFM_CREATE              0x02    // create file if it does't exist
#define RFM_READONLY            0x04    // open file for read only
#define RFM_LOADCOMMENTS        0x08    // load comment lines into memory
#define RFM_ENUMSECTIONS        0x10    // only section headers loaded
#define RFM_KEEPDISKFILEOPEN    0x20    // if not set close the disk file

//
// RASFILE line type bit-masks.
// The ANY types are shorthand for multiple line types.
//
#define RFL_SECTION             0x01
#define RFL_GROUP               0x02
#define RFL_ANYHEADER           (RFL_SECTION | RFL_GROUP)
#define RFL_BLANK               0x04
#define RFL_COMMENT             0x08
#define RFL_ANYINACTIVE         (RFL_BLANK | RFL_COMMENT)
#define RFL_KEYVALUE            0x10
#define RFL_COMMAND             0x20
#define RFL_ANYACTIVE           (RFL_KEYVALUE | RFL_COMMAND)
#define RFL_ANY                 0x3F


// Note MAX_RASFILES increased from 10 to 500  12-14-92 perryh

// max number of configuration files
// for the gpRasfiles[] defined in rffile.c
#define MAX_RASFILES        500    
#define MAX_LINE_SIZE       RAS_MAXLINEBUFLEN   // max line length
#define TEMP_BUFFER_SIZE    2048        // size of temporary I/O buffer

#define VALIDATEHRASFILE(_x) (( (_x) < 0 || (_x) >= MAX_RASFILES ) ? FALSE : TRUE)

//
// RASFILE search scope.
//
typedef enum
{
    RFS_FILE,
    RFS_SECTION,
    RFS_GROUP
} RFSCOPE;

typedef int     HRASFILE;
typedef BOOL    (*PFBISGROUP)();

#define INVALID_HRASFILE     -1
#define RAS_MAXLINEBUFLEN    600
#define RAS_MAXSECTIONNAME   RAS_MAXLINEBUFLEN

//
// RasfileLoad parameters as returned by RasfileLoadInfo.
//
typedef struct _RASFILELOADINFO
{
    CHAR        szPath[ MAX_PATH ];
    DWORD       dwMode;
    CHAR        szSection[ RAS_MAXSECTIONNAME + 1 ];
    PFBISGROUP  pfbIsGroup;
} RASFILELOADINFO;


//
// RASFILE APIs
//

// file management routines
HRASFILE APIENTRY  RasfileLoad( LPCSTR, DWORD, LPCSTR, PFBISGROUP);
HRASFILE APIENTRY  RasfileLoadEx(LPCSTR,DWORD,LPCSTR, PFBISGROUP,FILETIME*);
BOOL APIENTRY    RasfileWrite( HRASFILE, LPCSTR );
BOOL APIENTRY    RasfileClose( HRASFILE );
VOID APIENTRY    RasfileLoadInfo( HRASFILE, RASFILELOADINFO* );

// file navigation routines
BOOL APIENTRY    RasfileFindFirstLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindLastLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindPrevLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindNextLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindNextKeyLine( HRASFILE, LPCSTR, RFSCOPE );
BOOL APIENTRY    RasfileFindMarkedLine( HRASFILE, BYTE );
BOOL APIENTRY    RasfileFindSectionLine( HRASFILE, LPCSTR, BOOL );

// file editing routines
const LPCSTR APIENTRY    RasfileGetLine( HRASFILE );
BOOL APIENTRY    RasfileGetLineText( HRASFILE, LPSTR );
BOOL APIENTRY    RasfilePutLineText( HRASFILE, LPCSTR );
BYTE APIENTRY    RasfileGetLineMark( HRASFILE );
BOOL APIENTRY    RasfilePutLineMark( HRASFILE, BYTE );
BYTE APIENTRY    RasfileGetLineType( HRASFILE );
BOOL APIENTRY    RasfileInsertLine( HRASFILE, LPCSTR, BOOL );
BOOL APIENTRY    RasfileDeleteLine( HRASFILE );
BOOL APIENTRY    RasfileGetSectionName( HRASFILE, LPSTR );
BOOL APIENTRY    RasfilePutSectionName( HRASFILE, LPCSTR );
BOOL APIENTRY    RasfileGetKeyValueFields( HRASFILE, LPSTR, LPSTR );
BOOL APIENTRY    RasfilePutKeyValueFields( HRASFILE, LPCSTR, LPCSTR );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\rasauth.h ===
/********************************************************************/
/**               Copyright(c) 1997-1998 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    RASAUTH.H
//
// Description: Contains definitions to allow for third parties to plug in
//              back-end authenticaion modules into Remote Access Service.
//
#ifndef _RASAUTH_
#define _RASAUTH_

#include <raseapif.h>

#ifdef __cplusplus
extern "C" {
#endif

#if(WINVER >= 0x0500)

//
// Registry definitions used for installation or Accounting and Authenticaion
// providers

#define RAS_AUTHPROVIDER_REGISTRY_LOCATION      \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\Providers")

#define RAS_ACCTPROVIDER_REGISTRY_LOCATION      \
    TEXT("SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Accounting\\Providers")

#define RAS_PROVIDER_VALUENAME_PATH             TEXT("Path")
#define RAS_PROVIDER_VALUENAME_CONFIGCLSID      TEXT("ConfigCLSID")
#define RAS_PROVIDER_VALUENAME_DISPLAYNAME      TEXT("DisplayName")

DWORD APIENTRY
RasAuthProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE * pServerAttributes,
    IN  HANDLE               hEventLog,
    IN  DWORD                dwLoggingLevel
);

DWORD APIENTRY
RasAuthProviderTerminate(
    VOID
);

DWORD APIENTRY
RasAuthProviderFreeAttributes(
    IN  RAS_AUTH_ATTRIBUTE * pAttributes
);

DWORD APIENTRY
RasAuthProviderAuthenticateUser(
    IN  RAS_AUTH_ATTRIBUTE *    prgInAttributes,
    OUT RAS_AUTH_ATTRIBUTE **   pprgOutAttributes,
    OUT DWORD *                 lpdwResultCode
);

DWORD APIENTRY
RasAuthConfigChangeNotification(
    IN  DWORD                dwLoggingLevel
);

DWORD APIENTRY
RasAcctProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE * pServerAttributes,
    IN  HANDLE               hEventLog,
    IN  DWORD                dwLoggingLevel
);

DWORD APIENTRY
RasAcctProviderTerminate(
    VOID
);


DWORD APIENTRY
RasAcctProviderFreeAttributes(
    IN  RAS_AUTH_ATTRIBUTE * pAttributes
);

DWORD APIENTRY
RasAcctProviderStartAccounting(
    IN  RAS_AUTH_ATTRIBUTE *prgInAttributes,
    OUT RAS_AUTH_ATTRIBUTE **pprgOutAttributes
);

DWORD APIENTRY
RasAcctProviderStopAccounting(
    IN  RAS_AUTH_ATTRIBUTE *prgInAttributes,
    OUT RAS_AUTH_ATTRIBUTE **pprgOutAttributes
);

DWORD APIENTRY
RasAcctProviderInterimAccounting(
    IN  RAS_AUTH_ATTRIBUTE *prgInAttributes,
    OUT RAS_AUTH_ATTRIBUTE **pprgOutAttributes
);

DWORD APIENTRY
RasAcctConfigChangeNotification(
    IN  DWORD                dwLoggingLevel
);

#endif /* WINVER >= 0x0500 */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\serial.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: serial.h
//
//  Revision History:
//
//  July 27, 1992   Gurdeep Pall Created
//
//
//  Description: This file contains name strings for standard parameter
//               names used for serial Media.
//
//****************************************************************************


#ifndef _SERIALDLLINCLUDE_
#define _SERIALDLLINCLUDE_


//  General Defines  *********************************************************
//

#define MAX_BPS_STR_LEN     11  //Longest string from a DWORD + zero byte

#define SERIAL_TXT          "serial"


//  Serial.ini File Defines  *************************************************
//

#define SER_MAXCONNECTBPS_KEY   "MAXCONNECTBPS"
#define SER_MAXCARRIERBPS_KEY   "MAXCARRIERBPS"
#define SER_INITBPS_KEY         "INITIALBPS"

#define SER_DEVICETYPE_KEY      "DEVICETYPE"
#define SER_DEVICENAME_KEY      "DEVICENAME"

#define SER_USAGE_KEY           "USAGE"
#define SER_USAGE_VALUE_CLIENT  "Client"
#define SER_USAGE_VALUE_SERVER  "Server"
//#define SER_USAGE_VALUE_BOTH    "ClientAndServer"
#define SER_USAGE_VALUE_ROUTER  "Router"
#define SER_USAGE_VALUE_NONE    "None"

#define SER_DEFAULTOFF_KEY      "DEFAULTOFF"
#define SER_C_DEFAULTOFF_KEY    "CLIENT_DEFAULTOFF"


//  PortGetInfo and PortSetInfo Defines  *************************************
//

#define SER_PORTNAME_KEY        "PortName"
#define SER_CONNECTBPS_KEY      "ConnectBPS"
#define SER_DATABITS_KEY        "WordSize"

#define SER_PARITY_KEY          "Parity"
#define SER_STOPBITS_KEY        "StopBits"
#define SER_HDWFLOWCTRLON_KEY   "HdwFlowControlEnabled"

#define SER_CARRIERBPS_KEY      "CarrierBPS"
#define SER_ERRORCONTROLON_KEY  "ErrorControlEnabled"
#define SER_DEFAULTOFFSTR_KEY   "DEFAULTOFF"
#define SER_C_DEFAULTOFFSTR_KEY "CLIENT_DEFAULTOFF"

#define SER_PORTOPEN_KEY        "PortOpenFlag"


//  Statistics Indicies  *****************************************************
//

#define NUM_RAS_SERIAL_STATS    14

#define BYTES_XMITED            0       //Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR                 4       //Serial Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#define BYTES_XMITED_UNCOMP     10      //Compression Stats
#define BYTES_RCVED_UNCOMP      11
#define BYTES_XMITED_COMP       12
#define BYTES_RCVED_COMP        13



#endif // _SERIALDLLINCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\sechost.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:    sechost.h
//
// Description: This header defines the interface between third party security
//              DLLs and the supervisor. 
//
// History:
//	Nov 11,1994.	NarenG		Created original version.
//

#ifndef _SECHOST_
#define _SECHOST_

#include <lmcons.h>                 // Defines for DNLEN and UNLEN

#define DEVICE_NAME_LEN             32

// typedef DWORD  HPORT;

typedef struct _SECURITY_MESSAGE
{
    DWORD dwMsgId;

    HPORT hPort;
    
    DWORD dwError;                  // Should be non-zero only if error
                                    // occurred during the security dialog.
                                    // Should contain errors from winerror.h
                                    // or raserror.h
    CHAR  UserName[UNLEN+1];        // Should always contain username if 
                                    // dwMsgId is SUCCESS/FAILURE

    CHAR  Domain[DNLEN+1];          // Should always contain domain if 
                                    // dwMsgId is SUCCESS/FAILURE

} SECURITY_MESSAGE, *PSECURITY_MESSAGE;


// Values for dwMsgId in SECURITY_MESSAGE structure

#define SECURITYMSG_SUCCESS     1
#define SECURITYMSG_FAILURE     2
#define SECURITYMSG_ERROR       3

// Used by RasSecurityGetInfo call

typedef struct _RAS_SECURITY_INFO
{

    DWORD LastError;                    // SUCCESS = receive completed
                                        // PENDING = receive pending
                                        // else completed with error

    DWORD BytesReceived;                // only valid if LastError == SUCCESS

    CHAR  DeviceName[DEVICE_NAME_LEN+1];        
   

}RAS_SECURITY_INFO,*PRAS_SECURITY_INFO;

typedef DWORD (WINAPI *RASSECURITYPROC)();

//
// Called by third party DLL to notify the supervisor of termination of 
// the security dialog
//

VOID WINAPI
RasSecurityDialogComplete(
    IN SECURITY_MESSAGE * pSecMsg       // Pointer to the above info. structure
);

//
// Called by supervisor into the security DLL to notify it to begin the 
// security dialog for a client.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogBegin(
    IN HPORT  hPort,        // RAS handle to port
    IN PBYTE  pSendBuf,     // Pointer to the buffer used in 
                            // RasSecurityDialogSend
    IN DWORD  SendBufSize,  // Size of above bufer in bytes
    IN PBYTE  pRecvBuf,     // Pointer to the buffer used in 
                            // RasSecurityDialogReceive
    IN DWORD  RecvBufSize,  // Size of above buffer
    IN VOID  (WINAPI *RasSecurityDialogComplete)( SECURITY_MESSAGE* )
                            // Pointer to function RasSecurityDialogComplete.   
                            // Guaranteed to be the same on every call.
);

//
// Called by supervisor into the security DLL to notify it to stop the 
// security dialog for a client. If this call returns an error, then it is not
// neccesary for the dll to call RasSecurityDialogComplete. Otherwise the DLL
// must call RasSecurityDialogComplete.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogEnd(
    IN HPORT    hPort           // RAS handle to port.
);

//
// Called to send data to remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogSend(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer containing data to send
    IN WORD     BufferLength    // Length of above buffer.
);

//
// Called to receive data from remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogReceive(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer to receive data
    IN PWORD    pBufferLength,  // length of data received in bytes.
    IN DWORD    Timeout,        // in seconds
    IN HANDLE   hEvent          // Event to set when receive completes or 
                                // timeouts
);

//
// Called to get Information about port.
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogGetInfo(
    IN HPORT                hPort,      // RAS handle to port.
    IN RAS_SECURITY_INFO*   pBuffer     // Pointer to get info structure.
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\uiip.h ===
/* Copyright (c) 1994, Microsoft Corporation, all rights reserved
**
** uiip.h
** Remote Access PPP
** UI->IPCP interface definitions
*/

#ifndef _UIIP_H_
#define _UIIP_H_


/* Parameter buffer option keys.
*/
#define PBUFKEY_IpAddress           "IpAddr"
#define PBUFKEY_IpAddressSource     "IpAddrSrc"
#define PBUFKEY_IpPrioritizeRemote  "IpRemote"
#define PBUFKEY_IpVjCompression     "IpVj"
#define PBUFKEY_IpDnsAddress        "IpDns"
#define PBUFKEY_IpDns2Address       "IpDns2"
#define PBUFKEY_IpWinsAddress       "IpWins"
#define PBUFKEY_IpWins2Address      "IpWins2"
#define PBUFKEY_IpNameAddressSource "IpNameSrc"
#define PBUFKEY_IpDnsFlags          "IpDnsFlags"
#define PBUFKEY_IpDnsSuffix         "IpDnsSuffix"

/* IpAddressSource values.  For the UI's convenience, these codes are defined
** to match the codes stored in the phonebook.
*/
#define PBUFVAL_ServerAssigned   1
#define PBUFVAL_RequireSpecific  2


#endif // _UIIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\inc\srvauth.h ===
/*****************************************************************************/
/**                      Microsoft LAN Manager                              **/
/**                Copyright (C) Microsoft Corp., 1992-1993                 **/
/*****************************************************************************/

//***
//    File Name:
//       SRVAUTH.H
//
//    Function:
//        Contains header information for Supervisor and Server
//        Authentication Transport module
//
//    History:
//        05/18/92 - Michael Salamone (MikeSa) - Original Version 1.0
//***

#ifndef _SRVAUTH_
#define _SRVAUTH_


/* This flag enables the NT31/WFW311 RAS compression support re-added for the
** NT-PPC release.
*/
#define RASCOMPRESSION 1


#include <lmcons.h>
#include <rasman.h>

#ifndef MAX_PHONE_NUMBER_LEN
#define MAX_PHONE_NUMBER_LEN    48
#endif

#ifndef MAX_INIT_NAMES
#define MAX_INIT_NAMES          16
#endif


//
// Used for establishing session with remote netbios clients
//
#define AUTH_NETBIOS_NAME    "DIALIN_GATEWAY  "



//
// Used for passing NetBIOS projection info to Supervisor
//
typedef struct _NAME_STRUCT
{
    BYTE NBName[NETBIOS_NAME_LEN]; // NetBIOS name
    WORD wType;                    // GROUP, UNIQUE, COMPUTER
} NAME_STRUCT, *PNAME_STRUCT;


//
// Manifests used to find location and type of name in the buffer returned
// by the NCB.STATUS call
//
#define NCB_GROUP_NAME  0x0080
#define UNIQUE_INAME    0x0001
#define GROUP_INAME     0x0002
#define COMPUTER_INAME  0x0004  // A computer name is also unique


//
// Projection result codes.  If not success, then the reason code
// (below) should be examined.  These values are used in wResult
// field in structs define below.
//
#define AUTH_PROJECTION_SUCCESS        0
#define AUTH_PROJECTION_FAILURE        1


//
// Projection reason codes.
//
#define FATAL_ERROR                    0x80000000
#define AUTH_DUPLICATE_NAME            (FATAL_ERROR | 0x00000001)
#define AUTH_OUT_OF_RESOURCES          (FATAL_ERROR | 0x00000002)
#define AUTH_STACK_NAME_TABLE_FULL     (FATAL_ERROR | 0x00000003)
#define AUTH_MESSENGER_NAME_NOT_ADDED                0x00000004
#define AUTH_CANT_ALLOC_ROUTE          (FATAL_ERROR | 0x00000005)
#define AUTH_LAN_ADAPTER_FAILURE       (FATAL_ERROR | 0x00000006)

//
// Projection result info must be copied into this structure.
//

typedef struct _IP_PROJECTION_RESULT
{
    DWORD Result;
    DWORD Reason;
} IP_PROJECTION_RESULT, *PIP_PROJECTION_RESULT;

typedef struct _IPX_PROJECTION_RESULT
{
    DWORD Result;
    DWORD Reason;
} IPX_PROJECTION_RESULT, *PIPX_PROJECTION_RESULT;


typedef struct _NETBIOS_PROJECTION_RESULT
{
    DWORD Result;
    DWORD Reason;
    char achName[NETBIOS_NAME_LEN];
} NETBIOS_PROJECTION_RESULT, *PNETBIOS_PROJECTION_RESULT;


typedef struct _AUTH_PROJECTION_RESULT
{
    IP_PROJECTION_RESULT IpResult;
    IPX_PROJECTION_RESULT IpxResult;
    NETBIOS_PROJECTION_RESULT NetbiosResult;
} AUTH_PROJECTION_RESULT, *PAUTH_PROJECTION_RESULT;


//
// The Supervisor will supply this structure to the Auth Xport (in
// the AuthStart API) so it knows what transport, as well as any
// necessary info for that transport, to use for authenticating on
// the given port.
//
typedef struct _AUTH_XPORT_INFO
{
    RAS_PROTOCOLTYPE Protocol;
    BYTE bLana;   // Only valid if Protocol == ASYBEUI
} AUTH_XPORT_INFO, *PAUTH_XPORT_INFO;


#ifndef _CLAUTH_


typedef WORD (*MSG_ROUTINE)(WORD, PVOID);

//
// Used to initialize the Auth Xport module
//
DWORD 
AuthInitialize(
    IN HPORT        *phPorts,  // pointer to array of port handles
    IN WORD         cPorts,    // number of port handles in array
    IN WORD         cRetries,  // number of retries clients will get if initial
                               // authentication attemps fails
    IN MSG_ROUTINE  MsgSend,
    IN DWORD        dwLocalIpAddress,
    IN LPVOID       lpfnRasAuthProviderAuthenticateUser,
    IN LPVOID       lpfnRasAuthProviderFreeAttributes,
    IN LPVOID       lpfnRasAcctProviderStartAccounting,
    IN LPVOID       lpfnRasAcctProviderInterimAccounting,
    IN LPVOID       lpfnRasAcctProviderStopAccounting,
    IN LPVOID       lpfnRasAcctProviderFreeAttributes,
    IN LPVOID       GetNextAccountingSessionId
);

//
// Returned by AuthInitialize
//
#define AUTH_INIT_SUCCESS          0
#define AUTH_INIT_FAILURE          1


//
// Used by Supervisor to tell Auth Xport module that it has completed its
// callback request.
//
VOID AuthCallbackDone(
    IN HPORT hPort
    );


//
// Used by Supervisor to tell Auth Xport module that it has completed its
// projection request.
//
VOID AuthProjectionDone(
    IN HPORT hPort,
    IN PAUTH_PROJECTION_RESULT
    );


//
// Returned by AuthRecognizeFrame
//
#define AUTH_FRAME_RECOGNIZED      0
#define AUTH_FRAME_NOT_RECOGNIZED  1


//
// To kick off an Authentication thread for the given port.
//
WORD AuthStart(
    IN HPORT,
    IN PAUTH_XPORT_INFO
    );

//
// Returned by AuthStart:
//
#define AUTH_START_SUCCESS         0
#define AUTH_START_FAILURE         1


//
// Used by Supervisor to tell Auth Xport module to halt authentication
// processing on the given port.
//
WORD AuthStop(
    IN HPORT hPort
    );

//
// Returned by AuthStop
//
#define AUTH_STOP_SUCCESS          0
#define AUTH_STOP_PENDING          1
#define AUTH_STOP_FAILURE          2


//
// The following messages are sent from Authentication to Supervisor via
// MESSAGE.DLL and are to be used in wMsgId in message struct below:
//
#define AUTH_DONE                    100
#define AUTH_FAILURE                 101
#define AUTH_STOP_COMPLETED          102
#define AUTH_PROJECTION_REQUEST      103
#define AUTH_CALLBACK_REQUEST        104
#define AUTH_ACCT_OK                 105


//
// These are the structures that accompany each message defined above:
//

// No structure for AUTH_DONE

// Structure for AUTH_FAILURE
typedef struct _AUTH_FAILURE_INFO
{
    WORD wReason;
    BYTE szLogonDomain[DNLEN + 1];
    BYTE szUserName[UNLEN + 1];
} AUTH_FAILURE_INFO, *PAUTH_FAILURE_INFO;

//
// These are the reasons that Authentication might fail:
//
#define AUTH_XPORT_ERROR             200
#define AUTH_NOT_AUTHENTICATED       201
#define AUTH_ALL_PROJECTIONS_FAILED  202
#define AUTH_INTERNAL_ERROR          203
#define AUTH_ACCT_EXPIRED            204
#define AUTH_NO_DIALIN_PRIVILEGE     205
#define AUTH_UNSUPPORTED_VERSION     206
#define AUTH_ENCRYPTION_REQUIRED     207
#define AUTH_PASSWORD_EXPIRED        208
#define AUTH_LICENSE_LIMIT_EXCEEDED  209


// No structure for AUTH_STOP_COMPLETED


typedef BOOL IP_PROJECTION_INFO, *PIP_PROJECTION_INFO;

typedef BOOL IPX_PROJECTION_INFO, *PIPX_PROJECTION_INFO;

typedef struct _NETBIOS_PROJECTION_INFO
{
    BOOL fProject;
    WORD cNames;
    NAME_STRUCT Names[MAX_INIT_NAMES];
} NETBIOS_PROJECTION_INFO, *PNETBIOS_PROJECTION_INFO;


typedef struct _AUTH_PROJECTION_REQUEST_INFO
{
    IP_PROJECTION_INFO IpInfo;
    IPX_PROJECTION_INFO IpxInfo;
    NETBIOS_PROJECTION_INFO NetbiosInfo;
} AUTH_PROJECTION_REQUEST_INFO, *PAUTH_PROJECTION_REQUEST_INFO;


typedef struct _AUTH_CALLBACK_REQUEST_INFO
{
    BOOL fUseCallbackDelay;
    WORD CallbackDelay;       // Valid only if fUseCallbackDelay == TRUE
    CHAR szCallbackNumber[MAX_PHONE_NUMBER_LEN + 1];
} AUTH_CALLBACK_REQUEST_INFO, *PAUTH_CALLBACK_REQUEST_INFO;


typedef struct _AUTH_ACCT_OK_INFO
{
    BYTE szUserName[UNLEN + 1];
    BYTE szLogonDomain[DNLEN + 1];
    BOOL fAdvancedServer;
    HANDLE hLicense;
} AUTH_ACCT_OK_INFO, *PAUTH_ACCT_OK_INFO;


//
// This is the structure used in sending messages to the Supervisor
//
typedef struct _AUTH_MESSAGE
{
    WORD wMsgId;
    HPORT hPort;
    union
    {
        AUTH_FAILURE_INFO FailureInfo;
        AUTH_PROJECTION_REQUEST_INFO ProjectionRequest;
        AUTH_CALLBACK_REQUEST_INFO CallbackRequest;
        AUTH_ACCT_OK_INFO AcctOkInfo;
    };
} AUTH_MESSAGE, *PAUTH_MESSAGE;


#endif // _CLAUTH_


#endif // _SRVAUTH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ppp\auth\nt\ntauth.h ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    ntauth.h
//
// Description: 
//
// History:     Feb 11,1997	    NarenG		Created original version.
//

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ALLOCATE_GLOBALS
#define EXTERN
#else
#define EXTERN extern
#endif

#include <iaspolcy.h>
#include <iasext.h>

typedef enum
{
    RAS_IAS_START_ACCOUNTING,
    RAS_IAS_STOP_ACCOUNTING,
    RAS_IAS_INTERIM_ACCOUNTING,
    RAS_IAS_ACCOUNTING_ON,
    RAS_IAS_ACCOUNTING_OFF,
    RAS_IAS_ACCESS_REQUEST

} RAS_IAS_REQUEST_TYPE;

EXTERN 
DWORD g_dwTraceIdNt
#ifdef GLOBALS
    = INVALID_TRACEID;
#endif
;

EXTERN 
BOOL g_fInitialized
#ifdef GLOBALS
    = FALSE;
#endif
;

EXTERN
RAS_AUTH_ATTRIBUTE *
g_pServerAttributes 
#ifdef GLOBALS
    = NULL
#endif
;

EXTERN
DWORD *
g_hEventLog
#ifdef GLOBALS
    = NULL
#endif
;

EXTERN
HANDLE
g_hInstance
#ifdef GLOBALS
    = NULL
#endif
;

EXTERN
DWORD
g_LoggingLevel
#ifdef GLOBALS
    = 0
#endif
;

#define MaxCharsUnauthUser_c 100
EXTERN CHAR g_aszUnauthenticatedUser[MaxCharsUnauthUser_c+1];

#define TRACE_NTAUTH        (0x00010000|TRACE_USE_MASK|TRACE_USE_MSEC)

#define TRACE(a)            TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a )
#define TRACE1(a,b)         TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a,b )
#define TRACE2(a,b,c)       TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a,b,c )
#define TRACE3(a,b,c,d)     TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a,b,c,d )
#define TRACE4(a,b,c,d,e)   TracePrintfExA(g_dwTraceIdNt,TRACE_NTAUTH,a,b,c,d,e)

#define NtAuthLogWarning( LogId, NumStrings, lpwsSubStringArray )        \
    if ( g_LoggingLevel > 1 ) {                                          \
        RouterLogWarningW( g_hEventLog, LogId,                           \
                          NumStrings, lpwsSubStringArray, 0 ); }

DWORD
IASSendReceiveAttributes(
    IN  RAS_IAS_REQUEST_TYPE    RequestType,
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes,
    OUT DWORD *                 lpdwResultCode
);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ppp\auth\nt\ntauth.c ===
/********************************************************************/
/**               Copyright(c) 1995 Microsoft Corporation.	       **/
/********************************************************************/

//***
//
// Filename:    ntauth.c
//
// Description: Contains entrypoints to do NT back-end authentication for
//              ppp.
//
// History:     Feb 11,1997	    NarenG		Created original version.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <ntsamp.h>
#include <crypt.h>

#include <crypt.h>
#define INC_OLE2
#include <windows.h>
#include <lmcons.h>
#include <netlib.h>     // For NetpGetDomainNameEx
#include <lmapibuf.h>
#include <lmaccess.h>
#include <raserror.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>
#include <shlobj.h>
#include <dsclient.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <rasman.h>
#include <rasppp.h>
#include <mprerror.h>
#include <rasauth.h>
#include <mprlog.h>
#include <pppcp.h>
#include <rtutils.h>
#define INCL_RASAUTHATTRIBUTES
#define INCL_HOSTWIRE
#define INCL_MISC
#include <ppputil.h>
#define ALLOCATE_GLOBALS
#include "ntauth.h"
#include "resource.h"

//**
//
// Call:        RasAuthDllEntry
//
// Returns:     TRUE        - Success
//              FALSE       - Failure
//
// Description:
//
BOOL
RasAuthDllEntry(
    HANDLE hinstDll,
    DWORD  fdwReason,
    LPVOID lpReserved
)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            DisableThreadLibraryCalls( hinstDll );

            g_hInstance = hinstDll;

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            g_hInstance = NULL;

            break;
        }

        default:

            break;
    }

    return( TRUE );
}

//**
//
// Call:        RasAuthProviderInitialize
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAuthProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE *    pServerAttributes,
    IN  HANDLE                  hEventLog,
    IN  DWORD                   dwLoggingLevel
)
{
    DWORD           dwRetCode = NO_ERROR;
    HRESULT         hResult;
    NT_PRODUCT_TYPE NtProductType       = NtProductLanManNt;
    LPWSTR          lpwstrDomainNamePtr = NULL;
    BOOLEAN         fIsWorkgroupName    = FALSE;

    //
    // If already initalized, we return
    //

    if ( g_fInitialized )
    {
        return( NO_ERROR );
    }

    g_dwTraceIdNt = INVALID_TRACEID;

    setlocale( LC_ALL,"" );

    g_dwTraceIdNt = TraceRegisterA( "RASAUTH" );

    hResult = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED( hResult ) )
    {
        return( HRESULT_CODE( hResult ) );
    }

    hResult = InitializeIas( TRUE );

    if ( FAILED( hResult ) )
    {
        dwRetCode = HRESULT_CODE( hResult );

        TRACE1("Initialize Ias failed with %d", dwRetCode );

        CoUninitialize();

        return( dwRetCode );
    }

    g_hEventLog = hEventLog;

    g_LoggingLevel = dwLoggingLevel;

    if (!LoadString(g_hInstance, IDS_UNAUTHENTICATED_USER,
            g_aszUnauthenticatedUser, MaxCharsUnauthUser_c))
    {
        g_aszUnauthenticatedUser[0] = 0;
    }

    g_fInitialized = TRUE;

    TRACE("RasAuthProviderInitialize succeeded");

    return( NO_ERROR );
}

//**
//
// Call:        RasAuthProviderTerminate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAuthProviderTerminate(
    VOID
)
{
    //
    // If already terminated, we return
    //

    if ( !g_fInitialized )
    {
        return( NO_ERROR );
    }

    g_fInitialized = FALSE;

    if ( g_dwTraceIdNt != INVALID_TRACEID )
    {
        TraceDeregisterA( g_dwTraceIdNt );
    }

    ShutdownIas();

    CoUninitialize();

    TRACE("RasAuthTerminate succeeded");

    return( NO_ERROR );
}

//**
//
// Call:        RasAcctProviderInitialize
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderInitialize(
    IN  RAS_AUTH_ATTRIBUTE *    pServerAttributes,
    IN  HANDLE                  hEventLog,
    IN  DWORD                   dwLoggingLevel
)
{
    RAS_AUTH_ATTRIBUTE *    pOutAttributes = NULL;
    DWORD                   dwResultCode;

    DWORD dwRetCode =  RasAuthProviderInitialize( pServerAttributes, 
                                                  hEventLog, 
                                                  dwLoggingLevel );

    if ( dwRetCode == NO_ERROR )
    {
        dwRetCode = IASSendReceiveAttributes( RAS_IAS_ACCOUNTING_ON,
                                              pServerAttributes,
                                              &pOutAttributes,
                                              &dwResultCode );

        if ( pOutAttributes != NULL )
        {
            RasAuthAttributeDestroy( pOutAttributes );
        }

        if ( dwRetCode == NO_ERROR )
        {
            //
            // Make a copy of the Server attributes
            //

            g_pServerAttributes = RasAuthAttributeCopy( pServerAttributes );

            if ( g_pServerAttributes == NULL )
            {
                dwRetCode = GetLastError();
            }
        }
    }

    g_hEventLog = hEventLog;

    g_LoggingLevel = dwLoggingLevel;

    return( dwRetCode );
}

//**
//
// Call:        RasAcctProviderTerminate
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderTerminate(
    VOID
)
{
    RAS_AUTH_ATTRIBUTE *    pOutAttributes = NULL;
    DWORD                   dwResultCode;

    IASSendReceiveAttributes( RAS_IAS_ACCOUNTING_OFF,
                              g_pServerAttributes,
                              &pOutAttributes,
                              &dwResultCode );

    if ( pOutAttributes != NULL )
    {
        RasAuthAttributeDestroy( pOutAttributes );
    }

    if ( g_pServerAttributes != NULL )
    {
        RasAuthAttributeDestroy( g_pServerAttributes );

        g_pServerAttributes = NULL;
    }

    RasAuthProviderTerminate();

    return( NO_ERROR );
}

//**
//
// Call:        RasAcctProviderStartAccounting
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderStartAccounting(
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes
)
{
    DWORD dwResultCode = NO_ERROR;

    TRACE("RasStartAccounting called");

    return( IASSendReceiveAttributes( RAS_IAS_START_ACCOUNTING,
                                      pInAttributes,
                                      ppOutAttributes,
                                      &dwResultCode ) );
}

//**
//
// Call:        RasAcctProviderStopAccounting
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderStopAccounting(
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes
)
{
    DWORD dwResultCode = NO_ERROR;

    TRACE("RasStopAccounting called");

    return( IASSendReceiveAttributes( RAS_IAS_STOP_ACCOUNTING,
                                      pInAttributes,
                                      ppOutAttributes,
                                      &dwResultCode ) );
}

//**
//
// Call:        RasAcctConfigChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Reloads config information dynamically
//
DWORD APIENTRY
RasAcctConfigChangeNotification(
    IN  DWORD                   dwLoggingLevel
)
{
    TRACE("RasAcctConfigChangeNotification called");

    g_LoggingLevel = dwLoggingLevel;

    return( NO_ERROR );
}

//**
//
// Call:        RasAcctProviderInterimAccounting
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
DWORD APIENTRY
RasAcctProviderInterimAccounting(
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes
)
{
    DWORD dwResultCode = NO_ERROR;

    TRACE("RasInterimAccounting called");

    return( IASSendReceiveAttributes( RAS_IAS_INTERIM_ACCOUNTING,
                                      pInAttributes,
                                      ppOutAttributes,
                                      &dwResultCode ) );
}

//**
//
// Call:        RasAuthConfigChangeNotification
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Reloads config information dynamically
//
DWORD APIENTRY
RasAuthConfigChangeNotification(
    IN  DWORD                   dwLoggingLevel
)
{
    TRACE("RasAuthConfigChangeNotification called");

    g_LoggingLevel = dwLoggingLevel;

    return( NO_ERROR );
}

//**
//
// Call:        MapIasRetCodeToRasError
//
// Description: Maps IAS_RETCODE to an error in raserror.h or mprerror.h
//
DWORD
MapIasRetCodeToRasError(
    IN  LONG    lFailureReason
)
{
    DWORD   dwError;

    switch ( lFailureReason )
    {
    case IAS_CHANGE_PASSWORD_FAILURE:
        dwError = ERROR_CHANGING_PASSWORD;
        break;
    
    case IAS_ACCOUNT_DISABLED:
        dwError = ERROR_ACCT_DISABLED;
        break;

    case IAS_ACCOUNT_EXPIRED:
        dwError = ERROR_ACCT_EXPIRED;
        break;

    case IAS_INVALID_LOGON_HOURS:
    case IAS_INVALID_DIALIN_HOURS:
        dwError = ERROR_DIALIN_HOURS_RESTRICTION;
        break;

    case IAS_DIALIN_DISABLED:
        dwError = ERROR_NO_DIALIN_PERMISSION;
        break;

    case IAS_SESSION_TIMEOUT:
        dwError = ERROR_AUTH_SERVER_TIMEOUT;
        break;

    case IAS_INVALID_PORT_TYPE:
        dwError = ERROR_ALLOWED_PORT_TYPE_RESTRICTION;
        break;

    case IAS_INVALID_AUTH_TYPE:
        dwError = ERROR_AUTH_PROTOCOL_RESTRICTION;
        break;

    default:
        dwError = ERROR_AUTHENTICATION_FAILURE;
        break;
    }

    return( dwError );
}

//**
//
// Call:        IASSendReceiveAttributes
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description: Will send attributes to and receive attributes from IAS
//
DWORD
IASSendReceiveAttributes(
    IN  RAS_IAS_REQUEST_TYPE    RequestType,
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes,
    OUT DWORD *                 lpdwResultCode
)
{
    DWORD                   dwIndex;
    HRESULT                 hResult;
    LONG                    IasResponse;
    LONG                    IasRequest;
    DWORD                   dwInAttributeCount      = 0;
    DWORD                   dwTotalInAttributeCount = 0;
    PIASATTRIBUTE *         ppInIasAttributes       = NULL;
    DWORD                   dwOutAttributeCount     = 0;
    PIASATTRIBUTE *         ppOutIasAttributes      = NULL;
    IAS_INET_ADDR           InetAddr                = 0;
    RAS_AUTH_ATTRIBUTE *    pNASIdentifier          = NULL;
    RAS_AUTH_ATTRIBUTE *    pCallingStationId       = NULL;
    DWORD                   dwLength;
    PVOID                   pValue;
    BOOL                    fConvertToAnsi;
    DWORD                   dwRetCode               = NO_ERROR;
    LPSTR                   lpsUserName             = g_aszUnauthenticatedUser;
    LONG                    lFailureReason;

    RasAuthAttributesPrint( g_dwTraceIdNt, TRACE_NTAUTH, pInAttributes );

    switch( RequestType )
    {
    case RAS_IAS_START_ACCOUNTING:
    case RAS_IAS_STOP_ACCOUNTING:
    case RAS_IAS_INTERIM_ACCOUNTING:
    case RAS_IAS_ACCOUNTING_ON:
    case RAS_IAS_ACCOUNTING_OFF:

        IasRequest = IAS_REQUEST_ACCOUNTING;
        break;

    case RAS_IAS_ACCESS_REQUEST:
        IasRequest = IAS_REQUEST_ACCESS_REQUEST;
        break;

    default:
        ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    *ppOutAttributes = NULL;
    *lpdwResultCode  = ERROR_AUTHENTICATION_FAILURE;

    hResult = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED( hResult ) )
    {
        return( HRESULT_CODE( hResult ) );
    }

    do
    {
        //
        // First findout how many attributes there are
        //

        for ( dwInAttributeCount = 0;
              pInAttributes[dwInAttributeCount].raaType != raatMinimum;
              dwInAttributeCount++);

        dwTotalInAttributeCount = dwInAttributeCount;

        if ( IasRequest == IAS_REQUEST_ACCOUNTING )
        {
            //
            // Add one more of the Acct-Status-Type attribute
            //

            dwTotalInAttributeCount++;
        }

        //
        // Add two more for Client-IP-Address and Client-Friendly-Name
        //

        dwTotalInAttributeCount += 2;

        //
        // Now allocate an array of pointer to attributes
        //

        ppInIasAttributes =
            (PIASATTRIBUTE *)
                MemAllocIas(sizeof(PIASATTRIBUTE) * dwTotalInAttributeCount);

        if ( ppInIasAttributes == NULL )
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;

            break;
        }

        ZeroMemory( ppInIasAttributes,
                    sizeof(PIASATTRIBUTE) * dwTotalInAttributeCount );

        //
        // Now allocate the attributes
        //

        hResult = AllocateAttributes( dwTotalInAttributeCount,
                                        ppInIasAttributes );

        if ( FAILED( hResult ) )
        {
            dwRetCode = HRESULT_CODE( hResult );

            break;
        }

        //
        // Convert to IAS attributes
        //

        for ( dwIndex = 0; dwIndex < dwInAttributeCount; dwIndex++ )
        {
            switch( pInAttributes[dwIndex].raaType )
            {
            case raatNASPort:
            case raatServiceType:
            case raatFramedProtocol:

                //
                // arap connection?  it's an access-request
                //

                if ((pInAttributes[dwIndex].raaType == raatFramedProtocol) &&
                    (pInAttributes[dwIndex].Value == (LPVOID)3))
                {
                    IasRequest = IAS_REQUEST_ACCESS_REQUEST;
                }

                //
                // fall through
                //

            case raatFramedRouting:
            case raatFramedMTU:
            case raatFramedCompression:
            case raatLoginIPHost:
            case raatLoginService:
            case raatLoginTCPPort:
            case raatFramedIPXNetwork:
            case raatSessionTimeout:
            case raatIdleTimeout:
            case raatTerminationAction:
            case raatFramedAppleTalkLink:
            case raatFramedAppleTalkNetwork:
            case raatNASPortType:
            case raatPortLimit:
            case raatTunnelType:
            case raatTunnelMediumType:
            case raatAcctStatusType:
            case raatAcctDelayTime:
            case raatAcctInputOctets:
            case raatAcctOutputOctets:
            case raatAcctAuthentic:
            case raatAcctSessionTime:
            case raatAcctInputPackets:
            case raatAcctOutputPackets:
            case raatAcctTerminateCause:
            case raatAcctLinkCount:
            case raatFramedIPNetmask:
            case raatPrompt:
            case raatPasswordRetry:
            case raatARAPZoneAccess:
            case raatARAPSecurity:
            case raatAcctEventTimeStamp:

                (ppInIasAttributes[dwIndex])->Value.itType = IASTYPE_INTEGER;
                (ppInIasAttributes[dwIndex])->Value.Integer =
                                    PtrToUlong(pInAttributes[dwIndex].Value);
                break;

            case raatNASIPAddress:

                InetAddr = PtrToUlong(pInAttributes[dwIndex].Value);

                //
                // Fall through
                //

            case raatFramedIPAddress:

                (ppInIasAttributes[dwIndex])->Value.itType = IASTYPE_INET_ADDR;
                (ppInIasAttributes[dwIndex])->Value.InetAddr =
                                    PtrToUlong(pInAttributes[dwIndex].Value);

                break;

            case raatUserPassword:
            case raatMD5CHAPPassword:
            case raatARAPPassword:
            case raatEAPMessage:


                //
                // If any passwords are present then we want authentication
                // as well.
                //

                IasRequest = IAS_REQUEST_ACCESS_REQUEST;

                //
                // Fall thru
                //

            case raatVendorSpecific:

                //
                // Is this the MS-CHAP password ?
                //

                if ( ( pInAttributes[dwIndex].raaType == raatVendorSpecific ) &&
                     ( pInAttributes[dwIndex].dwLength >= 8 ) )
                {
                    //
                    // Does the Vendor Id match Microsoft's ?
                    //

                    if ( WireToHostFormat32(
                            (PBYTE)(pInAttributes[dwIndex].Value)) == 311 )
                    {
                        //
                        // Does the vendor type match MS-CHAP password's,
                        // change pasword V1 or V2 ?
                        //

                        switch( *(((PBYTE)(pInAttributes[dwIndex].Value))+4) )
                        {
                            //
                            // is this is an MS-CHAP password?
                            //
                        case 1:
                        case 3:
                        case 4:


                            //
                            // is this is an ARAP password?
                            //
                        case raatARAPOldPassword:
                        case raatARAPNewPassword:

                            IasRequest = IAS_REQUEST_ACCESS_REQUEST;

                            break;

                        default:
                            break;
                        }
                    }
                }

                //
                // Fall thru
                //

            default:

                if ( pInAttributes[dwIndex].raaType == raatUserName )
                {
                    //
                    // Save pointer for logging purposes
                    //
    
                    lpsUserName = (PBYTE)(pInAttributes[dwIndex].Value);
                }

                {
                    DWORD dwLength1 = pInAttributes[dwIndex].dwLength;
                    PBYTE pValue1   = (PBYTE)MemAllocIas( dwLength1 );

                    if ( pValue1 == NULL )
                    {
                        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }

                    if ( raatNASIdentifier == pInAttributes[dwIndex].raaType )
                    {
                        pNASIdentifier = pInAttributes + dwIndex;
                    }

                    if ( raatCallingStationId == pInAttributes[dwIndex].raaType )
                    {
                        pCallingStationId = pInAttributes + dwIndex;
                    }

                    (ppInIasAttributes[dwIndex])->Value.itType =
                                                           IASTYPE_OCTET_STRING;

                    (ppInIasAttributes[dwIndex])->Value.OctetString.dwLength =
                                                            dwLength1;

                    (ppInIasAttributes[dwIndex])->Value.OctetString.lpValue =
                                                            pValue1;

                    CopyMemory( pValue1,
                                (PBYTE)(pInAttributes[dwIndex].Value),
                                dwLength1 );

                    break;
                }
            }

            if ( dwRetCode != NO_ERROR )
            {
                break;
            }

            //
            // Set the attribute Id
            //

            (ppInIasAttributes[dwIndex])->dwId = pInAttributes[dwIndex].raaType;

            TRACE1( "Inserting attribute type %d",
                     pInAttributes[dwIndex].raaType );
        }

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        //
        // If accounting type of request then we need to add the
        // Acct-Status-Type attribute
        //

        if ( IasRequest == IAS_REQUEST_ACCOUNTING )
        {
            (ppInIasAttributes[dwIndex])->dwId         = raatAcctStatusType;
            (ppInIasAttributes[dwIndex])->Value.itType = IASTYPE_INTEGER;

            switch ( RequestType )
            {
            case RAS_IAS_START_ACCOUNTING:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)1;
                break;

            case RAS_IAS_STOP_ACCOUNTING:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)2;
                break;

            case RAS_IAS_INTERIM_ACCOUNTING:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)3;
                break;

            case RAS_IAS_ACCOUNTING_ON:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)7;
                break;

            case RAS_IAS_ACCOUNTING_OFF:

                (ppInIasAttributes[dwIndex])->Value.Integer = (DWORD)8;
                break;
            }

            dwIndex++;
        }

        //
        // Insert Client-IP-Address and Client-Friendly-Name
        //

        if ( 0 != InetAddr )
        {
            (ppInIasAttributes[dwIndex])->dwId = 4108; // Client-IP-Address
            (ppInIasAttributes[dwIndex])->Value.itType = IASTYPE_INET_ADDR;
            (ppInIasAttributes[dwIndex])->Value.InetAddr = InetAddr;
            dwIndex++;

            TRACE( "Inserting attribute type 4108" );
        }
        else
        {
            //
            // Decrement the count since we added this to count
            // before
            //
            dwTotalInAttributeCount--;
        }

        if ( NULL != pNASIdentifier )
        {
            DWORD dwLength1 = pNASIdentifier->dwLength;
            PBYTE pValue1   = (PBYTE)MemAllocIas( dwLength1 );

            if ( pValue1 == NULL )
            {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            (ppInIasAttributes[dwIndex])->dwId = 4128; // Client-Friendly-Name

            (ppInIasAttributes[dwIndex])->Value.itType =
                                                    IASTYPE_OCTET_STRING;

            (ppInIasAttributes[dwIndex])->Value.OctetString.dwLength =
                                                    dwLength1;

            (ppInIasAttributes[dwIndex])->Value.OctetString.lpValue =
                                                    pValue1;

            CopyMemory( pValue1,
                        (PBYTE)(pNASIdentifier->Value),
                        dwLength1 );

            dwIndex++;

            TRACE( "Inserting attribute type 4128" );
        }
        else
        {
            //
            // Decrement the count since we added this to the count
            // before.
            //
            dwTotalInAttributeCount--;
        }

        //
        //  process the filled attributes
        //

        hResult = DoRequest(
                            dwTotalInAttributeCount,
                            ppInIasAttributes,
                            &dwOutAttributeCount,
                            &ppOutIasAttributes,
                            IasRequest,
                            &IasResponse,
                            IAS_PROTOCOL_RAS,
                            &lFailureReason,
                            TRUE );

        if ( FAILED( hResult ) )
        {
            dwRetCode = HRESULT_CODE( hResult );

            TRACE1( "IAS->DoRequest failed with %d", dwRetCode );

            break;
        }

        switch( IasResponse )
        {
        case IAS_RESPONSE_ACCESS_ACCEPT:

            TRACE( "IASResponse = ACCESS_ACCEPT");

            *lpdwResultCode = NO_ERROR;

            break;

        case IAS_RESPONSE_ACCESS_CHALLENGE:

            TRACE( "IASResponse = ACCESS_CHALLENGE");

            *lpdwResultCode = NO_ERROR;

            break;

        case IAS_RESPONSE_DISCARD_PACKET:

            TRACE1( "IASResponse = DISCARD_PACKET. Failurereason=0x%x",
                    lFailureReason);

            *lpdwResultCode = MapIasRetCodeToRasError( lFailureReason );
            dwRetCode = *lpdwResultCode;

            break;

        case IAS_RESPONSE_ACCESS_REJECT:

            {
                WCHAR  *lpwsSubStringArray[3];
                WCHAR  wchInsertionString[13];
                WCHAR  wchUserName[UNLEN+1];
                WCHAR  wchCallerId[100];

                MultiByteToWideChar( CP_ACP,
                                     0,
                                     lpsUserName,
                                     -1,
                                     wchUserName,
                                     UNLEN+1 );

                wsprintfW( wchInsertionString, L"%%%%%lu", lFailureReason + 0x1000 );


                if ( pCallingStationId != NULL )
                {
                    lpwsSubStringArray[0] = wchUserName;
                    lpwsSubStringArray[1] = wchCallerId;
                    lpwsSubStringArray[2] = wchInsertionString;

                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         (PBYTE)(pCallingStationId->Value),
                                         -1,
                                         wchCallerId,
                                         100 );

                    NtAuthLogWarning( ROUTERLOG_NTAUTH_FAILURE_EX, 3, lpwsSubStringArray);
                }
                else
                {
                    lpwsSubStringArray[0] = wchUserName;
                    lpwsSubStringArray[1] = wchInsertionString;

                    NtAuthLogWarning( ROUTERLOG_NTAUTH_FAILURE, 2, lpwsSubStringArray );
                }

                *lpdwResultCode = MapIasRetCodeToRasError( lFailureReason );
            }

        default:

            TRACE2( "IASResponse = %d, FailureReason = 0x%x",
                     IasResponse, lFailureReason );

            break;
        }

        if ( dwRetCode != NO_ERROR )
        {
            break;
        }

        if ( dwOutAttributeCount > 0 )
        {
            //
            // Convert from IAS attributes
            //

            *ppOutAttributes = RasAuthAttributeCreate( dwOutAttributeCount );

            if ( *ppOutAttributes == NULL )
            {
                dwRetCode = GetLastError();

                break;
            }

            for ( dwIndex = 0; dwIndex < dwOutAttributeCount; dwIndex++ )
            {
                IASVALUE IasValue = (ppOutIasAttributes[dwIndex])->Value;

                fConvertToAnsi = FALSE;

                switch ( IasValue.itType )
                {
                case IASTYPE_INTEGER:

                    dwLength = sizeof( DWORD );
                    pValue = (LPVOID) ULongToPtr(IasValue.Integer);
                    break;

                case IASTYPE_BOOLEAN:

                    dwLength = sizeof( DWORD );
                    pValue = (LPVOID)ULongToPtr(IasValue.Boolean);
                    break;

                case IASTYPE_ENUM:

                    dwLength = sizeof( DWORD );
                    pValue = (LPVOID)ULongToPtr(IasValue.Enumerator);
                    break;

                case IASTYPE_INET_ADDR:

                    dwLength = sizeof( DWORD );
                    pValue = (LPVOID)ULongToPtr(IasValue.InetAddr);
                    break;

                case IASTYPE_STRING:

                    if ( NULL != IasValue.String.pszAnsi )
                    {
                        dwLength = strlen( IasValue.String.pszAnsi );
                        pValue = (LPVOID)( IasValue.String.pszAnsi );
                    }
                    else if ( NULL != IasValue.String.pszWide )
                    {
                        dwLength = wcslen( IasValue.String.pszWide );
                        pValue = (LPVOID)( IasValue.String.pszWide );
                        fConvertToAnsi = TRUE;
                    }
                    else
                    {
                        continue;
                    }

                    break;

                case IASTYPE_OCTET_STRING:

                    dwLength = IasValue.OctetString.dwLength;
                    pValue = IasValue.OctetString.lpValue;
                    break;

                default:

                    continue;
                }

                dwRetCode =
                    RasAuthAttributeInsert(
                        dwIndex,
                        *ppOutAttributes,
                        (ppOutIasAttributes[dwIndex])->dwId,
                        fConvertToAnsi,
                        dwLength,
                        pValue );

                if ( dwRetCode != NO_ERROR )
                {
                    break;
                }

                TRACE1( "Received attribute %d",
                         (ppOutIasAttributes[dwIndex])->dwId );
            }

            RasAuthAttributesPrint( g_dwTraceIdNt, TRACE_NTAUTH,
                *ppOutAttributes );
        }

    } while( FALSE );

    //
    //  Free all the IAS attributes allocated earlier
    //

    if ( ppInIasAttributes != NULL )
    {
        if(NO_ERROR == dwRetCode)
        {
            FreeAttributes( dwTotalInAttributeCount, ppInIasAttributes );
        }

        MemFreeIas( ppInIasAttributes );
    }

    if ( ppOutIasAttributes != NULL )
    {
        FreeAttributes( dwOutAttributeCount, ppOutIasAttributes );

        MemFreeIas( ppOutIasAttributes );
    }

    if ( dwRetCode != NO_ERROR )
    {
        if ( *ppOutAttributes != NULL )
        {
            RasAuthAttributeDestroy( *ppOutAttributes );

            *ppOutAttributes = NULL;
        }
    }

    CoUninitialize();

    return( dwRetCode );
}

//**
//
// Call:        RasAuthProviderAuthenticateUser
//
// Returns:     NO_ERROR         - Success
//              Non-zero returns - Failure
//
// Description:
//
//
DWORD APIENTRY
RasAuthProviderAuthenticateUser(
    IN  RAS_AUTH_ATTRIBUTE *    pInAttributes,
    OUT PRAS_AUTH_ATTRIBUTE *   ppOutAttributes,
    OUT DWORD *                 lpdwResultCode
)
{
    *ppOutAttributes = NULL;
    *lpdwResultCode  = NO_ERROR;

    TRACE("RasAuthProviderAuthent