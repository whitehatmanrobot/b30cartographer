an V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
    int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
        V0X = V0X << 1;
        V0Y = V0Y << 1;
    } else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
        V0X = V0X + V1X;
        V0Y = V0Y + V1Y;
    }
    if (V2On) {
        V2X = V2X << 1;
        V2Y = V2Y << 1;
    } else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
        V2X = V2X + V1X;
        V2Y = V2Y + V1Y;
    }
    V1X = V1X << 1;
    V1Y = V1Y << 1;
    // at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
    // with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
    // its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
    // which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
    // likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
    uDen = V0X - 2*V1X + V2X;
    if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
        uNum = V0X - V1X;
        u1Num = V2X - V1X;
        uDen2 = uDen*uDen;
        xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
        yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;
    //  if we're calculating the left extremal point, we floor the result for the probing line
    //  not to start inside the contour as a result of rounding. Starting on the contour should be fine,
    //  as this is handled in CurveTransitions, which does not include the lower end of the interval.
        *extrX = min ? (long)(xNum/uDen2) : (long)((xNum + uDen2 - 1)/uDen2);
    //  symmetrical rounding here
        *extrY = yNum >= 0 ? (long)((yNum + uDen2)/uDen2) : -(long)((uDen2 - yNum)/uDen2);
    } else { // can't solve it
        *extrX = V1X;
        *extrY = V1Y;
    }
} // CalculateXExtremum

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
    int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
        V0X = V0X << 1;
        V0Y = V0Y << 1;
    } else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
        V0X = V0X + V1X;
        V0Y = V0Y + V1Y;
    }
    if (V2On) {
        V2X = V2X << 1;
        V2Y = V2Y << 1;
    } else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
        V2X = V2X + V1X;
        V2Y = V2Y + V1Y;
    }
    V1X = V1X << 1;
    V1Y = V1Y << 1;
    // at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
    // with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
    // its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
    // which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
    // likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
    uDen = V0Y - 2*V1Y + V2Y;
    if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
        uNum = V0Y - V1Y;
        u1Num = V2Y - V1Y;
        uDen2 = uDen*uDen;
        xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
        yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;

        *extrY = min ? (long)(yNum/uDen2) : (long)((yNum + uDen2 - 1)/uDen2);
    //  symmetrical rounding here
        *extrX = xNum >= 0 ? (long)((xNum + uDen2)/uDen2) : -(long)((uDen2 - xNum)/uDen2);
    } else { // can't solve it
        *extrX = V1X;
        *extrY = V1Y;
    }
} // CalculateYExtremum

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1)
{
/* extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY,
    the coordinates returned in C0 and C1 are scaled by 2 */

    switch (extremumNumber) {
    case 0:
        /* line from minX to infinity */
        C0->x = extremum.x+1;
        C0->y = extremum.y;
        C1->x = -32768;
        C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
    case 1:
        /* line from maxX to infinity */
        C0->x = extremum.x-1;
        C0->y = extremum.y;
        C1->x = 32767;
        C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
    case 2:
        /* line from minY to infinity */
        C0->x = extremum.x;
        C0->y = extremum.y+1;
        C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
        C1->y = -32768;
        break;
    case 3:
        /* line from maxY to infinity */
        C0->x = extremum.x;
        C0->y = extremum.y-1;
        C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
        C1->y = 32767;
        break;
    default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, FindExtremaKnot, illegal case");
    }
}

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (C.x < Min->x) Min->x = C.x;
    if (B.y < Min->y) Min->y = B.y;
    if (C.y < Min->y) Min->y = C.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (C.x > Max->x) Max->x = C.x;
    if (B.y > Max->y) Max->y = B.y;
    if (C.y > Max->y) Max->y = C.y;
}

void MinMax2Vectors (Vector A,Vector B, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (B.y < Min->y) Min->y = B.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (B.y > Max->y) Max->y = B.y;
}

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement)
{
    int32 Contour;
    boolean bMisoriented;
    short knot, n, i, start, end, predKnot, succKnot;
    short extremumKnot[4];
    Vector extremum[4];
    long minX, maxX, minY, maxY;
    long distance0_1, distance0_2, distance0_3;
    uint16 extremaNumber2, extremaNumber3;

    for (Contour = 0; Contour < pElement->nc; Contour++)
    {
        pElement->fc[Contour] = 0;

        start = pElement->sp[Contour];
        end = pElement->ep[Contour];
        
        n = end - start + 1;

        if (n > 2) 
        {
            /* we are not interested in degenerated contours */

            /* look for exterma knots to decide which direction to look to increase our chance of getting the correct result even on bad fonts */

            /* we will look for the following extrema :
               extremumKnot = 0 : MinX
               extremumKnot = 1 : MaxX
               extremumKnot = 2 : MinY
               extremumKnot = 3 : MaxY */

            for (i = 0; i < 4; i++) extremumKnot[i] = -1;
            
            minX = minY = 0x7fffffff;
            maxX = maxY = 0x80000000;

            for (knot = 0; knot < n; knot++) {
                /* look for Min X */
                if (pElement->oox[start + knot] < minX || 
                    pElement->oox[start + knot] == minX && !pElement->onCurve[extremumKnot[0]] ||  // try to get an on-curve point at same x coord
                    pElement->oox[start + knot] == minX && pElement->onCurve[extremumKnot[0]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] < pElement->ooy[extremumKnot[0]]) {
                    extremumKnot[0] = start + knot;
                    minX = pElement->oox[extremumKnot[0]];
                    if (pElement->onCurve[extremumKnot[0]]) {
                        extremum[0].x = pElement->oox[extremumKnot[0]] << 1;
                        extremum[0].y = pElement->ooy[extremumKnot[0]] << 1;
                    } else {
                        predKnot = extremumKnot[0] == start ? end : extremumKnot[0] - 1;
                        succKnot = extremumKnot[0] == end ? start : extremumKnot[0] + 1;
                        CalculateXExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
                                            pElement->oox[extremumKnot[0]],pElement->ooy[extremumKnot[0]],
                                            pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[0].x,&extremum[0].y);
                    }
                }
                /* look for Max X */
                if (pElement->oox[start + knot] > maxX || 
                    pElement->oox[start + knot] == maxX && !pElement->onCurve[extremumKnot[1]] ||  // try to get an on-curve point at same x coord
                    pElement->oox[start + knot] == maxX && pElement->onCurve[extremumKnot[1]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] > pElement->ooy[extremumKnot[1]]) {
                    extremumKnot[1] = start + knot;
                    maxX = pElement->oox[extremumKnot[1]];
                    if (pElement->onCurve[extremumKnot[1]]) {
                        extremum[1].x = pElement->oox[extremumKnot[1]] << 1;
                        extremum[1].y = pElement->ooy[extremumKnot[1]] << 1;
                    } else {
                        predKnot = extremumKnot[1] == start ? end : extremumKnot[1] - 1;
                        succKnot = extremumKnot[1] == end ? start : extremumKnot[1] + 1;
                        CalculateXExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
                                            pElement->oox[extremumKnot[1]],pElement->ooy[extremumKnot[1]],
                                            pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[1].x,&extremum[1].y);
                        }
                }
                /* look for Min Y */
                if (pElement->ooy[start + knot] < minY || 
                    pElement->ooy[start + knot] == minY && !pElement->onCurve[extremumKnot[2]] ||  // try to get an on-curve point at same y coord
                    pElement->ooy[start + knot] == minY && pElement->onCurve[extremumKnot[2]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] > pElement->oox[extremumKnot[2]]) {
                    extremumKnot[2] = start + knot;
                    minY = pElement->ooy[extremumKnot[2]];
                    if (pElement->onCurve[extremumKnot[2]]) {
                        extremum[2].x = pElement->oox[extremumKnot[2]] << 1;
                        extremum[2].y = pElement->ooy[extremumKnot[2]] << 1;
                    } else {
                        predKnot = extremumKnot[2] == start ? end : extremumKnot[2] - 1;
                        succKnot = extremumKnot[2] == end ? start : extremumKnot[2] + 1;
                        CalculateYExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
                                            pElement->oox[extremumKnot[2]],pElement->ooy[extremumKnot[2]],
                                            pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[2].x,&extremum[2].y);
                    }
                }
                /* look for Max Y */
                if (pElement->ooy[start + knot] > maxY || 
                    pElement->ooy[start + knot] == maxY && !pElement->onCurve[extremumKnot[3]] ||  // try to get an on-curve point at same y coord
                    pElement->ooy[start + knot] == maxY && pElement->onCurve[extremumKnot[3]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] < pElement->oox[extremumKnot[3]]) {
                    extremumKnot[3] = start + knot;
                    maxY = pElement->ooy[extremumKnot[3]];
                    if (pElement->onCurve[extremumKnot[3]]) {
                        extremum[3].x = pElement->oox[extremumKnot[3]] << 1;
                        extremum[3].y = pElement->ooy[extremumKnot[3]] << 1;
                    } else {
                        predKnot = extremumKnot[3] == start ? end : extremumKnot[3] - 1;
                        succKnot = extremumKnot[3] == end ? start : extremumKnot[3] + 1;
                        CalculateYExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
                                            pElement->oox[extremumKnot[3]],pElement->ooy[extremumKnot[3]],
                                            pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[3].x,&extremum[3].y);
                    }
                }
            }

            /* diagonal distance, we don't need a precise distance */

            distance0_1 = MABS(pElement->oox[extremumKnot[1]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[1]] - pElement->ooy[extremumKnot[0]]);
            distance0_2 = MABS(pElement->oox[extremumKnot[2]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[2]] - pElement->ooy[extremumKnot[0]]);
            distance0_3 = MABS(pElement->oox[extremumKnot[3]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[3]] - pElement->ooy[extremumKnot[0]]);

            if (distance0_2 > distance0_3)
            {
                /* we will look at MinY */
                extremaNumber2 = 2;
                if (distance0_3 > distance0_1)
                {
                    /* we will look then at MaxY */
                    extremaNumber3 = 3;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            } else {
                /* we will look at MaxY */
                extremaNumber2 = 3;
                if (distance0_2 > distance0_1)
                {
                    /* we will look then at MinY */
                    extremaNumber3 = 2;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            }

            bMisoriented = Misoriented(Contour, 0 /* MinX */, extremumKnot[0], extremum[0], pElement);

            /* look in a second direction to check if same result 
               this additional work help weed out problems with bad fonts having self-intersecting
               or overlapping outlines */
            if (bMisoriented != Misoriented(Contour, extremaNumber2, extremumKnot[extremaNumber2], extremum[extremaNumber2], pElement))
            {
                /* we need to look in a third direction */
                bMisoriented = Misoriented(Contour, extremaNumber3, extremumKnot[extremaNumber3], extremum[extremaNumber3], pElement);
            }

                // at this point we store the orientation of the original component (original in the sense of before the composite code potentially
                // applies a mirroring), such that the concertina code can work on the component w/o having to know about composite transformations
                if (bMisoriented) pElement->fc[Contour] |= OUTLINE_MISORIENTED;
        }
    }
}

boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement)
/* we will check the coutour orientation at the following extrema :
   extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY */

{
    LinkColor color,orientation;
    short predKnot,cont,knot,start,iter,end,n;
    long parity;
    Vector V[3],D[2],C[2],W[3],Wi;
    boolean on[3];

    short dirChange = 0;      
    
    start = pElement->sp[contour];
    end = pElement->ep[contour];
    n = end - start + 1;

    // here we determine the straight line that runs from the extreme of the contour to infinity, to be used below.
    SetLineToInfinity(extremumNumber, extremum, &C[0], &C[1]);
    
    // find out the current orientation of the contour
    // to do so first determine what kinds of turns we make at each knot
    orientation = linkBlack; // assume as default

    knot = extremumKnot - start;
    predKnot = (knot+n-1)%n;

    V[0].x = pElement->oox[start+predKnot]; V[1].x = pElement->oox[start+knot];
    V[0].y = pElement->ooy[start+predKnot]; V[1].y = pElement->ooy[start+knot];
    D[0] = SubV(V[1],V[0]);
    for (iter = 0; iter < n && !dirChange; iter++) {
        V[2].x = pElement->oox[start + (knot + 1)%n];
        V[2].y = pElement->ooy[start + (knot + 1)%n];
        if (NotSameKnot(V[1],V[2])) {
            D[1] = SubV(V[2],V[1]);
            dirChange = ComputeSign(D[0].x, D[0].y, D[1].x, D[1].y);
            V[0] = V[1]; V[1] = V[2]; D[0] = D[1];
        }
        knot = (knot + 1)%n;
    }

    if (iter < n && dirChange > 0)
    {
        orientation = linkWhite; /* counter clockwise */
    }
    
    // now find out what the orientation of the contour should really be
    // to do so we intersect the above probing line with all other contours.
    // If the number of intersections is odd, we have started inside, else outside.
    // if this doesn't correspond to the contour orientation determined above, then we're misoriented.
    // The loops below follow the same pattern used for Contour::Draw but are separate due to different underlying data structure.
    // Notice that this doesn't work for overlapping or self-intersecting contours. They're against the TT laws...
    parity = 0;
    for (cont = 0; cont < pElement->nc; cont++) {
        if (cont != contour) 
        /* we are not interested by the intersections of the contour with itself, optimization */
        {
            start = pElement->sp[cont];
            end = pElement->ep[cont];
            n = end - start + 1;

            if (n > 2) 
            {
                /* we are not interested in degenerated contours */
                W[1].x = pElement->oox[start] << 1;
                W[1].y = pElement->ooy[start] << 1;
                on[1] = pElement->onCurve[start];
                if (!on[1]) { // we start amidst a curve => get curve start point
                    W[0].x = pElement->oox[end] << 1;
                    W[0].y = pElement->ooy[end] << 1;
                    on[0] = pElement->onCurve[end];
                    if (!on[0]) { // curve start point is implied on-curve point => compute
                        W[0] = ShrV(AddV(W[0],W[1]),1);
                    }
                }
                knot = start;
                do {
                    knot = knot == end ? start : knot + 1;
                    W[2].x = pElement->oox[knot] << 1;
                    W[2].y = pElement->ooy[knot] << 1;
                    on[2] = pElement->onCurve[knot];
                    switch (on[1] << 1 | on[2]) {
                        case 3: // on---on => start and end a line => intersect with line
                            if (NotSameKnot(W[1],W[2]))
                            {
                            /* check bounding box before computing the intersection for performance */
                                if (CheckBoundingBoxSegment(C[0],W[1],W[2],extremumNumber))
                                {
                                    parity += CurveTransitionsSegment(C[0],C[1],W[1],W[2]); // repeating first vertex makes Bzier curve a line...
                                }
                            }
                            break;
                        case 2: // on---off => start a curve => intersect with nothing
                            W[0] = W[1];
                            break;
                        case 1: // off---on => end a curve => intersect with the curve
                            if (NotSameKnot(W[0],W[2])) 
                            {
                                /* check bounding box before computing the intersection for performance */
                                if (CheckBoundingBoxCurve(C[0],W[0],W[1],W[2],extremumNumber))
                                {
                                    parity += CurveTransitions(C[0],C[1],W[0],W[1],W[2]);
                                }
                            }
                            break;
                        case 0: // off---off => end a curve => intersect with the curve; then start a curve => intersect with nothing
                            Wi = ShrV(AddV(W[1],W[2]),1);
                            if (NotSameKnot(W[0],Wi))
                            {
                                if (CheckBoundingBoxCurve(C[0],W[0],W[1],Wi,extremumNumber))
                                {
                                    parity += CurveTransitions(C[0],C[1],W[0],W[1],Wi);
                                }
                            }
                            W[0] = Wi;
                            break;
                    }
                    W[1] = W[2]; on[1] = on[2];
                } while (knot != start);
            }
        }
    }
    color = parity & 1 ? linkBlack : linkWhite;

    return color == orientation; // cw (black) contours should have white to their left, and v.v., else they're oriented the wrong way round
} // Misoriented

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
    void *              pvGlobalGS,
    void *              pvGlobalGSSubPixel)
{
    fnt_GlobalGraphicStateType *globalGS, *globalGSSubPixel;
    int32 i;

    globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
    globalGSSubPixel = (fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel;

    for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
    {
        globalGSSubPixel->funcDef[i] = globalGS->funcDef[i];

    }

    globalGSSubPixel->instrDefCount = globalGS->instrDefCount;

    for (i = 0; i < globalGS->instrDefCount; i++)
    {
        globalGSSubPixel->instrDef[i] = globalGS->instrDef[i];

    }
    globalGSSubPixel->subPixelCompatibilityFlags = globalGS->subPixelCompatibilityFlags;

    globalGSSubPixel->numDeltaFunctionsDetected = globalGS->numDeltaFunctionsDetected;
    for (i = 0; i < globalGSSubPixel->numDeltaFunctionsDetected; i++)
        globalGSSubPixel->deltaFunction[i] = globalGS->deltaFunction[i];
}


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;
    scl_ScaleToCompatibleWidth(pElement, fxCompatibleWidthScale);
}


FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;
    scl_AdjustCompatibleMetrics(pElement, horTranslation, newDevAdvanceWidthX);
}

FS_PUBLIC void  fsg_CalcDevHorMetrics(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6 *           pDevAdvanceWidthX,
    F26Dot6 *           pDevLeftSideBearingX,
    F26Dot6 *           pDevRightSideBearingX)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX);

}

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
    fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6 *           pDevAdvanceWidthX,
    F26Dot6 *           pDevLeftSideBearingX,
    F26Dot6 *           pDevRightSideBearingX,
    F26Dot6 *           pNatAdvanceWidthX,
    F26Dot6 *           pNatLeftSideBearingX,
    F26Dot6 *           pNatRightSideBearingX)
{
    fnt_ElementType *   pElement;

    pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevNatHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX, pNatAdvanceWidthX, pNatLeftSideBearingX, pNatRightSideBearingX);

}

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\fshelper.h ===
/*
	 File:		 helper.h

	 Contains:	 Helper exports for Font Scaler

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1993. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		 <1>		 6/11/93	 GregH		Created.
*/

#ifndef FS_MATH_PROTO
#define FS_MATH_PROTO
#endif

int32 FS_MATH_PROTO ShortMulDiv(int32 a, int16 b, int16 c);	 /* (a*b)/c */

Fract FS_MATH_PROTO FracSqrt(Fract);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\interp.h ===
/*
	 File:		 interp.h

	 Contains:	 Exports and constants used by TrueType Interpreter

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):
*/

#include 	"fnterr.h"

#define NOGRIDFITFLAG   1
#define DEFAULTFLAG     2
#define TUNED4SPFLAG	4

FS_PUBLIC ErrorCode itrp_SetDefaults (
    void *  pvGlobalGS,
    Fixed   fxPixelDiameter);

FS_PUBLIC void  itrp_UpdateGlobalGS(
    void *              pvGlobalGS, /* GlobalGS                             */
    void *              pvCVT,      /* Pointer to control value table       */
    void *              pvStore,    /* Pointer to storage                   */
    void *              pvFuncDef,  /* Pointer to function defintions       */
    void *              pvInstrDef, /* Pointer to instruction definitions   */
    void *              pvStack,    /* Pointer to the stack                 */
	 LocalMaxProfile *	maxp,
    uint16              cvtCount,
    uint32              ulLengthFontProgram, /* Length of font program      */
    void *              pvFontProgram, /* Pointer to font program           */
    uint32              ulLengthPreProgram, /* Length of pre program        */
    void *              pvPreProgram, /* Pointer to pre program             */
	ClientIDType        clientID);    /* User ID Number                     */

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void itrp_InitializeData (void);
#endif

FS_PUBLIC ErrorCode   itrp_ExecuteFontPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecutePrePgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecuteGlyphPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    uint8 *             ptr,
    uint8 *             eptr,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl);

FS_PUBLIC boolean itrp_bApplyHints(
    void *      pvGlobalGS);

FS_PUBLIC void  itrp_QueryScanInfo(
    void *      pvGlobalGS,
    uint16 *    pusScanType,
    uint16 *    pusScanControl);

FS_PUBLIC void	itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8		bCompositeFlag);

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster);

FS_PUBLIC void  itrp_ResetMaxInstructionCounter(
	void *      pvGlobalGS);

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scbitmap.h ===
/*********************************************************************

	  scbitmap.h -- BitMap Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/19/93 deanb    fsc_CalcGrayRow added
	   6/10/93 deanb    fsc_InitializeBitMasks added
	   4/29/93 deanb    BLTCopy routine added
	   9/15/92 deanb    GetBit returns uint32 
	   8/17/92 deanb    GetBit, SetBit added 
	   7/27/92 deanb    ClearBitMap call added 
	   6/02/92 deanb    Row pointer, integer limits, no descriptor 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/15/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeBitMasks (
		void
);

FS_PUBLIC int32 fsc_ClearBitMap ( 
		uint32,             /* longs per bmp */
		uint32*             /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_BLTHoriz ( 
		int32,              /* x start */
		int32,              /* x stop */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_BLTCopy ( 
		uint32*,            /* source row pointer */
		uint32*,            /* destination row pointer */
		int32               /* long word counter */
);

FS_PUBLIC uint32 fsc_GetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_SetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_CalcGrayRow(
		GrayScaleParam*     /* pointer to param block */
);


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scale.h ===
/*

	Copyright:  (c) 1992-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				7/10/99  BeatS	Add support for native SP fonts, vertical RGB
	   <1>     02/21/97    CB   claudebe, scaled component in composite glyphs
	   <1>     12/14/95    CB   add private phantom points for vertical positionning
*/

/* total number of phantom points */

typedef enum { evenMult90DRotation = 0, oddMult90DRotation, arbitraryRotation } RotationParity;

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm);        /* OUT: Pixels Per Em       */

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem);                 /* Current units per Em     */

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT);

FS_PUBLIC void  scl_ScaleCVT (
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT);

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH); /* Non-scaled Advance Height    */

FS_PUBLIC void  scl_ScaleOldCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleOldPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution);

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParityParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset);        /* Y Offset             */

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset);        /* Y Offset             */


FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             xShift,
	F26Dot6             yShift);

FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,
	int16               sMaxPoints,
	int16               sMaxContours);

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType *   pElement,           /* Element              */
	uint16              usNumberOfPoints,   /* Number of Points     */
	uint16              usNumberOfContours);/* Number of Contours   */

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement);            /* Element pointer  */

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement);

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               pbyOutline);

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline);

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing);

FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine);

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine);

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth);

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight);

FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY);

FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement);

FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans);

FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement);   /* Element  */

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\sbit.c ===
/*********************************************************************

      sbit.c -- Embedded Bitmap Module

      (c) Copyright 1993-96  Microsoft Corp.  All rights reserved.

      04/01/96  claudebe    adding support for embedded grayscale bitmap
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/31/95  deanb       memset unrotated bitmap to zero
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      12/21/94  deanb       rotation and vertical metrics support
      08/02/94  deanb       pf26DevLSB->y calculated correctly
      01/05/94  deanb       Bitmap scaling added
      11/29/93  deanb       First cut 
 
**********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for inttodot6 macro */
        
#include    "sfntaccs.h"            /* sfnt access functions */
#include    "sbit.h"                /* own function prototypes */

/**********************************************************************/

#define MAX_BIT_INDEX	8			/* maximum bit index in a byte */

/*  Local structure */

typedef struct
{
    uint8*  pbySrc;                 /* unrotated source bitmap (as read) */
    uint8*  pbyDst;                 /* rotated destination bitmap (as returned) */
    uint16  usSrcBytesPerRow;       /* source bitmap width */
    uint16  usDstBytesPerRow;       /* destination bitmap width */
    uint16  usSrcX;                 /* source horiz pixel index */
    uint16  usSrcY;                 /* destination horiz pixel index */
    uint16  usDstX;                 /* source vert pixel index */
    uint16  usDstY;                 /* destination vert pixel index */
	uint16	usBitDepth;				/* bit depth of source/destination bitmap */
} 
CopyBlock;

/**********************************************************************/

/*  Local prototypes  */

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead, 
    uint8           *pbyExpand 
);

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap );

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
);

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
);

FS_PRIVATE void CopyBit(
    CopyBlock* pcb );

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);



/**********************************************************************/
/***                                                                ***/
/***                       SBIT Functions                           ***/
/***                                                                ***/
/**********************************************************************/

/*  reset sbit state structure to default values */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16		sBoldSimulHorShift,
     int16		sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
	)
{
    pSbit->usPpemX = usPpemX;                       /* save requested ppem */
    pSbit->usPpemY = usPpemY;
    pSbit->usRotation = usRotation;                 /* used later on */

    pSbit->bGlyphFound = FALSE;
    pSbit->usTableState = SBIT_UN_SEARCHED;
    pSbit->usEmResolution = usEmResolution;

    /* with embedded bitmap, the emboldement is done before the rotation */
    pSbit->uBoldSimulHorShift = MABS(sBoldSimulHorShift); 
    pSbit->uBoldSimulVertShift = MABS(sBoldSimulVertShift); 
    if ((pSbit->usRotation == 1) || (pSbit->usRotation == 3))
    {
        /* with embedded bitmap, the emboldement is done before the rotation */
        uint16 temp;
        temp = pSbit->uBoldSimulHorShift;
        pSbit->uBoldSimulHorShift = pSbit->uBoldSimulVertShift;
        pSbit->uBoldSimulVertShift = temp;
    }
    return NO_ERR;
}

/**********************************************************************/

/*  Determine whether a glyph bitmap exists */

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint16          usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode )         /* 0 = not found, 1 = bloc, 2 = bsca */
{    
    ErrorCode   ReturnCode;

    *pusFoundCode = 0;                              /* default */
    if (pSbit->usRotation > 3)
    {
        return NO_ERR;                              /* can't match a general rotation */
    }


    if (pSbit->usTableState == SBIT_UN_SEARCHED)    /* new trans - 1st glyph */
    {
        ReturnCode = sfac_SearchForStrike (         /* look for a strike */
            pClientInfo,
            pSbit->usPpemX, 
            pSbit->usPpemY, 
			usOverScale,            /* outline magnification requested */
			&pSbit->usBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
            &pSbit->usTableState,                   /* may set to BLOC or BSCA */
            &pSbit->usSubPpemX,                     /* if BSCA us this ppem */
            &pSbit->usSubPpemY,
            &pSbit->ulStrikeOffset );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
    }

	*pusBitDepth = pSbit->usBitDepth;

    if ((pSbit->usTableState == SBIT_BLOC_FOUND) || 
        (pSbit->usTableState == SBIT_BSCA_FOUND))
    {
        ReturnCode = sfac_SearchForBitmap (         /* now look for this glyph */
            pClientInfo,
            usGlyphCode,
            pSbit->ulStrikeOffset,
            &pSbit->bGlyphFound,                    /* return values */
            &pSbit->usMetricsType,
            &pSbit->usMetricsTable,
            &pSbit->ulMetricsOffset,
            &pSbit->usBitmapFormat,
            &pSbit->ulBitmapOffset,
            &pSbit->ulBitmapLength );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
        
        if (pSbit->bGlyphFound)
        {
            if (pSbit->usTableState == SBIT_BLOC_FOUND)
            {
                *pusFoundCode = 1;
            }
            else
            {
                *pusFoundCode = 2;
            }
            pSbit->bMetricsValid = FALSE;
        }
    }
    return NO_ERR;
}


/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW )
{
    point       ptDevAdvW;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceWidth */
	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ptDevAdvW.x = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    ptDevAdvW.y = 0L;                           /* always zero for horizontal metrics */

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pf26DevAdvW->x = ptDevAdvW.x;
        pf26DevAdvW->y = ptDevAdvW.y;
		break;
	case 1:                                     /* 90 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.y;
        pf26DevAdvW->y = ptDevAdvW.x;
		break;
	case 2:                                     /* 180 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.x;
        pf26DevAdvW->y = -ptDevAdvW.y;
		break;
	case 3:                                     /* 270 degree rotation */
        pf26DevAdvW->x = ptDevAdvW.y;
        pf26DevAdvW->y = -ptDevAdvW.x;
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

	/* metrics without rotation */
    FS_ASSERT(((pSbit->usRotation == 0) || (pSbit->usRotation == 2)), "sbit_CalcDevHorMetrics called under rotation\n");

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        *pDevAdvanceWidthX = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX - INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	case 2:                                     /* 180 degree rotation */
        *pDevAdvanceWidthX = -INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = -INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX + INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
    

    return NO_ERR;
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH )
{
    point       ptDevAdvH;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceHeight */
	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

/* set x components to zero */

    ptDevAdvH.x = 0L;
    ptDevAdvH.y = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
        
     switch(pSbit->usRotation)                   /* handle 90 degree rotations */
    {
    case 0:                                     /* no rotation */
           pf26DevAdvH->x = ptDevAdvH.x;
           pf26DevAdvH->y = ptDevAdvH.y;
    	break;
    case 1:                                     /* 90 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.y;
           pf26DevAdvH->y = ptDevAdvH.x;
    	break;
    case 2:                                     /* 180 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.x;
           pf26DevAdvH->y = -ptDevAdvH.y;
    	break;
    case 3:                                     /* 270 degree rotation */
           pf26DevAdvH->x = ptDevAdvH.y;
           pf26DevAdvH->y = -ptDevAdvH.x;
    	break;
    default:                                    /* non 90 degree rotation */
    	return SBIT_ROTATION_ERR;
    }
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW,
    point           *pf26DevLSB,
    point           *pf26LSB,
    point           *pf26DevAdvH, 	/* NEW */
    point           *pf26DevTopSB,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize )
{
    ErrorCode   ReturnCode;
    uint32      ulOrgMemSize;               /* size of unscaled bitmap */
    uint32      ulExpMemSize;               /* size of unscaled bitmap after gray expansion */
    uint32      ulScaMemSize;               /* size of scaled bitmap */
    uint32      ulMaxMemSize;               /* size of larger of scaled, unscaled */
    
    F26Dot6     f26DevAdvWx;                /* unrotated metrics */
    F26Dot6     f26DevAdvWy;
    F26Dot6     f26DevLSBx;
    F26Dot6     f26DevLSBy;
    F26Dot6     f26DevAdvHx;                /* unrotated metrics */
    F26Dot6     f26DevAdvHy;
    F26Dot6     f26DevTopSBx;
    F26Dot6     f26DevTopSBy;
    int16       sTop;                       /* unrotated bounds */
    int16       sLeft;
    int16       sBottom;
    int16       sRight;
	uint16		usOutBitDepth;				/* number of bit per pixel in the output */

	if (pSbit->usBitDepth == 1)
	{
		usOutBitDepth = 1;
	} else {
		usOutBitDepth = 8;
	}

    ReturnCode = GetSbitMetrics(pSbit, pClientInfo);
    if (ReturnCode != NO_ERR) return ReturnCode;
    
    pSbit->usScaledWidth = UScaleX(pSbit, pSbit->usWidth);
    pSbit->usScaledHeight = UScaleY(pSbit, pSbit->usHeight);


    
    sTop = SScaleY(pSbit, pSbit->sLSBearingY);            /* calc scaled metrics */
    sLeft = SScaleX(pSbit, pSbit->sLSBearingX);
    sBottom = sTop - (int16)pSbit->usScaledHeight;
    sRight = sLeft + (int16)pSbit->usScaledWidth;

    f26DevAdvWx = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    f26DevAdvWy = 0L;                   /* always zero for horizontal metrics */
    f26DevAdvHx = 0L;                   /* always zero for vertical metrics */
    f26DevAdvHy = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
    f26DevLSBx = INTTODOT6(SScaleX(pSbit, pSbit->sLSBearingX));
    f26DevLSBy = INTTODOT6(SScaleY(pSbit, pSbit->sLSBearingY));
    f26DevTopSBx = INTTODOT6(SScaleX(pSbit, pSbit->sTopSBearingX));
    f26DevTopSBy = INTTODOT6(SScaleY(pSbit, pSbit->sTopSBearingY));

    pSbit->usOriginalRowBytes = ROWBYTESLONG(pSbit->usWidth * pSbit->usBitDepth);   /* keep unscaled */
    pSbit->usExpandedRowBytes = ROWBYTESLONG(pSbit->usWidth * usOutBitDepth);   /* keep unscaled */
    pSbit->usScaledRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);

	pSbit->ulReadMemSize = 0; /* size of extra memory, to read gray sbit under scaling or rotation */

    ulOrgMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usOriginalRowBytes;
    ulExpMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usExpandedRowBytes;
    ulScaMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usScaledRowBytes;
    if (ulExpMemSize >= ulScaMemSize)
    {
         ulMaxMemSize = ulExpMemSize;
    }
    else
    {
         ulMaxMemSize = ulScaMemSize;
    }

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pRect->top = sTop;                      /* return scaled metrics */
        pRect->left = sLeft;
        pRect->bottom = sBottom;
        pRect->right = sRight;

        pf26DevAdvW->x = f26DevAdvWx;
        pf26DevAdvW->y = f26DevAdvWy;
        pf26DevLSB->x = f26DevLSBx;
        pf26DevLSB->y = f26DevLSBy;
        pf26LSB->x = f26DevLSBx;
        pf26LSB->y = INTTODOT6(sTop);

        pf26DevAdvH->x = f26DevAdvHx;
        pf26DevAdvH->y = f26DevAdvHy;
        pf26DevTopSB->x = f26DevTopSBx;
        pf26DevTopSB->y = f26DevTopSBy;
        pf26TopSB->x = f26DevTopSBx;
        pf26TopSB->y = f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;

        if ((pSbit->usTableState == SBIT_BSCA_FOUND) || (pSbit->usBitDepth != 1))
        {
            pSbit->ulWorkMemSize = ulMaxMemSize;  /* room to read & scale or expand gray pixels */
			if (pSbit->usBitDepth != 1)
			{
				pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
				pSbit->ulReadMemSize = ulOrgMemSize;
			}
        }
        else
        {
            pSbit->ulWorkMemSize = 0L;
        }
		break;
	case 1:                                     /* 90 degree rotation */
        pRect->top = sRight;
        pRect->left = -sTop;
        pRect->bottom = sLeft;
        pRect->right = -sBottom;
        
        pf26DevAdvW->x = -f26DevAdvWy;
        pf26DevAdvW->y = f26DevAdvWx;
        pf26DevLSB->x = -f26DevLSBy;
        pf26DevLSB->y = f26DevLSBx + INTTODOT6(sRight - sLeft);
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(sRight) - f26DevLSBx;

        pf26DevAdvH->x = -f26DevAdvHy;
        pf26DevAdvH->y = f26DevAdvHx;
        pf26DevTopSB->x = -f26DevTopSBy;
        pf26DevTopSB->y = f26DevTopSBx + INTTODOT6(sRight - sLeft);

        pf26TopSB->x = INTTODOT6(-sTop) - f26DevTopSBy; 
        pf26TopSB->y = 0L; 	

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes; 
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 2:                                     /* 180 degree rotation */
        pRect->top = -sBottom;
        pRect->left = -sRight;
        pRect->bottom = -sTop;
        pRect->right = -sLeft;

        pf26DevAdvW->x = -f26DevAdvWx;
        pf26DevAdvW->y = -f26DevAdvWy;
        pf26DevLSB->x = -f26DevLSBx + INTTODOT6(sLeft - sRight);
        pf26DevLSB->y = -f26DevLSBy + INTTODOT6(sTop - sBottom);
        pf26LSB->x = -f26DevLSBx;
        pf26LSB->y = INTTODOT6(-sBottom);

        pf26DevAdvH->x = -f26DevAdvHx;
        pf26DevAdvH->y = -f26DevAdvHy;
        pf26DevTopSB->x = -f26DevTopSBx + INTTODOT6(sLeft - sRight);
        pf26DevTopSB->y = -f26DevTopSBy + INTTODOT6(sTop - sBottom);

		pf26TopSB->x = INTTODOT6(-sRight);	
        pf26TopSB->y = -f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 3:                                     /* 270 degree rotation */
        pRect->top = -sLeft;
        pRect->left = sBottom;
        pRect->bottom = -sRight;
        pRect->right = sTop;
        
        pf26DevAdvW->x = f26DevAdvWy;
        pf26DevAdvW->y = -f26DevAdvWx;
        pf26DevLSB->x = f26DevLSBy + INTTODOT6(sBottom - sTop);
        pf26DevLSB->y = -f26DevLSBx;
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(-sLeft) + f26DevLSBx;

        pf26DevAdvH->x = f26DevAdvHy;
        pf26DevAdvH->y = -f26DevAdvHx;
        pf26DevTopSB->x = f26DevTopSBy + INTTODOT6(sBottom - sTop);
        pf26DevTopSB->y = -f26DevTopSBx;

        pf26TopSB->x = INTTODOT6(sBottom) -INTTODOT6(sTop) -INTTODOT6(sTop) + f26DevTopSBy;
        pf26TopSB->y = 0L;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
        
    *pusRowBytes = pSbit->usOutRowBytes;
    *pulOutSize = pSbit->ulOutMemSize;          /* return mem requirement */
    *pulWorkSize = pSbit->ulWorkMemSize;
    return NO_ERR;
}

/******************************Public*Routine******************************\
*
* sbit_Embolden adapted from vTtfdEmboldenX
*
* Does emboldening in the x direction
*
* History:
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  24-Jun-1997 -by- Bodin Dresevic [BodinD]
* Stole from YungT
\**************************************************************************/

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)

/* embold only one pixel in the x direction */
#define DXABSBOLD 1

// array of masks for the last byte in a row

static uint8 gjMaskLeft[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static uint8 gjMaskRight[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1f, 0X3f, 0X7f };

//FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8   *pCur, *pyCur, *pyCurEnd, *pAdd, newByte;	

    uint8    beginMask, endMask;
    int32    i, j;
    int32    noOfValidBitsAtEndBold;
    int32    noOfValidBitsAtEndNormal;
    int32    noOfBytesForOneLineNormal;
    int32    noOfBytesForOneLineBold;
    int32   nBytesMore;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	// we want to embolden by sBoldSimulHorShift pixels horizontally(if sBoldSimulHorShift>0 then to the right; else to the left) along the base line 
    // and by sBoldSimulVertShift vertically(if sBoldSimulVertShift>0 then to the bottom; else to the top) )

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}


    noOfValidBitsAtEndBold = usBitmapWidth & 7; // styoo: same as noOfValidBitsAtEndBold = usBitmapWidth % 8

    // Before emboldening,the origninal image had scans of width
    // usBitmapWidth - sBoldSimulHorShift.

    noOfBytesForOneLineBold = CJ_MONOCHROME_SCAN(usBitmapWidth);
    if( sBoldSimulHorShift >= 0 ){
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - sBoldSimulHorShift);
        noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }
    else{
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - (-sBoldSimulHorShift));
        noOfValidBitsAtEndNormal = (usBitmapWidth - (-sBoldSimulHorShift)) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

//=============================================================================================================
	//Horizontal To Right
    if( sBoldSimulHorShift > 0){
        endMask = gjMaskLeft[noOfValidBitsAtEndNormal];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/
            

            pCur = &pyCur[noOfBytesForOneLineNormal - 1];
            *pCur &= endMask;

            pCur++;
            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = &pyCur[noOfBytesForOneLineBold - 1];

            while( pCur >= pyCur)
            {
                newByte = *pCur;
                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is 8, we need to borrow 2 bytes(current byte(0) and previous byte(-1))
                // if if sBoldSimulHorShift is 9, we need to borrow 3 bytes(current byte(0) and 2 previous bytes(-1,-2)
                nBytesMore = (sBoldSimulHorShift+7)/8;

                for(i = 1; i <= sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur-j < pyCur then out of bound
                        if(pCur-j < pyCur)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[-j] >> (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[-j] << (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur--;
            }

        // Special implementation for the last byte, styoo: don't need to borrow from previous byte

        }
    }

    //Horizontal To Left
    else if( sBoldSimulHorShift < 0){
        beginMask = gjMaskRight[8-(-sBoldSimulHorShift)];
        endMask = gjMaskLeft[noOfValidBitsAtEndBold];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
            *pCur &= beginMask;

            pCur = &pyCur[noOfBytesForOneLineBold-1];
            *pCur &= endMask;
            pCur++;

            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = pyCur;
            pyCurEnd = pyCur+(noOfBytesForOneLineBold-1);

            while( pCur <= pyCurEnd)
            {
                newByte = *pCur;

                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is -8, we need to borrow 2 bytes(current byte(0) and next byte(+1))
                // if if sBoldSimulHorShift is -9, we need to borrow 3 bytes(current byte(0) and 2 next bytes(+1,+2)
                nBytesMore = (-sBoldSimulHorShift+7)/8;

                for(i = 1; i <= -sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur+j > pyCur+usRowBytes then out of bound
                        if(pCur+j > pyCurEnd)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[j] << (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[j] >> (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur++;
            }

            // Special implementation for the last byte, styoo: don't need to borrow from previous byte


        }
    }
    // Vertical To the Bottom
	if( sBoldSimulVertShift > 0 ){
		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }

        //
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur -= usRowBytes;
		}

	}
    // Vertical To the Top
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur += usRowBytes;
		}
	}
}

/******************************Public*Routine******************************\
* sbit_EmboldenGray adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 newPix;
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels

            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur )
                    {
					  newPix += *(pCur-i);
                      if (newPix >= usGrayLevels){
                          newPix = (uint8)(usGrayLevels -1);
                          break;
                      }
                    }
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the leftt edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
				    if( (pCur+i) < pyCur+usBitmapWidth )
                    {
					    newPix += *(pCur+i);
                        if (newPix >= usGrayLevels){
                            newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
			    }


                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}

    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}
}

#ifdef FSCFG_SUBPIXEL

#define MAX(a,b)    ((a) > (b) ? (a) : (b))

/******************************Public*Routine******************************\
* sbit_EmboldenSubPixel adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
	uint8 newPix;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }


	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the right side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur && *(pCur-i) )
                    {
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur-i);
					}
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the left side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the left edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
                    if( (pCur+i) < pyCur+usBitmapWidth && *(pCur+i) ){
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur+i);
                    }
			    }

                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
                    if(pAdd >= pyTopNormal){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
					else 
						break;
				}

                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}
    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
                    if(pAdd < pyBottomNormal+usRowBytes){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
                    else 
						break;
				}

                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}

    // Second Pass to modify non edge pixel to MaxIndex
    if( MABS(sBoldSimulVertShift) > 1 ){ // If adding 2 or more pix vertically
        pyCur = pyTopBold+usRowBytes;
        while(pyCur < pyBottomBold){
            uint8 *pEndOfLine = pyCur+usBitmapWidth-1;

            pCur = pyCur+1;
            while(pCur < pEndOfLine){
                if( *pCur > (uint8)0 && *pCur < (uint8)MAX_RGB_INDEX){  // If it's color pix
                    if( *(pCur-1) && *(pCur+1) && *(pCur-usRowBytes) && *(pCur+usRowBytes)){  // If it's not edge pix
                        *pCur = (uint8)MAX_RGB_INDEX;
                    }
                }
                pCur++;
            }
            pyCur += usRowBytes;
        }
    }
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/
/*  if scaling or rotating, read bitmap into workspace,               */
/*  fix it up and copy it to the output map                           */

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork )
{
    ErrorCode   ReturnCode;
    uint8       *pbyRead;
    uint8       *pbyExpand;
    CopyBlock   cb;                                 /* for bitmap rotations */
    uint16      usSrcXMax;
    uint16      usSrcYMax;

    MEMSET(pbyOut, 0, pSbit->ulOutMemSize);         /* always clear the output map */

    if ((pSbit->usRotation == 0) &&                 /* if no rotation */
        (pSbit->usTableState != SBIT_BSCA_FOUND))   /* and no scaling */
    {
		if (pSbit->usBitDepth != 1)
		{
			MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyOut;						 /* expand in the output */
		} else {
			pbyRead = pbyOut;                           /* read straight to output map */
			pbyExpand = NULL;							/* expansion memory not used in that case */
		}
    } else                                            /* if any rotation or scaling */
    {
        MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
		if (pSbit->usBitDepth != 1)
		{
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyWork + pSbit->ulReadMemSize;	/* expand in the work memory */
		} else {
			pbyRead = pbyWork;                          /* read into workspace */
			pbyExpand = pbyWork;						/* scaling done in pbyExpand */
		}
    }

    ReturnCode = GetSbitComponent (                 /* fetch the bitmap */
        pClientInfo,
        pSbit->ulStrikeOffset,
        pSbit->usBitmapFormat,                      /* root data only in state */
        pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
        pSbit->usHeight,
        pSbit->usWidth,
        pSbit->usShaveLeft,
        pSbit->usShaveRight,
        pSbit->usShaveTop,
        pSbit->usShaveBottom,
        0,                                          /* no offset for the root */
        0,
        pSbit->usOriginalRowBytes,
        pSbit->usExpandedRowBytes,
		pSbit->usBitDepth,
        pbyRead,
		pbyExpand);
            
    if (ReturnCode != NO_ERR) return ReturnCode;

    
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        ScaleVertical (
            pbyExpand, 
            pSbit->usExpandedRowBytes, 
            pSbit->usHeight, 
            pSbit->usScaledHeight );

        ScaleHorizontal (
            pbyExpand, 
            pSbit->usExpandedRowBytes,
            pSbit->usScaledRowBytes,
            pSbit->usBitDepth, 
            pSbit->usWidth, 
            pSbit->usScaledWidth,
            pSbit->usScaledHeight );
            
        if (pSbit->usRotation == 0)                         /* if no rotation */
        {
            MEMCPY (pbyOut, pbyExpand, pSbit->ulOutMemSize);  /* keep this one */
        }
		/* in the SBIT_BSCA_FOUND the bitmap was already scaled to the final usScaledWidth, no need for additional emboldment */
	} else {
		if ((pSbit->uBoldSimulHorShift != 0) || (pSbit->uBoldSimulVertShift != 0))
		{
			if (pSbit->usRotation == 0)                             /* if no rotation */
			{
				cb.pbySrc = pbyOut;
			} else 
			{
				cb.pbySrc = pbyExpand;
			}
    
			if (pSbit->usBitDepth == 1)
			{
				sbit_Embolden(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			} else {
				uint16 usGrayLevels = (0x01 << pSbit->usBitDepth) ; /* Max gray level index */
				sbit_EmboldenGray(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, usGrayLevels, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			}

		}
    }

    if (pSbit->usRotation == 0)                             /* if no rotation */
    {
        return NO_ERR;                                      /* done */
    }
    
    cb.pbySrc = pbyExpand;
    cb.pbyDst = pbyOut;
    cb.usSrcBytesPerRow = pSbit->usScaledRowBytes;
    cb.usDstBytesPerRow = pSbit->usOutRowBytes;

	cb.usBitDepth = 1;
	if (pSbit->usBitDepth != 1)
		cb.usBitDepth = 8;

    usSrcXMax = pSbit->usScaledWidth;
    usSrcYMax = pSbit->usScaledHeight;

   	switch(pSbit->usRotation)
	{
	case 1:                                     /* 90 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = cb.usSrcY;                          /* x' = y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = usSrcXMax - cb.usSrcX - 1;      /* y' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 2:                                     /* 180 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstY = usSrcYMax - cb.usSrcY - 1;          /* y' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstX = usSrcXMax - cb.usSrcX - 1;      /* x' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 3:                                     /* 270 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = usSrcYMax - cb.usSrcY - 1;          /* x' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = cb.usSrcX;                      /* y' = x */
                CopyBit(&cb);
            }
        }
		break;
	default:                                    /* shouldn't happen */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}


/**********************************************************************/

/*      Private Functions                                             */

/**********************************************************************/

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo
)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    if (pSbit->bMetricsValid)
    {
        return NO_ERR;                      /* already got 'em */
    }

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ReturnCode = sfac_ShaveSbitMetrics (
	    pClientInfo,
        pSbit->usBitmapFormat,
	    pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
		pSbit->usBitDepth,
    	&pSbit->usHeight,
    	&pSbit->usWidth,
        &pSbit->usShaveLeft,
        &pSbit->usShaveRight,
        &pSbit->usShaveTop,
        &pSbit->usShaveBottom,
    	&pSbit->sLSBearingX,
    	&pSbit->sLSBearingY,
    	&pSbit->sTopSBearingX,
    	&pSbit->sTopSBearingY);

    if (ReturnCode != NO_ERR) return ReturnCode;
        
    pSbit->bMetricsValid = TRUE;
    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAH;
	int16	sNonScaledTSB;

	ReturnCode = sfac_ReadGlyphVertMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAH,
		&sNonScaledTSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceHeight = UEmScaleY(pSbit, usNonScaledAH);

	pSbit->sTopSBearingX = pSbit->sLSBearingX;
	pSbit->sTopSBearingY = - SEmScaleY(pSbit, sNonScaledTSB);

    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAW;
	int16	sNonScaledLSB;

	ReturnCode = sfac_ReadGlyphHorMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAW,
		&sNonScaledLSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceWidth = UEmScaleX(pSbit, usNonScaledAW);

	pSbit->sLSBearingX = pSbit->sTopSBearingX;
	pSbit->sLSBearingY = SEmScaleY(pSbit, sNonScaledLSB);
	
    return NO_ERR;
}

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap )
{
	uint16          usCount;
	uint16			usBitIndex, usOriginalBitIndex;
	uint8			*pbyDstBitRow;
	uint8			*pbySrcBitRow;
	uint16			usMask, usShift, usMaxLevel;

	usMaxLevel = (0x01 << usBitDepth) -1; /* Max gray level index */

	if (usBitDepth == 2)
	{
		usMask = 0x03;
		usShift = 0x02;
		usOriginalBitIndex = ((usWidth -1) & 0x03) << 0x01;
	} else if (usBitDepth == 4)
	{
		usMask = 0x0F;
		usShift = 0x01;
		usOriginalBitIndex = ((usWidth -1) & 0x01) << 0x02;
	} else if (usBitDepth == 8)
	{
		usMask = 0xFF;
		usShift = 0x00;
		usOriginalBitIndex = 0; /* ((usWidth -1) & 0x00) << 0x03 */
	} else
	{
		return;
	}

	/* start from the end to be able to use overlapping memories */
	pbyDstBitRow = pbyDstBitMap + (long) (usHeight-1) * (long) usExpandedRowBytes;
	pbySrcBitRow = pbySrcBitMap + (long) (usHeight-1) * (long) usOriginalRowBytes;
	
	while (usHeight > 0)
	{
		pbyDstBitMap = pbyDstBitRow + (long)(usWidth -1);
		pbySrcBitMap = pbySrcBitRow + (long)((usWidth -1) >> usShift);
		usBitIndex = usOriginalBitIndex;

		*pbySrcBitMap = *pbySrcBitMap >> (MAX_BIT_INDEX - usBitDepth - usBitIndex);

		for (usCount = usWidth; usCount > 0; usCount--)
		{
			if (*pbyDstBitMap == 0)
			{
				/* 99.9% of the case */
				*pbyDstBitMap = *pbySrcBitMap & usMask;
			} else {
				*pbyDstBitMap = usMaxLevel - 
						(usMaxLevel - *pbyDstBitMap) * (usMaxLevel - *pbySrcBitMap & usMask) / usMaxLevel;
			}
			*pbySrcBitMap = *pbySrcBitMap >> usBitDepth;

			pbyDstBitMap--;
			if (usBitIndex == 0)
			{
				usBitIndex = MAX_BIT_INDEX;
				pbySrcBitMap--;
			}
			usBitIndex = usBitIndex - usBitDepth;

		}
		pbyDstBitRow -= usExpandedRowBytes;
		pbySrcBitRow -= usOriginalRowBytes;
		usHeight--;
	}
}
/**********************************************************************/

/*  This is the recursive composite routine */

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead,
    uint8           *pbyExpand )
{
    uint32          ulCompMetricsOffset;            /* component params */
    uint32          ulCompBitmapOffset;
    uint32          ulCompBitmapLength;
    uint16          usComponent;                    /* index counter */
    uint16          usCompCount;
    uint16          usCompGlyphCode;
    uint16          usCompXOff;
    uint16          usCompYOff;
    uint16          usCompMetricsType;
    uint16          usCompMetricsTable;
    uint16          usCompBitmapFormat;
    uint16          usCompHeight;
    uint16          usCompWidth;
    uint16          usCompShaveLeft;
    uint16          usCompShaveRight;
    uint16          usCompShaveTop;
    uint16          usCompShaveBottom;
    uint16          usCompAdvanceWidth;
    uint16          usCompAdvanceHeight;
    int16           sCompLSBearingX;
    int16           sCompLSBearingY;
    int16           sCompTopSBearingX;
    int16           sCompTopSBearingY;
    boolean         bCompGlyphFound;
   	boolean         bCompHorMetricsFound;
   	boolean         bCompVertMetricsFound;
    ErrorCode       ReturnCode;

		ReturnCode = sfac_GetSbitBitmap (               /* fetch the bitmap */
        pClientInfo,
        usBitmapFormat,
        ulBitmapOffset,
        ulBitmapLength,
        usHeight,
        usWidth,
        usShaveLeft,
        usShaveRight,
        usShaveTop,
        usShaveBottom,
        usXOffset,
        usYOffset,
        usOriginalRowBytes,
		usBitDepth,
        pbyRead,
        &usCompCount );                             /* zero for simple glyph */
            
    if (ReturnCode != NO_ERR) return ReturnCode;
    
	/* we expand after handling composite glyphs and before scaling and applying rotation */	
	if (usBitDepth != 1 && usCompCount == 0)
		ExpandSbitToBytePerPixel (
			usHeight,
			usWidth,
			usOriginalRowBytes,
			usExpandedRowBytes,
			usBitDepth,
			pbyRead,
			pbyExpand );

    if (usCompCount > 0)                            /* if composite glyph */
    {
        for (usComponent = 0; usComponent < usCompCount; usComponent++)
        {
			if (usBitDepth != 1)
			{
				/* for grayscale, the composition is done during expansion, I need to
				   clean the memory used to read between each component */
				MEMSET(pbyRead, 0, usOriginalRowBytes*usHeight);
			}
            ReturnCode = sfac_GetSbitComponentInfo (
                pClientInfo,
                usComponent,                        /* component index */
                ulBitmapOffset,
                ulBitmapLength,
                &usCompGlyphCode,                   /* return values */
                &usCompXOff,
                &usCompYOff );
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_SearchForBitmap (     /* look for component glyph */
                pClientInfo,
                usCompGlyphCode,
                ulStrikeOffset,                     /* same strike for all */
                &bCompGlyphFound,                   /* return values */
                &usCompMetricsType,
                &usCompMetricsTable,
                &ulCompMetricsOffset,
                &usCompBitmapFormat,
                &ulCompBitmapOffset,
                &ulCompBitmapLength );
            
            if (ReturnCode != NO_ERR) return ReturnCode;
            
            if (bCompGlyphFound == FALSE)           /* should be there! */
            {
                return SBIT_COMPONENT_MISSING_ERR;
            }

            ReturnCode = sfac_GetSbitMetrics (      /* get component's metrics */
                pClientInfo,
                usCompMetricsType,
                usCompMetricsTable,
                ulCompMetricsOffset,
                &usCompHeight,                      /* these matter */
                &usCompWidth,
                &sCompLSBearingX,                     /* these don't */
                &sCompLSBearingY,
                &sCompTopSBearingX,                     
                &sCompTopSBearingY,
                &usCompAdvanceWidth,
                &usCompAdvanceHeight,
   				&bCompHorMetricsFound,
   				&bCompVertMetricsFound	);
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_ShaveSbitMetrics (    /* shave white space for const metrics */
        	    pClientInfo,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
				usBitDepth,
            	&usCompHeight,
            	&usCompWidth,
                &usCompShaveLeft,
                &usCompShaveRight,
                &usCompShaveTop,
                &usCompShaveBottom,
            	&sCompLSBearingX,
            	&sCompLSBearingY,
            	&sCompTopSBearingX,
             	&sCompTopSBearingY );

            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = GetSbitComponent (         /* recurse here */
                pClientInfo,
                ulStrikeOffset,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
                usCompHeight,
                usCompWidth,
                usCompShaveLeft,
                usCompShaveRight,
                usCompShaveTop,
                usCompShaveBottom,
                (uint16)(usCompXOff + usXOffset + usCompShaveLeft),   /* for nesting */
                (uint16)(usCompYOff + usYOffset + usCompShaveTop),
                usOriginalRowBytes,                         /* same for all */
                usExpandedRowBytes,                         /* same for all */
				usBitDepth,
                pbyRead,
				pbyExpand);
            
            if (ReturnCode != NO_ERR) return ReturnCode;
        }
    }
    return NO_ERR;
}

/********************************************************************/

/*                  Bitmap Scaling Routines                         */

/********************************************************************/

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemX << 1; 
        ulValue += (uint32)pSbit->usSubPpemX;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemX << 1;
        usValue = (uint16)ulValue;
    }
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemY << 1; 
        ulValue += (uint32)pSbit->usSubPpemY;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemY << 1;
        usValue = (uint16)ulValue;
    }
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleX(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleX(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}

/********************************************************************/

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleY(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleY(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}


FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemX;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemX = pSbit->usSubPpemX;
    } else {
		usPpemX = pSbit->usPpemX;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemX << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemY;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemY = pSbit->usSubPpemY;
    } else {
		usPpemY = pSbit->usPpemY;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemY << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleX(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleX(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleY(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleY(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
)
{
    uint8 *pbyOrgRow;                   /* original data pointer */
    uint8 *pbyNewRow;                   /* new data pointer */
    uint16 usErrorTerm;                 /* for 'Bresenham' calculation */
    uint16 usLine;                      /* loop counter */

    usErrorTerm = usOrgHeight >> 1;                 /* used by both comp and exp */

    if (usOrgHeight > usNewHeight)                  /* Compress Vertical */
    {
        pbyOrgRow = pbyBitmap;
        pbyNewRow = pbyBitmap;

        for (usLine = 0; usLine < usNewHeight; usLine++)
        {
            while (usErrorTerm >= usNewHeight)
            {
                pbyOrgRow += usBytesPerRow;         /* skip a row */
                usErrorTerm -= usNewHeight;
            }
            if (pbyOrgRow != pbyNewRow)
            {
                MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
            }
            pbyNewRow += usBytesPerRow;
            usErrorTerm += usOrgHeight;
        }
        for (usLine = usNewHeight; usLine < usOrgHeight; usLine++)
        {
            MEMSET(pbyNewRow, 0, usBytesPerRow);    /* erase the leftover */
            pbyNewRow += usBytesPerRow;
        }
    }
    else if (usNewHeight > usOrgHeight)             /* Expand Vertical */
    {
        pbyOrgRow = pbyBitmap + (usOrgHeight - 1) * usBytesPerRow;
        pbyNewRow = pbyBitmap + (usNewHeight - 1) * usBytesPerRow;

        for (usLine = 0; usLine < usOrgHeight; usLine++)
        {
            usErrorTerm += usNewHeight;
            
            while (usErrorTerm >= usOrgHeight)      /* executes at least once */
            {
                if (pbyOrgRow != pbyNewRow)
                {
                    MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
                }
                pbyNewRow -= usBytesPerRow;
                usErrorTerm -= usOrgHeight;
            }
            pbyOrgRow -= usBytesPerRow;
        }
    }
}

/********************************************************************/

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
)
{
    uint8 *pbyOrgRow;               /* points to original row beginning */
    uint8 *pbyNewRow;               /* points to new row beginning */
    uint8 *pbyOrg;                  /* original data pointer */
    uint8 *pbyNew;                  /* new data pointer */
    uint8 byOrgData;                /* original data read 1 byte at a time */
    uint8 byNewData;                /* new data assembled bit by bit */

    uint16 usErrorTerm;             /* for 'Bresenham' calculation */
    uint16 usByte;                  /* to byte counter */
    uint16 usOrgBytes;              /* from width rounded up in bytes */
    uint16 usNewBytes;              /* to width rounded up in bytes */
    
    int16 sOrgBits;                 /* counts valid bits of from data */
    int16 sNewBits;                 /* counts valid bits of to data */
    int16 sOrgBitsInit;             /* valid original bits at row begin */
    int16 sNewBitsInit;             /* valid new bits at row begin */

    
	if (usBitDepth == 1)
	{
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;
			usNewBytes = (usNewWidth + 7) >> 3;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = 0;                           /* start at left edge */
				sNewBits = 0;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)
				{
					while (usErrorTerm >= usNewWidth)
					{
						sOrgBits--;                     /* skip a bit */
						usErrorTerm -= usNewWidth;
					}
					while (sOrgBits <= 0)               /* if out of data */
					{
						byOrgData = *pbyOrg++;          /*   then get some fresh */
						sOrgBits += 8;
					}
					byNewData <<= 1;                    /* new bit to lsb */
					byNewData |= (byOrgData >> (sOrgBits - 1)) & 1;
                
					sNewBits++;
					if (sNewBits == 8)                  /* if to data byte is full */
					{
						*pbyNew++ = byNewData;          /*   then write it out */
						sNewBits = 0;
						usByte++;                       /* loop counter */
					}
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = (usOrgWidth + 7) >> 3;
			sOrgBitsInit = (int16)((usOrgWidth + 7) & 0x07) - 7;
        
			usNewBytes = (usNewWidth + 7) >> 3;
			sNewBitsInit = 7 - (int16)((usNewWidth + 7) & 0x07);

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytes - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = sOrgBitsInit;                /* initially unaligned */
				sNewBits = sNewBitsInit;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)             /* for each output byte */
				{
					if (sOrgBits <= 0)                  /* if out of data */
					{
						byOrgData = *pbyOrg--;          /*   then get some fresh */
						sOrgBits += 8;
					}
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						byNewData >>= 1;                /* use the msb of byte */
						byNewData |= (byOrgData << (sOrgBits - 1)) & 0x80;
                    
						sNewBits++;
						if (sNewBits == 8)              /* if to data byte is full */
						{
							*pbyNew-- = byNewData;      /*   then write it out */
							sNewBits = 0;
							usByte++;                   /* loop counter */
						}
						usErrorTerm -= usOrgWidth;
					}
					sOrgBits--;                         /* get next bit */
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
    } else {											/* one byte per pixel */
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = 0;
				while (usByte < usNewWidth)
				{
					while (usErrorTerm >= usNewWidth)
					{
						pbyOrg++;                     /* skip a byte */
						usErrorTerm -= usNewWidth;
					}
					*pbyNew++ = *pbyOrg;
					usByte++;                       /* loop counter */
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = usOrgWidth;        
			usNewBytes = usNewWidth ;

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytesPerRow - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = usNewBytesPerRow;
				while (usByte > usNewBytes)
				{
					*pbyNew-- = 0;                      /* blank out the extra bytes on the right */
					usByte--;
				}
				while (usByte > 0)             /* for each output byte */
				{
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						*pbyNew-- = *pbyOrg;

						usByte--;                   /* loop counter */
						usErrorTerm -= usOrgWidth;
					}
					pbyOrg--;
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
	}
}

/********************************************************************/

FS_PRIVATE void CopyBit(
    CopyBlock* pcb )
{
    uint16  usSrcOffset;
    uint16  usSrcShift;
    uint16  usDstOffset;
    uint16  usDstShift;
    
    static  uint16 usByteMask[8] = 
        { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

/*  if speed becomes an issue, this next multiply could be moved up */
/*  to the calling routine, and placed outside the 'x' loop */

/*  if speed becomes an issue, the test between 1 bit and 1 byte per pixel */
/*  could be moved up to the calling routine */

	if (pcb->usBitDepth == 1)
	{
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + (pcb->usSrcX >> 3);
		usSrcShift = pcb->usSrcX & 0x0007;

		if (pcb->pbySrc[usSrcOffset] & usByteMask[usSrcShift])
		{
			usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + (pcb->usDstX >> 3);
			usDstShift = pcb->usDstX & 0x0007;
			pcb->pbyDst[usDstOffset] |= usByteMask[usDstShift];
		}
	} else {
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + pcb->usSrcX;
		usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + pcb->usDstX;
		pcb->pbyDst[usDstOffset] = pcb->pbySrc[usSrcOffset];
	}

}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scbitmap.c ===
/*********************************************************************

      scbitmap.c -- New Scan Converter BitMap Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

      10/03/93  deanb   use (x) in bitmask shift macros
       8/23/93  deanb   gray scale functions
       6/11/93  deanb   use MEMSET macro, string & stddef removed
       6/10/93  deanb   Start/Stop/Bit mask macros
       6/10/93  deanb   InitializeBitMasks added, stdio & assert removed
       4/29/93  deanb   BLTCopy routine added
       3/19/93  deanb   size_t caste checked
      10/14/92  deanb   memset for fsc_ClearBitMap
       9/15/92  deanb   Set bit coded 
       8/18/92  deanb   include scconst.h 
       6/02/92  deanb   Row pointer, integer limits, no descriptor 
       5/08/92  deanb   reordered includes for precompiled headers 
       5/04/92  deanb   Array tags added 
       4/27/92  deanb   Negative runs handled 
       4/16/92  deanb   Coding 
       3/23/92  deanb   First cut 

**********************************************************************/

#define FSCFG_INTERNAL

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/


#include    "fscdefs.h"             /* shared data types */
#include    "scgray.h"              /* gray scale param block */
#include    "fserror.h"             /* error codes */
#include    "scbitmap.h"            /* for own function prototypes */


/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     MASKSIZE    32              /* bits per bitmap masks */
#define     MASKSHIFT   5               /* log2 of MASKSIZE */
#define     MASKBITS    0x0000001FL     /* masks pix loc of long word */

#define     ALL_ONES    ((uint32)0xFFFFFFFFL)
#define     HIGH_ONE    ((uint32)0x80000000L)


/*********************************************************************/

/*      Bitmask definitions                                          */

/*********************************************************************/
    
#ifndef FSCFG_USE_MASK_SHIFT    /* if using bitmask tables */

#define START_MASK(x)   aulStartBits[x]
#define STOP_MASK(x)    aulStopBits[x]
#define BIT_MASK(x)     aulBitMask[x]

/*  bitmask tables */

FS_PRIVATE uint32 aulStartBits[MASKSIZE];       /* such as:  0000111 */
FS_PRIVATE uint32 aulStopBits[MASKSIZE];        /* such as:  1110000 */
FS_PRIVATE uint32 aulBitMask[MASKSIZE];         /* such as:  0001000 */


#else                           /* if using bitmask shift */

#define START_MASK(x)   (ALL_ONES >> (x))
#define STOP_MASK(x)    (ALL_ONES << ((MASKSIZE - 1) - (x)))
#define BIT_MASK(x)     (HIGH_ONE >> (x))

#endif


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*      fsc_InitializeBitMasks() loads the arrays of 32-bit masks at 
 *      runtime to create CPU independent bitmap masks.
 *
 *      It is conditionally compiled because the arrays are unused
 *      in a "USE_MASK_SHIFT" (e.g. Apple, HP) configuration. 
 *
 *      We load the arrays by converting the Big-Endian value of
 *      the mask to the "native" representation of that mask.  The
 *      "native" representation can be applied to a "native" byte
 *      array to manipulate more than 8 bits at a time of an output
 *      bitmap.
 */

FS_PUBLIC void fsc_InitializeBitMasks (void)
{
#ifndef FSCFG_USE_MASK_SHIFT

    int32 lIdx;
    uint32 ulStartMask;
    uint32 ulStopMask;
    uint32 ulBitMask;

    ulStartMask = ALL_ONES;
    ulStopMask = ALL_ONES;
    ulBitMask = HIGH_ONE;
    
    for (lIdx = 0; lIdx < MASKSIZE; lIdx++)
    {
        aulStartBits[lIdx] = (uint32) SWAPL(ulStartMask);
        aulStopBits[MASKSIZE - lIdx - 1] = (uint32) SWAPL(ulStopMask);
        aulBitMask[lIdx] = (uint32) SWAPL(ulBitMask);

        ulStartMask >>= 1;
        ulStopMask <<= 1;
        ulBitMask >>= 1;
    }
#endif
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ClearBitMap (
        uint32 ulBMPLongs, 
        uint32 *pulMap )
{
    size_t stBytes;

    stBytes = (size_t)ulBMPLongs << 2;

    Assert((uint32)stBytes == (ulBMPLongs << 2));

    MEMSET((void*)pulMap, 0, stBytes);
    
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTHoriz (
        int32 lXStart, 
        int32 lXStop, 
        uint32 *pulMap )                 
{
    int32 lSkip;

    lSkip = (lXStart >> MASKSHIFT);         /* longwords to first black */
    pulMap += lSkip;
    lXStart -= lSkip << MASKSHIFT;          /* correct start/stop */
    lXStop -= lSkip << MASKSHIFT;
    while (lXStop >= MASKSIZE)
    {
        *pulMap |= START_MASK(lXStart);
        pulMap++;
        lXStart = 0;
        lXStop -= MASKSIZE;
    }
    *pulMap |= START_MASK(lXStart) & STOP_MASK(lXStop);
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTCopy ( 
        uint32 *pulSource,         /* source row pointer */
        uint32 *pulDestination,    /* destination row pointer */
        int32 lCount )             /* long word counter */
{
    while (lCount)
    {
        *pulDestination = *pulSource;
        pulDestination++;
        pulSource++;
        lCount--;
    }
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC uint32 fsc_GetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    return(pulMap[lXCoord >> MASKSHIFT] & BIT_MASK(lXCoord & MASKBITS));
}


/*********************************************************************/

FS_PUBLIC int32 fsc_SetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    pulMap[lXCoord >> MASKSHIFT] |= BIT_MASK(lXCoord & MASKBITS);
    
    return NO_ERR;
}


/*********************************************************************/

/*  Gray scale row bitmap calculation                                */
/*  Count one row of over scale pixels into gray scale row           */

/*********************************************************************/
                
FS_PUBLIC int32 fsc_CalcGrayRow(
        GrayScaleParam* pGSP
)
{            
    char        *pchOver;               /* pointer to overscaled bitmap */
    char        *pchGray;               /* pointer to gray scale bitmap */
    uint16      usShiftMask;            /* masks off over scaled bits of interest */
    uint16      usGoodBits;             /* number of valid bits in usOverBits */
    uint16      usOverBits;             /* a byte of overscaled bitmap */
    int16       sGrayColumns;           /* number of gray columns to calc */
    
    static char chCount[256] = {        /* count of one bits */    
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };


    pchGray = pGSP->pchGray;
    pchOver = pGSP->pchOver;
    sGrayColumns = pGSP->sGrayCol;
    usShiftMask = 0x00FF >> (8 - pGSP->usOverScale);  /* over bits per gray pix */
    usGoodBits = 8 - pGSP->usFirstShift;
    usOverBits = ((uint16)*pchOver) >> pGSP->usFirstShift;
      
    /* Asserts in this function validate internal consistancy of the callers use of this function.  */
    Assert (pchGray >= pGSP->pchGrayLo);
    Assert (pchGray < pGSP->pchGrayHi);
    
    *pchGray += chCount[usOverBits & usShiftMask];
    pchGray--;                              /* move backwards through both bitmaps! */
    sGrayColumns--;

    while (sGrayColumns > 0)                /* for each gray column (after 1st) */
    {
        usGoodBits -= pGSP->usOverScale;
        if (usGoodBits > 0)                 /* if bits remain in over byte */
        {
            usOverBits >>= pGSP->usOverScale;
        }
        else                                /* if we've looked at everything */
        {
            pchOver--;

            Assert (pchOver >= pGSP->pchOverLo);
            Assert (pchOver < pGSP->pchOverHi);

            usOverBits = (uint16)*pchOver;
            usGoodBits = 8;
        }

        Assert (pchGray >= pGSP->pchGrayLo);
        Assert (pchGray < pGSP->pchGrayHi);

        *pchGray += chCount[usOverBits & usShiftMask];  /* accumulate count */
        pchGray--;
        sGrayColumns--;
    }
    return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scanlist.c ===
/*********************************************************************

	  scanlist.c -- New Scan Converter ScanList Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/22/93  deanb   all dropouts confined to bounding box
	   6/10/93  deanb   fsc_InitializeScanlist added, stdio & assert gone
	   4/26/93  deanb   fix pointers now works with segmented memory
	   4/19/93  deanb   banding added
	   4/07/93  deanb   sorting is now done on the fly
	   4/01/93  deanb   intersection arrays replace linked lists
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   memory requirements reworked
	  10/19/92  deanb   smart dropout tiebreak left & down
	  10/14/92  deanb   delete usScanKind from state
	  10/09/92  deanb   reentrant
	  10/08/92  deanb   reworked for split workspace
	  10/02/92  deanb   correct AddVertDropoutScan assertions
	   9/25/92  deanb   separate nodrop/dropout entry points
	   9/22/92  deanb   smart dropout control
	   9/17/92  deanb   stub control
	   9/15/92  deanb   simple dropout control
	   9/11/92  deanb   setupscan handles scankind
	   9/09/92  deanb   dropout / nodropout begun
	   8/17/92  deanb   include struc.h scconst.h
	   8/07/92  deanb   initial dropout control
	   8/06/92  deanb   assertions reinstated
	   7/27/92  deanb   bitmap clear added
	   7/16/92  deanb   gulBytesRemaining -> gulIntersectRemaining
	   6/18/92  deanb   int x coord for HorizScanAdd
	   6/01/92  deanb   incorporate bitmap functions
	   5/08/92  deanb   reordered includes for precompiled headers
	   5/04/92  deanb   Array tags added
	   4/28/92  deanb   list array sentinels added
	   4/21/92  deanb   single HorizScanAdd routine
	   4/15/92  deanb   calls to BitMap
	   4/13/92  deanb   uiY to iY for HorizScanOn/Off
	   4/09/92  deanb   New types
	   4/03/92  deanb   HorizScan On/Off coded
	   3/31/92  deanb   InitScanArray begun
	   3/25/92  deanb   GetWorkSizes and local types
	   3/23/92  deanb   First cut

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scbitmap.h"            /* bit blt operations */
#include    "scmemory.h"            /* for allocations */

/*********************************************************************/

/*      Contour reversal list structures                             */

/*********************************************************************/

typedef struct Rev                  /* Reversal list entry */
{
	int16 sScan;                    /* scan line */
	int16 sCross;                   /* direction +1 or -1 */
	struct Rev *prevLink;           /* link to next reversal */
}
Reversal;

struct RevRoots                     /* Reversal list roots */
{
	Reversal *prevYRoot;            /* Y direction contour reversals */
	Reversal *prevXRoot;            /* X direction contour reversals */
	Reversal *prevNext;             /* Next available list item */
	Reversal *prevEnd;              /* End of buffer (for overflow check) */
	struct RevRoots *prrSelf;       /* to check for moved memory */
};

#include    "scanlist.h"            /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void AddReversal (Reversal**, Reversal*, F26Dot6, int16);
FS_PRIVATE int32 GetIxEstimate(Reversal*);
FS_PRIVATE void FixPointers(PRevRoot);

FS_PRIVATE int32 AddHorizSimpleScan(PSTATE int32, int32);
FS_PRIVATE int32 AddVertSimpleScan(PSTATE int32, int32);
FS_PRIVATE int32 AddHorizSmartScan(PSTATE int32, int32);
FS_PRIVATE int32 AddVertSmartScan(PSTATE int32, int32);
FS_PRIVATE int32 AddHorizSimpleBand(PSTATE int32, int32);
FS_PRIVATE int32 AddHorizSmartBand(PSTATE int32, int32);

FS_PRIVATE int32 LookForDropouts(PSTATE char*, uint16);
FS_PRIVATE int32 DoHorizDropout(PSTATE int16*, int16*, int32, char*, uint16);
FS_PRIVATE int32 DoVertDropout(PSTATE int16*, int16*, int32, char*, uint16);

FS_PRIVATE int32 HorizCrossings(PSTATE int32, int32);
FS_PRIVATE int32 VertCrossings(PSTATE int32, int32);

FS_PRIVATE uint32 GetBitAbs(PSTATE char*, int32, int32);
FS_PRIVATE int32 SetBitAbs(PSTATE char*, int32, int32);


/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_InitializeScanlist()
{
	fsc_InitializeBitMasks();
}


/*********************************************************************/

/*      Contour Reversal Functions                                   */

/*********************************************************************/

/* setup the contour reversal list roots structure */

FS_PUBLIC PRevRoot  fsc_SetupRevRoots (
		char* pchRevBuf,
		int32 lRevBufSize )
{
	PRevRoot prrRoots;
	Reversal *prevSentinel;
	
	prrRoots = (PRevRoot) pchRevBuf;                /* workspace begin */
	prevSentinel = (Reversal*) (prrRoots + 1);      /* just past the roots */

	prrRoots->prevYRoot = prevSentinel;             /* point to sentinel */
	prrRoots->prevXRoot = prevSentinel;             /* for both lists */
	prevSentinel->sScan = HUGEINT;                  /* stop value */
	prevSentinel->sCross = 0;
	prevSentinel->prevLink = NULL;
	prrRoots->prevNext = prevSentinel + 1;          /* to next free record */
	
	prrRoots->prevEnd = (Reversal*)(pchRevBuf + lRevBufSize);
	prrRoots->prrSelf = prrRoots;                   /* for address validation */
	
	return prrRoots;
}

/*********************************************************************/

/* insert into y list one countour reversal structure */

FS_PUBLIC int32 fsc_AddYReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	/* reversal not very common. */

	AddReversal(&(prrRoots->prevYRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd); 

	if(prrRoots->prevNext > prrRoots->prevEnd)
		return MEM_OVERRUN_ERR;

	return NO_ERR;
}

/*********************************************************************/

/* insert into x list one countour reversal structure */

FS_PUBLIC int32 fsc_AddXReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	/* reversal not very common. */

	AddReversal(&(prrRoots->prevXRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd); 

	if(prrRoots->prevNext > prrRoots->prevEnd)
		return MEM_OVERRUN_ERR;

	return NO_ERR;
}

/*********************************************************************/

/* insert into x or y list one countour reversal structure */

FS_PRIVATE void AddReversal (
		Reversal **pprevList,
		Reversal *prevNext,
		F26Dot6 fxCoord,
		int16 sDir )
{
	int16 sScan;

	sScan = (int16)((fxCoord + SUBHALF + (sDir >> 1)) >> SUBSHFT);

	while(sScan > (*pprevList)->sScan)          /* will stop before sentinel */
	{
		pprevList = &((*pprevList)->prevLink);  /* else link to next */
	}
	prevNext->sScan = sScan;                    /* save scanline */
	prevNext->sCross = -sDir;                   /* count up from bottom */
	prevNext->prevLink = *pprevList;            /* link rest of list */

	*pprevList = prevNext;                      /* insert new item */
}

/*********************************************************************/

/* return the total number of reversals in the lists */

FS_PUBLIC int32 fsc_GetReversalCount (PRevRoot prrRoots)
{
	return (int32)(( prrRoots->prevNext - 1 -           /* don't count sentinel */
			 (Reversal*)((char*)prrRoots + sizeof(struct RevRoots))) );
}

/*********************************************************************/

/* calculate anticipated horizontal intersections */

FS_PUBLIC int32 fsc_GetHIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevYRoot ) );
}

/*********************************************************************/

/* calculate anticipated vertical intersections */

FS_PUBLIC int32 fsc_GetVIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevXRoot ) );
}

/*********************************************************************/

/* calculate anticipated intersections */

FS_PRIVATE int32 GetIxEstimate(Reversal *prevList)
{
	int32 lTotalIx;
	
	lTotalIx = 0L;
	while (prevList->sScan < HUGEINT)       /* look through list */
	{
		if (prevList->sCross == 1)          /* adding up columns! */
		{
			lTotalIx -= (int32)prevList->sScan;
		}
		else
		{
			lTotalIx += (int32)prevList->sScan;
		}
		prevList = prevList->prevLink;
	}
	return(lTotalIx);
}

/*********************************************************************/

/* calculate horizontal intersections for banding */

FS_PUBLIC int32 fsc_GetHIxBandEst(
		PRevRoot prrRoots,
		Rect* prectBox,
		  int32 lBandWidth
)
{
	Reversal *prevHiList;               /* high band reversal pointer */
	Reversal *prevLoList;               /* low band reversal pointer */
	int16 sHiScan;                      /* current top of band */
	int16 sLoScan;                      /* current bottom of band */
	int16 sHiCross;                     /* top of band's crossings */
	int16 sLoCross;                     /* bottom of band's crossings*/
	int32 lTotalIx;                     /* intersection count for each band */
	int32 lBiggestIx;                   /* largest intersection count */

	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	lTotalIx = 0;
	prevHiList = prrRoots->prevYRoot;
	sHiScan = prectBox->bottom;
	sHiCross = 0;
	while (lBandWidth > 0)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in this line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)sHiCross;            /* add up first band's crossings */
		sHiScan++;
		lBandWidth--;
	}
	lBiggestIx = lTotalIx;

	prevLoList = prrRoots->prevYRoot;
	sLoScan = prectBox->bottom;
	sLoCross = 0;
	while (sHiScan < prectBox->top)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in high line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		while (prevLoList->sScan <= sLoScan)
		{
			sLoCross += prevLoList->sCross;     /* add in low line's crossings */
			prevLoList = prevLoList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)(sHiCross - sLoCross);
		if (lTotalIx > lBiggestIx)
		{
			lBiggestIx = lTotalIx;              /* save the largest value */
		}
		sHiScan++;
		sLoScan++;
	}
	return(lBiggestIx);
}

/*********************************************************************/

/*      return number of bytes used by reversal lists                */

FS_PUBLIC int32 fsc_GetRevMemSize(PRevRoot prrRoots)
{
	return (int32)((char*)(prrRoots->prevNext) - (char*)prrRoots);
}

/*********************************************************************/

/*  when reversal list has moved, recalculate the pointers           */

FS_PRIVATE void FixPointers(PRevRoot prrRoots)
{
	char *pchNewBase;
	char *pchOldBase;
	Reversal *prevList;

	pchNewBase = (char*)prrRoots;
	pchOldBase = (char*)prrRoots->prrSelf;          /* pre-move base addr */

	prrRoots->prevYRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevYRoot - pchOldBase));
	prrRoots->prevXRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevXRoot - pchOldBase));
	prrRoots->prevNext = (Reversal*)(pchNewBase + ((char*)prrRoots->prevNext - pchOldBase));
	prrRoots->prevEnd = (Reversal*)(pchNewBase + ((char*)prrRoots->prevEnd - pchOldBase));
	
	prevList = prrRoots->prevYRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prevList = prrRoots->prevXRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prrRoots->prrSelf = prrRoots;                   /* for next time */
}

/*********************************************************************/

/*      Workspace Calcluation Functions                              */

/*********************************************************************/

/* calculate horizontal scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanHMem(
		uint16 usScanKind,      /* scan type */
		int32 lHScan,           /* number of horiz scanlines */
		int32 lHInter )         /* number of horiz intersections */
{
	ALIGN(voidPtr, lHScan); 
	ALIGN(voidPtr, lHInter ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lHScan * (5 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lHScan * (5 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (4 * sizeof(int16)));     /* for ix/code arrays */
	}
}


/*********************************************************************/

/* calculate vertical scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanVMem(
		uint16 usScanKind,      /* scan type */
		int32 lVScan,           /* number of vert scanlines */
		int32 lVInter,          /* number of vert intersections */
		int32 lElemPts )        /* number of contour element points */
{
	ALIGN(voidPtr, lVScan); 
	ALIGN(voidPtr, lVInter); 
	ALIGN(voidPtr, lElemPts ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lVScan * (5 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lVScan * (5 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (4 * sizeof(int16)) +     /* for ix/code arrays */
				lElemPts * (2 * sizeof(F26Dot6)));  /* for element (x, y) */
	}
}

/*********************************************************************/

/*      Scan Conversion Preparation Functions                        */

/*********************************************************************/

/*  Line, Spline, and Endpoint register their callbacks here */

FS_PUBLIC void fsc_SetupCallBacks(
		PSTATE                       /* pointer to state variables */
		int16 sCode,                 /* element code (line, spline, endpoint) */
		F26Dot6 (*pfnHoriz)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*pfnVert)(int32, F26Dot6*, F26Dot6*)     /* vert callback */
)
{
	STATE.pfnHCallBack[sCode] = pfnHoriz;
	STATE.pfnVCallBack[sCode] = pfnVert;
}


/*********************************************************************/

/*  Allocate scan workspace memory and set up pointer arrays */

FS_PUBLIC int32 fsc_SetupScan(
		PSTATE                      /* pointer to state variables */
		Rect* prectBox,             /* bounding box */
		uint16 usScanKind,          /* dropout control value */
		int32 lHiBand,              /* top scan limit */
		int32 lLoBand,              /* bottom scan limit */
		boolean bSaveRow,           /* save last bitmap row for dropout */
		int32 lRowBytes,            /* for last row alloc */
		int32 lHInterCount,         /* estimate of horiz intersections */
		int32 lVInterCount,         /* estimate of vert intersections */
		int32 lElemCount,           /* estimate of element points */
		PRevRoot prrRoots           /* reversal list roots */
)
{
	int32 lHorizBandCount;          /* number of horizontal scan lines */
	int32 lVertScanCount;           /* number of vertical scan lines */
	int32 lPointerArraySize;        /* bytes per pointer array */

	int16 sScan;                    /* current scan line */
	int16 sCross;                   /* crossings on this line */
	int16 *psScanIx;                /* temp scan intersection array */
	Reversal *prevList;             /* pointer to reversal list */
	
    int16 **ppsHOnBegin;            /* for init speed */
    int16 **ppsHOnEnd;
    int16 **ppsHOffBegin;
    int16 **ppsHOffEnd;
    int16 **ppsHOffMax;
    int16 **ppsVOnBegin;            /* for init speed */
    int16 **ppsVOnEnd;
    int16 **ppsVOffBegin;
    int16 **ppsVOffEnd;
    int16 **ppsVOffMax;


    STATE.lBoxTop = (int32)prectBox->top;   /* copy the bounding box */
    STATE.lBoxBottom = (int32)prectBox->bottom;
    STATE.lBoxLeft = (int32)prectBox->left;
    STATE.lBoxRight = (int32)prectBox->right;
    
    STATE.lHiScanBand = lHiBand;    /* copy scan band limits */
    STATE.lLoScanBand = lLoBand;
    
/*  set STATE according to dropout and banding requirements */

    if ((usScanKind & SK_NODROPOUT) || !(usScanKind & SK_SMART))
    {
        STATE.sIxSize = 1;          /* one int16 per intersection */
        STATE.sIxShift = 0;         /* log2 of size */

        if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
        {
            STATE.pfnAddHoriz = AddHorizSimpleScan;
        }
        else    /* if banding */
        {
            STATE.pfnAddHoriz = AddHorizSimpleBand;
        }
        STATE.pfnAddVert = AddVertSimpleScan;
    }
    else        /* if smart dropout */
    {
        STATE.sIxSize = 2;          /* two int16's per intersection */
        STATE.sIxShift = 1;         /* log2 of size */

        if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
        {
            STATE.pfnAddHoriz = AddHorizSmartScan;
        }
        else    /* if banding */
        {
            STATE.pfnAddHoriz = AddHorizSmartBand;
        }
        STATE.pfnAddVert = AddVertSmartScan;
    }

/* setup horizontal intersection array for all cases */
    
    lHorizBandCount = STATE.lHiScanBand - STATE.lLoScanBand;
    Assert(lHorizBandCount > 0); /* Also checked in fsc_FillGlyph(). */
    
    lPointerArraySize = lHorizBandCount * sizeof(int16*);
    STATE.apsHOnBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
    if(STATE.apsHOnBegin == NULL)
        return MEM_SUBALLOC_ERR;

    STATE.apsHOffBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
    if(STATE.apsHOffBegin == NULL)
        return MEM_SUBALLOC_ERR;

    STATE.apsHOnEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
    if(STATE.apsHOnEnd == NULL)
        return MEM_SUBALLOC_ERR;

    STATE.apsHOffEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
    if(STATE.apsHOffEnd == NULL)
        return MEM_SUBALLOC_ERR;

    STATE.apsHOffMax = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
    if(STATE.apsHOffMax == NULL)
        return MEM_SUBALLOC_ERR;

    STATE.lPoint = 0L;                      /* initial element index */
    STATE.lElementPoints = lElemCount;

    psScanIx = (int16*) fsc_AllocHMem(ASTATE lHInterCount << (STATE.sIxShift + 2));
    if(psScanIx == NULL)
        return MEM_SUBALLOC_ERR;
            
    if (prrRoots != prrRoots->prrSelf)      /* if reversals have moved */
    {
        FixPointers(prrRoots);              /* then patch up the pointers */
    }
    prevList = prrRoots->prevYRoot;         /* root of y list reversals */
    sCross = 0;
    
    ppsHOnBegin = STATE.apsHOnBegin;        /* for init speed */
    ppsHOnEnd = STATE.apsHOnEnd;
    ppsHOffBegin = STATE.apsHOffBegin;
    ppsHOffEnd = STATE.apsHOffEnd;
    ppsHOffMax = STATE.apsHOffMax;

/* initialize horizontal scan arrays */
    
    for (sScan = (int16)STATE.lLoScanBand; sScan < (int16)STATE.lHiScanBand; sScan++)
    {
        while (prevList->sScan <= sScan)
        {
            sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
            prevList = prevList->prevLink;                  /* link to next reversal */
        }
        *ppsHOnBegin = psScanIx;
        ppsHOnBegin++;
        *ppsHOnEnd = psScanIx;
        ppsHOnEnd++;
        psScanIx += sCross;
                
        *ppsHOffBegin = psScanIx;
        ppsHOffBegin++;
        *ppsHOffEnd = psScanIx;
        ppsHOffEnd++;
        psScanIx += sCross;
        *ppsHOffMax = psScanIx;
        ppsHOffMax++;
    }
    
/* if doing dropout control, setup X intersection array */

    if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
    {
        lVertScanCount = (int32)(prectBox->right - prectBox->left);
        Assert(lVertScanCount > 0); /* trying to rasterize mirror image, unlikely client condition */ 

        lPointerArraySize = lVertScanCount * sizeof(int16*);
        STATE.apsVOnBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
        if(STATE.apsVOnBegin == NULL)
            return MEM_SUBALLOC_ERR;

        STATE.apsVOffBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
        if(STATE.apsVOffBegin == NULL)
            return MEM_SUBALLOC_ERR;

        STATE.apsVOnEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
        if(STATE.apsVOnEnd == NULL)
            return MEM_SUBALLOC_ERR;

        STATE.apsVOffEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
        if(STATE.apsVOffEnd == NULL)
            return MEM_SUBALLOC_ERR;

        STATE.apsVOffMax = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
        if(STATE.apsVOffMax == NULL)
            return MEM_SUBALLOC_ERR;

        if (bSaveRow)                           /* if fast banding & dropout */
        {
            STATE.pulLastRow = (uint32*) fsc_AllocVMem(ASTATE lRowBytes);
            STATE.lLastRowIndex = HUGEFIX;      /* impossible value => uninitialized */
        }
        psScanIx = (int16*) fsc_AllocVMem(ASTATE lVInterCount << (STATE.sIxShift + 2));
        if(psScanIx == NULL)
            return MEM_SUBALLOC_ERR;
                
        prevList = prrRoots->prevXRoot;         /* root of x list reversals */
        sCross = 0;
        sScan = prectBox->left;
    
        ppsVOnBegin = STATE.apsVOnBegin;        /* for init speed */
        ppsVOnEnd = STATE.apsVOnEnd;
        ppsVOffBegin = STATE.apsVOffBegin;
        ppsVOffEnd = STATE.apsVOffEnd;
        ppsVOffMax = STATE.apsVOffMax;
    
        for (sScan = prectBox->left; sScan < prectBox->right; sScan++)
        {
            while (prevList->sScan <= sScan)
            {
                sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
                prevList = prevList->prevLink;                  /* link to next reversal */
            }
            *ppsVOnBegin = psScanIx;
            ppsVOnBegin++;
            *ppsVOnEnd = psScanIx;
            ppsVOnEnd++;
            psScanIx += sCross;
                    
            *ppsVOffBegin = psScanIx;
            ppsVOffBegin++;
            *ppsVOffEnd = psScanIx;
            ppsVOffEnd++;
            psScanIx += sCross;
            *ppsVOffMax = psScanIx;
            ppsVOffMax++;
        }
        if (usScanKind & SK_SMART)              /* if smart dropout */
        {
            STATE.afxXPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
            if(STATE.afxXPoints == NULL)
                return MEM_SUBALLOC_ERR;

            STATE.afxYPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
            if(STATE.afxYPoints == NULL)
                return MEM_SUBALLOC_ERR;
        }
    }
    return NO_ERR;
}

/*********************************************************************/

/* This function saves the first contour point for smart dropout calcs */

FS_PUBLIC int32 fsc_BeginContourScan(
		PSTATE                              /* pointer to state variables */
		uint16 usScanKind,                  /* scan type */
		F26Dot6 fxX1,                       /* starting point x coordinate */
		F26Dot6 fxY1                        /* starting point y coordinate */
)
{
	if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART)) /* if smart dropout */
	{
		STATE.afxXPoints[STATE.lPoint] = fxX1;
		STATE.afxYPoints[STATE.lPoint] = fxY1;
		STATE.lPoint++;
		Assert (STATE.lPoint <= STATE.lElementPoints); /* have not allocated enough element space */

		if(STATE.lPoint > STATE.lElementPoints)
			return MEM_OVERRUN_ERR;
	}

	return NO_ERR;
}

/*********************************************************************/
	
/* This function is called at the beginning of each line, subdivided */
/* spline, or endpoint-on-scanline.  It sets scanline state variables, */
/* save control points (for smart dropout control), and return the */
/* appropriate AddScan function pointers */

FS_PUBLIC int32 fsc_BeginElement(
	PSTATE                                      /* pointer to state variables */
	uint16 usScanKind,                          /* type of dropout control */
	int32 lQuadrant,                            /* determines scan on/off */
	int32 lElementCode,                         /* element (line, spline, ep) */
	int32 lPts,                                 /* number of points to store */
	F26Dot6 *pfxX,                              /* next x control point(s) */
	F26Dot6 *pfxY,                              /* next y control point(s) */
	int32 (**ppfnAddHorizScan)(PSTATE int32, int32),  /* horiz add scan return */
	int32 (**ppfnAddVertScan)(PSTATE int32, int32)    /* vert add scan return */
)
{
	*ppfnAddHorizScan = STATE.pfnAddHoriz;      /* set horiz add scan func */
	*ppfnAddVertScan = STATE.pfnAddVert;        /* set vert add scan func */

	
    if ((lQuadrant == 1) || (lQuadrant == 2))
    {
        STATE.apsHorizBegin = STATE.apsHOnBegin;    /* add 'on' interscections */
        STATE.apsHorizEnd = STATE.apsHOnEnd;
        STATE.apsHorizMax = STATE.apsHOffBegin;  /* the max for the on array is the beginning of off array */
    }
    else
    {
        STATE.apsHorizBegin = STATE.apsHOffBegin;   /* add 'off' interscections */
        STATE.apsHorizEnd = STATE.apsHOffEnd;
        STATE.apsHorizMax = STATE.apsHOffMax; /* the max for the off array is the max array */ 
    }
    
    if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
    {
        if ((lQuadrant == 2) || (lQuadrant == 3))
        {
            STATE.apsVertBegin = STATE.apsVOnBegin; /* add 'on' interscections */
            STATE.apsVertEnd = STATE.apsVOnEnd;
            STATE.apsVertMax = STATE.apsVOffBegin;  /* the max for the on array is the beginning of off array */
        }
        else
        {
            STATE.apsVertBegin = STATE.apsVOffBegin; /* add 'off' interscections */
            STATE.apsVertEnd = STATE.apsVOffEnd;
            STATE.apsVertMax = STATE.apsVOffMax; /* the max for the off array is the max array */
        }
		
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
            Assert((STATE.lPoint - 1) <= (0xFFFF >> SC_CODESHFT)); /* exceeding max number of points of scan conversion with smart dropout control (2^14 - 1) */
			if((STATE.lPoint - 1) > (0xFFFF >> SC_CODESHFT))
				return SMART_DROP_OVERFLOW_ERR;
			
			STATE.usScanTag = (uint16)(((STATE.lPoint - 1) << SC_CODESHFT) | lElementCode);

			while (lPts > 0)                    /* save control points */
			{
				STATE.afxXPoints[STATE.lPoint] = *pfxX;
				pfxX++;
				STATE.afxYPoints[STATE.lPoint] = *pfxY;
				pfxY++;
				STATE.lPoint++;
				lPts--;
				Assert (STATE.lPoint <= STATE.lElementPoints); /* have not allocated enough element space. */
				if(STATE.lPoint > STATE.lElementPoints)
					return MEM_OVERRUN_ERR;
			}
		}
	}

	return NO_ERR;
}


/*********************************************************************/

/*      Add Scanline Intersection Functions                          */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal scan list array  */

FS_PRIVATE int32 AddHorizSimpleScan(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    int16 *psBegin;                 /* pts to first array element */
    int16 *psEnd;                   /* pts past last element */
    int16 *psLead;                  /* leads psEnd walking backward */
    int16 sX;

/* printf("H(%li, %li)  ", lX, lY); */
	 
	/* x or y value is outside bounding box	*/
	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX <= STATE.lBoxRight);
    Assert(lY >= STATE.lBoxBottom);
    Assert(lY < STATE.lBoxTop);

    if((lX < STATE.lBoxLeft) || (lX > STATE.lBoxRight) || (lY < STATE.lBoxBottom) || (lY >= STATE.lBoxTop))
         return SCAN_ERR;

    lY -= STATE.lBoxBottom;         /* normalize */
    psBegin = STATE.apsHorizBegin[lY];
    ppsEnd = &STATE.apsHorizEnd[lY];
    psEnd = *ppsEnd;
    (*ppsEnd)++;                    /* bump ptr for next time */

    Assert(*ppsEnd <= STATE.apsHorizMax[lY]); 

    if(*ppsEnd > STATE.apsHorizMax[lY])
        return SCAN_ERR;
    
    psLead = psEnd - 1;
    sX = (int16)lX;
    
    while((psLead >= psBegin) && (*psLead > sX))
    {
        *psEnd-- = *psLead--;       /* make room */
    }
    *psEnd = sX;                    /* store new value */

	return NO_ERR;
}

/*********************************************************************/

/*  Sort a simple intersection into the vertical scan list array  */

FS_PRIVATE int32 AddVertSimpleScan(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    int16 *psBegin;                 /* pts to first array element */
    int16 *psEnd;                   /* pts past last element */
    int16 *psLead;                  /* leads psEnd walking backward */
    int16 sY;

/* printf("V(%li, %li)  ", lX, lY); */

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX < STATE.lBoxRight);
    Assert(lY >= STATE.lBoxBottom);
    Assert(lY <= STATE.lBoxTop);

	if((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight) || (lY < STATE.lBoxBottom) || (lY > STATE.lBoxTop))
         return SCAN_ERR;

    lX -= STATE.lBoxLeft;           /* normalize */
    psBegin = STATE.apsVertBegin[lX];
    ppsEnd = &STATE.apsVertEnd[lX];
    psEnd = *ppsEnd;
    (*ppsEnd)++;                    /* bump ptr for next time */

    Assert(*ppsEnd <= STATE.apsVertMax[lX]); 

    if(*ppsEnd > STATE.apsVertMax[lX])
        return SCAN_ERR;
    
    psLead = psEnd - 1;
    sY = (int16)lY;
    
    while((psLead >= psBegin) && (*psLead > sY))
    {
        *psEnd-- = *psLead--;       /* make room */
    }
    *psEnd = sY;                    /* store new value */

	return NO_ERR;
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal scan list array  */

FS_PRIVATE int32 AddHorizSmartScan(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    uint32 *pulBegin;                /* pts to first array element */
    uint32 *pulEnd;                  /* pts past last element */
    uint32 *pulLead;                 /* leads pulEnd walking backward */
    int16 *psInsert;                /* new data insertion point */
    int16 sX;

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX <= STATE.lBoxRight);
    Assert(lY >= STATE.lBoxBottom);
    Assert(lY < STATE.lBoxTop);

	if((lX < STATE.lBoxLeft) || (lX > STATE.lBoxRight) || (lY < STATE.lBoxBottom) || (lY >= STATE.lBoxTop))
         return SCAN_ERR;
    
    lY -= STATE.lBoxBottom;         /* normalize */
    pulBegin = (uint32*)STATE.apsHorizBegin[lY];
    ppsEnd = &STATE.apsHorizEnd[lY];
    pulEnd = (uint32*)*ppsEnd;
    (*ppsEnd) += 2;                 /* value & tag */

    Assert(*ppsEnd <= STATE.apsHorizMax[lY]); 

   if(*ppsEnd > STATE.apsHorizMax[lY])
        return SCAN_ERR;

    pulLead = pulEnd - 1;
    sX = (int16)lX;

    while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
    {
        *pulEnd-- = *pulLead--;     /* make room */
    }
    psInsert = (int16*)pulEnd;
    *psInsert = sX;                 /* store new value */
    psInsert++;
    *psInsert = STATE.usScanTag;    /* keep tag too */

	return NO_ERR;
}

/*********************************************************************/

/*  Sort a smart intersection into the vertical scan list array  */

FS_PRIVATE int32 AddVertSmartScan(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    uint32 *pulBegin;                /* pts to first array element */
    uint32 *pulEnd;                  /* pts past last element */
    uint32 *pulLead;                 /* leads pulEnd walking backward */
    int16 *psInsert;                /* new data insertion point */
    int16 sY;

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX < STATE.lBoxRight);
    Assert(lY >= STATE.lBoxBottom);
    Assert(lY <= STATE.lBoxTop);

	if((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight) || (lY < STATE.lBoxBottom) || (lY > STATE.lBoxTop))
         return SCAN_ERR;
    
    lX -= STATE.lBoxLeft;         /* normalize */
    pulBegin = (uint32*)STATE.apsVertBegin[lX];
    ppsEnd = &STATE.apsVertEnd[lX];
    pulEnd = (uint32*)*ppsEnd;
    (*ppsEnd) += 2;                 /* value & tag */

    Assert(*ppsEnd <= STATE.apsVertMax[lX]); 

	if(*ppsEnd > STATE.apsVertMax[lX])
		return SCAN_ERR;

    pulLead = pulEnd - 1;
    sY = (int16)lY;

    while((pulLead >= pulBegin) && (*((int16*)pulLead) > sY))
    {
        *pulEnd-- = *pulLead--;     /* make room */
    }
    psInsert = (int16*)pulEnd;
    *psInsert = sY;                 /* store new value */
    psInsert++;
    *psInsert = STATE.usScanTag;    /* keep tag too */

	return NO_ERR;
}

/*********************************************************************/

/*  Add an intersection with banding                                 */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal band list array  */

FS_PRIVATE int32 AddHorizSimpleBand(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    int16 *psBegin;                 /* pts to first array element */
    int16 *psEnd;                   /* pts past last element */
    int16 *psLead;                  /* leads psEnd walking backward */
    int16 sX;

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX <= STATE.lBoxRight);

	if((lX < STATE.lBoxLeft) || (lX > STATE.lBoxRight))
         return SCAN_ERR;
    
    if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
    {
        lY -= STATE.lLoScanBand;    /* normalize */
        psBegin = STATE.apsHorizBegin[lY];
        ppsEnd = &STATE.apsHorizEnd[lY];
        psEnd = *ppsEnd;
        (*ppsEnd)++;                /* bump ptr for next time */

        Assert(*ppsEnd <= STATE.apsHorizMax[lY]); 

		if(*ppsEnd > STATE.apsHorizMax[lY])
			return SCAN_ERR;

        psLead = psEnd - 1;
        sX = (int16)lX;

        while((psLead >= psBegin) && (*psLead > sX))
        {
            *psEnd-- = *psLead--;   /* make room */
        }
        *psEnd = sX;                /* store new value */
    }

	return NO_ERR;
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal band list array  */

FS_PRIVATE int32 AddHorizSmartBand(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    uint32 *pulBegin;               /* pts to first array element */
    uint32 *pulEnd;                 /* pts past last element */
    uint32 *pulLead;                /* leads pulEnd walking backward */
    int16 *psInsert;                /* new data insertion point */
    int16 sX;

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX <= STATE.lBoxRight);

	if((lX < STATE.lBoxLeft) || (lX > STATE.lBoxRight))
         return SCAN_ERR;
    
    if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
    {
        lY -= STATE.lLoScanBand;    /* normalize */
        pulBegin = (uint32*)STATE.apsHorizBegin[lY];
        ppsEnd = &STATE.apsHorizEnd[lY];
        pulEnd = (uint32*)*ppsEnd;
        (*ppsEnd) += 2;             /* value & tag */

        Assert(*ppsEnd <= STATE.apsHorizMax[lY]); 

		if(*ppsEnd > STATE.apsHorizMax[lY])
			return SCAN_ERR;

        pulLead = pulEnd - 1;
        sX = (int16)lX;

        while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
        {
            *pulEnd-- = *pulLead--;  /* make room */
        }
        psInsert = (int16*)pulEnd;
        *psInsert = sX;              /* store new value */
        psInsert++;
        *psInsert = STATE.usScanTag; /* keep tag too */
    }

	return NO_ERR;
}


/*********************************************************************/

/*  When all contours have been scanned, fill in the bitmap          */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap(
		PSTATE                          /* pointer to state variables */
		char *pchBitMap,                /* target memory */
		int32 lHiBand,                  /* top bitmap limit */
		int32 lLoBand,                  /* bottom bitmap limit */
		int32 lRowBytes,                /* bitmap bytes per row */
		int32 lOrgLoBand,               /* original low band row */
		uint16 usScanKind )             /* dropout control value */
{
	int32 lHeight;                      /* of scan band in pixels */
	int32 lIndex;                       /* array index */
	int32 lFirstScan;                   /* first scanline index */

	int16 sXOffset;                     /* bitmap box shift */
	int16 sXStart;                      /* on transition */
	int16 sXStop;                       /* off transition */
	
	uint32 *pulRow;                     /* row beginning pointer */
	uint32 ulBMPLongs;                  /* longs per bitmap */
	int32 lRowLongs;                    /* long words per row */
	int32 lErrCode;
	
	int16 **ppsHOnBegin;                /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	

/*  printf("%li : %li\n", lHiBand, lLoBand); */
	
	STATE.lHiBitBand = lHiBand;                 /* copy bit band limits */
	STATE.lLoBitBand = lLoBand;
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	
	STATE.lRowBytes = lRowBytes;                /* save bytes per row */
	lRowLongs = lRowBytes >> 2;                 /* long words per row */
	
	ulBMPLongs = (uint32)(lRowLongs * (int32)lHeight);
	pulRow = (uint32*)pchBitMap;                /* start at glyph top */
	lErrCode = fsc_ClearBitMap(ulBMPLongs, pulRow);
	if (lErrCode != NO_ERR) return lErrCode;

	sXOffset = (int16)STATE.lBoxLeft;
	
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
						
/*  now go through the bitmap from top to bottom */

	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
				
		Assert(psHorizOnEnd <= psHorizOff); /* if error checking at add scan time then this can stay assert, else make error. */
		Assert(psHorizOnEnd - psHorizOn == STATE.apsHOffEnd[lFirstScan - lIndex] - psHorizOff);

		while (psHorizOn < psHorizOnEnd)
		{
			sXStart = *psHorizOn - sXOffset;
			psHorizOn += STATE.sIxSize;
			sXStop = *psHorizOff - sXOffset;
			psHorizOff += STATE.sIxSize;

			if (sXStart < sXStop)                   /* positive run */
			{
				lErrCode = fsc_BLTHoriz(sXStart, sXStop - 1, pulRow);
			}
			else if (sXStart > sXStop)              /* negative run */
			{
				lErrCode = fsc_BLTHoriz(sXStop, sXStart - 1, pulRow);
			}
			if (lErrCode != NO_ERR) return lErrCode;
		}
		pulRow += lRowLongs;                        /* next row */
	}
	
/* if doing dropout control, do it now */

	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		lErrCode = LookForDropouts(ASTATE pchBitMap, usScanKind);
		if (lErrCode != NO_ERR) return lErrCode;
		
		if (lOrgLoBand != STATE.lLoScanBand)        /* if fast banding & dropout */
		{
			pulRow -= lRowLongs;                    /* back to overscan row */
			pulRow -= lRowLongs;                    /* back to low row */
			lErrCode = fsc_BLTCopy (pulRow, STATE.pulLastRow, lRowLongs);
			if (lErrCode != NO_ERR) return lErrCode;

			STATE.lLastRowIndex = STATE.lLoBitBand + 1; /* save row ID */
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Dropout Control Functions                                    */

/*********************************************************************/
	
FS_PRIVATE int32 LookForDropouts(
		PSTATE                      /* pointer to state variables  */
		char *pchBitMap,
		uint16 usScanKind )         /* dropout control value */
{
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffEnd;
			
	int16 *psVertOn;
	int16 *psVertOff;
	int16 *psVertOnBegin;

	int32 lHeight;
	int32 lWidth;
	int32 lIndex;                   /* array index */
	int32 lFirstScan;               /* first scanline index */
	
	int32 lErrCode;

/*  Check horizontal scan lines for dropouts  */
	
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
		
	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
		
		while (psHorizOn < psHorizOnEnd)
		{
			if (*psHorizOn == *psHorizOff)  /* zero length run */
			{
				lErrCode = DoHorizDropout(ASTATE psHorizOn, psHorizOff,
										 STATE.lHiBitBand - lIndex - 1,
										 pchBitMap,
										 usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psHorizOn += STATE.sIxSize;
			psHorizOff += STATE.sIxSize;
		}
	}
		
/*  Check vertical scan lines for dropouts  */
	
	lWidth = STATE.lBoxRight - STATE.lBoxLeft;
	ppsVOnBegin = STATE.apsVOnBegin;
	ppsVOnEnd = STATE.apsVOnEnd;
	ppsVOffEnd = STATE.apsVOffEnd;
	
	for (lIndex = 0; lIndex < lWidth; lIndex++)
	{
		psVertOnBegin = *ppsVOnBegin;
		ppsVOnBegin++;
		psVertOn = *ppsVOnEnd - STATE.sIxSize;  /* start at end (glyph top) */
		ppsVOnEnd++;
		psVertOff = *ppsVOffEnd - STATE.sIxSize;
		ppsVOffEnd++;
		
		while (psVertOn >= psVertOnBegin)       /* from top to bottom */
		{
			if (*psVertOn == *psVertOff)        /* zero length run */
			{
				lErrCode = DoVertDropout(ASTATE psVertOn, psVertOff,
										 STATE.lBoxLeft + lIndex,
										 pchBitMap, usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psVertOn -= STATE.sIxSize;
			psVertOff -= STATE.sIxSize;
		}
	}
	return NO_ERR;
}


/*********************************************************************/

FS_PRIVATE int32 DoHorizDropout(
		PSTATE                  /* pointer to state variables */
		int16 *psOn,            /* pointer to on intersection */
		int16 *psOff,           /* pointer to off intersection */
		int32 lYDrop,           /* y coord of dropout */
		char *pchBitMap,        /* target memory */
		uint16 usScanKind )     /* dropout control value */
{
	int32 lXDrop;                                   /* x coord of dropout */
	int32 lCross;                                   /* scanline crossings */
	F26Dot6 fxX1, fxX2;                             /* for smart dropout */
	uint16 usOnTag, usOffTag;                       /* element info */
	int16 sOnPt, sOffPt;                            /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);    /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*);   /* off callback */

	lXDrop = (int32)*psOn;
	
/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop + 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation above */
		}
		
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation below */
		}
	}

/*  passed stub control, now check pixels left and right  */

	if (lXDrop > STATE.lBoxLeft)                /* if pixel to left */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop - 1, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}
	if (lXDrop < STATE.lBoxRight)               /* if pixel to right */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}

/*  no pixels left or right, now determine bit placement  */

	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnHCallBack[usOnTag & SC_CODEMASK];
		fxX1 = pfnOn(lYDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnHCallBack[usOffTag & SC_CODEMASK];
		fxX2 = pfnOff(lYDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lXDrop = (int32)((fxX1 + fxX2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lXDrop--;                               /* always to the left */
	}
	
	if (lXDrop < STATE.lBoxLeft)                /* confine to bounding box */
	{
		lXDrop = STATE.lBoxLeft;
	}
	if (lXDrop >= STATE.lBoxRight)
	{
		lXDrop = STATE.lBoxRight - 1L;
	}

	return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
}


/*********************************************************************/

FS_PRIVATE int32 DoVertDropout(
		PSTATE                      /* pointer to state variables */
		int16 *psOn,                /* pointer to on intersection */
		int16 *psOff,               /* pointer to off intersection */
		int32 lXDrop,               /* x coord of dropout */
		char *pchBitMap,            /* target memory descriptor */
		uint16 usScanKind )         /* dropout control value */
{
	int32 lYDrop;                                 /* y coord of dropout */
	int32 lCross;                                 /* scanline crossings */
	F26Dot6 fxY1, fxY2;                           /* for smart dropout */
	uint16 usOnTag, usOffTag;                     /* element info */
	int16 sOnPt, sOffPt;                          /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);  /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*); /* off callback */
	
	lYDrop = (int32)*psOn;

	if ((lYDrop < STATE.lLoBitBand) || (lYDrop > STATE.lHiBitBand))
	{
		return NO_ERR;                          /* quick return for outside band */
	}

/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to left */
		}
		
		lCross = VertCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to right */
		}
	}

/*  passed stub control, now check pixels below and above  */

	if (lYDrop > STATE.lBoxBottom)                  /* if pixel below */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop - 1) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}
	if (lYDrop < STATE.lBoxTop)                     /* if pixel above */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}

/*  no pixels above or below, now determine bit placement  */
	
	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnVCallBack[usOnTag & SC_CODEMASK];
		fxY1 = pfnOn(lXDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnVCallBack[usOffTag & SC_CODEMASK];
		fxY2 = pfnOff(lXDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lYDrop = (int32)((fxY1 + fxY2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lYDrop--;                               /* always below */
	}
	
	if (lYDrop < STATE.lBoxBottom)              /* confine to bounding box */
	{
		lYDrop = STATE.lBoxBottom;
	}
	if (lYDrop >= STATE.lBoxTop)
	{
		lYDrop = STATE.lBoxTop - 1L;
	}
		
	if ((lYDrop >= STATE.lLoBitBand) && (lYDrop < STATE.lHiBitBand))
	{
		return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Count contour crossings of a horizontal scan line segment  */

FS_PRIVATE int32 HorizCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sX;
	
	if ((lY < STATE.lLoScanBand) || (lY >= STATE.lHiScanBand))
	{
		return 0;                       /* if outside the scan region */
	}
	
	lCrossings = 0;
	lIndex = lY - STATE.lLoScanBand;
	psOn = STATE.apsHOnBegin[lIndex];
	psOff = STATE.apsHOffBegin[lIndex];
	psOnEnd = STATE.apsHOnEnd[lIndex];
	sX = (int16)lX;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sX)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sX)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}


/*********************************************************************/

/*  Count contour crossings of a vertical scan line segment  */

FS_PRIVATE int32 VertCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sY;
	
	if ((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight))
	{
		return 0;                       /* if outside the bitmap */
	}
	
	lCrossings = 0;
	lIndex = lX - STATE.lBoxLeft;
	psOn = STATE.apsVOnBegin[lIndex];
	psOff = STATE.apsVOffBegin[lIndex];
	psOnEnd = STATE.apsVOnEnd[lIndex];
	sY = (int16)lY;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sY)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sY)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}
		

/****************************************************************************/

/*              Get a pixel using absolute coordinates                      */

/*  When banding with dropout control, this routine uses the last low row   */
/*  of the previous bitmap when possible.                                   */

FS_PRIVATE uint32 GetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */

	Assert(lX >= STATE.lBoxLeft);  /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	if((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight) || (lY < STATE.lBoxBottom) || (lY >= STATE.lBoxTop))
         return 0;

	if ((lY < STATE.lHiBitBand) && (lY >= STATE.lLoBitBand))  /* if within the bitmap */
	{
		pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
		return fsc_GetBit(lX - STATE.lBoxLeft, pulRow);       /* read the bitmap */
	}
	if (lY == STATE.lLastRowIndex)          /* if saved from last band */
	{
		return fsc_GetBit(lX - STATE.lBoxLeft, STATE.pulLastRow);
	}
	return(0L);                             /* outside bitmap doesn't matter */
}


/*********************************************************************/

/*  Set a pixel using absolute coordinates  */

FS_PRIVATE int32 SetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */
	
	Assert(lX >= STATE.lBoxLeft);    /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lLoBitBand);
	Assert(lY < STATE.lHiBitBand);

	if((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight) || (lY < STATE.lLoBitBand) || (lY >= STATE.lHiBitBand))
		return SCAN_ERR;
	
	pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
	
	return fsc_SetBit(lX - STATE.lBoxLeft, pulRow);
}


/*********************************************************************/

/*      Gray Scale Pass Through Functions                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap (
		uint32 ulCount,                     /* longs per bmp */
		uint32* pulBitMap                   /* bitmap ptr caste long */
)
{
	return fsc_ClearBitMap(ulCount, pulBitMap);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam* pGSP                /* pointer to param block */
)
{
	return fsc_CalcGrayRow(pGSP);
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scale.c ===
/****************************** Module Header ******************************\
* Module Name: Scale.c
*
* Created: 16-Oct-1992
*
* Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
*             (c) 1989-1999. Microsoft Corporation.
*
* All Rights Reserved
*
* History:
*  Tue 16-Oct-1992 09:53:51 -by-  Greg Hitchcock [gregh]
* Created.
*   
*	 7/10/99	BeatS	   Add support for native SP fonts, vertical RGB
*	 4/01/99	BeatS	   Implement alternative interpretation of TT instructions for SP
*	02/21/97    claudebe   scaled component in composite glyphs
*	12/14/95    claudebe   adding two private phantom points for vertical positionning
* .
\***************************************************************************/

#define FSCFG_INTERNAL

/* INCLUDES */

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "scale.h"

#include "stat.h"

/* Constants    */

/* use the lower ones for public phantom points */

// public phantom points moved to fnt.h more global use

/* private phantom points start here */

#define ORIGINPOINT 4
#define LEFTEDGEPOINT 5

#define TOPORIGINPOINT 6
#define TOPEDGEPOINT 7

#define CANTAKESHIFT    0x02000000

/* MACROS   */

/* d is half of the denumerator */
#define FROUND( x, n, d, s ) \
		((SHORTMUL (x, n) + (d)) >> s)

#define SROUND( x, n, d, halfd ) \
	(x < 0 ? -((SHORTMUL (-(x), (n)) + (halfd)) / (d)) : ((SHORTMUL ((x), (n)) + (halfd)) / (d)))

#define NUMBEROFCHARPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1)
#define NUMBEROFTOTALPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1 + PHANTOMCOUNT)

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define ORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + ORIGINPOINT)
#define LEFTEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTEDGEPOINT)

#define TOPORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPORIGINPOINT)
#define TOPEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPEDGEPOINT)

/* PROTOTYPES   */

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D);
FS_PRIVATE F26Dot6 scl_FRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_SRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_FixRound (fnt_ScaleRecord* rec, F26Dot6 value);

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints);

FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);
/* FUNCTIONS    */

#define BOLD_FACTOR 0x51e
#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )
#define POINTSPERINCH               72

void  multiplyForEmbold(long a, long b, long *highRes, long *lowRes)
{
    long lowA, highA, lowB, highB, temp1, temp2;

    lowA = a & 0xffff;
    highA = (a & 0xffff0000) >> 16;
    lowB = b & 0xffff;
    highB = (b & 0xffff0000) >> 16;

    *highRes = highA*highB;
    *lowRes = lowA*lowB;

    temp1 = highA*lowB;
    temp2 = lowA*highB;

    *highRes += (temp1 & 0xffff0000) >> 16;
    *highRes += (temp2 & 0xffff0000) >> 16;

    *lowRes += (temp1 & 0xffff) << 16;
    *lowRes += (temp2 & 0xffff) << 16;
}

void  adjustTrans(transMatrix *trans)   //Adjust matrix for Emboldening
{
    int i,j;
    int  bNegative;
    long tmp, highRes, lowRes;

    for(i=0; i<2; i++)
        for(j=0; j<2; j++){
        
        	tmp = (long) trans->transform[i][j];

            bNegative = tmp < 0 ? TRUE: FALSE;
            tmp = MABS(tmp);

            multiplyForEmbold(tmp, BOLD_FACTOR, &highRes, &lowRes);

            highRes <<= 16;
            tmp -= highRes;

            if(bNegative)
	            tmp = -tmp;

            trans->transform[i][j] = tmp;
        }
}

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm)         /* OUT: Pixels Per Em       */
{
	Fixed        maxScale;
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	transMatrix   origTrans = *trans;
	uint16		usRotation;
	boolean			non90degreeRotation,nonUniformStretching;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	mth_FoldPointSizeResolution(fxPointSize, sXResolution, sYResolution, trans);

	if ( ( (usEmboldWeightx != 0) || (usEmboldWeighty != 0))  && 							// Adjust matrix for Emboldening
		 (uint16)ROUNDFIXTOINT(ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH)) > 50 )// when bigger than 50 ppem
	{
        adjustTrans(trans);
    }

	mth_ReduceMatrix (trans);

	fxUpem = INTTOFIX(usUpem);

/*
 *  First set up the scalars...
 */

	/*save the flag for use in composite glyphs */
	globalGS->bHintAtEmSquare = bHintAtEmSquare;

	if (bHintAtEmSquare)
	{
		globalGS->interpScalarX = fxUpem;
		globalGS->interpScalarY = fxUpem;
		globalGS->fxMetricScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->fxMetricScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);

		/* we don't want to round the interpScalar */
	}
	else
	{
		globalGS->interpScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->interpScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);
		globalGS->fxMetricScalarX = globalGS->interpScalarX;
		globalGS->fxMetricScalarY = globalGS->interpScalarY;

		if (bIntegerScaling)
		{
			globalGS->interpScalarX = (Fixed)ROUNDFIXED(globalGS->interpScalarX);
			globalGS->interpScalarY = (Fixed)ROUNDFIXED(globalGS->interpScalarY);
		}
	}

	globalGS->ScaleFuncX = scl_ComputeScaling(&globalGS->scaleX, globalGS->interpScalarX, fxUpem);
	globalGS->ScaleFuncY = scl_ComputeScaling(&globalGS->scaleY, globalGS->interpScalarY, fxUpem);

	if (globalGS->interpScalarX >= globalGS->interpScalarY)
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncX;
		globalGS->scaleCVT = globalGS->scaleX;
		globalGS->cvtStretchX = ONEFIX;
		globalGS->cvtStretchY = FixDiv(globalGS->interpScalarY, globalGS->interpScalarX);;
		maxScale = globalGS->interpScalarX;
	}
	else
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncY;
		globalGS->scaleCVT = globalGS->scaleY;
		globalGS->cvtStretchX = FixDiv(globalGS->interpScalarX, globalGS->interpScalarY);
		globalGS->cvtStretchY = ONEFIX;
		maxScale = globalGS->interpScalarY;
	}

	*pulPixelsPerEm = (uint32)ROUNDFIXTOINT (globalGS->interpScalarY);

	globalGS->bSameStretch  = (uint8)mth_SameStretch( globalGS->interpScalarX, globalGS->interpScalarY );
	globalGS->pixelsPerEm   = (uint16)ROUNDFIXTOINT(maxScale);
	globalGS->pointSize     = (uint16)ROUNDFIXTOINT( fxPointSize );
	globalGS->fpem          = maxScale;
	globalGS->identityTransformation = (int8)mth_PositiveSquare( trans );

	/* Use bit 1 of non90degreeTransformation to signify stretching.  stretch = 2 */

	mth_Non90DegreeTransformation(&origTrans,&non90degreeRotation,&nonUniformStretching);

	globalGS->non90DegreeTransformation = 0;

	if (non90degreeRotation)  globalGS->non90DegreeTransformation |= NON90DEGTRANS_ROTATED;
	if (nonUniformStretching) globalGS->non90DegreeTransformation |= NON90DEGTRANS_STRETCH;


	*psBoldSimulHorShift = 0;
	*psBoldSimulVertShift = 0;

	if ((usEmboldWeightx != 0) || (usEmboldWeighty != 0))
	{
		/* we cannot use globalGS->pixelsPerEm because it s incorrect under non 90degree rotation */
		uint16 ppemY;
		Fixed fxBoldSimulHorShift,fxBoldSimulVertShift;
		F26Dot6	fxDefaultDescender;
        transMatrix reverseTrans;
        Fixed   fxDeterminant;
		Fixed fxScale;

		fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
		ppemY = (uint16)ROUNDFIXTOINT(fxScale);  
		usRotation = mth_90degRotationFactorForEmboldening(trans);
		if( usRotation == 8 )   // Consider Italic/Bold case
            usRotation = mth_90degClosestRotationFactor(trans);

		if (bHintAtEmSquare)
		{
            *psBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000; /* save the number of pixels for bitmap emboldening */
			ppemY = usUpem;
		}

		/* this computation is intended to give backwards compatible results with the
			bitmap emboldening simulation done in Windows NT 4.0
		    The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
			for an emboldening factor of 2% (usEmboldWeight = 20)
		*/

		globalGS->uBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000;
		globalGS->uBoldSimulHorShift = (ppemY * usEmboldWeightx - 10) /1000 + 1;

		if (!bHintAtEmSquare)
		    *psBoldSimulVertShift = globalGS->uBoldSimulVertShift; /* save the number of pixels for bitmap emboldening */

 		switch(usRotation)                   /* handle 90 degree rotations */
		{
		case 0:                                     // 0 degree with sx>0 & sy>0 or 180 degree with sx<0 & sy<0
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift);
 			break;
		case 1:                                     // 90 degree with sx>0 & sy>0 or 270 degree with sx<0 & sy<0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift);
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 2:                                     // 180 degree with sx>0 & sy>0 or 0 degree with sx<0 & sy<0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = *psBoldSimulVertShift;
			break;
		case 3:                                     // 270 degree with sx>0 & sy>0 or 90 degree with sx<0 & sy<0
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		case 4:                                     // 0 degree with sx>0 & sy<0 or 180 degree with sx<0 & sy>0
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = *psBoldSimulVertShift;
 			break;
		case 5:                                     // 90 degree with sx>0 & sy<0 or 270 degree with sx<0 & sy>0
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 6:                                     // 180 degree with sx>0 & sy<0 or 0 degree with sx<0 & sy>0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = -*psBoldSimulVertShift;
			break;
		case 7:                                     // 270 degree with sx>0 & sy<0 or 90 degree with sx<0 & sy>0
			*psBoldSimulHorShift = -*psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		default:                                    /* non 90 degree rotation */
			*psBoldSimulHorShift = 0;
			*psBoldSimulVertShift = 0;
		}

		if (!bHintAtEmSquare && (sYResolution != sXResolution))
		{
			fxBoldSimulHorShift = globalGS->uBoldSimulHorShift << 16;
			fxBoldSimulVertShift = globalGS->uBoldSimulVertShift << 16;
            fxDeterminant = MABS( FixMul(origTrans.transform[0][0],origTrans.transform[1][1]) - FixMul(origTrans.transform[0][1],origTrans.transform[1][0]) );

			if (fxDeterminant == 0)
			{
				globalGS->uBoldSimulHorShift = 0;  
				globalGS->uBoldSimulVertShift = 0;  
			}
			else
			{
				origTrans.transform[0][0] = FixDiv(origTrans.transform[0][0], fxDeterminant);
				origTrans.transform[0][1] = FixDiv(origTrans.transform[0][1], fxDeterminant);
				origTrans.transform[1][0] = FixDiv(origTrans.transform[1][0], fxDeterminant);
				origTrans.transform[1][1] = FixDiv(origTrans.transform[1][1], fxDeterminant);
				reverseTrans = origTrans;
				reverseTrans.transform[0][1] = - reverseTrans.transform[0][1];
				reverseTrans.transform[1][0] = - reverseTrans.transform[1][0];

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&origTrans,
					ONEFIX,
					ONEFIX);

				fxBoldSimulHorShift = ShortMulDiv(fxBoldSimulHorShift, sXResolution, sYResolution);

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&reverseTrans,
					ONEFIX,
					ONEFIX);

				globalGS->uBoldSimulHorShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulHorShift));  
				globalGS->uBoldSimulVertShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulVertShift));  
			}

        }

		if (!bHintAtEmSquare && !(globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
		{
			/* 90 degree rotation, convert the device value into 26.6 */
			globalGS->fxScaledDescender = -lDescDev << 6;
		} else 
		{
			/* under rotation, we use the value from head-Descender and scale it */
			fxDefaultDescender = sWinDescender;

			scl_Scale (&globalGS->scaleY,
					globalGS->ScaleFuncY,
					&fxDefaultDescender,
					&globalGS->fxScaledDescender,
					1);

			/* add the uBoldSimulVertShift and round to the next pixel */
			globalGS->fxScaledDescender = globalGS->fxScaledDescender & ~(LOWSIXBITS);
		}
	} else {
		globalGS->uBoldSimulHorShift = 0;
		globalGS->uBoldSimulVertShift = 0;
		globalGS->fxScaledDescender = 0;
	}
	return NO_ERR;
}

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem)                 /* Current units per Em     */
{
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed           interpScalarX;    
	Fixed           interpScalarY;    

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	fxUpem = INTTOFIX(usUpem);

/* 
 * This procedure is a subset from scl_InitializeScaling. 
 * There is no perfect solution here, we decided that the best, in the case of a
 * component that is not at the same transformation as the master glyph,
 * is to scale this child glyph to the user grid for hinting, without re-running
 * the pre-program, without rescaling the cvt or changing other GloblaGS information (pointSize, pixelPerEm,...)
 */

/*
 *  First set up the scalars...
 */
	if (globalGS->bHintAtEmSquare)
	{
		interpScalarX = fxUpem;
		interpScalarY = fxUpem;
	}
	else
	{
		interpScalarX = mth_max_abs (CurrentTMatrix.transform[0][0], CurrentTMatrix.transform[0][1]);
		interpScalarY = mth_max_abs (CurrentTMatrix.transform[1][0], CurrentTMatrix.transform[1][1]);
	}

	globalGS->ScaleFuncXChild = scl_ComputeScaling(&globalGS->scaleXChild, interpScalarX, fxUpem);
	globalGS->ScaleFuncYChild = scl_ComputeScaling(&globalGS->scaleYChild, interpScalarY, fxUpem);

}

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->bHintForGray = bHintForGray;

#ifdef FSCFG_SUBPIXEL
	globalGS->flHintForSubPixel = flHintForSubPixel;
#endif // FSCFG_SUBPIXEL
}

/******************** These three scale 26.6 to 26.6 ********************/
/*
 * Fast (scaling)
 */
FS_PRIVATE F26Dot6 scl_FRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FROUND (value, rec->numer, rec->denom >> 1, rec->shift);
}

/*
 * Medium (scaling)
 */
FS_PRIVATE F26Dot6 scl_SRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	int32 D;

	D = rec->denom;
	return (F26Dot6) SROUND (value, rec->numer, D, D >> 1);
}

/*
 * Fixed Rounding (scaling), really slow
 */
FS_PRIVATE F26Dot6 scl_FixRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FixMul ((Fixed)value, rec->fixedScale);
}

/********************************* End scaling utilities ************************/

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D)
{
	int32     lShift;

	lShift = mth_CountLowZeros((uint32)(N | D) ) - 1;

	if (lShift > 0)
	{
		N >>= lShift;
		D >>= lShift;
	}


	if ( N < CANTAKESHIFT )
	{
		N <<= FNT_PIXELSHIFT;
	}
	else
	{
		D >>= FNT_PIXELSHIFT;
	}

	/* fixedScale is now set in every case for the scale back in scaled composites */
	rec->fixedScale = FixDiv(N, D);

	if (N <= SHRT_MAX)   /* Check to see if N fits in a short    */
	{
		lShift = mth_GetShift ((uint32) D);
		rec->numer = (int32)N;
		rec->denom = (int32)D;

		if ( lShift >= 0 )                  /* FAST SCALE */
		{
			rec->shift = (int32)lShift;
			return (GlobalGSScaleFunc)scl_FRound;
		}
		else                                /* MEDIUM SCALE */
		{
			return (GlobalGSScaleFunc)scl_SRound;
		}
	}
	else                                    /* SLOW SCALE */
	{
		return (GlobalGSScaleFunc)scl_FixRound;
	}
}


FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	if (ScaleFunc == scl_FRound)
	{
		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, sr->shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], sr->numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], sr->fixedScale);
			}
		}
	}
}


FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	Scale;
	int32	Shift;
	int32	Numer;

	/* we are now multiplying a 26.6 by sr->numer, we could overflow if (sr->numer >= SHRT_MAX >> FNT_PIXELSHIFT) */
	if ((ScaleFunc == scl_FRound) && (sr->numer < (SHRT_MAX >> FNT_PIXELSHIFT) ))
	{
		
		Shift = sr->shift + FNT_PIXELSHIFT;

		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, Shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			Numer = sr->numer >> FNT_PIXELSHIFT;

			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], Numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			Scale = sr->fixedScale >> FNT_PIXELSHIFT;
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], Scale);
			}
		}
	}
}

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	ScaleBack;

	ScaleBack = sr->fixedScale >> FNT_PIXELSHIFT;
	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (F26Dot6) FixDiv ((Fixed)oop[Index], ScaleBack);
	}
}

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (Fixed)oop[Index] << FNT_PIXELSHIFT;
	}
}

/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleOldCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}
/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleOldPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}

}

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;


	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	Assert(globalGS->bSameTransformAsMaster);

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ScaleFromFixedFUnits (&globalGS->scaleX,
			   globalGS->ScaleFuncX,
			   &(pElement->x[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ScaleFromFixedFUnits (&globalGS->scaleY,
			   globalGS->ScaleFuncY,
			   &(pElement->y[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

}

/*
 *  scl_ScaleBackCurrentCharPoints                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
}

/*
 *  scl_OriginalCharPointsToCurrentFixedFUnits                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{

	scl_ConvertToFixedFUnits (
			   pElement->oox,
			   pElement->x,
			   (int32)NUMBEROFCHARPOINTS(pElement));

	scl_ConvertToFixedFUnits (
			   pElement->ooy,
			   pElement->y,
			   (int32)NUMBEROFCHARPOINTS(pElement));
}

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{
	uint16                    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ConvertToFixedFUnits (
			   &(pElement->oox[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ConvertToFixedFUnits (
			   &(pElement->ooy[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);
}

/*
 * scl_ScaleCVT
 */

FS_PUBLIC void  scl_ScaleCVT(
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if(globalGS->cvtCount > 0)
	{
		scl_Scale (
			&globalGS->scaleCVT,
			globalGS->ScaleFuncCVT,
			pfxCVT,
			globalGS->controlValueTable,
			(int32)globalGS->cvtCount);
	}
}

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pfxCVT = globalGS->controlValueTable;

}

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH)  /* Non-scaled Advance Height    */
{

	F26Dot6             fxXMinMinusLSB;
	F26Dot6             fxYMaxPlusTSB;

	MEMSET (&(pElement->ooy[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->ooy[0]));

	MEMSET (&(pElement->oox[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->oox[0]));

	fxXMinMinusLSB = ((F26Dot6)bbox->xMin - (F26Dot6)sNonScaledLSB);

	pElement->oox[LSBPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[RSBPOINTNUM(pElement)] = fxXMinMinusLSB + (F26Dot6)usNonScaledAW;
	pElement->oox[ORIGINPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[LEFTEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->xMin;

	fxYMaxPlusTSB = ((F26Dot6)bbox->yMax + (F26Dot6)sNonScaledTSB);

	pElement->ooy[TOPSBPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[BOTTOMSBPOINTNUM(pElement)] = fxYMaxPlusTSB - (F26Dot6)usNonScaledAH;
	pElement->ooy[TOPORIGINPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[TOPEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->yMax;
}

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
	uint16      cNumCharPoints;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	cNumCharPoints = NUMBEROFCHARPOINTS(pElement);

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		0,
		cNumCharPoints);

}

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		LSBPOINTNUM(pElement),
		PHANTOMCOUNT);
}

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6 fxOldLeftOrigin;
	F26Dot6 fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	pElement->ox[LSBPOINTNUM(pElement)]  = fxNewLeftOrigin;
	pElement->ox[RSBPOINTNUM(pElement)] += fxNewLeftOrigin - fxOldLeftOrigin;
}

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->ox, pElement->x, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->oy, pElement->y, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->x, pElement->ox, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->y, pElement->oy, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	uint16    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);
	MEMCPY(&pElement->x[usFirstPhantomPoint],
		   &pElement->ox[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));

	MEMCPY(&pElement->y[usFirstPhantomPoint],
		   &pElement->oy[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution)
{
	F26Dot6     fxWidth;
	F26Dot6     fxHeight;
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	/* autoround the right side bearing */

	fxWidth = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarX,
		(int16)(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxWidth = globalGS->ScaleFuncX(&globalGS->scaleX,
		(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]));
*/

#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)  ) {
		fxWidth += VIRTUAL_PIXELSIZE_RTG / 2;
		fxWidth &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else { // for SubPixel in compatible width mode, always round to full pixel to get full pixel advance width
#endif
		fxWidth += FNT_PIXELSIZE / 2;
		fxWidth &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif
	pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + fxWidth;

	/* autoround the top side bearing */

	fxHeight = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarY,
		(int16)(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxHeight = globalGS->ScaleFuncY(&globalGS->scaleY,
		(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]));
*/

	/* in the vertical direction, as we don't round the old TOPSBPOINT 
	    and do scl_ShiftOldPoints, we need to round TOPSBPOINT here */
	pElement->y[TOPSBPOINTNUM(pElement)] =
		(pElement->y[TOPSBPOINTNUM(pElement)] + DOT6ONEHALF) & ~(LOWSIXBITS);

	pElement->y[BOTTOMSBPOINTNUM(pElement)] =
		pElement->y[TOPSBPOINTNUM(pElement)] + (fxHeight + DOT6ONEHALF) & ~(LOWSIXBITS);
}

/*
 *  scl_ShiftChar
 *
 *  Shifts a character          <3>
 */
FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift)

{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->x[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->y[ulCharIndex] += fxYShift;
		}
	}
}

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints)
{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->ox[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->oy[ulCharIndex] += fxYShift;
		}
	}
}

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset)         /* Y Offset             */
{
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed     scalarX;
	Fixed     scalarY;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (bSameTransformAsMaster) {
		*pfxXOffset = globalGS->ScaleFuncX(&globalGS->scaleX,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncY(&globalGS->scaleY,(F26Dot6)sYOffset);
	} else {
		*pfxXOffset = globalGS->ScaleFuncXChild(&globalGS->scaleXChild,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncYChild(&globalGS->scaleYChild,(F26Dot6)sYOffset);
	}

	if (bScaleCompositeOffset)
	/* the composite is designed to have its offset scaled (designed for Apple) */
	{
		/* Apple use a 45 degree special case that they are dropping on their GX rasterizer,
		   I'm not implementing this special rule here */
		scalarX = mth_max_abs (mulT.transform[0][0], mulT.transform[0][1]);
		scalarY = mth_max_abs (mulT.transform[1][0], mulT.transform[1][1]);
		if ((scalarX != ONEFIX) || (scalarY != ONEFIX)) {
			*pfxXOffset = (F26Dot6) FixMul ((Fixed)*pfxXOffset, scalarX);
			*pfxYOffset = (F26Dot6) FixMul ((Fixed)*pfxYOffset, scalarY);
		}
	}

	if (bRounding) {
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) != VerticalSPDirection(globalGS)))) {
			*pfxXOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxXOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxXOffset += FNT_PIXELSIZE / 2;
			*pfxXOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) == VerticalSPDirection(globalGS)))) {
			*pfxYOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxYOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxYOffset += FNT_PIXELSIZE / 2;
			*pfxYOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}
	if (!bSameTransformAsMaster)
	/* we need to scale back the offset in fixed FUnits */
	{
		scl_ScaleBack (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pfxXOffset,
				pfxXOffset,
				1 /* only one value to scale */);
		scl_ScaleBack (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pfxYOffset,
				pfxYOffset,
				1 /* only one value to scale */);
	}
}

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset)         /* Y Offset             */
{
	*pfxXOffset = pParentElement->x[usAnchorPoint1] - pChildElement->x[usAnchorPoint2];
	*pfxYOffset = pParentElement->y[usAnchorPoint1] - pChildElement->y[usAnchorPoint2];
}



FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pElement->x[usPhantomPointNumber] = pptLSB->x;
	pElement->y[usPhantomPointNumber] = pptLSB->y;
	usPhantomPointNumber++;
	pElement->x[usPhantomPointNumber] = pptRSB->x;
	pElement->y[usPhantomPointNumber] = pptRSB->y;
}

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pptLSB->x = pElement->x[usPhantomPointNumber];
	pptLSB->y = pElement->y[usPhantomPointNumber];
	usPhantomPointNumber++;
	pptRSB->x = pElement->x[usPhantomPointNumber];
	pptRSB->y = pElement->y[usPhantomPointNumber];
}

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,       /* Element  */
	int16               sMaxPoints,
	int16               sMaxContours)
{
	pElement->sp[0] = 0;
	pElement->ep[0] = sMaxPoints - 1;
	pElement->nc = sMaxContours;
}

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType * pElement,     /* Element pointer  */
	uint16      usNumberOfPoints,
	uint16      usNumberOfContours)
{

	MEMSET (&pElement->x[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->y[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ooy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->onCurve[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));
	MEMSET (&pElement->f[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));

	MEMSET (&pElement->sp[0], 0, (size_t)usNumberOfContours * sizeof(int16));
	MEMSET (&pElement->ep[0], 0, (size_t)usNumberOfContours * sizeof(int16));
}

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement)     /* Element pointer  */
{
	MEMSET (&pElement->f[0], 0, (size_t)NUMBEROFTOTALPOINTS(pElement) * sizeof(uint8));
}

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usParentNewStartPoint;

	if(pParentElement->nc != 0)
	{
		usParentNewStartPoint = LSBPOINTNUM(pParentElement);

		pChildElement->x = &pParentElement->x[usParentNewStartPoint];
		pChildElement->y = &pParentElement->y[usParentNewStartPoint];

		pChildElement->ox = &pParentElement->ox[usParentNewStartPoint];
		pChildElement->oy = &pParentElement->oy[usParentNewStartPoint];

		pChildElement->oox = &pParentElement->oox[usParentNewStartPoint];
		pChildElement->ooy = &pParentElement->ooy[usParentNewStartPoint];

		pChildElement->onCurve = &pParentElement->onCurve[usParentNewStartPoint];
		pChildElement->f = &pParentElement->f[usParentNewStartPoint];

		pChildElement->fc = &pParentElement->fc[pParentElement->nc];

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		pChildElement->pcr = &pParentElement->pcr[usParentNewStartPoint];
#endif

		pChildElement->sp = &pParentElement->sp[pParentElement->nc];
		pChildElement->ep = &pParentElement->ep[pParentElement->nc];

		pChildElement->nc = 0;
	}
	else
	{
		MEMCPY(pChildElement, pParentElement, sizeof(fnt_ElementType));
	}
}

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usNumberOfParentPoints;
	uint32          ulPointIndex;

	if(pParentElement->nc != 0)
	{
		usNumberOfParentPoints = NUMBEROFCHARPOINTS(pParentElement);

		for(ulPointIndex = (uint32)(uint16)pParentElement->nc;
			ulPointIndex < (uint32)(uint16)pParentElement->nc + (uint32)(uint16)pChildElement->nc;
			ulPointIndex++)
		{
			pParentElement->sp[ulPointIndex] += (int16)usNumberOfParentPoints;
			pParentElement->ep[ulPointIndex] += (int16)usNumberOfParentPoints;
		}
	}

	pParentElement->nc += pChildElement->nc;
}

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement)
{
	 uint16 usNumberOfPoints;
	 uint32 ulSize;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 ulSize =  sizeof( pElement->nc );
	 ulSize += sizeof( *pElement->sp ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->ep ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->x ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->y ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->onCurve ) * (size_t)usNumberOfPoints;

	 return( ulSize );
}

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 *((int16 *)*ppbyOutline) = pElement->nc;
	 *ppbyOutline += sizeof( pElement->nc   );

	 MEMCPY(*ppbyOutline, pElement->sp, (size_t)pElement->nc * sizeof( *pElement->sp ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->ep, (size_t)pElement->nc * sizeof( *pElement->ep ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->x, (size_t)usNumberOfPoints * sizeof(*pElement->x));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->x );

	 MEMCPY(*ppbyOutline, pElement->y, (size_t)usNumberOfPoints * sizeof(*pElement->y));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->y );

	 MEMCPY(*ppbyOutline, pElement->onCurve, (size_t)usNumberOfPoints * sizeof(*pElement->onCurve));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->onCurve );

}

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 pElement->nc = *((int16 *)(*ppbyOutline));
	 *ppbyOutline += sizeof( int16 );

	 pElement->sp = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 pElement->ep = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 pElement->x = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->y = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->onCurve = (uint8 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( uint8 );
}

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceWidth->x = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarX, (int16)usNonScaledAW, (int16)usEmResolution );
        if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceWidth->x = FixRatio( (int16)usNonScaledAW, (int16)usEmResolution );
        if ((globalGS->fxMetricScalarX != ONEFIX) && (globalGS->uBoldSimulHorShift != 0))
        {
            AdvanceWidth->x = FixMul(AdvanceWidth->x, globalGS->fxMetricScalarX);
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
            AdvanceWidth->x = FixDiv(AdvanceWidth->x, globalGS->fxMetricScalarX);
        }
        else
        {
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        }
		mth_FixXYMul( &AdvanceWidth->x, &AdvanceWidth->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceHeight->y = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarY, (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
		mth_FixXYMul( &AdvanceHeight->x, &AdvanceHeight->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing
)
{
	fnt_GlobalGraphicStateType *    globalGS;

	if ( bPositiveSquare )
	{
	    globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
		pvecAdvanceHeight->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    (int16)usNonScaledAH, 
		    (int16)usEmResolution );
		
		pvecTopSideBearing->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    sNonScaledTSB, 
		    (int16)usEmResolution );
	}
	else
	{
		pvecAdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
		mth_FixXYMul( &pvecAdvanceHeight->x, &pvecAdvanceHeight->y, trans );

		pvecTopSideBearing->y = FixRatio( sNonScaledTSB, (int16)usEmResolution );
		mth_FixXYMul( &pvecTopSideBearing->x, &pvecTopSideBearing->y, trans );
	}
}


FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine)
{
	scl_CalcDevAdvanceWidth(pElement, devAdvanceWidth);

	devLeftSideBearing->x = f26XMin - pElement->x[LSBPOINTNUM(pElement)];
	devLeftSideBearing->y = f26YMax - pElement->y[LSBPOINTNUM(pElement)];

	LeftSideBearing->x = pElement->x[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->x -= pElement->x[ORIGINPOINTNUM(pElement)];
	LeftSideBearing->y = f26YMax - pElement->y[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->y -= pElement->y[ORIGINPOINTNUM(pElement)];

	*devLeftSideBearingLine = *devLeftSideBearing;
	*LeftSideBearingLine = *LeftSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth)

{
	devAdvanceWidth->x = pElement->x[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->x -= pElement->x[LSBPOINTNUM(pElement)];
	devAdvanceWidth->y = pElement->y[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->y -= pElement->y[LSBPOINTNUM(pElement)];
}

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine)
{
	scl_CalcDevAdvanceHeight(pElement, devAdvanceHeight);

	devTopSideBearing->x = f26XMin - pElement->x[TOPSBPOINTNUM(pElement)];
	devTopSideBearing->y = f26YMax - pElement->y[TOPSBPOINTNUM(pElement)];

	TopSideBearing->x = f26XMin - pElement->x[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->x -= pElement->x[TOPORIGINPOINTNUM(pElement)];
	TopSideBearing->y = pElement->y[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->y -= pElement->y[TOPORIGINPOINTNUM(pElement)];

	*devTopSideBearingLine = *devTopSideBearing;
	*TopSideBearingLine = *TopSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight)

{
	devAdvanceHeight->x = pElement->x[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->x -= pElement->x[BOTTOMSBPOINTNUM(pElement)];
	devAdvanceHeight->y = pElement->y[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->y -= pElement->y[BOTTOMSBPOINTNUM(pElement)];
}


FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEM = globalGS->pixelsPerEm;
}

/*  Return ppem in X and Y directions for sbits */

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEMX = (uint16)ROUNDFIXTOINT(globalGS->interpScalarX);
	*pusPPEMY = (uint16)ROUNDFIXTOINT(globalGS->interpScalarY);
}


FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement)
{
  F26Dot6 * x;
  int16     count;

  x = pElement->x;
  count = (int16)NUMBEROFCHARPOINTS(pElement) - 1;
  for (; count >= 0; --count)
  {
	(*x)++;
	++x;
  }
}

/*
 *  scl_PostTransformGlyph              <3>
 */
FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bHintAtEmSquare)
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
			globalGS->interpScalarX,
			globalGS->interpScalarY); 
	}
	else
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
	/*        globalGS->interpScalarX,
			globalGS->interpScalarY); */
			globalGS->fxMetricScalarX,
			globalGS->fxMetricScalarY);
	}
}

/*
 *  scl_ApplyTranslation              
 */
FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
   )
{
	int32 ulPointIndex;
	F26Dot6 xShift, yShift;

	/* transform from 16.16 to 26.6 */
	xShift = (trans->transform[0][2] + 0x200) >> 10;
	yShift = (trans->transform[1][2] + 0x200) >> 10;

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		xShift = xShift * RGB_OVERSCALE;
    }
#endif

	/* lsb point should be moved to (0,0) so that we can get correct bitmap bounding box when overscaling */
	xShift -= pElement->x[LSBPOINTNUM(pElement)];
	yShift -= pElement->y[LSBPOINTNUM(pElement)];

	
	if (bUseHints && !bHintAtEmSquare) {
#ifdef FSCFG_SUBPIXEL
		if (bSubPixel) {
			/* We want to round to a virtual pixel boundary when hinted */ 
			xShift += VIRTUAL_PIXELSIZE_RTG/2; 
			xShift &= ~(VIRTUAL_PIXELSIZE_RTG - 1); 
		} else {
#endif
			/* We want to round to a pixel boundary when hinted */ 
			xShift += FNT_PIXELSIZE/2; 
			xShift &= ~(FNT_PIXELSIZE - 1); 
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}

	if (xShift != 0 || yShift != 0)
	{
		for(ulPointIndex = 0;
				ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
				ulPointIndex++)
		{
			pElement->x[ulPointIndex] += xShift;
			pElement->y[ulPointIndex] += yShift;
		}
	}

}
/*
 *      scl_LocalPostTransformGlyph                             <3>
 *
 * (1) Inverts the stretch from the CTM
 * (2) Applies the local transformation passed in in the trans parameter
 * (3) Applies the global stretch from the root CTM
 * (4) Restores oox, ooy, oy, ox, and f.
 */
FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans)
{
	int32 lCount;

	lCount = (int32)NUMBEROFTOTALPOINTS(pElement);

	mth_IntelMul (lCount, pElement->x, pElement->y, trans, ONEFIX, ONEFIX);
}

#ifdef FSCFG_SUBPIXEL

FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement)   /* Element  */
{
	int32 ulPointIndex;
	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->ox[ulPointIndex] = ROUND_RGB_OVERSCALE(pElement->x[ulPointIndex]);
	}
}

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale)  
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] = FixMul(pElement->x[ulPointIndex], fxCompatibleWidthScale);
	}
}


FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] += horTranslation;
	}
    pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + newDevAdvanceWidthX;
}


FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
	int32 ulPointIndex;
	F26Dot6 fxMaxX;             /* for bounding box left, right */

	*pDevLeftSideBearingX = LONG_MAX;     /* default bounds limits */
	fxMaxX = LONG_MIN;

	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]; 
	*pDevAdvanceWidthX -= pElement->x[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		if (pElement->x[ulPointIndex] > fxMaxX)
			fxMaxX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex] < *pDevLeftSideBearingX)
			*pDevLeftSideBearingX = pElement->x[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - fxMaxX;

}

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
	int32 ulPointIndex;

	*pDevLeftSideBearingX = LONG_MAX; *pDevRightSideBearingX = LONG_MIN;
	*pNatLeftSideBearingX = LONG_MAX; *pNatRightSideBearingX = LONG_MIN;
	
	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]  - pElement->x[LSBPOINTNUM(pElement)];
	*pNatAdvanceWidthX = pElement->ox[RSBPOINTNUM(pElement)] - pElement->ox[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0; ulPointIndex < NUMBEROFCHARPOINTS(pElement); ulPointIndex++) {
		if (pElement->x[ulPointIndex]  > *pDevRightSideBearingX) *pDevRightSideBearingX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex]  < *pDevLeftSideBearingX)  *pDevLeftSideBearingX  = pElement->x[ulPointIndex];
		if (pElement->ox[ulPointIndex] > *pNatRightSideBearingX) *pNatRightSideBearingX = pElement->ox[ulPointIndex];
		if (pElement->ox[ulPointIndex] < *pNatLeftSideBearingX)  *pNatLeftSideBearingX  = pElement->ox[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevRightSideBearingX;
    *pNatRightSideBearingX = *pNatAdvanceWidthX - *pNatRightSideBearingX;
} // scl_CalcDevNatHorMetrics

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scgray.h ===
/*********************************************************************

	  scgray.h -- Gray Scale Parameter Block Definition

	  (c) Copyright 1993  Microsoft Corp.  All rights reserved.

	   8/23/93 deanb    First cut 

**********************************************************************/

#ifndef FSCGRAY_DEFINED
#define FSCGRAY_DEFINED


#include "fscdefs.h"                /* for type definitions */

/*********************************************************************/

/*      Gray scale calculation parameters                            */

/*********************************************************************/

typedef struct
{
	char* pchOver;                  /* pointer to overscaled bitmap */
	char* pchGray;                  /* pointer to gray scale bitmap */
	int16 sGrayCol;                 /* number of gray columns to calc */
	uint16 usOverScale;             /* outline magnification factor */
	uint16 usFirstShift;            /* first byte's shift */
	char* pchOverLo;                /* low limit of overscaled bitmap */
	char* pchOverHi;                /* high limit of overscaled bitmap */
	char* pchGrayLo;                /* low limit of gray scale bitmap */
	char* pchGrayHi;                /* high limit of gray scale bitmap */
}
GrayScaleParam;


/*********************************************************************/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scanlist.h ===
/*********************************************************************

	  scanlist.h -- ScanList Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/10/93  deanb   fsc_InitializeScanlist added
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   uiRowBytes moved from setup to fillbitmap
	  10/09/92  deanb   PSTP added
	  10/08/92  deanb   reworked for split workspace
	   9/25/92  deanb   separate entry for nodrop/dropout 
	   9/10/92  deanb   horiz & vert callbacks 
	   9/09/92  deanb   size_t changes 
	   9/08/92  deanb   SetElemGlobals added 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   6/01/92  deanb   New/Old FillBitMap for debug comparisons 
	   4/21/92  deanb   Single HorizScan with flag 
	   4/13/92  deanb   unsigned int to int for HorizScanOn/Off 
	   3/31/92  deanb   InitScanArray Rectangle param 
	   3/23/92  deanb   GetWorkSize added 
	   3/16/92  deanb   New types 
	   1/31/92  deanb   HorizScan[On/Off] export functions 
	   1/14/92  deanb   First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */
#include "scgray.h"                 /* for gray param definition */


typedef struct RevRoots *PRevRoot;  /* opaque type */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeScanlist (
		void
);

FS_PUBLIC PRevRoot fsc_SetupRevRoots (
		char*,                      /* reversal list buffer space */
		int32                       /* size of buffer space */
);

FS_PUBLIC int32 fsc_AddYReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC int32 fsc_AddXReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC int32 fsc_GetReversalCount (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxEstimate  (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetVIxEstimate (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxBandEst  (
		PRevRoot,                   /* pointer to reversal roots */
		Rect*,                      /* bitmap bounding box */
		int32                                /* band width in scan lines */
);

FS_PUBLIC int32 fsc_GetRevMemSize(
		PRevRoot                    /* pointer to reversal roots */
);


/*********************************************************************/

FS_PUBLIC int32 fsc_GetScanHMem( 
		uint16,                     /* scan type */
		int32,                      /* number of horiz scanlines */
		int32                       /* number of horiz intersections */
);

FS_PUBLIC int32 fsc_GetScanVMem( 
		uint16,                     /* scan type */
		int32,                      /* number of vert scanlines */
		int32,                      /* number of vert intersections */
		int32                       /* number of contour element points */
);

/*********************************************************************/

FS_PUBLIC void fsc_SetupCallBacks( 
		PSTATE                      /* pointer to state variables */
		int16,                      /* element code (line, spline, endpoint) */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*)    /* vert callback */
);

FS_PUBLIC int32 fsc_SetupScan( 
		PSTATE                      /* pointer to state variables */
		Rect*,                      /* bitmap bounding box */
		uint16,                     /* scan type */
		int32,                      /* band scan upper limit */
		int32,                      /* band scan lower limit */
		boolean,                    /* save over scan bitmap row */
		int32,                      /* bytes per bitmap row */
		int32,                      /* estimate of horiz intersections */
		int32,                      /* estimate of vert intersections */
		int32,                      /* estimate of element points */
		PRevRoot                    /* reversal list Roots */ 
);


FS_PUBLIC int32 fsc_BeginContourScan(
		PSTATE                      /* pointer to state variables */
		uint16,                     /* scan type */
		F26Dot6,                    /* starting point x coordinate */
		F26Dot6                     /* starting point y coordinate */
);


FS_PUBLIC int32 fsc_BeginElement( 
		PSTATE                      /* pointer to state variables */
		uint16,                     /* type of dropout control */
		int32,                      /* determines scan on/off */   
		int32,                      /* element (line, spline, ep) */
		int32,                      /* number of points to store */
		F26Dot6*,                   /* next x control point(s) */
		F26Dot6*,                   /* next y control point(s) */
		int32 (**)(PSTATE int32, int32),    /* horiz add scan return */
		int32 (**)(PSTATE int32, int32)     /* vert add scan return */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap( 
		PSTATE                      /* pointer to state variables */
		char*,                      /* target memory */
		int32,                      /* bitmap upper limit */
		int32,                      /* bitmap lower limit */
		int32,                      /* bitmap bytes per row */
		int32,                      /* original low band row */
		uint16                      /* scan type */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap ( 
		uint32,                     /* longs per bmp */
		uint32*                     /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam*             /* pointer to param block */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scendpt.c ===
/*********************************************************************

	  scendpt.c -- New Scan Converter EndPoint Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  10/28/92  deanb   reentrant params renamed
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/14/92  deanb   check vert topology written 
	   9/10/92  deanb   first dropout code 
	   8/18/92  deanb   include struc.h, scconst.h 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   5/08/92  deanb   reordered includes for precompiled headers 
	   4/21/92  deanb   Single HorizScanAdd 
	   4/09/92  deanb   New types 
	   4/06/92  deanb   Check Topology corrected 
	   4/02/92  deanb   Coded 
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scendpt.h"             /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE int32 CheckHorizTopology( PSTATE F26Dot6, F26Dot6, uint16 );
FS_PRIVATE int32 CheckVertTopology( PSTATE F26Dot6, F26Dot6, uint16 );

FS_PRIVATE int32 AddHorizOn( PSTATE uint16 );
FS_PRIVATE int32 AddHorizOff( PSTATE uint16 );
FS_PRIVATE int32 AddVertOn( PSTATE uint16 );
FS_PRIVATE int32 AddVertOff( PSTATE uint16 );

FS_PRIVATE F26Dot6 CalcHorizEpSubpix( int32, F26Dot6*, F26Dot6* );
FS_PRIVATE F26Dot6 CalcVertEpSubpix( int32, F26Dot6*, F26Dot6* );


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupEndPt (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_ENDPTCODE, CalcHorizEpSubpix, CalcVertEpSubpix);
}

/*********************************************************************/

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX,         /* starting point x coordinate */
		F26Dot6 fxY )        /* starting point y coordinate */
{
	STATE.fxX1 = fxX;                   /* last = contour start point */
	STATE.fxY1 = fxY;
	STATE.fxX0 = HUGEFIX;               /* contour begin alert */
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX2,        /* x coordinate */
		F26Dot6 fxY2,        /* y coordinate */
		uint16 usScanKind )  /* dropout control type */
{
	int32 lErrCode;

	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
		{
			return NO_ERR;                  /*   and just ignore them   */
		}
				
		if (STATE.fxX0 == HUGEFIX)          /* if contour begin */
		{
			STATE.fxX2Save = fxX2;          /*   keep for contour end   */
			STATE.fxY2Save = fxY2;          
		}
		else                                /* if mid contour */
		{
			lErrCode = CheckHorizTopology(ASTATE fxX2, fxY2, usScanKind);
			if (lErrCode != NO_ERR) return lErrCode;
		}               
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
			{
				return NO_ERR;              /*   and just ignore them   */
			}
				
			if (STATE.fxX0 == HUGEFIX)      /* if contour begin */
			{
				STATE.fxX2Save = fxX2;      /*   keep for contour end   */
				STATE.fxY2Save = fxY2;
			}
			else                            /* if mid contour */
			{
				lErrCode = CheckVertTopology(ASTATE fxX2, fxY2, usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}               
		}
	}

	STATE.fxX0 = STATE.fxX1;                /* old = last */
	STATE.fxY0 = STATE.fxY1;
	STATE.fxX1 = fxX2;                      /* last = current */
	STATE.fxY1 = fxY2;
	
	return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE                          /* pointer to state variables */
		uint16 usScanKind )             /* dropout control type */
{
	int32 lErrCode;

	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		lErrCode = CheckHorizTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
		if (lErrCode != NO_ERR) return lErrCode;
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			lErrCode = CheckVertTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
			if (lErrCode != NO_ERR) return lErrCode;
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Private Functions      */

/*********************************************************************/

/*      Implement the endpoint-on-horiz-scanline case table    */

FS_PRIVATE int32 CheckHorizTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{
	int32 lErrCode;

/* printf("(%li, %li)", fxX2, fxY2); */

	lErrCode = NO_ERR;

	if (fxY2 > STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			lErrCode = AddHorizOn(ASTATE usScanKind);			
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			lErrCode = AddHorizOn(ASTATE usScanKind);
			if (lErrCode == NO_ERR)
			{
				lErrCode = AddHorizOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 < STATE.fxX0)
			{
				lErrCode = AddHorizOn(ASTATE usScanKind);				
			}
		}
	}
	else if (fxY2 < STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			lErrCode = AddHorizOn(ASTATE usScanKind);
			if (lErrCode == NO_ERR) 
			{
				lErrCode = AddHorizOff(ASTATE usScanKind);	
			}
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			lErrCode = AddHorizOff(ASTATE usScanKind);		
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 > STATE.fxX0)
			{
				lErrCode = AddHorizOff(ASTATE usScanKind);				
			}
		}
	}
	else                        /* (fxY2 == STATE.fxY1) */
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			if (fxX2 > STATE.fxX1)
			{
				lErrCode = AddHorizOn(ASTATE usScanKind);				
			}
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			if (fxX2 < STATE.fxX1)
			{
				lErrCode = AddHorizOff(ASTATE usScanKind);				
			}
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if ((STATE.fxX1 > STATE.fxX0) && (fxX2 < STATE.fxX1))
			{
				lErrCode = AddHorizOff(ASTATE usScanKind);				
			}
			else if ((STATE.fxX1 < STATE.fxX0) && (fxX2 > STATE.fxX1))
			{
				lErrCode = AddHorizOn(ASTATE usScanKind);				
			}
		}
	}	

	return lErrCode;
}


/*********************************************************************/

/*      Implement the endpoint-on-vert-scanline case table      */

FS_PRIVATE int32 CheckVertTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{
	int32 lErrCode;

	lErrCode = NO_ERR;

	if (fxX2 < STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			lErrCode = AddVertOn(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			lErrCode = AddVertOn(ASTATE usScanKind);
			if (lErrCode == NO_ERR)
			{
				lErrCode = AddVertOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 < STATE.fxY0)
			{
				lErrCode = AddVertOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxX2 > STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			lErrCode = AddVertOn(ASTATE usScanKind);
			if (lErrCode == NO_ERR)
			{
				lErrCode = AddVertOff(ASTATE usScanKind);
			}
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			lErrCode = AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 > STATE.fxY0)
			{
				lErrCode = AddVertOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxX2 == STATE.fxX1) */
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			if (fxY2 > STATE.fxY1)
			{
				lErrCode = AddVertOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			if (fxY2 < STATE.fxY1)
			{
				lErrCode = AddVertOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if ((STATE.fxY1 > STATE.fxY0) && (fxY2 < STATE.fxY1))
			{
				lErrCode = AddVertOff(ASTATE usScanKind);
			}
			else if ((STATE.fxY1 < STATE.fxY0) && (fxY2 > STATE.fxY1))
			{
				lErrCode = AddVertOn(ASTATE usScanKind);
			}
		}
	}	

	return lErrCode;
}


/*********************************************************************/
	
FS_PRIVATE int32 AddHorizOn( PSTATE uint16 usScanKind )
{
	int32 lErrCode;
	int32 lXScan, lYScan;
	int32 (*pfnAddHorizScan)(PSTATE int32, int32);
	int32 (*pfnAddVertScan)(PSTATE int32, int32);
	
	lErrCode = fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	if (lErrCode != NO_ERR) return lErrCode;
	
	lXScan = (int32)((STATE.fxX1 + SUBHALF - 1) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);	

	return pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE int32 AddHorizOff( PSTATE uint16 usScanKind )
{
	int32 lErrCode;
	int32 lXScan, lYScan;
	int32 (*pfnAddHorizScan)(PSTATE int32, int32);
	int32 (*pfnAddVertScan)(PSTATE int32, int32);
	
	lErrCode = fsc_BeginElement( ASTATE usScanKind, 4, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	if (lErrCode != NO_ERR) return lErrCode;

	lXScan = (int32)((STATE.fxX1 + SUBHALF) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);	

	return pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE int32 AddVertOn( PSTATE uint16 usScanKind )
{
	int32 lErrCode;
	int32 lXScan, lYScan;
	int32 (*pfnAddHorizScan)(PSTATE int32, int32);
	int32 (*pfnAddVertScan)(PSTATE int32, int32);
	
	lErrCode = fsc_BeginElement( ASTATE usScanKind, 2, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	if (lErrCode != NO_ERR) return lErrCode;

	lYScan = (int32)((STATE.fxY1 + SUBHALF - 1) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);	
	
	return pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE int32 AddVertOff( PSTATE uint16 usScanKind )
{
	int32 lErrCode;
	int32 lXScan, lYScan;
	int32 (*pfnAddHorizScan)(PSTATE int32, int32);
	int32 (*pfnAddVertScan)(PSTATE int32, int32);
	
	lErrCode = fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	if (lErrCode != NO_ERR) return lErrCode;

	lYScan = (int32)((STATE.fxY1 + SUBHALF) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);	

	return pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizEpSubpix(int32 lYScan, 
									 F26Dot6 *pfxX, 
									 F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lYScan);
	FS_UNUSED_PARAMETER(pfxY);

/* printf("HorizEndpt(%li %li)\n", *pfxX, *pfxY); */

	return *pfxX;                           /* exact intersection */
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertEpSubpix(int32 lXScan, 
									F26Dot6 *pfxX, 
									F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lXScan);
	FS_UNUSED_PARAMETER(pfxX);

/* printf("VertEndpt (%li %li)\n", *pfxX, *pfxY); */

	return *pfxY;                           /* exact intersection */
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scline.h ===
/*********************************************************************

	  scline.h -- Line Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetLineElemSize returns size_t 
	   8/21/92 deanb    GetLineElemSize added 
	   7/23/92 deanb    Back to x2,y2 again 
	   7/17/92 deanb    Changed from longline to line 
	   4/21/92 deanb    Scan lines and on/off added 
	   4/09/92 deanb    New types 
	   4/01/92 deanb    Back to x2,y2 
	   3/20/92 deanb    Reintroduced 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupLine ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* point 1  x coordinate */
		F26Dot6,            /* point 1  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\interp.c ===
/*********************************************************************

	  interp.c -- TT Rasterizer Interpreter Module

	  Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				  (c) 1989-1999. Microsoft Corporation, all rights reserved.

	   7/10/99  BeatS	 62 Add support for native SP fonts, vertical RGB
	   4/01/99  BeatS	 61 Implement alternative interpretation of TT instructions for SP
	  10/14/97  claudebe 60 ClaudeBe, allowing a trace function to know if in FontProgram
							access to unitialized data
	  04/29/97  claudebe 59 ClaudeBe, catching illegal recursion and infinite loops
	  02/21/97  claudebe 58 ClaudeBe, scaled component in composite glyphs
	   2/05/96  claudebe 57 compfont for itpr_MD, wrong zone pointer
	   2/05/96  claudebe 56 GetInfo return HintForGray information
	   8/12/94  deanb  55   orphan routine CHECK_STATE deleted
	   2/09/94  deanb  54   RASTERIZER_VERSION defined for GETINFO
	  12/17/93  deanb  53   CHECK_POINT zone corrected in MIRP
	  12/08/93  deanb  52   itrp_SCANTYPE enabled for smart dropout control
	   9/15/93  deanb  51   InnerTraceEx double call fixed; iOpCode -> lOpCode
	   7/29/93  deanb  50   ALIGNPTS, SHE fixed; InnerTraceExecute saves first
	   7/12/93  deanb  49   itrp_IllegalInstruction works
	   6/28/93  deanb  48   gbyPushTable made const
	   2/16/93  deanb  47   fxUnRounded set after check single width
	   2/15/93  deanb  46   fall back to MIRPG when using single width
	   2/15/93  deanb  45   vector defaults for FONTPROGRAM, stat back
	   2/12/93  deanb  44   delete stat code
	   2/12/93  deanb  43   cleanup MSIRP & itrp_Execute
	   2/12/93  deanb  42   branch itrp_IP on MovePoint
	   2/11/93  deanb  41   use c8 register calling convetions
	   2/11/93  deanb  40   switch to Microsoft C ver 8
	   2/09/93  deanb  39   skipPushData inline in itrp_IF
	   2/09/93  deanb  38   do fast MIRP's with if statments
	   2/09/93  deanb  37   remove fast MDRPX and MIRPY routines
	   2/09/93  deanb  36   fast MDRPX and MIRPY routines
	   2/08/93  deanb  35   cleanup MIRPs, combine if statments
	   2/08/93  deanb  34   dual rounding with 6 ptr init values
	   2/08/93  deanb  33   IUP inner loop pointer check
	   2/08/93  deanb  32   repair skipPushData for npushw
	   2/05/93  deanb  31   check for fxHintedDelta = 0
	   2/05/93  deanb  30   use roundFuncPtr in fast MIRP's
	   2/05/93  deanb  29   itrp_SWAP done in place
	   2/05/93  deanb  28   fntMirpFunc defined for MIRPG/X/Y
	   2/05/93  deanb  27   iOpCode passed in to all functions
	   2/05/93  deanb  26   use instr ptr for param and return
	   2/04/93  deanb  25   pull oldRange out of itrp_IP loops
	   2/04/93  deanb  24   movePoint check for proj.x/y = 1
	   2/03/93  deanb  23   table driven skipPushData
	   2/03/93  deanb  22   zero based Unary Operand pointers
	   2/01/93  deanb  21   split out SetRoundState
	   2/01/93  deanb  20   eliminate OpCode assignemnt, registers
	   2/01/93  deanb  19   bump Normalize limit up to 0x20000000L
	   1/29/93  deanb  18   add SuperRound MIRPG fallback
	   1/29/93  deanb  17   fast MIRPX and MIRPY routines
	   1/27/93  deanb  16   single rounding routines restored
	   1/27/93  deanb  15   innerExecute tune up
	   1/27/93  deanb  14   rounding routines for engine/no engine
	   1/27/93  deanb  13   repair itrp_Normalize for BIG vectors
	   1/26/93  deanb  12   split out SPVTCA and SFVTCA
	   1/26/93  deanb  11   clean up itrp_IP
	   1/26/93  deanb  10   return IUP to old start/end calc
	   1/25/93  deanb   9   use pointers in IUP loops
	   1/25/93  deanb   8   major rewrite of itrp_IUP
	   1/25/93  deanb   7   rewrite itrp_Normalize
	   1/22/93  deanb   6   split and do Unary Operands in place
	   1/22/93  deanb   5   do Binary Operands in place
	   1/22/93  deanb   4   split out BinaryOperand
	   1/22/93  deanb   3   split out PUSHB1 and PUSHW1
	   1/22/93  deanb   2   split out PushSomeBytes/Words
	   1/22/93  deanb   1   split out SRP0-2, LLOOP, POP
	   1/22/93  deanb   0   STAT card timing added
	   1/22/93  deanb       dead code/comments moved to history.fnt
 
**********************************************************************/

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "interp.h"
#include "fserror.h"

#include "stat.h"                   /* for STAT card timing only */

#include <stdio.h>

#ifdef SEGMENT_LINK
#pragma segment FNT_C
#endif

/* perfect spot size (Fixed) */
#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

#ifdef FSCFG_SUBPIXEL
#define RASTERIZER_VERSION  37      /* MS reserved values 33 - 64 */
#else
#define RASTERIZER_VERSION  35      /* MS reserved values 33 - 64 */
#endif // FSCFG_SUBPIXEL
									/* 33 = Rasterizer v1.5 */
									/* 34 = Rasterizer v1.6 */
									/* 35 = Rasterizer v1.7 */
									/* 36 = Rasterizer v1.6+, Windows CE, SubPixel */
									/* 37 = Rasterizer v1.8, Windows XP (NT 5.1), SubPixel */

#ifdef FSCFG_SUBPIXEL
	// the following are 9 switches to avoid all kinds of "hinting techniques" that have adverse effects on SubPixel
	// they should be considered "band-aid" solutions, to avoid us the worst of the worst with existing fonts.
	// in the future, fonts that are optimized for SubPixel should be tagged as such.
	// This will permit to switch these switches off again.
	#define RDTGRoundsDownToGrid		// to avoid not aligning control points when Align translates to MDRP with RDTG preceded by SPVTL
	#define NoVirtRoundInPrep			// to avoid PMingLiU vertically misplacing strokes (vectors not set properly in prep for certain calculations)
	#define RoundOffRespectsCvtCutIn	// to avoid Palatino Italic's fractional grey-scale targetted cvts and unrounded MIRP (little r) which bypasses cvt cut-in
	#define MSIRPRespectsCvtCutIn		// to avoid fonts pre-calculating a distance and subsequently MSIRPing it (neither rounding nor cvt cut-in involved in MSIRP)
	#define InlineDeltasOnly			// to avoid all kinds of bumps, blops, or irregular weight gains
	#define BypassDandIStroke			// to avoid collapsing strokes in (partly) auto-hinted fonts using DStroke and IStroke commands
	#define BypassJellesSpacing			// to avoid bloated characters
	#define BypassVacuformRound			// to avoid diamond shaped characters
	#define AssistTomsDiagonal			// to avoid Georgia italic to become upright

	// values derived from the primary values in fscdefs.h
	#define CVT_CUT_IN_OVERSCALE	VIRTUAL_OVERSCALE	// high value to encourage MIRP to fall back on original distance to avoid stroke weight jumps in size ramp
	#define ENGINE_COMP_OVERSCALE	VISUAL_OVERSCALE	// value not particularly relevant as engine compensation is not currently used
	#define MIN_DIST_OVERSCALE		VISUAL_OVERSCALE	// value not terribly important as it basically affects the minimum stroke weight

	#define Tuned4SubPixel(globalGS) ((uint16)((globalGS)->localParBlock.instructControl & TUNED4SPFLAG))
#else
	#define Tuned4SubPixel(globalGS) (false)
#endif

#define MAX_ELEMENTS 2
#define TWILIGHTZONE 0 /* The point storage */
#define GLYPHELEMENT 1 /* The actual glyph */

/* those constant are used as default to catch illegal fonts */
#define INTERP_MAX_JUMPS			10000
#define INTERP_MAX_RECURSIVE_CALLS	100
#define INTERP_MAX_INSTRUCTIONS_PER_PGM		10000000 /* On a 1Ghz system ~3.6 million TT instructions per second executed. Allow ~2.5 seconds per program. */

#define MAXANGLES       20

#define ROTATEDGLYPH        0x0100
#define STRETCHEDGLYPH      0x0200
/* new Apple 1994 */
#define VARIATIONGLYPH      0x0400
#define VERTICALGLYPH       0x0800
/* new Microsoft 1996 */
#define HINTEDFORGRAYGLYPH  0x1000

#define VERSIONINTERPRETERQUERY          0x0001
#define ROTATEDINTERPRETERQUERY          0x0002
#define STRETCHEDINTERPRETERQUERY        0x0004
/* new Apple 1994 */
#define VARIATIONINTERPRETERQUERY        0x0008
#define VERTICALMETRICSINTERPRETERQUERY  0x0010
/* new Microsoft 1996 */
#define HINTFORGRAYINTERPRETERQUERY      0x0020

/* new Microsoft 1998
   moved out of FSCFG_SUBPIXEL to build debug version for non SP environment */
#define HINTFORSUBPIXELINTERPRETERQUERY						0x0040
#define HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY		0x0080
#define HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY	0x0100
#define HINTFORSUBPIXELBGRORDERINTERPRETERQUERY				0x0200

#ifdef FSCFG_SUBPIXEL
/* new Microsoft 1998 */
#define HINTEDFORSUBPIXELGLYPH								0x02000
#define HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH				0x04000
#define HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH				0x08000
#define HINTEDFORSUBPIXELBGRORDERGLYPH						0x10000
#endif // FSCFG_SUBPIXEL

// this includes all SP specific flags, since we don't want a SP enabled font to break on a non SP enabled rasterizer
#define SELECTOR_FLAGS (VERSIONINTERPRETERQUERY | ROTATEDINTERPRETERQUERY | STRETCHEDINTERPRETERQUERY |					\
						VARIATIONINTERPRETERQUERY | VERTICALMETRICSINTERPRETERQUERY | HINTFORGRAYINTERPRETERQUERY |		\
						HINTFORSUBPIXELINTERPRETERQUERY | HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY |			\
						HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY | HINTFORSUBPIXELBGRORDERINTERPRETERQUERY)

#define MAXBYTE_INSTRUCTIONS 256

#define ONEVECTOR                       ONESHORTFRAC
#define VECTORMUL(value, component)     ShortFracMul((F26Dot6)(value), (ShortFract)(component))
#define VECTORDOT(a,b)                  ShortFracDot((ShortFract)(a),(ShortFract)(b))
#define VECTORDIV(num,denum)            ShortFracDiv((ShortFract)(num),(ShortFract)(denum))
#define VECTORMULDIV(a,b,c)             ShortFracMulDiv((ShortFract)(a),(ShortFract)(b),(ShortFract)(c))
#define VECTOR2FIX(a)                   ((Fixed) (a) << 2)
#define ONESIXTEENTHVECTOR              ((ONEVECTOR) >> 4)

#ifdef FSCFG_REENTRANT
#define GSP0    fnt_LocalGraphicStateType* pLocalGS
#define GSP     fnt_LocalGraphicStateType* pLocalGS,
#define GSA0    pLocalGS
#define GSA     pLocalGS,
#define LocalGS (*pLocalGS)
#else 
#define GSP0    void
#define GSP
#define GSA0
#define GSA
fnt_LocalGraphicStateType LocalGS
 #ifndef FSCFG_NO_INITIALIZED_DATA
  = {0}
 #endif 
;
#endif 


#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )


/* Common Interpreter Function Parameter */

#define IPARAM         GSP uint8 *pbyInst, int32 lOpCode

#define MIRPG          0
#define MIRPX          1
#define MIRPY          2
				  
// color compensation flags in ROUND, MDRP, and MIRP
#define	GREY	0
#define BLACK	1
#define WHITE	2
#define OTHER	3

// flags for UTP, IUP, MovePoint
#define XMOVED 0x01
#define YMOVED 0x02


#define NUM_PHANTOM_PTS   4L

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA // master switch

	#define NumRelationShips(elem) (elem->ep[elem->nc - 1] + 1 + NUM_PHANTOM_PTS)

	// Make an empty data structure (DAG)
	void InitPhaseControl(fnt_ElementType *elem) {
		long i;
		PhaseControlRelation *rel;

		for (i = 0; i < NumRelationShips(elem); i++) {
			rel = &elem->pcr[i];
			rel->parent0 = rel->parent1 = rel->child = -1;
			rel->flags = 0;
			rel->phaseShift = 0;
		}
		elem->phaseControlExecuted = false;
	} // InitPhaseControl

	//	Function to avert circular dependencies, whose traversal would cause endless recursion in
	//	"PhaseShift" further below.
	//
	//	In the trivial case (self dependency), a child would depend on itself. This scenario is ex-
	//	cluded by respective tests in the callers.
	//
	//	In the simplest non-trivial case (direct dependency), before linking from a parent to a child,
	//	we want to determine whether the child links back to the parent:
	//
	//		IndirectlyDependsOn(..., parent, child, ...) ?
	//
	//	If it does, then "self" (the parent) depends on "whom" (the child), and we'd get a circular
	//	dependency, because the child would depend on the parent as a result of "AddDistance":
	//
	//		rel->parent0 == whom ?
	//
	//	noting that "rel" points to self's phase control relation structure.
	//
	//	In the more general case (indirect dependency, which includes direct dependency via zero
	//	indirections), self's parent may depend on the child (and recursively), hence:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) ?
	//
	//	In the most general case, there may be two parents involved, hence we have to follow both
	//	lines of ancestry:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) || 
	//		rel->parent1 == whom || IndirectlyDependsOn(..., rel->parent1, whom, ...) ?
	//
	//	Notice that in the actual code the latter is re-arranged for efficiency.
	//	Notice also that we don't have a simple case of tail recursion, which could be replaced by
	//	an iteration easily.

	boolean IndirectlyDependsOn(fnt_ElementType *elem, long self, long whom, long level) {
		PhaseControlRelation *rel;

		level--;
		if (level < 0) return true; // safeguard against stack overflow, probably redundant

	//	here we assume that we're called only from within AddDistance or AddProportion, hence
	//	"self" and "whom" have been range checked initially. Every recursion changes the actual
	//	value of "self", but only to a value obtained from a "pcr", which only gets range checked
	//	values, hence we don't need to range check "self" again. "whom" is invariant anyhow.
	//	Additionally, we also assume that "self" and "whom" are not the same. Since the algorithm
	//	below terminates if "self"'s parent equals "whom", "self" never becomes "whom".

		rel = &elem->pcr[self];
		if (rel->parent0 == -1) // 0 parents (MDAP, MIAP)
			return false; // no dependencies
		else if (rel->parent1 == -1) // 1 parent (MDRP, MIRP, SHP, ALIGNRP, etc.)
			return rel->parent0 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1);
		else // 2 parents (IP)
			return rel->parent0 == whom || rel->parent1 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1) || IndirectlyDependsOn(elem,rel->parent1,whom,level-1);
		return false; // we shouldn't get down here, but the compiler thinks we do...
	} // IndirectlyDependsOn

	// Called from the TT interpreter whenever a MIRP, MDRP, SHP, ALIGNRP (etc.) is executed
	// Add a distance relationship to the DAG
	void AddDistance(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from, long to, long color) {
		long parent;

		if (0 <= from && from < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from != to) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1) { // we have no parent for this child
				while ((parent = elem->pcr[from].parent0) != -1 && elem->oox[from] == elem->oox[parent])
					from = parent; // simplify link structure in case of links to "align" vertical edges
				elem->pcr[to].parent0 = (int16)from; // first link wins, bad links may produce suboptimal phase control
				elem->pcr[to].parent1 = -1;
			}
			if (color == BLACK && elem->pcr[from].child == -1 && elem->pcr[to].child != from) { // first black link wins...
				if ((parent = elem->pcr[from].parent0) != -1 && elem->pcr[parent].child == from)
					elem->pcr[to].flags |= BADREL;
				else
					elem->pcr[from].child = (int16)to;
			}
		}
	} // AddDistance
	
	// Called from the TT interpreter when an IP is executed
	// Add a proportion relationship to the DAG
	void AddProportion(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from0, long to, long from1) {
		if (0 <= from0 && from0 < NumRelationShips(elem) && 0 <= from1 && from1 < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from0 != to && from1 != to && from0 != from1) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from0,to,INTERP_MAX_RECURSIVE_CALLS) || IndirectlyDependsOn(elem,from1,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1 && elem->pcr[to].parent1 == -1) {
				elem->pcr[to].parent0 = (int16)from0; // first interpolate wins, bad interpolates
				elem->pcr[to].parent1 = (int16)from1; // ...may produce suboptimal phase control
			}
		}
	} // AddProportion
	
	// Calculate the phase shift resulting from a child point that depends on two parent points by proportion (interpolation)
	F26Dot6 CalcAvgXPhaseShift(fnt_ElementType *elem, long parent0, long child, long parent1, F26Dot6 phase0, F26Dot6 phase1) {
		F26Dot6 leftX,childX,rightX,leftPhase,rightPhase;
		
		// the phase of child control points that are interpolated between a pair of parent control points depends on the phase
		// applied to both of these parent control points.
		// If both parents have the same phase, then the child point gets that phase
		if (phase0 == phase1) return phase0; // IPs "within" strokes

		// if the phase is different, we try to calculcate a weighted average.
		// In dubious cases, this may fail (divide-by-zero), in which case we fall back on an unweighted (plain) average.
		if (elem->ox[parent0] < elem->ox[parent1]) {
			leftX = elem->ox[parent0]; rightX = elem->ox[parent1];
			leftPhase = phase0; rightPhase = phase1;
		} else {
			leftX = elem->ox[parent1]; rightX = elem->ox[parent0];
			leftPhase = phase1; rightPhase = phase0;
		}
		childX = elem->ox[child];
		
		return leftX != rightX 
			? ((childX - leftX)*rightPhase + (rightX - childX)*leftPhase)/(rightX - leftX) // weighted average
			: (leftPhase + rightPhase) / 2; // unweighted average
	} // CalcAvgXPhaseShift
	
	// This is the part that (recursively) traverses the data structure to apply the above rules, called from ExecutePhaseControl below
	// Notice that it works much like the early prototype for the compiler that translates VTT's GUI into TMT
	F26Dot6 PhaseShift(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, short anyBadRelation, long child) {
		PhaseControlRelation *rel,*childRel;
		F26Dot6 phase;
		
		if (child == -1) return 0; // nothing, hence no phase shift
		
		rel = &elem->pcr[child];
		
		if (rel->flags & DOING) return 0; // prevent from endless recursion due to circular dependencies; probably redundant
		rel->flags |= DOING;

		if ((rel->flags & DONE) == 0) { // else been there already, know phase
			if (child > elem->ep[elem->nc-1]) { // LSB, RSB
				phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
			} else if (rel->parent0 == -1) { // MDAP, MIAP
				if (anyBadRelation) {
					phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
				} else {
					phase = 0;
				}
			} else if (rel->parent1 == -1) { // MDRP, MIRP, SHP, ALIGNRP, ...
				phase = PhaseShift(localGS,elem,anyBadRelation,rel->parent0);
			} else { // IP
				phase = CalcAvgXPhaseShift(elem,rel->parent0,child,rel->parent1,PhaseShift(localGS,elem,anyBadRelation,rel->parent0),PhaseShift(localGS,elem,anyBadRelation,rel->parent1));
			}
			
			if ((rel->flags & DONE) == 0) { // still not done, after above recursion
				if (rel->child != -1 && ((childRel = &elem->pcr[rel->child])->flags & DONE) == 0) {
					if (rel->parent0 == -1 || rel->parent1 == -1) { // not IP
						phase = LongMulDiv(elem->x[child] + elem->x[rel->child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x20000);
					}
					
					elem->x[child] += phase;
					elem->x[rel->child] += phase;
					
					childRel->phaseShift = phase;
					childRel->flags |= DONE;
				
				// else if we're linked to, and we're not a leaf, such as in a chain of links through a 'v',
				// do the proportional thing, in order not to twist the 'v'
				// additionally, we may want to make the decision, which "stroke" wins, a bit smarter,
				// by giving preference to the one with the lesser |dy|

				} else {
					if (anyBadRelation && rel->parent1 == -1 && (rel->parent0 == -1 || elem->ox[child] != elem->ox[rel->parent0])) {
					//	bad MDRP, MIRP, SHP, ALIGNRP, MDAP, or MIAP, but not in case aligned along vertical edge
						phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
					} // else IP
					if (rel->parent0 != -1) {
						elem->x[child] += phase;
					}
				}
				rel->phaseShift = phase;
				rel->flags |= DONE;
			}
		}

		rel->flags &= ~DOING;
		return rel->phaseShift;
	} // PhaseShift

	// This is a plain old loop
	// It is never to be executed in the twilight zone, hence all the guards upon calling it.
	void ExecutePhaseControl(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem) {
		long i,numRelationShips;
		short anyBadRelation;
		F26Dot6 phase;

		numRelationShips = NumRelationShips(elem);
		for (i = 0; i < numRelationShips && (elem->pcr[i].flags & BADREL) == 0; i++);
		anyBadRelation = i < numRelationShips;
		for (i = 0; i < numRelationShips; i++) {
			phase = PhaseShift(localGS,elem,anyBadRelation,i);
		}
		elem->phaseControlExecuted = true;
	} // ExecutePhaseControl

	// helper function
	long ContNum(fnt_ElementType *elem, long knot) {
		long i;

		for (i = 0; i < elem->nc && knot > elem->ep[i]; i++);
		return i < elem->nc ? i : -1;
	} // ContNum

	// The "concertina algorithm" uses the color flags in the MDRP and MIRP instructions to "determine" the existence
	// of stems. Most of the time, the color flags are set correctly; in fact, if the TT code is generated by the TMT
	// compiler, they should always be correct. However, there is a small number of cases where the flags are erroneous
	// (a black stroke which is not flagged as black) or misleading (the extent of a cross bar, which is a black link
	// as defined in the TMT compiler, but which for the purpose of this algorithm had rather not be flagged as black).
	// Not surprisingly, most of these cases (avoiding to say, all of them) happen on grotesque fonts, with the MDRP
	// or MIRP between two neighbouring points on the outline (cases in which a compiler generating TT code could ar-
	// gueably be undecided). Therefore we make a last ditch effort in this function to correct the colour flags for
	// this special class of problems.
	long DoubleCheckLinkColor(fnt_ElementType *elem, long from, long to, long color) {
		long fromCont,fromStart,fromEnd,fromSucc,fromPred,toCont,toSucc,toPred;
		boolean fromRightTurn,toRightTurn,properlyOriented;

		// first, determine whether we link between a pair of neighbours on one and the same contour
		// one of the knots is not on any contour (LSB, RSB), hence can't be neighbours
		if ((fromCont = ContNum(elem,from)) < 0 || // error
			(toCont   = ContNum(elem,to))   < 0)
			return GREY; // it's not a black stroke
		
		// if they belong to different contours, we don't attempt to improve color flag
		if (fromCont != toCont) return color;
		
		// if they belong to the same contour, but are not neighbours, we don't attempt to improve color flag, either
		fromStart = elem->sp[fromCont];
		fromEnd   = elem->ep[fromCont];
		fromSucc = from == fromEnd ? fromStart : from+1;
		fromPred = from == fromStart ? fromEnd : from-1;
		if (to != fromSucc && to != fromPred) return color;

		// if they are neighbours, but the link is along the arm of a T-junction, we call it a grey link.
		// we determine this by testing whether the link starts at a point where the outline makes a right
		// turn and ends at a point where the outline makes a left turn, or vice versa.
		toSucc = to == fromEnd ? fromStart : to+1;
		toPred = to == fromStart ? fromEnd : to-1;
		fromRightTurn = (elem->oox[from]-elem->oox[fromPred])*(elem->ooy[fromSucc]-elem->ooy[from]) <
						(elem->ooy[from]-elem->ooy[fromPred])*(elem->oox[fromSucc]-elem->oox[from]);
		toRightTurn   = (elem->oox[to]-elem->oox[toPred])*(elem->ooy[toSucc]-elem->ooy[to]) <
						(elem->ooy[to]-elem->ooy[toPred])*(elem->oox[toSucc]-elem->oox[to]);
		if (fromRightTurn != toRightTurn)
			return GREY;

		// a extraneous case encountered, a link along a diagonal stroke
		if (2*MABS(elem->oox[to]-elem->oox[from]) < MABS(elem->ooy[to]-elem->ooy[from]))
			return GREY;

		properlyOriented = (elem->fc[fromCont] & OUTLINE_MISORIENTED) == 0;

		return properlyOriented == fromRightTurn ? BLACK : WHITE;
	} // DoubleCheckLinkColor

	// Determine whether an interpolation is actually an interpolation, as opposed to an extrapolation.
	// For actual interpolations, child points are moved along proportionally to the parent points. For
	// extrapolations child points are shifted along with the parent point(s). Notice that we implement
	// a behaviour similar to IUP (points between extrema are interpolated, the others are shifted along)
	boolean InterAlign(fnt_ElementType *elem, long parent0, long child, long parent1) {
		long parent0x,childx,parent1x,temp;

		parent0x = elem->oox[parent0];
		parent1x = elem->oox[parent1];
		if (parent0x > parent1x) { temp = parent0x; parent0x = parent1x; parent1x = temp; }
		childx = elem->oox[child];
		return parent0x <= childx && childx <= parent1x;
	} // InterAlign

#endif // SUBPIXEL_BC_AW_STEM_CONCERTINA


/* Private function prototypes */

FS_PRIVATE F26Dot6 itrp_RoundToDoubleGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundDownToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundUpToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToHalfGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundOff(GSP F26Dot6 xin, F26Dot6 engine);

#ifdef FSCFG_SUBPIXEL
	// a duplicate set of rounding functions, with either the b/w (above) or the sp (below) version being installed
	FS_PRIVATE F26Dot6 itrp_RoundToDoubleGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundDownToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundUpToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToHalfGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundOffSP(GSP F26Dot6 xin, F26Dot6 engine);
#endif

FS_PRIVATE F26Dot6 itrp_SuperRound(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_Super45Round(GSP F26Dot6 xin, F26Dot6 engine);

FS_PRIVATE void itrp_MovePoint  (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0);
FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);
FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);

FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_InnerExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_Check_PF_Proj (GSP0);
FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0);
FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound);
FS_PRIVATE F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 value);
FS_PRIVATE fnt_instrDef*itrp_FindIDef (GSP uint8 opCode);
FS_PRIVATE uint8* itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 base, int16 shift);

/* Actual instructions for the jump table */
FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SDPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SFVTL (IPARAM);
FS_PRIVATE uint8* itrp_WPV (IPARAM);
FS_PRIVATE uint8* itrp_WFV (IPARAM);
FS_PRIVATE uint8* itrp_RPV (IPARAM);
FS_PRIVATE uint8* itrp_RFV (IPARAM);
FS_PRIVATE uint8* itrp_SFVTPV (IPARAM);
FS_PRIVATE uint8* itrp_ISECT (IPARAM);
FS_PRIVATE uint8* itrp_SRP0 (IPARAM);
FS_PRIVATE uint8* itrp_SRP1 (IPARAM);
FS_PRIVATE uint8* itrp_SRP2 (IPARAM);
FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM);
FS_PRIVATE uint8* itrp_LLOOP (IPARAM);
FS_PRIVATE uint8* itrp_RTG (IPARAM);
FS_PRIVATE uint8* itrp_RTHG (IPARAM);
FS_PRIVATE uint8* itrp_RTDG (IPARAM);
FS_PRIVATE uint8* itrp_ROFF (IPARAM);
FS_PRIVATE uint8* itrp_RUTG (IPARAM);
FS_PRIVATE uint8* itrp_RDTG (IPARAM);
FS_PRIVATE uint8* itrp_SROUND (IPARAM);
FS_PRIVATE uint8* itrp_S45ROUND (IPARAM);
FS_PRIVATE uint8* itrp_LMD (IPARAM);
FS_PRIVATE uint8* itrp_RAW (IPARAM);
FS_PRIVATE uint8* itrp_LWTCI (IPARAM);
FS_PRIVATE uint8* itrp_LSWCI (IPARAM);
FS_PRIVATE uint8* itrp_LSW (IPARAM);
FS_PRIVATE uint8* itrp_DUP (IPARAM);
FS_PRIVATE uint8* itrp_POP (IPARAM);
FS_PRIVATE uint8* itrp_CLEAR (IPARAM);
FS_PRIVATE uint8* itrp_SWAP (IPARAM);
FS_PRIVATE uint8* itrp_DEPTH (IPARAM);
FS_PRIVATE uint8* itrp_CINDEX (IPARAM);
FS_PRIVATE uint8* itrp_MINDEX (IPARAM);
FS_PRIVATE uint8* itrp_ROTATE (IPARAM);
FS_PRIVATE uint8* itrp_MDAP (IPARAM);
FS_PRIVATE uint8* itrp_MIAP (IPARAM);
FS_PRIVATE uint8* itrp_IUP (IPARAM);
FS_PRIVATE uint8* itrp_SHP (IPARAM);
FS_PRIVATE uint8* itrp_SHC (IPARAM);
FS_PRIVATE uint8* itrp_SHE (IPARAM);
FS_PRIVATE uint8* itrp_SHPIX (IPARAM);
FS_PRIVATE uint8* itrp_IP (IPARAM);
FS_PRIVATE uint8* itrp_MSIRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM);
FS_PRIVATE uint8* itrp_SANGW (IPARAM);
FS_PRIVATE uint8* itrp_FLIPPT (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM);
FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM);
FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM);
FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM);
FS_PRIVATE uint8* itrp_AA (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM);
FS_PRIVATE uint8* itrp_WS (IPARAM);
FS_PRIVATE uint8* itrp_RS (IPARAM);
FS_PRIVATE uint8* itrp_WCVT (IPARAM);
FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM);
FS_PRIVATE uint8* itrp_RCVT (IPARAM);
FS_PRIVATE uint8* itrp_RC (IPARAM);
FS_PRIVATE uint8* itrp_WC (IPARAM);
FS_PRIVATE uint8* itrp_MD (IPARAM);
FS_PRIVATE uint8* itrp_MPPEM (IPARAM);
FS_PRIVATE uint8* itrp_MPS (IPARAM);
FS_PRIVATE uint8* itrp_GETINFO (IPARAM);
FS_PRIVATE uint8* itrp_FLIPON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM);
FS_PRIVATE uint8* itrp_IF (IPARAM);
FS_PRIVATE uint8* itrp_ELSE (IPARAM);
FS_PRIVATE uint8* itrp_EIF (IPARAM);
FS_PRIVATE uint8* itrp_JMPR (IPARAM);
FS_PRIVATE uint8* itrp_JROT (IPARAM);
FS_PRIVATE uint8* itrp_JROF (IPARAM);
FS_PRIVATE uint8* itrp_ROUND (IPARAM);
FS_PRIVATE uint8* itrp_NROUND (IPARAM);
FS_PRIVATE uint8* itrp_PUSHB (IPARAM);
FS_PRIVATE uint8* itrp_PUSHW (IPARAM);
FS_PRIVATE uint8* itrp_MDRP (IPARAM);
FS_PRIVATE uint8* itrp_MIRP (IPARAM);
FS_PRIVATE uint8* itrp_CALL (IPARAM);
FS_PRIVATE uint8* itrp_FDEF (IPARAM);
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM);
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM);
FS_PRIVATE uint8* itrp_IDEF (IPARAM);
FS_PRIVATE uint8* itrp_UTP (IPARAM);
FS_PRIVATE uint8* itrp_SDB (IPARAM);
FS_PRIVATE uint8* itrp_SDS (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM);

FS_PRIVATE uint8*  itrp_PUSHB1 (IPARAM);
FS_PRIVATE uint8*  itrp_PUSHW1 (IPARAM);

FS_PRIVATE uint8*  itrp_LT  (IPARAM);
FS_PRIVATE uint8*  itrp_LTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_GT  (IPARAM);
FS_PRIVATE uint8*  itrp_GTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_EQ  (IPARAM);
FS_PRIVATE uint8*  itrp_NEQ (IPARAM);
FS_PRIVATE uint8*  itrp_AND (IPARAM);
FS_PRIVATE uint8*  itrp_OR  (IPARAM);
FS_PRIVATE uint8*  itrp_ADD (IPARAM);
FS_PRIVATE uint8*  itrp_SUB (IPARAM);
FS_PRIVATE uint8*  itrp_DIV (IPARAM);
FS_PRIVATE uint8*  itrp_MUL (IPARAM);
FS_PRIVATE uint8*  itrp_MAX (IPARAM);
FS_PRIVATE uint8*  itrp_MIN (IPARAM);

FS_PRIVATE uint8*  itrp_ODD (IPARAM);
FS_PRIVATE uint8*  itrp_EVEN (IPARAM);
FS_PRIVATE uint8*  itrp_NOT (IPARAM);
FS_PRIVATE uint8*  itrp_ABS (IPARAM);
FS_PRIVATE uint8*  itrp_NEG (IPARAM);
FS_PRIVATE uint8*  itrp_CEILING (IPARAM);
FS_PRIVATE uint8*  itrp_FLOOR (IPARAM);

FS_PRIVATE uint8*  itrp_IllegalInstruction (IPARAM);

FS_PRIVATE fnt_ElementType*itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode);
FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy);
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8*);

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
FS_PRIVATE void itrp_DDT (int8 c, int32 n);
#endif
#endif
FS_PRIVATE uint8* itrp_DEBUG (IPARAM);

#define MAX(a,b)        ((a) > (b) ? (a) : (b))

FS_PRIVATE ErrorCode   itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc);

/* GLOBAL GS INITIALIZATION */

FS_PUBLIC void          itrp_UpdateGlobalGS(
	void *              pvGlobalGS, /* GlobalGS                             */
	void *              pvCVT,      /* Pointer to control value table       */
	void *              pvStore,    /* Pointer to storage                   */
	void *              pvFuncDef,  /* Pointer to function defintions       */
	void *              pvInstrDef, /* Pointer to instruction definitions   */
	void *              pvStack,    /* Pointer to the stack                 */
	LocalMaxProfile *       maxp,
	uint16              cvtCount,
	uint32              ulLengthFontProgram, /* Length of font program      */
	void *              pvFontProgram, /* Pointer to font program           */
	uint32              ulLengthPreProgram, /* Length of pre program        */
	void *              pvPreProgram,  /* Pointer to pre program            */
	ClientIDType        clientID)     /* User ID Number                     */
{
	fnt_GlobalGraphicStateType *    globalGS;
#ifdef FSCFG_SECURE
    uint16      maxStackElements = maxp->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
      maxStackElements = 1;
    }

#endif // FSCFG_EUDC_EDITOR_BUG
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->controlValueTable =   (F26Dot6 *)pvCVT;
	globalGS->store =               (F26Dot6 *)pvStore;
	globalGS->funcDef =             (fnt_funcDef *)pvFuncDef;
	globalGS->instrDef =            (fnt_instrDef *)pvInstrDef;
	globalGS->stackBase =           (F26Dot6 *)pvStack;
	globalGS->clientID =            clientID;
#ifdef FSCFG_SECURE
	globalGS->stackMax =            globalGS->stackBase + maxStackElements;
    globalGS->maxPointsIncludePhantom = MAX (maxp->maxPoints,maxp->maxCompositePoints) + NUM_PHANTOM_PTS;
#endif // FSCFG_SECURE

	if(ulLengthFontProgram)
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = (unsigned char *)pvFontProgram;
	}
	else
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = NULL;
	}
	if(ulLengthPreProgram)
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = (unsigned char *)pvPreProgram;
	}
	else
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = NULL;
	}

	globalGS->maxp = maxp;
	globalGS->cvtCount = cvtCount;
	globalGS->bCompositeGlyph = FALSE;
	globalGS->bSameTransformAsMaster = TRUE;
	globalGS->bOriginalPointIsInvalid = FALSE;

	globalGS->ulMaxJumpCounter = INTERP_MAX_JUMPS;
	globalGS->ulMaxRecursiveCall = INTERP_MAX_RECURSIVE_CALLS;
	globalGS->ulMaxInstPerProgram = INTERP_MAX_INSTRUCTIONS_PER_PGM;
}

FS_PUBLIC boolean itrp_bApplyHints(
	void *      pvGlobalGS)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	return (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG));
}

FS_PUBLIC void  itrp_QueryScanInfo(
	void *      pvGlobalGS,
	uint16 *    pusScanType,
	uint16 *    pusScanControl)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
}

FS_PUBLIC void  itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8       bCompositeFlag)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bCompositeGlyph = bCompositeFlag;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bSameTransformAsMaster = (uint8)bSameTransformAsMaster;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

FS_PUBLIC void  itrp_ResetMaxInstructionCounter(
	void *      pvGlobalGS)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->ulMaxInstPerProgram = INTERP_MAX_INSTRUCTIONS_PER_PGM;
}

/*
*  function table
*/

FntFunc function [MAXBYTE_INSTRUCTIONS]
#ifndef FSCFG_NO_INITIALIZED_DATA
=
{
  itrp_SVTCA_0, itrp_SVTCA_1, itrp_SPVTCA_0, itrp_SPVTCA_1, itrp_SFVTCA_0, itrp_SFVTCA_1, itrp_SPVTL, itrp_SPVTL,
  itrp_SFVTL, itrp_SFVTL, itrp_WPV, itrp_WFV, itrp_RPV, itrp_RFV, itrp_SFVTPV, itrp_ISECT,
  itrp_SRP0, itrp_SRP1, itrp_SRP2, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_LLOOP,
  itrp_RTG, itrp_RTHG, itrp_LMD, itrp_ELSE, itrp_JMPR, itrp_LWTCI, itrp_LSWCI, itrp_LSW,
  itrp_DUP, itrp_POP, itrp_CLEAR, itrp_SWAP, itrp_DEPTH, itrp_CINDEX, itrp_MINDEX, itrp_ALIGNPTS,
  itrp_RAW, itrp_UTP, itrp_LOOPCALL, itrp_CALL, itrp_FDEF, itrp_IllegalInstruction, itrp_MDAP, itrp_MDAP,
  itrp_IUP, itrp_IUP, itrp_SHP, itrp_SHP, itrp_SHC, itrp_SHC, itrp_SHE, itrp_SHE,
  itrp_SHPIX, itrp_IP, itrp_MSIRP, itrp_MSIRP, itrp_ALIGNRP, itrp_RTDG, itrp_MIAP, itrp_MIAP,
  itrp_NPUSHB, itrp_NPUSHW, itrp_WS, itrp_RS, itrp_WCVT, itrp_RCVT, itrp_RC, itrp_RC,
  itrp_WC, itrp_MD, itrp_MD, itrp_MPPEM, itrp_MPS, itrp_FLIPON, itrp_FLIPOFF, itrp_DEBUG,
  itrp_LT, itrp_LTEQ, itrp_GT, itrp_GTEQ, itrp_EQ, itrp_NEQ, itrp_ODD, itrp_EVEN,
  itrp_IF, itrp_EIF, itrp_AND, itrp_OR, itrp_NOT, itrp_DELTAP1, itrp_SDB, itrp_SDS,
  itrp_ADD, itrp_SUB, itrp_DIV, itrp_MUL, itrp_ABS, itrp_NEG, itrp_FLOOR, itrp_CEILING,
  itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND,
  itrp_WCVTFOD, itrp_DELTAP2, itrp_DELTAP3, itrp_DELTAC1, itrp_DELTAC2, itrp_DELTAC3, itrp_SROUND, itrp_S45ROUND,
  itrp_JROT, itrp_JROF, itrp_ROFF, itrp_IllegalInstruction, itrp_RUTG, itrp_RDTG, itrp_SANGW, itrp_AA,

  itrp_FLIPPT, itrp_FLIPRGON, itrp_FLIPRGOFF, itrp_IDefPatch, itrp_IDefPatch, itrp_SCANCTRL, itrp_SDPVTL, itrp_SDPVTL,
  itrp_GETINFO, itrp_IDEF, itrp_ROTATE, itrp_MAX, itrp_MIN, itrp_SCANTYPE, itrp_INSTCTRL, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_PUSHB1, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB,
  itrp_PUSHW1, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP
}
#endif /* FSCFG_NO_INITIALIZED_DATA */
;

/* the old itrp_Init function and tables now live in history.fnt - deanb */


#ifdef  GET_STACKSPACE
  int32 MaxStackSize = 0;

  #define PUSH(p, x) \
	{ \
	  if (p - LocalGS.globalGS->stackBase > MaxStackSize) \
		MaxStackSize = p - LocalGS.globalGS->stackBase; \
	  (*(p)++ = (x)); \
	}

#else
  #define PUSH( p, x ) ( *(p)++ = (x) )
#endif
  #define POP( p )     ( *(--p) )

#define BADCOMPILER

#ifdef BADCOMPILER
#define BOOLEANPUSH( p, x ) PUSH( p, ((x) ? 1 : 0) ) /* MPW 3.0 */
#else
#define BOOLEANPUSH( p, x ) PUSH( p, x )
#endif

#ifdef FSCFG_DEBUG
void CHECK_RANGE (int32 n, int32 min, int32 max);
void CHECK_RANGE (int32 n, int32 min, int32 max)
{
  if (n > max || n < min)
	ERR_REPORT (ERR_RANGE, n, min, max, 0);
}


void CHECK_ASSERTION (int32 expression);
void CHECK_ASSERTION (int32 expression)
{
  if (!expression)
	ERR_REPORT (ERR_ASSERTION, expression, 0, 0, 0);
}


void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt);
void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt)
{
  int32 cvtCount = (int32)(pGS->globalGS->cvtCount - 1L);

  if ((int32)cvt > cvtCount || (int32)cvt < 0L)
	ERR_REPORT (ERR_CVT, cvt, 0, cvtCount, 0);
}


void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef);
void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef)
{
  int32 maxFdef = (int32)(pGS->globalGS->maxp->maxFunctionDefs - 1L);

  if ((int32)fdef > maxFdef || (int32)fdef < 0L)
	ERR_REPORT (ERR_FDEF, fdef, 0, maxFdef, 0);
}

#define CHECK_PROGRAM(a)

void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem);
void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem)
{
  int32 maxElem = (int32)(pGS->globalGS->maxp->maxElements - 1L);

/*
  At least 1 maxElements will always be available
*/
  if (!maxElem)
	maxElem++;

  if ((int32)elem > maxElem || (int32)elem < 0L)
	ERR_REPORT (ERR_ELEMENT, elem, 0, maxElem, 0);
}

void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem);
void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem)
{
  if (elem == &pGS->elements[1])
  {
	 int32 maxctrs, maxpts;

	maxctrs = MAX (pGS->globalGS->maxp->maxContours,
				   pGS->globalGS->maxp->maxCompositeContours);
	maxpts  = MAX (pGS->globalGS->maxp->maxPoints,
				   pGS->globalGS->maxp->maxCompositePoints);

	if ((int32)elem->nc > (int32)maxctrs || (int32)elem->nc < 1L)
	  ERR_REPORT (ERR_CONTOUR, elem->nc, 1, maxctrs, 0);

	if ((int32)elem->ep[elem->nc-1] > maxpts - 1L ||
		(int32)elem->ep[elem->nc-1] < 0L)
	  ERR_REPORT (ERR_POINT, elem->ep[elem->nc-1], 0, maxpts - 1L, 0);
  }
  else if (elem != &pGS->elements[0])
	ERR_REPORT (ERR_INDEX, elem, &pGS->elements[0], &pGS->elements[1], 0);
}

void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index);
void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index)
{
  int32 maxIndex = (int32)(pGS->globalGS->maxp->maxStorage - 1L);

  if ((int32)index > maxIndex || (int32)index < 0L)
	ERR_REPORT (ERR_STORAGE, index, 0, maxIndex, 0);
}

void CHECK_STACK (fnt_LocalGraphicStateType* pGS);
void CHECK_STACK (fnt_LocalGraphicStateType* pGS)
{
  int32 base = (int32)(pGS->stackPointer - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt);
void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if (pGS->elements == elem)
  {
	if ((int32)pt > pGS->globalGS->maxp->maxTwilightPoints - 1L ||
		(int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, pGS->globalGS->maxp->maxTwilightPoints - 1L, 0);
  }
  else                                                      /* phantom points */
  {
	if ((int32)pt > elem->ep[elem->nc-1] + 2L || (int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, elem->ep[elem->nc-1] + 2L, 0);
  }
}

void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr);
void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if ((int32)ctr > elem->nc - 1L || (int32)ctr < 0L)
	ERR_REPORT (ERR_CONTOUR, ctr, 0, elem->nc -1L, 0);
}

void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y);
void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y)
{
  if ( x == 0 && y == 0 )
	ERR_REPORT (ERR_VECTOR, x, y, 0, 0);
}

void CHECK_LARGER (int32 min, int32 n);
void CHECK_LARGER (int32 min, int32 n)
{
  if ( n <= min )
	ERR_REPORT (ERR_LARGER, min, n, 0, 0);
}

void CHECK_INT8 (int32 n);
void CHECK_INT8 (int32 n)
{
  if ( n & 0xFFFFFF00 )
	ERR_REPORT (ERR_INT8, n, 0, 0, 0);
}

void CHECK_INT16 (int32 n);
void CHECK_INT16 (int32 n)
{
  if ( n & 0xFFFF0000 )
	ERR_REPORT (ERR_INT16, n, 0, 0, 0);
}

void CHECK_SELECTOR (int32 n);
void CHECK_SELECTOR (int32 n)
{
  if ( n & ~((int32)SELECTOR_FLAGS) )
	ERR_REPORT (ERR_SELECTOR, n, 0, 0, 0);
}

void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt);
void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt)
{
  int32 base = (int32)(pt - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void POP_CHECK (F26Dot6*);
void POP_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr <= base)
	ERR_REPORT (ERR_STACK, (stackPtr - base - 1L), 0, (max - base), 0);
  return;
}

void PUSH_CHECK (F26Dot6*);
void PUSH_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr > max )
	ERR_REPORT (ERR_STACK, (stackPtr - base), 0, (max - base), 0);
  return;
}

#define CHECK_POP(s)                (POP_CHECK(s),POP(s))
#define CHECK_PUSH(s, v)            (PUSH_CHECK(s),PUSH(s, v))

#else
#define CHECK_RANGE(a,b,c)
#define CHECK_ASSERTION(a)
#define CHECK_CVT(pgs,b)
#define CHECK_POINT(pgs,b,c)
#define CHECK_CONTOUR(pgs,b,c)
#define CHECK_FDEF(pgs,b)
#define CHECK_PROGRAM(a)
#define CHECK_ELEMENT(pgs,b)
#define CHECK_ELEMENTPTR(pgs,b)
#define CHECK_STORAGE(pgs,b)
#define CHECK_STACK(pgs)
#define CHECK_VECTOR(a,b)
#define CHECK_LARGER(a,b)
#define CHECK_INT8(a)
#define CHECK_INT16(a)
#define CHECK_SELECTOR(a)
#define CHECK_SUBSTACK(pgs,a)
#define CHECK_POP(s)                POP(s)
#define CHECK_PUSH(s, v)            PUSH(s, v)
#endif

/*@@*/

/* ClaudeBe 4/15/98 new secure rasterizer testing of critical errors */
/* errors originally detected by the fstrace callback trace function */
/* moved inside the rasterizer for performance reason */

#ifdef FSCFG_SECURE

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) \
 \
  if ( (uintptr_t)lNumItems > (uintptr_t)(stackPtr - LocalGS.globalGS->stackBase) ) \
{ \
	LocalGS.ercReturn = SECURE_STACK_UNDERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) \
 \
  if ( (uintptr_t)lNumItems > (uintptr_t)(LocalGS.globalGS->stackMax - stackPtr) ) \
{ \
	LocalGS.ercReturn = SECURE_STACK_OVERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_SUBSTACK(stackPtr) \
 \
  if ((stackPtr < LocalGS.globalGS->stackBase) || (stackPtr >= LocalGS.globalGS->stackMax)) \
{ \
	LocalGS.ercReturn = SECURE_INVALID_STACK_ACCESS;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_POINT(elem, pt) \
{ \
    if (LocalGS.elements == elem) \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxp->maxTwilightPoints || \
		 (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
    else \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxPointsIncludePhantom || (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
}

#define SECURE_CHECK_FDEF(fdef) \
{ \
    if ((int32)fdef >= (LocalGS.globalGS->maxp->maxFunctionDefs) || (int32)fdef < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_FDEF_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_PROGRAM(pgmIndex) \
{ \
    if (pgmIndex >= MAXPREPROGRAMS) \
    { \
	  LocalGS.ercReturn = SECURE_ERR_FUNCTION_NOT_DEFINED;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_ZONE(elem) \
{ /* in theory we should compare with maxp->maxElements but the rasterizer always allocate for MAX_ELEMENTS zones */ \
    if ((int32)elem >= MAX_ELEMENTS || (int32)elem < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_INVALID_ZONE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) \
{ \
	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM) \
	/* in the glyph program, both zone (glyph and twilight are initialized */ \
	{ \
	    if (LocalGS.globalGS->pgmIndex != PREPROGRAM || LocalGS.elements != elem ) \
		/* in the pre-program, only the twilight zone is initialized, */ \
		/* in any other zone i.e. font program, none of the zones are initialized */ \
		{ \
	       LocalGS.ercReturn = SECURE_UNITIALIZED_ZONE;  /* error returned to client */ \
	       return LocalGS.pbyEndInst; \
		} \
    } \
}


#define SECURE_CHECK_IDEF_OPCODE(idef) \
{ \
    if ( idef & 0xFFFFFF00 ) \
    { \
	  LocalGS.ercReturn = SECURE_INST_OPCODE_TO_LARGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_IDEF_OVERFLOW() \
{ \
    if (LocalGS.globalGS->instrDefCount >= LocalGS.globalGS->maxp->maxInstructionDefs) \
    { \
	  LocalGS.ercReturn = SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_STORAGE(index) \
{ \
    if ((int32)index >= (LocalGS.globalGS->maxp->maxStorage) || (int32)index < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_STORAGE_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CONTOUR(elem, ctr) \
{ /* The reason in SECURE_CHECK_CONTOUR that we are checking against elem->nc instead of maxContours */ \
	/* is that we will access CE2->sp[contour] and we may try to access a point out of bounds */ \
    if ((int32)ctr < 0L || (int32)ctr >= (elem)->nc) \
    { \
	  LocalGS.ercReturn = SECURE_CONTOUR_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CVT(cvt) \
{ \
    if ((int32)cvt >= (LocalGS.globalGS->cvtCount) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) \
{ \
    if (((int32)cvt >= (LocalGS.globalGS->cvtCount) && cvt > 255) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}
#endif // FSCFG_FONTOGRAPHER_BUG

#else

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) 
#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) 
#define SECURE_CHECK_SUBSTACK(stackPtr) 
#define SECURE_CHECK_POINT(elem, pt) 
#define SECURE_CHECK_FDEF(fdef) 
#define SECURE_CHECK_PROGRAM(pgmIndex)
#define SECURE_CHECK_ZONE(elem)
#define SECURE_CHECK_IDEF_OPCODE(idef) 
#define SECURE_CHECK_IDEF_OVERFLOW() 
#define SECURE_CHECK_STORAGE(index) 
#define SECURE_CHECK_CONTOUR(elem, ctr) 
#define SECURE_CHECK_CVT(cvt) 
#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) 

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) 
#endif // FSCFG_FONTOGRAPHER_BUG

#endif


#define BIT0( t ) ( (t) & 0x01 )
#define BIT1( t ) ( (t) & 0x02 )
#define BIT2( t ) ( (t) & 0x04 )
#define BIT3( t ) ( (t) & 0x08 )
#define BIT4( t ) ( (t) & 0x10 )
#define BIT5( t ) ( (t) & 0x20 )
#define BIT6( t ) ( (t) & 0x40 )
#define BIT7( t ) ( (t) & 0x80 )

/****** Element Codes *********/
#define SCE0_CODE       0x13
#define SCE1_CODE       0x14
#define SCE2_CODE       0x15
#define SCES_CODE       0x16

/****** Control Codes *********/
#define IF_CODE         0x58
#define ELSE_CODE       0x1B
#define EIF_CODE        0x59
#define ENDF_CODE       0x2d
#define MD_CODE         0x49

#ifdef FSCFG_SUBPIXEL
	// For SubPixel, rather than deciding within the rounding function whether we're currently
	// running SubPixel at all, and whether we're in the SubPixel-specific direction, we
	// install the appropriate version of the rounding function into the local ParameterBlock.
	// There are two parameters that determine this installation:
	// - a boolean "inSubPixelDirection" in LocalGS, set whenever the pv changes (eg. in SVTCA[X])
	// - an enum "roundState" in localParBlock, set whenever rounding state changes (eg. in RTG[])
	// It is necessary to have variables for these two parameters, because the states they
	// represent change independently, yet the round function depends on both parameters.
	// Whenever any of these two parameters change, we index the matrix "itrp_RoundFunction"
	// below to install the correct rounding function into the local ParameterBlock. 
	// Exception: itrp_RoundDownToGridSP, the SubPixel version of the RDTG function, inspects
	// the pv and actually rounds down to grid if pv == dpv. (cf. comments in itrp_RoundDownToGridSP)
	
	typedef enum { inRtdg = 0, inRdtg, inRutg, inRtg, inRthg, inRoff, inSRnd, inS45Rnd } RoundFunction;
	#ifndef FSCFG_NO_INITIALIZED_DATA
	const
	#endif
		  FntRoundFunc itrp_RoundFunction[2][8]
	#ifndef FSCFG_NO_INITIALIZED_DATA
												=  {{itrp_RoundToDoubleGrid,   itrp_RoundDownToGrid,   itrp_RoundUpToGrid,   itrp_RoundToGrid,   itrp_RoundToHalfGrid,   itrp_RoundOff,   itrp_SuperRound, itrp_Super45Round},
													{itrp_RoundToDoubleGridSP, itrp_RoundDownToGridSP, itrp_RoundUpToGridSP, itrp_RoundToGridSP, itrp_RoundToHalfGridSP, itrp_RoundOffSP, itrp_SuperRound, itrp_Super45Round}}
	#endif
	;
	// Following are two helper macros to update the aforementioned parameters "inSubPixelDirection"
	// and "roundState", along with installing the updated rounding function. The purpose of these
	// macros is to assert correspondence of the two parameters with the rounding function by system,
	// rather than by industriousness. The first helper macro is used whenever the projection vector
	// changes (eg. in SVTCA[X]) which changes whether or not we're in the SubPixel-specific direction.
	// The second helper macro is used whenever the round state changes (eg. in RTG[]).

	// Two versions of the first helper macro to update
	// - localGS.inSubPixelDirection (flag)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the projection vector.
	// We're using two different macros merely because VC wouldn't let us nest an #ifdef within a #define
	#ifdef NoVirtRoundInPrep
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection && (Tuned4SubPixel((localGS).globalGS) || (localGS).globalGS->pgmIndex != PREPROGRAM)][par->roundState];	\
			}
	#else
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
			}
	#endif

	// Second helper macro to update
	// - localParBlock.roundState (enum)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the round state.
	#define UpdateRoundFunctionByRoundState(localGS,state)											\
		{																							\
			fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																									\
			par->roundState = (state);																\
			par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
		}

	// Helper macro to used to determine whether or not to skip a delta instruction or function.
	// In backwardscompatibility mode, deltas are skipped if they are in SubPixel direction or
	// if they are applied to an untouched/unmoved point or if they are postIUP. Additionally,
	// deltas are skipped in composites if they are in SubPixel direction for proper centering
	// and vertical positioning of diacritical marks.
	// See also comments in itrp_SHP_Common.
	#ifdef InlineDeltasOnly
		#define AMovedPointInNonSPDirection(localGS,zonePtr,pointNum)							\
			((uint16)(!VerticalSPDirection((localGS).globalGS) ?								\
					  ProjVectInY((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & YMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupyCalled))) :	\
					  ProjVectInX((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & XMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupxCalled)))))
	#endif

#endif // FSCFG_SUBPIXEL

// Macros for rounding to grid etc. The purpose of these macros is to make the code more readable
// in cases such as MIRP, where rounding is performed inline for optimization reasons.
// - All rounding is applied to non-negative numbers only, negative numbers have their sign changed
//   before and after. 
// - Engine compensation is added to the unrounded number. Notice that substituting (literal) 0 for
//   engine will be optimized by the compiler
// - Rounding, in principle, follows the pattern in RTG:
//   - add half the "resolution" (this corresponds to adding 0.5)
//   - mask with the complement of "resolution"-minus-1 (this corresponds to a truncated division by
//	   "resolution", immediately followed by a multiplication by the same amount)
//	   Notice that masking only works with powers of two for the resolution

// for round-to-double-grid, we simply use half the resolution
#define RTDG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
		x = -x;						\
	}

// for round-down-to-grid, we skip the part that adds 0.5
#define RDTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-up-to-grid, we add "0.9999" instead of 0.5
#define RUTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

#define RTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-to-half-grid, we first round-down-to-grid, then add 0.5
#define RTHG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
		x = -x;						\
	}

// for round-off, we have to do the engine compensation part only
#define ROFF(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
	} else {						\
		x -= engine;				\
	}


// Macro for testing against cvt cut-in. The purpose of this macro is to make the code more readable
// in cases such as MIRP, where this test is performed in various places in accordance with #defines
// and flags. Notice that substituting (literal) 1 for overscale will be optimized by the compiler.
#define CVTCI(parameterBlock,distance,originalDistance,overscale)													\
	{																												\
		F26Dot6 difference = distance - originalDistance;															\
		difference *= overscale;																					\
		if (difference > parameterBlock->wTCI || difference < -parameterBlock->wTCI) /* not within cvt cut-in? */	\
			distance = originalDistance;																			\
	}

/* Set default values for all variables in globalGraphicsState DefaultParameterBlock
 *      Eventually, we should provide for a Default preprogram that could optionally be 
 *      run at this time to provide a different set of default values.
 */
ErrorCode itrp_SetDefaults (
	void *  pvGlobalGS,
	Fixed   fxPixelDiameter)
{
  fnt_ParameterBlock *par;
  fnt_GlobalGraphicStateType *  globalGS;

  globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

  par = &globalGS->defaultParBlock;

#ifdef FSCFG_SUBPIXEL
  par->roundState = inRtg;
  par->RoundValue = itrp_RoundFunction[RunningSubPixel(globalGS)
#ifdef NoVirtRoundInPrep
	// at this point, globalGS->pgmIndex is not defined. However, we may assume that we're called
	// exclusively from fsg_RunPreProgram, hence we assume that we're about to do the pre-program
	&& Tuned4SubPixel(globalGS)
#endif
	][par->roundState]; // at this point, LocalGS.inSubPixelDirection may not be defined
#else
  par->RoundValue = itrp_RoundToGrid;
#endif
  par->minimumDistance = FNT_PIXELSIZE;
  par->wTCI = FNT_PIXELSIZE * 17 / 16;
  par->sWCI = 0;
  par->sW   = 0;
  par->autoFlip = true;
  par->deltaBase = 9;
  par->deltaShift = 3;
  par->angleWeight = 128;
  par->scanControl = 0;
  par->instructControl = 0;

/* Set up the engine compensation array for the interpreter */
/* This will be indexed into by the booleans in some instructions */
  globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
  globalGS->engine[1] = FIXEDTODOT6 (FIXEDSQRT2 - fxPixelDiameter);  /* Black distance */
  globalGS->engine[2] = -globalGS->engine[1];                        /* White distance */

  return NO_ERR;
}

/************************************************************************/

/*
 * Illegal instruction trap
 */
FS_PRIVATE uint8* itrp_IllegalInstruction (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
	FS_UNUSED_PARAMETER(pbyInst);

	LocalGS.ercReturn = UNDEFINED_INSTRUCTION_ERR;  /* returned to client */
	return LocalGS.pbyEndInst;                      /* stops innerEx loop */
}

/************************************************************************/

/*  Scale vector (x,y) to unit length in 2.14   rewrite - 1/25/93 - deanb */

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec)
{
	Fract fLength;
	int32 lSumOfSquares;
	 int32 lShift;

	CHECK_RANGE (x, -32768L << 6, 32767L << 6);
	CHECK_RANGE (y, -32768L << 6, 32767L << 6);


	if ((x == 0L) && (y == 0L))             /* if null vector in */
	{
		pVec->x = ONEVECTOR;                /* default to unit x vector */
		pVec->y = 0;
	}
	else
	{
		if ((x < 32767L) && (x > -32768L) && (y < 32767L) && (y > -32768L))
		{
			lSumOfSquares = (x * x) + (y * y);  
			
				lShift = 8 * sizeof(Fract) - 17; /* to get x and y to 2.30 */
			while (lSumOfSquares < 0x20000000L)
			{
				lSumOfSquares <<= 2;        /* maximize precision */
					 lShift++;
			}
				x <<= lShift;
				y <<= lShift;                         /* keep x and y in step */
		}
		else
		{
			while ((x < 0x20000000L) && (x > -0x20000000L) && (y < 0x20000000L) && (y > -0x20000000L))
			{
				x <<= 1;
				y <<= 1;
			}
			lSumOfSquares = FracMul(x, x) + FracMul(y, y);
		}
		fLength = FracSqrt(lSumOfSquares);
		pVec->x = ROUNDFIXTOINT (FracDiv(x, fLength));
		pVec->y = ROUNDFIXTOINT (FracDiv(y, fLength));
	}
}


/******************** BEGIN Internal Rounding Routines ***************************/

F26Dot6 itrp_RoundToDoubleGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTDG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToDoubleGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTDG(x,engine,VIRTUAL_PIXELSIZE_RTDG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGridSP
#endif


F26Dot6 itrp_RoundDownToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RDTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundDownToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundDownToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
#ifdef RDTGRoundsDownToGrid
	// Historically, if a point to be aligned was away by 1.5 degrees or more from the line to which to align, the TypemanTalk
	// Align has translated to SPVTL, followed by RDTG and MDRP. This has a major problem: The MDRP instruction uses the set pv
	// to measure the original distance on the UNINSTRUCTED outline. This gives us an "original" distance which is more or less
	// wrong, depending on how far the reference point has moved already (notice that it is most likely that the reference point
	// has moved somewhat in x and in y before the alignee gets to be aligned). Subsequently, when MDRP gets to move the point,
	// it uses the same pv again, but this time around on the INSTRUCTED outline, in order to determine how far the point has to
	// be moved in the end. Luckily, this is used in connection with RDTG, which is applied to the "original" distance, and
	// thereby often reduces the "original" distance to 0, which often is closer the the correct original distance than the one
	// obtained by using the pv on the uninstructed outline.
	//   In SubPixel, however, these erroneous "original" distances would be rounded down to the nearest 1/16 of a pixel, and
	// with that become highly visible (a distance of just under 1 pixel, which is what gets rounded down to 0 in b/w, is too
	// large a distance to be ignored in SP). Therefore, we have to make an exception here. The recently introduced TypemanTalk
	// DAlign command, in contrast, uses the DUAL projection vector to measure the original distance on the UNINSTRUCTED outline,
	// which gives us the correct original distance. Therefore the exception is to test whether we're using the PV (in which case
	// we fall back onto the b/w rounding) or not (in which case we're using the SP rounding).
	if (Tuned4SubPixel(LocalGS.globalGS) || LocalGS.OldProject != itrp_Project) { // we're using the dual projection vector
#endif
		F26Dot6 x = xin;

		engine /= ENGINE_COMP_OVERSCALE;
		RDTG(x,engine,VIRTUAL_PIXELSIZE_RDTG);
		if (( (int32) (xin ^ x)) < 0 && xin) {
			x = 0; /* The sign flipped, make zero */
		}
		return x;
#ifdef RDTGRoundsDownToGrid
	} else { // we're using the "normal" projection vector
		return itrp_RoundDownToGrid(GSA xin,engine);
	}
#endif
} // itrp_RoundDownToGridSP
#endif


F26Dot6 itrp_RoundUpToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RUTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundUpToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RUTG(x,engine,VIRTUAL_PIXELSIZE_RUTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGridSP
#endif


F26Dot6 itrp_RoundToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTG(x,engine,VIRTUAL_PIXELSIZE_RTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGridSP
#endif


F26Dot6 itrp_RoundToHalfGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTHG(x,engine,FNT_PIXELSIZE);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? FNT_PIXELSIZE / 2 : -FNT_PIXELSIZE / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToHalfGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTHG(x,engine,VIRTUAL_PIXELSIZE_RTHG);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? VIRTUAL_PIXELSIZE_RTHG / 2 : -VIRTUAL_PIXELSIZE_RTHG / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGridSP
#endif


/*
 * Internal rounding routine
 */
F26Dot6 itrp_RoundOff (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	ROFF(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOff

/*
 * Internal rounding routine
 */
#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundOffSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	ROFF(x,engine,VIRTUAL_PIXELSIZE_ROFF);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOffSP
#endif


/************************************************************************/

/*
 * Internal rounding routine
 */
F26Dot6 itrp_SuperRound (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
	x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin) 
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 itrp_Super45Round (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
	x = -x;
  }
  if (((xin ^ x)) < 0 && xin)
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/******************** END Rounding Routines ***************************/


/* 3-versions ************************************************************************/

/*
 * Moves the point in element by delta (measured against the projection vector)
 * along the freedom vector.
 */

FS_PRIVATE void itrp_MovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
	VECTORTYPE pfProj;
	VECTORTYPE fx;
	VECTORTYPE fy;
	  
	pfProj = LocalGS.pfProj;
	fx = LocalGS.free.x;
	fy = LocalGS.free.y;

	CHECK_POINT (&LocalGS, element, point);

	if (pfProj != ONEVECTOR)
	{
		if (fx) 
		{
			if (pfProj == fx)                   /* if proj.x = 1 */
			{
				element->x[point] += delta;
			}
			else
			{
				element->x[point] += LongMulDiv (delta, (int32)fx, (int32)pfProj);
			}
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			if (pfProj == fy)                   /* if proj.y = 1 */
			{
				element->y[point] += delta;
			}
			else
			{
				element->y[point] += LongMulDiv (delta, (int32)fy, (int32)pfProj);
			}
			element->f[point] |= YMOVED;
		}
	}
	else
	{
		if (fx) 
		{
			element->x[point] += VECTORMUL (delta, fx);
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			element->y[point] += VECTORMUL (delta, fy);
			element->f[point] |= YMOVED;
		}
	}
}


/*
 * For use when the projection and freedom vectors coincide along the x-axis.
 */

FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType*element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->x[point] += delta;
  element->f[point] |= XMOVED;
}


/*
 * For use when the projection and freedom vectors coincide along the y-axis.
 */
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->y[point] += delta;
  element->f[point] |= YMOVED;
}

/*
 * projects x and y into the projection vector.
 */
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.proj.x) + VECTORMUL (y, LocalGS.proj.y));
}


/*
 * projects x and y into the old projection vector.
 */
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.oldProj.x) + VECTORMUL (y, LocalGS.oldProj.y));
}


/*
 * Projects when the projection vector is along the x-axis
 */
F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(y);

  return (x);
}


/*
 * Projects when the projection vector is along the y-axis
 */
F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(x);

  return (y);
}


/*************************************************************************/

/*** Compensation for Transformations ***/

/*
* Internal support routine, keep this guy FAST!!!!!!!          <3>
*/
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0)
{
  VECTORTYPE pvx, pvy;
  fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
  Fixed sySq, sxSq, strSq;

/* Do as few Math routines as possible to gain speed */

  pvx = LocalGS.proj.x;
  pvy = LocalGS.proj.y;
  if (pvy) 
  {
	if (pvx)
	{
	  if (LocalGS.cvtDiagonalStretch == 0)    /* cache is now invalid */
	  {
		pvy = VECTORDOT (pvy, pvy);
		pvx = VECTORDOT (pvx, pvx);
		sySq = FixMul (globalGS->cvtStretchY, globalGS->cvtStretchY);
		sxSq = FixMul (globalGS->cvtStretchX, globalGS->cvtStretchX);

		strSq = FixMul (VECTOR2FIX(pvx),sxSq) + FixMul (VECTOR2FIX(pvy),sySq);
		if  (strSq > ONEFIX)      /* Never happens! */
		  return ONEFIX;

		/* Convert 16.16 to 2.30, compute square root, round to 16.16 */
		LocalGS.cvtDiagonalStretch = (FracSqrt (strSq<<14) + (1<<13)) >> 14;
	  }
	  return LocalGS.cvtDiagonalStretch;
	}
	else        /* pvy == +1 or -1 */
	  return globalGS->cvtStretchY;
  }
  else  /* pvx == +1 or -1 */
	return globalGS->cvtStretchX;
}


/*      Functions for function pointer in local graphic state
*/

FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n)
{
  CHECK_CVT (&LocalGS, n);
  return LocalGS.globalGS->controlValueTable[ n ];
}


FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n)
{
  Fixed scale;

  CHECK_CVT (&LocalGS, n);
  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->controlValueTable[ n ], scale));
}


FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0)
{
  return LocalGS.globalGS->localParBlock.scaledSW;
}


/*
 *
 */
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0)
{
  Fixed scale;

  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->localParBlock.scaledSW, scale));
}


/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);
  CHECK_CVT (&LocalGS, number);
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}



/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);

  CHECK_CVT (&LocalGS, number);

  delta = FixDiv (delta, itrp_GetCVTScale(GSA0));
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}

/*************************************************************************/

/*
 * This is the tracing interpreter.
 */
FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */

	if (pbyInst < pbyEndInst)
	{
		ERR_START ();
		while ((pbyInst < pbyEndInst) && (LocalGS.TraceFunc != NULL))
		{
			LocalGS.insPtr = pbyInst;               /* save for client */
			LocalGS.opCode = *pbyInst;              /* save for client */
			ERR_RECORD (*pbyInst);
			LocalGS.TraceFunc (&LocalGS, pbyEndInst);
			if (LocalGS.TraceFunc == NULL)          /* allow client to break out */
			{
				break;
			}
			lOpCode = (int32)*pbyInst;
			pbyInst++;

			LocalGS.ulInstPerProgram--;
			if(LocalGS.ulInstPerProgram == 0)
			{
				LocalGS.ercReturn = MAX_INSTRUCTIONS_PER_PGM_ERR;
				break;
			}

			pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
			ERR_BREAK ();
		}
		ERR_END ();
	}
}

/*************************************************************************/

/*
 * This is the fast non-tracing interpreter inner loop.
 */

FS_PRIVATE void itrp_InnerExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	ERR_START ();
	
	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */
	
	while (pbyInst < pbyEndInst)
	{
		ERR_RECORD (*pbyInst);
			  
		lOpCode = (int32)*pbyInst;  /* opCode no longer saved in LocalGS */
		pbyInst++;

		LocalGS.ulInstPerProgram--;
		if(LocalGS.ulInstPerProgram == 0)
		{
			LocalGS.ercReturn = MAX_INSTRUCTIONS_PER_PGM_ERR;
			break;
		}

		pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
		ERR_BREAK ();
	}
	ERR_END ();
}

/*************************************************************************/


#ifdef FSCFG_DEBUG
FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n);

FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0)
{
  ERR_REPORT (ERR_GETSINGLEWIDTHNIL, 0, 0, 0, 0);
  return 0;
}

FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n)
{
  ERR_REPORT (ERR_GETCVTENTRYNIL, 0, 0, 0, 0);
  return 0;
}
#endif

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteFontPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	fnt_GlobalGraphicStateType *    globalGS;

#ifdef FSCFG_SECURE
	int32 i;
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->instrDefCount = 0;        /* none allocated yet, always do this, even if there's no fontProgram */
	globalGS->init          = TRUE;
	globalGS->pgmIndex = FONTPROGRAM;

	/* To avoid accessing unitialized memory when setting LocalGS.MIRPCode */
    globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
    globalGS->engine[1] = 0;  /* Black distance */
    globalGS->engine[2] = 0;                        /* White distance */

#ifdef FSCFG_SUBPIXEL
		// init since we don't do itrp_SetDefaults prior to executing the fpgm
    globalGS->localParBlock.roundState = inRtg;
    globalGS->localParBlock.RoundValue = itrp_RoundToGrid;

    globalGS->subPixelCompatibilityFlags = 0;
    globalGS->numDeltaFunctionsDetected = 0;
#endif

#ifdef FSCFG_SECURE
	/* initialize globalGS->funcDef[...].pgmIndex with MAXPREPROGRAMS to detect calls to undefined functions */
	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGS->funcDef[i].pgmIndex = MAXPREPROGRAMS;

	}
#endif // FSCFG_SECURE

	if (globalGS->pgmList[FONTPROGRAM].Instruction)
	{
		return itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[FONTPROGRAM].Instruction,
			globalGS->pgmList[FONTPROGRAM].Instruction +
				globalGS->pgmList[FONTPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	return NO_ERR;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecutePrePgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	ErrorCode   result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->init          = TRUE;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* copy gState parameters */

	globalGS->pgmIndex = PREPROGRAM;

	if (globalGS->pgmList[PREPROGRAM].Instruction)
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[PREPROGRAM].Instruction,
			globalGS->pgmList[PREPROGRAM].Instruction + globalGS->pgmList[PREPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	else
	{
		result = NO_ERR;
	}

	if (! (globalGS->localParBlock.instructControl & DEFAULTFLAG))
		globalGS->defaultParBlock = globalGS->localParBlock;    /* change default parameters */

	return result;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteGlyphPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	uint8 *             ptr,
	uint8 *    eptr,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode                       result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	result = NO_ERR;

	globalGS->init          = FALSE;
	globalGS->pgmIndex		= GLYPHPROGRAM;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* default parameters for glyphs */
	
	if (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG))
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			ptr,
			eptr,
			globalGS,
			TraceFunc);
	}
	*pbChangeScanControl = (globalGS->localParBlock.scanControl !=
						   globalGS->defaultParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);

	return result;
}

/*************************************************************************/

/*
 * Executes the font instructions.
 *
 * Parameter Description
 *
 * elements points to the character elements. Element 0 is always
 * reserved and not used by the actual character.
 *
 * ptr points at the first instruction.
 * eptr points to right after the last instruction
 *
 * globalGS points at the global graphics state
 *
 * TraceFunc is pointer to a callback functioned called with a pointer to the
 *              local graphics state if TraceFunc is not null.
 *
 * Note: The stuff globalGS is pointing at must remain intact
 *       between calls to this function.
 */
FS_PRIVATE ErrorCode itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc)

{
#ifdef FSCFG_REENTRANT
	fnt_LocalGraphicStateType thisLocalGS;
	fnt_LocalGraphicStateType* pLocalGS = &thisLocalGS;
#endif
	fnt_ElementType       aElements[MAX_ELEMENTS];

	MEMCPY((void*)&(aElements[TWILIGHTZONE]), (void*)pTwilightElement, sizeof (fnt_ElementType));
	MEMCPY((void*)&(aElements[GLYPHELEMENT]), (void*)pGlyphElement, sizeof (fnt_ElementType));
	
	STAT_ON_FNTEXEC;                        /* start STAT timer */    
	
	LocalGS.globalGS = globalGS;            /* init Local Graphics State */
	LocalGS.elements = aElements;
	LocalGS.Pt0 = 0; 
	LocalGS.Pt1 = 0; 
	LocalGS.Pt2 = 0;
	LocalGS.CE0 = &aElements[GLYPHELEMENT];
	LocalGS.CE1 = &aElements[GLYPHELEMENT];
	LocalGS.CE2 = &aElements[GLYPHELEMENT];
	LocalGS.free.x = ONEVECTOR;
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.oldProj.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.proj.y = 0;
	LocalGS.oldProj.y = 0;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
	LocalGS.OldProject = itrp_XProject;
	LocalGS.loop = 0;           /* 1 less than count for faster loops. mrr */

	LocalGS.ulJumpCounter = globalGS->ulMaxJumpCounter;           /* counter used to catch infinite loops */
	LocalGS.ulRecursiveCall = globalGS->ulMaxRecursiveCall;           /* counter used to catch deep recrusion */
	LocalGS.ulInstPerProgram = globalGS->ulMaxInstPerProgram;

	if (globalGS->engine[1] == 0)           /* if engine compenstion turned off */
	{
		LocalGS.MIRPCode = MIRPX;           /* default to fast mirp */
	}
	else
	{
		LocalGS.MIRPCode = MIRPG;           /* fall back to general mirp */
	}

	if (globalGS->pgmIndex == FONTPROGRAM)
	{
#ifdef FSCFG_DEBUG
		LocalGS.GetCVTEntry = itrp_GetCVTEntryNil;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthNil;
#else
		LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
#endif
		LocalGS.ChangeCvt = itrp_ChangeCvtFast;
	}
	else
	{
#ifdef FSCFG_SUBPIXEL
		globalGS->subPixelCompatibilityFlags &= ~(SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound | SPCF_inSkippableDeltaFn);
		// can't do this when doing the font program, would try to access the localParBlock, which is still uninitialized at this point.
		UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif
		if (globalGS->pixelsPerEm <= 1)
			return NO_ERR;
		  
		if (globalGS->bSameStretch)
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
			LocalGS.ChangeCvt = itrp_ChangeCvtFast;
		} 
		else 
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntrySlow;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthSlow;
			LocalGS.ChangeCvt = itrp_ChangeCvtSlow;
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}

		if (globalGS->localParBlock.sW)     /* We need to scale the single width for this size  */
		{
			globalGS->localParBlock.scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)(globalGS->localParBlock.sW));
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}
	}
	
	LocalGS.stackPointer = globalGS->stackBase;
	LocalGS.TraceFunc = TraceFunc;
	LocalGS.ercReturn = NO_ERR;             /* default return value */

	if (TraceFunc != NULL)
	{
		LocalGS.Interpreter = itrp_InnerTraceExecute;
	}
	else
	{
		LocalGS.Interpreter = itrp_InnerExecute;
	}
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(globalGS) && CompatibleWidthSP(globalGS))
			InitPhaseControl(&LocalGS.elements[GLYPHELEMENT]); // beats
#endif

	(*LocalGS.Interpreter) (GSA ptr, eptr);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!LocalGS.elements[GLYPHELEMENT].phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,&LocalGS.elements[GLYPHELEMENT]); // beats
	//	phaseControlExecuted == true by now
	}
#endif

	globalGS->ulMaxInstPerProgram = LocalGS.ulInstPerProgram;

        STAT_OFF_FNTEXEC;                            /* stop STAT timer */
	
	return LocalGS.ercReturn;               /* NO_ERR unless illegal inst */
}


/*************************************************************************/

/*** 2 internal LocalGS.pfProj computation support routines ***/

/*
 * Only does the check of LocalGS.pfProj
 */
  FS_PRIVATE void itrp_Check_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj = LocalGS.pfProj;

	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  LocalGS.pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
  }


/*
 * Computes LocalGS.pfProj and then does the check
 */
  FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj;

	pfProj = (VECTORTYPE)(VECTORDOT (LocalGS.proj.x, LocalGS.free.x) + VECTORDOT (LocalGS.proj.y, LocalGS.free.y));
	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
	LocalGS.pfProj = pfProj;

	LocalGS.cvtDiagonalStretch = 0;      /* invalidate cache */ 
  }

/******************************************/
/******** The Actual Instructions *********/
/******************************************/

/*
 * Set Vectors To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = 0;
	LocalGS.free.y = LocalGS.proj.y = ONEVECTOR;
	LocalGS.MovePoint = itrp_YMovePoint;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_YProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPY;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Vectors To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = ONEVECTOR;
	LocalGS.free.y = LocalGS.proj.y = 0;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_XProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPX;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = 0;
	LocalGS.proj.y = ONEVECTOR;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.proj.y = 0;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Freedom Vector to Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = 0;
	LocalGS.free.y = ONEVECTOR;
	LocalGS.pfProj = LocalGS.proj.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector to Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.pfProj = LocalGS.proj.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SPVTL (IPARAM)
  {
	int32 arg1, arg2;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

	CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);
	}

	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Dual Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SDPVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

//	Do the current domain
	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);

//	Do the old domain
	itrp_Normalize (LocalGS.CE1->ox[arg1] - LocalGS.CE2->ox[arg2], LocalGS.CE1->oy[arg1] - LocalGS.CE2->oy[arg2], &LocalGS.oldProj);

	if (BIT0 (lOpCode))	{ // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);

	  tmp = LocalGS.oldProj.y;
	  LocalGS.oldProj.y = LocalGS.oldProj.x;
	  LocalGS.oldProj.x = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = itrp_OldProject;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector To Line
 */
  FS_PRIVATE uint8* itrp_SFVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.free);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp     = LocalGS.free.y;
	  LocalGS.free.y     = LocalGS.free.x;
	  LocalGS.free.x     = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Write Projection Vector
 */
  FS_PRIVATE uint8* itrp_WPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.proj.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.proj.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	CHECK_VECTOR (LocalGS.proj.x, LocalGS.proj.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Write Freedom vector
 */
  FS_PRIVATE uint8* itrp_WFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.free.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.free.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

	CHECK_VECTOR (LocalGS.free.x, LocalGS.free.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Read Projection Vector
 */
  FS_PRIVATE uint8* itrp_RPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.y);
	return pbyInst;
  }

/*
 * Read Freedom Vector
 */
  FS_PRIVATE uint8* itrp_RFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.y);
	return pbyInst;
  }

/*
 * Set Freedom Vector To Projection Vector
 */
  FS_PRIVATE uint8* itrp_SFVTPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free = LocalGS.proj;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * itrp_ISECT ()
 *
 * Computes the intersection of two lines without using floating point!!
 *
 * (1) Bx + dBx * t0 = Ax + dAx * t1
 * (2) By + dBy * t0 = Ay + dAy * t1
 *
 *  1  => (t1 = Bx - Ax + dBx * t0) / dAx
 *  +2 =>   By + dBy * t0 = Ay + dAy/dAx * [ Bx - Ax + dBx * t0 ]
 *     => t0 * [dAy/dAx * dBx - dBy] = By - Ay - dAy/dAx* (Bx-Ax)
 *     => t0 (dAy*DBx - dBy*dAx) = dAx (By - Ay) + dAy (Ax-Bx)
 *     => t0 = [dAx (By-Ay) + dAy (Ax-Bx)] / [dAy*dBx - dBy*dAx]
 *     => t0 = [dAx (By-Ay) - dAy (Bx-Ax)] / [dBx*dAy - dBy*dAx]
 *     t0 = N/D
 *     =>
 *          N = (By - Ay) * dAx - (Bx - Ax) * dAy;
 *              D = dBx * dAy - dBy * dAx;
 *      A simple floating point implementation would only need this, and
 *      the check to see if D is zero.
 *              But to gain speed we do some tricks and avoid floating point.
 *
 */
  FS_PRIVATE uint8* itrp_ISECT (IPARAM)
  {
	F26Dot6 N, D;
	int32   arg1, arg2;
	F26Dot6 Bx, By, Ax, Ay;
	F26Dot6 dBx, dBy, dAx, dAy;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int32 arg1p, arg2p;
#endif

	{
	  fnt_ElementType*element = LocalGS.CE0;
	  F26Dot6*stack = LocalGS.stackPointer;

	  FS_UNUSED_PARAMETER(lOpCode);

      SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 5);

	  arg2 = (int32)CHECK_POP (stack); /* get one line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg1);
	  dAx = element->x[arg2] - (Ax = element->x[arg1]);
	  dAy = element->y[arg2] - (Ay = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS)) {
		  arg2p = arg2;
		  arg1p = arg1;
	  }
#endif

	  element = LocalGS.CE1;
	  arg2 = (int32)CHECK_POP (stack); /* get the other line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);
	  dBx = element->x[arg2] - (Bx = element->x[arg1]);
	  dBy = element->y[arg2] - (By = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS) && MABS(Mul26Dot6(dBy,dAx)) > MABS(Mul26Dot6(dBx,dAy))) {
		  arg2p = arg2;	// pick the line which is closer to the y-axis
		  arg1p = arg1; // since aligning perpendicular to parent axis
	  }
#endif
	  arg1 = (int32)CHECK_POP (stack); /* get the point number */
	  SECURE_CHECK_POINT (LocalGS.CE2, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE2, arg1);
	  LocalGS.stackPointer = stack;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  // for our purposes, handle like a proportion (have intersected point follow proportional to parents)
	  // need no fv, pv set for ISECT, hence we don't test against LocalGS.inSubPixelDirection
	  if (LocalGS.CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS))
		AddProportion(&LocalGS,LocalGS.CE2,arg1p,arg1,arg2p);
#endif
				


	}
	LocalGS.CE2->f[arg1] |= XMOVED | YMOVED;
	{
	  F26Dot6*elementx = LocalGS.CE2->x;
	  F26Dot6*elementy = LocalGS.CE2->y;
	  if (dAy == 0) 
	  {
		if (dBx == 0) 
		{
		  elementx[arg1] = Bx;
		  elementy[arg1] = Ay;
		  return pbyInst;
		}
		N = By - Ay;
		D = -dBy;
	  } 
	  else if (dAx == 0) 
	  {
		if (dBy == 0) 
		{
		  elementx[arg1] = Ax;
		  elementy[arg1] = By;
		  return pbyInst;
		}
		N = Bx - Ax;
		D = -dBx;
	  } 
	  else if (MABS (dAx) >= MABS (dAy))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (By - Ay) - MulDiv26Dot6 (Bx - Ax, dAy, dAx);
		D = MulDiv26Dot6 (dBx, dAy, dAx) - dBy;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (By - Ay, dAx, dAy) - (Bx - Ax);
		D = dBx - MulDiv26Dot6 (dBy, dAx, dAy);
	  }

	  if (D) 
	  {
		elementx[arg1] = Bx + (F26Dot6) MulDiv26Dot6 (dBx, N, D);
		elementy[arg1] = By + (F26Dot6) MulDiv26Dot6 (dBy, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, put point in the middle */
		elementx[arg1] = (Bx + (dBx >> 1) + Ax + (dAx >> 1)) >> 1;
		elementy[arg1] = (By + (dBy >> 1) + Ay + (dAy >> 1)) >> 1;
	  }
	}
	return pbyInst;
  }

/*
 * Load Minimum Distance
 */
  FS_PRIVATE uint8* itrp_LMD (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.minimumDistance = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.minimumDistance);
	return pbyInst;
  }

/*
 * Load Control Value Table Cut In
 */
  FS_PRIVATE uint8* itrp_LWTCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.wTCI = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.wTCI);
	return pbyInst;
  }

/*
 * Load Single Width Cut In
 */
  FS_PRIVATE uint8* itrp_LSWCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.sWCI = CHECK_POP (LocalGS.stackPointer);
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.sWCI);
	return pbyInst;
  }

/*
 * Load Single Width , assumes value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_LSW (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->sW = (int16)arg;
	CHECK_LARGER (-1L, pb->sW);

	pb->scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)pb->sW); /* measurement should not come from the outline */
	return pbyInst;
  }

/* these functions were split out from itrp_SetLocalGraphicState - deanb */
  
  FS_PRIVATE uint8* itrp_SRP0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt0 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt1 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP2 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_LLOOP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.loop = (int32)(CHECK_POP (LocalGS.stackPointer)) - 1;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_POP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }


  FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM)
  {
	int32             arg;
	fnt_ElementType * element;

	switch (lOpCode)
	{
	  case SCES_CODE: 
		ERR_OPC ("SCES");
		break;
	  case SCE0_CODE: 
		ERR_OPC ("SCE0");
		break;
	  case SCE1_CODE: 
		ERR_OPC ("SCE1");
		break;
	  case SCE2_CODE: 
		ERR_OPC ("SCE2");
		break;
	  default:
		ERR_OPC ("???");
		break;
	}

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg);
    CHECK_ELEMENT (&LocalGS, arg);
	element = &LocalGS.elements[ arg ];

	switch (lOpCode)
	{
	  case SCES_CODE: 
		LocalGS.CE2 = element;
		LocalGS.CE1 = element;
	  case SCE0_CODE: 
		LocalGS.CE0 = element;
		break;
	  case SCE1_CODE: 
		LocalGS.CE1 = element;
		break;
	  case SCE2_CODE: 
		LocalGS.CE2 = element;
		break;
#ifdef FSCFG_DEBUG
	  default:
		ERR_REPORT (ERR_INVOPC, lOpCode, 0, 0, 0);
		break;
#endif
	}
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_SROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, true);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inSRnd);
#else
	pb->RoundValue = itrp_SuperRound; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_S45ROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, false);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inS45Rnd);
#else
	pb->RoundValue = itrp_Super45Round; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*********************************************************************/

/*  These routines were split out from SetRoundState  */
/*  They set the current rounding state, and all but  */
/*  RoundToGrid cause MIRP to fall back to MIRPG      */


FS_PRIVATE uint8* itrp_RTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtg)
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToGrid;
#endif
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTHG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRthg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToHalfGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTDG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtdg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToDoubleGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_ROFF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRoff);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundOff;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RDTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRdtg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundDownToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RUTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRutg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundUpToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

/*********************************************************************/


#define FRACSQRT2DIV2   11591
/*
 * Internal support routine for the super rounding routines
 */
  FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound)
  {
	 int32       tmp;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

	tmp = arg1 & 0xC0;

	if (normalRound) 
	{
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period = FNT_PIXELSIZE / 2;
		break;
	  case 0x40:
		pb->period = FNT_PIXELSIZE;
		break;
	  case 0x80:
		pb->period = FNT_PIXELSIZE * 2;
		break;
	  default:
		pb->period = 999; /* Illegal */
	  }
	  pb->periodMask = ~ (pb->period - 1);
	} 
	else 
	{
	  pb->period45 = FRACSQRT2DIV2;
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period45 >>= 1;
		break;
	  case 0x40:
		break;
	  case 0x80:
		pb->period45 <<= 1;
		break;
	  default:
		pb->period45 = 999; /* Illegal */
	  }
	  tmp = (sizeof (pb->period45) * 8 - 2 - FNT_PIXELSHIFT);
	  pb->period = (int16) ((pb->period45 + (1L << (tmp - 1))) >> tmp); /*convert from 2.30 to 26.6 */
	}

	tmp = arg1 & 0x30;
	switch (tmp) 
	{
	case 0x00:
	  pb->phase = 0;
	  break;
	case 0x10:
	  pb->phase = (int16)((pb->period + 2) >> 2);
	  break;
	case 0x20:
	  pb->phase = (int16)((pb->period + 1) >> 1);
	  break;
	case 0x30:
	  pb->phase = (int16)((pb->period + pb->period + pb->period + 2) >> 2);
	  break;
	}
	tmp = arg1 & 0x0f;
	if (tmp == 0) 
	{
	  pb->threshold = (int16)(pb->period - 1);
	} 
	else 
	{
	  pb->threshold = (int16)(((tmp - 4) * pb->period + 4) >> 3);
	}
  }

/*
 * Read Advance Width
 */
  FS_PRIVATE uint8* itrp_RAW (IPARAM)
  {
	F26Dot6* ox;
	int32 index;  

	FS_UNUSED_PARAMETER(lOpCode);

	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM)
	{
		LocalGS.ercReturn = RAW_NOT_IN_GLYPHPGM_ERR;  /* returned to client, error RAW not in glyph program */
		return LocalGS.pbyEndInst;
	}

	ox = LocalGS.elements[GLYPHELEMENT].ox;
	index = LocalGS.elements[GLYPHELEMENT].ep[LocalGS.elements[GLYPHELEMENT].nc - 1] + 1;      /* lsb point */

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH( LocalGS.stackPointer, ox[index+1] - ox[index] );
	return pbyInst;
  }

/*
 * DUPlicate
 */
  FS_PRIVATE uint8* itrp_DUP (IPARAM)
  {
	F26Dot6 top;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	top = LocalGS.stackPointer[-1];
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, top);
	return pbyInst;
  }

/*
 * CLEAR stack
 */
  FS_PRIVATE uint8* itrp_CLEAR (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.stackPointer = LocalGS.globalGS->stackBase;
	return pbyInst;
  }

/*********************************************************************/

/*
 * SWAP
 */
FS_PRIVATE uint8* itrp_SWAP (IPARAM)
{
	F26Dot6 *pfxStack;
	F26Dot6 fxTemp;
		   
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	fxTemp = pfxStack[0];
	pfxStack[0] = pfxStack[-1];
	pfxStack[-1] = fxTemp;
	
	return pbyInst;
}

/*********************************************************************/

/*
 * DEPTH
 */
  FS_PRIVATE uint8* itrp_DEPTH (IPARAM)
  {
	F26Dot6 depth = (F26Dot6)(LocalGS.stackPointer - LocalGS.globalGS->stackBase);
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, depth);
	return pbyInst;
  }

/*
 * Copy INDEXed value
 */
  FS_PRIVATE uint8* itrp_CINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	CHECK_PUSH (stack , tmp);
	return pbyInst;
  }

/*
 * Move INDEXed value
 */
  FS_PRIVATE uint8* itrp_MINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	if (arg1 > 0) 
	{
	  do 
	  {
		*p = * (p + 1); 
		p++;
	  } while (--arg1);
	  CHECK_POP (stack);
	}
	CHECK_PUSH (stack, tmp);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 *      Rotate element 3 to the top of the stack                        <4>
 *      Thanks to Oliver for the obscure code.
 */
  FS_PRIVATE uint8* itrp_ROTATE (IPARAM)
  {
	F26Dot6 *stack = LocalGS.stackPointer;
	F26Dot6 element1;
	F26Dot6 element2;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 3);
	element1 = *--stack;
	element2 = *--stack;

    *stack = element1;
	element1 = *--stack;
	*stack = element2;
	* (stack + 2) = element1;
	return pbyInst;
  }

/*********************************************************************/

/*
 * Move Direct Absolute Point
 */
FS_PRIVATE uint8* itrp_MDAP (IPARAM) {
	F26Dot6 fxProj;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;
	int32 iPoint;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint; 
	LocalGS.Pt1 = iPoint;

	if (BIT0 (lOpCode)) { // round?
		fxProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);
		fxProj = pb->RoundValue (GSA fxProj, LocalGS.globalGS->engine[0]) - fxProj;
	} else {
		fxProj = 0;         /* mark the point as touched */
	}

	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxProj);
	return pbyInst;
} // itrp_MDAP

/*********************************************************************/

/*
 * Move Indirect Absolute Point
 */
FS_PRIVATE uint8* itrp_MIAP (IPARAM) {
	int32   iPoint;
	int32   iCVTIndex;
	F26Dot6 fxNewProj;
	F26Dot6 fxOrigProj;
	F26Dot6 fxProjDif;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	fxNewProj = LocalGS.GetCVTEntry (GSA iCVTIndex);

	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint;
	LocalGS.Pt1 = iPoint;

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE0->x[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.x);
		pCE0->ox[iPoint] = pCE0->x[iPoint];
		pCE0->y[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.y);
		pCE0->oy[iPoint] = pCE0->y[iPoint];
	}

	fxOrigProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);

	if (BIT0 (lOpCode)) { // round?
		fxProjDif = fxNewProj - fxOrigProj;
		if (fxProjDif < 0) {
			fxProjDif = -fxProjDif;
		}
		if (fxProjDif > pb->wTCI) {
			fxNewProj = fxOrigProj;
		}
		fxNewProj = pb->RoundValue (GSA fxNewProj, LocalGS.globalGS->engine[0]);
	}
	// Notice that unlike MIRP, here we don't have a switch that would require the round-off flag MIAP[r] to honour
	// the cvt cut-in. We assume that the context is a stroke placement with coordinates calculated to move a stroke
	// possibly from the origin to the targeted location such as in PMingLiU. See also comments in MSIRP and MIRP.
	
	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxNewProj - fxOrigProj);
	return pbyInst;
} // itrp_MIAP


/*********************************************************************/

FS_PRIVATE uint8* itrp_IUP (IPARAM)
{
	fnt_ElementType *pCE2;
	
	int32 *alOrig;                          /* original outline array */
	int32 *plOrig;
	int32 *plOrigTouch2;                    /* for loop stop */
	int32 *plOrigEnd;
	int32 lOrig1;                           /* touched point 1 */
	int32 lOrig2;                           /* touched point 2 */
	int32 lOrigMin;                         /* min coord touched point */
	int32 lOrigDelta;
	int32 lOrigCorr;
	
	F26Dot6 *afxScaled;                     /* scaled outline array */
	F26Dot6 *pfxScaled;
	F26Dot6 fxScaledMax;
	F26Dot6 fxScaledMin;
	F26Dot6 fxScaledCoord;
	
	F26Dot6 fxMovedMax;                     /* hint movement of max */
	F26Dot6 fxMovedMin;                     /* hint movement of min */

	F26Dot6 *afxHinted;                     /* hinted outline array */
	F26Dot6 *pfxHinted;
	F26Dot6 fxHintedMax;
	F26Dot6 fxHintedMin;
	F26Dot6 fxHintedDelta;

	uint8 *abyFlags;                        /* point flags array */
	uint8 byMask;
	
	int32 iPt;                         /* current point index */
	int32 iStartPt;                    /* start of contour */
	int32 iEndPt;                      /* end of contour */
	int32 iStopPt;                     /* touched point indicates completion */
	int32 iTouch1;
	int32 iTouch2;
	int32 iMin;
	int32 iMax;
			   
	int32 iContour;

	int32 lTemp;
	Fixed fRatio;

	STAT_ON_IUP;                        /* start STAT timer */    

	pCE2 = LocalGS.CE2;

	SECURE_CHECK_FOR_UNITIALIZED_ZONE(pCE2);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS,pCE2 != &LocalGS.elements[TWILIGHTZONE] && // beats
		LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		VerticalSPDirection(LocalGS.globalGS) != (lOpCode & 0x01) && !pCE2->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,pCE2);
	//	phaseControlExecuted == true by now
	}
#endif
	
	abyFlags = pCE2->f;

	if (lOpCode & 0x01)              /* use x coordinates */
	{
		afxHinted = pCE2->x;
		afxScaled = pCE2->ox;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->ox;
		}
		else
		{
			alOrig = pCE2->oox;
		}
		byMask = XMOVED;
	} 
	else                                    /* use y coordinates */
	{
		afxHinted = pCE2->y;
		afxScaled = pCE2->oy;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->oy;
		}
		else
		{
			alOrig = pCE2->ooy;
		}
		byMask = YMOVED;
	}

	for (iContour = 0; iContour < pCE2->nc; iContour++)
	{
		iStartPt = pCE2->sp[iContour];
		iEndPt = pCE2->ep[iContour];
		plOrigEnd = &alOrig[iEndPt];        /* for limit check */

		iPt = iStartPt;
		while (!(abyFlags[iPt] & byMask) && (iPt <= iEndPt))
		{
			iPt++;
		}
		if (iPt <= iEndPt)                  /* if any points are touched */
		{
			iStopPt = iPt;                  /* save for done condition */
			
			do                              /* for each contour segment */
			{
				do                          /* find next untouched point */
				{
					iTouch1 = iPt;
					iPt++;
					if (iPt > iEndPt)
					{
						iPt = iStartPt;
					}
				} while ((abyFlags[iPt] & byMask) && iPt != iStopPt);

				if (iPt != iStopPt)
				{
					iTouch2 = iPt;
					do                      /* find next touched point */
					{
						iTouch2++;
						if (iTouch2 > iEndPt)
						{
							iTouch2 = iStartPt;
						}
					} while (!(abyFlags[iTouch2] & byMask));

					lOrig1 = alOrig[iTouch1];
					lOrig2 = alOrig[iTouch2];
					if (lOrig1 < lOrig2)
					{
						lOrigMin = lOrig1;
						lOrigDelta = lOrig2 - lOrig1;
						iMin = iTouch1;
						iMax = iTouch2;
					}
					else
					{
						lOrigMin = lOrig2;
						lOrigDelta = lOrig1 - lOrig2;
						iMin = iTouch2;
						iMax = iTouch1;
					}
					
					fxHintedMin = afxHinted[iMin];
					fxScaledMin = afxScaled[iMin];
					fxMovedMin = fxHintedMin - fxScaledMin;

					if (lOrigDelta != 0L)
					{
						fxScaledMax = afxScaled[iMax];
						fxHintedMax = afxHinted[iMax];
						fxMovedMax = fxHintedMax - fxScaledMax;
						fxHintedDelta = fxHintedMax - fxHintedMin;

						if (lOrigDelta < 32768 && fxHintedDelta < 32768)
						{
							plOrig = &alOrig[iPt];          /* set up pointers */
							pfxScaled = &afxScaled[iPt];
							pfxHinted = &afxHinted[iPt];
							lOrigCorr = lOrigDelta >> 1;
							plOrigTouch2 = &alOrig[iTouch2];    /* set limits */
							
							while (plOrig < plOrigTouch2)   /* if not across start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
							}                               /* end of time critical loop */
															
							while (plOrig != plOrigTouch2)  /* if points span start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
								
								if (plOrig > plOrigEnd)
								{
									plOrig = &alOrig[iStartPt];
									pfxScaled = &afxScaled[iStartPt];
									pfxHinted = &afxHinted[iStartPt];
								}
							}
							iPt = iTouch2;              /* keep in step */
						}
						else                /* if too big for 32 bit product */
						{
							fRatio = FixDiv (fxHintedDelta, lOrigDelta);
							while (iPt != iTouch2)
							{
								lTemp = afxScaled[iPt];
								if (lTemp <= fxScaledMin)
								{
									lTemp += fxMovedMin;
								}
								else if (lTemp >= fxScaledMax)
								{
									lTemp += fxMovedMax;
								}
								else
								{
									lTemp = alOrig[iPt];
									lTemp -= lOrigMin;
									lTemp = FixMul (lTemp, fRatio);
									lTemp += fxHintedMin;
								}
								afxHinted[iPt] = (F26Dot6)lTemp;
								
								if (iPt < iEndPt)
									iPt++;
								else
									iPt = iStartPt;
							}
						}                   /* endif (lOrigDelta < 32768 && fxHintedDelta < 32768) */
					}
					else                    /* if (lOrigDelta == 0L) */
					{
						while (iPt != iTouch2)
						{
							afxHinted[iPt] += fxMovedMin;
							
							if (iPt < iEndPt)
								iPt++;
							else
								iPt = iStartPt;
						}
					}                       /* endif (lOrigDelta != 0L) */
				}                           /* endif (iPt != iStopPt) */
			} while (iPt != iStopPt);       /* until contour is closed */
		}                                   /* endif (iPt <= iEndPt) */
	 }
								  /* next contour */
	STAT_OFF_IUP;                           /* stop STAT timer */    

#ifdef FSCFG_SUBPIXEL
	LocalGS.globalGS->subPixelCompatibilityFlags |= (lOpCode & 0x01 ? SPCF_iupxCalled : SPCF_iupyCalled);
#endif

	return pbyInst;
} // itrp_IUP

/*********************************************************************/

boolean IsSideBearingPoint(fnt_ElementType *element, int32 point);
boolean IsSideBearingPoint(fnt_ElementType *element, int32 point) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point && point <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingPoint

boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1);
boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point0 && point0 <= numPoints + RIGHTSIDEBEARING || numPoints + LEFTSIDEBEARING <= point1 && point1 <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingLink


  FS_PRIVATE fnt_ElementType* itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode)
  {
	F26Dot6 proj;
	int32 pt;
	fnt_ElementType * element;

	if (BIT0 (lOpCode))
	{
	  pt = LocalGS.Pt1;
	  element = LocalGS.CE0;
	} 
	else 
	{
	  pt = LocalGS.Pt2;
	  element = LocalGS.CE1;
	}

	proj = (*LocalGS.Project) (GSA element->x[pt] - element->ox[pt], element->y[pt] - element->oy[pt]);

	*dx = *dy = 0; // silence prefix

	if (LocalGS.pfProj != ONEVECTOR)
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.x, (int32)LocalGS.pfProj);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.y, (int32)LocalGS.pfProj);
	}
	else
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	}
	*point = pt;
	return element;
  }

/*********************************************************************/

FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy)
{
	fnt_ElementType *CE2;
	int32 count;
	int32 point;
	
	CE2 = LocalGS.CE2;
	count = LocalGS.loop + 1;         /* faster for ms c8 */

	while (count != 0)
	{
		point = (int32)CHECK_POP (LocalGS.stackPointer);
		SECURE_CHECK_POINT (LocalGS.CE2, point);
		CHECK_POINT (&LocalGS, LocalGS.CE2, point);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			AddDistance(&LocalGS,CE2,refPoint,point,OTHER);
#endif

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// here we assume that if we're doing a SHPIX instruction, we're in the context of a function that implements delta instructions
		// for a range of ppem sizes. If such a delta occurs on an untouched point, regardless of whether it's in SP direction or not,
		// it creates a dent in the outline. While for b/w this is intended to flip one or more pixels, it distorts the stroke in SP.
		// If such a delta occurs on a touched point, it moves along the entire outline, such as to place strokes differently. If this
		// happens in SP direction, this distorts the natural spacing of the stroke(s). Therefore we keep only deltas on touched points
		// in non SP direction.
		//   Notice that strictly speaking, we should keep inline deltas (in non SP direction) only. However, since we do not have the
		// tree of instructions at this level, we don't know whether there are any dependant points that have been touched already,
		// prior to applying the delta (in which case it's a pre-IUP delta), or not (in which case it's an inline delta). In cases
		// where a pre-IUP delta was used to cleanup several pixels of the b/w bitmap, the SP result won't be optimal, but not nearly
		// as bad as it would be in grey-scaling. This is due to the oversampling, which in grey-scaling is done in both directions,
		// while only in one direction in SP. As a result, even the oversampled pixels (stripes) are typically "in".
		//   Notice also that we cannot use the fact whether IUP has happened already or not (even though this would be easy to track),
		// since some pre-IUP deltas are erroneously applied to untouched points, the result of which is unreliable in the sense that
		// the delta amount applies to the original (untouched) position of the point, which typically differs from its post-IUP
		// position. While this may lead to the desired result in b/w, in SP point positions likely will differ from those in b/w.
		// This has lead to irregularly spaced (and "angled") glyphs in fonts such as Palatino italic.
		//   Notice, finally, that for composites, the touched/untouched rule does not apply the same way. A point that is flagged as
		// untouched may have been previously touched while executing the code for the respective component. Yet a subsequent SHPIX or
		// possibly delta applied to that point will not create a(nother) dent in the outline, but move the entire outline, instead.
		// This is used in b/w e.g. to re-position diacritics to ensure a minimal distance of 1 pixel between the base character and
		// the diacritic. Hence we also keep deltas in composites.

		if (!shpix || (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_inSkippableDeltaFn) == 0 || AMovedPointInNonSPDirection(LocalGS,CE2,point)) {
#endif // InlineDeltasOnly
#endif // FSCFG_SUBPIXEL
		if (LocalGS.free.x) {
			CE2->x[point] += dx;
			CE2->f[point] |= XMOVED;
		}
		if (LocalGS.free.y) {
			CE2->y[point] += dy;
			CE2->f[point] |= YMOVED;
		}
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		}
#endif
#endif
		count--;
	}
	LocalGS.loop = 0;
    return pbyInst;
}

/*********************************************************************/

/*
 * SHift Point
 */
  FS_PRIVATE uint8* itrp_SHP (IPARAM)
  {
	F26Dot6 dx, dy;
	int32 point;

#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	itrp_SH_Common (GSA &dx, &dy, &point, lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

    return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		point,
#endif
#ifdef FSCFG_SUBPIXEL
		false, // we don't come from SHPIX
#endif
		dx, dy);
  }

/*
 * SHift Contour
 */
  FS_PRIVATE uint8* itrp_SHC (IPARAM)
  {
	fnt_ElementType *element;
	F26Dot6 dx, dy;
	int32 contour, point;

	{
	  F26Dot6 x, y;
	  int32 pt;

#ifdef FSCFG_SECURE
	  if (BIT0 (lOpCode))
	  {
	    SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	  } 
	  else 
	  {
	    SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	  }
#endif 
	  
	  element = itrp_SH_Common (GSA &x, &y, &pt, lOpCode);
	  point = pt;
	  dx = x;
	  dy = y;
	}
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	contour = (int32)CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (element != &LocalGS.elements[TWILIGHTZONE] && // beats
		LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!VerticalSPDirection(LocalGS.globalGS) && !element->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,element);
	//	phaseControlExecuted == true by now
		dx += element->pcr[point].phaseShift;
	}
#endif
	


	SECURE_CHECK_FOR_UNITIALIZED_ZONE(LocalGS.CE2);
	SECURE_CHECK_CONTOUR (LocalGS.CE2, contour);
	CHECK_CONTOUR (&LocalGS, LocalGS.CE2, contour);

	{
	  VECTORTYPE fvx = LocalGS.free.x;
	  VECTORTYPE fvy = LocalGS.free.y;
	  fnt_ElementType*CE2 = LocalGS.CE2;
	  int32 currPt = CE2->sp[contour];
	  int32 count = CE2->ep[contour] - currPt;
	  SECURE_CHECK_POINT (CE2, currPt + count);
	  CHECK_POINT (&LocalGS, CE2, currPt + count);
	  for (; count >= 0; --count)
	  {
		if (currPt != point || element != CE2)
		{
		  if (fvx) 
		  {
			CE2->x[currPt] += dx;
			CE2->f[currPt] |= XMOVED;
		  }
		  if (fvy) 
		  {
			CE2->y[currPt] += dy;
			CE2->f[currPt] |= YMOVED;
		  }
		}
		currPt++;
	  }
	}
	
	return pbyInst;
  }

/*********************************************************************/

/*
 * SHift Element                     rewritten 7/29/93 deanb
 *
 * Flags are no longer set to show touch in x or y direction
 */

FS_PRIVATE uint8* itrp_SHE (IPARAM)
{
	fnt_ElementType *element;
	F26Dot6 fxDX, fxDY;
	int32 lFirstPt, lRefPt, lLastPt, arg1;
	
	F26Dot6 fxSaveX;                    /* for ref point restoration */
	F26Dot6 fxSaveY;
	
	F26Dot6 *pfxX, *pfxStopX;           /* temporary element pointers */
	F26Dot6 *pfxY, *pfxStopY;
	
#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	element = itrp_SH_Common (GSA &fxDX, &fxDY, &lRefPt, lOpCode);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg1);
	CHECK_ELEMENT (&LocalGS, arg1);
	SECURE_CHECK_FOR_UNITIALIZED_ZONE(&LocalGS.elements[arg1]);

	lLastPt = LocalGS.elements[arg1].ep[LocalGS.elements[arg1].nc - 1];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lLastPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lLastPt);
	lFirstPt  = LocalGS.elements[arg1].sp[0];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lFirstPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lFirstPt);

	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		fxSaveX = LocalGS.elements[arg1].x[lRefPt];
		fxSaveY = LocalGS.elements[arg1].y[lRefPt];
	}
	
	if (LocalGS.free.x != 0) 
	{
		pfxX = &LocalGS.elements[arg1].x[lFirstPt];
		pfxStopX = &LocalGS.elements[arg1].x[lLastPt];

		while (pfxX <= pfxStopX)
		{
			*pfxX += fxDX;                      /* shift each point in x */
			pfxX++;
		}
	}

	if (LocalGS.free.y != 0) 
	{
		pfxY = &LocalGS.elements[arg1].y[lFirstPt];
		pfxStopY = &LocalGS.elements[arg1].y[lLastPt];

		while (pfxY <= pfxStopY)
		{
			*pfxY += fxDY;                      /* shift each point in y */
			pfxY++;
		}
	}
	
	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		LocalGS.elements[arg1].x[lRefPt] = fxSaveX;
		LocalGS.elements[arg1].y[lRefPt] = fxSaveY;
	}

	return pbyInst;
}

/*********************************************************************/

/*
 * SHift point by PIXel amount
 */
  FS_PRIVATE uint8* itrp_SHPIX (IPARAM)
  {
	F26Dot6 proj, dx, dy;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 2);
	proj = CHECK_POP (LocalGS.stackPointer);
	if (LocalGS.free.x)
	  dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	else
		dx = 0; // silence BC
	if (LocalGS.free.y)
	  dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	else
		dy = 0; // silence BC

	return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		-1,
#endif
#ifdef FSCFG_SUBPIXEL
		true, // we do come from SHPIX
#endif
		dx, dy);
  }

/*********************************************************************/

/*
 * Interpolate Point
 */

uint8* itrp_IP (IPARAM)
{
	int32 arg1;
	int32 RP1;
	int32 RP2;
	
	int32 cLoop;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_ElementType *pCE2;
	fnt_ElementType *pTwilight;
	
	F26Dot6 x_RP1;
	F26Dot6 ox_RP1;
	F26Dot6 *pCE1_ox;
	F26Dot6 *pCE2_ox;

	F26Dot6 y_RP1;
	F26Dot6 oy_RP1;
	F26Dot6 *pCE1_oy;
	F26Dot6 *pCE2_oy;

	F26Dot6 oldRange;
	F26Dot6 proj;
	F26Dot6 fxDelta;
	
	F26Dot6 *pfxStack;

	FntMoveFunc MovePoint;
	FntProject Project;
	

	FS_UNUSED_PARAMETER(lOpCode);

	cLoop = LocalGS.loop + 1;               /* faster for ms c8 */
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	pCE2 = LocalGS.CE2;
	pTwilight = &LocalGS.elements[TWILIGHTZONE];
	RP1 = LocalGS.Pt1;
	RP2 = LocalGS.Pt2;

	SECURE_CHECK_POINT (pCE0, RP1);
	SECURE_CHECK_POINT (pCE1, RP2);

	pfxStack = LocalGS.stackPointer;

	MovePoint = LocalGS.MovePoint;
	Project = LocalGS.Project;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, cLoop);
    
	if (pCE0 == pTwilight || pCE1 == pTwilight || pCE2 == pTwilight 
		|| LocalGS.globalGS->bOriginalPointIsInvalid)
	{
		ox_RP1 = pCE0->ox[RP1];
		oy_RP1 = pCE0->oy[RP1];
		pCE1_ox = pCE1->ox;
		pCE1_oy = pCE1->oy;
		pCE2_ox = pCE2->ox;
		pCE2_oy = pCE2->oy;
	}
	else
	{
		ox_RP1 = pCE0->oox[RP1];
		oy_RP1 = pCE0->ooy[RP1];
		pCE1_ox = pCE1->oox;
		pCE1_oy = pCE1->ooy;
		pCE2_ox = pCE2->oox;
		pCE2_oy = pCE2->ooy;
	}
	x_RP1 = pCE0->x[RP1];
	y_RP1 = pCE0->y[RP1];
		
	oldRange = LocalGS.OldProject (GSA pCE1_ox[RP2] - ox_RP1, pCE1_oy[RP2] - oy_RP1);
	
	if (oldRange != 0)                      /* this should always happen */
	{
		if (MovePoint == itrp_XMovePoint)   /* so project is also xproject */
		{
			proj = pCE1->x[RP2] - x_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_ox[arg1] - ox_RP1;
				fxDelta = (F26Dot6)MulDiv26Dot6 (proj, fxDelta, oldRange);
				
				pCE2->x[arg1] = fxDelta + x_RP1;
				pCE2->f[arg1] |= XMOVED;
				cLoop--;
			}
		}
		else if (MovePoint == itrp_YMovePoint)  /* so project is also yproject */
		{
			proj = pCE1->y[RP2] - y_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_oy[arg1] - oy_RP1; 
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				
				pCE2->y[arg1] = fxDelta + y_RP1;
				pCE2->f[arg1] |= YMOVED;
				cLoop--;
			}
		}
		else    /* if (MovePoint == itrp_MovePoint) */
		{
			proj = Project (GSA pCE1->x[RP2] - x_RP1, pCE1->y[RP2] - y_RP1);
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				MovePoint (GSA pCE2, arg1, fxDelta - 
					Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
				cLoop--;
			}
		}
	}
	else    /* if (oldRange == 0) */  
			/* this should never happen, but for safety's sake... */
	{
		while (cLoop != 0)
		{
			arg1 = (int32)CHECK_POP (pfxStack);
			SECURE_CHECK_POINT (pCE2, arg1);
			CHECK_POINT (&LocalGS, pCE2, arg1);
						
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
			if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
				AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
			fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
			MovePoint (GSA pCE2, arg1, fxDelta - 
				Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
			cLoop--;
		}
	}       /* endif (oldRange != 0) */
	
	LocalGS.stackPointer = pfxStack;
	LocalGS.loop = 0;
	return pbyInst;
}

/*********************************************************************/

/*
 * Move Stack Indirect Relative Point
 */

uint8* itrp_MSIRP (IPARAM) {
	int32 iPt0;
	int32 iPt2;                            // point #
	F26Dot6 fxDist;                        // distance
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	F26Dot6 fxOutlineDist;
	fnt_ParameterBlock *pb;
#endif
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	F26Dot6 fxPosition;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;

	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iPt0 = LocalGS.Pt0;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    fxDist = CHECK_POP (LocalGS.stackPointer);
	iPt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt2);
	CHECK_POINT (&LocalGS, pCE1, iPt2);
		
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPt2,BLACK); // don't really know any better
		AddDistance(&LocalGS,pCE1,iPt0,iPt2,color);
	}
#endif

	if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE1->ox[iPt2] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.x);
		pCE1->oy[iPt2] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.y);
		pCE1->x[iPt2] = pCE1->ox[iPt2];
		pCE1->y[iPt2] = pCE1->oy[iPt2];
	}
	
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	if (!Tuned4SubPixel(LocalGS.globalGS) && LocalGS.inSubPixelDirection) {
	// similarly to MIRP, here we honour a cvt cut-in in case there is a non-trivial outline distance between the
	// parent (reference) and the child (target) point involved, in which case we assume the context is a stroke weight,
	// else we assume the context is an accent placement function, in which case we use the actual distance as before
		fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt2] - pCE0->ox[iPt0], pCE1->oy[iPt2] - pCE0->oy[iPt0]);
		if (fxOutlineDist) { // else assume we're positioning accents with a calculated MSIRP, hence no cvt cut-in
			pb = &LocalGS.globalGS->localParBlock;
			// notice that unlike MIRP, we don't do the autoFlip since MSIRP is used with calculated distances that
			// would have the correct sign to begin with.
			CVTCI(pb,fxDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
		}
	}
#endif
#endif

	fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPt2] - pCE0->x[iPt0], pCE1->y[iPt2] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt2, fxDist - fxPosition);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt2;
	if (BIT0 (lOpCode)) {
		LocalGS.Pt0 = iPt2; // move the reference point
	}
	return pbyInst;
} // itrp_MSIRP

/*********************************************************************/

/*
 * Align Relative Point
 */

FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM)
  {
	fnt_ElementType*ce1 = LocalGS.CE1;
	F26Dot6 pt0x, pt0y;

	SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt0);

	pt0x = LocalGS.CE0->x[LocalGS.Pt0];
	pt0y = LocalGS.CE0->y[LocalGS.Pt0];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

	for (; LocalGS.loop >= 0; --LocalGS.loop)
	{
	  int32 ptNum = (int32)CHECK_POP (LocalGS.stackPointer);
	  F26Dot6 proj;

	  SECURE_CHECK_POINT (ce1, ptNum);
	  CHECK_POINT (&LocalGS, ce1, ptNum);
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (ce1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			// if we are aligning to some diagonal (pt0 and pt1 are set after SPVTL etc.), and if the child is between the parents
			// (InterAlign, cf. also comments there), we handle it as a proportion, else as a distance with non specific color.
			if (LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,ptNum,LocalGS.pt1))
				AddProportion(&LocalGS,ce1,LocalGS.pt0,ptNum,LocalGS.pt1);
			else
				AddDistance(&LocalGS,ce1,LocalGS.Pt0,ptNum,OTHER);
#endif
	  proj = -(* LocalGS.Project) (GSA ce1->x[ptNum] - pt0x, ce1->y[ptNum] - pt0y);
	  (*LocalGS.MovePoint) (GSA ce1, ptNum, proj);
	}
	LocalGS.loop = 0;
	return pbyInst;
  }


/*
 * Align Two Points (by moving both of them)
 */
  FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 move1, dist;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 2   */
	pt1  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 1   */
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
/* We do not have to check if we are in character element zero (the twilight zone)
		   since both points already have to have defined values before we execute this instruction */
	dist = LocalGS.CE1->x[pt2] - LocalGS.CE0->x[pt1];
	move1 = LocalGS.CE1->y[pt2] - LocalGS.CE0->y[pt1];
	if (LocalGS.Project != itrp_XProject)
	{
	  if (LocalGS.Project == itrp_YProject)
		dist = move1;
	  else
		dist = (*LocalGS.Project) (GSA dist, move1);
	}

	move1 = dist >> 1;
	(*LocalGS.MovePoint) (GSA LocalGS.CE0, pt1, move1);
	(*LocalGS.MovePoint) (GSA LocalGS.CE1, pt2, move1 - dist);
	return pbyInst;
  }

/*
 * Set Angle Weight
 */
  FS_PRIVATE uint8* itrp_SANGW (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.angleWeight = (int16)arg;
	return pbyInst;
  }

/*
 * Flip Point
 */
  FS_PRIVATE uint8* itrp_FLIPPT (IPARAM)
  {
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;
	int32 count = LocalGS.loop;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, count + 1);

    for (; count >= 0; --count)
	{
	  int32 point = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, point);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	  onCurve[ point ] ^= ONCURVE;
	}
	LocalGS.loop = 0;

	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip On a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ |= ONCURVE;
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip Off a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ &= ~ONCURVE;
	return pbyInst;
  }

/* 4/22/90 rwb - made more general
 * Sets lower 16 flag bits of ScanControl variable.  Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 *
 * stack: value => -;
 *
 */
  FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->scanControl = (pb->scanControl & 0xFFFF0000) | arg;
	return pbyInst;
  }

/* 5/24/90 rwb
 * Sets upper 16 bits of ScanControl variable. Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 */

  FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	int32 *scanPtr;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;
	scanPtr = (int32*)&(pb->scanControl);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);

/*  how it was:
	CHECK_SCANMODE (arg);
	if (arg == 0)  
	  *scanPtr &= 0xFFFF;
	else if (arg == 1)        
	  *scanPtr = (*scanPtr & 0xFFFF) | STUBCONTROL;
	else if (arg == 2)        
	  *scanPtr = (*scanPtr & 0xFFFF) | NODOCONTROL;
*/

/*  now any 8 bit value may be passed to the scan converter */
	
	*scanPtr = (*scanPtr & 0xFFFF) | (arg << 16);
	return pbyInst;
  }

/* 6/28/90 rwb
 * Sets instructControl flags in global graphic state.  Only legal in pre program.
 * A selector is used to choose the flag to be set.
 * Bit0 - NOGRIDFITFLAG - if set, then truetype instructions are not executed.
 *              A font may want to use the preprogram to check if the glyph is rotated or
 *              transformed in such a way that it is better to not gridfit the glyphs.
 * Bit1 - DEFAULTFLAG - if set, then changes in localParameterBlock variables in the
 *              globalGraphics state made in the CVT preprogram are not copied back into
 *              the defaultParameterBlock.  So, the original default values are the starting
 *              values for each glyph.
 * Bit2 - TUNED4SPFLAG - if set, a font will be rendered in native SP mode (as opposed to
 *              backwards compatible mode)
 *
 * stack: value, selector => -;
 *
 */
  FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM)  /* <13> */
  {
	fnt_GlobalGraphicStateType *globalGS;
	int32 *ic;
	int32 selector;
	int32 value;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;
	ic = (int32*)&globalGS->localParBlock.instructControl;
	arg = CHECK_POP (LocalGS.stackPointer);
	value = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (globalGS->init)
	{
	  if (selector == 1) 
		*ic &= ~NOGRIDFITFLAG;
	  else if (selector == 2) 
		*ic &= ~DEFAULTFLAG;
	  else if (selector == 3)
		*ic &= ~TUNED4SPFLAG;

	  *ic |= value;
	}
	return pbyInst;
  }

/*
 * AdjustAngle         <4>
 */
  FS_PRIVATE uint8* itrp_AA (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

	/* This is a NOP now. However, do pop the argument off the stack -amitc- 9/11/91. */
	/* Discard the popped value. -lenox- 11/11/91 */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	(void) CHECK_POP (LocalGS.stackPointer);
						 /* old code now lives in history.fnt - deanb */
	return pbyInst;
  }

/*********************************************************************/

/* Called by itrp_PUSHB and itrp_NPUSHB */

/* these functions were split out from itrp_PushSomeStuff - deanb */
  
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		CHECK_PUSH (stack, *pbyInst++);
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
	int16 word;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		word = *pbyInst++;
		CHECK_PUSH (stack, (int16) ((word << 8) + *pbyInst++));
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

/*********************************************************************/

/*
 * PUSH 1 Byte           the most commonly called pushb
 */
FS_PRIVATE uint8* itrp_PUSHB1 (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, *pbyInst++);
	return pbyInst;
}

/*
 * PUSH Bytes
 */
FS_PRIVATE uint8* itrp_PUSHB (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb0 + 1;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * N PUSH Bytes
 */
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * PUSH 1 Word           the most commonly called pushw
 */
FS_PRIVATE uint8* itrp_PUSHW1 (IPARAM)
{
	int16 word;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	word = *pbyInst++;
	CHECK_PUSH (LocalGS.stackPointer, (int16)((word << 8) + *pbyInst++));
	return pbyInst;
}

/*
 * PUSH Words           <3>
 */
FS_PRIVATE uint8* itrp_PUSHW (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb8 + 1;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*
 * N PUSH Words
 */
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*********************************************************************/

/*
 * Write Store
 */
  FS_PRIVATE uint8* itrp_WS (IPARAM)
  {
	F26Dot6 storage;
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	storage = CHECK_POP (LocalGS.stackPointer);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS,storeIndex);

	LocalGS.globalGS->store[ storeIndex ] = storage;
	return pbyInst;
  }

/*
 * Read Store
 */
  FS_PRIVATE uint8* itrp_RS (IPARAM) {
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS, storeIndex);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	if (storeIndex == 8 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedVacuformRound) > 0) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inVacuformRound;
		CHECK_PUSH (LocalGS.stackPointer, 0); // push 0 indicating we don't do vacuforming
	} else {
#endif
#endif
		CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->store[storeIndex]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	}
#endif
#endif
	return pbyInst;
  }

/*
 * Write Control Value Table from outLine, assumes the value comes form the outline domain
 */
  FS_PRIVATE uint8* itrp_WCVT (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);

	if (cvtValue != 0 && LocalGS.GetCVTEntry != itrp_GetCVTEntryFast)
	  cvtValue = FixDiv (cvtValue, itrp_GetCVTScale (GSA0));
	LocalGS.globalGS->controlValueTable[ cvtIndex ] = cvtValue;
	return pbyInst;
  }

/*
 * Write Control Value Table From Original Domain, assumes the value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);
	globalGS->controlValueTable[ cvtIndex ] = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, cvtValue);
	return pbyInst;
  }



/*
 * Read Control Value Table
 */
  FS_PRIVATE uint8* itrp_RCVT (IPARAM)
  {
	int32 cvtIndex;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

#ifndef FSCFG_FONTOGRAPHER_BUG
	SECURE_CHECK_CVT (cvtIndex);
#else
	SECURE_CHECK_CVT_READ_SPECIAL (cvtIndex);
#endif // FSCFG_FONTOGRAPHER_BUG

	CHECK_CVT (&LocalGS, cvtIndex);

	CHECK_PUSH (LocalGS.stackPointer, LocalGS.GetCVTEntry (GSA cvtIndex));
	return pbyInst;
  }

/*
 * Read Coordinate
 */
  FS_PRIVATE uint8* itrp_RC (IPARAM)
  {
	int32 pt;
	fnt_ElementType * element;
	F26Dot6 proj;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pt = (int32)CHECK_POP (LocalGS.stackPointer);
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	if (BIT0 (lOpCode))
	  proj = (*LocalGS.OldProject) (GSA element->ox[pt], element->oy[pt]);
	else
	  proj = (*LocalGS.Project) (GSA element->x[pt], element->y[pt]);

	CHECK_PUSH (LocalGS.stackPointer, proj);
	return pbyInst;
  }

/*
 * Write Coordinate
 */
  FS_PRIVATE uint8* itrp_WC (IPARAM)
  {
	F26Dot6 proj, coord;
	int32 pt;
	fnt_ElementType *element;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	coord = CHECK_POP (LocalGS.stackPointer);/* value */
	pt = (int32)CHECK_POP (LocalGS.stackPointer);/* point */
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	proj = (*LocalGS.Project) (GSA element->x[pt],  element->y[pt]);
	proj = coord - proj;

	(*LocalGS.MovePoint) (GSA element, pt, proj);

	if (element == &LocalGS.elements[TWILIGHTZONE])
	{
	  element->ox[pt] = element->x[pt];
	  element->oy[pt] = element->y[pt];
	}
	return pbyInst;
  }


/*
 * Measure Distance
 */
  FS_PRIVATE uint8* itrp_MD (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 proj, *stack = LocalGS.stackPointer;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2 = (int32)CHECK_POP (stack);
	pt1 = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	if (BIT0 (lOpCode - MD_CODE)) { // MD[O] in original outline
		if (LocalGS.CE0 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.CE1 == &LocalGS.elements[TWILIGHTZONE] 
			|| LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->ox[pt1] - LocalGS.CE0->ox[pt2], LocalGS.CE1->oy[pt1] - LocalGS.CE0->oy[pt2]);
		}
		else if (globalGS->bSameStretch)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2], LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2] );
			proj = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, proj );
		}
		else
		{
			proj = (*LocalGS.OldProject) (GSA 
				globalGS->ScaleFuncX (&globalGS->scaleX, LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2]), 
				globalGS->ScaleFuncY (&globalGS->scaleY, LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2]) );
		}
	}

	/* old MS code, give different value than Apple :
	 * proj  = (*LocalGS.OldProject) (GSA LocalGS.CE0->ox[pt1] - LocalGS.CE1->ox[pt2], LocalGS.CE0->oy[pt1] - LocalGS.CE1->oy[pt2]);
	*/
	
	else { // MD[N] in grid-fitted outline
		proj  = (*LocalGS.Project) (GSA LocalGS.CE0->x[pt1] - LocalGS.CE1->x[pt2], LocalGS.CE0->y[pt1] - LocalGS.CE1->y[pt2]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
		if ((LocalGS.globalGS->subPixelCompatibilityFlags & (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound)) == (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound) && proj == FNT_PIXELSIZE)
			proj++; // increase by smallest possible amount to throw off type 2 vacuforms which are keyed off a distance being exacly 1 pixel
#endif
#endif
	}
	CHECK_PUSH (stack, proj);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Measure Pixels Per EM
 */
  FS_PRIVATE uint8* itrp_MPPEM (IPARAM)
  {
	uint16 ppem;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

	ppem = globalGS->pixelsPerEm;
	if (!globalGS->bSameStretch)
		ppem = (uint16)FixMul (ppem, itrp_GetCVTScale (GSA0));

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, ppem);
	return pbyInst;
  }

/*
 * Measure Point Size
 */
  FS_PRIVATE uint8* itrp_MPS (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->pointSize);
	return pbyInst;
  }

/*
 * Get Miscellaneous info: version number, rotated, stretched   <6>
 * Version number is 8 bits.  This is version 0x01 : 5/1/90
 *
 */

  FS_PRIVATE uint8* itrp_GETINFO (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	int32      info = 0;
	int32      selector;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (selector & VERSIONINTERPRETERQUERY)                            /* version */
	  info |= RASTERIZER_VERSION;
	if ((selector & ROTATEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
	  info |= ROTATEDGLYPH;
	if ((selector & STRETCHEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_STRETCH))
	  info |= STRETCHEDGLYPH;
	if ((selector & HINTFORGRAYINTERPRETERQUERY) && (globalGS->bHintForGray))
	  info |= HINTEDFORGRAYGLYPH;
#ifdef FSCFG_SUBPIXEL
	if ((selector & HINTFORSUBPIXELINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_SUB_PIXEL))
	  info |= HINTEDFORSUBPIXELGLYPH;
	if ((selector & HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
	  info |= HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH;
	if ((selector & HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
	  info |= HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH;
	if ((selector & HINTFORSUBPIXELBGRORDERINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_BGR_ORDER))
	  info |= HINTEDFORSUBPIXELBGRORDERGLYPH;
#endif // FSCFG_SUBPIXEL
	CHECK_PUSH (LocalGS.stackPointer, info);
	return pbyInst;
  } // itrp_GETINFO

/*
 * FLIP ON
 */
  FS_PRIVATE uint8* itrp_FLIPON (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = true;
	return pbyInst;
  }

/*
 * FLIP OFF
 */
  FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = false;
	return pbyInst;
  }

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
/*
 * DEBUG
 */
  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	int32 arg;
	int8 buffer[24];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);

	buffer[1] = 'D';
	buffer[2] = 'E';
	buffer[3] = 'B';
	buffer[4] = 'U';
	buffer[5] = 'G';
	buffer[6] = ' ';
	if (arg >= 0) 
	{
	  buffer[7] = '+';
	} 
	else 
	{
	  arg = -arg;
	  buffer[7] = '-';
	}

	buffer[13] = arg % 10 + '0'; 
	arg /= 10;
	buffer[12] = arg % 10 + '0'; 
	arg /= 10;
	buffer[11] = arg % 10 + '0'; 
	arg /= 10;
	buffer[10] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 9] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 8] = arg % 10 + '0'; 
	arg /= 10;

	buffer[14] = arg ? '*' : ' ';


	buffer[0] = 14; /* convert to pascal */
	DEBUGSTR (buffer);
	return pbyInst;
  }

#else           /* debug */

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* debug */
#else

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* ! not on the mac */


/* these functions were split out from itrp_BinaryOperand - deanb */

  FS_PRIVATE uint8* itrp_LT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] < pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_LTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] <= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] > pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] >= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] == pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] != pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_AND (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] && pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_OR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] || pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_ADD (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] += pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SUB (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] -= pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MUL (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] =  Mul26Dot6(pfxStack[-1], pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_DIV (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[0] == 0)
	{
		LocalGS.ercReturn = DIV_BY_0_IN_HINTING_ERR;  /* returned to client, error DIV by zero */
		return LocalGS.pbyEndInst;
	} 
	pfxStack[-1] = (int32)(((long)pfxStack[-1] << 6) / pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MAX (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] < pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_MIN (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] > pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

/**************************************************************************/

/* these functions were split out from itrp_UnaryOperand - deanb */

// for the ODD/EVEN pair, b/w, and no engine compensation case, we could
// essentially look at the two bits before and after the binary point of
// the F26Dot6 number:
//		1.100000 rounds to 2 (even)
//		1.000000 rounds to 1 (odd)
//		0.100000 rounds to 1 (odd)
//		0.000000 rounds to 0 (even)
// If the two bits are equal, then the number is even, else odd
// for engine compensation, we currently call the full itrp_RoundToGrid
// we'll allow tagged SP fonts to inquire about even/odd virtual pixels

  FS_PRIVATE uint8* itrp_ODD (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EVEN (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	fxArg++;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NOT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = !*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_ABS (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	if (*pfxStack < 0L)
	{
		*pfxStack = -*pfxStack;
	}
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_NEG (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = -*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_CEILING (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack += FNT_PIXELSIZE - 1;		// actually, this is not the pixel size, but the number 1 in 26.6
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// same here
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_FLOOR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// actually, this is not the pixel size, but the number 1 in 26.6
	return pbyInst;
  }
	  

/**************************************************************************/

/* This is called by itrp_IF, itrp_ELSE, itrp_FDEF, and itrp_IDEF         */
/* It is used to find the next TrueType instruction in the instruction    */
/* stream by skipping over push data.  It is table driven for speed.      */

static const uint8 gbyPushTable[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   21,22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 2, 3, 4, 5, 6, 7, 8, 2, 4, 6, 8,10,12,14,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8* pbyInst)
{
	int32 iDataCount;         /* count of data following push instruction */
	
	iDataCount = (int32)gbyPushTable[ pbyInst[-1] ];   /* opcode */
	
	if (iDataCount != 0)                        /* if a push instruction */
	{
		if (iDataCount == 21)                   /* special for npushb */
		{
			iDataCount = (int32)*pbyInst + 1;
		}
		else if (iDataCount == 22)              /* special for npushw */
		{
			iDataCount = ((int32)*pbyInst << 1) + 1;
		}
		pbyInst += iDataCount;

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * IF
 */
FS_PRIVATE uint8* itrp_IF (IPARAM)
{
	int32 iLevel;
	int32 iScanOpCode;
	int32 iDataCount;         /* count of data following push instruction */

	FS_UNUSED_PARAMETER(lOpCode);	
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	if (!CHECK_POP (LocalGS.stackPointer))
	{
		iLevel = 1;
		while ((iLevel != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
		{
			iScanOpCode = (int32)*pbyInst++;

			if (iScanOpCode == EIF_CODE)
			{
				ERR_IF (-1);
				iLevel--;
			} 
			else if (iScanOpCode == IF_CODE) 
			{
				ERR_IF (1);
				iLevel++;
			} 
			else if (iScanOpCode == ELSE_CODE) 
			{
				if (iLevel == 1) 
					break;
			} 
			else
			{
				iDataCount = (int32)gbyPushTable[iScanOpCode];
				
				if (iDataCount != 0)            /* if a push instruction */
				{
					if (iDataCount == 21)       /* special for npushb */
					{
						iDataCount = (int32)*pbyInst + 1;
					}
					else if (iDataCount == 22)  /* special for npushw */
					{
						iDataCount = ((int32)*pbyInst << 1) + 1;
					}
					pbyInst += iDataCount;
				}
			}
		}

		if ((pbyInst == LocalGS.pbyEndInst) && (iLevel != 0))
		{
			LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      ELSE for the IF
 */
FS_PRIVATE uint8* itrp_ELSE (IPARAM)
{
	int16 level;
	uint8 opCode;

	FS_UNUSED_PARAMETER(lOpCode);

	level = 1;
	while ((level != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
	{
		opCode = *pbyInst++;
		
		if (opCode == EIF_CODE)
		{
			ERR_IF (-1);
			level--;
		} 
		else if (opCode == IF_CODE) 
		{
			ERR_IF (1);
			level++;
		} 
		else
		{
			pbyInst = itrp_SkipPushData (GSA pbyInst);
		}
	}

	if (level != 0)
	{
		LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * End IF
 */
FS_PRIVATE uint8* itrp_EIF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);

	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative
 */
FS_PRIVATE uint8* itrp_JMPR (IPARAM)
{
	int32 offset;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);
	offset--;       /* since the interpreter post-increments the IP */
	pbyInst += offset;
	LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */

	if (LocalGS.ulJumpCounter == 0)
	{
		LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
    if (pbyInst < LocalGS.pbyStartInst)
	{
		LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
    }
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On True
 */
FS_PRIVATE uint8* itrp_JROT (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
		{
			LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On False
 */
FS_PRIVATE uint8* itrp_JROF (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (!bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
	    {
		    LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		    return LocalGS.pbyEndInst;
        }
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * ROUND
 */
  FS_PRIVATE uint8* itrp_ROUND (IPARAM)
  {
	F26Dot6 arg1;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x68, 0x6B);

	arg1 = pb->RoundValue (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x68]);
	
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/*
 * No ROUND
 */
  FS_PRIVATE uint8* itrp_NROUND (IPARAM)
  {
	F26Dot6 arg1;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x6C, 0x6F);

	arg1 = itrp_RoundOff (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x6c]);
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/**************************************************************************/

/*
 * An internal function used by MIRP an MDRP.
 */
  F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 fxValue) { // Single Width cut-in? B.St. to check
	F26Dot6 fxDelta;
	F26Dot6 fxScaledSW;
	fnt_ParameterBlock *pb;

	pb = &LocalGS.globalGS->localParBlock;
	fxScaledSW = LocalGS.GetSingleWidth (GSA0);

	if (fxValue >= 0) 
	{
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
	} 
	else 
	{
		fxValue = -fxValue;
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
		fxValue = -fxValue;
	}
	return fxValue;
}

/**************************************************************************/

/*
 * Move Direct Relative Point
 */
FS_PRIVATE uint8* itrp_MDRP (IPARAM)
{
	int32 iPt0;
	int32 iPt1;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	F26Dot6 fxMoveDist;
	F26Dot6 fxUnRounded;
	F26Dot6 fxMin;
	
	iPt0 = LocalGS.Pt0;
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPt1 = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt1);
	CHECK_POINT (&LocalGS, pCE0, iPt0);
	CHECK_POINT (&LocalGS, pCE1, iPt1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS))
		if (LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,iPt1,LocalGS.pt1))
			AddProportion(&LocalGS,pCE1,LocalGS.pt0,iPt1,LocalGS.pt1);
		else 
			AddDistance(&LocalGS,pCE1,iPt0,iPt1,OTHER); // strokes are hardly MDRPed, more likely to get black MDRPs that should be grey
#endif

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE] || pCE1 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.globalGS->bOriginalPointIsInvalid) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt1] - pCE0->ox[iPt0], pCE1->oy[iPt1] - pCE0->oy[iPt0]);
	} else if (globalGS->bSameStretch) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->oox[iPt1] - pCE0->oox[iPt0], pCE1->ooy[iPt1] - pCE0->ooy[iPt0]);
		fxMoveDist = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, fxMoveDist );
	} else {
		fxMoveDist = (*LocalGS.OldProject) (GSA 
			globalGS->ScaleFuncX (&globalGS->scaleX, pCE1->oox[iPt1] - pCE0->oox[iPt0]), 
			globalGS->ScaleFuncY (&globalGS->scaleY, pCE1->ooy[iPt1] - pCE0->ooy[iPt0]) );
	}

	if (pb->sWCI) { // Single Width cut-in? B.St. to check
		fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
	}

	fxUnRounded = fxMoveDist;

	if (BIT2 (lOpCode)) { // Round?
		fxMoveDist = pb->RoundValue (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	} else {
		fxMoveDist = itrp_RoundOff (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	}
	
	if (BIT3 (lOpCode)) { // Minimum distance?
		fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
		if (fxUnRounded >= 0) {
			if (fxMoveDist < fxMin)
				fxMoveDist = fxMin;
		} else {
			fxMin = -fxMin;
			if (fxMoveDist > fxMin)
				fxMoveDist = fxMin;
		}
	}

	fxMoveDist -= (*LocalGS.Project) (GSA pCE1->x[iPt1] - pCE0->x[iPt0], pCE1->y[iPt1] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt1, fxMoveDist);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt1;
	if (BIT4 (lOpCode))
	{
		LocalGS.Pt0 = iPt1;          /* move the reference point */
	}
	return pbyInst;
} // itrp_MDRP


/**************************************************************************/

/*
 * Move Indirect Relative Point     General
 */

/*    
 *  This routine branches to either the general MIRPG, or to the fast MIRPX 
 *  or MIRPY.  The MIRPCode is set to MIRPX at the beginning of each glyph, 
 *  and may be changed to MIRPY or to MIRPX by the SVTCA instructions.  
 *  Any other change in relevant state will cause the function vector to fall 
 *  back to MIRPG.
 *
 *  Conditions for fast MIRPX and MIRPY:
 *      fast cvt (identity transform)
 *      no single width cut in
 *      no twilight zone
 *      round to grid
 *      no engine compensation
 *      LocalGS.MovePoint = itrp_X[or Y]MovePoint;  
 */

FS_PRIVATE uint8* itrp_MIRP (IPARAM)
{
	int32 iPoint;
	int32 iPt0;
	int32 iCVTIndex;
	F26Dot6 fxMoveDist;
	F26Dot6 fxMin;
	F26Dot6 fxOutlineDist;
	F26Dot6 fxPosition;
	F26Dot6 fxEngine;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	
	fnt_ParameterBlock *pb;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;                /* common setup */
	pb = &globalGS->localParBlock;      
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE1, iPoint);
	CHECK_POINT (&LocalGS, LocalGS.CE1, iPoint);
	
	iPt0 = LocalGS.Pt0;
	SECURE_CHECK_POINT (LocalGS.CE0, iPt0);
	CHECK_POINT (&LocalGS, LocalGS.CE0, iPt0);
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPoint;
	
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPoint,lOpCode & 0x03);
		AddDistance(&LocalGS,pCE1,iPt0,iPoint,color);
	}
#endif

	if (LocalGS.MIRPCode == MIRPG)              /********* MIRPG *********/
	{
		fxMoveDist = LocalGS.GetCVTEntry (GSA iCVTIndex);

		if (pb->sWCI) { // Single Width cut-in? B.St. to check
			fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
		}

		if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
			pCE1->ox[iPoint] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.x);
			pCE1->x[iPoint] = pCE1->ox[iPoint];
			pCE1->oy[iPoint] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.y);
			pCE1->y[iPoint] = pCE1->oy[iPoint];
		}

		if (LocalGS.OldProject == itrp_XProject) {
			fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];
		} else if (LocalGS.OldProject == itrp_YProject) {
			fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];
		} else {
			fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPoint] - pCE0->ox[iPt0], pCE1->oy[iPoint] - pCE0->oy[iPt0]);
		}

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

		fxEngine = globalGS->engine[lOpCode & 0x03];

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// here we may honour a cvt cut-in even though the round-off flag would require not to do so. We assume that the
			// context is a stroke weight that has been tweaked for use with grey-scaling, and the only way to force MIRP
			// to use a particular distance is to round the cvt "by hand" and then turn off the rounding flag, which is
			// quite what we don't want to do in SubPixel, ie. to enforce an unnatural weight.
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif // RoundOffRespectsCvtCutIn
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else { // !Round
				fxMoveDist = itrp_RoundOffSP (GSA fxMoveDist, fxEngine);
			}
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL
			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else {
				fxMoveDist = itrp_RoundOff (GSA fxMoveDist, fxEngine);
			}
#ifdef FSCFG_SUBPIXEL
		}
#endif
		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}
		if (LocalGS.Project == itrp_XProject) {
			fxPosition = pCE1->x[iPoint] - pCE0->x[iPt0];
		} else if (LocalGS.Project == itrp_YProject) {
			fxPosition = pCE1->y[iPoint] - pCE0->y[iPt0];
		} else {
			fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPoint] - pCE0->x[iPt0], pCE1->y[iPoint] - pCE0->y[iPt0]);
		}

		(*LocalGS.MovePoint) (GSA pCE1, iPoint, fxMoveDist - fxPosition);
	
	} else if (LocalGS.MIRPCode == MIRPX) {        /********* MIRPX *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];  /* x direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->x[iPoint] = fxMoveDist + pCE0->x[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= XMOVED;
	
	} else { /* if (LocalGS.MIRPCode == MIRPY) */  /********* MIRPY *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];  /* y direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->y[iPoint] = fxMoveDist + pCE0->y[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= YMOVED;
	}
	
	if (BIT4 (lOpCode)) {
		LocalGS.Pt0 = iPoint;                   /* move the reference point */
	}
	return pbyInst;
} // itrp_MIRP

/**************************************************************************/

/*
 * CALL a function
 */
FS_PRIVATE uint8* itrp_CALL (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 *pbySubroutine;
	fnt_GlobalGraphicStateType *globalGS;
	int32 arg;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	uint8 patchedStore22 = false;
	F26Dot6 store22;
#endif
#ifdef BypassJellesSpacing
	uint8 patchedStore24 = false;
	F26Dot6 store24;
#endif
#ifdef AssistTomsDiagonal
	uint8 assistTomsDiagonal = false;
	F26Dot6 cvtCI = 0;
#endif
#ifdef InlineDeltasOnly
	uint16 i;
	uint8 inSkippableDeltaFn = false;
#endif
#endif

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);

	CHECK_PROGRAM (funcDef->pgmIndex);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);
	funcDef = &globalGS->funcDef[ arg ];

 	SECURE_CHECK_PROGRAM (funcDef->pgmIndex);

	pbySubroutine = globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (pbySubroutine != 0);

	pbySubroutine += funcDef->start;
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;        /* save for parent */

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	// here we're assuming that fns 64 through 66 are support functions for the TMT D/IStroke commands, which may make strokes collapse in SubPixel.
	// To determine whether we've actually run into the context of these fns, we look at the first couple of bytes only, as the exact implementation
	// of these functions may have changed over time, but hopefully, the preamble (to look at storage #22) hasn't. The easiest way to by-pass these
	// fns is to flag storage #22 with 0, indicating not to use D/IStrokes, else we'd have to cleanup the stack.
	// Admittedly a bit of a hack. If anybody can think of a "better bandaid", I'll be happy to consider it.
	//    The reason, by the way, why DStroke doesn't work, is the following. DStroke brings pairs of points to the same y (or x), MIRP[m<rBl] the
	// floating point, and the moves it back to the old y (or x). Now that we re-interpret little r, cvt cut in actually gets to cut in, the original
	// distance gets to apply, just that the original distance is taken prior to bringing points to same y (or x), meaning it's likely to be WAY off.
	// As a result, the diagonal stroke weight (in x) starts to depend heavily on the distance (in y) of the control points involved, which obviously
	// is not what we want. Notice that for non-square aspect ratios, the DStroke is a NOP, therefore was a NOP with 16x SubPixel, and hence we're
	// not doing any major harm by skipping it in SubPixel.
	if (64 <= arg && arg <= 66 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedDandIStroke) > 0) {
		store22 = LocalGS.globalGS->store[22];
		LocalGS.globalGS->store[22] = 0;
		patchedStore22 = true;
	}
#endif
#ifdef BypassJellesSpacing
	// here we're assuming that fns 0, 1, 2, 4, 7, and 8 are support functions for Monotype's Jelle Bosma's spacing functions, which may squish
	// characters or pull them left or right or in both directions at the same time. This has to do amongst other with using the twilight zone.
	// The spacing algorithm is meant to be turned off above a certain size, such as 30 ppem, hence we may argue that with the extra virtual re-
	// solution we should turn it off at a considerably smaller ppem size, or altogether. From there the logic is like bypassing D/IStroke.
	// (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedJellesSpacing) > 0) {
		store24 = LocalGS.globalGS->store[24];
		LocalGS.globalGS->store[24] = 0;
		patchedStore24 = true;
	}
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedTomsDiagonal) > 0) {
		cvtCI = LocalGS.globalGS->localParBlock.wTCI;
		LocalGS.globalGS->localParBlock.wTCI = 0x7fffffff;
		assistTomsDiagonal = true;
	}
#endif
#ifdef InlineDeltasOnly
	for (i = 0; i < LocalGS.globalGS->numDeltaFunctionsDetected && LocalGS.globalGS->deltaFunction[i] != (uint16)arg; i++);
	if (i < LocalGS.globalGS->numDeltaFunctionsDetected && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS)) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inSkippableDeltaFn;
		inSkippableDeltaFn = true;
	}
#endif
#endif


	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
	LocalGS.Interpreter (GSA pbySubroutine, pbySubroutine + funcDef->length);   /* recursion */
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
	if (inSkippableDeltaFn) {
		LocalGS.globalGS->subPixelCompatibilityFlags &= ~SPCF_inSkippableDeltaFn;
	}
#endif
#ifdef AssistTomsDiagonal
	if (assistTomsDiagonal) {
		LocalGS.globalGS->localParBlock.wTCI = cvtCI;
	}
#endif
#ifdef BypassJellesSpacing
	if (patchedStore24) {
		LocalGS.globalGS->store[24] = store24;
	}
#endif
#ifdef BypassDandIStroke
	if (patchedStore22) {
		LocalGS.globalGS->store[22] = store22;
	}
#endif
#endif

	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
			
	return pbyInst;
}

/**************************************************************************/

/*
 * Function DEFinition
 */
FS_PRIVATE uint8* itrp_FDEF (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 * program, *funcStart;
	static const uint8 funcFragment[8][16] ={
								{0x01,0x20,0xB0,0x03,0x25},				// SVTCA[X] DUP[] #PUSH 3 CINDEX[] (DiagEndCtrl)
								{0xB0,0x16,0x43,0x58},					// #PUSH 22 RS[] IF[] (D/IStroke)
								{0x01,0xB0,0x18,0x43,0x58},				// SVTCA[X] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #1)
								{0x01,0x18,0xB0,0x18,0x43,0x58},		// SVTCA[X] RTG[] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #2)
								{0x45,0x23,0x46,0x60,0x20,0xB0,0x26},	// RCVT[] SWAP[] GC[N] ADD[] DUP[] #PUSH 38 (VacuFormRound)
								{0x20,0x20,0xB0,0x01,0x60,0x46,0xB0,0x40,0x23,0x42}, // DUP[] DUP[] #PUSH[] 1 ADD[] GC[N] #PUSH[] 64 SWAP[] WS[] (Tom's Diagonal)
								{0x4B,0x53,0x23,0x4B,0x51,0x5A,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}, // MPPEM[] GTEQ[] SWAP[] MPPEM[] LTEQ[] AND[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Range of deltas)
								{0x4B,0x54,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}}; // MPPEM[] EQ[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Delta)

	// extend here for two variants of delta fn

	fnt_GlobalGraphicStateType * globalGS;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	if (LocalGS.globalGS->pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = FDEF_IN_GLYPHPGM_ERR;  /* returned to client, error FDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	funcDef = &globalGS->funcDef[ arg ];
	program = globalGS->pgmList[ funcDef->pgmIndex = LocalGS.globalGS->pgmIndex ].Instruction;

	CHECK_PROGRAM (funcDef->pgmIndex);
	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (globalGS->pgmList[funcDef->pgmIndex].Instruction != 0);

	funcDef->start = (int32)(pbyInst - program);

	funcStart = pbyInst;

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	if (64 <= arg && arg <= 66 && memcmp(funcStart,funcFragment[1],4) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedDandIStroke;
#endif
#ifdef BypassJellesSpacing // (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && (memcmp(funcStart,funcFragment[2],5) == 0 || memcmp(funcStart,funcFragment[3],6) == 0))
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedJellesSpacing;
#endif
#ifdef BypassVacuformRound
	if (arg == 0 && memcmp(funcStart,funcFragment[4],7) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedVacuformRound;
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && memcmp(funcStart,funcFragment[5],10) == 0) 
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedTomsDiagonal;
#endif
#ifdef InlineDeltasOnly
	if (*funcStart == funcFragment[6][0] && (memcmp(funcStart,funcFragment[7],9) == 0 || memcmp(funcStart,funcFragment[6],13) == 0) && LocalGS.globalGS->numDeltaFunctionsDetected < maxDeltaFunctions)
		LocalGS.globalGS->deltaFunction[LocalGS.globalGS->numDeltaFunctionsDetected++] = (uint16)arg;
	// if we have too many delta fns, we'll end up executing a delta fn; this may not look optimal, but we don't expect to get to this point in the first place.
#endif
#endif
	while ( ((*pbyInst++) != ENDF_CODE)  && (pbyInst < LocalGS.pbyEndInst) )
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	funcDef->length = (uint16)(pbyInst - funcStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * LOOP while CALLing a function
 */
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM)
{
	uint8 *start, *stop;
	InterpreterFunc Interpreter;
	fnt_funcDef *funcDef;
	int32 arg;
	int32 loop;
	uint8 * ins;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	funcDef = & (LocalGS.globalGS->funcDef[ arg ]);
	{
		SECURE_CHECK_PROGRAM (funcDef->pgmIndex);
		CHECK_PROGRAM (funcDef->pgmIndex);
		ins = LocalGS.globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

		start = &ins[funcDef->start];
		stop = &ins[funcDef->start + funcDef->length];  /* funcDef->end -> funcDef->length <4> */
	}
	Interpreter = LocalGS.Interpreter;
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	CHECK_LARGER (-1L, arg);
	loop = (int32)arg;
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}

	for (--loop; ((loop >= 0) && (LocalGS.ercReturn == NO_ERR)); --loop)
	{
		Interpreter (GSA start, stop);
	}
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      This guy returns the index of the given opCode, or 0 if not found <4>
 */
FS_PRIVATE fnt_instrDef *itrp_FindIDef (GSP uint8 opCode)
{
	fnt_GlobalGraphicStateType *globalGS;
	int32 count;
	fnt_instrDef*instrDef;
	
	globalGS = LocalGS.globalGS;
	count = globalGS->instrDefCount;
	instrDef = globalGS->instrDef;
		
	for (--count; count >= 0; instrDef++, --count)
	{
		if (instrDef->opCode == opCode)
		{
			return instrDef;
		}
	}
	return 0;
}

/**************************************************************************/

/*
 *      This guy gets called for opCodes that has been patch by the font's IDEF <4>
 *      or if they have never been defined.  If there is no corresponding IDEF,
 *      flag it as an illegal instruction.
 */
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM)
{
	fnt_instrDef *instrDef;
	uint8 *program;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	
	instrDef = itrp_FindIDef (GSA (uint8)lOpCode);
	if (instrDef == 0)
	{
		return itrp_IllegalInstruction (GSA pbyInst, lOpCode);
	}
	else
	{
		SECURE_CHECK_PROGRAM (instrDef->pgmIndex);
		CHECK_PROGRAM (instrDef->pgmIndex);
		program = LocalGS.globalGS->pgmList[ instrDef->pgmIndex ].Instruction;
		program += instrDef->start;
		
		LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
		if (LocalGS.ulRecursiveCall == 0)
		{
			LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}

		LocalGS.Interpreter (GSA program, program + instrDef->length);
	
		LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */

		LocalGS.pbyEndInst = pbyEndInst;    /* restore for parent */
		LocalGS.pbyStartInst = pbyStartInst;/* restore for parent */
		
		if (LocalGS.ercReturn != NO_ERR)    /* if illegal inst has been hit */
		{
			return pbyEndInst;              /* exit parent's loop */
		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 * Instruction DEFinition       <4>
 */
FS_PRIVATE uint8* itrp_IDEF (IPARAM)
{
	int32 arg;
	uint8 opCode;
	fnt_instrDef *instrDef;
	int32 pgmIndex;
	uint8 * program;
	uint8 * instrStart;

	FS_UNUSED_PARAMETER(lOpCode);

	pgmIndex = (int32)LocalGS.globalGS->pgmIndex;

	if (pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = IDEF_IN_GLYPHPGM_ERR;  /* returned to client, error IDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	program = LocalGS.globalGS->pgmList[ pgmIndex ].Instruction;
	instrStart = pbyInst;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_IDEF_OPCODE(arg);
    CHECK_INT8 (arg);
	opCode = (uint8)arg;
	CHECK_PROGRAM (pgmIndex);

	instrDef = itrp_FindIDef (GSA opCode);
	if (!instrDef)
	{
        SECURE_CHECK_IDEF_OVERFLOW();
		instrDef = LocalGS.globalGS->instrDef + LocalGS.globalGS->instrDefCount++;
	}

	instrDef->pgmIndex = (uint8) pgmIndex;
	instrDef->opCode = opCode;          /* this may or may not have been set */
	instrDef->start = (int32)(pbyInst - program);

	while (((*pbyInst++) != ENDF_CODE) && (pbyInst < LocalGS.pbyEndInst))
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	instrDef->length = (uint16)(pbyInst - instrStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * UnTouch Point
 */
  FS_PRIVATE uint8* itrp_UTP (IPARAM)
  {
	uint8*f = LocalGS.CE0->f;
	int32 point;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	point = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, point);
	CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	if (LocalGS.free.x)
	{
	  f[point] &= ~XMOVED;
	}
	if (LocalGS.free.y)
	{
	  f[point] &= ~YMOVED;
	}
	return pbyInst;
  }

/*
 * Set Delta Base
 */
  FS_PRIVATE uint8* itrp_SDB (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaBase = (int16)arg;
	return pbyInst;
  }

/*
 * Set Delta Shift
 */
  FS_PRIVATE uint8* itrp_SDS (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaShift = (int16)arg;
	return pbyInst;
  }

/**************************************************************************/

/*
 * DeltaEngine, internal support routine
 */
FS_PRIVATE uint8*  itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 sBase, int16 sShift)
{
	int32 iRange;
	int32 iAim;
	int32 iHigh;
	int32 iFakePPEM;
	int32 iPPEM;
	F26Dot6 fxDelta;

		/* Find the beginning of data pairs for this particular size */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iHigh = CHECK_POP (LocalGS.stackPointer) << 1;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, iHigh);
	LocalGS.stackPointer -= iHigh;              /* -= number of pops required */
	CHECK_STACK (&LocalGS);

	iRange = LocalGS.globalGS->pixelsPerEm;     /* same as itrp_MPPEM () */
	if (!LocalGS.globalGS->bSameStretch)
		iRange = (int32)FixMul(iRange, itrp_GetCVTScale (GSA0));
	iFakePPEM = iRange - (int32)sBase;

	if ((iFakePPEM >= 16) || (iFakePPEM < 0))
	{
		return pbyInst;                                 /* Not within exception range */
	}
	iFakePPEM = iFakePPEM << 4;

	iAim = 0;
	iRange = iHigh >> 1; 
	iRange &= ~1;
	while (iRange > 2)                          /* binary search for first data */
	{
		iPPEM = LocalGS.stackPointer[ iAim + iRange ]; /* [ iPPEM << 4 | exception ] */
		if ((iPPEM & ~0x0f) < iFakePPEM) 
		{
			iAim += iRange;                     /* approach the starting point */
		}
		iRange >>= 1; 
		iRange &= ~1;                           /* iRange must stay even */
	}

	while (iAim < iHigh) 
	{
		iPPEM = LocalGS.stackPointer[ iAim ];   /* [ iPPEM << 4 | exception ] */
		fxDelta = iPPEM & ~0x0f;
		if (fxDelta == iFakePPEM)
		{                                       /* We found an exception, go ahead and apply it */
			fxDelta = iPPEM & 0xf;              /* 0 ... 15 */
			fxDelta -= fxDelta >= 8 ? 7 : 8;    /* -8 ... -1, 1 ... 8 */
			fxDelta <<= FNT_PIXELSHIFT;        /* convert to pixels */
			fxDelta >>= sShift;                 /* scale to right size */
            
#ifdef FSCFG_SECURE
            if (doIt == LocalGS.MovePoint)
            {
                SECURE_CHECK_POINT(LocalGS.CE0,(int32)LocalGS.stackPointer[iAim+1]);
            } else
			{
				FS_ASSERT( (doIt == LocalGS.ChangeCvt), "itrp_DeltaEngine called with wrong doIt.")
                SECURE_CHECK_CVT((int32)LocalGS.stackPointer[iAim+1]);
			}
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// similar to itrp_SHP_Common above
		// main difference: we don't distinguish between SHPIX and SHP, but between CVT deltas and ordinary deltas
			if (doIt == LocalGS.ChangeCvt || !RunningSubPixel(LocalGS.globalGS) || Tuned4SubPixel(LocalGS.globalGS) || AMovedPointInNonSPDirection(LocalGS,CE0,(int16)LocalGS.stackPointer[iAim+1]))
#endif
#endif
				doIt (GSA LocalGS.CE0, (int32)LocalGS.stackPointer[iAim+1], (F26Dot6) fxDelta);
		} 
		else if (fxDelta > iFakePPEM)
		{
			break;                              /* we passed the data */
		}
		iAim += 2;
	}
    return pbyInst;
}

/**************************************************************************/

/*
 * DELTAP1
 */
  FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAP2
 */
  FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAP3
 */
  FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAC1
 */
  FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAC2
 */
  FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }

/*
 * DELTAC3
 */
  FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }


#ifdef FSCFG_NO_INITIALIZED_DATA
	
	void itrp_InitializeData (void)
	{
		int32 i;

		/***** 0x00 - 0x0f *****/
		function[0x00] = itrp_SVTCA_0;
		function[0x01] = itrp_SVTCA_1;
		function[0x02] = itrp_SPVTCA_0;
		function[0x03] = itrp_SPVTCA_1;
		function[0x04] = itrp_SFVTCA_0;
		function[0x05] = itrp_SFVTCA_1;
		function[0x06] = itrp_SPVTL;
		function[0x07] = itrp_SPVTL;
		function[0x08] = itrp_SFVTL;
		function[0x09] = itrp_SFVTL;
		function[0x0A] = itrp_WPV;
		function[0x0B] = itrp_WFV;
		function[0x0C] = itrp_RPV;
		function[0x0D] = itrp_RFV;
		function[0x0E] = itrp_SFVTPV;
		function[0x0F] = itrp_ISECT;

		/***** 0x10 - 0x1f *****/
		function[0x10] = itrp_SRP0;
		function[0x11] = itrp_SRP1;
		function[0x12] = itrp_SRP2;
		function[0x13] = itrp_SetElementPtr;
		function[0x14] = itrp_SetElementPtr;
		function[0x15] = itrp_SetElementPtr;
		function[0x16] = itrp_SetElementPtr;
		function[0x17] = itrp_LLOOP;
		function[0x18] = itrp_RTG;
		function[0x19] = itrp_RTHG;
		function[0x1A] = itrp_LMD;
		function[0x1B] = itrp_ELSE;
		function[0x1C] = itrp_JMPR;
		function[0x1D] = itrp_LWTCI;
		function[0x1E] = itrp_LSWCI;
		function[0x1F] = itrp_LSW;

		/***** 0x20 - 0x2f *****/
		function[0x20] = itrp_DUP;
		function[0x21] = itrp_POP;
		function[0x22] = itrp_CLEAR;
		function[0x23] = itrp_SWAP;
		function[0x24] = itrp_DEPTH;
		function[0x25] = itrp_CINDEX;
		function[0x26] = itrp_MINDEX;
		function[0x27] = itrp_ALIGNPTS;
		function[0x28] = itrp_RAW;
		function[0x29] = itrp_UTP;
		function[0x2A] = itrp_LOOPCALL;
		function[0x2B] = itrp_CALL;
		function[0x2C] = itrp_FDEF;
		function[0x2D] = itrp_IllegalInstruction;
		function[0x2E] = itrp_MDAP;
		function[0x2F] = itrp_MDAP;

		/***** 0x30 - 0x3f *****/
		function[0x30] = itrp_IUP;
		function[0x31] = itrp_IUP;
		function[0x32] = itrp_SHP;
		function[0x33] = itrp_SHP;
		function[0x34] = itrp_SHC;
		function[0x35] = itrp_SHC;
		function[0x36] = itrp_SHE;
		function[0x37] = itrp_SHE;
		function[0x38] = itrp_SHPIX;
		function[0x39] = itrp_IP;
		function[0x3A] = itrp_MSIRP;
		function[0x3B] = itrp_MSIRP;
		function[0x3C] = itrp_ALIGNRP;
		function[0x3D] = itrp_RTDG;
		function[0x3E] = itrp_MIAP;
		function[0x3F] = itrp_MIAP;

		/***** 0x40 - 0x4f *****/
		function[0x40] = itrp_NPUSHB;
		function[0x41] = itrp_NPUSHW;
		function[0x42] = itrp_WS;
		function[0x43] = itrp_RS;
		function[0x44] = itrp_WCVT;
		function[0x45] = itrp_RCVT;
		function[0x46] = itrp_RC;
		function[0x47] = itrp_RC;
		function[0x48] = itrp_WC;
		function[0x49] = itrp_MD;
		function[0x4A] = itrp_MD;
		function[0x4B] = itrp_MPPEM;
		function[0x4C] = itrp_MPS;
		function[0x4D] = itrp_FLIPON;
		function[0x4E] = itrp_FLIPOFF;
		function[0x4F] = itrp_DEBUG;

		/***** 0x50 - 0x5f *****/
		function[0x50] = itrp_LT;
		function[0x51] = itrp_LTEQ;
		function[0x52] = itrp_GT;
		function[0x53] = itrp_GTEQ;
		function[0x54] = itrp_EQ;
		function[0x55] = itrp_NEQ;
		function[0x56] = itrp_ODD;
		function[0x57] = itrp_EVEN;
		function[0x58] = itrp_IF;
		function[0x59] = itrp_EIF;
		function[0x5A] = itrp_AND;
		function[0x5B] = itrp_OR;
		function[0x5C] = itrp_NOT;
		function[0x5D] = itrp_DELTAP1;
		function[0x5E] = itrp_SDB;
		function[0x5F] = itrp_SDS;

		/***** 0x60 - 0x6f *****/
		function[0x60] = itrp_ADD;
		function[0x61] = itrp_SUB;
		function[0x62] = itrp_DIV;
		function[0x63] = itrp_MUL;
		function[0x64] = itrp_ABS;
		function[0x65] = itrp_NEG;
		function[0x66] = itrp_FLOOR;
		function[0x67] = itrp_CEILING;
		function[0x68] = itrp_ROUND;
		function[0x69] = itrp_ROUND;
		function[0x6A] = itrp_ROUND;
		function[0x6B] = itrp_ROUND;
		function[0x6C] = itrp_NROUND;
		function[0x6D] = itrp_NROUND;
		function[0x6E] = itrp_NROUND;
		function[0x6F] = itrp_NROUND;

		/***** 0x70 - 0x7f *****/
		function[0x70] = itrp_WCVTFOD;
		function[0x71] = itrp_DELTAP2;
		function[0x72] = itrp_DELTAP3;
		function[0x73] = itrp_DELTAC1;
		function[0x74] = itrp_DELTAC2;
		function[0x75] = itrp_DELTAC3;
		function[0x76] = itrp_SROUND;
		function[0x77] = itrp_S45ROUND;
		function[0x78] = itrp_JROT;
		function[0x79] = itrp_JROF;
		function[0x7A] = itrp_ROFF;
		function[0x7B] = itrp_IllegalInstruction;
		function[0x7C] = itrp_RUTG;
		function[0x7D] = itrp_RDTG;
		function[0x7E] = itrp_SANGW;
		function[0x7F] = itrp_AA;

		/***** 0x80 - 0x8d *****/
		function[0x80] = itrp_FLIPPT;
		function[0x81] = itrp_FLIPRGON;
		function[0x82] = itrp_FLIPRGOFF;
		function[0x83] = itrp_IDefPatch;
		function[0x84] = itrp_IDefPatch;
		function[0x85] = itrp_SCANCTRL;
		function[0x86] = itrp_SDPVTL;
		function[0x87] = itrp_SDPVTL;
		function[0x88] = itrp_GETINFO;
		function[0x89] = itrp_IDEF;
		function[0x8A] = itrp_ROTATE;
		function[0x8B] = itrp_MAX;
		function[0x8C] = itrp_MIN;
		function[0x8D] = itrp_SCANTYPE;
		function[0x8E] = itrp_INSTCTRL;

		/***** 0x8f - 0xaf *****/
		for ( i = 0x8F; i <= 0xAF;  ++i )
			function[i] = itrp_IDefPatch;

		/***** 0xb0 - 0xb7 *****/
		function[0xB0] = itrp_PUSHB1;
		function[0xB1] = itrp_PUSHB;
		function[0xB2] = itrp_PUSHB;
		function[0xB3] = itrp_PUSHB;
		function[0xB4] = itrp_PUSHB;
		function[0xB5] = itrp_PUSHB;
		function[0xB6] = itrp_PUSHB;
		function[0xB7] = itrp_PUSHB;

		/***** 0xb8 - 0xbf *****/
		function[0xB8] = itrp_PUSHW1;
		function[0xB9] = itrp_PUSHW;
		function[0xBA] = itrp_PUSHW;
		function[0xBB] = itrp_PUSHW;
		function[0xBC] = itrp_PUSHW;
		function[0xBD] = itrp_PUSHW;
		function[0xBE] = itrp_PUSHW;
		function[0xBF] = itrp_PUSHW;

		/***** 0xc0 - 0xdf *****/
		for ( i = 0xC0; i <= 0xDF;  i++ )
			function[i] = itrp_MDRP;

		/***** 0xe0 - 0xff *****/
		for ( i = 0xE0; i <= 0xFF;  i++ )
			function[i] = itrp_MIRP;
		
#ifdef FSCFG_SUBPIXEL
		// initialize round function table for SP
		itrp_RoundFunction[0][0] = itrp_RoundToDoubleGrid;
		itrp_RoundFunction[0][1] = itrp_RoundDownToGrid;
		itrp_RoundFunction[0][2] = itrp_RoundUpToGrid;
		itrp_RoundFunction[0][3] = itrp_RoundToGrid;
		itrp_RoundFunction[0][4] = itrp_RoundToHalfGrid;
		itrp_RoundFunction[0][5] = itrp_RoundOff;
		itrp_RoundFunction[0][6] = itrp_SuperRound;
		itrp_RoundFunction[0][7] = itrp_Super45Round;
		itrp_RoundFunction[1][0] = itrp_RoundToDoubleGridSP;
		itrp_RoundFunction[1][1] = itrp_RoundDownToGridSP;
		itrp_RoundFunction[1][2] = itrp_RoundUpToGridSP;
		itrp_RoundFunction[1][3] = itrp_RoundToGridSP;
		itrp_RoundFunction[1][4] = itrp_RoundToHalfGridSP;
		itrp_RoundFunction[1][5] = itrp_RoundOffSP;
		itrp_RoundFunction[1][6] = itrp_SuperRound;
		itrp_RoundFunction[1][7] = itrp_Super45Round;
#endif
	}

#endif /* FSCFG_NO_INITIALIZED_DATA */

/* END OF interp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scmemory.h ===
/*********************************************************************

      scmemory.h -- Memory Module Exports

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       3/19/93 deanb    size_t replaced with int32
      10/14/92 deanb    New SetupMem parameters
      10/09/92 deanb    PSTP added
      10/08/92 deanb    Horiz/Vert memory alloc's
       9/09/92 deanb    Alloc param int32  
       9/08/92 deanb    Setup with WorkSpace pointer 
       8/21/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE              /* pointer to state variables */
        char*,              /* pointer to horiz workspace */
        int32 ,             /* size of horiz workspace */
        char*,              /* pointer to vert workspace */
        int32               /* size of vert workspace */
);

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from horiz memory pool */
);

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from vert memory pool */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scendpt.h ===
/*********************************************************************

	  scendpt.h -- EndPoint Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetEndpointElemSize returns size_t 
	   9/08/92 deanb    GetEndpointElemSize added 
	   7/24/92 deanb    ContourSave functions deleted 
	   4/09/92 deanb    New types again 
	   3/20/92 deanb    New types, save contour functions 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupEndPt ( PSTATE0 );

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* starting point x coordinate */
		F26Dot6             /* starting point y coordinate */
);

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* x coordinate */
		F26Dot6,            /* y coordinate */
		uint16              /* scan control type */
);

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE              /* pointer to state variables */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scentry.c ===
/*********************************************************************

      scentry.c -- New Scan Converter NewScan Module

      (c) Copyright 1992-1997  Microsoft Corp.  All rights reserved.

      10/14/97  claudebe    accessing unitialized memory
       1/31/95  deanb       added fsc_GetCoords function
       8/04/94  deanb       State initialized to more it out of bss
       8/24/93  deanb       flatcount fix to reversal detection
       8/10/93  deanb       gray scale support routines added
       6/22/93  deanb       all black bounding box, (0,0) for null glyph
       6/11/93  gregh       Removed ONCURVE definition
       6/11/93  deanb       if HiBand <= LoBand do entire bitmap
       6/10/93  deanb       fsc_Initialize added, stdio & assert gone
       4/06/92  deanb       CheckContour removed
       3/19/92  deanb       ScanArrays rather than lists
      12/22/92  deanb       MultDivide -> LongMulDiv; Rectangle -> Rect
      12/21/92  deanb       interface types aligned with rasterizer
      12/11/92  deanb       fserror.h imported, new error codes
      11/30/92  deanb       WorkSpace renamed WorkScan
      11/04/92  deanb       remove duplicate points function added
      10/28/92  deanb       memory requirement calculation reworked
      10/19/92  deanb       bad contours ignored rather than error'd
      10/16/92  deanb       first contour point off curve fix
      10/13/92  deanb       rect.bounds correction
      10/12/92  deanb       reentrant State implemented
      10/08/92  deanb       reworked for split workspace
      10/05/92  deanb       global ListMemory replace with stListSize 
       9/25/92  deanb       scankind included in line/spline/endpoint calls 
       9/10/92  deanb       dropout coding begun 
       9/08/92  deanb       MAXSPLINELENGTH now imported from scspline.h 
       8/18/92  deanb       New i/f for dropout control, contour elems 
       7/28/92  deanb       Recursive calls for up/down & left/right 
       7/23/92  deanb       EvaluateSpline included 
       7/17/92  deanb       Included EvaluateLine 
       7/13/92  deanb       Start/End point made SHORT 
       6/01/92  deanb       fsc_FillBitMap debug switch added 
       5/08/92  deanb       reordered includes for precompiled headers 
       4/27/92  deanb       Splines coded 
       4/09/92  deanb       New types 
       4/06/92  deanb       rectBounds calc corrected 
       3/30/92  deanb       MinMax calc added to MeasureContour 
       3/24/92  deanb       GetWorkspaceSize coded 
       3/23/92  deanb       First cut 
 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for LongMulDiv */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scspline.h"            /* spline evaluation */
#include    "scline.h"              /* line evaluation */
#include    "scendpt.h"             /* for init and contour list */
#include    "scanlist.h"            /* for init and bitmap */
#include    "scmemory.h"            /* for setup mem */
#include    "scentry.h"             /* for own function prototypes */

/*********************************************************************/
                                             
/*      Global state structure                                       */

/*********************************************************************/

#ifndef FSCFG_REENTRANT
    
FS_PUBLIC StateVars   State = {0};  /* global static:  available to all */

#endif

/*********************************************************************/
                                             
/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema(ContourList*, GlyphBitMap*);

FS_PRIVATE int32 EvaluateSpline(PSTATE F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, uint16 );


/*********************************************************************/
                                             
/*      Function Exports                                             */

/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_Initialize()
{
    fsc_InitializeScanlist();               /* scanlist calls to bitmap */
}


/*********************************************************************/

/*  Remove duplicated points from contour data                       */

/*  This was previously done in sc_FindExtrema of sc.c,              */
/*  but was pulled out to avoid having fsc_MeasureGlyph              */
/*  make changes to the contour list data structure.                 */

/*********************************************************************/

FS_PUBLIC int32 fsc_RemoveDups( 
        ContourList* pclContour )           /* glyph outline */
{
    uint16 usContour;                       /* contour limit */
    int16 sStartPt, sEndPt;                 /* coutour index limits */
    int16 sPt;                              /* point index */
    int16 s;                                /* index for list collapse */
    F26Dot6 *pfxX1, *pfxY1;                 /* leading point */
    F26Dot6 fxX2, fxY2;                     /* trailing point */

    for (usContour = 0; usContour < pclContour->usContourCount; usContour++)
    {
        sStartPt = pclContour->asStartPoint[usContour];
        sEndPt = pclContour->asEndPoint[usContour];
        
        pfxX1 = &(pclContour->afxXCoord[sStartPt]); 
        pfxY1 = &(pclContour->afxYCoord[sStartPt]); 
                    
        for (sPt = sStartPt; sPt < sEndPt; ++sPt)
        {
            fxX2 = *pfxX1;                          /* check next pair */
            pfxX1++;
            fxY2 = *pfxY1;
            pfxY1++;
            
            if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if duplicate */
            {
                for(s = sPt; s > sStartPt; s--)     /* s = index of point to be removed */
                {
                    pclContour->afxXCoord[s] = pclContour->afxXCoord[s - 1];
                    pclContour->afxYCoord[s] = pclContour->afxYCoord[s - 1];
                    pclContour->abyOnCurve[s] = pclContour->abyOnCurve[s - 1];
                }
                sStartPt++;                         /* advance start past dup */
                pclContour->asStartPoint[usContour] = sStartPt;
                pclContour->abyOnCurve[sPt + 1] |= ONCURVE; /* dup'd pt must be on curve */
            }
        }
        
        /* now pfxX1 and pfxY1 point to end point coordinates */

        if (sStartPt != sEndPt)                     /* finished if single point */
        {
            fxX2 = pclContour->afxXCoord[sStartPt];
            fxY2 = pclContour->afxYCoord[sStartPt];
                                
            if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if start = end */
            {
                pclContour->asStartPoint[usContour]++;
                pclContour->abyOnCurve[sEndPt] |= ONCURVE;  /* dup'd pt must be on curve */
            }
        }
    }
    return NO_ERR;
}


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given glyph into a given bitmap.  Get per intersection and     */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

 FS_PRIVATE int32 fsc_CheckYReversal (
        PRevRoot prrRoots,
        F26Dot6 fxY1,
        F26Dot6 fxY2,
        int16 *sDir,
        int16 *sOrgDir,
        int16 *sFlatCount)
{
    int32 lErrCode;

    if (*sDir == 0)
    {
        if (fxY2 > fxY1)                        /* find first up or down */
        {
            *sDir = 1;
            *sOrgDir = *sDir;                    /* save original ep check */
        }
        else if (fxY2 < fxY1)
        {
            *sDir = -1;
            *sOrgDir = *sDir;                     /* save original ep check */
        }
        else
        {
            (*sFlatCount)++;                       /* countour starts flat */
        }
    }
    else if (*sDir == 1)
    {
        if (fxY2 <= fxY1)                   /* = is for endpoint cases */
        {
            lErrCode = fsc_AddYReversal (prrRoots, fxY1, 1);
            if (lErrCode != NO_ERR) return lErrCode;

            *sDir = -1;
        }
    }
    else    /* if sDir == -1 */
    {
        if (fxY2 >= fxY1)                   /* = is for endpoint cases */
        {
            lErrCode = fsc_AddYReversal (prrRoots, fxY1, -1);
            if (lErrCode != NO_ERR) return lErrCode;

            *sDir = 1;
        }
    }

    return NO_ERR;
}

FS_PRIVATE int32 fsc_CheckYReversalInSpline( 
        PRevRoot prrRoots,
        int16 *sDir,
        int16 *sOrgDir,
        int16 *sFlatCount,
        F26Dot6 fxX1,               /* start point x coordinate */
        F26Dot6 fxY1,               /* start point y coordinate */
        F26Dot6 fxX2,               /* control point x coordinate */
        F26Dot6 fxY2,               /* control point y coordinate */
        F26Dot6 fxX3,               /* ending x coordinate */
        F26Dot6 fxY3               /* ending y coordinate */
)
{
    /* subset of EvaluateSpline, must cut spline the same way in regrads to Y direction reversal */

    int32 lErrCode;

    F26Dot6 fxDX21, fxDX32;     /* delta x's */
    F26Dot6 fxDY21, fxDY32;     /* delta y's */
    
    F26Dot6 fxDenom;                    /* ratio denominator  */
    F26Dot6 fxX4, fxY4;                 /* first mid point */
    F26Dot6 fxX5, fxY5;                 /* mid mid point */
    F26Dot6 fxX6, fxY6;                 /* second mid point */
    F26Dot6 fxX456, fxY456;             /* for monotonic subdivision */

    fxDX21 = fxX2 - fxX1;                       /* get all four deltas */
    fxDX32 = fxX3 - fxX2;
    fxDY21 = fxY2 - fxY1;
    fxDY32 = fxY3 - fxY2;
  
/*  If spline goes up and down, then subdivide it  */

    if (((fxDY21 > 0L) && (fxDY32 < 0L)) || ((fxDY21 < 0L) && (fxDY32 > 0L)))
    {
        fxDenom = fxDY21 - fxDY32;              /* total y span */
        
        if(fxDenom == 0)
            return SPLINE_SUBDIVISION_ERR;

        fxX4 = fxX1 + LongMulDiv(fxDX21, fxDY21, fxDenom);
        fxX6 = fxX2 + LongMulDiv(fxDX32, fxDY21, fxDenom);
        fxX5 = fxX4 + LongMulDiv(fxX6 - fxX4, fxDY21, fxDenom);
        fxY456 = fxY1 + LongMulDiv(fxDY21, fxDY21, fxDenom);        
        
        lErrCode = fsc_CheckYReversalInSpline(prrRoots, sDir, sOrgDir, sFlatCount, fxX1, fxY1, fxX4, fxY456, fxX5, fxY456);
        if (lErrCode != NO_ERR) return lErrCode;
       
        return fsc_CheckYReversalInSpline(prrRoots, sDir, sOrgDir, sFlatCount, fxX5, fxY456, fxX6, fxY456, fxX3, fxY3);
    }
    
/*  If spline goes left and right, then subdivide it  */
    
    if (((fxDX21 > 0L) && (fxDX32 < 0L)) || ((fxDX21 < 0L) && (fxDX32 > 0L)))
    {
        fxDenom = fxDX21 - fxDX32;              /* total x span */

        if(fxDenom == 0)
            return SPLINE_SUBDIVISION_ERR;
        
        fxY4 = fxY1 + LongMulDiv(fxDY21, fxDX21, fxDenom);
        fxY6 = fxY2 + LongMulDiv(fxDY32, fxDX21, fxDenom);
        fxY5 = fxY4 + LongMulDiv(fxY6 - fxY4, fxDX21, fxDenom);
        fxX456 = fxX1 + LongMulDiv(fxDX21, fxDX21, fxDenom);
        
        lErrCode = fsc_CheckYReversalInSpline(prrRoots, sDir, sOrgDir, sFlatCount, fxX1, fxY1, fxX456, fxY4, fxX456, fxY5);
        if (lErrCode != NO_ERR) return lErrCode;       

        return fsc_CheckYReversalInSpline(prrRoots, sDir, sOrgDir, sFlatCount, fxX456, fxY5, fxX456, fxY6, fxX3, fxY3);
    }
/*  By now the spline must be monotonic  */   

    return fsc_CheckYReversal(prrRoots, fxY1, fxY3, sDir, sOrgDir, sFlatCount);
}


FS_PUBLIC int32 fsc_MeasureGlyph( 
        ContourList* pclContour,        /* glyph outline */
        GlyphBitMap* pbmpBitMap,        /* to return bounds */
        WorkScan  * pwsWork,              /* to return values */
        uint16 usScanKind,              /* dropout control value */
        uint16 usRoundXMin,              /* for gray scale alignment */
        int16 sBitmapEmboldeningHorExtra,
        int16 sBitmapEmboldeningVertExtra )
{
    uint16 usCont;                      /* contour index */
    int16 sPt;                          /* point index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int16 sOrgDir;                      /* original contour direction */
    int16 sDir;                         /* current contour direction */
    int16 sFlatCount;                   /* for contours starting flat */
    int32 lVScanCount;                  /* total vertical scan lines */
    int32 lHScanCount;                  /* total horizontal scan lines */
    int32 lTotalHIx;
    int32 lTotalVIx;
    int32 lElementCount;                /* total element point estimate */
    int32 lDivide;                      /* spline element point counter */
    int32 lErrCode;    
    
    F26Dot6 fxX1, fxX2, fxX3;                 /* x coord endpoints */
    F26Dot6 fxY1, fxY2, fxY3;                 /* y coord endpoints */
    F26Dot6 *pfxXCoord, *pfxYCoord, *pfxXStop;     /* for fast point array access */
    F26Dot6 fxAbsDelta;                 /* for element count check */
    uint8 byF1, byF2;                   /* oncurve flag values */
    uint8 *pbyFlags;                    /* for element count check */

    PRevRoot prrRoots;                  /* reversal list roots structure */

    
    lErrCode = FindExtrema(pclContour, pbmpBitMap); /* calc bounding box */
    if (lErrCode != NO_ERR) return lErrCode;

    pbmpBitMap->rectBounds.left &= -((int32)usRoundXMin);   /* mask off low n bits */

    /* bitmap emboldening by 2% + 1 pixel horizontally, 2% vertically */
    if ((pbmpBitMap->rectBounds.top != pbmpBitMap->rectBounds.bottom) && (pbmpBitMap->rectBounds.left != pbmpBitMap->rectBounds.right))
    {
         // we don't want to increase the size of the bitmap on a empty glyph
        if (sBitmapEmboldeningHorExtra > 0)
        {
            pbmpBitMap->rectBounds.right += sBitmapEmboldeningHorExtra;
        }
        else
        {
            pbmpBitMap->rectBounds.left += sBitmapEmboldeningHorExtra;
        }
        if (sBitmapEmboldeningVertExtra > 0)
        {
            pbmpBitMap->rectBounds.bottom -= (sBitmapEmboldeningVertExtra);
        }
        else
        {
            pbmpBitMap->rectBounds.top -= (sBitmapEmboldeningVertExtra);
        }
    }

    prrRoots = fsc_SetupRevRoots(pwsWork->pchRBuffer, pwsWork->lRMemSize);
    lElementCount = 0;                  /* smart point counter */
    
    for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
    {
        sStart = pclContour->asStartPoint[usCont];
        sEnd = pclContour->asEndPoint[usCont];
        if (sStart == sEnd)
        {
            continue;                               /* for anchor points */
        }

/* check contour Y values for direction reversals */

        /* in order to get correct value here and avoid overflow later, 
           we need to cut splines is subsplines the same way as it's done in fsc_FillGlyph */

        pfxXCoord = &pclContour->afxXCoord[sStart];
        pfxYCoord = &pclContour->afxYCoord[sStart];
        pbyFlags = &pclContour->abyOnCurve[sStart];
        pfxXStop = &pclContour->afxXCoord[sEnd];

        if (pclContour->abyOnCurve[sEnd] & ONCURVE) /* if endpoint oncurve */
        {
            fxX1 = pclContour->afxXCoord[sEnd];
            fxY1 = pclContour->afxYCoord[sEnd];
            fxX2 = *pfxXCoord;
            fxY2 = *pfxYCoord;
            byF1 = *pbyFlags;                /* 1st pt might be off */
            pfxXStop++;                             /* stops at endpoint */
        }
        else                                        /* if endpoint offcurve */
        {
            fxX1 = pclContour->afxXCoord[sEnd - 1];
            fxY1 = pclContour->afxYCoord[sEnd - 1];
            fxX2 = pclContour->afxXCoord[sEnd];
            fxY2 = pclContour->afxYCoord[sEnd];
            if ((pclContour->abyOnCurve[sEnd - 1] & ONCURVE) == 0)
            {
                fxX1 = (fxX1 + fxX2 + 1) >> 1;      /* offcurve midpoint */
                fxY1 = (fxY1 + fxY2 + 1) >> 1;
            }
            byF1 = 0;
            pfxXCoord--;                            /* pre decrement */
            pfxYCoord--;
            pbyFlags--;
        }
/*
    At this point, (x1,y1) is the last oncurve point; (x2,y2) is the next
    point (on or off); and the pointers are ready to be incremented to the
    point following (x2,y2).  
        
    Throughout this loop (x1,y1) is always an oncurve point (it may be the 
    midpoint between two offcurve points).  If (x2,y2) is oncurve, then we 
    have a line; if offcurve, we have a spline, and (x3,y3) will be the 
    next oncurve point.
*/

        sDir = 0;                                   /* starting dir unknown */
        sFlatCount = 0;
        sOrgDir = 1;                        /* default direction if everything is flat */                          

        while (pfxXCoord < pfxXStop)
        {
            if (byF1 & ONCURVE)                /* if next point oncurve */
            {
                lErrCode = fsc_CheckYReversal(prrRoots, fxY1, fxY2, &sDir, &sOrgDir, &sFlatCount);
                if (lErrCode != NO_ERR) return lErrCode;

                fxX1 = fxX2;                        /* next oncurve point */
                fxY1 = fxY2;
                        
                pfxXCoord++;
                pfxYCoord++;
                pbyFlags++;
            }
            else
            {
                pfxXCoord++;                        /* check next point */
                fxX3 = *pfxXCoord;
                pfxYCoord++;
                fxY3 = *pfxYCoord;
                pbyFlags++;
                        
                if (*pbyFlags & ONCURVE)          /* if it's on, use it */
                {
                    pfxXCoord++;
                    pfxYCoord++;
                    pbyFlags++;
                }
                else                                /* if not, calc next on */
                {
                    fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
                    fxY3 = (fxY2 + fxY3 + 1) >> 1;
                }
                lErrCode = fsc_CheckYReversalInSpline(prrRoots, &sDir, &sOrgDir, &sFlatCount,fxX1, fxY1, fxX2, fxY2, fxX3, fxY3);
                if (lErrCode != NO_ERR) return lErrCode;

                fxX1 = fxX3;                        /* next oncurve point */
                fxY1 = fxY3;
           }

            /* test to avoid reading past the end of memory on the last line */
            if (pfxXCoord != pfxXStop)
            {
                fxX2 = *pfxXCoord;                      /* next contour point */
                fxY2 = *pfxYCoord;
                byF1 = *pbyFlags;
            }
        }
                                
        while (sFlatCount > 0)                      /* if contour started flat */
        {
            if (sDir == 0)                          /* if completely flat */
            {
                sDir = 1;                           /* then pick a direction */
            }
            lErrCode = fsc_AddYReversal (prrRoots, fxY1, sDir); /* add one per point */
            if (lErrCode != NO_ERR) return lErrCode;

            sDir = -sDir;
            sFlatCount--;
        }
        if (sOrgDir != sDir)                        /* if endpoint reverses */
        {
            lErrCode = fsc_AddYReversal (prrRoots, fxY1, sDir); /* then balance up/down */
            if (lErrCode != NO_ERR) return lErrCode;
        }

/* if doing dropout control, check contour X values for direction reversals */

        if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
        {
            fxX1 = pclContour->afxXCoord[sEnd];     /* start by closing */
            pfxXCoord = &pclContour->afxXCoord[sStart];

            sPt = sStart;
            sDir = 0;                               /* starting dir unknown */
            sFlatCount = 0;
            while ((sDir == 0) && (sPt <= sEnd))
            {
                fxX2 = *pfxXCoord++;
                if (fxX2 > fxX1)                    /* find first up or down */
                {
                    sDir = 1;
                }
                else if (fxX2 < fxX1)
                {
                    sDir = -1;
                }
                else
                {
                    sFlatCount++;                   /* countour starts flat */
                }
                fxX1 = fxX2;
                sPt++;
            }
            sOrgDir = sDir;                         /* save original ep check */

            while (sPt <= sEnd)
            {
                fxX2 = *pfxXCoord++;
                if (sDir == 1)
                {
                    if (fxX2 <= fxX1)               /* = is for endpoint cases */
                    {
                        lErrCode = fsc_AddXReversal (prrRoots, fxX1, 1);
                        if (lErrCode != NO_ERR) return lErrCode;

                        sDir = -1;
                    }
                }
                else    /* if sDir == -1 */
                {
                    if (fxX2 >= fxX1)               /* = is for endpoint cases */
                    {
                        lErrCode = fsc_AddXReversal (prrRoots, fxX1, -1);
                        if (lErrCode != NO_ERR) return lErrCode;

                        sDir = 1;
                    }
                }
                fxX1 = fxX2;                        /* next segment */
                sPt++;
            }
                                    
            while (sFlatCount > 0)                  /* if contour started flat */
            {
                if (sDir == 0)                      /* if completely flat */
                {
                    sDir = 1;                       /* then pick a direction */
                    sOrgDir = 1;
                }
                lErrCode = fsc_AddXReversal (prrRoots, fxX1, sDir); /* add one per point */
                if (lErrCode != NO_ERR) return lErrCode;

                sDir = -sDir;
                sFlatCount--;
            }
            if (sOrgDir != sDir)                    /* if endpoint reverses */
            {
                lErrCode = fsc_AddXReversal (prrRoots, fxX1, sDir); /* then balance up/down */
                if (lErrCode != NO_ERR) return lErrCode;
            }

            if (usScanKind & SK_SMART)              /* if smart dropout control */
            {                                       /* estimate the elem point count */
                fxX1 = pclContour->afxXCoord[sEnd];
                fxY1 = pclContour->afxYCoord[sEnd];
                byF1 = pclContour->abyOnCurve[sEnd];
                pfxXCoord = &pclContour->afxXCoord[sStart];
                pfxYCoord = &pclContour->afxYCoord[sStart];
                pbyFlags = &pclContour->abyOnCurve[sStart];

                lElementCount += (uint32)(sEnd - sStart) + 2L;  /* 1/pt + 1/contour */

                for (sPt = sStart; sPt <= sEnd; sPt++)
                {
                    fxX2 = *pfxXCoord++;
                    fxY2 = *pfxYCoord++;
                    byF2 = *pbyFlags++;

                    if (((byF1 & byF2) & ONCURVE) == 0) /* if this is a spline */
                    {
                        if (((byF1 | byF2) & ONCURVE) == 0)
                        {
                            lElementCount++;            /* +1 for midpoint */
                        }
                                
                        if (FXABS(fxX2 - fxX1) > FXABS(fxY2 - fxY1))
                        {
                            fxAbsDelta = FXABS(fxX2 - fxX1);
                        }
                        else
                        {
                            fxAbsDelta = FXABS(fxY2 - fxY1);
                        }
                        lDivide = 0;
                        while (fxAbsDelta > (MAXSPLINELENGTH / 2))
                        {
                            lDivide++;
                            lDivide <<= 1;
                            fxAbsDelta >>= 1;
                        }
                        lElementCount += lDivide;   /* for subdivision */
                    }
                    fxX1 = fxX2;
                    fxY1 = fxY2;
                    byF1 = byF2;
                }
            }
        }
    }
    if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART))  /* if smart dropout */
    {
        lElementCount += fsc_GetReversalCount(prrRoots) << 1;  /* add in 2 * reversals */
        if (lElementCount > (0xFFFF >> SC_CODESHFT))
        {
            return SMART_DROP_OVERFLOW_ERR;
        }
    }

        
/*  set horiz workspace return values */

    lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
    lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
    
    pbmpBitMap->sRowBytes = (int16)ROWBYTESLONG(lVScanCount);
    pbmpBitMap->lMMemSize = (lHScanCount * (int32)pbmpBitMap->sRowBytes);
    
    lTotalHIx = fsc_GetHIxEstimate(prrRoots);   /* intersection count */
    pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

/*  set vertical workspace return values */
    
    if (usScanKind & SK_NODROPOUT)                  /* if no dropout */
    {
        pwsWork->lVMemSize = 0L;
        lTotalVIx = 0;
    }
    else
    {
        lTotalVIx = fsc_GetVIxEstimate(prrRoots);   /* estimate intersection count */
        pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, lTotalVIx, lElementCount);
    }
    
    pwsWork->lHInterCount = lTotalHIx;              /* save for SetupScan */
    pwsWork->lVInterCount = lTotalVIx;
    pwsWork->lElementCount = lElementCount;
    pwsWork->lRMemSize = fsc_GetRevMemSize(prrRoots);

#ifdef FSCFG_REENTRANT
    
    pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif

    return NO_ERR;
} 

/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given band into a given bitmap.  Get per intersection and      */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureBand( 
        GlyphBitMap* pbmpBitMap,        /* computed by MeasureGlyph */
        WorkScan* pwsWork,              /* to return new values */
        uint16 usBandType,              /* small or fast */
        uint16 usBandWidth,             /* scanline count */
        uint16 usScanKind )             /* dropout control value */
{
    int32 lBandWidth;                   /* max scanline count */
    int32 lTotalHIx;                    /* est of horiz intersections in band */
    int32 lVScanCount;                  /* total vertical scan lines */
    int32 lHScanCount;                  /* total horizontal scan lines */

    lBandWidth = (int32)usBandWidth;
    pbmpBitMap->lMMemSize = (lBandWidth * (int32)pbmpBitMap->sRowBytes);
    
    if (usBandType == FS_BANDINGSMALL) 
    {
        lTotalHIx = fsc_GetHIxBandEst((PRevRoot)pwsWork->pchRBuffer, &pbmpBitMap->rectBounds, lBandWidth);
        pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
        pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lBandWidth, lTotalHIx);
        pwsWork->lVMemSize = 0L;            /* force dropout control off */
    }
    else if (usBandType == FS_BANDINGFAST) 
    {
        lTotalHIx = fsc_GetHIxEstimate((PRevRoot)pwsWork->pchRBuffer);  /* intersection count */
        pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
        
        lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
        pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

        if (usScanKind & SK_NODROPOUT)      /* if no dropout */
        {
            pwsWork->lVMemSize = 0L;
        }
        else                                /* if any kind of dropout */
        {
            pbmpBitMap->lMMemSize += (int32)pbmpBitMap->sRowBytes;  /* to save below row */
            
            lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
            pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, pwsWork->lVInterCount, pwsWork->lElementCount);
            pwsWork->lVMemSize += (int32)pbmpBitMap->sRowBytes;     /* to save above row */
            ALIGN(voidPtr, pwsWork->lVMemSize ); 
        }
    }
    
#ifdef FSCFG_REENTRANT
    
    pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif
    
    return NO_ERR;
}


/*********************************************************************/

/*  Scan Conversion Routine                                          */
/*  Trace the contour, passing out lines and splines,                */
/*  then call ScanList to fill the bitmap                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillGlyph( 
        ContourList* pclContour,        /* glyph outline */
        GlyphBitMap* pgbBitMap,         /* target */
        WorkScan* pwsWork,              /* for scan array */
        uint16 usBandType,              /* old, small, fast or faster */
        uint16 usScanKind )             /* dropout control value */
{
    uint16 usCont;                      /* contour index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int32 lStateSpace;                  /* HMem used by state structure */
    int32 lErrCode;                     /* function return code */
    F26Dot6 *pfxXCoord;                 /* next x coord ptr */
    F26Dot6 *pfxYCoord;                 /* next y coord ptr */
    uint8 *pbyOnCurve;                  /* next flag ptr */
    F26Dot6 *pfxXStop;                  /* contour trace end condition */
    F26Dot6 fxX1, fxX2, fxX3;           /* x coord endpoints */
    F26Dot6 fxY1, fxY2, fxY3;           /* y coord endpoints */
    uint8 byOnCurve;                    /* point 2 flag variable */
    int32 lHiScanBand;                  /* top scan limit */ 
    int32 lLoScanBand;                  /* bottom scan limit */
    int32 lHiBitBand;                   /* top bitmap limit */
    int32 lLoBitBand;                   /* bottom bitmap limit */
    int32 lOrgLoBand;                   /* save for overscan fill check */
    F26Dot6 fxYHiBand, fxYLoBand;       /* limits in f26.6 */
    boolean bSaveRow;                   /* for dropout over scanning */
    boolean bBandCheck;                 /* eliminate out of band elements */

#ifdef FSCFG_REENTRANT
    
    StateVars *pState;                  /* reentrant State is accessed via pointer */

    pState = (StateVars*)pwsWork->pchHBuffer;  /* and lives in HMem (memoryBase[6]) */ 
    lStateSpace = sizeof(StateVars);

#else
    
    lStateSpace = 0L;                   /* no HMem needed if not reentrant */

#endif
    
    if (pgbBitMap->rectBounds.top <= pgbBitMap->rectBounds.bottom)
    {
        return NO_ERR;                              /* quick out for null glyph */
    }

    if (pgbBitMap->bZeroDimension)                  /* if no height or width */
    {
        usScanKind &= (~SK_STUBS);                  /* force no-stub dropout */
    }

    lHiBitBand = (int32)pgbBitMap->sHiBand, 
    lLoBitBand = (int32)pgbBitMap->sLoBand;
    lOrgLoBand = lLoBitBand;                        /* save for fill call */    
    
    Assert (lHiBitBand > lLoBitBand);               /* should be handled above */
    
    if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
    {
        lLoBitBand--;                               /* leave room below line */
    }
    if (lHiBitBand > pgbBitMap->rectBounds.top)
    {
        lHiBitBand = pgbBitMap->rectBounds.top;     /* clip to top */
    }
    if (lLoBitBand < pgbBitMap->rectBounds.bottom)
    {
        lLoBitBand = pgbBitMap->rectBounds.bottom;  /* clip to bottom */
    }
    if (usBandType == FS_BANDINGFAST)               /* if fast banding */
    {
        lHiScanBand = pgbBitMap->rectBounds.top;    /* render everything */
        lLoScanBand = pgbBitMap->rectBounds.bottom;
        bSaveRow = TRUE;                            /* keep last row for dropout */
    }
    else                                            /* if old or small banding */
    {
        lHiScanBand = lHiBitBand;                   /* just take the band */
        lLoScanBand = lLoBitBand;
        bSaveRow = FALSE;                           /* last row not needed */
    }
    
/*  if fast banding has already renderend elements, skip to FillBitMap */

    if (usBandType != FS_BANDINGFASTER)             /* if rendering required */
    {
        fsc_SetupMem(ASTATE                         /* init workspace */
                pwsWork->pchHBuffer + lStateSpace, 
                pwsWork->lHMemSize - lStateSpace,
                pwsWork->pchVBuffer, 
                pwsWork->lVMemSize);
        
        fsc_SetupLine(ASTATE0);             /* passes line callback to scanlist */
        fsc_SetupSpline(ASTATE0);           /* passes spline callback to scanlist */
        fsc_SetupEndPt(ASTATE0);            /* passes endpoint callback to scanlist */

/*  Eliminate out of band lines and splines, unless fast banding */

        bBandCheck = ((lHiScanBand < pgbBitMap->rectBounds.top) || (lLoScanBand > pgbBitMap->rectBounds.bottom));

        fxYHiBand = (F26Dot6)((lHiScanBand << SUBSHFT) - SUBHALF);  /* may be too wide */
        fxYLoBand = (F26Dot6)((lLoScanBand << SUBSHFT) + SUBHALF);

        lErrCode = fsc_SetupScan(ASTATE &(pgbBitMap->rectBounds), usScanKind, 
                             lHiScanBand, lLoScanBand, bSaveRow, (int32)pgbBitMap->sRowBytes,
                             pwsWork->lHInterCount, pwsWork->lVInterCount,
                             pwsWork->lElementCount, (PRevRoot)pwsWork->pchRBuffer );

        if (lErrCode != NO_ERR) return lErrCode;
        
        for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
        {
            sStart = pclContour->asStartPoint[usCont];
            sEnd = pclContour->asEndPoint[usCont];

            if (sStart == sEnd)
            {
                continue;                               /* for compatibilty */
            }
/*
    For efficiency in tracing the contour, we start by assigning (x1,y1)
    to the last oncurve point.  This is found by starting with the End
    point and backing up if necessary.  The pfxCoord pointers can then
    be used to trace the entire contour without being reset across the
    Start/End gap. 
*/
            pfxXCoord = &pclContour->afxXCoord[sStart];
            pfxYCoord = &pclContour->afxYCoord[sStart];
            pbyOnCurve = &pclContour->abyOnCurve[sStart];
            pfxXStop = &pclContour->afxXCoord[sEnd];

            if (pclContour->abyOnCurve[sEnd] & ONCURVE) /* if endpoint oncurve */
            {
                fxX1 = pclContour->afxXCoord[sEnd];
                fxY1 = pclContour->afxYCoord[sEnd];
                fxX2 = *pfxXCoord;
                fxY2 = *pfxYCoord;
                byOnCurve = *pbyOnCurve;                /* 1st pt might be off */
                pfxXStop++;                             /* stops at endpoint */
            }
            else                                        /* if endpoint offcurve */
            {
                fxX1 = pclContour->afxXCoord[sEnd - 1];
                fxY1 = pclContour->afxYCoord[sEnd - 1];
                fxX2 = pclContour->afxXCoord[sEnd];
                fxY2 = pclContour->afxYCoord[sEnd];
                if ((pclContour->abyOnCurve[sEnd - 1] & ONCURVE) == 0)
                {
                    fxX1 = (fxX1 + fxX2 + 1) >> 1;      /* offcurve midpoint */
                    fxY1 = (fxY1 + fxY2 + 1) >> 1;
                }
                byOnCurve = 0;
                pfxXCoord--;                            /* pre decrement */
                pfxYCoord--;
                pbyOnCurve--;
            }
            fsc_BeginContourEndpoint(ASTATE fxX1, fxY1);          /* 1st oncurve pt -> ep module */
            lErrCode = fsc_BeginContourScan(ASTATE usScanKind, fxX1, fxY1);  /* to scanlist module too */
            if (lErrCode != NO_ERR) return lErrCode;
/*
    At this point, (x1,y1) is the last oncurve point; (x2,y2) is the next
    point (on or off); and the pointers are ready to be incremented to the
    point following (x2,y2).  
        
    Throughout this loop (x1,y1) is always an oncurve point (it may be the 
    midpoint between two offcurve points).  If (x2,y2) is oncurve, then we 
    have a line; if offcurve, we have a spline, and (x3,y3) will be the 
    next oncurve point.
*/
            if (!bBandCheck)
            {
                while (pfxXCoord < pfxXStop)
                {
                    if (byOnCurve & ONCURVE)                /* if next point oncurve */
                    {
                        lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        fxX1 = fxX2;                        /* next oncurve point */
                        fxY1 = fxY2;
                                
                        pfxXCoord++;
                        pfxYCoord++;
                        pbyOnCurve++;
                    }
                    else
                    {
                        pfxXCoord++;                        /* check next point */
                        fxX3 = *pfxXCoord;
                        pfxYCoord++;
                        fxY3 = *pfxYCoord;
                        pbyOnCurve++;
                                
                        if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
                        {
                            pfxXCoord++;
                            pfxYCoord++;
                            pbyOnCurve++;
                        }
                        else                                /* if not, calc next on */
                        {
                            fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
                            fxY3 = (fxY2 + fxY3 + 1) >> 1;
                        }
                        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        fxX1 = fxX3;                        /* next oncurve point */
                        fxY1 = fxY3;
                    }

                    /* test to avoid reading past the end of memory on the last line */
                    if (pfxXCoord != pfxXStop)
                    {
                        fxX2 = *pfxXCoord;                      /* next contour point */
                        fxY2 = *pfxYCoord;
                        byOnCurve = *pbyOnCurve;
                    }
                }
            }
            else    /* if band checking */
            {
                while (pfxXCoord < pfxXStop)
                {
                    if (byOnCurve & ONCURVE)                /* if next point oncurve */
                    {
                        lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
                        if (lErrCode != NO_ERR) return lErrCode;

                        if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand)) ||
                              ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand))))
                        {
                            lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
                            if (lErrCode != NO_ERR) return lErrCode;
                        }

                        fxX1 = fxX2;                        /* next oncurve point */
                        fxY1 = fxY2;
                                
                        pfxXCoord++;
                        pfxYCoord++;
                        pbyOnCurve++;
                    }
                    else
                    {
                        pfxXCoord++;                        /* check next point */
                        fxX3 = *pfxXCoord;
                        pfxYCoord++;
                        fxY3 = *pfxYCoord;
                        pbyOnCurve++;
                                
                        if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
                        {
                            pfxXCoord++;
                            pfxYCoord++;
                            pbyOnCurve++;
                        }
                        else                                /* if not, calc next on */
                        {
                            fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
                            fxY3 = (fxY2 + fxY3 + 1) >> 1;
                        }

                        if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand) && (fxY3 > fxYHiBand)) ||
                              ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand) && (fxY3 < fxYLoBand))))
                        {
                            lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
                            if (lErrCode != NO_ERR) return lErrCode;
                        }
                        else    /* if entirely outside of the band */
                        {
                            lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);
                            if (lErrCode != NO_ERR) return lErrCode;
                        }

                        fxX1 = fxX3;                        /* next oncurve point */
                        fxY1 = fxY3;
                    }

                    /* test to avoid reading past the end of memory on the last line */
                    if (pfxXCoord != pfxXStop)
                    {
                        fxX2 = *pfxXCoord;                      /* next contour point */
                        fxY2 = *pfxYCoord;
                        byOnCurve = *pbyOnCurve;
                    }
                }
            }
            lErrCode = fsc_EndContourEndpoint(ASTATE usScanKind);
            if (lErrCode != NO_ERR) return lErrCode;
        }
    }
    
    lErrCode = fsc_FillBitMap(
            ASTATE 
            pgbBitMap->pchBitMap, 
            lHiBitBand, 
            lLoBitBand,
            (int32)pgbBitMap->sRowBytes, 
            lOrgLoBand,
            usScanKind
    );

    if (lErrCode != NO_ERR) return lErrCode;
    
    return NO_ERR;
}


#ifndef FSCFG_DISABLE_GRAYSCALE

/*********************************************************************/

/*  This routine scales up an outline for gray scale scan conversion */

/*********************************************************************/

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList* pclContour,        /* glyph outline */
        uint16 usOverScale              /* over scale factor */
)
{
    uint16 usCont;                      /* contour index */
    int16 sPt;                          /* point index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int16 sShift;                       /* for power of two multiply */
    F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
    
    
    switch (usOverScale)                /* look for power of two */
    {
    case 1:
        sShift = 0;
        break;
    case 2:
        sShift = 1;
        break;
    case 4:
        sShift = 2;
        break;
    case 8:
        sShift = 3;
        break;
    default:
        sShift = -1;
        break;
    }

    for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
    {
        sStart = pclContour->asStartPoint[usCont];
        sEnd = pclContour->asEndPoint[usCont];
                
        pfxXCoord = &pclContour->afxXCoord[sStart];
        pfxYCoord = &pclContour->afxYCoord[sStart];
            
        if (sShift >= 0)                    /* if power of two */
        {
            for (sPt = sStart; sPt <= sEnd; sPt++)
            {
                *pfxXCoord <<= sShift;
                pfxXCoord++;
                *pfxYCoord <<= sShift;
                pfxYCoord++;
            }
        }
        else                                /* if not a power of two */
        {
            for (sPt = sStart; sPt <= sEnd; sPt++)
            {
                *pfxXCoord *= (int32)usOverScale;
                pfxXCoord++;
                *pfxYCoord *= (int32)usOverScale;
                pfxYCoord++;
            }
        }
    }
    return NO_ERR;
}


/*********************************************************************/

/*  Gray scale bitmap calculation                                    */
/*  Count over scale pixels into gray scale byte array               */
/*  Be sure that Hi/LoBand are set correctly for both Over & Gray!   */

/*********************************************************************/

FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap* pOverGBMap,        /* over scaled source */
        GlyphBitMap* pGrayGBMap,        /* gray scale target */
        uint16 usOverScale              /* over scale factor */
)
{
    char        *pchOverRow;            /* over scaled bitmap row pointer */
    char        *pchGrayRow;            /* gray scale bitmap row pointer */

    int16       sVOffset;               /* over scaled rows to skip */
    int16       sRightPix;              /* right edge of used over pix's */
        
    int16       sGrayRow;               /* gray scale row loop counter */
    uint16      usOverRowCount;         /* over scaled row loop counter */
    int16       sTotalRowCount;         /* over scaled whole band counter */
    
    uint32      ulBytes;                /* gray scale count for clear */
    int32       lErrCode;               /* function return code */
    
    GrayScaleParam  GSP;                /* param block for CalcGrayRow */


    /* checked above */
    Assert ((usOverScale == 1) || (usOverScale == 2) || (usOverScale == 4) || (usOverScale == 8)); 

    ulBytes = (uint32)pGrayGBMap->sRowBytes * (uint32)(pGrayGBMap->sHiBand - pGrayGBMap->sLoBand);
    Assert(((ulBytes >> 2) << 2) == ulBytes); 
    fsc_ScanClearBitMap (ulBytes >> 2, (uint32*)pGrayGBMap->pchBitMap);
    
    GSP.usOverScale = usOverScale;
    GSP.pchOverLo = pOverGBMap->pchBitMap;      /* set pointer limits */
    GSP.pchOverHi = pOverGBMap->pchBitMap + pOverGBMap->lMMemSize;
    GSP.pchGrayLo = pGrayGBMap->pchBitMap;      /* set pointer limits */
    GSP.pchGrayHi = pGrayGBMap->pchBitMap + pGrayGBMap->lMMemSize;

    pchOverRow = pOverGBMap->pchBitMap;
    usOverRowCount = usOverScale;
    sTotalRowCount = pOverGBMap->sHiBand - pOverGBMap->sLoBand;
    sVOffset = pOverGBMap->sHiBand - usOverScale * pGrayGBMap->sHiBand;
    if (sVOffset < 0)                                   /* if mapped above over's bitmap */
    {
        usOverRowCount -= (uint16)(-sVOffset);          /* correct first band count */
    }
    else
    {
        pchOverRow += sVOffset * pOverGBMap->sRowBytes; /* point into bitmap */
        sTotalRowCount -= sVOffset;                     /* adjust for skipped rows */
    }
    
    sRightPix = pGrayGBMap->rectBounds.right * (int16)usOverScale - pOverGBMap->rectBounds.left;
    pchOverRow += (sRightPix - 1) >> 3;
    GSP.usFirstShift = (uint16)(7 - ((sRightPix-1) & 0x0007));

    GSP.sGrayCol = pGrayGBMap->rectBounds.right - pGrayGBMap->rectBounds.left;
    pchGrayRow = pGrayGBMap->pchBitMap + (GSP.sGrayCol - 1);

    for (sGrayRow = pGrayGBMap->sHiBand - 1; sGrayRow >= pGrayGBMap->sLoBand; sGrayRow--)
    {
        GSP.pchGray = pchGrayRow;
        while ((usOverRowCount > 0) && (sTotalRowCount > 0))
        {
            GSP.pchOver = pchOverRow;
            lErrCode = fsc_ScanCalcGrayRow( &GSP );
            if (lErrCode != NO_ERR) return lErrCode;
            
            pchOverRow += pOverGBMap->sRowBytes;
            usOverRowCount--;
            sTotalRowCount--;
        }                               
        pchGrayRow += pGrayGBMap->sRowBytes;
        usOverRowCount = usOverScale;
    }
    return NO_ERR;
}

#else                                   /* if grayscale is disabled */

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList* pclContour,        /* glyph outline */
        uint16 usOverScale              /* over scale factor */
)
{
    FS_UNUSED_PARAMETER(pclContour);
    FS_UNUSED_PARAMETER(usOverScale);
    
    return BAD_GRAY_LEVEL_ERR;
}


FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap* pOverGBMap,        /* over scaled source */
        GlyphBitMap* pGrayGBMap,        /* gray scale target */
        uint16 usOverScale              /* over scale factor */
)
{
    FS_UNUSED_PARAMETER(pOverGBMap);
    FS_UNUSED_PARAMETER(pGrayGBMap);
    FS_UNUSED_PARAMETER(usOverScale);
    
    return BAD_GRAY_LEVEL_ERR;
}

#endif

/*********************************************************************/
                                             
/*      Local Functions                                              */

/*********************************************************************/

/*********************************************************************/

/*  This routine examines a glyph contour by contour and calculates  */
/*  its bounding box.                                                */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema( 
        ContourList* pclContour,        /* glyph outline */
        GlyphBitMap* pbmpBitMap         /* to return bounds */
)
{
    uint16 usCont;                      /* contour index */
    int16 sPt;                          /* point index */
    int16 sStart, sEnd;                 /* start and end point of contours */
    int32 lMaxX, lMinX;                 /* for bounding box left, right */
    int32 lMaxY, lMinY;                 /* for bounding box top, bottom */
    
    F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
    F26Dot6 fxMaxX, fxMinX;             /* for bounding box left, right */
    F26Dot6 fxMaxY, fxMinY;             /* for bounding box top, bottom */
    boolean bFirstContour;              /* set false after min/max set */


    fxMaxX = 0L;                        /* default bounds limits */
    fxMinX = 0L;
    fxMaxY = 0L;
    fxMinY = 0L;
    bFirstContour = TRUE;               /* first time only */
    
    for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
    {
        sStart = pclContour->asStartPoint[usCont];
        sEnd = pclContour->asEndPoint[usCont];
        if (sStart == sEnd)
        {
            continue;                               /* for anchor points */
        }
        
        pfxXCoord = &pclContour->afxXCoord[sStart];
        pfxYCoord = &pclContour->afxYCoord[sStart];
                
        if (bFirstContour)            
        {
            fxMaxX = *pfxXCoord;                    /* init bounds limits */
            fxMinX = *pfxXCoord;
            fxMaxY = *pfxYCoord;
            fxMinY = *pfxYCoord;
            bFirstContour = FALSE;                  /* just once */
        }

        for (sPt = sStart; sPt <= sEnd; sPt++)      /* find the min & max */
        {
            if (*pfxXCoord > fxMaxX)
                fxMaxX = *pfxXCoord;
            if (*pfxXCoord < fxMinX)
                fxMinX = *pfxXCoord;
                    
            if (*pfxYCoord > fxMaxY)
                fxMaxY = *pfxYCoord;
            if (*pfxYCoord < fxMinY)
                fxMinY = *pfxYCoord;

            pfxXCoord++;
            pfxYCoord++;
        }
    }
    
    pbmpBitMap->fxMinX = fxMinX;                    /* save full precision bounds */
    pbmpBitMap->fxMinY = fxMinY;
    pbmpBitMap->fxMaxX = fxMaxX;                    /* save full precision bounds */
    pbmpBitMap->fxMaxY = fxMaxY;

    lMinX = (fxMinX + SUBHALF - 1) >> SUBSHFT;      /* pixel black box */
    lMinY = (fxMinY + SUBHALF - 1) >> SUBSHFT;

	lMaxX = (fxMaxX + SUBHALF) >> SUBSHFT;
    lMaxY = (fxMaxY + SUBHALF) >> SUBSHFT;
            
    if ((F26Dot6)(int16)lMinX != lMinX ||           /* check overflow */
        (F26Dot6)(int16)lMinY != lMinY ||
        (F26Dot6)(int16)lMaxX != lMaxX ||
        (F26Dot6)(int16)lMaxY != lMaxY )
    {
        return POINT_MIGRATION_ERR;
    }

    pbmpBitMap->bZeroDimension = FALSE;             /* assume some size */
    
    if (bFirstContour == FALSE)                     /* if contours present */
    {                                               /* then force a non-zero bitmap */
        if (lMinX == lMaxX)
        {
            lMaxX++;                                /* force 1 pixel wide */
            pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
        }
        if (lMinY == lMaxY)
        {
            lMaxY++;                                /* force 1 pixel high */
            pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
        }
    }
    
/*  set bitmap structure return values */

    pbmpBitMap->rectBounds.left   = (int16)lMinX;
    pbmpBitMap->rectBounds.right  = (int16)lMaxX;
    pbmpBitMap->rectBounds.bottom = (int16)lMinY;
    pbmpBitMap->rectBounds.top    = (int16)lMaxY;

    return NO_ERR;
}

/*********************************************************************/

/* This recursive routine subdivides splines that are non-monotonic or   */
/* too big into splines that fsc_CalcSpline can handle.  It also         */
/* filters out degenerate (linear) splines, passing off to fsc_CalcLine. */


FS_PRIVATE int32 EvaluateSpline( 
        PSTATE                      /* pointer to state vars */
        F26Dot6 fxX1,               /* start point x coordinate */
        F26Dot6 fxY1,               /* start point y coordinate */
        F26Dot6 fxX2,               /* control point x coordinate */
        F26Dot6 fxY2,               /* control point y coordinate */
        F26Dot6 fxX3,               /* ending x coordinate */
        F26Dot6 fxY3,               /* ending y coordinate */
        uint16 usScanKind           /* scan control type */
)
{
    F26Dot6 fxDX21, fxDX32, fxDX31;     /* delta x's */
    F26Dot6 fxDY21, fxDY32, fxDY31;     /* delta y's */
    
    F26Dot6 fxDenom;                    /* ratio denominator  */
    F26Dot6 fxX4, fxY4;                 /* first mid point */
    F26Dot6 fxX5, fxY5;                 /* mid mid point */
    F26Dot6 fxX6, fxY6;                 /* second mid point */
    F26Dot6 fxX456, fxY456;             /* for monotonic subdivision */
    F26Dot6 fxAbsDX, fxAbsDY;           /* abs of DX31, DY31 */
    
    int32 lErrCode;


    fxDX21 = fxX2 - fxX1;                       /* get all four deltas */
    fxDX32 = fxX3 - fxX2;
    fxDY21 = fxY2 - fxY1;
    fxDY32 = fxY3 - fxY2;
  
/*  If spline goes up and down, then subdivide it  */

    if (((fxDY21 > 0L) && (fxDY32 < 0L)) || ((fxDY21 < 0L) && (fxDY32 > 0L)))
    {
        fxDenom = fxDY21 - fxDY32;              /* total y span */
        fxX4 = fxX1 + LongMulDiv(fxDX21, fxDY21, fxDenom);
        fxX6 = fxX2 + LongMulDiv(fxDX32, fxDY21, fxDenom);
        fxX5 = fxX4 + LongMulDiv(fxX6 - fxX4, fxDY21, fxDenom);
        fxY456 = fxY1 + LongMulDiv(fxDY21, fxDY21, fxDenom);
        
        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY456, fxX5, fxY456, usScanKind);
        if (lErrCode != NO_ERR)  return lErrCode;

        return EvaluateSpline(ASTATE fxX5, fxY456, fxX6, fxY456, fxX3, fxY3, usScanKind);
    }
    
/*  If spline goes left and right, then subdivide it  */
    
    if (((fxDX21 > 0L) && (fxDX32 < 0L)) || ((fxDX21 < 0L) && (fxDX32 > 0L)))
    {
        fxDenom = fxDX21 - fxDX32;              /* total x span */
        fxY4 = fxY1 + LongMulDiv(fxDY21, fxDX21, fxDenom);
        fxY6 = fxY2 + LongMulDiv(fxDY32, fxDX21, fxDenom);
        fxY5 = fxY4 + LongMulDiv(fxY6 - fxY4, fxDX21, fxDenom);
        fxX456 = fxX1 + LongMulDiv(fxDX21, fxDX21, fxDenom);

        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX456, fxY4, fxX456, fxY5, usScanKind);
        if (lErrCode != NO_ERR)  return lErrCode;

        return EvaluateSpline(ASTATE fxX456, fxY5, fxX456, fxY6, fxX3, fxY3, usScanKind);
    }

/*  By now the spline must be monotonic  */

    fxDX31 = fxX3 - fxX1;                       /* check overall size */
    fxDY31 = fxY3 - fxY1;
    fxAbsDX = FXABS(fxDX31);
    fxAbsDY = FXABS(fxDY31);

/*  If spline is too big to calculate, then subdivide it  */

    if ((fxAbsDX > MAXSPLINELENGTH) || (fxAbsDY > MAXSPLINELENGTH))
    {
        fxX4 = (fxX1 + fxX2) >> 1;              /* first segment mid point */
        fxY4 = (fxY1 + fxY2) >> 1;
        fxX6 = (fxX2 + fxX3) >> 1;              /* second segment mid point */
        fxY6 = (fxY2 + fxY3) >> 1;
        fxX5 = (fxX4 + fxX6) >> 1;              /* mid segment mid point */
        fxY5 = (fxY4 + fxY6) >> 1;

        lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY4, fxX5, fxY5, usScanKind);
        if (lErrCode != NO_ERR)  return lErrCode;

        return EvaluateSpline(ASTATE fxX5, fxY5, fxX6, fxY6, fxX3, fxY3, usScanKind);
    }

/*  The spline is now montonic and small enough  */

    lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);  /* first check endpoint */
    if (lErrCode != NO_ERR)  return lErrCode;

    if (fxDX21 * fxDY32 == fxDY21 * fxDX32)     /* if spline is degenerate (linear) */
    {                                           /* treat as a line */
        return fsc_CalcLine(ASTATE fxX1, fxY1, fxX3, fxY3, usScanKind);
    }
    else        
    {
        return fsc_CalcSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
    }
}


/*********************************************************************/

/*  Return an array of coordinates for outline points */

FS_PUBLIC int32 fsc_GetCoords(
        ContourList* pclContour,        /* glyph outline */
        uint16 usPointCount,            /* point count */
        uint16* pusPointIndex,          /* point indices */
        PixCoord* ppcCoordinate         /* point coordinates */
)
{
    uint16  usMaxIndex;                 /* last defined point */
    int32  lX;                          /* integer x coord */
    int32  lY;                          /* integer y coord */

    if (pclContour->usContourCount == 0)
    {
        return BAD_POINT_INDEX_ERR;     /* can't have a point without a contour */
    }
     
    usMaxIndex = pclContour->asEndPoint[pclContour->usContourCount - 1] + 2;    /* allow 2 phantoms */

    while (usPointCount > 0)
    {
        if (*pusPointIndex > usMaxIndex)
        {
            return BAD_POINT_INDEX_ERR;     /* beyond the last contour */
        }

        lX = (pclContour->afxXCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;
        lY = (pclContour->afxYCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;

        if ( ((int32)(int16)lX != lX) || ((int32)(int16)lY != lY) )
        {
            return POINT_MIGRATION_ERR;    /* catch overflow */
        }

        ppcCoordinate->x = (int16)lX;
        ppcCoordinate->y = (int16)lY;

        pusPointIndex++;
        ppcCoordinate++;
        usPointCount--;                     /* loop through all points */
    }
    return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scglobal.h ===
/*********************************************************************

      scglobal.h -- Information shared by all scan converter modules

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       7/09/93 deanb    include fsconfig.h removed (fscdefs does it)
       4/19/93 deanb    banding limits added
       4/12/93 deanb    from old scconst.h + scstate.h

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */

/********************************************************************/

/*      Internal Constant Values                                    */

/********************************************************************/

#define HUGEINT         0x7FFF          /* impossibly large int16 value */
#define HUGEFIX         0x7FFFFFFFL     /* impossibly large fx value */

#define SUBPIX          64L             /* sub pixels per pix */
#define SUBHALF         32L             /* one half of SUBPIX */
#define SUBSHFT         6               /* log base two of SUBPIX */
    
#define ONSCANLINE(y)   ((y) & (SUBPIX - 1L)) == SUBHALF
#define SCANABOVE(y)    ((((y) + SUBHALF) & (-SUBPIX)) + SUBHALF)
#define SCANBELOW(y)    ((((y) - SUBHALF - 1L) & (-SUBPIX)) + SUBHALF)

/*      Math macros      */

#define FXABS(x)  ((x) >= 0L ? (x) : -(x))

/*      Module codes for subpix callbacks   */

#define SC_LINECODE     0
#define SC_SPLINECODE   1
#define SC_ENDPTCODE    2

#define SC_MAXCODES     3               /* number of codes above */
#define SC_CODESHFT     2               /* bits needed to store codes */
#define SC_CODEMASK     0x0003          /* to mask off codes */


/**********************************************************************

    The following structure defines all of the state variables for the 
    scan converter.  This structure is allocated statically for a non-
    reentrant implementation, or as an automatic variable to permit 
    reentrancy.  There are three sets of variables: one for the endpoint 
    module, one for scanlist, and one for memory.  Rules of the game are 
    that each module accesses ONLY its own variables for reading AND 
    writing.  It is possible for one module to read another's variables, 
    BUT IT WOULD BE WRONG.

**********************************************************************/

typedef struct statevar
{

/* endpoint state variables */

    F26Dot6 fxX0, fxY0;             /* point from call before last */
    F26Dot6 fxX1, fxY1;             /* point from previous call */
    F26Dot6 fxX2Save, fxY2Save;     /* for closing the contour */
                 
/* scanlist state variables */

    int32 lBoxLeft;                 /* bounding box xmin */
    int32 lBoxRight;                /* bounding box xmax */
    int32 lBoxTop;                  /* bounding box ymax */
    int32 lBoxBottom;               /* bounding box ymin */
    int32 lRowBytes;                /* bitmap bytes per row */
    int32 lHiScanBand;              /* banding upper scan limit */
    int32 lLoScanBand;              /* banding lower scan limit */
    int32 lHiBitBand;               /* banding upper bitmap limit */
    int32 lLoBitBand;               /* banding lower bitmap limit */
    int32 lLastRowIndex;            /* last row scan line index */
    uint32* pulLastRow;             /* for dropout banding */

    int16 **apsHOnBegin;            /* beginning of on pointers array */
    int16 **apsHOffBegin;           /* beginning of off pointers array */
    int16 **apsHOnEnd;              /* end of on pointers array */
    int16 **apsHOffEnd;             /* end of off pointers array */
    int16 **apsHOffMax;             /* max of off pointers array, to detect overflow */
    int16 **apsHorizBegin;          /* current pointer array */
    int16 **apsHorizEnd;            /* current pointer array */
    int16 **apsHorizMax;            /* current pointer array, to detect overflow */

    int16 **apsVOnBegin;            /* beginning of on pointers array */
    int16 **apsVOffBegin;           /* beginning of off pointers array */
    int16 **apsVOnEnd;              /* end of on pointers array */
    int16 **apsVOffEnd;             /* end of off pointers array */
    int16 **apsVOffMax;             /* max of off pointers array, to detect overflow */
    int16 **apsVertBegin;           /* current pointer array */
    int16 **apsVertEnd;             /* current pointer array */
    int16 **apsVertMax;             /* current pointer array, to detect overflow */
                            
#ifdef FSCFG_REENTRANT              /* needed to avoid circular PSTATE */
    int32 (*pfnAddHoriz)(struct statevar*, int32, int32);
    int32 (*pfnAddVert)(struct statevar*, int32, int32);
#else
    int32 (*pfnAddHoriz)(int32, int32);
    int32 (*pfnAddVert)(int32, int32);
#endif

    F26Dot6 (*pfnHCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
    F26Dot6 (*pfnVCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
        
    F26Dot6 *afxXPoints;            /* x element control points */
    F26Dot6 *afxYPoints;            /* y element control points */
    int32 lElementPoints;           /* estimate of element points */
    int32 lPoint;                   /* index to element control points */
    uint16 usScanTag;               /* stores point index, element code */
    int16 sIxSize;                  /* int16's per intersection */
    int16 sIxShift;                 /* log2 of size */

/* memory state variables */

    char *pchHNextAvailable;        /* horizontal memory pointer */
    char *pchVNextAvailable;        /* vertical memory pointer */
    char *pchHWorkSpaceEnd;         /* horizontal memory overflow */
    char *pchVWorkSpaceEnd;         /* vertical memory overflow */
}
StateVars;

/********************************************************************/

/*              Reentrancy parameters                               */

/********************************************************************/

#ifdef FSCFG_REENTRANT

#define PSTATE      StateVars *pState,
#define PSTATE0     StateVars *pState
#define ASTATE      pState,
#define ASTATE0     pState
#define STATE       (*pState)

#else 

#define PSTATE
#define PSTATE0     void
#define ASTATE
#define ASTATE0
#define STATE       State

extern  StateVars   State;              /* statically alloc'd in NewScan */

#endif 

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scentry.h ===
/*********************************************************************

      scentry.h -- NewScan Module Exports

      (c) Copyright 1992-95  Microsoft Corp.  All rights reserved.

       1/23/95  deanb       added fsc_GetCoords helper function
       9/07/93  deanb       F26Dot6 min/max added to gbmp structure
       8/10/93  deanb       expand interface for gray scale
       6/10/93  deanb       fsc_Initialize added
       4/21/93  deanb       banding params for MeasureGlyph
       3/29/93  deanb       reversal memory added to WorkScan
       3/19/93  deanb       size_t replaced with int32
      12/22/92  deanb       Rectangle -> Rect
      12/21/92  deanb       Interface types aligned with rasterizer
      11/30/92  deanb       WorkSpace renamed WorkScan
      11/05/92  deanb       ulPointCount removed from ContourList
      11/04/92  deanb       RemoveDups function added
      10/14/92  deanb       Exported data structures added
       8/18/92  deanb       Scan type param added 
       8/17/92  deanb       Functions renamed to ..Glyph 
       7/24/92  deanb       Polyline functions deleted 
       4/09/92  deanb       New types 
       3/30/92  deanb       WorkspaceSize renamed MeasureContour 
       3/24/92  deanb       BitMap back to WorkspaceSize 
       3/20/92  deanb       Structs moved to fscdefs.h, params trimmed 
       3/17/92  deanb       Add ulPointCount, rework fcn params 
       3/05/92  deanb       Add data structures 
       3/04/92  deanb       Size reports added 
       2/21/92  deanb       First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/********************************************************************/

/*      Exported Data Structures                                    */

/********************************************************************/

typedef struct
{
    uint16 usContourCount;          /* number of contours */
    int16 *asStartPoint;            /* contour startpoint index array */
    int16 *asEndPoint;              /* contour endpoint index array */
    F26Dot6 *afxXCoord;             /* contour x coordinate array */
    F26Dot6 *afxYCoord;             /* contour y coordinate array */
    uint8 *abyOnCurve;              /* on curve / off curve array */
    uint8 *abyFc;					/* contour flags, one byte for every contour */
}
ContourList;

typedef struct
{
    int16 sRowBytes;                /* bit map width in bytes */
    int16 sHiBand;                  /* upper banding limit */
    int16 sLoBand;                  /* lower banding limit */
    Rect rectBounds;                /* bit map border */
    boolean bZeroDimension;         /* flags zero width or height */
    F26Dot6 fxMinX;                 /* full precision x minimum */
    F26Dot6 fxMaxX;                 /* full precision x maximum */
    F26Dot6 fxMinY;                 /* full precision y minimum */
    F26Dot6 fxMaxY;                 /* full precision y maximum */
    int32 lMMemSize;                /* size of bitmap in bytes */
    char *pchBitMap;                /* pixel bit map */
}
GlyphBitMap;

typedef struct
{
    int32 lRMemSize;                /* workspace bytes for reversal lists */
    int32 lHMemSize;                /* workspace bytes needed for horiz scan */
    int32 lVMemSize;                /* additional workspace for vert scan */
    int32 lHInterCount;             /* estimate of horiz scan intersections */
    int32 lVInterCount;             /* estimate of vert scan intersections */
    int32 lElementCount;            /* estimate of element control points */
    char *pchRBuffer;               /* reversal workspace byte pointer */
    char *pchHBuffer;               /* horiz workspace byte pointer */
    char *pchVBuffer;               /* vert workspace byte pointer */
}
WorkScan;

typedef struct
{
    int16 x;                        /* x pixel value */
    int16 y;                        /* y pixel value */
}
PixCoord;

/*********************************************************************/

/*      Function Exports                                             */

/*********************************************************************

  fsc_Initialize

    This routine calls down to the bitmap module to initialize the
    bitmap masks.  It should be called once, before and scan conversion
    is done.  No harm will be done if it is called more than once.

*/

FS_PUBLIC void fsc_Initialize (
        void
);


/*********************************************************************

  fsc_RemoveDups

    This routine examines a glyph contour by contour and removes any
    duplicated points.  Two subtlties here:  1) following a call to
    this routine, the relation of End[i] + 1 = Start[i + 1] may no
    longer hold (in other words, the contours may not be tightly
    packed);  and 2) two duplicate off curve points will become a
    single ON curve point (this makes sense when you remember that
    between any two offs there must be an on).

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

  Returned Values:
    
    ContourList -   Start, X, Y, and OnCurve arrays may be modified

*/

FS_PUBLIC int32 fsc_RemoveDups( 
        ContourList*        /* glyph outline */
);

/*********************************************************************

  fsc_OverScaleOutline(&Clist, inputPtr->param.gray.usOverScale);

    This routine scales up an outline for gray scale scan conversion

  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usOverScale     Multiplier

  Returned Values:
    
    ContourList -   X and Y arrays will be multiplied by usOverScale

*/

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList*,       /* glyph outline */
        uint16              /* over scale factor */
);

/*********************************************************************

  fsc_MeasureGlyph

    This routine examines a glyph contour by contour and calculates 
    its size and the amount of workspace needed to scan convert it.

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Points to MeasureGlyph workspace used to
                                    store contour reversals.
                    lRMemSize       Size of RBuffer in bytes.  This should be
                                    2 * sizeof(Reversal) * NumberOfPoints to
                                    handle the worst case.
    
    uint16      -   usScanKind      Dropout control code

    uint16      -   usRoundXMin     Allows alignment of XMin for gray scale
                                    XMin modulo usRoundXMin will be zero

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Amount of RBuffer actually used.  This will
                                    typically be much less than the worst case.
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz scan intersections
                    lVInterCount    Estimate of vert scan intersections
                    lElementCount   Estimate of element control points

    GlyphBitMap -   sRowBytes       Bytes per row in bitmap (padded to 0 mod 4).
                    rectBounds      Worst case black bounding box.
                    lMMemSize       Size of bitmap in bytes
*/

FS_PUBLIC int32 fsc_MeasureGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap,        /* to return bounds */
		WorkScan* pwsWork,              /* to return values */
		uint16 usScanKind,              /* dropout control value */
		uint16 usRoundXMin,              /* for gray scale alignment */
		int16 sBitmapEmboldeningHorExtra,
		int16 sBitmapEmboldeningVertExtra );
    
/*********************************************************************

  fsc_MeasureBand

    This routine calculates the amount of workspace needed to scan 
    convert a glyph using banding.

  Input Values:

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    lHMemSize       Size of horizontal memory from MeasureGlyph
                    lVMemSize       Size of vertical memory from MeasureGlyph
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph
    
    uint16      -   usBandType      FS_BANDINGSMALL or FS_BANDINGFAST
    
    uint16      -   usBandWidth     Number of scan lines of maximum band

    uint16      -   usScanKind      Dropout control code

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Unchanged
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz band intersections
                    lVInterCount    Unchanged
                    lElementCount   Unchanged

    GlyphBitMap -   sRowBytes       Unchanged
                    rectBounds      Unchanged
                    lMMemSize       Size of bitmap in bytes

*/

FS_PUBLIC int32 fsc_MeasureBand( 
        GlyphBitMap*,        /* computed by MeasureGlyph */
        WorkScan*,           /* to return new values */
        uint16,              /* usBandType = small or fast */
        uint16,              /* usBandWidth = scanline count */
        uint16               /* usScanKind = dropout control value */
);


/*********************************************************************

  fsc_FillGlyph

    This routine is responsible for the actual creation of a bitmap
    from the outline.
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    pchHBuffer      Pointer to horizontal workspace memory
                    pchVBuffer      Pointer to vertical workspace memory
                    lHMemSize       Size of horizontal memory (for assertion checks)
                    lVMemSize       Size of vertical memory (for assertion checks)
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph

    GlyphBitMap -   pchBitMap       Pointer to bit map output buffer
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
  
    uint16      -   usBandType      Old, Small, or Fast banding code
    
    uint16      -   usScanKind      Dropout control code

  Returned Values:

    GlyphBitMap -   Bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_FillGlyph( 
        ContourList*,       /* glyph outline */
        GlyphBitMap*,       /* target */
        WorkScan*,          /* for scan array */
        uint16,             /* banding type */
        uint16              /* scan type */
);

/*********************************************************************

  fsc_CalcGrayMap

    This routine calculates a gray scale bitmap from an overscaled bitmap
    
  Input Values:

    GlyphBitMap1 -  pchBitMap       Pointer to over scaled bit map
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
    
    GlyphBitMap2 -  pchBitMap       Pointer to gray scale bit map output buffer
                    sRowBytes       1 byte per pixel
                    rectBounds      Same value as returned from fsc_MeasureExtrema
    
    uint16       -  usOverScale     Gray scale contour multiplier
  
  Returned Values:

    GlyphBitMap2 -  Gray scale bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap*,       /* over scaled source */
        GlyphBitMap*,       /* gray scale target */
        uint16              /* over scale factor */
);


/*********************************************************************

  fsc_GetCoords

    This routine returns an array of coordinates for outline points
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usPointCount    Number of points to look up

    uint16*     -   pusPointIndex   Array of point indices
  
  Returned Values:

    pxyCoords   -   Array of (x,y) integer (pixel) coordinates

*/

FS_PUBLIC int32 fsc_GetCoords(
        ContourList*,       /* glyph outline */
        uint16,             /* point count */
        uint16*,            /* point indices */
        PixCoord*           /* point coordinates */
);

 /*********************************************************************/

#ifdef FSCFG_SUBPIXEL

/*********************************************************************

  fsc_OverscaleToSubPixel

    This routine is the heart of the RGB striping algorithm
    
  Input Values:

    OverscaledBitmap
  
  Returned Values:

    SubPixelBitMap

*/

FS_PUBLIC void fsc_OverscaleToSubPixel (
    GlyphBitMap * OverscaledBitmap, 
	boolean bgrOrder, 
    GlyphBitMap * SubPixelBitMap
);

 /*********************************************************************/

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scspline.h ===
/*********************************************************************

	  scspline.h -- Spline Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTATE added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetSplineElemSize returns size_t 
	   9/08/92 deanb    MAXSPLINELENGTH added 
	   8/17/92 deanb    PowerOf2 moved to math 
	   7/23/92 deanb    EvaluateSpline replaced with CalcSpline + PowerOf2 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/14/92 deanb    First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupSpline ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcSpline( 
		PSTATE          /* pointer to state varables */
		F26Dot6,        /* start point x coordinate */
		F26Dot6,        /* start point y coordinate */
		F26Dot6,        /* control point x coordinate */
		F26Dot6,        /* control point y coordinate */
		F26Dot6,        /* ending x coordinate */
		F26Dot6,        /* ending y coordinate */
		uint16          /* scan control type */
);

/********************************************************************/

/*              Export Definitions                                  */

/********************************************************************/

#define MAXSPLINELENGTH     3200        /* calculation overflow limit */

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scspline.c ===
/*********************************************************************

      scspline.c -- New Scan Converter Spline Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
       3/19/93  deanb   size_t replaced with int32
      10/28/92  deanb   memory requirements reworked
      10/09/92  deanb   reentrant
       9/28/92  deanb   quick out for nearly vert/horiz splines 
       9/25/92  deanb   branch on scan kind 
       9/22/92  deanb   subpix calculation using subdivision 
       9/14/92  deanb   reflection correction with iX/YOffset 
       9/10/92  deanb   first dropout code 
       9/02/92  deanb   Precision reduction by shifting control points 
       7/24/92  deanb   Initial Q set for perfect symmetry 
       7/23/92  deanb   EvaluateSpline split out and moved to NewScan 
       7/20/92  deanb   removed unreachable case 
       7/16/92  deanb   faster power of 2 
       7/06/92  deanb   Cleanups 
       7/01/92  deanb   Reinstate a single spline routine 
       6/30/92  deanb   Implicit spline rendering 
       3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for power of 2 calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* for direct horizscan add call */
#include    "scspline.h"            /* for own function prototypes */
                
/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     QMAXSHIFT      7            /* shift limit q precision */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/
 
FS_PRIVATE F26Dot6 CalcHorizSpSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertSpSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
    
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupSpline (PSTATE0) 
{
    fsc_SetupCallBacks(ASTATE SC_SPLINECODE, CalcHorizSpSubpix, CalcVertSpSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcSpline( 
        PSTATE                  /* pointer to state variables */
        F26Dot6 fxX1,           /* start point x coordinate */
        F26Dot6 fxY1,           /* start point y coordinate */
        F26Dot6 fxX2,           /* control point x coordinate */
        F26Dot6 fxY2,           /* control point y coordinate */
        F26Dot6 fxX3,           /* ending x coordinate */
        F26Dot6 fxY3,           /* ending y coordinate */
        uint16 usScanKind )     /* dropout control type */
{
    F26Dot6 fxXInit, fxYInit;           /* initial step values */
    F26Dot6 fxXScan, fxYScan;           /* set to first crossings */
    F26Dot6 fxXX2, fxYY2;               /* translated reflected control point */
    F26Dot6 fxXX3, fxYY3;               /* translated reflected end point */
    
    F26Dot6 afxXControl[2];             /* params for BeginElement call */
    F26Dot6 afxYControl[2];

    int32 (*pfnAddHorizScan)(PSTATE int32, int32);
    int32 (*pfnAddVertScan)(PSTATE int32, int32);
    
    int32 lABits;                       /* 1+int(log2(alpha)) */
    int32 lXYBits;                      /* 1+int(log2(max(x3,y3))) */
    int32 lZBits;                       /* 6, 5, 4 log2(subpixels per pix) */
    int32 lZShift;                      /* 0, 1, 2 shift to minipixel */
    F26Dot6 fxZRound;                   /* rounding factor for minipix shift */
    F26Dot6 fxZSubpix;                  /* 64, 32, 16 subpixels per pix */
    int32 lQuadrant;                    /* 1, 2, 3, or 4 */

    F26Dot6 fxAx, fxAy;                 /* parametric 2nd order terms */
    F26Dot6 lAlpha;                     /* cross product measures curvature */

    int32 lR, lT;                       /* quadratic coefficients for xx, yy */
    int32 lS2, lU2, lV2;                /* half coefficients for xy, x, y */
    int32 lRz, lSz, lTz;                /* coeff's times subpix size */
        
    int32 lQ;                           /* cross product value */
    int32 lDQx, lDQy;                   /* first order derivative */
    int32 lDDQx, lDDQy;                 /* second order derivative */

    int32 lYScan;                       /* scan line counter */
    int32 lYStop;                       /* scan line end */
    int32 lYIncr;                       /* scan line direction */
    int32 lYOffset;                     /* reflection correction */
    int32 lXScan;                       /* horiz pix position */
    int32 lXStop;                       /* pix end */
    int32 lXIncr;                       /* pix increment direction */
    int32 lXOffset;                     /* reflection correction */

	int32 lErrCode;

    static const int32 lZShiftTable[] = { /* for precision adjustment */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /*  0 -  9  */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 10 - 19 */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 20 - 29 */
        1, 1, 1, 2, 2, 2, 3, 3          /* 30 - 34 */
    };


/* printf("(%li, %li) - (%li, %li) -(%li, %li)\n", fxX1, fxY1, fxX2, fxY2, fxX3, fxY3 ); */


/*  Translate spline point 1 to (0,0) and reflect into the first quadrant  */
    
    if (fxY3 > fxY1)                            /* if going up */
    {
        lQ = 0L;
        lQuadrant = 1;

        fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
        fxYInit = fxYScan - fxY1;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANBELOW(fxY3)) >> SUBSHFT) + 1;
        lYIncr = 1;        
        lYOffset = 0;                           /* no reflection */
        fxYY2 = fxY2 - fxY1;                    /* translate */
        fxYY3 = fxY3 - fxY1;
    }
    else                                        /* if going down */
    {
        lQ = 1L;                                /* to include pixel centers */
        lQuadrant = 4;
        
        fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
        fxYInit = fxY1 - fxYScan;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANABOVE(fxY3)) >> SUBSHFT) - 1;
        lYIncr = -1;        
        lYOffset = 1;                           /* reflection correction */
        fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
        fxYY3 = fxY1 - fxY3;
    }
    
    if (fxX3 > fxX1)                            /* if going right */
    {
        fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
        fxXInit = fxXScan - fxX1;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANBELOW(fxX3)) >> SUBSHFT) + 1;
        lXIncr = 1;        
        lXOffset = 0;                           /* no reflection */
        fxXX2 = fxX2 - fxX1;                    /* translate */
        fxXX3 = fxX3 - fxX1;
    }
    else                                        /* if going left or straight */
    {
        lQ = 1L - lQ;                           /* to include pixel centers */
        lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

        fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
        fxXInit = fxX1 - fxXScan;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANABOVE(fxX3)) >> SUBSHFT) - 1;
        lXIncr = -1;        
        lXOffset = 1;                           /* reflection correction */
        fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
        fxXX3 = fxX1 - fxX3;
    }

/*-------------------------------------------------------------------*/
    
    afxXControl[0] = fxX2;
    afxYControl[0] = fxY2;
    afxXControl[1] = fxX3;
    afxYControl[1] = fxY3;

    fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_SPLINECODE,  /* where and what */
                      2, afxXControl, afxYControl,                  /* number of pts */
                      &pfnAddHorizScan, &pfnAddVertScan );          /* what to call */

/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        if (lYScan == lYStop)                   /* and if no scan crossings */
        {
            return NO_ERR;                      /* then quick exit */
        }
        
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                lErrCode = pfnAddHorizScan(ASTATE lXScan, lYScan);

				if(lErrCode != NO_ERR) return lErrCode;

                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }
    }
        
/*-------------------------------------------------------------------*/

    else                                        /* if smart dropout control on */
    {
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                lErrCode = pfnAddHorizScan(ASTATE lXScan, lYScan);

				if(lErrCode != NO_ERR) return lErrCode;

                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }

        if (lYScan == lYStop)                   /* if nearly horizontal */
        {
            lYScan += lYOffset;
            while (lXScan != lXStop)
            {
                lErrCode = pfnAddVertScan(ASTATE lXScan, lYScan);

				if(lErrCode != NO_ERR) return lErrCode;

                lXScan += lXIncr;               /* advance x scan + or - */
            }        
            return NO_ERR;                      /* quick out */
        }
    }

/*-------------------------------------------------------------------*/

/*  Now calculate parametric term precision      */

    Assert(fxXX3 <= MAXSPLINELENGTH); // internal sanity check
    Assert(fxYY3 <= MAXSPLINELENGTH); // internal sanity check

    lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;      /* curvature term */
    
    lABits = PowerOf2(lAlpha);
    lXYBits = fxXX3 > fxYY3 ? PowerOf2((int32)fxXX3) : PowerOf2((int32)fxYY3);
    
    Assert(lXYBits <= 12);  /* max allowed spline bits */
    Assert(lABits <= 25);  

    /* spline is to big and should have been subdivided */
    if(lXYBits > 12 || lABits > 25) 
        return SPLINE_SUBDIVISION_ERR;

    lZShift = lZShiftTable[lABits + lXYBits];   /* look up precision fix */
    lZBits = SUBSHFT - lZShift;

    if (lZShift > 0)                            /* if precision fix is needed */
    {
        fxZRound = 1L << (lZShift - 1);
        
        fxXX2 = (fxXX2 + fxZRound) >> lZShift;  /* shift to 32 or 16 subpix grid */
        fxXX3 = (fxXX3 + fxZRound) >> lZShift;
        fxYY2 = (fxYY2 + fxZRound) >> lZShift;
        fxYY3 = (fxYY3 + fxZRound) >> lZShift;
        
        fxXInit = (fxXInit + fxZRound) >> lZShift;
        fxYInit = (fxYInit + fxZRound) >> lZShift;

        lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;  /* recompute curvature */
    }

    Assert (FXABS(lAlpha * fxXX3) < (1L << 29) + (3L << 24)); 
    Assert (FXABS(lAlpha * fxYY3) < (1L << 29) + (3L << 24)); 

    if(FXABS(lAlpha * fxXX3) >= (1L << 29) + (3L << 24))
        return SPLINE_SUBDIVISION_ERR;

    if(FXABS(lAlpha * fxYY3) >= (1L << 29) + (3L << 24))
        return SPLINE_SUBDIVISION_ERR;

/*  Calculate terms for Q = Rxx + Sxy + Tyy + Ux + Vy  */

    fxAx = fxXX3 - (fxXX2 << 1);
    fxAy = fxYY3 - (fxYY2 << 1);

    lR = fxAy * fxAy;
    lS2 = -fxAx * fxAy;
    lT = fxAx * fxAx;
    lU2 = fxYY2 * lAlpha;
    lV2 = -fxXX2 * lAlpha;

/*  
    Calculate starting forward difference terms:

    lQ = Q(x,y) = Rxx + Sxy + Tyy + Ux + Vy
    lDQx = Q(x+z, y) - Q(x, y) = R(2xz + zz) + Syz + Uz
    lDQy = Q(x, y+z) - Q(x, y) = T(2yz + zz) + Sxz + Vz 

*/
    fxZSubpix = 1L << lZBits;                   /* adjusted subpix per pix */

    if (lXYBits <= QMAXSHIFT)                   /* if small enough use full Q */
    {
        lQ += (lR * fxXInit + (lS2 << 1) * fxYInit + (lU2 << 1)) * fxXInit + 
              (lT * fxYInit + (lV2 << 1)) * fxYInit;
        lDQx = (lR * ((fxXInit << 1) + fxZSubpix) + (lS2 << 1) * fxYInit + (lU2 << 1)) << lZBits;
        lDQy = (lT * ((fxYInit << 1) + fxZSubpix) + (lS2 << 1) * fxXInit + (lV2 << 1)) << lZBits;
        
        lRz = lR << (lZBits << 1);              /* needed in the loop */
        lSz = (lS2 << 1) << (lZBits << 1);
        lTz = lT << (lZBits << 1);
    }
    else                                        /* if too big take out a 2 * Z */
    {
        lQ += (((lR >> 1) * fxXInit + lS2 * fxYInit + lU2) >> lZBits) * fxXInit + 
              (((lT >> 1) * fxYInit + lV2) >> lZBits) * fxYInit;
        
        lDQx = lR * (fxXInit + (fxZSubpix >> 1)) + lS2 * fxYInit + lU2;
        lDQy = lT * (fxYInit + (fxZSubpix >> 1)) + lS2 * fxXInit + lV2;
        
        lRz = lR << (lZBits - 1);               /* needed in the loop */
        lSz = lS2 << lZBits;
        lTz = lT << (lZBits - 1);
    }
    lDDQx = lRz << 1;                           /* 2nd derivative terms */
    lDDQy = lTz << 1;
                
/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        lXScan += lXOffset;                     /* pre increment */
        lXStop += lXOffset;                     /* limit too */

/*  Branch to appropriate inner loop  */

        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    lErrCode = pfnAddHorizScan(ASTATE lXScan, lYScan);

					if(lErrCode != NO_ERR) return lErrCode;

                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    lErrCode = pfnAddHorizScan(ASTATE lXScan, lYScan);

					if(lErrCode != NO_ERR) return lErrCode;

                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if past bounding box, finish up */

        while (lYScan != lYStop)
        {
            lErrCode = pfnAddHorizScan(ASTATE lXScan, lYScan);

			if(lErrCode != NO_ERR) return lErrCode;

            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }        

/*-------------------------------------------------------------------*/

    else                                        /* if dropout control on */
    {
        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    lErrCode = pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);

					if(lErrCode != NO_ERR) return lErrCode;

                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    lErrCode = pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);

					if(lErrCode != NO_ERR) return lErrCode;

                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    lErrCode = pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);

					if(lErrCode != NO_ERR) return lErrCode;

                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    lErrCode = pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);

					if(lErrCode != NO_ERR) return lErrCode;

                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if outside the bounding box, finish up */

        while (lXScan != lXStop)
        {
            lErrCode = pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);

			if(lErrCode != NO_ERR) return lErrCode;

            lXScan += lXIncr;                   /* advance x scan + or - */
        }        
        
        while (lYScan != lYStop)
        {
            lErrCode = pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);

			if(lErrCode != NO_ERR) return lErrCode;

            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }

/*-------------------------------------------------------------------*/

    return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions      */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizSpSubpix(
    int32 lYScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxYDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/

    fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
    
	/* programmer sanity check. */
    Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+2))) ||
           ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+2))));

    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);
    
    if (*pfxY < *(pfxY+2))                      /* if spline goes up */
    {
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes down */
    {
        fxX1 = *(pfxX+2);                       /* flip it upside down */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do                                          /* midpoint subdivision */
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxYMid > fxYDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide down */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxYMid < fxYDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide up */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxYMid != fxYDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */

    return fxXMid;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertSpSubpix(
    int32 lXScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxXDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/
    
    fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
    
	/* programmer sanity check. */
    Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+2))) ||
           ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+2))));
    
    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);

    if (*pfxX < *(pfxX+2))                      /* if spline goes right */
    {                                                                  
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes left */
    {                                                                  
        fxX1 = *(pfxX+2);                       /* flip it around */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxXMid > fxXDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide left */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxXMid < fxXDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide right */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxXMid != fxXDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */
    
    return fxYMid;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scmemory.c ===
/*********************************************************************

      scmemory.c -- New Scan Converter Memory Managment Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
      10/28/92  deanb   reentrant params renamed
      10/14/92  deanb   New fsc_SetupMem parameters
      10/09/92  deanb   Reentrant
      10/08/92  deanb   Separate Horiz/Vert memory pools
       9/10/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "scglobal.h"            /* structures & constants */
#include    "scmemory.h"            /* for own function prototypes */


/**********************************************************************

    Workspace memory is divided into two pools, identified here as
    HMem (horizontal memory) and VMem (vertical memory).  HMem is
    always used, and contains horizontal scan array lists.  VMem is 
    used only when dropout control is enabled, and contains the 
    vertical scan array lists and the contour elements used to compute 
    subpixel intersections for smart dropout control.  This division 
    into two pools was done, in part, for backward compatiblity with 
    the Apple rasterizer.  It allows a client to force dropout control
    off by setting the allocated size of VMem to zero.

**********************************************************************/
    
/*********************************************************************/

/*      Export Functions      */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE                           /* pointer to state variables */
        char* pchHBuffer,                /* pointer to horiz workspace */
        int32 lHMemSize,                 /* size of horiz workspace */
        char* pchVBuffer,                /* pointer to vert workspace */
        int32 lVMemSize )                /* size of vert workspace */
{
    STATE.pchHNextAvailable = pchHBuffer;
    STATE.pchHWorkSpaceEnd = pchHBuffer + lHMemSize;
    
    STATE.pchVNextAvailable = pchVBuffer;
    STATE.pchVWorkSpaceEnd = pchVBuffer + lVMemSize;
}


/********************************************************************/

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE                         /* pointer to state variables  */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;
    
/* printf("H: %ui   ", lSize); */

    pvTemp = (void*)STATE.pchHNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchHNextAvailable += lSize;
    
    Assert(STATE.pchHNextAvailable <= STATE.pchHWorkSpaceEnd); 
    if(STATE.pchHNextAvailable > STATE.pchHWorkSpaceEnd) /* return NULL of suballoc error */
        return NULL;

    return pvTemp;
}

/********************************************************************/

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE                         /* pointer to state variables */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;

/* printf("V: %ui   ", lSize); */
    
    pvTemp = (void*)STATE.pchVNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchVNextAvailable += lSize;
    
    Assert(STATE.pchVNextAvailable <= STATE.pchVWorkSpaceEnd); 
    if(STATE.pchVNextAvailable > STATE.pchVWorkSpaceEnd) /* return NULL on suballoc error */
        return NULL;

    return pvTemp;
}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\sfnt.h ===
/*
	File:       sfnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	            (c) 1989-1999 by Microsoft Corporation.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <3>    02/21/97    CB      ClaudeBe, add flags for scaled composite offset compatibility
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Remove unneeded tables from sfnt_tableIndex. [rb]
		<12>     7/18/90    MR      platform and specific should always be unsigned
		<11>     7/14/90    MR      removed duplicate definitions of int[8,16,32] etc.
		<10>     7/13/90    MR      Minor type changes, for Ansi-C
		 <9>     6/29/90    RB      revise postscriptinfo struct
		 <7>      6/4/90    MR      Remove MVT
		 <6>      6/1/90    MR      pad postscriptinfo to long word aligned
		 <5>     5/15/90    MR      Add definition of PostScript table
		 <4>      5/3/90    RB      mrr     Added tag for font program 'fpgm'
		 <3>     3/20/90    CL      chucked old change comments from EASE
		 <2>     2/27/90    CL      getting bbs headers
	   <3.1>    11/14/89    CEL     Instructions are legal in components.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
		<3+>     3/20/90    mrr     Added tag for font program 'fpgm'
*/

#pragma pack(1)

#ifndef SFNT_DEFINED
#define SFNT_DEFINED

#include "fscdefs.h" // DO NOT REMOVE
#include "sfnt_en.h"

typedef struct {
	uint32 bc;
	uint32 ad;
} BigDate;

typedef struct {
	sfnt_TableTag   tag;
	uint32          checkSum;
	uint32          offset;
	uint32          length;
} sfnt_DirectoryEntry;

/*
 *  The search fields limits numOffsets to 4096.
 */
typedef struct {
	int32 version;                  /* 0x10000 (1.0) */
	uint16 numOffsets;              /* number of tables */
	uint16 searchRange;             /* (max2 <= numOffsets)*16 */
	uint16 entrySelector;           /* log2 (max2 <= numOffsets) */
	uint16 rangeShift;              /* numOffsets*16-searchRange*/
	sfnt_DirectoryEntry table[1];   /* table[numOffsets] */
} sfnt_OffsetTable;
#define OFFSETTABLESIZE     12  /* not including any entries */

/*
 *  for the flags field
 */
#define Y_POS_SPECS_BASELINE            0x0001
#define X_POS_SPECS_LSB                 0x0002
#define HINTS_USE_POINTSIZE             0x0004
#define USE_INTEGER_SCALING             0x0008
#define INSTRUCTED_ADVANCE_WIDTH        0x0010

/* flags 5-10 defined by Apple */
#define APPLE_VERTICAL_LAYOUT           0x0020
#define APPLE_RESERVED                  0x0040
#define APPLE_LINGUISTIC_LAYOUT         0x0080
#define APPLE_GX_METAMORPHOSIS          0x0100
#define APPLE_STRONG_RIGHT_TO_LEFT      0x0200
#define APPLE_INDIC_EFFECT              0x0400

#define FONT_COMPRESSED                 0x0800
#define FONT_CONVERTED                  0x1000

#define OUTLINE_CORRECT_ORIENTATION     0x4000
#define SFNT_MAGIC 0x5F0F3CF5

#define SHORT_INDEX_TO_LOC_FORMAT       0
#define LONG_INDEX_TO_LOC_FORMAT        1
#define GLYPH_DATA_FORMAT               0

typedef struct {
	Fixed       version;            /* for this table, set to 1.0 */
	Fixed       fontRevision;       /* For Font Manufacturer */
	uint32      checkSumAdjustment;
	uint32      magicNumber;        /* signature, should always be 0x5F0F3CF5  == MAGIC */
	uint16      flags;
	uint16      unitsPerEm;         /* Specifies how many in Font Units we have per EM */

	BigDate     created;
	BigDate     modified;

	/** This is the font wide bounding box in ideal space
 (baselines and metrics are NOT worked into these numbers) **/
	FUnit       xMin;
	FUnit       yMin;
	FUnit       xMax;
	FUnit       yMax;

	uint16      macStyle;               /* macintosh style word */
	uint16      lowestRecPPEM;          /* lowest recommended pixels per Em */

	/* 0: fully mixed directional glyphs, 1: only strongly L->R or T->B glyphs, 
	   -1: only strongly R->L or B->T glyphs, 2: like 1 but also contains neutrals,
	   -2: like -1 but also contains neutrals */
	int16       fontDirectionHint;

	int16       indexToLocFormat;
	int16       glyphDataFormat;
} sfnt_FontHeader;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */

	FUnit       yAscender;
	FUnit       yDescender;
	FUnit       yLineGap;       /* Recommended linespacing = ascender - descender + linegap */
	uFUnit      advanceWidthMax;
	FUnit       minLeftSideBearing;
	FUnit       minRightSideBearing;
	FUnit       xMaxExtent; /* Max of (LSBi + (XMAXi - XMINi)), i loops through all glyphs */

	int16       horizontalCaretSlopeNumerator;
	int16       horizontalCaretSlopeDenominator;

	uint16      reserved0;
	uint16      reserved1;
	uint16      reserved2;
	uint16      reserved3;
	uint16      reserved4;

	int16       metricDataFormat;           /* set to 0 for current format */
	uint16      numberOf_LongHorMetrics;    /* if format == 0 */
} sfnt_HorizontalHeader;

typedef struct {
	uint16      advanceWidth;
	int16       leftSideBearing;
} sfnt_HorizontalMetrics;

typedef struct {
	uint16      advanceHeight;
	int16       topSideBearing;
} sfnt_VerticalMetrics;

/*
 *  CVT is just a bunch of int16s
 */
typedef int16 sfnt_ControlValue;

/*
 *  Char2Index structures, including platform IDs
 */
typedef struct {
	uint16  format;
	uint16  length;
	uint16  version;
} sfnt_mappingTable;

typedef struct {
	uint16  platformID;
	uint16  specificID;
	uint32  offset;
} sfnt_platformEntry;

typedef struct {
	uint16  version;
	uint16  numTables;
	sfnt_platformEntry platform[1]; /* platform[numTables] */
} sfnt_char2IndexDirectory;
#define SIZEOFCHAR2INDEXDIR     4

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  int16   idDelta;
  uint16  idRangeOffset;
} sfnt_subHeader2;

typedef struct {
  uint16            subHeadersKeys [256];
  sfnt_subHeader2   subHeaders [1];
} sfnt_mappingTable2;

typedef struct {
  uint16  segCountX2;
  uint16  searchRange;
  uint16  entrySelector;
  uint16  rangeShift;
  uint16  endCount[1];
} sfnt_mappingTable4;

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  uint16  glyphIdArray [1];
} sfnt_mappingTable6;

typedef struct {
	uint16 platformID;
	uint16 specificID;
	uint16 languageID;
	uint16 nameID;
	uint16 length;
	uint16 offset;
} sfnt_NameRecord;

typedef struct {
	uint16 format;
	uint16 count;
	uint16 stringOffset;
/*  sfnt_NameRecord[count]  */
} sfnt_NamingTable;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} sfnt_maxProfileTable;

typedef struct {
  int16       numberOfContours;
  BBOX        bbox;
  int16       endPoints[1];
} sfnt_PackedSplineFormat;

#define DEVEXTRA    2   /* size + max */
/*
 *  Each record is n+2 bytes, padded to long word alignment.
 *  First byte is ppem, second is maxWidth, rest are widths for each glyph
 */
typedef struct {
	int16               version;
	int16               numRecords;
	int32               recordSize;
	/* Byte widths[numGlyphs+2] * numRecords */
} sfnt_DeviceMetrics;

#ifdef UNNAMED_UNION        /* Anonymous unions are supported */
#define postScriptNameIndices   /* by some C implementations,  */
#endif              /* but they are not portable. */

typedef struct {
	Fixed   version;                /* 1.0 */
	Fixed   italicAngle;
	FUnit   underlinePosition;
	FUnit   underlineThickness;
	uint32  isFixedPitch;
	uint32  minMemType42;
	uint32  maxMemType42;
	uint32  minMemType1;
	uint32  maxMemType1;

	uint16  numberGlyphs;
	union
	{
	  uint16  glyphNameIndex[1];   /* version == 2.0 */
	  int8    glyphNameIndex25[1]; /* version == 2.5 */
	} postScriptNameIndices;
} sfnt_PostScriptInfo;

#ifdef postScriptNameIndices
#undef postScriptNameIndices
#endif 

typedef struct {
	uint16  Version;
	int16   xAvgCharWidth;
	uint16  usWeightClass;
	uint16  usWidthClass;
	int16   fsType;
	int16   ySubscriptXSize;
	int16   ySubscriptYSize;
	int16   ySubscriptXOffset;
	int16   ySubscriptYOffset;
	int16   ySuperScriptXSize;
	int16   ySuperScriptYSize;
	int16   ySuperScriptXOffset;
	int16   ySuperScriptYOffset;
	int16   yStrikeOutSize;
	int16   yStrikeOutPosition;
	int16   sFamilyClass;
	uint8   Panose [10];
	uint32  ulCharRange [4];
	char    achVendID [4];
	uint16  usSelection;
	uint16  usFirstChar;
	uint16  usLastChar;
	int16   sTypoAscender;
	 int16  sTypoDescender;
	int16   sTypoLineGap;
	int16   sWinAscent;
	int16   sWinDescent;
	uint32  ulCodePageRange[2];
} sfnt_OS2;

typedef struct
{
	uint8   bEmY;
	uint8   bEmX;
	uint8   abInc[1];
} sfnt_hdmxRecord;

typedef struct
{
	uint16          Version;
	int16           sNumRecords;
	int32           lSizeRecord;
	sfnt_hdmxRecord HdmxTable;
} sfnt_hdmx;

typedef struct
{
	uint16    Version;
	uint16    usNumGlyphs;
	uint8     ubyPelsHeight;
} sfnt_LTSH;

typedef struct
{
	uint16          rangeMaxPPEM;
	uint16          rangeGaspBehavior;
} sfnt_gaspRange;

typedef struct
{
	uint16          version;
	uint16          numRanges;
	sfnt_gaspRange  gaspRange[1];
} sfnt_gasp;

/* various typedef to access to the sfnt data */

typedef sfnt_OffsetTable          *sfnt_OffsetTablePtr;
typedef sfnt_FontHeader           *sfnt_FontHeaderPtr;
typedef sfnt_HorizontalHeader     *sfnt_HorizontalHeaderPtr;
typedef sfnt_maxProfileTable      *sfnt_maxProfileTablePtr;
typedef sfnt_ControlValue         *sfnt_ControlValuePtr;
typedef sfnt_char2IndexDirectory  *sfnt_char2IndexDirectoryPtr;
typedef sfnt_HorizontalMetrics    *sfnt_HorizontalMetricsPtr;
typedef sfnt_VerticalMetrics      *sfnt_VerticalMetricsPtr;
typedef sfnt_platformEntry        *sfnt_platformEntryPtr;
typedef sfnt_NamingTable          *sfnt_NamingTablePtr;
typedef sfnt_OS2                  *sfnt_OS2Ptr;
typedef sfnt_DirectoryEntry       *sfnt_DirectoryEntryPtr;
typedef sfnt_PostScriptInfo       *sfnt_PostScriptInfoPtr;
typedef sfnt_gasp                 *sfnt_gaspPtr;

/*
 * 'gasp' Table Constants
*/

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002


/*
 * UNPACKING Constants
*/
/*define ONCURVE                 0x01   defined in FSCDEFS.H    */
#define XSHORT              0x02
#define YSHORT              0x04
#define REPEAT_FLAGS        0x08 /* repeat flag n times */
/* IF XSHORT */
#define SHORT_X_IS_POS      0x10 /* the short vector is positive */
/* ELSE */
#define NEXT_X_IS_ZERO      0x10 /* the relative x coordinate is zero */
/* ENDIF */
/* IF YSHORT */
#define SHORT_Y_IS_POS      0x20 /* the short vector is positive */
/* ELSE */
#define NEXT_Y_IS_ZERO      0x20 /* the relative y coordinate is zero */
/* ENDIF */
/* 0x40 & 0x80              RESERVED
** Set to Zero
**
*/

/*
 * Composite glyph constants
 */
#define COMPONENTCTRCOUNT           -1      /* ctrCount == -1 for composite */
#define ARG_1_AND_2_ARE_WORDS       0x0001  /* if set args are words otherwise they are bytes */
#define ARGS_ARE_XY_VALUES          0x0002  /* if set args are xy values, otherwise they are points */
#define ROUND_XY_TO_GRID            0x0004  /* for the xy values if above is true */
#define WE_HAVE_A_SCALE             0x0008  /* Sx = Sy, otherwise scale == 1.0 */
#define NON_OVERLAPPING             0x0010  /* set to same value for all components */
#define MORE_COMPONENTS             0x0020  /* indicates at least one more glyph after this one */
#define WE_HAVE_AN_X_AND_Y_SCALE    0x0040  /* Sx, Sy */
#define WE_HAVE_A_TWO_BY_TWO        0x0080  /* t00, t01, t10, t11 */
#define WE_HAVE_INSTRUCTIONS        0x0100  /* instructions follow */
#define USE_MY_METRICS              0x0200  /* apply these metrics to parent glyph */
#define OVERLAP_COMPOUND			0x0400  /* used by Apple in GX fonts */
#define SCALED_COMPONENT_OFFSET     0x0800  /* composite designed to have the component offset scaled (designed for Apple) */
#define UNSCALED_COMPONENT_OFFSET   0x1000  /* composite designed not to have the component offset scaled (designed for MS) */

/*
 *  Private enums for tables used by the scaler.  See sfnt_Classify
 */
typedef enum {
	sfnt_fontHeader,
	sfnt_horiHeader,
	sfnt_indexToLoc,
	sfnt_maxProfile,
	sfnt_controlValue,
	sfnt_preProgram,
	sfnt_glyphData,
	sfnt_horizontalMetrics,
	sfnt_charToIndexMap,
	sfnt_fontProgram,
	sfnt_Postscript,
	sfnt_HoriDeviceMetrics,
	sfnt_LinearThreshold,
	sfnt_Names,
	sfnt_OS_2,
	sfnt_GlyphDirectory,
	sfnt_BitmapData,
	sfnt_BitmapLocation,
	sfnt_BitmapScale,
	sfnt_vertHeader,
	sfnt_verticalMetrics,
	sfnt_BeginningOfFont,       /* References the beginning of memory   */
	sfnt_NUMTABLEINDEX
} sfnt_tableIndex;

#endif
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\scline.c ===
/*********************************************************************

	  scline.c -- New Scan Converter Line Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   MultDivide replaced with LongMulDiv
	  10/28/92  deanb   mem requirement reworked
	  10/13/92  deanb   horiz / vert line rework
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/21/92  deanb   rework horiz & vert lines 
	   9/14/92  deanb   reflection correction with iX/YOffset 
	   9/10/92  deanb   first dropout code 
	   9/08/92  deanb   quickstep deleted 
	   8/18/92  deanb   include struc.h, scconst.h 
	   7/23/92  deanb   Back to x1,y1,x2,y2 input params 
	   7/17/92  deanb   Changed from longline to line 
	   6/18/92  deanb   Cross product line rendering  
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for subpix calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scline.h"              /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
	
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupLine (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_LINECODE, CalcHorizLineSubpix, CalcVertLineSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE                /* pointer to state variables */
		F26Dot6 fxX1,         /* point 1  x coordinate */
		F26Dot6 fxY1,         /* point 1  y coordinate */
		F26Dot6 fxX2,         /* point 2  x coordinate */
		F26Dot6 fxY2,         /* point 2  y coordinate */
		uint16 usScanKind     /* dropout control type */
)
{
	int32 lXScan;                           /* current x pixel index */
	int32 lXSteps;                          /* vert scanline index count */
	int32 lXIncr;                           /* x pixel increment */
	int32 lXOffset;                         /* reflection correction */
	
	int32 lYScan;                           /* current scanline index */
	int32 lYSteps;                          /* horiz scanline index count */
	int32 lYIncr;                           /* y pixel increment */
	int32 lYOffset;                         /* reflection correction */

	F26Dot6 fxXInit, fxYInit;               /* sub steps to first pixel */
	F26Dot6 fxXScan, fxYScan;               /* x,y pixel center coords */
	F26Dot6 fxXX2, fxYY2;                   /* absolute value of DX, DY */
	F26Dot6 fxXTemp, fxYTemp;               /* for horiz/vert line calc */
	
	int32 (*pfnAddHorizScan)(PSTATE int32, int32);
	int32 (*pfnAddVertScan)(PSTATE int32, int32);
	
	int32 lQuadrant;                        /* 1, 2, 3, or 4 */
	int32 lQ;                               /* cross product */
	int32 lDQy, lDQx;                       /* cross product increments */
	int32 i;                                /* loop counter */

	int32 lErrCode;

/* printf("(%li, %li) - (%li, %li)\n", fxX1, fxY1, fxX2, fxY2); */
	
/*  check y coordinates  */

	if (fxY2 >= fxY1)                           /* if going up or flat */
	{
		lQuadrant = 1;
		lQ = 0L;
		
		fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
		fxYInit = fxYScan - fxY1;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = (int32)((SCANBELOW(fxY2)) >> SUBSHFT) - lYScan + 1;
		lYIncr = 1;        
		lYOffset = 0;                           /* no reflection */
		fxYY2 = fxY2 - fxY1;                    /* translate */
	}
	else                                        /* if going down */
	{
		lQuadrant = 4;
		lQ = 1L;                                /* to include pixel centers */
		
		fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
		fxYInit = fxY1 - fxYScan;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = lYScan - (int32)((SCANABOVE(fxY2)) >> SUBSHFT) + 1;
		lYIncr = -1;        
		lYOffset = 1;                           /* reflection correction */
		fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
	}
	
	if (fxY2 == fxY1)                           /* if horizontal line */
	{
		if (usScanKind & SK_NODROPOUT)          /* if no dropout control */
		{
			return NO_ERR;                      /* if only horiz scan, done */
		}
		if (fxX2 < fxX1)                        /* if going left  */
		{
			fxYTemp = fxY1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going right */
		{
			fxYTemp = fxY1;          
		}
		lYScan = (int32)(SCANABOVE(fxYTemp) >> SUBSHFT);
		lYSteps = 0;
	}

/*  check x coordinates  */
	
	if (fxX2 >= fxX1)                           /* if going right or vertical */
	{
		fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
		fxXInit = fxXScan - fxX1;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = (int32)((SCANBELOW(fxX2)) >> SUBSHFT) - lXScan + 1;
		lXIncr = 1;        
		lXOffset = 0;                           /* no reflection */
		fxXX2 = fxX2 - fxX1;                    /* translate */
	}
	else                                        /* if going left */
	{
		lQ = 1L - lQ;                           /* reverse it */
		lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

		fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
		fxXInit = fxX1 - fxXScan;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = lXScan - (int32)((SCANABOVE(fxX2)) >> SUBSHFT) + 1;
		lXIncr = -1;        
		lXOffset = 1;                           /* reflection correction */
		fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
	}
	
	if (fxX2 == fxX1)                           /* if vertical line       */
	{
		if (fxY2 > fxY1)                        /* if going up  */
		{
			fxXTemp = fxX1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going down */
		{
			fxXTemp = fxX1;          
		}
		lXScan = (int32)(SCANABOVE(fxXTemp) >> SUBSHFT);
		lXSteps = 0;
	}

/*-------------------------------------------------------------------*/
	
	fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_LINECODE, /* where and what */
					  1, &fxX2, &fxY2,                           /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );       /* what to call */

/*-------------------------------------------------------------------*/

	if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
	{
		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				lErrCode = pfnAddHorizScan(ASTATE lXScan, lYScan);

				if(lErrCode != NO_ERR) return lErrCode;

				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		lXScan += lXOffset;

		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				lErrCode = pfnAddHorizScan(ASTATE lXScan, lYScan);
				
				if(lErrCode != NO_ERR) return lErrCode;

				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
/*-------------------------------------------------------------------*/
	
	else  /* if dropout control */
	{                                           /* handle special case lines  */
		if (fxY1 == fxY2)                       /* if horizontal line */
		{
			for (i = 0; i < lXSteps; i++)       /*   then blast a row   */
			{
				lErrCode = pfnAddVertScan(ASTATE lXScan, lYScan);

				if(lErrCode != NO_ERR) return lErrCode;

				lXScan += lXIncr;               /* advance x scan + or - */
			}
			return NO_ERR;
		}

		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				lErrCode = pfnAddHorizScan(ASTATE lXScan, lYScan);

				if(lErrCode != NO_ERR) return lErrCode;

				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				lErrCode = pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);

				if(lErrCode != NO_ERR) return lErrCode;

				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				lErrCode = pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);

				if(lErrCode != NO_ERR) return lErrCode;

				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32 lYScan, 
									   F26Dot6 *pfxX, 
									   F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
	
	/* programmer sanity check for internal consistancy. */
	Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+1))) ||
		   ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+1))));

	fxXDrop = *pfxX + LongMulDiv(*(pfxX+1) - *pfxX, fxYDrop - *pfxY, *(pfxY+1) - *pfxY);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxXDrop;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32 lXScan, 
									  F26Dot6 *pfxX, 
									  F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
	
	/* programmer sanity check for internal consistancy. */
	Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+1))) ||
		   ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+1))));

	fxYDrop = *pfxY + LongMulDiv(*(pfxY+1) - *pfxY, fxXDrop - *pfxX, *(pfxX+1) - *pfxX);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxYDrop;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\sfnt_en.h ===
/*
	File:       sfnt_en.h

	Written by: Mike Reed

	Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.

	Change History (most recent first):

		<8+>     7/16/90    MR      Fixed INTEL version of tag_GlyphData
		 <8>     7/16/90    MR      Conditionalize redefinition of script codes
		 <7>     7/13/90    MR      Conditionalize enums to allow for byte-reversal on INTEL chips
		 <6>     6/30/90    MR      Remove tag reference to 'mvt ' and 'cryp'
		 <4>     6/26/90    MR      Add all script codes, with SM naming conventions
		 <3>     6/20/90    MR      Change tag enums to #defines to be ansi-correct
		 <2>      6/1/90    MR      Add postscript name to sfnt_NameIndex and 'post' to tags.
	To Do:
*/

#ifndef SFNT_ENUMS

#define SFNT_ENUMS

typedef enum {
	plat_Unicode,
	plat_Macintosh,
	plat_ISO,
	plat_MS
} sfnt_PlatformEnum;

#ifndef __SCRIPT__
typedef enum {
	smRoman,
	smJapanese,
	smTradChinese,
	smChinese = smTradChinese,
	smKorean,
	smArabic,
	smHebrew,
	smGreek,
	smCyrillic,
	smRussian = smCyrillic,
	smRSymbol,
	smDevanagari,
	smGurmukhi,
	smGujarati,
	smOriya,
	smBengali,
	smTamil,
	smTelugu,
	smKannada,
	smMalayalam,
	smSinhalese,
	smBurmese,
	smKhmer,
	smThai,
	smLaotian,
	smGeorgian,
	smArmenian,
	smSimpChinese,
	smTibetan,
	smMongolian,
	smGeez,
	smEthiopic = smGeez,
	smAmharic = smGeez,
	smSlavic,
	smEastEurRoman = smSlavic,
	smVietnamese,
	smExtArabic,
	smSindhi = smExtArabic,
	smUninterp
} sfnt_ScriptEnum;
#endif

typedef enum {
	lang_English,
	lang_French,
	lang_German,
	lang_Italian,
	lang_Dutch,
	lang_Swedish,
	lang_Spanish,
	lang_Danish,
	lang_Portuguese,
	lang_Norwegian,
	lang_Hebrew,
	lang_Japanese,
	lang_Arabic,
	lang_Finnish,
	lang_Greek,
	lang_Icelandic,
	lang_Maltese,
	lang_Turkish,
	lang_Yugoslavian,
	lang_Chinese,
	lang_Urdu,
	lang_Hindi,
	lang_Thai
} sfnt_LanguageEnum;

typedef enum {
	name_Copyright,
	name_Family,
	name_Subfamily,
	name_UniqueName,
	name_FullName,
	name_Version,
	name_Postscript
} sfnt_NameIndex;

typedef uint32 sfnt_TableTag;

#define tag_CharToIndexMap      0x636d6170        /* 'cmap' */
#define tag_ControlValue        0x63767420        /* 'cvt ' */
#define tag_BitmapData          0x45424454        /* 'EBDT' */
#define tag_BitmapLocation      0x45424c43        /* 'EBLC' */
#define tag_BitmapScale         0x45425343        /* 'EBSC' */
#define tag_Editor0             0x65647430        /* 'edt0' */
#define tag_Editor1             0x65647431        /* 'edt1' */
#define tag_Encryption          0x63727970        /* 'cryp' */
#define tag_FontHeader          0x68656164        /* 'head' */
#define tag_FontProgram         0x6670676d        /* 'fpgm' */
#define tag_GridfitAndScanProc	0x67617370		  /* 'gasp' */
#define tag_GlyphDirectory      0x67646972        /* 'gdir' */
#define tag_GlyphData           0x676c7966        /* 'glyf' */
#define tag_HoriDeviceMetrics   0x68646d78        /* 'hdmx' */
#define tag_HoriHeader          0x68686561        /* 'hhea' */
#define tag_HorizontalMetrics   0x686d7478        /* 'hmtx' */
#define tag_IndexToLoc          0x6c6f6361        /* 'loca' */
#define tag_Kerning             0x6b65726e        /* 'kern' */
#define tag_LinearThreshold     0x4c545348        /* 'LTSH' */
#define tag_MaxProfile          0x6d617870        /* 'maxp' */
#define tag_NamingTable         0x6e616d65        /* 'name' */
#define tag_OS_2                0x4f532f32        /* 'OS/2' */
#define tag_Postscript          0x706f7374        /* 'post' */
#define tag_PreProgram          0x70726570        /* 'prep' */
#define tag_VertDeviceMetrics	0x56444d58		  /* 'VDMX' */
#define tag_VertHeader	        0x76686561		  /* 'vhea' */
#define tag_VerticalMetrics     0x766d7478		  /* 'vmtx' */

#define tag_TTO_GSUB     		0x47535542		  /* 'GSUB' */
#define tag_TTO_GPOS     		0x47504F53		  /* 'GPOS' */
#define tag_TTO_GDEF     		0x47444546		  /* 'GDEF' */
#define tag_TTO_BASE     		0x42415345		  /* 'BASE' */
#define tag_TTO_JSTF     		0x4A535446		  /* 'JSTF' */

#endif      /* not sfnt_enums */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\sfntaccs.c ===
/*
    File:       sfnt.c

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
               (c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

        <>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
        <>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
       <17+>     10/9/90    MR,rb   Remove classification of unused tables in sfnt_Classify
        <17>     8/10/90    MR      Pass nil for textLength parameter to MapString2, checked in
                                    other files to their precious little system will BUILD.  Talk
                                    about touchy!
        <16>     8/10/90    gbm     rolling out Mike's textLength change, because he hasn't checked
                                    in all the relevant files, and the build is BROKEN!
        <15>     8/10/90    MR      Add textLength arg to MapString2
        <14>     7/26/90    MR      don't include toolutil.h
        <13>     7/23/90    MR      Change computeindex routines to call functins in MapString.c
        <12>     7/18/90    MR      Add SWAPW macro for INTEL
        <11>     7/13/90    MR      Lots of Ansi-C stuff, change behavior of ComputeMapping to take
                                    platform and script
         <9>     6/27/90    MR      Changes for modified format 4: range is now times two, loose pad
                                    word between first two arrays.  Eric Mader
         <8>     6/21/90    MR      Add calls to ReleaseSfntFrag
         <7>      6/5/90    MR      remove vector mapping functions
         <6>      6/4/90    MR      Remove MVT
         <5>      5/3/90    RB      simplified decryption.
         <4>     4/10/90    CL      Fixed mapping table routines for double byte codes.
         <3>     3/20/90    CL      Joe found bug in mappingtable format 6 Added vector mapping
                                    functions use pointer-loops in sfnt_UnfoldCurve, changed z from
                                    int32 to int16
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)  New
                                    CharToIndexMap Table format.
                                    Assume subtablenumber zero for old sfnt format.  Fixed
                                    transformed component bug.
       <3.2>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
                                    phantom points are in, even for components in a composite glyph.
                                    They should also work for transformations. Device metric are
                                    passed out in the output data structure. This should also work
                                    with transformations. Another leftsidebearing along the advance
                                    width vector is also passed out. whatever the metrics are for
                                    the component at it's level. Instructions are legal in
                                    components. Instructions are legal in components. Glyph-length 0
                                    bug in sfnt.c is fixed. Now it is legal to pass in zero as the
                                    address of memory when a piece of the sfnt is requested by the
                                    scaler. If this happens the scaler will simply exit with an
                                    error code ! Fixed bug with instructions in components.
       <3.1>     9/27/89    CEL     Removed phantom points.
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
        <3+>     3/20/90    mrr     Fixed mapping table routines for double byte codes.
                                    Added support for font program.
                                    Changed count from uint16 to int16 in vector char2index routines.
*/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/

#include "fserror.h"
#include "fscdefs.h"
#include "sfntaccs.h"
#include "sfntoff.h"
/*#include "MapString.h" */

#include "stat.h"                   /* STAT timing card prototypes */

/*  CONSTANTS   */

#define MISSING_GLYPH_INDEX     0
#define MAX_FORMAT0_CHAR_INDEX  256
#define MAX_LINEAR_X2           16
static  const   transMatrix   IdentTransform =
   {{{ONEFIX,      0,      0},
     {     0, ONEFIX,      0},
     {     0,      0, ONEFIX}}};

/*  MACROS  */
#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define GETSFNTFRAG(ClientInfo,lOffset,lLength) (ClientInfo)->GetSfntFragmentPtr(ClientInfo->lClientID, lOffset, lLength)
#define RELEASESFNTFRAG(ClientInfo,data)        (ClientInfo)->ReleaseSfntFrag((voidPtr)data)

#define SFAC_BINARYITERATION \
      newP = (uint16 *) ((char *)tableP + (usSearchRange >>= 1)); \
        if (charCode > (uint16) SWAPW (*newP)) tableP = newP;

#define SFAC_GETUNSIGNEDBYTEINC( p ) ((uint8)(*p++))

/* PRIVATE PROTOTYES */

FS_PRIVATE void sfac_Classify (
     sfac_OffsetLength * TableDirectory,
     uint8 *                    dir);

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);

FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
    sfac_ClientRec *    ClientInfo,
    uint16              gIndex,
    uint32 *            ulOffset,
    uint32 *            ulLength,
    sfnt_tableIndex*  pGlyphTableIndex);

FS_PRIVATE ErrorCode    sfac_GetDataPtr (
    sfac_ClientRec *    ClientInfo,
    uint32              ulOffset,
    uint32              ulLength,
    sfnt_tableIndex     TableRef,
    boolean             bMustHaveTable,
    const void * *     ppvTablePtr);

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
    MappingFunc         pfnGlyphMapping,        /* mapping func char to glyph   */
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
    sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usCharCode,         /* First char code              */
    uint16 *            pusCharCode,        /* or Pointer to char code list */
    uint16 *            pusGlyphID);        /* Output glyph ID array        */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
    MappingFunc         pfnGlyphMapping,    /* mapping func char to glyph   */
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
    sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
    uint16              numGlyphs,          /* maxp->numGlyphs */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usCharCode,         /* First char code              */
    uint32              ulCharCodeOffset,   /* Offset to be added to *pulCharCode
                                               before converting            */
    uint32 *            pulCharCode,        /* Pointer to char code list    */
    uint32 *            pulGlyphID);         /* Output glyph ID array        */

FS_PRIVATE void sfac_ComputeBinarySearchParams(
    uint16      usSegCount,         /* INPUT */
    uint16 *    pusSearchRange,     /* OUTPUT */
    uint16 *    pusEntrySelector,   /* OUTPUT */
    uint16 *    pusRangeShift);     /* OUTPUT */

FS_PRIVATE ErrorCode sfac_ReadGlyphBbox(
    sfac_ClientRec *    ClientInfo,         /* Client Information           */
    uint16              usGlyphIndex,       /* Glyph index to read          */
    BBOX *              pbbox);             /* Glyph Bounding box           */

/*
 * Internal routine (make this an array and do a look up?)
 */
FS_PRIVATE void sfac_Classify (
     sfac_OffsetLength * TableDirectory,
     uint8 *                    dir)
{
    int32 Index;

    switch ((uint32)SWAPL(*((sfnt_TableTag *)&dir[SFNT_DIRECTORYENTRY_TAG])))
    {
        case tag_FontHeader:
            Index = (int32)sfnt_fontHeader;
            break;
        case tag_HoriHeader:
            Index = (int32)sfnt_horiHeader;
            break;
        case tag_IndexToLoc:
            Index = (int32)sfnt_indexToLoc;
            break;
        case tag_MaxProfile:
            Index = (int32)sfnt_maxProfile;
            break;
        case tag_ControlValue:
            Index = (int32)sfnt_controlValue;
            break;
        case tag_PreProgram:
            Index = (int32)sfnt_preProgram;
            break;
        case tag_GlyphData:
            Index = (int32)sfnt_glyphData;
            break;
        case tag_HorizontalMetrics:
            Index = (int32)sfnt_horizontalMetrics;
            break;
        case tag_CharToIndexMap:
            Index = (int32)sfnt_charToIndexMap;
            break;
        case tag_FontProgram:
            Index = (int32)sfnt_fontProgram;   /* <4> */
            break;
        case tag_GlyphDirectory:         /* Used for GlyphDirectory Download */
            Index = (int32)sfnt_GlyphDirectory;
            break;
        case tag_HoriDeviceMetrics:
            Index = (int32)sfnt_HoriDeviceMetrics;
            break;
        case tag_LinearThreshold:
            Index = (int32)sfnt_LinearThreshold;
            break;
        case tag_BitmapData:
            Index = (int32)sfnt_BitmapData;
            break;
        case tag_BitmapLocation:
            Index = (int32)sfnt_BitmapLocation;
            break;
        case tag_BitmapScale:
            Index = (int32)sfnt_BitmapScale;
            break;
        case tag_VertHeader:
            Index = (int32)sfnt_vertHeader;
            break;
        case tag_VerticalMetrics:
            Index = (int32)sfnt_verticalMetrics;
            break;
        case tag_OS_2:
            Index = (int32)sfnt_OS_2;
            break;
        default:
            Index = -1;
            break;
    }
    if (Index >= 0)
    {
          TableDirectory[Index].ulOffset = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLEOFFSET]));
          TableDirectory[Index].ulLength = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLELENGTH]));
    }
}


/*
 * Creates mapping for finding offset table     <4>
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
    sfac_ClientRec *  ClientInfo)    /* Sfnt Client information */

{
    int32        i;
    uint8 *      sfntDirectory;
    int32        cTables;
    uint8 *      dir;

    STAT_OFF_CALLBACK;                  /* pause STAT timer */

    sfntDirectory = (uint8 *) GETSFNTFRAG (ClientInfo, 0L, (int32)SIZEOF_SFNT_OFFSETTABLE);

    STAT_ON_CALLBACK;                /* restart STAT timer */

    if (sfntDirectory != NULL)
    {
        cTables = (int32) SWAPW (*((uint16 *)&sfntDirectory[SFNT_OFFSETTABLE_NUMOFFSETS]));
        RELEASESFNTFRAG(ClientInfo, sfntDirectory);

        STAT_OFF_CALLBACK;               /* pause STAT timer */

        sfntDirectory = (uint8 *) GETSFNTFRAG (
            ClientInfo,
            0L,
            ((int32)SIZEOF_SFNT_OFFSETTABLE + (int32)SIZEOF_SFNT_DIRECTORYENTRY * (int32)(cTables)));

        STAT_ON_CALLBACK;             /* restart STAT timer */


        if (sfntDirectory == NULL)
        {
            return(CLIENT_RETURNED_NULL);
        }
    }
    else
    {
        return(NULL_SFNT_DIR_ERR);
    }

    /* Initialize */

    MEMSET (ClientInfo->TableDirectory, 0, sizeof (ClientInfo->TableDirectory));

    dir = &sfntDirectory[SFNT_OFFSETTABLE_TABLE];

    for (i = 0; i < cTables; i++)
    {
        sfac_Classify (ClientInfo->TableDirectory, dir);
        dir += SIZEOF_SFNT_DIRECTORYENTRY;
    }

    /* Used when glyphs are accessed from the base of memory */

    ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulOffset = 0U;
    ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulLength = ~0U;

    RELEASESFNTFRAG(ClientInfo, sfntDirectory);

    return NO_ERR;
}

/*
 * Use this function when only part of the table is needed.
 *
 * n is the table number.
 * offset is within table.
 * length is length of data needed.
 * To get an entire table, pass length = ULONG_MAX     <4>
 */

FS_PRIVATE ErrorCode sfac_GetDataPtr (
    sfac_ClientRec *    ClientInfo,
    uint32              ulOffset,
    uint32              ulLength,
    sfnt_tableIndex     TableRef,
    boolean             bMustHaveTable,
    const void **       ppvTablePtr)
{
    uint32      ulTableLength;

    ulTableLength = SFAC_LENGTH(ClientInfo, TableRef);

    if (ulTableLength > 0)
    {
        if(ulLength == ULONG_MAX)
        {
            ulLength = ulTableLength;
        }

        STAT_OFF_CALLBACK;               /* pause STAT timer */

        *ppvTablePtr = (void *)GETSFNTFRAG (
            ClientInfo,
            (int32)(ulOffset + ClientInfo->TableDirectory[(int32)TableRef].ulOffset),
            (int32)ulLength);

        STAT_ON_CALLBACK;             /* restart STAT timer */

        if (*ppvTablePtr == NULL)
        {
            if (bMustHaveTable)
            {
                return CLIENT_RETURNED_NULL; /* Do a gracefull recovery   */
            }
            else
            {
                FS_WARNING("sfntaccs.c, sfac_GetDataPtr, optional table ignored due to bogus size");
            }
        }
    }
    else
    {
        *ppvTablePtr = (void *)NULL;

        if (bMustHaveTable)
        {
            return MISSING_SFNT_TABLE; /* Do a gracefull recovery  */
        }
    }

    return NO_ERR;
}


/*
 * This, is when we don't know what is going on
 */

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
    FS_UNUSED_PARAMETER(mapping);
    FS_UNUSED_PARAMETER(charCode);
    FS_UNUSED_PARAMETER(ClientInfo);
    return MISSING_GLYPH_INDEX;
}


/*
 * Byte Table Mapping 256->256          <4>
 */
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
    FS_UNUSED_PARAMETER(ClientInfo);
    if (charCode < MAX_FORMAT0_CHAR_INDEX)
    {
        return (uint16)mapping[charCode];
    }
    else
    {
        return MISSING_GLYPH_INDEX;
    }
}

/*
 * High byte mapping through table
 *
 * Useful for the national standards for Japanese, Chinese, and Korean characters.
 *
 * Dedicated in spirit and logic to Mark Davis and the International group.
 *
 *  Algorithm: (I think)
 *      First byte indexes into KeyOffset table.  If the offset is 0, keep going, else use second byte.
 *      That offset is from beginning of data into subHeader, which has 4 words per entry.
 *          entry, extent, delta, range
 *
 */

FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
    uint16          usIndex;
    uint16          usMapMe;
    uint16          usHighByte;
    uint16          usGlyph;
    const uint8 *   Table2;
    const uint8 *   subHeader;

    FS_UNUSED_PARAMETER(ClientInfo);
    Table2 = (const uint8 *) mapping;

    usHighByte = (uint16)(charCode >> 8);

    if (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte])
    {
        usMapMe = (uint16)(charCode & 0xFF); /* We also need the low byte. */
    }
    else
    {
#ifdef  FSCFG_MICROSOFT_KK
        if(usHighByte != 0)
        {
            usMapMe = usHighByte;
        }
        else
        {
                usMapMe = (uint16)(charCode & 0xFF);
        }
#else
        usMapMe = usHighByte;
#endif
    }

    subHeader = (const uint8 *) ((char *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERS] +
        (uint16)SWAPW (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte]));

    usMapMe -= (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_FIRSTCODE]));    /* Subtract first code. */

    if (usMapMe < (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_ENTRYCOUNT])))
    {  /* See if within range. */

        usGlyph = (uint16)(* ((uint16 *) ((char *) &subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET] +
            (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET]))) + usMapMe));

        if (usGlyph != 0) /* Note: usGlyph has not been swapped yet */
        {
            usIndex = (uint16)((int32)(uint32)(uint16)SWAPW(usGlyph) + (int32)SWAPW (*((int16 *)&subHeader[SFNT_SUBHEADER2_IDDELTA])));
        }
        else
        {
            usIndex = MISSING_GLYPH_INDEX;
        }
    }
    else
    {
        usIndex = MISSING_GLYPH_INDEX;
    }

    return usIndex;
}

/*
 * Segment mapping to delta values, Yack.. !
 *
 * In memory of Peter Edberg. Initial code taken from code example supplied by Peter.
 */
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
    const uint16 *  tableP;
    const uint8 *   Table4;
    uint16          usIdDelta;
    uint16          usOffset;
    uint16          usIndex;
    uint16          usSegCountX2;
    uint16          usSearchRange;
    uint16          usEntrySelector;
    uint16          usRangeShift;
    const uint16 *  newP;    /* temporary pointer for binary iteration   */
    uint16          usStartCount;

    Table4 = (const uint8 *)mapping;

    usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));
    tableP = (const uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENDCOUNT];

    /* If there are just a few segments, skip straight to the linear search */

    if (usSegCountX2 >= MAX_LINEAR_X2 && charCode > 0xFF)
    {
        /* start with unrolled binary search */

        /* tableP points at endCount[] */
        if( ClientInfo == NULL )
        {
            sfac_ComputeBinarySearchParams(
                (uint16)(usSegCountX2 / 2),
                &usSearchRange,
                &usEntrySelector,
                &usRangeShift);
        }
        else
        {
            usSearchRange = ClientInfo->usFormat4SearchRange;

            /* Assert(SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_RANGESHIFT])) == ClientInfo->usFormat4RangeShift); */
            usRangeShift = ClientInfo->usFormat4RangeShift;

            /* Assert((uint16)SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENTRYSELECTOR])) == ClientInfo->usFormat4EntrySelector); */
            usEntrySelector = ClientInfo->usFormat4EntrySelector;
        }

        if (charCode >= (uint16) SWAPW (* ((uint16 *) ((char *)tableP + usSearchRange))))
        {
            tableP = (uint16 *) ((char *)tableP + usRangeShift); /* range to low shift it up */
        }


        switch( usEntrySelector )
        {
        case 15:
            SFAC_BINARYITERATION;
            /* fall through */
        case 14:
            SFAC_BINARYITERATION;
            /* fall through */
        case 13:
            SFAC_BINARYITERATION;
            /* fall through */
        case 12:
            SFAC_BINARYITERATION;
            /* fall through */
        case 11:
            SFAC_BINARYITERATION;
            /* fall through */
        case 10:
            SFAC_BINARYITERATION;
            /* fall through */
        case 9:
            SFAC_BINARYITERATION;
            /* fall through */
        case 8:
            SFAC_BINARYITERATION;
            /* fall through */
        case 7:
            SFAC_BINARYITERATION;
            /* fall through */
        case 6:
            SFAC_BINARYITERATION;
            /* fall through */
        case 5:
            SFAC_BINARYITERATION;
            /* fall through */
        case 4:
            SFAC_BINARYITERATION;
            /* fall through */
        case 3:
        case 2:   /* drop through */
        case 1:
        case 0:
            break;
        default:
            Assert(FALSE);
            break;
        }
    }

    /*  Now do linear search */

    while(charCode > (uint16) SWAPW(*tableP))
    {
        tableP++;
    }

    tableP++;                  /*  Skip Past reservedPad word    */

    /* End of search, now do mapping */

    tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point at startCount[] */
    usStartCount = (uint16) SWAPW (*tableP);

    if (charCode >= usStartCount)
    {
          usOffset = (uint16)(charCode - (uint16) SWAPW (*tableP));
        tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idDelta[] */
        usIdDelta = (uint16) SWAPW (*tableP);
        tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idRangeOffset[] */

        if ((uint16) SWAPW (*tableP) == 0)
        {
                usIndex   = (uint16)(charCode + usIdDelta);
        }
        else
        {
            /* Use glyphIdArray to access index */

            usOffset += usOffset; /* make word offset */
            tableP   = (uint16 *) ((char *)tableP + (uint16) SWAPW (*tableP) + usOffset); /* point to glyphIndexArray[] */

            if((uint16)SWAPW (*tableP) != MISSING_GLYPH_INDEX)
            {
                     usIndex    = (uint16)((uint16) SWAPW (*tableP) + usIdDelta);
            }
            else
            {
                usIndex = MISSING_GLYPH_INDEX;
            }
        }
    }
    else
    {
        usIndex = MISSING_GLYPH_INDEX;
    }

    return usIndex;
}


/*
 * Trimmed Table Mapping
 */

FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
    const uint8 *Table6;

    FS_UNUSED_PARAMETER(ClientInfo);

    Table6 = (const uint8 *) mapping;

    charCode  -= (uint16)SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_FIRSTCODE]));

    if (charCode < (uint16) SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_ENTRYCOUNT])))
    {
        return ((uint16) SWAPW (((uint16 *)&Table6[SFNT_MAPPINGTABLE6_GLYPHIDARRAY]) [charCode]));
    }
    else
    {
        return   MISSING_GLYPH_INDEX;
    }
}


/*
 * Sets up our mapping function pointer.
 */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
    sfac_ClientRec *  ClientInfo,
    uint16            usPlatformID,
    uint16            usSpecificID)

{
    const uint8 *   table;
    const uint8 *   MappingTable;
    const uint8 *   Table4;
    boolean         bFound;
    ErrorCode       Ret;
    const uint8 *   plat;
    uint16          usSegCountX2;

    bFound = FALSE;

    /* the following code allow a client that is only interested by glyph indices to
               call fs_NewSfnt with -1 for PlatformID and SpecificID */
    if(usPlatformID == 0xFFFF)
    {
        ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
        return NO_ERR;
    }


    Ret = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, FALSE, (const void **)&table);

    if(Ret != NO_ERR)
    {
        return Ret;
    }


    if (table == NULL)
    {
        /* If no "cmap" is present, permits access to characters by glyph index */

        ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
        return NO_ERR;
    }

    /* APPLE Code
    if(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_VERSION]) != 0)
    {
        ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
        RELEASESFNTFRAG(ClientInfo, table);
        return OUT_OF_RANGE_SUBTABLE;
    }
    */

    /* mapping */

    plat = (uint8 *) &table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM]; /* <4> */

    while(plat < (uint8 *)&table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM + ((uint16)SWAPW(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_NUMTABLES])) *
          SIZEOF_SFNT_PLATFORMENTRY)] && !bFound)
    {
        if (((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_PLATFORMID])) == usPlatformID) &&
            ((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_SPECIFICID])) == usSpecificID))
        {
            bFound = TRUE;
            ClientInfo->ulMapOffset = (uint32) SWAPL (*((uint32 *)&plat[SFNT_PLATFORMENTRY_PLATFORMOFFSET]));   /* skip header */
        }
        plat += SIZEOF_SFNT_PLATFORMENTRY;
    }


    if (!bFound)
    {
        ClientInfo->ulMapOffset = 0;
        ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
        RELEASESFNTFRAG(ClientInfo, table);
        return OUT_OF_RANGE_SUBTABLE;
    }
    else
    {
        Assert(Ret == NO_ERR);
        MappingTable = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);  /* back up for header */
        ClientInfo->ulMapOffset += (uint32)SIZEOF_SFNT_MAPPINGTABLE;
    }

    ClientInfo->usMappingFormat = (uint16)SWAPW (*((uint16 *)&MappingTable[SFNT_MAPPINGTABLE_FORMAT]));

    switch (ClientInfo->usMappingFormat)
    {
    case 0:
        ClientInfo->GlyphMappingF = sfac_ComputeIndex0;
        break;
    case 2:
        ClientInfo->GlyphMappingF = sfac_ComputeIndex2;
        break;
    case 4:
        ClientInfo->GlyphMappingF = sfac_ComputeIndex4;

        /* Pre-compute several values used for Index 4 lookups */
        /* This becomes necessary because of several font vendors who */
        /* have placed incorrect values in the TrueType font file. */

        Table4 = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);
        usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));

        sfac_ComputeBinarySearchParams(
            (uint16)(usSegCountX2 / 2),
            &ClientInfo->usFormat4SearchRange,
            &ClientInfo->usFormat4EntrySelector,
            &ClientInfo->usFormat4RangeShift);

        break;
    case 6:
        ClientInfo->GlyphMappingF = sfac_ComputeIndex6;
        break;
    default:
        ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
        Ret = UNKNOWN_CMAP_FORMAT;
        break;
    }
    RELEASESFNTFRAG(ClientInfo, table);

    return Ret;
}

FS_PRIVATE void sfac_ComputeBinarySearchParams(
    uint16      usSegCount,         /* INPUT */
    uint16 *    pusSearchRange,     /* OUTPUT */
    uint16 *    pusEntrySelector,   /* OUTPUT */
    uint16 *    pusRangeShift)      /* OUTPUT */
{
    uint16          usLog;
    uint16          usPowerOf2;

    usLog = 0;
    usPowerOf2 = 1;

    while((2 * usPowerOf2) <= usSegCount )
    {
        usPowerOf2 *= 2;
        usLog++;
    }

    *pusSearchRange = 2 * usPowerOf2;
    *pusEntrySelector = usLog;
    *pusRangeShift = (2 * usSegCount) - (2 * usPowerOf2);
}

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
    sfac_ClientRec *  ClientInfo,
    uint16            usCharacterCode)
{
     const uint8 *   mappingPtr;
    ErrorCode   error;

     error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);

    if(error != NO_ERR)
    {
        return error;
    }

    ClientInfo->usGlyphIndex = ClientInfo->GlyphMappingF (mappingPtr + ClientInfo->ulMapOffset, usCharacterCode, ClientInfo);

    RELEASESFNTFRAG(ClientInfo, mappingPtr);

    return NO_ERR;
}

/*  return glyph ID's for a range or for an array of character codes */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
    sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usFirstChar,        /* First char code              */
    uint16 *            pusCharCode,        /* or Pointer to char code list */
    uint16 *            pusGlyphID)         /* Output glyph ID array        */
{
    const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
    ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

    errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
    {
        return errCode;
    }
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetGlyphIDs (
        ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
        usFirstChar,
        pusCharCode,
        pusGlyphID);

    RELEASESFNTFRAG(ClientInfo, mappingPtr);

    return errCode;
}

/*  special version for Win95 doesn't require a font context */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
    uint8 *             pbyCmapSubTable,       /* Pointer to cmap sub table    */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usFirstChar,        /* First char code              */
    uint16 *            pusCharCode,        /* or Pointer to char code list */
    uint16 *            pusGlyphID)         /* Output glyph ID array        */
{
    uint16              usMappingFormat;    /* cmap subtable format code    */
    MappingFunc         pfnGlyphMapping;    /* mapping func char to glyph   */
    const uint8 *       pbyCmapData;        /* past subtable header         */
    ErrorCode           errCode;

    usMappingFormat = (uint16)SWAPW (*((uint16 *)&pbyCmapSubTable[SFNT_MAPPINGTABLE_FORMAT]));
    switch (usMappingFormat)
    {
    case 0:
        pfnGlyphMapping = sfac_ComputeIndex0;
        break;
    case 2:
        pfnGlyphMapping = sfac_ComputeIndex2;
        break;
    case 4:
        pfnGlyphMapping = sfac_ComputeIndex4;
        break;
    case 6:
        pfnGlyphMapping = sfac_ComputeIndex6;
        break;
    default:
        return UNKNOWN_CMAP_FORMAT;
    }
    pbyCmapData = pbyCmapSubTable + SIZEOF_SFNT_MAPPINGTABLE;


    errCode = sfac_GetGlyphIDs (
        pfnGlyphMapping,
        pbyCmapData,
        NULL,                               /* ClientInfo */
        usCharCount,
        usFirstChar,
        pusCharCode,
        pusGlyphID );

    return errCode;
}

/* special helper function for NT
   - an offset usCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
    sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
    uint16              numGlyphs,          /* maxp->numGlyphs */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usFirstChar,        /* First char code              */
    uint32              ulCharCodeOffset,   /* Offset to be added to *pulCharCode
                                               before converting            */
    uint32 *            pulCharCode,        /* Pointer to char code list    */
    uint32 *            pulGlyphID)        /* Output glyph ID array        */
{
    const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
    ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

    errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
    {
        return errCode;
    }
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetLongGlyphIDs (
        ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        numGlyphs,
        usCharCount,
        usFirstChar,
        ulCharCodeOffset,
        pulCharCode,
        pulGlyphID);

    RELEASESFNTFRAG(ClientInfo, mappingPtr);

    return errCode;
}

/*      common code for the two get glyph ID helper routines */

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
    MappingFunc         pfnGlyphMapping,    /* mapping func char to glyph   */
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
    sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usCharCode,         /* First char code              */
    uint16 *            pusCharCode,        /* or Pointer to char code list */
    uint16 *            pusGlyphID)         /* Output glyph ID array        */
{
    if (pusCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
            *pusGlyphID = pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pusGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
            if (*pusCharCode == 0xFFFF)     /* trap illegal char code */
            {
                return INVALID_CHARCODE_ERR;
            }
            *pusGlyphID = pfnGlyphMapping (mapOffsetPtr, *pusCharCode, ClientInfo);
            pusGlyphID++;
            pusCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
    return NO_ERR;
}

/*      special for NT */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
    MappingFunc         pfnGlyphMapping,    /* mapping func char to glyph   */
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
    sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
    uint16              numGlyphs,          /* maxp->numGlyphs */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usCharCode,         /* First char code              */
    uint32              ulCharCodeOffset,   /* Offset to be added to *pulCharCode
                                               before converting            */
    uint32 *            pulCharCode,        /* Pointer to char code list    */
    uint32 *            pulGlyphID)         /* Output glyph ID array        */
{
    if (pulCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
            *pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);

            if (*pulGlyphID >= numGlyphs)
            {
                *pulGlyphID = 0; /* in case a character is mapped to glyph ID our of range, map it to the missing glyph */
            }
            pulGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
            if ((*pulCharCode + ulCharCodeOffset) > 0x0000FFFFL)
            {
                return INVALID_CHARCODE_ERR;   /* trap an illegal range */
            }
            usCharCode = (uint16) (*pulCharCode + ulCharCodeOffset);
            *pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            if (*pulGlyphID >= numGlyphs)
            {
                *pulGlyphID = 0; /* in case a character is mapped to glyph ID our of range, map it to the missing glyph */
            }
            pulGlyphID++;
            pulCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
    return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
    sfac_ClientRec *        ClientInfo,
    uint16 *                pusEmResolution,
    boolean *               pbIntegerScaling,
    LocalMaxProfile *       pMaxProfile)
{
    ErrorCode       error;
    const uint8 *   fontHead;
    const uint8 *   horiHead;
    const uint8 *   pTempMaxProfile;
    const uint8 *   pTempOS_2;

    error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontHeader, TRUE, (const void **)&fontHead);

    if(error != NO_ERR)
    {
        return error;
    }

    error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horiHeader, TRUE, (const void **)&horiHead);

    if(error != NO_ERR)
    {
        return error;
    }

    if ((uint32)SWAPL (*((uint32 *)&fontHead[SFNT_FONTHEADER_MAGICNUMBER])) != SFNT_MAGIC)
    {
        return BAD_MAGIC_ERR;
    }

    *pusEmResolution     = (uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_UNITSPEREM]));
    if(*pusEmResolution < 16 || *pusEmResolution > 16384)
        return BAD_UNITSPEREM_ERR;
        
    *pbIntegerScaling    = (((uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_FLAGS]))& USE_INTEGER_SCALING) ==
                                     USE_INTEGER_SCALING);

    ClientInfo->usNumberOf_LongHorMetrics = (uint16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS]));
    if(ClientInfo->usNumberOf_LongHorMetrics == 0)
        return BAD_NUMLONGHORMETRICS_ERR;

    ClientInfo->sIndexToLocFormat       = SWAPW (*((int16 *)&fontHead[SFNT_FONTHEADER_INDEXTOLOCFORMAT]));

    error = sfac_GetDataPtr (ClientInfo, 0L, SIZEOF_SFNT_OS2, sfnt_OS_2, FALSE, (const void **)&pTempOS_2); /* not a mandatory table */

    if(error != NO_ERR)
    {
        return error;
    }

    if(pTempOS_2 != NULL)
    {
        /* get TypoAscender and TypoDescender from the OS/2 table */
        ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPOASCENDER]));
        ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPODESCENDER]));
        RELEASESFNTFRAG(ClientInfo, pTempOS_2);
    } else {
        /* if OS/2 is not there get the values from horizontal header */
        ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YASCENDER]));
        ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));
    }
    ClientInfo->sWinDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));

    RELEASESFNTFRAG(ClientInfo, horiHead);
    RELEASESFNTFRAG(ClientInfo, fontHead);

    error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_maxProfile, TRUE, (const void **)&pTempMaxProfile);

    if(error != NO_ERR)
    {
        return error;
    }

    pMaxProfile->version =              (Fixed)SWAPL(*((Fixed *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_VERSION]));
    pMaxProfile->numGlyphs =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_NUMGLYPHS]));
    pMaxProfile->maxPoints =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXPOINTS]));
    pMaxProfile->maxContours =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCONTOURS]));
    pMaxProfile->maxCompositePoints =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS]));
    pMaxProfile->maxCompositeContours = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS]));
    pMaxProfile->maxElements =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXELEMENTS]));
    pMaxProfile->maxTwilightPoints =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS]));
    pMaxProfile->maxStorage =           (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTORAGE]));
    pMaxProfile->maxFunctionDefs =      (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS]));
    pMaxProfile->maxInstructionDefs =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS]));
    pMaxProfile->maxStackElements =     (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS]));
    pMaxProfile->maxSizeOfInstructions =(uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS]));
    pMaxProfile->maxComponentElements = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS]));
    pMaxProfile->maxComponentDepth =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH]));

    RELEASESFNTFRAG(ClientInfo, pTempMaxProfile);

	if ((MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints) > (USHRT_MAX - PHANTOMCOUNT - 1)))
		return BAD_MAXP_DATA;

	error = sfac_ReadNumLongVertMetrics(ClientInfo, &ClientInfo->usNumLongVertMetrics,&ClientInfo->bValidNumLongVertMetrics);

    return error;
}



/*
 *
 */

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
    sfac_ClientRec *    ClientInfo,
    uint16              glyphIndex,
    uint16 *            pusNonScaledAW,
    int16 *             psNonScaledLSB)
{
    const uint8 *   horizMetricPtr;
    uint16          numberOf_LongHorMetrics;
    ErrorCode       error;
    int16 *         lsb;

    numberOf_LongHorMetrics = ClientInfo->usNumberOf_LongHorMetrics;
    error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horizontalMetrics, TRUE, (const void **)&horizMetricPtr);

    if(error != NO_ERR)
    {
        return error;
    }

    if (glyphIndex < numberOf_LongHorMetrics)
    {
        *pusNonScaledAW     = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
        *psNonScaledLSB     = SWAPW (*((int16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING]));
    }
    else
    {
        lsb = (int16 *) (char *)& horizMetricPtr[numberOf_LongHorMetrics * SIZEOF_SFNT_HORIZONTALMETRICS]; /* first entry after[AW,LSB] array */

        *pusNonScaledAW       = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[((numberOf_LongHorMetrics-1) * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
        *psNonScaledLSB      = SWAPW (lsb[glyphIndex - numberOf_LongHorMetrics]);
    }

    RELEASESFNTFRAG(ClientInfo, horizMetricPtr);

    return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
    sfac_ClientRec *    ClientInfo,
    uint16              glyphIndex,
    uint16 *            pusNonScaledAH,
    int16 *             psNonScaledTSB)
{
    const uint8 *   vertMetricPtr;
    uint16          usNumLongVertMetrics;       /* number of entries with AH */
    ErrorCode       error;
    int16 *         psTSB;
    BBOX            bbox;           
    uint32          ulLength;


    usNumLongVertMetrics = ClientInfo->usNumLongVertMetrics;

    if (glyphIndex < usNumLongVertMetrics)
    {
        ulLength = (glyphIndex + 1) * SIZEOF_SFNT_VERTICALMETRICS;
    }
    else
    {
        ulLength = usNumLongVertMetrics * SIZEOF_SFNT_VERTICALMETRICS + (glyphIndex-usNumLongVertMetrics+1) * sizeof(int16);
    }

    if(ClientInfo->bValidNumLongVertMetrics)
    {

        error = sfac_GetDataPtr (ClientInfo, 0L, ulLength, sfnt_verticalMetrics, FALSE, (const void **)&vertMetricPtr);  /* not a mandatory table */

        if(error != NO_ERR)
        {
            return error;
        }
    }

    if (ClientInfo->bValidNumLongVertMetrics && (vertMetricPtr != NULL) )
    {
        if (glyphIndex < usNumLongVertMetrics)
        {
            *pusNonScaledAH     = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
            *psNonScaledTSB     = SWAPW (*((int16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_TOPSIDEBEARING]));
        }
        else
        {
            psTSB = (int16 *) (char *)& vertMetricPtr[usNumLongVertMetrics * SIZEOF_SFNT_VERTICALMETRICS]; /* first entry after[AW,TSB] array */

            *pusNonScaledAH       = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[((usNumLongVertMetrics-1) * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
            *psNonScaledTSB      = SWAPW (psTSB[glyphIndex - usNumLongVertMetrics]);
        }

        RELEASESFNTFRAG(ClientInfo, vertMetricPtr);
    } else {

        /* We don't have vertical metrics, let's set to default values */

        /* to get the glyph bbox for the defalut value of the vertical metrics */
        error = sfac_ReadGlyphBbox(ClientInfo,ClientInfo->usGlyphIndex, &bbox);

        if(error != NO_ERR)
        {
            return error;
        }       

        /* default if no vertical metrics found */
        *pusNonScaledAH = ClientInfo->sDefaultAscender - ClientInfo->sDefaultDescender;   
        *psNonScaledTSB = ClientInfo->sDefaultAscender - bbox.yMax;
    }

    return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
    sfac_ClientRec *    ClientInfo,
    uint16              glyphIndex,
    uint16 *            pusNonScaledAW,
    uint16 *            pusNonScaledAH,
    int16 *             psNonScaledLSB,
    int16 *             psNonScaledTSB)
{
    ErrorCode       error;

    error = sfac_ReadGlyphHorMetrics (ClientInfo, glyphIndex, pusNonScaledAW, psNonScaledLSB);

    if(error != NO_ERR)
    {
        return error;
    }

    error = sfac_ReadGlyphVertMetrics (ClientInfo, glyphIndex, pusNonScaledAH, psNonScaledTSB);
    return error;
}

/*
 *  Read Number of Long Vertical Metrics from vhea table
 */

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics(
    sfac_ClientRec *        ClientInfo,
    uint16 *                pusNumLongVertMetrics,
    boolean *               pbValidNumLongVertMetrics )
{
    ErrorCode       error;
    const uint8 *   vertHead;

    *pbValidNumLongVertMetrics = FALSE;
    error = sfac_GetDataPtr (ClientInfo, 0L, SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS + sizeof(uint16), sfnt_vertHeader, FALSE, (const void **)&vertHead);

    if(error != NO_ERR)
    {
        return error;
    }       
    
    if(vertHead != NULL)
    {
        *pusNumLongVertMetrics = (uint16)SWAPW (*((uint16 *)&vertHead[SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS]));
        *pbValidNumLongVertMetrics = TRUE;

        RELEASESFNTFRAG(ClientInfo, vertHead);
    }

    return NO_ERR;
}


FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
    sfac_ClientRec *    ClientInfo,
    uint16              gIndex,
    uint32 *            ulOffset,
    uint32 *            ulLength,
    sfnt_tableIndex*    pGlyphTableIndex)

{
    const void *    indexPtr;
    ErrorCode       error;
    uint16 *        shortIndexToLoc;
    uint32 *        longIndexToLoc;
    uint32 *        offsetPtr;
    uint16 *        lengthPtr;
    uint32          ulGlyphDirectoryLength = (((uint32)gIndex + 1) * (uint32)(sizeof(int32)+sizeof(uint16)));
    uint32          ulLengthLoca;
    uint32          ulOffset2;

    error = sfac_GetDataPtr (ClientInfo, 0L, ulGlyphDirectoryLength, sfnt_GlyphDirectory, FALSE, (const void **)&indexPtr);

    if(error != NO_ERR)
    {
        return error;
    }

    /* If there is a glyph directory, first check for the glyph there.  */

    if (indexPtr != NULL)
    {
        offsetPtr = (uint32 *)((char *)indexPtr+((int32)gIndex*(int32)(sizeof(int32)+sizeof(uint16))));
        lengthPtr = (uint16 *)(char *)(offsetPtr+1);

        *ulOffset = (uint32)SWAPL(*offsetPtr);

        if(*ulOffset == 0L)
        {
            *ulLength =  0L;
        }
        else
        {
            *ulLength =  (uint32) (uint16)SWAPW(*lengthPtr);
        }

        /* sfnt_BeginningOfFont references the beginning of memory  */

        *pGlyphTableIndex = sfnt_BeginningOfFont;

        RELEASESFNTFRAG(ClientInfo, indexPtr);
        return NO_ERR;
    }

    if (ClientInfo->sIndexToLocFormat == SHORT_INDEX_TO_LOC_FORMAT)
    {
        ulLengthLoca = (gIndex + 2) * sizeof(uint16);
    }
    else
    {
        ulLengthLoca = (gIndex + 2) * sizeof(uint32);
    }

    error = sfac_GetDataPtr (ClientInfo, 0L, ulLengthLoca, sfnt_indexToLoc, TRUE, (const void **)&indexPtr);
    if(error != NO_ERR)
    {
        return error;
    }

    if (ClientInfo->sIndexToLocFormat == SHORT_INDEX_TO_LOC_FORMAT)
    {
        shortIndexToLoc = (uint16 *)indexPtr + gIndex;
        *ulOffset = (uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1;
        shortIndexToLoc++;
        ulOffset2 = (uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1;
    }
    else
    {
        longIndexToLoc = (uint32 *)indexPtr + gIndex;
        *ulOffset = (uint32) SWAPL (*longIndexToLoc);
        longIndexToLoc++;
        ulOffset2 = (uint32) SWAPL (*longIndexToLoc);
    }

    if (*ulOffset > ulOffset2)
        return LOCA_NOT_ASCENDING;

    *ulLength =  ulOffset2 - *ulOffset;

    *pGlyphTableIndex = sfnt_glyphData;

    RELEASESFNTFRAG(ClientInfo, indexPtr);

    return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
    sfac_ClientRec *    ClientInfo,    /* Client Information         */
    char *              pFontProgram,  /* pointer to Font Program    */
    char *              pPreProgram)   /* pointer to Pre Program     */
{
    uint32              ulLength;
    const char *        pFragment;
    ErrorCode           error;

    error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontProgram, FALSE, (const void **)&pFragment);
    if(error)
    {
        return error;
    }
    ulLength = SFAC_LENGTH (ClientInfo, sfnt_fontProgram);
    if (ulLength)
    {
        MEMCPY (pFontProgram, pFragment, ulLength);
        RELEASESFNTFRAG(ClientInfo, pFragment);
    }

    error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_preProgram, FALSE, (const void **)&pFragment);
    if(error)
    {
        return error;
    }
    ulLength = SFAC_LENGTH (ClientInfo, sfnt_preProgram);
    if (ulLength)
    {
        MEMCPY (pPreProgram, pFragment, ulLength);
        RELEASESFNTFRAG(ClientInfo, pFragment);
    }

    return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyCVT(
    sfac_ClientRec *    ClientInfo,    /* Client Information   */
    F26Dot6 *           pCVT)       /* pointer to CVT    */
{
    uint32              ulLength;
    const int16 *       pFragment;
    int32               lNumCVT;
    int32               lCVTCount;
    const int16 *       psSrcCVT;
    F26Dot6 *           pfxDstCVT;
    ErrorCode           error;

    error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_controlValue, FALSE, (const void **)&pFragment);

    if(error)
    {
        return error;
    }

    ulLength = SFAC_LENGTH (ClientInfo, sfnt_controlValue);

    if (ulLength)
    {
        psSrcCVT = pFragment;
        pfxDstCVT = pCVT;

        lNumCVT = ((int32)ulLength / (int32)sizeof( sfnt_ControlValue));

        for(lCVTCount = 0L; lCVTCount < lNumCVT; lCVTCount++)
        {
            pfxDstCVT[lCVTCount] = (F26Dot6)SWAPW(psSrcCVT[lCVTCount]);
        }

        RELEASESFNTFRAG(ClientInfo, pFragment);
    }

    return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
    sfac_ClientRec *    ClientInfo,     /* Client Information   */
    uint16              usPixelsPerEm,  /* Current Pixels per Em    */
    boolean *           pbFound,        /* Flag indicating if entry found */
    uint16              usFirstGlyph,   /* First Glyph to copy */
    uint16              usLastGlyph,    /* Last Glyph to copy */
    int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
    const uint8 *       pHdmx;
    const uint8 *       pCurrentHdmxRecord;
    uint32              ulHdmxRecordSize;
    uint16              usRecordIndex;
    uint16              usGlyphIndex;
    ErrorCode           error;

    Assert( usFirstGlyph <= usLastGlyph );
    Assert( psBuffer != NULL );

    *pbFound = FALSE;

    error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_HoriDeviceMetrics, FALSE, (const void **)&pHdmx);

    if(error)
    {
        return error;
    }

    /* If no 'hdmx' return success and not found    */

    if( pHdmx == NULL )
    {
        return NO_ERR;
    }

    if((uint16)pHdmx[SFNT_HDMX_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
    {
        ulHdmxRecordSize = (uint32)SWAPL(*((uint32 *)&pHdmx[SFNT_HDMX_LSIZERECORD]));

        usRecordIndex = 0;
        pCurrentHdmxRecord = &pHdmx[SFNT_HDMX_HDMXTABLE];
        while (  (usRecordIndex < (uint16)SWAPW(*((uint16 *)&pHdmx[SFNT_HDMX_SNUMRECORDS]))) && !*pbFound )
        {
            if( usPixelsPerEm == (uint16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BEMY] )
            {
                *pbFound = TRUE;
            }
            else
            {
                pCurrentHdmxRecord += ulHdmxRecordSize;
            }
            usRecordIndex++;
        }

        if ( *pbFound )
        {
            for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
            {
                *psBuffer = (int16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BWIDTHS + usGlyphIndex];
                psBuffer++;
            }
        }
    }

    RELEASESFNTFRAG(ClientInfo, pHdmx);

    return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
    sfac_ClientRec *    ClientInfo,     /* Client Information   */
    uint16              usPixelsPerEm,  /* Current Pixels per Em    */
    uint16              usFirstGlyph,   /* First Glyph to copy */
    uint16              usLastGlyph,    /* Last Glyph to copy */
    int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
    const uint8 *       pLTSH;
    uint16              usGlyphIndex;
    ErrorCode           error;

    MEMSET(psBuffer, FALSE, ((usLastGlyph - usFirstGlyph) + 1) * sizeof(int16));

    error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_LinearThreshold, FALSE, (const void **)&pLTSH);

    if(error)
    {
        return error;
    }
    
    if( pLTSH == NULL )
    {
        return NO_ERR;
    }

    if((uint16)pLTSH[SFNT_LTSH_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
    {
        for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++ )
        {
            if( usPixelsPerEm >= (uint16)pLTSH[SFNT_LTSH_UBYPELSHEIGHT + usGlyphIndex] )
            {
                *psBuffer = TRUE;
            }
            else
            {
                *psBuffer = FALSE;
            }
            psBuffer++;
        }
    }

    RELEASESFNTFRAG(ClientInfo, pLTSH);

    return NO_ERR;
}



/***************************** Public  Function ****************************\
* sfac_ReadGlyphHeader
*
* This routine sets up the glyph handle to a glyph, and returns the header
* information in the glyph.
*
* Effects:
*
* Error Returns:
*
* UNKNOWN_COMPOSITE_VERSION
*
* History:
* Wed 26-Aug-1992 09:55:19 -by-  Greg Hitchcock [gregh]
*      Added CodeReview fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
    sfac_ClientRec *    ClientInfo,       /* Client Information         */
    uint16              usGlyphIndex,     /* Glyph index to read        */
    sfac_GHandle *      hGlyph,           /* Return glyph handle        */
    boolean *           pbCompositeGlyph, /* Is glyph a composite?      */
    boolean *           pbHasOutline,     /* Does glyph have outlines?  */
    int16 *             psNumberOfContours, /* Number of contours in glyph */
    BBOX *              pbbox)            /* Glyph Bounding box         */
{
    uint32              ulLength;
    uint32              ulOffset;
    sfnt_tableIndex     glyphTableIndex;
    ErrorCode           error;
    const uint8 *       GlyphHeader;

    hGlyph->pvGlyphBaseAddress = NULL;
    hGlyph->pvGlyphNextAddress = NULL;

    /* Locate the glyph in the font file   */

    error = sfac_GetGlyphLocation(
        ClientInfo,
        usGlyphIndex,
        &ulOffset,
        &ulLength,
        &glyphTableIndex);

    if(error)
    {
        return error;
    }

    if( ulLength == 0 )
    {
        *psNumberOfContours = 1;
        MEMSET(pbbox, 0, sizeof(BBOX));
        *pbHasOutline = FALSE;
        *pbCompositeGlyph = FALSE;
    }
    else
    {
        if (ulLength < SFNT_PACKEDSPLINEFORMAT_ENDPOINTS)
        {
            return GLYF_TABLE_CORRUPTION_ERR;
        }

        error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
                glyphTableIndex, TRUE, (const void **)&hGlyph->pvGlyphBaseAddress);

        if(error)
        {
            return error;
        }

        hGlyph->pvGlyphEndAddress = (uint8 *)hGlyph->pvGlyphBaseAddress + ulLength;

        GlyphHeader = (uint8 *)hGlyph->pvGlyphBaseAddress;
        *psNumberOfContours = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS]));

        if( *psNumberOfContours < COMPONENTCTRCOUNT )
        {
            return UNKNOWN_COMPOSITE_VERSION;
        }

        if( *psNumberOfContours == COMPONENTCTRCOUNT )
        {
            *pbCompositeGlyph = TRUE;
            *psNumberOfContours = 0;
            *pbHasOutline = FALSE;
        }
        else
        {
            *pbCompositeGlyph = FALSE;
            *pbHasOutline = TRUE;
        }

        pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
        pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
        pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
        pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

        if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
        {
            return SFNT_DATA_ERR;
        }

        if(pbHasOutline)
        {
            hGlyph->pvGlyphNextAddress = (voidPtr)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_ENDPOINTS];
        }
    }

    return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadGlyphBbox
*
*
* Effects:
*         This function release the glyph memory immediately
*
* Error Returns:
*
* SFNT_DATA_ERR
*
* History:
* Wed 20-Dec-1996 18:42:51 -by-  Claude Betrisey [claudebe]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphBbox(
    sfac_ClientRec *    ClientInfo,       /* Client Information         */
    uint16              usGlyphIndex,     /* Glyph index to read        */
    BBOX *              pbbox)            /* Glyph Bounding box         */
{
    uint32              ulLength;
    uint32              ulOffset;
    sfnt_tableIndex     glyphTableIndex;
    ErrorCode           error;
    const uint8 *       GlyphHeader;


    /* Locate the glyph in the font file   */

    error = sfac_GetGlyphLocation(
        ClientInfo,
        usGlyphIndex,
        &ulOffset,
        &ulLength,
        &glyphTableIndex);

    if(error)
    {
        return error;
    }

    if( ulLength == 0 )
    {
        MEMSET(pbbox, 0, sizeof(BBOX));
    }
    else
    {
        error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
                glyphTableIndex, TRUE, (const void **)&GlyphHeader);

        if(error)
        {
            return error;
        }

        pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
        pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
        pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
        pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

        RELEASESFNTFRAG(ClientInfo, GlyphHeader );

        if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
        {
            return SFNT_DATA_ERR;
        }


    }

    return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadOutlineData
*
*   This routine reads the outline data from the font file. This information
*   includes x and y coordinates, and on-curve indicators as well as start/end
*   points, flags, and instruction data.
*
* Effects:
*   hGlyph
*
* Error Returns:
*   CONTOUR_DATA_ERR
*
* History:
* Wed 26-Aug-1992 09:55:49 -by-  Greg Hitchcock [gregh]
*      Added Code Review fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/


FS_PUBLIC ErrorCode sfac_ReadOutlineData(
    uint8 *             abyOnCurve,             /* Array of on curve indicators per point */
    F26Dot6 *           afxOoy,                 /* Array of ooy points for every point    */
    F26Dot6 *           afxOox,                 /* Array of oox points for every point    */
    sfac_GHandle *      hGlyph,
    LocalMaxProfile *   pMaxProfile,            /* copy of profile                        */
    boolean             bHasOutline,            /* Does glyph have outlines?              */
    int16               sNumberOfContours,      /* Number of contours in glyph            */
    int16 *             asStartPoints,          /* Array of start points for every contour   */
    int16 *             asEndPoints,            /* Array of end points for every contour    */
    uint16 *            pusSizeOfInstructions,  /* Size of instructions in bytes        */
     uint8 **               pbyInstructions,    /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours) /* total number of contours for composites, to check for overflow */

{

    uint8 *     pbyCurrentSfntLocation;
    int16 *     psCurrentLocation;
    int16 *     asSfntEndPoints;
    uint8 *     pbySfntFlags;
    uint8       byRepeatFlag;

    int32       lNumPoints;
    int32       lContourIndex;
    int32       lPointCount;
    int32       lPointIndex;
    uint16      usRepeatCount;
    int16       sXValue;
    int16       sYValue;
    uint8 *     pbyFlags;
    F26Dot6 *   pf26OrigX;
    F26Dot6 *   pf26OrigY;

    /* Initialize Fields */

    asStartPoints[0] = 0;
    asEndPoints[0] = 0;

    abyOnCurve[0] = ONCURVE;
    afxOox[0] = 0;
    afxOoy[0] = 0;

    *pbyInstructions = NULL;
    *pusSizeOfInstructions = 0;

    /* If we don't have an outline, exit here   */

    if (!bHasOutline)
    {
        return NO_ERR;
    }

    if (sNumberOfContours <= 0 || sNumberOfContours > (int16)pMaxProfile->maxContours)
    {
        return CONTOUR_DATA_ERR;
    }

    /* Handle the case of outlines   */

    psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

    asSfntEndPoints = psCurrentLocation;
    psCurrentLocation += sNumberOfContours;

    if ((voidPtr)psCurrentLocation > hGlyph->pvGlyphEndAddress)
    {
        return GLYF_TABLE_CORRUPTION_ERR;
    }

    *pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
    *pbyInstructions = (uint8 *)psCurrentLocation;
    pbySfntFlags = (uint8 *)((char *)psCurrentLocation + *pusSizeOfInstructions);

    if ((voidPtr)pbySfntFlags > hGlyph->pvGlyphEndAddress)
    {
        return GLYF_TABLE_CORRUPTION_ERR;
    }


    *pCompositeContours += sNumberOfContours;
    if (*pCompositeContours > (uint32)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours))
    {
        return CONTOUR_DATA_ERR;
    }

    lContourIndex = 0;

    asStartPoints[lContourIndex] = 0;
    asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
    lNumPoints = (int32)asEndPoints[lContourIndex] + 1;

    for(lContourIndex = 1; lContourIndex < (int32)sNumberOfContours; lContourIndex++)
    {
        asStartPoints[lContourIndex] = (int16)(asEndPoints[lContourIndex - 1] + 1);
        asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
        if ((lNumPoints > asEndPoints[lContourIndex]) || (lNumPoints > (int32)pMaxProfile->maxPoints) || (lNumPoints <= 0))
        {
            /* array of end points is not in ascending order, or too many points */
            /* or negative, that mean overflow since it's signed int16 instead of unsigned int16, for example 0xcdab */
            return POINTS_DATA_ERR;
        }
        lNumPoints = (int32)asEndPoints[lContourIndex] + 1;
    }

    if (lNumPoints <= 0)
    {
        return POINTS_DATA_ERR;
    }

    *pCompositePoints += lNumPoints;
    if (*pCompositePoints > (uint32)MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints) )
    {
        return POINTS_DATA_ERR;
    }

    /* Do flags */

    usRepeatCount = 0;

    lPointCount = lNumPoints;
    pbyFlags = abyOnCurve;

    while(lPointCount > 0)
    {
        if(usRepeatCount == 0)
        {
            *pbyFlags = *pbySfntFlags;

            if(*pbyFlags & REPEAT_FLAGS)
            {
                pbySfntFlags++;
                usRepeatCount = (uint16)*pbySfntFlags;
            }
            pbySfntFlags++;
            pbyFlags++;
            lPointCount--;
        }
        else
        {
            byRepeatFlag = pbyFlags[-1];
            lPointCount -= (int32)usRepeatCount;

            if (lPointCount < 0)
            {
                return GLYF_TABLE_CORRUPTION_ERR;
            }

            while(usRepeatCount > 0)
            {
                *pbyFlags = byRepeatFlag;
                pbyFlags++;
                usRepeatCount--;
            }
        }
    }

    pbyCurrentSfntLocation = pbySfntFlags;

    if(usRepeatCount > 0)
    {
        return POINTS_DATA_ERR;
    }

    if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
    {
        return GLYF_TABLE_CORRUPTION_ERR;
    }
    /* Do X first */

    sXValue = 0;
    pf26OrigX = afxOox;
    pbyFlags = abyOnCurve;

    for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
    {
        if(*pbyFlags & XSHORT)
        {
            if(*pbyFlags & SHORT_X_IS_POS)
            {
                sXValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
            }
            else
            {
                sXValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
            }
        }
        else if (! (*pbyFlags & NEXT_X_IS_ZERO))
        {
            /* This means we have a two byte quantity */

            sXValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
            pbyCurrentSfntLocation += sizeof(int16);
        }
        *pf26OrigX = (F26Dot6)sXValue;
        pf26OrigX++;
        pbyFlags++;
    }

    if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
    {
        return GLYF_TABLE_CORRUPTION_ERR;
    }
    /* Now Do Y */

    sYValue = 0;
    pf26OrigY = afxOoy;
    pbyFlags = abyOnCurve;

    for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
    {
        if(*pbyFlags & YSHORT)
        {
            if(*pbyFlags & SHORT_Y_IS_POS)
            {
                sYValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
            }
            else
            {
                sYValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
            }
        }
        else if (! (*pbyFlags & NEXT_Y_IS_ZERO))
        {
            /* This means we have a two byte quantity */

            sYValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
            pbyCurrentSfntLocation += sizeof(int16);
        }
        *pf26OrigY = (F26Dot6)sYValue;
        pf26OrigY++;

        /* Clear out extraneous bits in OnCurve */

        *pbyFlags &= ONCURVE;
        pbyFlags++;
    }

    if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
    {
        return GLYF_TABLE_CORRUPTION_ERR;
    }

    hGlyph->pvGlyphNextAddress = (voidPtr)pbyCurrentSfntLocation;

    return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadComponentData
*
*   This routine reads information from the font file for positioning and
*   scaling a glyph component.
*
* Effects:
*
* Error Returns:
*   none
*
* History:
* Wed 26-Aug-1992 09:56:29 -by-  Greg Hitchcock [gregh]
*      Added Code Review Fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadComponentData(
    sfac_GHandle *          hGlyph,
    sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets  */
    boolean *               pbRoundXYToGrid,  /* Round composite offsets to grid     */
    boolean *               pbUseMyMetrics,   /* Use component metrics            */
    boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
    boolean *               pbWeHaveInstructions, /* Composite has instructions         */
    uint16 *                pusComponentGlyphIndex, /* Glyph index of component         */
    int16 *                 psXOffset,        /* X Offset of component (if app)      */
    int16 *                 psYOffset,        /* Y Offset of component (if app)      */
    uint16 *                pusAnchorPoint1,  /* Anchor point 1 of component (if app) */
    uint16 *                pusAnchorPoint2,  /* Anchor point 2 of component (if app) */
    transMatrix             *pMulT,           /* Transformation matrix for component */
    boolean *               pbWeHaveAScale,     /* We have a scaling in pMulT                   */
    boolean *               pbLastComponent)   /* Is this the last component?                  */

{
    int16 *     psCurrentLocation;
    uint16      usComponentFlags;
    char *      byteP;

    Fixed       fMultiplier;


    psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

    /* Initialize values */

    /* Initialize transformation matrix to identity */

    *pMulT = IdentTransform;

    *psXOffset = 0;
    *psYOffset = 0;
    *pusAnchorPoint1 = 0;
    *pusAnchorPoint2 = 0;
    *pbWeHaveAScale = FALSE;

    usComponentFlags = (uint16)SWAPWINC(psCurrentLocation);

    *pbWeHaveInstructions = ((usComponentFlags & WE_HAVE_INSTRUCTIONS) == WE_HAVE_INSTRUCTIONS);
    *pbUseMyMetrics =    ((usComponentFlags & USE_MY_METRICS) == USE_MY_METRICS);
    *pbRoundXYToGrid =      ((usComponentFlags & ROUND_XY_TO_GRID) == ROUND_XY_TO_GRID);

    /* new flags that indicate if the glyph was designed to have the component offset scaled or not
       Apple does scale the component offset, MS doesn't, those flags are supposed to be clear on old fonts
       on new fonts, only one of these flags must be set,
       default is set to false, MS behavior */
    if ((usComponentFlags & SCALED_COMPONENT_OFFSET) == SCALED_COMPONENT_OFFSET)
    {
        *pbScaleCompositeOffset = TRUE;
    }
    if ((usComponentFlags & UNSCALED_COMPONENT_OFFSET) == UNSCALED_COMPONENT_OFFSET)
    {
        *pbScaleCompositeOffset = FALSE;
    }

    *pusComponentGlyphIndex = (uint16)SWAPWINC(psCurrentLocation);

    if (usComponentFlags & ARGS_ARE_XY_VALUES)
    {
        *pMultiplexingIndicator = OffsetPoints;
    }
    else
    {
        *pMultiplexingIndicator = AnchorPoints;
    }


    /*
        !!!APPLEBUG The rasterizer did not handle Word Anchor Points. This
        !!!APPLEBUG has been corrected in our version of the rasterizer, but
        !!!APPLEBUG we need to verify with the Apple source code.  --GregH
     */

    if (usComponentFlags & ARG_1_AND_2_ARE_WORDS)
    {
        if (usComponentFlags & ARGS_ARE_XY_VALUES)
        {
            *psXOffset    = SWAPWINC (psCurrentLocation);
            *psYOffset    = SWAPWINC (psCurrentLocation);
        }
        else
        {
            *pusAnchorPoint1 = (uint16) SWAPWINC (psCurrentLocation);
            *pusAnchorPoint2 = (uint16) SWAPWINC (psCurrentLocation);
        }
    }
    else
    {
        byteP = (char *)psCurrentLocation;
        if (usComponentFlags & ARGS_ARE_XY_VALUES)
        {
        /* offsets are signed */
            *psXOffset = (int16)(int8)*byteP++;
            *psYOffset = (int16)(int8)*byteP;
        }
        else
        {
        /* anchor points are unsigned */
            *pusAnchorPoint1 = (uint16)(uint8) * byteP++;
            *pusAnchorPoint2 = (uint16)(uint8) * byteP;
        }
        ++psCurrentLocation;
    }


    if (usComponentFlags & (WE_HAVE_A_SCALE | WE_HAVE_AN_X_AND_Y_SCALE | WE_HAVE_A_TWO_BY_TWO))
    {

        *pbWeHaveAScale = TRUE;

        if (usComponentFlags & WE_HAVE_A_TWO_BY_TWO)
        {
            fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
            pMulT->transform[0][0] = (fMultiplier << 2); /* turn into 16.16 */

            fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
            pMulT->transform[0][1] = (fMultiplier << 2); /* turn into 16.16 */

            fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
            pMulT->transform[1][0] = (fMultiplier << 2); /* turn into 16.16 */

            fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
            pMulT->transform[1][1] = (fMultiplier << 2); /* turn into 16.16 */

        }
        else
        {
            /* If we have a scale factor, build it into the transformation matrix   */

            pMulT->transform[0][1] = 0;
            pMulT->transform[1][0] = 0;

            fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
            pMulT->transform[0][0] = (fMultiplier <<= 2); /* turn into 16.16 */

            if (usComponentFlags & WE_HAVE_AN_X_AND_Y_SCALE)
            {
                fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
                pMulT->transform[1][1] = (fMultiplier <<= 2); /* turn into 16.16 */
            }
            else
            {
                pMulT->transform[1][1] = pMulT->transform[0][0];
            }
        }
    }
    *pbLastComponent = !((usComponentFlags & MORE_COMPONENTS) == MORE_COMPONENTS);

    hGlyph->pvGlyphNextAddress = (voidPtr)psCurrentLocation;

    if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
    {
        return GLYF_TABLE_CORRUPTION_ERR;
    }
    return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadCompositeInstructions
*
*   This routine returns the instructions for the composite
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
    sfac_GHandle * hGlyph,
    uint8 **    pbyInstructions,     /* Pointer to start of glyph instructions */
    uint16 *    pusSizeOfInstructions) /* Size of instructions in bytes           */
{
    int16 *    psCurrentLocation;

    psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

    *pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
    *pbyInstructions = (uint8 *)psCurrentLocation;
    hGlyph->pvGlyphNextAddress = (voidPtr)(*pbyInstructions + *pusSizeOfInstructions);

    if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
    {
        return GLYF_TABLE_CORRUPTION_ERR;
    }

    return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReleaseGlyph
*
*   This routine releases the glyph handle for the font file
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
    sfac_ClientRec *  ClientInfo,
    sfac_GHandle *    hGlyph)
{
    if(hGlyph->pvGlyphNextAddress)
    {
        RELEASESFNTFRAG(ClientInfo,(voidPtr)hGlyph->pvGlyphBaseAddress);

        hGlyph->pvGlyphNextAddress = NULL;
        hGlyph->pvGlyphBaseAddress = NULL;

    }

    return NO_ERR;
}

/***************************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

/*  Local constants  */

#define     SBIT_BLOC_TABLE         1       /* which table are metrics in */
#define     SBIT_BDAT_TABLE         2

#define     SBIT_HORIZ_METRICS      1       /* which kind of metrics */
#define     SBIT_VERT_METRICS       2
#define     SBIT_BIG_METRICS        3

typedef enum {                              /* metrics type */
    flgHorizontal = 0x01,
    flgVertical = 0x02
} bitmapFlags;

FS_PRIVATE boolean FindBlocStrike (         /* helper function prototype */
    const uint8 *pbyBloc,
    uint32 ulTableLength,
    uint16 usPpemX, 
    uint16 usPpemY, 
    uint16 usOverScale,            /* outline magnification requested */
    uint16 *pusBitDepth,            /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint32 *pulStrikeOffset );

FS_PRIVATE boolean FindBscaStrike (         /* helper function prototype */
    const uint8 *pbyBsca,
    uint32 ulTableLength,
    uint16 usPpemX, 
    uint16 usPpemY, 
    uint32 *pulStrikeOffset );

/*  byte size bitmap range masks */

static const uint8    achStartMask[] = { 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01 };
static const uint8    achStopMask[] =  { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF };
                    
/**********************************************************************/

FS_PUBLIC ErrorCode sfac_SearchForStrike (
    sfac_ClientRec *pClientInfo,
    uint16 usPpemX, 
    uint16 usPpemY, 
    uint16 usOverScale,            /* outline magnification requested */
    uint16 *pusBitDepth,            /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16 *pusTableState,
    uint16 *pusSubPpemX,
    uint16 *pusSubPpemY,
    uint32 *pulStrikeOffset )
{
    const uint8 *   pbyBloc;
    const uint8 *   pbyBsca;
    ErrorCode       ReturnCode;
    uint32          ulTableLengthBitmapLocation = SFAC_LENGTH(pClientInfo, sfnt_BitmapLocation);
    uint32          ulTableLengthBitmapScale = SFAC_LENGTH(pClientInfo, sfnt_BitmapScale);
    
   
    *pusTableState = SBIT_NOT_FOUND;                /* defaults */
    *pulStrikeOffset = 0L;
    *pusSubPpemX = 0;
    *pusSubPpemY = 0;

    ReturnCode = sfac_GetDataPtr (
        pClientInfo,                                /* callback etc. */
        0L,                                         /* table start */
        ulTableLengthBitmapLocation,                /* table size */
        sfnt_BitmapLocation,                        /* registered tag */
        FALSE,                                      /* doesn't have to be there */
        (const void**)&pbyBloc );                   /* data pointer */
    
    if (ReturnCode != NO_ERR) return ReturnCode;
    
    if (pbyBloc != NULL)                            /* if bloc exists */
    {
        if (FindBlocStrike (pbyBloc, ulTableLengthBitmapLocation, usPpemX, usPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
        {
            *pusTableState = SBIT_BLOC_FOUND;       /* exact match */
        }
        else                                        /* if bloc and NO match */
        {
            ReturnCode = sfac_GetDataPtr (
                pClientInfo,                        /* callback etc. */
                0L,                                 /* table start */
                ulTableLengthBitmapScale,           /* table size */
                sfnt_BitmapScale,                   /* registered tag */
                FALSE,                              /* doesn't have to be there */
                (const void**)&pbyBsca );           /* data pointer */
            
            if (ReturnCode != NO_ERR) return ReturnCode;
            
            if (pbyBsca != NULL)                    /* if bsca exists */
            {
                if (FindBscaStrike (pbyBsca, ulTableLengthBitmapScale, usPpemX, usPpemY, pulStrikeOffset))
                {
                    *pusSubPpemX = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMX];
                    *pusSubPpemY = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMY];
                    
                    if (FindBlocStrike (pbyBloc, ulTableLengthBitmapLocation, *pusSubPpemX, *pusSubPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
                    {
                        *pusTableState = SBIT_BSCA_FOUND;
                    }
                }
                RELEASESFNTFRAG(pClientInfo, pbyBsca );
            }
        }
        RELEASESFNTFRAG(pClientInfo, pbyBloc);
    }
    return NO_ERR;
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bloc table */

FS_PRIVATE boolean FindBlocStrike (
    const uint8 *pbyBloc,
    uint32 ulTableLength,
    uint16 usPpemX, 
    uint16 usPpemY, 
    uint16 usOverScale,            /* outline magnification requested */
    uint16 *pusBitDepth,            /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint32 *pulStrikeOffset )
{
    uint32          ulNumStrikes;
    uint32          ulStrikeOffset;
    uint32          ulColorRefOffset;
    uint16          usPreferedBitDepth, usBestBitDepth, usCurrentBitDepth;
    uint16          usSbitBitDepthMask;

    if (SFNT_BLOC_FIRSTSTRIKE > ulTableLength)
    {
        /* bogus table, table is optional, we need to ignore */
        FS_WARNING("sfntaccs.c, FindBlocStrike, offset out of bounds");
        return FALSE;   
    }                      
   
    ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));
    ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;

//    if ((SFNT_BLOC_FIRSTSTRIKE + (ulNumStrikes * SIZEOF_BLOC_SIZESUBTABLE))  > ulTableLength)
    if (ulNumStrikes > (ulTableLength - SFNT_BLOC_FIRSTSTRIKE) / SIZEOF_BLOC_SIZESUBTABLE)
    {
        /* bogus table, table is optional, we need to ignore */
        FS_WARNING("sfntaccs.c, FindBlocStrike, offset out of bounds");
        return FALSE;   
    }                      

    usBestBitDepth = 0;
    
    if (usOverScale == 0)
    {
        usPreferedBitDepth = 1;
        usSbitBitDepthMask = SBIT_BITDEPTH_MASK & 0x0002; /* accept only black/white bitmap */
    } else 
    {
        if (usOverScale == 2)
        {
            usPreferedBitDepth = 2;
        } else if (usOverScale == 4) 
        {
            usPreferedBitDepth = 4;
        } else
        {
            usPreferedBitDepth = 8;
        }
        usSbitBitDepthMask = SBIT_BITDEPTH_MASK & ~0x0002; /* accept only grayscale bitmap */
    } 

    while (ulNumStrikes > 0)
    {
        if ((usPpemX == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
            (usPpemY == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
        {
            ulColorRefOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_COLORREF]));
            usCurrentBitDepth = pbyBloc[ulStrikeOffset + SFNT_BLOC_BITDEPTH];

            if (((0x01 << usCurrentBitDepth) & usSbitBitDepthMask) && (ulColorRefOffset == 0L))
            {
                if (usCurrentBitDepth == usPreferedBitDepth)
                {
                    /* perfect match */
                    *pulStrikeOffset = ulStrikeOffset;
                    *pusBitDepth = usPreferedBitDepth;
                    return TRUE;      
                } else if (usCurrentBitDepth > usPreferedBitDepth)
                {
                    /* above is better than below */
                    if ((usCurrentBitDepth < usBestBitDepth) || (usBestBitDepth < usPreferedBitDepth))
                    {
                        /* above and closer */
                        *pulStrikeOffset = ulStrikeOffset;
                        usBestBitDepth = usCurrentBitDepth;
                    }
                } else /* if (usCurrentBitDepth < usPreferedBitDepth) */
                {
                    /* we look below the prefered only if we don't have found anything above */
                    if ((usBestBitDepth < usPreferedBitDepth) && (usCurrentBitDepth > usBestBitDepth))
                    {
                        /* below and closer */
                        *pulStrikeOffset = ulStrikeOffset;
                        usBestBitDepth = usCurrentBitDepth;
                    }
                }
            }
        }
        ulNumStrikes--;
        ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
    }

    if (usBestBitDepth != 0)
    {
        *pusBitDepth = usBestBitDepth;
        return TRUE;                                   /* best match found */
    } 

    return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bsca table */

FS_PRIVATE boolean FindBscaStrike (
    const uint8 *pbyBsca,
    uint32 ulTableLength,
    uint16 usPpemX, 
    uint16 usPpemY, 
    uint32 *pulStrikeOffset )
{
    uint32          ulNumStrikes;
    uint32          ulStrikeOffset;
    
    if (SFNT_BSCA_FIRSTSTRIKE > ulTableLength)
    {
        /* bogus table, table is optional, we need to ignore */
        FS_WARNING("sfntaccs.c, FindBlocStrike, offset out of bounds");
        return FALSE;   
    }                      

    ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBsca[SFNT_BSCA_NUMSIZES]));
    ulStrikeOffset = SFNT_BSCA_FIRSTSTRIKE;

    if ((SFNT_BSCA_FIRSTSTRIKE + (ulNumStrikes * SIZEOF_BSCA_SIZESUBTABLE))  > ulTableLength)
    {
        /* bogus table, table is optional, we need to ignore */
        FS_WARNING("sfntaccs.c, FindBlocStrike, offset out of bounds");
        return FALSE;   
    }                      

    while (ulNumStrikes > 0)
    {
        if ((usPpemX == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMX]) &&
            (usPpemY == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMY]))
        {
            *pulStrikeOffset = ulStrikeOffset;
            return TRUE;                            /* match found */
        }
        ulNumStrikes--;
        ulStrikeOffset += SIZEOF_BSCA_SIZESUBTABLE;
    }
    return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Look for a glyph in a given strike */        

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
    sfac_ClientRec *pClientInfo,
    uint16 usGlyphCode,
    uint32 ulStrikeOffset,
    boolean *pbGlyphFound,                   /* return values */
    uint16 *pusMetricsType,
    uint16 *pusMetricsTable,
    uint32 *pulMetricsOffset,
    uint16 *pusBitmapFormat,
    uint32 *pulBitmapOffset,
    uint32 *pulBitmapLength )
{
    const uint8 *   pbyBloc;
    ErrorCode       ReturnCode;

    uint32      ulNumIndexTables;
    uint32      ulIndexArrayTop;
    uint32      ulIndexArrayOffset;
    uint32      ulSubTableOffset;
    uint32      ulGlyphOffset;
    uint32      ulNextGlyphOffset;
    uint32      ulBitmapLength;
    uint32      ulImageDataOffset;
    uint32      ulNumGlyphs;
    uint32      ulTop;                      /* binary search ranges */
    uint32      ulBottom;
    uint32      ulHit;
    uint32      ulHitOffset;

    uint16      usStartGlyph;               /* for whole strike */
    uint16      usEndGlyph;
    uint16      usFirstGlyph;               /* for one sub table */
    uint16      usLastGlyph;
    uint16      usIndexFormat;
    uint16      usImageFormat;
    uint16      usHitCode;
    
    bitmapFlags bmfDirection;               /* horiz or vert */
    uint32          ulTableLength = SFAC_LENGTH(pClientInfo, sfnt_BitmapLocation);

    
    *pbGlyphFound = FALSE;                              /* default */

    ReturnCode = sfac_GetDataPtr (
        pClientInfo,                                    /* callback etc. */
        0L,                                             /* table start */
        ulTableLength,                                  /* read whole table */
        sfnt_BitmapLocation,                            /* registered tag */
        TRUE,                                           /* better be there now */
        (const void**)&pbyBloc );                       /* data pointer */
    
    if (ReturnCode != NO_ERR) return ReturnCode;
        
    usStartGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_STARTGLYPH]));
    usEndGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_ENDGLYPH]));

    if ((usStartGlyph > usGlyphCode) || (usEndGlyph < usGlyphCode))
    {
        RELEASESFNTFRAG(pClientInfo, pbyBloc);
        return NO_ERR;                                  /* glyph out of range */
    }

    ulNumIndexTables = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_NUMINDEXTABLES]));
    ulIndexArrayTop = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_INDEXARRAYOFFSET]));
    ulIndexArrayOffset = ulIndexArrayTop;

    if ((ulIndexArrayOffset + (ulNumIndexTables * SIZEOF_BLOC_INDEXARRAY))  > ulTableLength)
    {
        /* bogus table, table is optional, we need to ignore */
        FS_WARNING("sfntaccs.c, sfac_SearchForBitmap, offset out of bounds");
        RELEASESFNTFRAG(pClientInfo, pbyBloc);
        return NO_ERR;   
    }                      

    while ((ulNumIndexTables > 0) && (*pbGlyphFound == FALSE))
    {
        usFirstGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_FIRSTGLYPH]));
        usLastGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_LASTGLYPH]));
    
        if ((usFirstGlyph <= usGlyphCode) && (usLastGlyph >= usGlyphCode))
        {
            ulSubTableOffset = ulIndexArrayTop +
                (uint32)SWAPL(*((uint32*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_ADDITIONALOFFSET]));
            
            if ((ulSubTableOffset + SFNT_BLOC_OFFSETARRAY)  > ulTableLength)
            {
                /* bogus table, table is optional, we need to ignore */
                FS_WARNING("sfntaccs.c, sfac_SearchForBitmap, offset out of bounds");
                RELEASESFNTFRAG(pClientInfo, pbyBloc);
                return NO_ERR; 
            }  

            usIndexFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_INDEXFORMAT]));
            usImageFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEFORMAT]));
            ulImageDataOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEOFFSET]));

/* decode the individual index subtable formats */            

            switch(usIndexFormat)                       /* different search req's */
            {
            case 1:
                ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint32) * (uint32)(usGlyphCode - usFirstGlyph);

                if ((ulSubTableOffset + 2* sizeof(uint32))  > ulTableLength)
                {
                    /* bogus table, table is optional, we need to ignore */
                    FS_WARNING("sfntaccs.c, sfac_SearchForBitmap, format 1, offset out of bounds");
                    RELEASESFNTFRAG(pClientInfo, pbyBloc);
                    return NO_ERR; 
                }  

                ulGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
                
                ulSubTableOffset += sizeof(uint32);
                ulNextGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
                ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

                if (ulBitmapLength == 0)
                {
                    RELEASESFNTFRAG(pClientInfo, pbyBloc);
                    return NO_ERR;                      /* no bitmap data stored */
                }
                ulImageDataOffset += ulGlyphOffset;
                *pulMetricsOffset = ulImageDataOffset;
                *pusMetricsTable = SBIT_BDAT_TABLE;
                break;
            
            case 2:
                if ((ulSubTableOffset + SFNT_BLOC_IDX2IMAGESIZE + sizeof(uint32))  > ulTableLength)
                {
                    /* bogus table, table is optional, we need to ignore */
                    FS_WARNING("sfntaccs.c, sfac_SearchForBitmap, format 2, offset out of bounds");
                    RELEASESFNTFRAG(pClientInfo, pbyBloc);
                    return NO_ERR; 
                }  

                ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX2IMAGESIZE]));
                ulImageDataOffset += ulBitmapLength * (usGlyphCode - usFirstGlyph);
                *pulBitmapOffset = ulImageDataOffset;
                
                *pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX2METRICS;
                *pusMetricsTable = SBIT_BLOC_TABLE;
                *pusMetricsType = SBIT_BIG_METRICS;
                break;
            
            case 3:
                ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint16) * (uint32)(usGlyphCode - usFirstGlyph);

                if ((ulSubTableOffset + 2 * sizeof(uint16))  > ulTableLength)
                {
                    /* bogus table, table is optional, we need to ignore */
                    FS_WARNING("sfntaccs.c, sfac_SearchForBitmap, format 3, offset out of bounds");
                    RELEASESFNTFRAG(pClientInfo, pbyBloc);
                    return NO_ERR; 
                }  

                ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
                
                ulSubTableOffset += sizeof(uint16);
                ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
                ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

                if (ulBitmapLength == 0)
                {
                    RELEASESFNTFRAG(pClientInfo, pbyBloc);
                    return NO_ERR;                      /* no bitmap data stored */
                }
                ulImageDataOffset += ulGlyphOffset;
                *pulMetricsOffset = ulImageDataOffset;
                *pusMetricsTable = SBIT_BDAT_TABLE;
                break;
            
            case 4:
                if ((ulSubTableOffset + SFNT_BLOC_IDX4NUMGLYPHS + sizeof(uint32))  > ulTableLength)
                {
                    /* bogus table, table is optional, we need to ignore */
                    FS_WARNING("sfntaccs.c, sfac_SearchForBitmap, format 4, offset out of bounds");
                    RELEASESFNTFRAG(pClientInfo, pbyBloc);
                    return NO_ERR; 
                }  

                ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX4NUMGLYPHS]));
                ulTop = 0L;
                ulBottom = ulNumGlyphs - 1L;
                ulSubTableOffset += SFNT_BLOC_IDX4OFFSETARRAY;  /* array base */

                ulHit = ulTop;
                ulHitOffset = ulSubTableOffset;

//                if ((ulSubTableOffset + SFNT_BLOC_IDX4CODE + (ulNumGlyphs + 1) * SIZEOF_CODEOFFSETPAIR)  > ulTableLength)
                if (ulNumGlyphs  > ((ulTableLength - ulSubTableOffset - SFNT_BLOC_IDX4CODE) / SIZEOF_CODEOFFSETPAIR) - 1)
                {
                    /* bogus table, table is optional, we need to ignore */
                    FS_WARNING("sfntaccs.c, sfac_SearchForBitmap, format 4, offset out of bounds for glyphArray");
                    RELEASESFNTFRAG(pClientInfo, pbyBloc);
                    return NO_ERR; 
                } 

                usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
                if (usHitCode != usGlyphCode)
                {
                    ulHit = ulBottom;
                    ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
                    usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
                    while (usHitCode != usGlyphCode)
                    {
                        if (usHitCode < usGlyphCode)    /* binary search for glyph code */
                        {
                            ulTop = ulHit;
                        }
                        else
                        {
                            ulBottom = ulHit;
                        }
                        
                        if ((ulBottom - ulTop) < 2L)
                        {
                            RELEASESFNTFRAG(pClientInfo, pbyBloc);
                            return NO_ERR;              /* glyph not found */
                        }
                        
                        ulHit = (ulTop + ulBottom) >> 1L;
                        ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
                        usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
                    }
                }
                ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4OFFSET]));
                ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SIZEOF_CODEOFFSETPAIR + SFNT_BLOC_IDX4OFFSET]));
                ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;
                
                ulImageDataOffset += ulGlyphOffset;
                *pulMetricsOffset = ulImageDataOffset;
                *pusMetricsTable = SBIT_BDAT_TABLE;
                break;
            
            case 5:
                if ((ulSubTableOffset + SFNT_BLOC_IDX5CODEARRAY)  > ulTableLength)
                {
                    /* bogus table, table is optional, we need to ignore */
                    FS_WARNING("sfntaccs.c, sfac_SearchForBitmap, format 5, offset out of bounds");
                    RELEASESFNTFRAG(pClientInfo, pbyBloc);
                    return NO_ERR; 
                } 

                ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5IMAGESIZE]));
                
                *pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX5METRICS;
                *pusMetricsTable = SBIT_BLOC_TABLE;
                *pusMetricsType = SBIT_BIG_METRICS;
                
                ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5NUMGLYPHS]));
                ulTop = 0L;
                ulBottom = ulNumGlyphs - 1L;
                ulSubTableOffset += SFNT_BLOC_IDX5CODEARRAY;  /* array base */

                ulHit = ulTop;
                ulHitOffset = ulSubTableOffset;

//                if ((ulSubTableOffset + SFNT_BLOC_IDX4CODE + ulNumGlyphs * sizeof(uint16))  > ulTableLength)
                if (ulNumGlyphs > (ulTableLength - ulSubTableOffset - SFNT_BLOC_IDX4CODE) / sizeof(uint16))
                {
                    /* bogus table, table is optional, we need to ignore */
                    FS_WARNING("sfntaccs.c, sfac_SearchForBitmap, format 5, offset out of bounds for glyphArray");
                    RELEASESFNTFRAG(pClientInfo, pbyBloc);
                    return NO_ERR; 
                } 

                usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
                if (usHitCode != usGlyphCode)
                {
                    ulHit = ulBottom;
                    ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
                    usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
                    while (usHitCode != usGlyphCode)
                    {
                        if (usHitCode < usGlyphCode)    /* binary search for glyph code */
                        {
                            ulTop = ulHit;
                        }
                        else
                        {
                            ulBottom = ulHit;
                        }
                        
                        if ((ulBottom - ulTop) < 2L)
                        {
                            RELEASESFNTFRAG(pClientInfo, pbyBloc);
                            return NO_ERR;              /* glyph not found */
                        }
                        
                        ulHit = (ulTop + ulBottom) >> 1L;
                        ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
                        usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
                    }
                }
                ulImageDataOffset += ulBitmapLength * ulHit;
                *pulBitmapOffset = ulImageDataOffset;
                break;
            
            
            default:
                
                RELEASESFNTFRAG(pClientInfo, pbyBloc);
                return NO_ERR;                          /* unknown format */
            }

/* use the glyph formats to calculate metrics type & data offsets */
                
            *pulBitmapLength = ulBitmapLength;
            *pusBitmapFormat = usImageFormat;           /* save for bitmap decoding */
            bmfDirection = (bitmapFlags)pbyBloc[ulStrikeOffset + SFNT_BLOC_FLAGS];

            switch(usImageFormat)                       /* different metrics sizes */
            {
            case 1:                                     /* small glyph metrics */
            case 2:
                if (bmfDirection == flgHorizontal)
                {
                    *pusMetricsType = SBIT_HORIZ_METRICS;
                }
                else
                {
                    Assert(bmfDirection == flgVertical);

                    *pusMetricsType = SBIT_VERT_METRICS;
                }
                *pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS;
                *pbGlyphFound = TRUE;
                break;
            
            case 3:
                break;
            
            case 4:
                break;
            
            case 5:             /* bitmap offset and metrics type set above */
                *pbGlyphFound = TRUE;
                break;
            
            case 6:
            case 7:
            case 9:
                *pusMetricsType = SBIT_BIG_METRICS;
                *pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_BIGMETRICS;
                *pbGlyphFound = TRUE;
                break;
            
            case 8:
                if (bmfDirection == flgHorizontal)
                {
                    *pusMetricsType = SBIT_HORIZ_METRICS;
                }
                else
                {
                    Assert(bmfDirection == flgVertical);

                    *pusMetricsType = SBIT_VERT_METRICS;
                }
                *pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS + SIZEOF_SBIT_GLYPH8PAD;
                *pbGlyphFound = TRUE;
                break;

            default:
                break;
            }
        }
        ulNumIndexTables--;    
        ulIndexArrayOffset += SIZEOF_BLOC_INDEXARRAY;
    }
    
    RELEASESFNTFRAG(pClientInfo, pbyBloc);
    return NO_ERR;
}


/**********************************************************************/

/* fetch the horizontal metrics */

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
    sfac_ClientRec *pClientInfo,
    uint16 usMetricsType,
    uint16 usMetricsTable,
    uint32 ulMetricsOffset,
    uint16 *pusHeight,
    uint16 *pusWidth,
    int16 *psLSBearingX,
    int16 *psLSBearingY,
    int16 *psTopSBearingX, /* NEW */
    int16 *psTopSBearingY, /* NEW */
    uint16 *pusAdvanceWidth,
    uint16 *pusAdvanceHeight,  /* NEW */
    boolean *pbHorMetricsFound, /* NEW */
    boolean *pbVertMetricsFound ) /* NEW */
{
    const uint8     *pbyTable;
    uint32          ulTableLength;
    sfnt_tableIndex TableIndex;
    ErrorCode       ReturnCode;

    *pbHorMetricsFound = FALSE;                        /* default */
    *pbVertMetricsFound = FALSE;                        /* default */

    if (usMetricsTable == SBIT_BDAT_TABLE)          /* if metrics in bdat */
    {
        TableIndex = sfnt_BitmapData;
    }
    else                                            /* if metrics in bloc */
    {
        TableIndex = sfnt_BitmapLocation;
    }
    if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
    {
        ulTableLength = SIZEOF_SBIT_BIGMETRICS;
    }
    else                                            /* if only h or v metrics */
    {
        ulTableLength = SIZEOF_SBIT_SMALLMETRICS;
    }

    ReturnCode = sfac_GetDataPtr (
        pClientInfo,                                /* callback etc. */
        ulMetricsOffset,                            /* metrics start */
        ulTableLength,                              /* read just metrics */
        TableIndex,                                 /* registered tag */
        TRUE,                                       /* should be there */
        (const void**)&pbyTable );                  /* data pointer */
    
    if (ReturnCode != NO_ERR) return ReturnCode;

/*  for horizontal metrics, offsets could be different for big & small */

    *pusHeight = (uint16)pbyTable[SFNT_SBIT_HEIGHT];
    *pusWidth = (uint16)pbyTable[SFNT_SBIT_WIDTH];

    if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
    {
        *psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
        *psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
        *pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
        *psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGX]));
        *psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGY]));
        *pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_VERTADVANCE];
        *pbHorMetricsFound = TRUE;                        
        *pbVertMetricsFound = TRUE;                     
    }
    else if (usMetricsType == SBIT_HORIZ_METRICS)   
    {
        *psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
        *psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
        *pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
        *pbHorMetricsFound = TRUE;                        
    }
    else /* if (usMetricsType == SBIT_VERT_METRICS) */  
    {
        *psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
        *psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
        *pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
        *pbVertMetricsFound = TRUE;                     
    }

    RELEASESFNTFRAG(pClientInfo, pbyTable);

    return NO_ERR;
}

/**********************************************************************/

/* shave the white space from horizontal metrics for bitmap format 5 */

#define     ROWSIZE     16                      /* 16 bytes = 128 bits max */

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
    sfac_ClientRec *pClientInfo,
    uint16 usBitmapFormat,
    uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
    uint16 usBitDepth,
    uint16 *pusHeight,
    uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
    int16 *psLSBearingX,
    int16 *psLSBearingY, /* NEW */
    int16 *psTopSBearingX, /* NEW */
    int16 *psTopSBearingY) /* NEW */
{
    uint8           abyBitRow[ROWSIZE];         /* or bitmap into one row */
    const uint8     *pbyTable;
    const uint8     *pbyBdat;
    uint8           *pbyBitMap;
    uint8           byMask;
    uint8           byUpMask;
    uint8           byLowMask;
    uint16          usBitData;
    uint16          usFreshBits;
    uint16          usOutBits;
    uint16          usRow;
    uint16          usStopBit;
    uint16          usShaveLeft;
    uint16          usShaveRight;
    uint16          usShaveTop;
    uint16          usShaveBottom;
    uint16          usStart;
    ErrorCode       ReturnCode;
    boolean         bWeGotBlackPixels;              /* used in vertical shaving */
    uint8           byBlackPixelsInCurrentRaw;      /* used in vertical shaving */
    uint8           byTempBuffer;       /* temporary buffer used to detect the first/last row containing black pixels */

    *pusShaveLeft = 0;                          /* defaults */
    *pusShaveRight = 0;
    *pusShaveTop = 0;                          /* defaults */
    *pusShaveBottom = 0;

    if (usBitmapFormat != 5)                    /* if not constant metrics data */
    {
        return NO_ERR;
    }

    if ((*pusWidth * usBitDepth) > (ROWSIZE << 3))
    {
        return NO_ERR;                          /* punt huge bitmaps */
    }
    
    MEMSET(abyBitRow, 0, ROWSIZE);              /* clear to zeros */

/*      read the bitmap data    */
    if  ((ulBitmapLength == 0) || (*pusWidth == 0) || (*pusHeight == 0))
    {
        return NO_ERR; 
    }

    ReturnCode = sfac_GetDataPtr (
        pClientInfo,                            /* callback etc. */
        ulBitmapOffset,                         /* metrics start */
        ulBitmapLength,                         /* read bitmap data */
        sfnt_BitmapData,                        /* registered tag */
        TRUE,                                   /* should be there */
        (const void**)&pbyTable );              /* data pointer */

    if (ReturnCode != NO_ERR) return ReturnCode;

    pbyBdat = pbyTable;
    usBitData = 0;                              /* up to 16 bits of bdat */
    usFreshBits = 0;                            /* read & unwritten */

    bWeGotBlackPixels = FALSE;                  /* used for vertical shaving */
    usShaveTop = 0;
    usShaveBottom = 0;


/*      'or' the bitmap data into a single row    */    
    usRow = *pusHeight;

    while (usRow > 0)
    {
        pbyBitMap = abyBitRow;
        usOutBits = *pusWidth * usBitDepth;
        usStopBit = 8;
        byBlackPixelsInCurrentRaw = 0;

        while (usOutBits > 0)                   /* if more to do */
        {
            if (usFreshBits < 8)                /* if room for fresh data */
            {
                usBitData <<= 8;
                if (ulBitmapLength > 0)         /* prevent read past data end */
                {
                    usBitData |= (uint16)*pbyBdat++;
                    ulBitmapLength--;
                }
                usFreshBits += 8;
            }
            
            if (usStopBit > usOutBits)
            {
                usStopBit = usOutBits;
            }
            byMask = achStopMask[usStopBit];
            
            byTempBuffer = (uint8)((usBitData >> (usFreshBits - 8)) & byMask);

            byBlackPixelsInCurrentRaw |= byTempBuffer;

            *pbyBitMap++ |= byTempBuffer;

            usFreshBits -= usStopBit;
            usOutBits -= usStopBit;
        }
        if (byBlackPixelsInCurrentRaw != 0)
        {
            bWeGotBlackPixels = TRUE;
            usShaveBottom = usRow-1;
        }
        if (!bWeGotBlackPixels) usShaveTop ++;
        usRow--;
    }

    if (usShaveTop == *pusHeight)
    {
        /* the bitmap is completely white */
        usShaveTop = 0;
        usShaveBottom = 0;
    }

    RELEASESFNTFRAG(pClientInfo, pbyTable);

/*      calculate white space on the left    */
    
    pbyBitMap = abyBitRow;
    if (usBitDepth == 1)
    {
        byUpMask = 0x80;
        byLowMask = 0x01;
    } else if (usBitDepth == 2)
    {
        byUpMask = 0xC0;
        byLowMask = 0x03;
    } else if (usBitDepth == 4)
    {
        byUpMask = 0xF0;
        byLowMask = 0x0F;
    } else /* usBitDepth == 8 */
    {
        byUpMask = 0xFF;
        byLowMask = 0xFF;
    }
    byMask = byUpMask;
    usShaveLeft = 0;

    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveLeft++;
        if (usShaveLeft == *pusWidth)
        {
            return NO_ERR;          /* no black found, don't shave */
        }
        byMask >>= usBitDepth;
        if (byMask == 0)
        {
            byMask = byUpMask;
            pbyBitMap++;
        }
    }

/*      calculate white space on the right    */
    
    usStart = (*pusWidth - 1) * usBitDepth;
    pbyBitMap = &abyBitRow[usStart >> 3];
    byMask = byUpMask >> (usStart & 0x0007);
    usShaveRight = 0;
    
    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveRight++;
        if (byMask == byUpMask)
        {
            byMask = byLowMask;
            pbyBitMap--;
        }
        else
        {
            byMask <<= usBitDepth;
        }
    }

/*      correct the width and sidebearing    */

    *pusShaveLeft = usShaveLeft;
    *pusShaveRight = usShaveRight;
    *pusWidth -= usShaveLeft + usShaveRight;
    *psLSBearingX += (int16)usShaveLeft;
    *psTopSBearingX += (int16)usShaveLeft;

    *pusShaveTop = usShaveTop;
    *pusShaveBottom = usShaveBottom;
    *pusHeight -= usShaveTop + usShaveBottom;
    *psLSBearingY -= (int16)usShaveTop;
    *psTopSBearingY -= (int16)usShaveTop;

    return NO_ERR;
}


/**********************************************************************/


/* fetch the bitmap */

/*  Currently supporting the following bdat formats:
    
    1 - Small metrics;  Byte aligned data
    2 - Small metrics;  Bit aligned data
    5 - Const metrics;  Bit aligned data
    6 - Big metrics;    Byte aligned data
    7 - Big metrics;    Bit aligned data
    8 - Small metrics;  Composite data
    9 - Big metrics;    Composite data
*/

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
    sfac_ClientRec *pClientInfo,
    uint16 usBitmapFormat,
    uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
    uint16 usHeight,
    uint16 usWidth,
    uint16 usShaveLeft,                             /* for white space in fmt 5 */
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
    uint16 usXOffset,
    uint16 usYOffset,
    uint16 usDstRowBytes,
    uint16 usBitDepth,
    uint8 *pbyBitMap, 
    uint16 *pusCompCount )
{
    const uint8     *pbyTable;
    const uint8     *pbyBdat;
    uint8           *pbyBitRow;                     /* start of bitmap row */

    uint16          usSrcRowBytes;                  /* bytes per row in bdat */
    ErrorCode       ReturnCode;

    uint16          usBitData;                      /* bdat data read into 16 bits */
    uint16          usOutBits;                      /* num of bits to put to bitmap */
    uint16          usCount;
    uint16          usXOffBytes;
    uint16          usXOffBits;
    uint16          usStartBit;
    uint16          usStopBit;
    int16           sFreshBits;                     /* num of bits read not written */
    uint8           byMask;                         /* for partial bytes */
    
    ReturnCode = sfac_GetDataPtr (
        pClientInfo,                                /* callback etc. */
        ulBitmapOffset,                             /* metrics start */
        ulBitmapLength,                             /* read bitmap data */
        sfnt_BitmapData,                            /* registered tag */
        TRUE,                                       /* should be there */
        (const void**)&pbyTable );                  /* data pointer */
    
    if (ReturnCode != NO_ERR) return ReturnCode;

    pbyBdat = pbyTable;
    *pusCompCount = 0;                              /* usual case */
    
    pbyBitRow = pbyBitMap + (usDstRowBytes * usYOffset);
    usXOffBytes = (usXOffset * usBitDepth) >> 3;
    usXOffBits = (usXOffset * usBitDepth) & 0x07;

    switch(usBitmapFormat)
    {
    case 1:                                         /* byte aligned */
    case 6:
        
        usSrcRowBytes = ((usWidth * usBitDepth) + 7) / 8;

        if (usXOffBits == 0)                         /* if byte aligned */
        {
            while (usHeight > 0)
            {
                pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */

                for (usCount = 0; usCount < usSrcRowBytes; usCount++)
                {
                    *pbyBitMap++ |= *pbyBdat++;
                }
                pbyBitRow += usDstRowBytes;
                usHeight--;
            }
        }
        else                                        /* if offset in x */
        {
            while (usHeight > 0)
            {
                pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
                usBitData = 0;

                for (usCount = 0; usCount < usSrcRowBytes; usCount++)
                {
                    usBitData |= (uint16)*pbyBdat++;
                    *pbyBitMap++ |= (usBitData >> usXOffBits) & 0x00FF;
                    usBitData <<= 8;
                }
                *pbyBitMap |= (usBitData >> usXOffBits) & 0x00FF;
                             
                pbyBitRow += usDstRowBytes;
                usHeight--;
            }
        }
        break;
    
    case 2:                                         /* bit aligned data */
    case 5:
    case 7:
        
        usBitData = 0;                              /* up to 16 bits of bdat */
        sFreshBits = 0;                             /* read & unwritten */
    
        usHeight += usShaveTop;

        while (usHeight > 0)                        /* for each row */
        {
            pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
            usOutBits = usWidth * usBitDepth;
            usStartBit = usXOffBits;
            usStopBit = 8;
            sFreshBits -= (int16)usShaveLeft * usBitDepth;       /* skip the left white bits */

            while (usOutBits > 0)                   /* if more to do */
            {
                while (sFreshBits < 8)              /* if room for fresh data */
                {
                    usBitData <<= 8;
                    if (ulBitmapLength > 0)         /* prevent read past data end */
                    {
                        usBitData |= (uint16)*pbyBdat++;
                        ulBitmapLength--;
                    }
                    sFreshBits += 8;
                }
                
                if (usStopBit > usOutBits + usStartBit)
                {
                    usStopBit = usStartBit + usOutBits;
                }
                byMask = achStartMask[usStartBit] & achStopMask[usStopBit];
                
                *pbyBitMap++ |= (uint8)((usBitData >> (sFreshBits + (int16)usStartBit - 8)) & byMask);

                sFreshBits -= (int16)(usStopBit - usStartBit);
                usOutBits -= usStopBit - usStartBit;
                usStartBit = 0;
            }
            sFreshBits -= (int16)usShaveRight*usBitDepth;      /* skip the right white bits */

            if (usShaveTop == 0)
            {
                pbyBitRow += usDstRowBytes;             /* next row */
            } else {
                usShaveTop --;
            }
            usHeight--;
        }
        break;
    
    case 3:                                         /* various */
    case 4:
        break;
    
    case 8:                                         /* composites */
    case 9:                                         /* just return count */
        
        *pusCompCount = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPCOUNT]));
        break;
    
    default:
        Assert(FALSE);
        break;
    }

    RELEASESFNTFRAG(pClientInfo, pbyTable);
    return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
    sfac_ClientRec *pClientInfo,
    uint16 usComponent,
    uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
    uint16 *pusCompGlyphCode,
    uint16 *pusCompXOffset,
    uint16 *pusCompYOffset
)
{
    const uint8 *   pbyBdat;
    ErrorCode       ReturnCode;

    
    ReturnCode = sfac_GetDataPtr (
        pClientInfo,                                /* callback etc. */
        ulBitmapOffset,                             /* metrics start */
        ulBitmapLength,                             /* read bitmap data */
        sfnt_BitmapData,                            /* registered tag */
        TRUE,                                       /* should be there */
        (const void**)&pbyBdat );                   /* data pointer */
    
    if (ReturnCode != NO_ERR) return ReturnCode;

    pbyBdat += SFNT_BDAT_FIRSTCOMP + (SIZEOF_SBIT_BDATCOMPONENT * usComponent);
        
    *pusCompGlyphCode = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPGLYPH]));
    *pusCompXOffset = (uint16)pbyBdat[SFNT_BDAT_COMPXOFF];
    *pusCompYOffset = (uint16)pbyBdat[SFNT_BDAT_COMPYOFF];

    RELEASESFNTFRAG(pClientInfo, pbyBdat);

    return NO_ERR;
}

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\stat.h ===
/*********************************************************************/
/*                                                                   */
/*    stat.h -- stat.asm exports                                     */
/*                                                                   */
/*    (c) Copyright 1992  Microsoft Corp.  All rights reserved.      */
/*                                                                   */
/*     4/9/96  claudebe adding profiling with IceCAP                 */
/*     2/26/93 deanb    macros come back                             */
/*     2/22/93 deanb    timing switch moved to fsconfig.h macros     */
/*     2/11/93 deanb    __cdecl's for ms C8                          */
/*    12/22/92 deanb    Apple types                                  */
/*    11/20/92 deanb    Timing switches revised                      */
/*    11/17/92 deanb    First cut                                    */
/*                                                                   */
/*********************************************************************/

/* STAT Card Timing Switches */

#ifdef FSCFG_USESTATCARD         /* compile option for profiling */
  #define STAT_ON               gbTimer = TRUE; StartSample();
  #define STAT_OFF              StopSample(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) StartSample();
  #define STAT_OFF_CALLBACK     if (gbTimer) StopSample();
#elif FSCFG_USEICECAP          /* compile option for profiling with IceCAP */
//#include <ICAPExp.h>
  #define STAT_ON               gbTimer = TRUE; StartCAP();
  #define STAT_OFF              StopCAP(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) ResumeCAP();
  #define STAT_OFF_CALLBACK     if (gbTimer) SuspendCAP();
#else
  #define STAT_ON
  #define STAT_OFF
  #define STAT_ON_CALLBACK
  #define STAT_OFF_CALLBACK
#endif

#if 1

#define STAT_ON_NEWSFNT         STAT_ON
#define STAT_OFF_NEWSFNT        STAT_OFF
#define STAT_ON_NEWTRAN         STAT_ON
#define STAT_OFF_NEWTRAN        STAT_OFF
#define STAT_ON_NEWGLYPH        STAT_ON
#define STAT_OFF_NEWGLYPH       STAT_OFF
#define STAT_ON_GRIDFIT         STAT_ON
#define STAT_OFF_GRIDFIT        STAT_OFF
#define STAT_ON_FINDBMS         STAT_ON
#define STAT_OFF_FINDBMS        STAT_OFF
#define STAT_ON_SCAN            STAT_ON
#define STAT_OFF_SCAN           STAT_OFF
#define STAT_ON_FNTEXEC         
#define STAT_OFF_FNTEXEC        
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#else

#define STAT_ON_NEWSFNT
#define STAT_OFF_NEWSFNT
#define STAT_ON_NEWTRAN
#define STAT_OFF_NEWTRAN
#define STAT_ON_NEWGLYPH
#define STAT_OFF_NEWGLYPH
#define STAT_ON_GRIDFIT         STAT_ON         
#define STAT_OFF_GRIDFIT        STAT_OFF         
#define STAT_ON_FINDBMS   
#define STAT_OFF_FINDBMS  
#define STAT_ON_SCAN            
#define STAT_OFF_SCAN           
#define STAT_ON_FNTEXEC
#define STAT_OFF_FNTEXEC
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#endif

/*********************************************************************/

/*              Global timing variable                               */

/*********************************************************************/

extern boolean gbTimer;                /* set true when timer running */

/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


#ifdef FSCFG_USESTATCARD         /* compile option for profiling */

uint16 __cdecl  InitStat( void );

uint16 __cdecl  ConfigElapsed( void );

uint16 __cdecl  ConfigSample( void );

uint16 __cdecl  StartElapsed( void );

uint16 __cdecl  StartSample( void );

uint32 __cdecl  ReadElapsed( void );

uint32 __cdecl  ReadSample( void );

uint16 __cdecl  ReadSample_Count( void );

uint16 __cdecl  StopElapsed( void );

uint16 __cdecl  StopSample( void );

uint16 __cdecl  ResetElapsed( void );

uint16 __cdecl  ResetSample( void );

#endif  /* FSCFG_USESTATCARD */

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\sfntaccs.h ===
/*
    File:       private sfnt.h

    Contains:   xxx put contents here xxx

    Written by: xxx put writers here xxx

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

        <>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
        <>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
        <3+>     7/17/90    MR      Change return types to in for computemapping and readsfnt
         <3>     7/14/90    MR      changed SQRT to conditional FIXEDSQRT2
         <2>     7/13/90    MR      Change parameters to ReadSFNT and ComputeMapping
        <1+>     4/18/90    CL      
         <1>     3/21/90    EMT     First checked in with Mike Reed's blessing.

    To Do:
*/

#include    "sfnt.h"

/* EXPORTED DATA TYPES */

typedef struct {
  uint32    ulOffset;
  uint32    ulLength;
} sfac_OffsetLength;

typedef struct sfac_ClientRec *sfac_ClientRecPtr;

typedef uint16 (*MappingFunc) (const uint8 *, uint16 , sfac_ClientRecPtr);

typedef struct sfac_ClientRec {
    ClientIDType        lClientID;          /* User ID Number                           */
    GetSFNTFunc         GetSfntFragmentPtr; /* User function to eat sfnt                */
    ReleaseSFNTFunc     ReleaseSfntFrag;    /* User function to relase sfnt             */
    int16               sIndexToLocFormat;  /* Format of loca table                     */
    uint32              ulMapOffset;        /* Offset to platform mapping data          */
    sfac_OffsetLength   TableDirectory[sfnt_NUMTABLEINDEX]; /* Table offsets/lengths    */
    uint16              usNumberOf_LongHorMetrics; /* Number of entries in hmtx table   */
    uint16              usNumLongVertMetrics;      /* number of entries with AH         */
    boolean             bValidNumLongVertMetrics; /* true if 'vhea' table exist         */
    uint16              usMappingFormat;    /* format code (0,2,4,6) for mapping func   */
    MappingFunc         GlyphMappingF;      /* mapping function char to glyph           */
    uint16              usGlyphIndex;       /* Current glyph index                      */
    uint16              usFormat4SearchRange; /* Format 4 cached SearchRange            */
    uint16              usFormat4EntrySelector; /* Format 4 cached EntrySelector        */
    uint16              usFormat4RangeShift;/* Format 4 cached Range Shift              */
    /* value for sDefaultAscender and sDefaultDescender comes from TypoAscender and     */
    /* TypoDescender from 'OS/2', if the 'OS/2' is missing, alternate values comes from */
    /* the horizontal header Ascender and Descender                                     */
    int16               sDefaultAscender;
    int16               sDefaultDescender;
    int16               sWinDescender;
} sfac_ClientRec;


/* It would be great if we could make this an opaque data type
// But in this case, the ownership of the memory for the data is the
// responsibility of the owner module. (i.e. sfntaccs.c) This adds
// complications to our model (read: it is much easier to allocate the
// data off the stack of the caller) so we won't implement this for now.
*/

/*  Glyph Handle -- Used for access to glyph data in 'glyf' table   */

typedef struct {
     const void *     pvGlyphBaseAddress; /* Base address of glyph, needed for Release */
     const void *     pvGlyphNextAddress; /* Current position in glyph                    */
     const void *     pvGlyphEndAddress; /* End address of glyph, used to catch glyph corruption */
} sfac_GHandle;

/*  ComponentTypes -- Method used for positioning component in composite    */

typedef enum {
    AnchorPoints,
    OffsetPoints,
    Undefined
} sfac_ComponentTypes;

/* MACROS */

#define SFAC_LENGTH(ClientInfo,Table)  ClientInfo->TableDirectory[(int)Table].ulLength

/* PUBLIC PROTOTYPE CALLS */

/*
 * Creates mapping for finding offset table
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
    sfac_ClientRec *    ClientInfo);    /* Sfnt Client information  */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
    sfac_ClientRec *    ClientInfo,     /* Sfnt Client information      */
    uint16              usPlatformID,   /* Platform Id used for mapping */
    uint16              usSpecificID);  /* Specific Id used for mapping */

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
    sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
    uint16              usCharacterCode);   /* Character code to be mapped  */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
    sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usFirstChar,        /* First char code              */
    uint16 *            pusCharCode,        /* or Pointer to char code list */
    uint16 *            pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
    uint8 *             pbyCmapSubTable,    /* Pointer to cmap sub table    */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usFirstChar,        /* First char code              */
    uint16 *            pusCharCode,        /* or Pointer to char code list */
    uint16 *            pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
    sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
    uint16              numGlyphs,          /* maxp->numGlyphs */
    uint16              usCharCount,        /* Number of chars to convert   */
    uint16              usFirstChar,        /* First char code              */
    uint32              ulCharCodeOffset,   /* Offset to be added to *pulCharCode
                                               before converting            */
    uint32 *            pulCharCode,        /* Pointer to char code list    */
    uint32 *            pulGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
     sfac_ClientRec *   ClientInfo,      /* Sfnt Client information     */
     uint16 *               pusEmResolution,/* Sfnt Em Resolution               */
     boolean *              pbIntegerScaling,/* Sfnt flag for int scaling   */
     LocalMaxProfile *  pMaxProfile);    /* Sfnt Max Profile table      */

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
    sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
    register uint16     glyphIndex,     /* Glyph number for metrics         */
    uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
    uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
    int16 *             psNonScaledLSB,
    int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
    sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
    register uint16     glyphIndex,     /* Glyph number for metrics         */
    uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
    int16 *             psNonScaledLSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
    sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
    register uint16     glyphIndex,     /* Glyph number for metrics         */
    uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
    int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics (
    sfac_ClientRec *    ClientInfo,     /* Sfnt Client information           */
    uint16 *            pusNumLongVertMetrics, /* Entries for which AH exists */
    boolean *           pbValidNumLongVertMetrics ); /* true if 'vhea' table exist  */

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
    sfac_ClientRec *    ClientInfo,     /* Sfnt Client Information  */
    char *              pFontProgram,   /* pointer to Font Program  */
    char *              pPreProgram);   /* pointer to Pre Program   */

FS_PUBLIC ErrorCode sfac_CopyCVT(
    sfac_ClientRec *    ClientInfo,     /* Client Information       */
    F26Dot6 *           pCVT);          /* pointer to CVT           */

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
    sfac_ClientRec *    ClientInfo,     /* Client Information   */
    uint16              usPixelsPerEm,  /* Current Pixels per Em    */
    boolean *           bFound,         /* Flag indicating if entry found */
    uint16              usFirstGlyph,   /* First Glyph to copy */
    uint16              usLastGlyph,    /* Last Glyph to copy */
    int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
    sfac_ClientRec *    ClientInfo,     /* Client Information   */
    uint16              usPixelsPerEm,  /* Current Pixels per Em    */
    uint16              usFirstGlyph,   /* First Glyph to copy */
    uint16              usLastGlyph,    /* Last Glyph to copy */
    int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
    sfac_ClientRec *    ClientInfo,         /* Client Information           */
    uint16              usGlyphIndex,       /* Glyph index to read          */
    sfac_GHandle *      hGlyph,             /* Return glyph handle          */
    boolean *           pbCompositeGlyph,   /* Is glyph a composite?        */
    boolean *           pbHasOutline,       /* Does glyph have outlines?    */
    int16 *             psNumberOfContours, /* Number of contours in glyph  */
    BBOX *              pbbox);             /* Glyph Bounding box           */

FS_PUBLIC ErrorCode sfac_ReadOutlineData(
     uint8 *                abyOnCurve,           /* Array of on curve indicators per point  */
     F26Dot6 *              afxOoy,               /* Array of ooy points for every point         */
     F26Dot6 *              afxOox,               /* Array of oox points for every point         */
     sfac_GHandle *     hGlyph,
     LocalMaxProfile *  maxProfile,       /* MaxProfile Table                                */
     boolean                bHasOutline,          /* Does glyph have outlines?                   */
     int16                  sNumberOfContours,  /* Number of contours in glyph               */
     int16 *                asStartPoints,    /* Array of start points for every contour  */
     int16 *                asEndPoints,          /* Array of end points for every contour   */
     uint16 *               pusSizeOfInstructions, /* Size of instructions in bytes          */
     uint8 **               pbyInstructions,   /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours);    /* total number of contours for composites, to check for overflow */

FS_PUBLIC ErrorCode sfac_ReadComponentData(
    sfac_GHandle *          hGlyph,
    sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets    */
    boolean *               pbRoundXYToGrid,    /* Round composite offsets to grid              */
    boolean *               pbUseMyMetrics,     /* Use component metrics                        */
    boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
    boolean *               pbWeHaveInstructions, /* Composite has instructions                 */
    uint16 *                pusComponentGlyphIndex, /* Glyph index of component                 */
    int16 *                 psXOffset,          /* X Offset of component (if app)               */
    int16 *                 psYOffset,          /* Y Offset of component (if app)               */
    uint16 *                pusAnchorPoint1,    /* Anchor point 1 of component (if app)         */
    uint16 *                pusAnchorPoint2,    /* Anchor point 2 of component (if app)         */
    transMatrix             *pMulT,             /* Transformation matrix for component          */
    boolean *               pbWeHaveAScale,     /* We have a scaling in pMulT                   */
    boolean *               pbLastComponent);   /* Is this the last component?                  */

/*  sfac_ReadCompositeInstructions

    Returns pointer to TrueType instructions for composites.

 */

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
    sfac_GHandle *  hGlyph,
    uint8 **        pbyInstructions,    /* Pointer to start of glyph instructions   */
    uint16 *        pusSizeOfInstructions); /* Size of instructions in bytes        */


/*  sfac_ReleaseGlyph

    Called when access to glyph in 'glyf' table is finished.

 */

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
    sfac_ClientRec *    ClientInfo, /* Sfnt Client Information  */
    sfac_GHandle *      hGlyph);    /* Glyph Handle Information */


/**********************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

#ifndef FSCFG_DISABLE_GRAYSCALE
#define SBIT_BITDEPTH_MASK  0x0116   /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#else

#define SBIT_BITDEPTH_MASK  0x0002   /* support only sbit with bitDepth of 1 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#endif


/*      SFNTACCS Export Prototypes for SBIT      */

FS_PUBLIC ErrorCode sfac_SearchForStrike (
    sfac_ClientRec *pClientInfo,
    uint16 usPpemX, 
    uint16 usPpemY, 
    uint16 usOverScale,            /* outline magnification requested */
    uint16 *pusBitDepth,            /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16 *pusTableState,
    uint16 *pusSubPpemX,
    uint16 *pusSubPpemY,
    uint32 *pulStrikeOffset 
);

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
    sfac_ClientRec *pClientInfo,
    uint16 usGlyphCode,
    uint32 ulStrikeOffset,
    boolean *pbGlyphFound,
    uint16 *pusMetricsType,
    uint16 *pusMetricsTable,
    uint32 *pulMetricsOffset,
    uint16 *pusBitmapFormat,
    uint32 *pulBitmapOffset,
    uint32 *pulBitmapLength
);

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
    sfac_ClientRec *pClientInfo,
    uint16 usMetricsType,
    uint16 usMetricsTable,
    uint32 ulMetricsOffset,
    uint16 *pusHeight,
    uint16 *pusWidth,
    int16 *psLSBearingX,
    int16 *psLSBearingY,
    int16 *psTopSBearingX, /* NEW */
    int16 *psTopSBearingY, /* NEW */
    uint16 *pusAdvanceWidth,
    uint16 *pusAdvanceHeight,  /* NEW */
    boolean *pbHorMetricsFound, /* NEW */
    boolean *pbVertMetricsFound /* NEW */
);

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
    sfac_ClientRec *pClientInfo,
    uint16 usBitmapFormat,
    uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
    uint16 usBitDepth,
    uint16 *pusHeight,
    uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
    int16 *psLSBearingX,
    int16 *psLSBearingY, /* NEW */
    int16 *psTopSBearingX, /* NEW */
    int16 *psTopSBearingY /* NEW */
);

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
    sfac_ClientRec *pClientInfo,
    uint16 usBitmapFormat,
    uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
    uint16 usHeight,
    uint16 usWidth,
    uint16 usShaveLeft,
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
    uint16 usXOffset,
    uint16 usYOffset,
    uint16 usRowBytes,
    uint16 usBitDepth,
    uint8 *pbyBitMap, 
    uint16 *pusCompCount
);

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
    sfac_ClientRec *pClientInfo,
    uint16 usComponent,
    uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
    uint16 *pusCompGlyphCode,
    uint16 *pusCompXOffset,
    uint16 *pusCompYOffset
);


/**********************************************************************/

/*  Results of search for strike's bitmapSizeSubtable   */

#define     SBIT_UN_SEARCHED    0
#define     SBIT_NOT_FOUND      1
#define     SBIT_BLOC_FOUND     2
#define     SBIT_BSCA_FOUND     3

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\sfntoff.h ===
#define BIGDATE_BC      0
#define BIGDATE_AD      4
#define SIZEOF_BIGDATE  8

#define BBOX_XMIN   0
#define BBOX_YMIN   2
#define BBOX_XMAX   4
#define BBOX_YMAX   6
#define SIZEOF_BBOX 8

#define SFNT_DIRECTORYENTRY_TAG         0
#define SFNT_DIRECTORYENTRY_CHECKSUM    4
#define SFNT_DIRECTORYENTRY_TABLEOFFSET 8
#define SFNT_DIRECTORYENTRY_TABLELENGTH 12
#define SIZEOF_SFNT_DIRECTORYENTRY      16

#define SFNT_OFFSETTABLE_VERSION        0
#define SFNT_OFFSETTABLE_NUMOFFSETS     4
#define SFNT_OFFSETTABLE_SEARCHRANGE    6
#define SFNT_OFFSETTABLE_ENTRYSELECTOR  8
#define SFNT_OFFSETTABLE_RANGESHIFT     10
#define SFNT_OFFSETTABLE_TABLE          12
#define SIZEOF_SFNT_OFFSETTABLE         12

#define SFNT_FONTHEADER_VERSION             0
#define SFNT_FONTHEADER_FONTREVISION        4
#define SFNT_FONTHEADER_CHECKSUMADJUSTMENT  8
#define SFNT_FONTHEADER_MAGICNUMBER         12
#define SFNT_FONTHEADER_FLAGS               16
#define SFNT_FONTHEADER_UNITSPEREM          18
#define SFNT_FONTHEADER_CREATED             20
#define SFNT_FONTHEADER_MODIFIED            28
#define SFNT_FONTHEADER_XMIN                36
#define SFNT_FONTHEADER_YMIN                38
#define SFNT_FONTHEADER_XMAX                40
#define SFNT_FONTHEADER_YMAX                42
#define SFNT_FONTHEADER_MACSTYLE            44
#define SFNT_FONTHEADER_LOWESTRECPPEM       46
#define SFNT_FONTHEADER_FONTDIRECTIONHINT   48
#define SFNT_FONTHEADER_INDEXTOLOCFORMAT    50
#define SFNT_FONTHEADER_GLYPHDATAFORMAT     52
#define SIZEOF_SFNT_FONTHEADER              54

#define SFNT_HORIZONTALHEADER_VERSION                           0
#define SFNT_HORIZONTALHEADER_YASCENDER                         4
#define SFNT_HORIZONTALHEADER_YDESCENDER                        6
#define SFNT_HORIZONTALHEADER_YLINEGAP                          8
#define SFNT_HORIZONTALHEADER_ADVANCEWIDTHMAX                   10
#define SFNT_HORIZONTALHEADER_MINLEFTSIDEBEARING                12
#define SFNT_HORIZONTALHEADER_MINRIGHTSIDEBEARING               14
#define SFNT_HORIZONTALHEADER_XMAXEXTENT                        16
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPENUMERATOR     18
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPEDENOMINATOR   20
#define SFNT_HORIZONTALHEADER_RESERVED0                         22
#define SFNT_HORIZONTALHEADER_RESERVED1                         24
#define SFNT_HORIZONTALHEADER_RESERVED2                         26
#define SFNT_HORIZONTALHEADER_RESERVED3                         28
#define SFNT_HORIZONTALHEADER_RESERVED4                         30
#define SFNT_HORIZONTALHEADER_METRICDATAFORMAT                  32
#define SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS           34
#define SIZEOF_SFNT_HORIZONTALHEADER                            36

#define SFNT_HORIZONTALMETRICS_ADVANCEWIDTH     0
#define SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING  2
#define SIZEOF_SFNT_HORIZONTALMETRICS           4

#define SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS            34

#define SFNT_VERTICALMETRICS_ADVANCEHEIGHT      0
#define SFNT_VERTICALMETRICS_TOPSIDEBEARING     2
#define SIZEOF_SFNT_VERTICALMETRICS             4



#define SFNT_CONTROLVALUE 2

#define SFNT_MAPPINGTABLE_FORMAT            0
#define SFNT_MAPPINGTABLE_MAPTABLELENGTH    2
#define SFNT_MAPPINGTABLE_VERSION           4
#define SIZEOF_SFNT_MAPPINGTABLE            6

#define SFNT_PLATFORMENTRY_PLATFORMID       0
#define SFNT_PLATFORMENTRY_SPECIFICID       2
#define SFNT_PLATFORMENTRY_PLATFORMOFFSET   4
#define SIZEOF_SFNT_PLATFORMENTRY           8

#define SFNT_CHAR2INDEXDIRECTORY_VERSION    0
#define SFNT_CHAR2INDEXDIRECTORY_NUMTABLES  2
#define SFNT_CHAR2INDEXDIRECTORY_PLATFORM   4
#define SIZEOF_SFNT_CHAR2INDEXDIRECTORY     4

#define SFNT_SUBHEADER2_FIRSTCODE       0
#define SFNT_SUBHEADER2_ENTRYCOUNT      2
#define SFNT_SUBHEADER2_IDDELTA         4
#define SFNT_SUBHEADER2_IDRANGEOFFSET   6
#define SIZEOF_SFNT_SUBHEADER2          8

#define SFNT_MAPPINGTABLE2_SUBHEADERSKEYS   0
#define SFNT_MAPPINGTABLE2_SUBHEADERS       512
#define SIZEOF_SFNT_MAPPINGTABLE2           512

#define SFNT_MAPPINGTABLE4_SEGCOUNTX2       0
#define SFNT_MAPPINGTABLE4_SEARCHRANGE      2
#define SFNT_MAPPINGTABLE4_ENTRYSELECTOR    4
#define SFNT_MAPPINGTABLE4_RANGESHIFT       6
#define SFNT_MAPPINGTABLE4_ENDCOUNT         8
#define SIZEOF_SFNT_MAPPINGTABLE4           8

#define SFNT_MAPPINGTABLE6_FIRSTCODE    0
#define SFNT_MAPPINGTABLE6_ENTRYCOUNT   2
#define SFNT_MAPPINGTABLE6_GLYPHIDARRAY 4
#define SIZEOF_SFNT_MAPPINGTABLE6       4

#define SFNT_NAMERECORD_PLATFORMID  0
#define SFNT_NAMERECORD_SPECIFICID  2
#define SFNT_NAMERECORD_LANGUAGEID  4
#define SFNT_NAMERECORD_NAMEID      6
#define SFNT_NAMERECORD_NAMELENGTH  8
#define SFNT_NAMERECORD_NAMEOFFSET  10
#define SIZEOF_SFNT_NAMERECORD      12

#define SFNT_NAMINGTABLE_FORMAT         0
#define SFNT_NAMINGTABLE_COUNT          2
#define SFNT_NAMINGTABLE_STRINGOFFSET   4
/*  SFNT_NAMERECORD[COUNT]  */
#define SIZEOF_SFNT_NAMINGTABLE         6

#define SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS    0
#define SFNT_PACKEDSPLINEFORMAT_BBOX                2
#define SFNT_PACKEDSPLINEFORMAT_ENDPOINTS           10
#define SIZEOF_SFNT_PACKEDSPLINEFORMAT              10

#define SFNT_DEVICEMETRICS_VERSION      0
#define SFNT_DEVICEMETRICS_NUMRECORDS   2
#define SFNT_DEVICEMETRICS_RECORDSIZE   4
/* BYTE WIDTHS[NUMGLYPHS+2] * NUMRECORDS */
#define SIZEOF_SFNT_DEVICEMETRICS       8

#define POSTSCRIPTNAMEINDICES_VERSION               0
#define POSTSCRIPTNAMEINDICES_ITALICANGLE           4
#define POSTSCRIPTNAMEINDICES_UNDERLINEPOSITION     8
#define POSTSCRIPTNAMEINDICES_UNDERLINETHICKNESS    10
#define POSTSCRIPTNAMEINDICES_ISFIXEDPITCH          12
#define POSTSCRIPTNAMEINDICES_PAD                   14
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE42          16
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE42          20
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE1           24
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE1           28
#define POSTSCRIPTNAMEINDICES_NUMBERGLYPHS          32
#define GLYPHNAMEINDEX                              34
#define GLYPHNAMEINDEX25                            34
#define SIZEOF_SFNT_POSTSCRIPTINFO                  36

#define SFNT_OS2_VERSION                0
#define SFNT_OS2_XAVGCHARWIDTH          2
#define SFNT_OS2_USWEIGHTCLASS          4
#define SFNT_OS2_USWIDTHCLASS           6
#define SFNT_OS2_FSTYPE                 8
#define SFNT_OS2_YSUBSCRIPTXSIZE        10
#define SFNT_OS2_YSUBSCRIPTYSIZE        12
#define SFNT_OS2_YSUBSCRIPTXOFFSET      14
#define SFNT_OS2_YSUBSCRIPTYOFFSET      16
#define SFNT_OS2_YSUPERSCRIPTXSIZE      18
#define SFNT_OS2_YSUPERSCRIPTYSIZE      20
#define SFNT_OS2_YSUPERSCRIPTXOFFSET    22
#define SFNT_OS2_YSUPERSCRIPTYOFFSET    24
#define SFNT_OS2_YSTRIKEOUTSIZE         26
#define SFNT_OS2_YSTRIKEOUTPOSITION     28
#define SFNT_OS2_SFAMILYCLASS           30
#define SFNT_OS2_PANOSE                 32
#define SFNT_OS2_ULCHARRANGE            42
#define SFNT_OS2_ACHVENDID              58
#define SFNT_OS2_USSELECTION            62
#define SFNT_OS2_USFIRSTCHAR            64
#define SFNT_OS2_USLASTCHAR             66
#define SFNT_OS2_STYPOASCENDER          68
#define SFNT_OS2_STYPODESCENDER         70
#define SFNT_OS2_STYPOLINEGAP           72
#define SFNT_OS2_SWINASCENT             74
#define SFNT_OS2_SWINDESCENT            76
#define SIZEOF_SFNT_OS2                 78

#define SFNT_HDMX_VERSION               0
#define SFNT_HDMX_SNUMRECORDS           2
#define SFNT_HDMX_LSIZERECORD           4
#define SFNT_HDMX_HDMXTABLE             8
#define SIZEOF_SFNT_HDMX                8

#define SFNT_HDMXRECORD_BEMY            0
#define SFNT_HDMXRECORD_BEMX            1
#define SFNT_HDMXRECORD_BWIDTHS         2
#define SIZEOF_SFNT_HDMXRECORD          2

#define SFNT_LTSH_VERSION               0
#define SFNT_LTSH_NUMGLYPHS             2
#define SFNT_LTSH_UBYPELSHEIGHT         4
#define SIZEOF_SFNT_LTSH                4

#define SFNT_MAXPROFILETABLE_VERSION                0
#define SFNT_MAXPROFILETABLE_NUMGLYPHS              4
#define SFNT_MAXPROFILETABLE_MAXPOINTS              6
#define SFNT_MAXPROFILETABLE_MAXCONTOURS            8
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS     10
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS   12
#define SFNT_MAXPROFILETABLE_MAXELEMENTS            14
#define SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS      16
#define SFNT_MAXPROFILETABLE_MAXSTORAGE             18
#define SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS        20
#define SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS     22
#define SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS       24
#define SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS  26
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS   28
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH      30
#define SIZEOF_SFNT_MAXPROFILETABLE 				32

#define SFNT_GASPRANGE_RANGEMAXPPEM 		0
#define SFNT_GASPRANGE_RANGEGASPBEHAVIOR	2
#define SIZEOF_SFNT_GASPRANGE				4

#define SFNT_GASP_VERSION					0
#define SFNT_GASP_NUMRANGES 				2
#define SFNT_GASP_GASPRANGE 				4
#define SIZEOF_SFNT_GASP					4

/**********************************************************************/

/*      Embedded Bitmap (sbit) Table Offsets      */

/**********************************************************************/

/*  Bloc, Bdat and Bsca file constants    */

/*  This first bloc is common to both bloc and bsca tables */

#define     SFNT_BLOC_NUMSIZES               4
#define     SFNT_BLOC_FIRSTSTRIKE            8

#define     SFNT_BLOC_INDEXARRAYOFFSET       0
#define     SFNT_BLOC_NUMINDEXTABLES         8
#define     SFNT_BLOC_COLORREF              12
#define     SFNT_BLOC_STARTGLYPH            40
#define     SFNT_BLOC_ENDGLYPH              42
#define     SFNT_BLOC_PPEMX                 44
#define     SFNT_BLOC_PPEMY                 45
#define     SFNT_BLOC_BITDEPTH              46
#define     SFNT_BLOC_FLAGS                 47
#define     SIZEOF_BLOC_SIZESUBTABLE        48

#define     SFNT_BLOC_FIRSTGLYPH             0
#define     SFNT_BLOC_LASTGLYPH              2
#define     SFNT_BLOC_ADDITIONALOFFSET       4
#define     SIZEOF_BLOC_INDEXARRAY           8

#define     SFNT_BLOC_INDEXFORMAT            0
#define     SFNT_BLOC_IMAGEFORMAT            2
#define     SFNT_BLOC_IMAGEOFFSET            4
#define     SFNT_BLOC_OFFSETARRAY            8

#define     SFNT_BLOC_IDX2IMAGESIZE          8
#define     SFNT_BLOC_IDX2METRICS           12

#define     SFNT_BLOC_IDX4NUMGLYPHS          8
#define     SFNT_BLOC_IDX4OFFSETARRAY       12

#define     SFNT_BLOC_IDX4CODE               0
#define     SFNT_BLOC_IDX4OFFSET             2
#define     SIZEOF_CODEOFFSETPAIR            4
                
#define     SFNT_BLOC_IDX5IMAGESIZE          8
#define     SFNT_BLOC_IDX5METRICS           12
#define     SFNT_BLOC_IDX5NUMGLYPHS         20
#define     SFNT_BLOC_IDX5CODEARRAY         24

#define     SFNT_SBIT_HEIGHT                 0
#define     SFNT_SBIT_WIDTH                  1
#define     SFNT_SBIT_BEARINGX               2
#define     SFNT_SBIT_BEARINGY               3
#define     SFNT_SBIT_ADVANCE                4
#define     SFNT_SBIT_VERTBEARINGX           5
#define     SFNT_SBIT_VERTBEARINGY           6
#define     SFNT_SBIT_VERTADVANCE            7
#define     SIZEOF_SBIT_SMALLMETRICS         5
#define     SIZEOF_SBIT_BIGMETRICS           8

#define     SFNT_BDAT_COMPCOUNT              0
#define     SIZEOF_SBIT_GLYPH8PAD            1
#define     SFNT_BDAT_FIRSTCOMP              2

#define     SFNT_BDAT_COMPGLYPH              0
#define     SFNT_BDAT_COMPXOFF               2
#define     SFNT_BDAT_COMPYOFF               3
#define     SIZEOF_SBIT_BDATCOMPONENT        4

#define     SFNT_BSCA_NUMSIZES               4
#define     SFNT_BSCA_FIRSTSTRIKE            8

#define     SFNT_BSCA_PPEMX                 24
#define     SFNT_BSCA_PPEMY                 25
#define     SFNT_BSCA_SUBPPEMX              26
#define     SFNT_BSCA_SUBPPEMY              27
#define     SIZEOF_BSCA_SIZESUBTABLE        28

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\i386\math386.asm ===
;*********************************************************************
;    
;   FONTMATH.ASM -- TT Rasterizer Assembly Optimization Math Functions
;
;   3/02/93     deanb   David Cutler's FracSqrt (slightly modified)
;   2/25/93     deanb   CompMul and CompDiv implementation
;
;*********************************************************************

;.386P
;.model FLAT
        .386
        .model  small

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        extrn   _function:dword

_TEXT   SEGMENT USE32 PUBLIC 'CODE'


;********************************************************************


PUBLIC  @FracSqrt@4

;   at entry:   ecx =  2.30 radicand
;   at exit:    eax =  2.30 square root
;
; Routine Description:
;
;    This function computes the square root of a 2.30 fractional (2.30)
;    number.
;
;    N.B. This algorithm produces results that are 100% compatible with
;         the portable True Type version. If this constraint were relaxed,
;         i.e., as under Win 3.1, then a faster algorithm could be used.
;

@FracSqrt@4 PROC NEAR
		push    esi
		push    edi
		push    ebx

		mov     eax,ecx                 ; get the input argument value
		or      eax,eax                 ; check is argument is zero or negative
		jle     short FsxfZeroNeg       ; jump if zero or negative

;
; Test for the two special cases that would result in a one bit error in
; least significant digit of the result.
;
		
		cmp     eax,3fffffffh           ; check for first special case
		je      short FsxfExit          ; if zf set, first special case
		cmp     eax,40000001h           ; check for second special case
		je      short FsxfSpecial       ; if zf set, second special case

		xor     ecx,ecx                 ; exponent counter

FsxfNormalize:                          ; this loop should be very fast
		inc     ecx                     ; since most arguments are
		add     eax,eax                 ; nearly normalized at input
		jns     FsxfNormalize

		dec     ecx
		shr     eax,1
;
; If the exponent is odd, then use the odd square root table to estimate
; the first approximation. Otherwise, use the even square root table to
; estimate the first approximation. The exponent of the result is the
; normalize shift divided by two.
;

		mov     esi,eax                 ; copy the operand for extraction
		mov     edi,eax                 ;
		shr     eax,23                  ; isolate table index value
		and     eax,7fh                 ;
		shr     ecx,1                   ; compute result exponent
		jnc     short FsxfEven          ; if cf clear, use even table

;
; The exponent is odd.
;

FsxfOdd:
		shr     esi,3                   ; shift high part into place
		shl     edi,29                  ; shift low part into place
		mov     ebx,FsEstimateTableOdd[eax*4] ; get first estimate value
		jmp     short FsxfFinish        ; finish in common code

;
; The exponent is even.
;

FsxfEven:
		shr     esi,2                   ; shift high part into place
		shl     edi,30                  ; shift low part into place
		mov     ebx,FsEstimateTableEven[eax*4] ; get first estimate value

;
; Perform three iterations of Newton's formula:
;
; X' = (X + N / X) / 2
;
; extract the result and round.
;

FsxfFinish:
		mov     edx,esi                 ; set high part of dividend
		mov     eax,edi                 ; set low part of dividend
		div     ebx                     ; compute first quotient
		add     ebx,eax                 ; add first estimate and average
		shr     ebx,1                   ;
		mov     edx,esi                 ; set high part of dividend
		mov     eax,edi                 ; set low part of dividend
		div     ebx                     ; compute second quotient
		add     ebx,eax                 ; add second estimate and average
		shr     ebx,1                   ;
		mov     edx,esi                 ; set high part of dividend
		mov     eax,edi                 ; set low part of dividend
		div     ebx                     ; compute third quotient
		add     ebx,eax                 ; add third estimate and average
		mov     eax,ebx                 ; copy estimate value scaled by two
		shr     eax,1                   ; average last estimate and extract
		shl     ebx,31                  ; possible rounding bit
		shrd    ebx,eax,cl              ; extract insignificant bits
		shr     eax,cl                  ; shift final result into position
		shr     ebx,31                  ; shift round bit into low bit position
		add     eax,ebx                 ; round result

FsxfExit:        
		pop     ebx
		pop     edi
		pop     esi
		ret

;
; The input value is zero or negative.
;

FsxfZeroNeg:
		jz      short FsxfExit          ; if zero, return zero
		mov     eax,80000001h           ; if negative, return negative infinity

;
; The input value is the special case 40000001h.
;

FsxfSpecial:
		dec     eax                     ; convert to compatible value
		jmp     short FsxfExit          ; finish in common code

@FracSqrt@4 ENDP

_TEXT   ENDS

	.data








;
; First Estimate Tables
;

FsEstimateTableOdd equ  this dword
		dd      2d413ccdh, 2d6e6780h, 2d9b6577h, 2dc83738h
		dd      2df4dd43h, 2e215817h, 2e4da830h, 2e79ce0ah
		dd      2ea5ca1bh, 2ed19cdah, 2efd46bbh, 2f28c82eh
		dd      2f5421a3h, 2f7f5388h, 2faa5e49h, 2fd5424eh
		dd      30000000h, 302a97c5h, 30550a01h, 307f5717h
		dd      30a97f67h, 30d38351h, 30fd6332h, 31271f67h
		dd      3150b84ah, 317a2e34h, 31a3817dh, 31ccb27bh
		dd      31f5c183h, 321eaee8h, 32477afch, 32702611h
		dd      3298b076h, 32c11a79h, 32e96467h, 33118e8ch
		dd      33399933h, 336184a6h, 3389512dh, 33b0ff10h
		dd      33d88e94h, 34000000h, 34275397h, 344e899dh
		dd      3475a254h, 349c9dfeh, 34c37cdah, 34ea3f29h
		dd      3510e528h, 35376f16h, 355ddd2fh, 35842fb0h
		dd      35aa66d3h, 35d082d2h, 35f683e8h, 361c6a4dh
		dd      36423639h, 3667e7e3h, 368d7f81h, 36b2fd49h
		dd      36d86170h, 36fdac2bh, 3722ddadh, 3747f629h
		dd      376cf5d1h, 3791dcd6h, 37b6ab6bh, 37db61beh
		dd      38000000h, 38248660h, 3848f50ch, 386d4c32h
		dd      38918c00h, 38b5b4a2h, 38d9c645h, 38fdc114h
		dd      3921a53ah, 394572e3h, 39692a37h, 398ccb60h
		dd      39b05689h, 39d3cbd8h, 39f72b77h, 3a1a758dh
		dd      3a3daa41h, 3a60c9bah, 3a83d41dh, 3aa6c992h
		dd      3ac9aa3ch, 3aec7642h, 3b0f2dc7h, 3b31d0efh
		dd      3b545fdfh, 3b76dabah, 3b9941a2h, 3bbb94b9h
		dd      3bddd423h, 3c000000h, 3c221872h, 3c441d9ah
		dd      3c660f99h, 3c87ee8eh, 3ca9ba9ah, 3ccb73dch
		dd      3ced1a73h, 3d0eae7fh, 3d30301dh, 3d519f6dh
		dd      3d72fc8bh, 3d944795h, 3db580aah, 3dd6a7e4h
		dd      3df7bd63h, 3e18c140h, 3e39b39ah, 3e5a948bh
		dd      3e7b642fh, 3e9c22a1h, 3ebccffch, 3edd6c5ah
		dd      3efdf7d7h, 3f1e728ch, 3f3edc93h, 3f5f3606h
		dd      3f7f7efdh, 3f9fb793h, 3fbfdfe0h, 3fdff7fch

FsEstimateTableEven equ this dword
		dd      40000000h, 403fe020h, 407f80feh, 40bee354h
		dd      40fe07d9h, 413cef41h, 417b9a3ch, 41ba0977h
		dd      41f83d9bh, 4236374fh, 4273f736h, 42b17df2h
		dd      42eecc1fh, 432be258h, 4368c136h, 43a5694eh
		dd      43e1db33h, 441e1776h, 445a1ea3h, 4495f146h
		dd      44d18fe9h, 450cfb12h, 45483345h, 45833905h
		dd      45be0cd2h, 45f8af29h, 46332087h, 466d6166h
		dd      46a7723eh, 46e15384h, 471b05adh, 4754892bh
		dd      478dde6eh, 47c705e6h, 48000000h, 4838cd26h
		dd      48716dc3h, 48a9e23fh, 48e22b00h, 491a486bh
		dd      49523ae4h, 498a02cdh, 49c1a086h, 49f9146fh
		dd      4a305ee5h, 4a678044h, 4a9e78e9h, 4ad5492ch
		dd      4b0bf165h, 4b4271edh, 4b78cb1ah, 4baefd3fh
		dd      4be508b1h, 4c1aedc1h, 4c50acc3h, 4c864604h
		dd      4cbbb9d6h, 4cf10885h, 4d26325fh, 4d5b37afh
		dd      4d9018c1h, 4dc4d5deh, 4df96f50h, 4e2de55eh
		dd      4e623850h, 4e96686bh, 4eca75f6h, 4efe6133h
		dd      4f322a67h, 4f65d1d4h, 4f9957bch, 4fccbc60h
		dd      50000000h, 503322dbh, 50662531h, 5099073dh
		dd      50cbc93fh, 50fe6b71h, 5130ee10h, 51635155h
		dd      5195957ch, 51c7babeh, 51f9c153h, 522ba973h
		dd      525d7356h, 528f1f32h, 52c0ad3eh, 52f21dafh
		dd      532370b9h, 5354a691h, 5385bf6bh, 53b6bb7ah
		dd      53e79aefh, 54185dfdh, 544904d6h, 54798fa9h
		dd      54a9fea7h, 54da5200h, 550a89e3h, 553aa67fh
		dd      556aa801h, 559a8e97h, 55ca5a6eh, 55fa0bb3h
		dd      5629a293h, 56591f37h, 568881cdh, 56b7ca7eh
		dd      56e6f975h, 57160edch, 57450adbh, 5773ed9dh
		dd      57a2b749h, 57d16807h, 58000000h, 582e7f5ah
		dd      585ce63dh, 588b34ceh, 58b96b34h, 58e78995h
		dd      59159016h, 59437edbh, 5971560ah, 599f15c6h
		dd      59ccbe34h, 59fa4f77h, 5a27c9b2h, 5a552d07h

;********************************************************************


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\cvt.h ===
/******************************Module*Header*******************************\
* Module Name: cvt.h
*
* function declarations that are private to cvt.c
*
* Created: 26-Nov-1990 17:39:35
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
\**************************************************************************/


BOOL bGetTagIndex
(
ULONG  ulTag,      // tag
INT   *piTable,    // index into a table
BOOL  *pbRequired  // requred or optional table
);

BOOL bGrabXform
(
PFONTCONTEXT pfc,
USHORT usOverScale,
BOOL  bBitmapEmboldening
,BOOL   bClearType
);


typedef struct _GMC  // Glyph Metrics Corrections
{
// corrections to top, bottom and cx:

    ULONG dyTop;        // (yTop < pfc->yMin) ? (pfc->yMin - yTop) : 0;
    ULONG dyBottom;     // (yBottom > pfc->Max) ? (yBottom - pfc->Max):0;

    ULONG dxLeft;
    ULONG dxRight;

// corrected values (using the corrections above)

    ULONG cxCor;
    ULONG cyCor;


} GMC, *PGMC;

#define FL_SKIP_IF_BITMAP  1
#define FL_FORCE_UNHINTED  2

// iMode is used in the case the user select a specific overScale (QFD_TT_GRAY1_BITMAP to QFD_TT_GRAY8_BITMAP)
// to be able to set the overScale in the font context correctely

FONTCONTEXT *ttfdOpenFontContext (
    FONTOBJ *pfo
    );

#if DBG
#define IS_GRAY(p) ((((p)->flFontType & FO_CHOSE_DEPTH) ? \
    0 : TtfdDbgPrint("Level Not chosen yet\n")) ,(p)->flFontType & FO_GRAY16)
#else
#define IS_GRAY(p) ((p)->flFontType & FO_GRAY16)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\fdfc.c ===
/******************************Module*Header*******************************\
* Module Name: fdfc.c                                                      *
*                                                                          *
* Open,Close,Reset Font Context                                            *
*                                                                          *
* Created: 18-Nov-1991 11:55:38                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
#include "winfont.h"

#if DBG
// #define DBG_XFORM
extern ULONG gflTtfdDebug;
ULONG gflTtfdDebug = 0;
#endif

STATIC BOOL bNewXform
(
FONTOBJ      *pfo,            // IN
PFONTCONTEXT  pfc             // OUT
);


STATIC BOOL bComputeMaxGlyph(PFONTCONTEXT pfc);

#define CVT_TRUNCATE  0x00000001
#define CVT_TO_FIX    0X00000002

STATIC BOOL bFloatToL(FLOATL e, PLONG pl);
STATIC Fixed fxPtSize(PFONTCONTEXT pfc);
STATIC BOOL ttfdCloseFontContext(FONTCONTEXT *pfc);
STATIC VOID vFindHdmxTable(PFONTCONTEXT pfc);
STATIC ULONG iHipot(LONG x, LONG y);
LONG lFFF(LONG l);


#define FFF(e,l) *(LONG*)(&(e)) = lFFF(l)

#define MAX_BOLD 56

/******************************Public*Routine******************************\
*
* BOOL bInitInAndOut
*
*
* History:
*  18-Nov-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bInitInAndOut(FONTFILE *pff)
{
    FS_ENTRY           iRet;
    fs_GlyphInputType *pgin;
    fs_GlyphInfoType  *pgout;

    ASSERTDD(pff->pj034 != NULL, "pff->pj3 IS null\n");

    pgin  = (fs_GlyphInputType *)pff->pj034;
    pgout = (fs_GlyphInfoType  *)(pff->pj034 + CJ_IN);

    if ((iRet = fs_OpenFonts(pgin, pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        return (FALSE);
    }

    pgin->memoryBases[0] = (char *)(pff->pj034 + CJ_IN + CJ_OUT);
    pgin->memoryBases[1] = NULL;
    pgin->memoryBases[2] = NULL;

// initialize the font scaler, notice no fields of pfc->gin are initialized [BodinD]

    if ((iRet = fs_Initialize(pgin, pgout)) != NO_ERR)
    {
    // clean up and return:

        V_FSERROR(iRet);
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_Initialize \n");
    }

// initialize info needed by NewSfnt function

    pgin->sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of the ttf file

    pgin->clientID = (ULONG_PTR)pff; // pointer to FONTFILE.

    pgin->GetSfntFragmentPtr = pvGetPointerCallback;
    pgin->ReleaseSfntFrag  = vReleasePointerCallback;

    pgin->param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
    pgin->param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

    if ((iRet = fs_NewSfnt(pgin, pgout)) != NO_ERR)
    {
    // clean up and exit

        V_FSERROR(iRet);
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_NewSfnt \n");
    }

// sizes 3 and 4 returned

    ASSERTDD(pff->ffca.cj3 == (ULONG)NATURAL_ALIGN(pgout->memorySizes[3]), "cj3\n");
    ASSERTDD(pff->ffca.cj4 == (ULONG)NATURAL_ALIGN(pgout->memorySizes[4]), "cj4\n");

// pj3 should  be shareable, but unfortunately there are fonts that
// use it to store some info there which they expect to find there at
// later times, so we have to make pj3 private as well

    pgin->memoryBases[3] = pff->pj034 + (CJ_IN + CJ_OUT + CJ_0);

// not shared, private

    pgin->memoryBases[4] = pgin->memoryBases[3] + pff->ffca.cj3;

    return TRUE;
}

/******************************Public*Routine******************************\
*
* void vCalcEmboldSize
*
* We only support embold enhancemet in FE font.
* The basic rule is 2% extended from normal font.
*
* History:
*  14-May-1997 -by- Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/


void vCalcEmboldSize(FONTCONTEXT * pfc)
{
    USHORT dDesc;

// we always shift glyphs in the direction of baseline and then in
// the direction opposite from ascender direction.
// That is the full shift vector is
//
// dv = dBase * pteUnitBase - dDesc * pteUnitSide;
//
// where dBase and dDesc are positive.
// We decompose this vector along x and y axes to get it in the form
//
// dv = dxBold * Ex + dyBold * Ey; // Ex, Ey unit vectors in x,y directions
//
// we shall use the win95-J compatible algorithm where
// we will shift bitmpas (((2%+1) right X 2% down)) algorithm
//
// The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
// for an emboldening factor of 2%

    dDesc = (USHORT)((pfc->lEmHtDev * 2 - 1) / 100);

// dBase is always at least 1, we do not compute it based on width

    pfc->dBase = dDesc + 1;

}


/******************************Public*Routine******************************\
*
* Find minimal non-zero advance width
*
* Called by:       ttfdOpenFontContext
*
* Routines called: bGetTablePointers
*
* History:
*  02-May-1996 [kirko]
* Added checking for table corruption.
*  22-Feb-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID  vGetMinD(FONTFILE *pff)
{
    extern PBYTE pjTable(ULONG, PFONTFILE, ULONG*);
    extern BOOL bGetTablePointers(ULONG, BYTE*, TABLE_POINTERS*);

    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    ULONG  cHMTX;

    BYTE  *pjView;

    ULONG  ig;
    ULONG  igMin = 0;
    USHORT usMinWidth = 0xffff;
    USHORT usWidth;


    pjView = (BYTE *)pff->pvView;
    ASSERTDD(pjView, "pjView is NULL 1\n");
    ASSERTDD(pff->ffca.igMinD == USHRT_MAX, "igMinD is bogus \n");

    phhea = (sfnt_HorizontalHeader *)(pjView + pff->ffca.tp.ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pff->ffca.tp.ateReq[IT_REQ_HMTX].dp);

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);

    for (ig = 0; ig < cHMTX; ig++)
    {
        usWidth = BE_UINT16(&phmtx[ig].advanceWidth);
        if ((usWidth < usMinWidth) && (usWidth != 0))
        {
            usMinWidth = usWidth;
            igMin = ig;
        }
    }

// store the results

    pff->ffca.usMinD = usMinWidth;
    pff->ffca.igMinD = (USHORT)igMin;
}

/******************************Public*Routine******************************\
* ttfdOpenFontContext                                                      *
*                                                                          *
* History:                                                                 *
*  11-Nov-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/


FONTCONTEXT *ttfdOpenFontContextInternal(FONTOBJ *pfo)
{
    PFONTCONTEXT  pfc   = PFC(NULL);
    PTTC_FONTFILE pttc  = (PTTC_FONTFILE)pfo->iFile;
    ULONG         iFace = pfo->iFace;
    ULONG_PTR     iFile;
    PFONTFILE     pff;

    if (!pttc)
        return((FONTCONTEXT *) NULL);

    ASSERTDD(
        iFace <= pttc->ulNumEntry,
        "gdisrv!ttfdOpenFontContextTTC(): ulFont out of range\n"
        );

    iFile = PFF(pttc->ahffEntry[0].hff)->iFile;

    if (pttc->cRef == 0)
    {
    // have to remap the file

        if
        (
            !EngMapFontFileFD(
                iFile,
                (PULONG*)&pttc->pvView,
                &pttc->cjView
                )
        )
        {
            RETURN("TTFD!_bMapTTF, somebody removed a ttf file\n",NULL);
        }
    }

    // Get FONTFILE structure.

    pff = PFF(pttc->ahffEntry[iFace-1].hff);

    if (pff->cRef == 0)
    {
    // Update FILEVIEW structure in FONTFILE

        pff->pvView = pttc->pvView;
        pff->cjView = pttc->cjView;

    // We have precomputed all sizes and we are allocating all memory at once:

        ASSERTDD(pff->pj034 == NULL, "TTFD, pff->pj034 should be null\n");

        if
        (
            !(pff->pj034 = (PBYTE)PV_ALLOC(
                                    CJ_IN    +
                                    CJ_OUT   +
                                    CJ_0     +
                                    pff->ffca.cj3 +
                                    pff->ffca.cj4
                                    ))
        )
        {
            if(pttc->cRef == 0)
                EngUnmapFontFileFD(iFile);
            RETURN("ttfd, MEM Alloc  failed for pj034\n", NULL);
        }

        if (!bInitInAndOut(pff)) // could cause the exception
        {
            if(pttc->cRef == 0)
                EngUnmapFontFileFD(iFile);
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
            RETURN("ttfd, bInitInAndOut failed for \n", NULL);
        }

    // check if ffca.usMinD has been initialized, if not do it

        if (!pff->ffca.usMinD)
            vGetMinD(pff);
    }

// allocate memory for the font context and get the pointer to font context

    ASSERTDD(!pff->pfcToBeFreed, "TTFD!ttfdOpenFontContext, pfcToBeFreed NOT null\n");

    if ((pff->pfcToBeFreed = pfc = pfcAlloc(sizeof(FONTCONTEXT))) ==
        (FONTCONTEXT *) NULL )
    {
        WARNING("TTFD!_ttfdOpenFontContext, hfcAlloc failed\n");
        if (pttc->cRef == 0)
            EngUnmapFontFileFD(iFile);
        if (pff->cRef == 0)
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
        return((FONTCONTEXT *) NULL);
    }

// state that the hff passed to this function is the FF selected in
// this font context

    pfc->pfo = pfo;
    pfc->pff = pff;
    pfc->ptp = &pff->ffca.tp;

// parts of FONTOBJ that are important

    pfc->flFontType   = pfo->flFontType  ;
    pfc->sizLogResPpi = pfo->sizLogResPpi;
    pfc->ulStyleSize  = pfo->ulStyleSize ;

// tt strucs

    pfc->pgin  = (fs_GlyphInputType *) pfc->pff->pj034;
    pfc->pgout = (fs_GlyphInfoType  *) (pfc->pff->pj034 + CJ_IN);

// 2,4,6... (n*2) is Vertical face.

    pfc->bVertical = (pttc->ahffEntry[iFace-1].iFace & 0x1) ? FALSE : TRUE;

// given the values in the context info store the transform matrix:



    if (!bNewXform(pfo,pfc))
    {
    // clean up and exit

        WARNING("TTFD!_ttfdOpenFontContext, bNewXform\n");

        vFreeFC(pfc);
        pff->pfcToBeFreed = NULL;

        if (pttc->cRef == 0)
            EngUnmapFontFileFD(iFile);
        if (pff->cRef == 0)
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
        return((FONTCONTEXT *) NULL);
    }

    pfc->ulControl = 0;

// setting up of the overScale to a default value

    pfc->overScale = FF_UNDEFINED_OVERSCALE;

// increase the reference count of the font file, WE DO THIS ONLY WHEN
// WE ARE SURE that can not fail any more
// we have pfc, no exceptions any more

// now that we have pfc, we do not want to delete it

    pff->pfcToBeFreed = NULL;

    (pff->cRef)++;
    (pttc->cRef)++;

    return(pfc);
}

/**************************Public*Routine****************************\
* ttfdOpenFontContext                                                *
*                                                                    *
* History:                                                           *
*  07-Jan-1999 -by- Xudong Wu [tessiew]                              *
* Wrote it.                                                          *
\********************************************************************/
FONTCONTEXT *ttfdOpenFontContext(FONTOBJ *pfo)
{
    FONTCONTEXT *pfc;

#ifndef TTFD_NO_TRY_EXCEPT
    VOID vMarkFontGone(TTC_FONTFILE*, DWORD);
    DWORD iExcCode;
    TTC_FONTFILE *pttc = (TTC_FONTFILE *)pfo->iFile;

    try 
    {
#endif
        pfc = ttfdOpenFontContextInternal(pfo);
#ifndef TTFD_NO_TRY_EXCEPT
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("TTFD!_ exception in ttfdOpenFontContext\n");

        vMarkFontGone(pttc, iExcCode = GetExceptionCode());
        if (pttc && (pttc->cRef == 0) && (iExcCode == STATUS_IN_PAGE_ERROR))
        {
            EngUnmapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile);
        }
        pfc = NULL;
    }
#endif

    return pfc;
}

/******************************Public*Routine******************************\
*
* ttfdCloseFontContext
*
*
* Effects:
*
*
* History:
*  11-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
ttfdCloseFontContext (
    FONTCONTEXT *pfc
    )
{
    PTTC_FONTFILE pttc;
    PFONTFILE     pff;

    if (pfc == (FONTCONTEXT *) NULL)
        return(FALSE);

    pff  = pfc->pff;
    pttc = pfc->pff->pttc;

// decrement the reference count for the corresponding FONTFILE

    ASSERTDD(pff->cRef > 0L, "TTFD!_CloseFontContext: cRef <= 0 \n");

    pff->cRef--;
    pttc->cRef--;

// if this was the last fc that last used the buffer at pj3, invalidate
// the associated pfcLast

    if (pff->pfcLast == pfc)
        pff->pfcLast = PFC(NULL);

// in case that this is happening after the exception, make sure to release
// any memory that may have possibly been allocated to perform queries
// on per character basis:

    if (pttc->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // if exception this memory has already been freed

        ASSERTDD(!pff->pj034, "\n TTFD! pff->pj3 is NOT null\n");

        if (pfc->gstat.pv) // this may or may have not been allocated
        {
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;
        }
    }
    else
    {
        ASSERTDD(pff->pj034, "\n TTFD! pff->pj3 is null\n");
    }

    if (pff->cRef == 0)
    {
    // there are no fc's  around to use memory at pff->pj3, release it.

        if (!(pttc->fl & FF_EXCEPTION_IN_PAGE_ERROR))
        {
            V_FREE(pff->pj034);
            pff->pj034 = (BYTE *)NULL;
        }
    }

    if (pttc->cRef == 0)
    {
    // file will not be used for a while,

        EngUnmapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile);
    }

// free the memory associated with hfc

    vFreeFC(pfc);
    return(TRUE);
}

/******************************Public*Routine******************************\
* ttfdDestroyFont
*
* Driver can release all resources associated with this font realization
* (embodied in the FONTOBJ).
*
* History:
*  27-Oct-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
ttfdDestroyFont (
    FONTOBJ *pfo
    )
{
// For the ttfd, this is simply closing the font context.
// We cleverly store the font context handle in the FONTOBJ pvProducer
// field.

// pfo->pvProducer COULD BE null if exception occured while trying to create fc

    if (pfo->pvProducer)
    {
        ttfdCloseFontContext((FONTCONTEXT *) pfo->pvProducer);
        pfo->pvProducer = NULL;
    }
}


/******************************Public*Routine******************************\
* ttfdFree
*
*
* Effects:
*
* Warnings:
*
* History:
*  27-Oct-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
ttfdFree (
    PVOID pv,
    ULONG_PTR id
    )
{
    DYNAMICDATA *pdd;

//
// If id is NULL, then we can ignore.
//
    if ( (pdd = (DYNAMICDATA *) id) == (DYNAMICDATA *) NULL )
        return;

// What kind of data?
//
    switch (pdd->ulDataType)
    {
    case ID_KERNPAIR:

    // Invalidate the cached pointer to the data.

         pdd->pff->pkp = NULL; // important to check at vUnloadFontFile time

    // Free the kerning pair buffer and DYNAMICDATA structure.

        pv;    // we ignore pv because it is part of the mem allocated with DYNAMICDATA structure.
        V_FREE(pdd);    // this frees both the DYNAMICDATA struct and the FD_KERNINGPAIR buffer.

        break;

    default:
    //
    // Don't do anything.
    //
        RIP("TTFD!_ttfdFree ulDataType of unknown type\n");
        break;
    }
}


/******************************Public*Routine******************************\
*
* bSetXform
*
* the only reason this funcion can fail is if fs_NewTransformation has failed
* Needs to be called when the transform has changed relative to the
* transform stored in this fc
*
* History:
*  28-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL bSetXform (
    PFONTCONTEXT  pfc,
    BOOL bBitmapEmboldening
    ,BOOL bClearType
    )
{
    FS_ENTRY    iRet;
    transMatrix mx = pfc->mx;
    Fixed       fxScale;
    LONG        ptSize;

// no previous glyph metric computation can be used

    vInitGlyphState(&pfc->gstat);

// if an illegal junk is passed for style size replace by reasonable default

    if (pfc->ulStyleSize > SHRT_MAX)
        pfc->ulStyleSize = 0;

    pfc->pgin->param.newtrans.xResolution = (int16)pfc->sizLogResPpi.cx;
    pfc->pgin->param.newtrans.yResolution = (int16)pfc->sizLogResPpi.cy;

    if (pfc->flXform & XFORM_SINGULAR)
    {
    // just put in some junk so that the preprogram does not explode

        pfc->pgin->param.newtrans.pointSize = LTOF16_16(12);

        mx.transform[0][0] = LTOF16_16(1);
        mx.transform[1][0] = 0;
        mx.transform[1][1] = LTOF16_16(1);
        mx.transform[0][1] = 0;
    }
    else
    {
        if (pfc->flXform & XFORM_HORIZ)
        {
            if (pfc->ulStyleSize == 0)
            {
            // hinting is determined by ptSize that corresponds to the
            // actual height in points of the font

                pfc->pgin->param.newtrans.pointSize = pfc->fxPtSize;

            // factor out pointSize from the xform:

                if (pfc->mx.transform[1][1] > 0)
                    mx.transform[1][1] = LTOF16_16(1);
                else
                    mx.transform[1][1] = LTOF16_16(-1);

                if
                (
                    (pfc->mx.transform[1][1] == pfc->mx.transform[0][0])
                    &&
                    (pfc->sizLogResPpi.cy == pfc->sizLogResPpi.cx)
                )
                {
                // important special case, simplify computation

                    mx.transform[0][0] = mx.transform[1][1];
                }
                else // general case
                {
                    fxScale = LongMulDiv(
                                 LTOF16_16(pfc->pff->ffca.ui16EmHt),pfc->sizLogResPpi.cy,
                                 pfc->lEmHtDev * pfc->sizLogResPpi.cx
                                 );

                    mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);
                }
            }
            else
            {
            // This is the support for new optical scaling feature.
            // Hint the font as determined by the style point size from
            // ExtLogFont,  but possibly zoom the font to a different
            // physical size

                pfc->pgin->param.newtrans.pointSize =
                    (Fixed)LTOF16_16(pfc->ulStyleSize);

            // factor out pointSize from the xform:

                fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                             pfc->ulStyleSize * pfc->sizLogResPpi.cx
                             );

                mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);

                if (pfc->sizLogResPpi.cy != pfc->sizLogResPpi.cx)
                {
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                  pfc->ulStyleSize * pfc->sizLogResPpi.cy
                                  );
                }

                mx.transform[1][1] = FixMul(mx.transform[1][1], fxScale);
            }
        }
        else
        {
            if (pfc->ulStyleSize == 0)
            {
            // compute the physical point size

                ptSize = F16_16TOLROUND(pfc->fxPtSize);
                pfc->pgin->param.newtrans.pointSize = pfc->fxPtSize;
            }
            else // use style size from logfont, the support for optical scaling
            {
                ptSize = pfc->ulStyleSize;
                pfc->pgin->param.newtrans.pointSize = LTOF16_16(pfc->ulStyleSize);
            }

        // factor out pointSize from the xform:

            if
            (
                (pfc->flXform & XFORM_VERT) &&
                (pfc->mx.transform[1][0] == -pfc->mx.transform[0][1])
                &&
                (pfc->sizLogResPpi.cy == pfc->sizLogResPpi.cx)
            )
            {
            // important special case, simplify computation
            // and avoid rounding error

                if (pfc->mx.transform[0][1] > 0)
                    mx.transform[0][1] = LTOF16_16(1);
                else
                    mx.transform[0][1] = LTOF16_16(-1);

                mx.transform[1][0] = -mx.transform[0][1];
                mx.transform[0][0] = 0;
                mx.transform[1][1] = 0;
            }
            else
            {
                if (((ptSize + 1) * pfc->sizLogResPpi.cx) > 0x8000)
                {
                    /* keep the old computation to avoid overflow */
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                 ptSize * pfc->sizLogResPpi.cx
                                 );
                } else {
                    fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),0x480000 /* 72 */,
                                 pfc->pgin->param.newtrans.pointSize * pfc->sizLogResPpi.cx
                                 );
                }

                mx.transform[0][0] = FixMul(mx.transform[0][0], fxScale);
                mx.transform[1][0] = FixMul(mx.transform[1][0], fxScale);

                if (pfc->sizLogResPpi.cy != pfc->sizLogResPpi.cx)
                {
                    if (((ptSize + 1) * pfc->sizLogResPpi.cy) > 0x8000)
                    {
                    /* keep the old computation to avoid overflow */
                        fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),72,
                                      ptSize * pfc->sizLogResPpi.cy
                                      );
                    } else {
                        fxScale = LongMulDiv(LTOF16_16(pfc->pff->ffca.ui16EmHt),0x480000 /* 72 */,
                                      pfc->pgin->param.newtrans.pointSize * pfc->sizLogResPpi.cy
                                      );
                    }
                }

                mx.transform[1][1] = FixMul(mx.transform[1][1], fxScale);
                mx.transform[0][1] = FixMul(mx.transform[0][1], fxScale);
            }
        }

    }

// last minute modification to the matrix if italicization is present:

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // the result of multiplying arbitrary matrix with italicization matrix
    // We are multiplying from the left because the italicization matrix
    // acts first on the notional space vectors on the left
    //
    // |1      0|   |m00    m01|   |m00                 m10              |
    // |        | * |          | = |                                     |
    // |sin20  1|   |m10    m11|   |m10 + m00 * sin20   m11 + m01 * sin20|
    //

        mx.transform[1][0] += FixMul(mx.transform[0][0], FX_SIN20);
        mx.transform[1][1] += FixMul(mx.transform[0][1], FX_SIN20);
    }

    pfc->pgin->param.newtrans.transformMatrix = &mx;

// FIXEDSQRT2 is good as pixel diameter for all practical purposes
// according to EliK, LenoxB and JeanP [bodind]

    if ( pfc->bVertical )
    {
    //
    // keep these values for later
    //
        pfc->mxn = mx;
        pfc->pointSize = pfc->pgin->param.newtrans.pointSize;

    // new comment:
    // When we rotate dbcs characters we do not want to deform them,
    // we want to leave the natural aspect ratio of these glyphs.
    // For vertical writing the base line for dbcs glyphs that need to be rotated
    // goes through the middle of the glyphs, for sbcs characters stays the same.
    // Shift vector computed below does this job. Also, for older fixed pitch fe
    // fonts, where dbcs glyphs have the w == h and sbcs glyphs have width = w/2 for
    // dbcs and height the same for as for dbcs, these formulas become the old
    // formulas we used to have.

        vCalcXformVertical(pfc);
    }

    pfc->pgin->param.newtrans.pixelDiameter = FIXEDSQRT2;

    pfc->pgin->param.newtrans.usOverScale = pfc->overScale;
    ASSERTDD( pfc->overScale != FF_UNDEFINED_OVERSCALE , "Undefined Overscale\n" );

    if (bClearType == -1) {
        pfc->pgin->param.newtrans.flSubPixel = SP_SUB_PIXEL;
    } else if (bClearType == TRUE)
    {
        pfc->pgin->param.newtrans.flSubPixel = SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH;
    } else {
        pfc->pgin->param.newtrans.flSubPixel = 0;
    }

    pfc->pgin->param.newtrans.traceFunc = (FntTraceFunc)NULL;

    if (pfc->flFontType & FO_SIM_BOLD)
    {
	/* 2% + 1 pixel along baseline, 2% along descender line */
	    pfc->pgin->param.newtrans.usEmboldWeightx = 20;
	    pfc->pgin->param.newtrans.usEmboldWeighty = 20;
	    pfc->pgin->param.newtrans.lDescDev = pfc->lDescDev;
	    pfc->pgin->param.newtrans.bBitmapEmboldening = bBitmapEmboldening;
    }
    else
    {
	    pfc->pgin->param.newtrans.usEmboldWeightx = 0;
	    pfc->pgin->param.newtrans.usEmboldWeighty = 0;
	    pfc->pgin->param.newtrans.lDescDev = 0;
	    pfc->pgin->param.newtrans.bBitmapEmboldening = FALSE;
    }

    pfc->pgin->param.newtrans.bHintAtEmSquare = FALSE;
// now call the rasterizer to acknowledge the new transform

    if ((iRet = fs_NewTransformation(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        if ((iRet = fs_NewTransformNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
           V_FSERROR(iRet);
            return(FALSE);
        }
    }

    if (bBitmapEmboldening && (pfc->flFontType & FO_SIM_BOLD))
    {
        pfc->flXform |= XFORM_BITMAP_SIM_BOLD;
    } else {
        pfc->flXform &= ~XFORM_BITMAP_SIM_BOLD;
    }
    return(TRUE);
}



VOID vQuantizeXform
(
PFONTCONTEXT pfc
);


/******************************Public*Routine******************************\
*
* STATIC bComputeMaxGlyph
*
*
* Effects:
*
* Warnings:
*
* History:
*  04-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bComputeMaxGlyph (
    PFONTCONTEXT   pfc
    )
{
    VOID vSetGrayState__FONTCONTEXT(FONTCONTEXT *);
    VOID vSetClearTypeState__FONTCONTEXT(FONTCONTEXT *);

    LONG              cxMax,cyMax;

    LONG              yMinN, yMaxN;
    LONG              xMinN, xMaxN;

    LONG              lTmp;
    Fixed             fxMxx,fxMyy;
    BYTE             *pjView = (BYTE *)pfc->pff->pvView;

    sfnt_FontHeader * phead = (sfnt_FontHeader *) (
                      pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp
                      );

    BYTE * pjOS2 = (pfc->ptp->ateOpt[IT_OPT_OS2].dp)          ?
                   (pjView + pfc->ptp->ateOpt[IT_OPT_OS2].dp) :
                   NULL                                       ;

    ASSERTDD(pjView, "bComputeMaxGlyph, pjView\n");

// get the notional space values

    if (pjOS2 && (pfc->flXform & (XFORM_HORIZ | XFORM_VERT)))
    {
    // win 31 compatibility: we only take the max over win 31 char set.
    // All the glyphs outside this set, if they stand out will get shaved
    // off to match the height of the win31 char subset. Also notice that
    // for nonhorizontal cases we do not use os2 values because shaving
    // only applies to horizontal case, otherwise our bounding box values
    // will not be computed properly for nonhorizontal cases.

        yMinN =  - BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        yMaxN =    BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
    }
    else
    {
        yMinN = - BE_INT16(&phead->yMax);
        yMaxN = - BE_INT16(&phead->yMin);
    }

    if (yMinN >= yMaxN)
            RETURN("TTFD! yMinN >= yMaxN, must fail\n", FALSE);

    xMinN = BE_INT16(&phead->xMin);
    xMaxN = BE_INT16(&phead->xMax);

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // IF there is italic simulation
    //     xMin -> xMin - yMaxN * sin20
    //     xMax -> yMax - yMinN * sin20

        xMinN -= FixMul(yMaxN, FX_SIN20);
        xMaxN -= FixMul(yMinN, FX_SIN20);
    }

    if (xMinN >= xMaxN)
            RETURN("TTFD! xMinN >= xMaxN, must fail\n", FALSE);

    pfc->lEmHtDev = 0; // flag that it has not been computed
    pfc->fxPtSize = 0; // flag that it has not been computed
    pfc->SBCSWidth = 0; // flag that it has not been computed
    pfc->phdmx = NULL; // NULL unless computed otherwise

    if ((pfc->flXform & XFORM_HORIZ) &&
        !(pfc->flXform & XFORM_SINGULAR))  // XX AND YY Only
    {
        sfnt_HorizontalHeader  *phhea;
        ULONG  cHMTX;

        fxMxx = pfc->mx.transform[0][0];
        fxMyy = pfc->mx.transform[1][1];

    // ascender, round up

        yMinN = FixMul(fxMyy, yMinN);
        yMaxN = FixMul(fxMyy, yMaxN);

        if (fxMyy > 0)
        {
        // vdmx table should be consulted if present and used to compute
        // ascender and descender. If this computation can not be done
        // based on vdmx table or if vdmx table is not present simple
        // linear scaling will suffice [bodind].

            vQuantizeXform(pfc);

            if (!(pfc->flXform & XFORM_VDMXEXTENTS)) // COMPUTED FROM VDMX
            {
                pfc->yMin = yMinN;
                pfc->yMax = yMaxN;
            }

            pfc->lAscDev  = - pfc->yMin;
            pfc->lDescDev =   pfc->yMax;
        }
        else // fxMyy < 0
        {
            pfc->lAscDev =    yMinN;
            pfc->lDescDev = - yMaxN;

        // swap yMin and yMax for when the xform flips y coord

            lTmp  = yMinN;
            yMinN = yMaxN;
            yMaxN = lTmp;

            pfc->yMin = yMinN;
            pfc->yMax = yMaxN;

        }

        if (pfc->lEmHtDev == 0)
        {
        // if this value has not been computed in vQuantizeXform routine

            pfc->lEmHtDev = FixMul(fxMyy, pfc->pff->ifi.fwdUnitsPerEm);
            if (pfc->lEmHtDev < 0)
                pfc->lEmHtDev = - pfc->lEmHtDev;
        }

        ASSERTDD(pfc->lEmHtDev >= 0, "lEmHt negative\n");

    // now that em height has been computed, we can compute the
    // pt size on the rendering device. This value will be fed to
    // fs_NewTransformation

        pfc->fxPtSize = LongMulDiv(
                            LTOF16_16(pfc->lEmHtDev), 72,
                            pfc->sizLogResPpi.cy);

        cyMax = pfc->yMax - pfc->yMin;

        if
        (
            (pfc->mx.transform[0][0] == pfc->mx.transform[1][1])  &&
            (pfc->mx.transform[1][1] > 0)
        )
        {
        // caution, do not move this line of code elsewhere for
        // this check has to be made after vQuantizeXform since
        // this function may change the transform, but it has to be
        // made before bGetFastAdvanceWidth or bQueryAdvanceWidths
        // are ever called for these functions check flXform agains
        // XFORM_POSITIVE_SCALE

            pfc->flXform |= XFORM_POSITIVE_SCALE;

        // find the hdmx table, in case of the console fixed pitch font this
        // table may be useful in determining if cxMax needs to be cut off
        // to the advance width of this font

            vFindHdmxTable(pfc); // this could cause an exception:
        }

        phhea = (sfnt_HorizontalHeader *)(
                (BYTE *)pfc->pff->pvView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp
                );
        cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);


    // scale xMin,xMax to device, 28.4 format

        xMinN = FixMul(LTOFX(xMinN), fxMxx);
        xMaxN = FixMul(LTOFX(xMaxN), fxMxx);

        if (fxMxx < 0)
        {
            lTmp  = xMinN;
            xMinN = xMaxN;
            xMaxN = lTmp;
        }

    // I run the experiment on 400 fonts at several sizes. I found
    // that subtracting 2 from xMin and adding 1 to xMax suffices
    // in all situations to prevent any columns from being shaved off.
    // [bodind]

        xMinN = FXTOLFLOOR(xMinN) - 2;
        xMaxN = FXTOLCEILING(xMaxN) + 1;

        pfc->xMin = xMinN;
        pfc->xMax = xMaxN;

        cxMax = xMaxN - xMinN;

    // the direction unit vectors for scaling transforms  are simple
    // if the font is intended for horizontal left to right writing

    //!!! here the check is due to verify that the font is not designed
    //!!! for vertical writing in the notional space [bodind]

        vLToE(&pfc->pteUnitBase.x, (fxMxx > 0) ? 1L : - 1L);
        vLToE(&pfc->pteUnitBase.y, 0L);
        vLToE(&pfc->pteUnitSide.x, 0L);
        vLToE(&pfc->pteUnitSide.y, (fxMyy > 0) ? -1L : 1L); // y axis points down

    // We need to adjust the the glyph origin of singular bitmaps for glyphs
    // when MaxAscent or MaxDescent is negative or zero. The trick is to choose
    // these values so that the "blank" glyph is always included in the
    // rectangle of the text. What this means is that
    //     for m11 > 0 we must have: yT >= -lAsc  && yB <= lDesc
    //     for m11 < 0 we must have: yT >= -lDesc && yB <= lAsc
    // here yB == yT + 1, because blank glyphs has a cy == 1, and
    //     yT == ptlSingularOrigin.y
    // This leads to
    //     for m11 > 0 we must have: - (lAsc + 1)  < yT < lDesc
    //     for m11 < 0 we must have: - (lDesc + 1) < yT < lAsc
    // One point that would satisfy both of these conditions is
    // the midpoint between the endpoints. Thus, before any rouding:
    //     for m11 > 0 we have: yT =  (lDesc- lAsc - 1)/2
    //     for m11 < 0 we have: yT = -(lDesc- lAsc - 1)/2
    // where divide by 2 is not integer divide but ordinary real number divide.
    // The proper rounding is done ala KirkO, that is, add 1/2 and take a
    // flor:
    //     for m11 > 0 we have: yT = FLOOR((lDesc - lAsc - 1)/2 + 1/2)
    //     for m11 < 0 we have: yT = FLOOR((lAsc - lDesc - 1)/2 + 1/2)
    // That is:
    //     for m11 > 0 we have: yT = FLOOR(lDesc - lAsc)/2)
    //     for m11 < 0 we have: yT = FLOOR(lAsc - lDesc)/2)
    // Now floor is computed correctly (on signed nubmers) by implementing
    // divide by 2 as >> 1 operation:

        pfc->ptlSingularOrigin.x = 0;

        if ((pfc->lAscDev <= 0) || (pfc->lDescDev <= 0))
        {
            if (pfc->mx.transform[1][1] > 0)
            {
                pfc->ptlSingularOrigin.y =
                    (pfc->lDescDev - pfc->lAscDev) >> 1;
            }
            else
            {
                pfc->ptlSingularOrigin.y =
                    (pfc->lAscDev - pfc->lDescDev) >> 1;
            }
        }
        else
        {
            pfc->ptlSingularOrigin.y = 0;
        }

    }
    else // nontrivial transformation
    {
        POINTL   aptl[4];
        POINTFIX aptfx[4];
        BOOL     bOk;
        INT      i;
        FIX      xMinD, xMaxD, yMinD, yMaxD; // device space values;

    // add little extra space to be safe

        i = (INT)(pfc->pff->ffca.ui16EmHt / 64);
        yMaxN +=  i; // adds about 1.7% to ht
        yMinN -=  i; // adds about 1.7% to ht

    // set up the input array, the four corners of the maximal bounding
    // box in the notional coords

        aptl[0].x = xMinN;       //  tl.x
        aptl[0].y = yMinN;       //  tl.y

        aptl[1].x = xMaxN;       //  tr.x
        aptl[1].y = yMinN;       //  tr.y

        aptl[2].x = xMinN;       //  bl.x
        aptl[2].y = yMaxN;       //  bl.y

        aptl[3].x = xMaxN;       //  br.x
        aptl[3].y = yMaxN;       //  br.y

    // xform to device coords with 28.4 precision:

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        bOk = bFDXform(&pfc->xfm, aptfx, aptl, 4);

        if (!bOk) { RETURN("TTFD!_:bFDXform\n", FALSE); }

        xMaxD = xMinD = aptfx[0].x;
        yMaxD = yMinD = aptfx[0].y;

        for (i = 1; i < 4; i++)
        {
            if (aptfx[i].x < xMinD)
                xMinD = aptfx[i].x;
            if (aptfx[i].x > xMaxD)
                xMaxD = aptfx[i].x;
            if (aptfx[i].y < yMinD)
                yMinD = aptfx[i].y;
            if (aptfx[i].y > yMaxD)
                yMaxD = aptfx[i].y;
        }

        yMinD = FXTOLFLOOR(yMinD)   ;
        yMaxD = FXTOLCEILING(yMaxD) ;
        xMinD = FXTOLFLOOR(xMinD)   ;
        xMaxD = FXTOLCEILING(xMaxD) ;

        cxMax = xMaxD - xMinD;
        cyMax = yMaxD - yMinD;

    // now re-use aptl to store e1 and -e2, base and side unit
    // vectors in the notional space.
    //!!! This may be wrong if have font for
    //!!! right to left or vert writing [bodind]

        aptl[0].x = 1;    // base.x
        aptl[0].y = 0;    // base.y

        aptl[1].x =  0;   // side.x
        aptl[1].y = -1;   // side.y

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        bOk = bXformUnitVector (
                  &aptl[0],          // IN,  incoming unit vector
                  &pfc->xfm,         // IN,  xform to use
                  &pfc->vtflBase,    // OUT, xform of the incoming unit vector
                  &pfc->pteUnitBase, // OUT, *pptqXormed/|*pptqXormed|, POINTE
                  (pfc->flFontType & FO_SIM_BOLD) ? &pfc->ptqUnitBase : NULL, // OUT, *pptqXormed/|*pptqXormed|, POINTQF
                  &pfc->efBase       // OUT, |*pptqXormed|
                  );

        bOk &= bXformUnitVector (
                  &aptl[1],          // IN,  incoming unit vector
                  &pfc->xfm,         // IN,  xform to use
                  &pfc->vtflSide,    // OUT, xform of the incoming unit vector
                  &pfc->pteUnitSide, // OUT, *pptqXormed/|*pptqXormed|, POINTE
                  (pfc->flFontType & FO_SIM_BOLD) ? &pfc->ptqUnitSide : NULL, // OUT, *pptqXormed/|*pptqXormed|, POINTQF
                  &pfc->efSide       // OUT, |*pptqXormed|
                  );

        if (!bOk) { RETURN("TTFD!_:bXformUnitVector\n", FALSE); }

        pfc->lAscDev  = -fxLTimesEf(&pfc->efSide,yMinN);
        pfc->lDescDev =  fxLTimesEf(&pfc->efSide,yMaxN);

        pfc->lAscDev  = FXTOLCEILING(pfc->lAscDev) ;
        pfc->lDescDev = FXTOLCEILING(pfc->lDescDev);

        pfc->ptfxTop.x    = lExL(pfc->pteUnitSide.x, LTOFX(pfc->lAscDev));
        pfc->ptfxTop.y    = lExL(pfc->pteUnitSide.y, LTOFX(pfc->lAscDev));
        pfc->ptfxBottom.x = lExL(pfc->pteUnitSide.x, -LTOFX(pfc->lDescDev));
        pfc->ptfxBottom.y = lExL(pfc->pteUnitSide.y, -LTOFX(pfc->lDescDev));

        if ((yMinN >= 0) || (yMaxN <= 0) || ((pfc->lAscDev + pfc->lDescDev) < 3))
        {
        // Either all the glyphs are above the base line or all the glyphs
        // are below the baseline.  In either case adjust the origin for
        // the singular glyph bitmap.
        // Compute the midpoint between asc and desc in notional space:
        // lAverage = ROUND(-(yMaxN+yMinN)/2)

            LONG lAverage =  (-yMaxN -yMinN + 1) >> 1;

            pfc->ptlSingularOrigin.x = fxLTimesEf(&pfc->vtflSide.x,lAverage);
            pfc->ptlSingularOrigin.x = FXTOLROUND(pfc->ptlSingularOrigin.x);

            pfc->ptlSingularOrigin.y = fxLTimesEf(&pfc->vtflSide.y,lAverage);
            pfc->ptlSingularOrigin.y = FXTOLROUND(pfc->ptlSingularOrigin.y);

        }
        else
        {
            pfc->ptlSingularOrigin.x = 0;
            pfc->ptlSingularOrigin.y = 0;
        }


    // finally store the results:

        pfc->xMin        = xMinD;
        pfc->xMax        = xMaxD;
        pfc->yMin        = yMinD;
        pfc->yMax        = yMaxD;

    // compute em ht in pixels and points


        pfc->fxPtSize = fxPtSize(pfc);

        /* compute pfc->lEmHtDev from pfc->fxPtSize to make sure values are coherent */

        {
            Fixed fxScale;

            fxScale = LongMulDiv(pfc->fxPtSize, pfc->sizLogResPpi.cy, 72);
            pfc->lEmHtDev = (uint16)ROUNDFIXTOINT(fxScale);
        }
    }

// compute corrections

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        vCalcEmboldSize(pfc);
    }
    else
    {
        pfc->dBase = 0;
    }

// if this is one of the almost singular transforms, reject this

    if ((cxMax == 0) || (cyMax == 0))
    {
        RETURN("TTFD! almost singular xform, must fail\n", FALSE);
    }


    if (pfc->flFontType & FO_SIM_BOLD)
    {
        /* we are on the safe side by adding dBase to both cxMax and cyMax */
        cxMax += pfc->dBase;
        cyMax += pfc->dBase;
    }

// we can liberally extend cxMax to the byte boundary, this is not
// going to change memory requirements of the system.

    cxMax = ((cxMax + 7) & ~7);
    pfc->cxMax = cxMax;

// now we have to determine how big in memory is the biggest glyph.
// let us remember that the rasterizer needs little more storage than the
// the engine does, because rasterizer will want dword aligned rows rather
// than byte aligned rows

    {
        DWORDLONG lrg;

    // why am I dword instead byte extending cxMax? because that is
    // how much rasterizer will want for this bitmap

        ULONG          cjMaxScan = ((cxMax + 31) & ~31) / 8;
        lrg =  UInt32x32To64(cjMaxScan, cyMax);
        if (lrg > ULONG_MAX)
        {
        // the result does not fit in 32 bits, alloc memory will fail
        // this is too big to digest, we fail to open fc

            RETURN("TTFD! huge pt size, must fail\n", FALSE);
        }
    }

// We now have all the informaiton to set the gray bit
// appropriately.

    if (pfc->flFontType & FO_CLEARTYPE_X)
    {
        vSetClearTypeState__FONTCONTEXT(pfc);
    }
    else
    {
        vSetGrayState__FONTCONTEXT(pfc);
    }

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,
        "We haven't decided about pixel depth\n"
    );

    pfc->cjGlyphMax = CJGD(cxMax,cyMax,pfc);

// See if this is shell font and we want to hack max neg a and c spaces

    if (
        (pfc->pff->ffca.fl & FF_NEW_SHELL_FONT) &&
        ((pfc->flXform & (XFORM_HORIZ | XFORM_POSITIVE_SCALE)) == (XFORM_HORIZ | XFORM_POSITIVE_SCALE))
    )
    {
        pfc->flXform |= XFORM_MAX_NEG_AC_HACK;
    }

    return TRUE;
}

//--------------------------------------------------------------------
// LONG iHipot(x, y)
//
// This routine returns the hypoteneous of a right triangle.
//
// FORMULA:
//          use sq(x) + sq(y) = sq(hypo);
//          start with MAX(x, y),
//          use sq(x + 1) = sq(x) + 2x + 1 to incrementally get to the
//          target hypotenouse.
//
// History:
//  Mon 07-Feb-1994 -by- Bodin Dresevic [BodinD]
//  update:   update to use Fixed 16.16
//   10-Feb-1993    -by-    Kent Settle     (kentse)
//  Stole from RASDD.
//   21-Aug-1991    -by-    Lindsay Harris  (lindsayh)
//  Cleaned up UniDrive version, added comments etc.
//--------------------------------------------------------------------


/*

      Algorithm analysis by DChinn :

      After a bit of incorrect attempts, I figured it all out.  It turns out that
    the if h is the correct hypotenuse, then the routine returns the
    ceiling of h.  Here's the analysis:


    Let h = the correct hypotenuse
        h = sqrt{x^2 + y^2}

        x and y are integers.

    Let h' = the value returned by the algorithm

                      { d-1                        }
        h' = y +  min { sum [ 2(y+i) + 1 ]  >= x^2 }
                  d>0 { i=0                        }

                 { d-1                        }
    Let d' = min { sum [ 2(y+i) + 1 ]  >= x^2 }
             d>0 { i=0                        }

    Consider the smallest d for which

            d-1
            sum [ 2(y+i) + 1 ]  >= x^2  .
            i=0

            d-1                d-1
            sum (2y + 1)  +  2 sum i   >= x^2
            i=0                i=0

               2yd + d    + (d-1)d   - x^2 >= 0

            d^2 + 2yd - x^2 >= 0        (solve this equation as if it were an equality)

                  -2y +/- sqrt{ (2y)^2 - 4 * 1 * (-x^2) }
            d  =  ---------------------------------------
                                    2
            d' =  ceiling (d)

            d' =  ceiling (  -y +/- sqrt{ y^2 + x^2 }  )

               =  -y + ceiling ( sqrt{ y^2 + x^2 } )     (the minus in +/- is impossible)

    So, h' = y +  (-y) + ceiling ( sqrt{ y^2 + x^2 } )
           = ceiling ( sqrt{ y^2 + x^2 } )

    The loop invariant: Since delta is incremented by 2*hypo+1 in each iteration and
    (hypo+1)^2 = hypo^2 + (2*hypo + 1), then at the end of each iteration, a
    triangle with sides y, sqrt{delta}, and hypo is always a right triangle.

    Note that there is no assumption in the above that y >= x, so
    that assumption is for performance reasons only.

  */

STATIC ULONG iHipot(LONG x, LONG y)
{
    ULONG  hypo;         /* Value to calculate */
    ULONG  delta;        /* Used in the calculation loop */
    ULONG  target;       /* Loop limit factor */
	USHORT  shift = 0;

// quick exit for frequent trivial cases [bodind]

    if (x < 0)
        x = -x;

    if (y < 0)
        y = -y;

    if (x == 0)
        return y;

    if (y == 0)
        return x;

    /* avoid overflow */
    while ((x > 0x8000L) || (y > 0x8000L))
    {
        x >>= 1;
        y >>= 1;
        shift ++;
    }

    if (x > y)
    {
        hypo = x;
        target = y * y;
    }
    else
    {
        hypo = y;
        target = x * x;
    }

    for (delta = 0; delta < target; hypo++)
        delta += ((hypo << 1) + 1);

    return (hypo << shift);
}


/******************************Public*Routine******************************\
*
* bSingularXform
*
* Checks whether this is one of the xforms that the rasterizer is known
* to choke on. Those are the transforms that generate very
* narrow fonts (less than 0.5 pixels/em wide or tall). For fonts that
* allow only integer widths/em and heights/em this number will get rounded
* down to zero and generate divide by zero exception in the preprogram.
* We will flag such transforms as XFORM_SINGULAR and return empty bitmaps
* and outlines for them shortcircuiting the rasterizer which would die on
* us.
*
* Actually, for compatibility reasons we will have to change
* this plan a little bit. It turns out that
* win 31 does not allow for the rasterization of a font that is less
* than 2 pixels tall (ie. the Em Ht of the font in device space must be
* >= 2 pixels). If a request comes down to realize a font that is tall less
* than 2 pixels we will simply have to substitute the transform by a scaled
* transform that will produce a font of height two pixels. We will still keep
* our singular transform code in case a font is requested that is singular in
* X direction, that is, too narrow.
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// smallest ppem allowed under  win31:

#define WIN31_PPEM_CUTOFF 2

STATIC VOID vCheckForSingularXform (PFONTCONTEXT  pfc) // OUT
{

    register LONG  lEmHtDev;

    Fixed fxEmHtDev;
    Fixed fxEmHtNot = LTOF16_16(pfc->pff->ffca.ui16EmHt);
    Fixed fxScale;
    Fixed fxEmWidthDev;

// xforms are conforming left multiplication rule v' = v * M i.e.:
//
// (x,0) -> x(m00,m01)
// (0,y) -> y(m10,m11)
//
// compute length of (0,Em) after it gets transformed to device space:
// We need to have fxEmHtDev computed with high precission, for we
// shall be using it to divide the original transform by.
// We want to avoid division by zero when that is not neccessary.

    fxEmHtDev = FixMul(
                   iHipot(pfc->mx.transform[1][1],pfc->mx.transform[1][0]),
                   fxEmHtNot
                   );

    lEmHtDev = F16_16TOLROUND(fxEmHtDev);
    if (lEmHtDev < WIN31_PPEM_CUTOFF) // too small a transform:
    {
        pfc->flXform |= XFORM_2PPEM;

    // according to win31 algorithm, we must scale this xform so that the
    // resulting xform will produce font that is 2 pels tall.
    // That is, the new transform M' is going to be
    //
    // M' = (WIN31_PPEM_CUTOFF / lEmHtDev) * M
    //
    // so that the following equation is satisfied:
    //
    // |(0,EmNotional) * M'| == WIN31_PPEM_CUTOFF == 2;

        if (pfc->flXform & XFORM_HORIZ)
        {
        // in this special case the above formula for M' becomes:
        //
        //                                         | m00/|m11|     0     |
        // M' = (WIN31_PPEM_CUTOFF / EmNotional) * |                     |
        //                                         |   0        sgn(m11) |

#define LABS(x) ((x)<0)?(-x):(x)

            Fixed fxAbsM11 = LABS(pfc->mx.transform[1][1]);
            Fixed fxAbsM00 = LABS(pfc->mx.transform[0][0]);

            LONG lSgn11 = (pfc->mx.transform[1][1] >= 0) ? 1 : -1;
            LONG lSgn00 = (pfc->mx.transform[0][0] >= 0) ? 1 : -1;

            fxScale = FixDiv(WIN31_PPEM_CUTOFF,pfc->pff->ffca.ui16EmHt);

            pfc->mx.transform[1][1] = fxScale;
            if (fxAbsM00 != fxAbsM11)
            {
                pfc->mx.transform[0][0] = LongMulDiv(fxScale,fxAbsM00,fxAbsM11);
            }
            else
            {
                pfc->mx.transform[0][0] = fxScale;
            }

        // fix the signs if needed:

            if (lSgn11 < 0)
                pfc->mx.transform[1][1] = - pfc->mx.transform[1][1];

            if (lSgn00 < 0)
                pfc->mx.transform[0][0] = - pfc->mx.transform[0][0];
        }
        else
        {
        // general case, compute scale (which involves division) once,
        // and use it for all four members of the matrix:

            fxScale = FixDiv(LTOF16_16(WIN31_PPEM_CUTOFF),fxEmHtDev);

            pfc->mx.transform[0][0] = FixMul(pfc->mx.transform[0][0],fxScale);
            pfc->mx.transform[0][1] = FixMul(pfc->mx.transform[0][1],fxScale);
            pfc->mx.transform[1][0] = FixMul(pfc->mx.transform[1][0],fxScale);
            pfc->mx.transform[1][1] = FixMul(pfc->mx.transform[1][1],fxScale);

        // In general case must also fix the original EFLOAT xform because
        // it is going to be used for computation of extents, max glyphs etc.

            FFF(pfc->xfm.eM11, +pfc->mx.transform[0][0]);
            FFF(pfc->xfm.eM22, +pfc->mx.transform[1][1]);
            FFF(pfc->xfm.eM12, -pfc->mx.transform[0][1]);
            FFF(pfc->xfm.eM21, -pfc->mx.transform[1][0]);
        }
    }

// Now check if the transform is singular in x. To do this
// compute length of (Em,0) after it gets transformed to device space:

    fxEmWidthDev = FixMul(
                   iHipot(pfc->mx.transform[0][0],pfc->mx.transform[0][1]),
                   fxEmHtNot
                   );

    if (fxEmWidthDev <= ONEHALFFIX)
    {
    // We are in trouble, we shall have to lie to the engine:

        pfc->flXform |= XFORM_SINGULAR;
    }
}




/******************************Public*Routine******************************\
*
* bNewXform:
*
* converts the transform matrix to the form the rasterizer likes
* and computes the global (per font) sizes that are relevant for this
* transform.
*
* History:
*  28-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC BOOL
bNewXform (
    FONTOBJ      *pfo,
    PFONTCONTEXT pfc             // OUT
    )
{
// do not write immediately to pfc->mx until sure that all bFloatToL
// have succeeded. You do not want to leave this function and leave
// fc in a dirty state

    Fixed fx00, fx01, fx10, fx11;

// Get the transform elements.

    XFORMOBJ_iGetXform(FONTOBJ_pxoGetXform(pfo),&pfc->xfm);

    if (
        !bFloatToL(pfc->xfm.eM11, &fx00) ||
        !bFloatToL(pfc->xfm.eM22, &fx11) ||
        !bFloatToL(pfc->xfm.eM12, &fx01) ||
        !bFloatToL(pfc->xfm.eM21, &fx10)
       )
        RET_FALSE("TTFD!_bFloatToL failed\n");

// we are fine now, can not fail after this:

    pfc->mx.transform[0][0]  = fx00;
    pfc->mx.transform[1][1]  = fx11;
    pfc->mx.transform[0][1]  = -fx01;
    pfc->mx.transform[1][0]  = -fx10;

// check if this is one of the sing xform where one row or column is zero:
// It is important to do this after bFloatToL, some floating numbers can be
// so small that can only be represented as zeros in 16.16 format

    if
    (
        !(fx00 | fx01) ||
        !(fx00 | fx10) ||
        !(fx11 | fx10) ||
        !(fx11 | fx01)
    )
    {
        ASSERTDD(1, "We are screwed by this xform\n");
        return FALSE;
    }

// components in the projective space are zero

// ClaudeBe, from the client interface Doc :
// Please note that although the third column of the matrix is defined as Fixed numbers
// you will actually need to use  Fract numbers in that column. The higher resolution provided
// by Fracts is required to change the perspective of a glyph. Fracts are 2.30 fixed point numbers.

    pfc->mx.transform[2][2] = ONEFRAC;
    pfc->mx.transform[0][2] = (Fixed)0;
    pfc->mx.transform[1][2] = (Fixed)0;
    pfc->mx.transform[2][0] = (Fixed)0;
    pfc->mx.transform[2][1] = (Fixed)0;

// set the flags for the transform:

    pfc->flXform = 0;

    if ((fx01 == 0) && (fx10 == 0))
        pfc->flXform |= XFORM_HORIZ;

    if ((fx00 == 0) && (fx11 == 0))
        pfc->flXform |= XFORM_VERT;

// important to check for "singular transform"
// (ie. request for too small a font realization) after flags have been set

    vCheckForSingularXform(pfc);

// no glyph metrics computation is valid yet

    vInitGlyphState(&pfc->gstat);

// no memory to rasterize a glyph or produce glyph outline has been allocated

    pfc->gstat.pv = NULL;

// now get the sizes for this transform

    return bComputeMaxGlyph(pfc);
}


/******************************Public*Function*****************************\
* bFToL                                                                    *
*                                                                          *
* Convert an IEEE floating point number to a long integer.                 *
*                                                                          *
* History:                                                                 *
*
*  Thu 29-Mar-2001 -by- Mikhail Leonov [MLeonov]
* update:
*   changed <= 23 to < 23, otherwise numbers like 142.5 get converted to 0
*
*  Sun 17-Nov-1991 -by- Bodin Dresevic [BodinD]
* update:
*
* changed the line
*    if (flType & CVT_TO_FIX) lExp += 4;
* to
*    if (flType & CVT_TO_FIX) lExp += 16;
* to reflect that we are converting to 16.16 format rather than to 28.4
*
*
*  03-Jan-1991 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

STATIC BOOL bFloatToL(FLOATL e, PLONG pl)
{

    LONG lEf, lExp;

    lEf = (*((LONG *) &e));        // convert type EFLOAT to LONG

// if exponent < 0 then convert to 0 and return true

    lExp = ((lEf >> 23) & 0xff) -127;

    lExp += 16; // this is the only line I changed [bodind]

    if (lExp < 0)
    {
        *pl = 0;
        return(TRUE);
    }

// if exponent < 23 then
//     lMantissa = (lEf & 0x7fffff) | 0x800000;
//         l = ((lMantissa >> (23 - lExponent -1)) + 1) >> 1;

    if (lExp < 23)
    {
        *pl = (lEf & 0x80000000) ?
             -(((((lEf & 0x7fffff) | 0x800000) >> (23 - lExp -1)) + 1) >> 1) :
             ((((lEf & 0x7fffff) | 0x800000) >> (23 - lExp -1)) + 1) >> 1;
        return(TRUE);
    }

// if exponent <= 30 then
// lMantissa = (lEf & 0x7fffff) | 0x800000;
// l = lMantissa << (lExponent - 23);

    if (lExp <= 30)
    {
        *pl = (lEf & 0x80000000) ?
            -(((lEf & 0x7fffff) | 0x800000) << (lExp - 23)) :
            ((lEf & 0x7fffff) | 0x800000) << (lExp - 23);
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* lFFF = long-float-from-fixed
*
* input: 16.16 representation
* output: LONG that is bit equivalent of the 32-bit ieee float
*         equal to the fix point number. To recover the float
*   the FLOAT representation you simply cast the bits as a float
*   that is
*
*   FLOAT e;
*
*       *(LONG*)&e = lFFF(n16Dot16)
*
* History:
*  Tue 03-Jan-1995 14:33:35 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

LONG lFFF(LONG l)
{
#if defined(_AMD64_) || defined(_IA64_)
    FLOAT e = ((FLOATL) l)/((FLOATL) 65536);
    return(*(LONG*)&e);
#elif defined(_X86_)
    int i;                              // shift count
    unsigned k;                         // significand

    if (k = (unsigned) l)
    {
        if (l < 0)
            k = (unsigned) -l;          // significand is positive, sign
                                        // bit accounted for later
        i = 0;
        if (k < (1 << 16)) {            // put the number in the
            k <<= 16;                   // range 2^31 <= k < 2^32
            i += 16;                    // by shifting to left, put
        }                               // shift count in i
        if (k < (1 << 24)) {
            k <<= 8;
            i += 8;
        }
        if (k < (1 << 28)) {
            k <<= 4;
            i += 4;
        }
        if (k < (1 << 30)) {
            k <<= 2;
            i += 2;
        }
        if (k < (1 << 31)) {
            k <<= 1;
            i += 1;
        }
                                        // at this point
                                        // i = 31-floor(log2(abs(l)))

        k += (1 << 7);                  // about to shift out
                                        // the lowest 8-bits
                                        // account for their effect by
                                        // rounding. This has the effect
                                        // that numbers are rounded away
                                        // from zero as opposed to rounding
                                        // stricktly up
        k >>= 8;                        // shift out the lowest 8 bits

        k &= ((1<<23) - 1);             // 2^23 bit is implicit so mask it out
        k |= (0xff & (142 - i)) << 23;  // set exponent at correct place
        if (l < 0)                      // if original number was negative
            k |= (1<<31);               // then set the sign bit
    }
    return((LONG) k);
#endif
}


#if DBG

/******************************Public*Routine******************************\
*
* VOID vFSError(FS_ENTRY iRet);
*
*
* Effects:
*
* Warnings:
*
* History:
*  25-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vFSError(FS_ENTRY iRet)
{
    PCHAR psz;

    switch (iRet)
    {
        case BAD_CALL_ERR:
            psz =  "BAD_CALL_ERR";
            break;
        case BAD_CLIENT_ID_ERR:
            psz =  "BAD_CLIENT_ID_ERR";
            break;
        case BAD_MAGIC_ERR:
            psz =  "BAD_MAGIC_ERR";
            break;
        case BAD_START_POINT_ERR:
            psz =  "BAD_START_POINT_ERR";
            break;
        case CLIENT_RETURNED_NULL:
            psz =  "CLIENT_RETURNED_NULL";
            break;
        case CONTOUR_DATA_ERR:
            psz =  "CONTOUR_DATA_ERR";
            break;
        case GLYPH_INDEX_ERR:
            psz =  "GLYPH_INDEX_ERR";
            break;
        case INSTRUCTION_SIZE_ERR:
            psz =  "INSTRUCTION_SIZE_ERR";
            break;
        case INVALID_GLYPH_INDEX:
            psz =  "INVALID_GLYPH_INDEX";
            break;
        case MISSING_SFNT_TABLE:
            psz =  "MISSING_SFNT_TABLE";
            break;
        case NULL_INPUT_PTR_ERR:
            psz =  "NULL_INPUT_PTR_ERR";
            break;
        case NULL_KEY_ERR:
            psz =  "NULL_KEY_ERR";
            break;
        case NULL_MEMORY_BASES_ERR:
            psz =  "NULL_MEMORY_BASES_ERR";
            break;
        case NULL_OUTPUT_PTR_ERR:
            psz =  "NULL_OUTPUT_PTR_ERR";
            break;
        case NULL_SFNT_DIR_ERR:
            psz =  "NULL_SFNT_DIR_ERR";
            break;
        case NULL_SFNT_FRAG_PTR_ERR:
            psz =  "NULL_SFNT_FRAG_PTR_ERR";
            break;
        case OUT_OFF_SEQUENCE_CALL_ERR:
            psz =  "OUT_OFF_SEQUENCE_CALL_ERR";
            break;
        case OUT_OF_RANGE_SUBTABLE:
            psz =  "OUT_OF_RANGE_SUBTABLE";
            break;
        case POINTS_DATA_ERR:
            psz =  "POINTS_DATA_ERR";
            break;
        case POINT_MIGRATION_ERR:
            psz =  "POINT_MIGRATION_ERR";
            break;
        case SCAN_ERR:
            psz =  "SCAN_ERR";
            break;
        case SFNT_DATA_ERR:
            psz =  "SFNT_DATA_ERR";
            break;
        case TRASHED_MEM_ERR:
            psz =  "TRASHED_MEM_ERR";
            break;
        case TRASHED_OUTLINE_CACHE:
            psz =  "TRASHED_OUTLINE_CACHE";
            break;
        case UNDEFINED_INSTRUCTION_ERR:
            psz =  "UNDEFINED_INSTRUCTION_ERR";
            break;
        case UNKNOWN_CMAP_FORMAT:
            psz =  "UNKNOWN_CMAP_FORMAT";
            break;
        case UNKNOWN_COMPOSITE_VERSION:
            psz =  "UNKNOWN_COMPOSITE_VERSION";
            break;
        case VOID_FUNC_PTR_BASE_ERR:
            psz =  "VOID_FUNC_PTR_BASE_ERR";
            break;
        case SBIT_COMPONENT_MISSING_ERR:
            psz =  "SBIT_COMPONENT_MISSING_ERR";
            break;
        case TRACE_FAILURE_ERR:
            psz = "Trace_Failure_Error";
            break;
        case DIV_BY_0_IN_HINTING_ERR:
            psz = "DIV_BY_0_IN_HINTING_ERR";
            break;
        case MISSING_ENDF_ERR:
            psz = "MISSING_ENDF_ERR";
            break;
        case MISSING_EIF_ERR:
            psz = "MISSING_EIF_ERR";
            break;
        case INFINITE_RECURSION_ERR:
            psz = "INFINITE_RECURSION_ERR";
            break;
        case INFINITE_LOOP_ERR:
            psz = "INFINITE_LOOP_ERR";
            break;
        case FDEF_IN_GLYPHPGM_ERR:
            psz = "FDEF_IN_GLYPHPGM_ERR";
            break;
        case IDEF_IN_GLYPHPGM_ERR:
            psz = "IDEF_IN_GLYPHPGM_ERR";
            break;
        case JUMP_BEFORE_START_ERR:
            psz = "JUMP_BEFORE_START_ERR";
            break;
        case RAW_NOT_IN_GLYPHPGM_ERR:
            psz = "RAW_NOT_IN_GLYPHPGM_ERR";
            break;	
        case INSTRUCTION_ERR:
            psz = "INSTRUCTION_ERR";
            break;
        case SECURE_STACK_UNDERFLOW:
            psz = "SECURE_STACK_UNDERFLOW";
            break;
        case SECURE_STACK_OVERFLOW:
            psz = "SECURE_STACK_OVERFLOW";
            break;
        case SECURE_POINT_OUT_OF_RANGE:
            psz = "SECURE_POINT_OUT_OF_RANGE";
            break;
        case SECURE_INVALID_STACK_ACCESS:
            psz = "SECURE_INVALID_STACK_ACCESS";
            break;
        case SECURE_FDEF_OUT_OF_RANGE:
            psz = "SECURE_FDEF_OUT_OF_RANGE";
            break;
        case SECURE_ERR_FUNCTION_NOT_DEFINED:
            psz = "SECURE_ERR_FUNCTION_NOT_DEFINED";
            break;
        case SECURE_INVALID_ZONE:
            psz = "SECURE_INVALID_ZONE";
            break;
        case SECURE_INST_OPCODE_TO_LARGE:
            psz = "SECURE_INST_OPCODE_TO_LARGE";
            break;
        case SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP:
            psz = "SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP";
            break;
        case SECURE_STORAGE_OUT_OF_RANGE:
            psz = "SECURE_STORAGE_OUT_OF_RANGE";
            break;
        case SECURE_CONTOUR_OUT_OF_RANGE:
            psz = "SECURE_CONTOUR_OUT_OF_RANGE";
            break;
        case SECURE_CVT_OUT_OF_RANGE:
            psz = "SECURE_CVT_OUT_OF_RANGE";
            break;
        case SECURE_UNITIALIZED_ZONE:
            psz = "SECURE_UNITIALIZED_ZONE";
            break;	
        case COMPOSITE_INVALID_GLYPH_INDEX:
            psz =  "COMPOSITE_INVALID_GLYPH_INDEX";
            break;
        case LOCA_NOT_ASCENDING:
            psz =  "LOCA_NOT_ASCENDING";
            break;
        default:
            psz = "UNKNOWN FONT SCALER ERROR";
                break;
    }
    TtfdDbgPrint ("\n Rasterizer Error: 0x%lx, %s \n", iRet, psz);

}


#endif


/******************************Public*Routine******************************\
*
* fxPtSize
*
* Effects: computes the size in points for this font realization
*
* History:
*  06-Aug-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC LONG fxPtSize(PFONTCONTEXT pfc)
{
// This is done as follows:
//
// Transform
// (0, ui16EmHt) to device (pixel) space.
// Let us say that the vector obtained is (xEm, yEm).
// Then, ptSize should be computed as
// ptSize =  72 * sqrt((xEm/xRes)^2 + (yEm/yRes)^2);

// expanding here a bit we get:
// ptSize =  72 * ui16EmHt * sqrt((mx10/xRes)^2 + (mx11/yRes)^2);

	Fixed x,y;
    LONG  lEmHtX72 = (LONG)(72 * pfc->pff->ffca.ui16EmHt);

    x = LongMulDiv(lEmHtX72,pfc->mx.transform[1][0],pfc->sizLogResPpi.cx);
    y = LongMulDiv(lEmHtX72,pfc->mx.transform[1][1],pfc->sizLogResPpi.cy);
    return iHipot(x,y);
}


//
// this is win31 code intended as a comment for our code:
//

#ifdef THIS_IS_WIN31_CODE_INTENDED_AS_COMMENT

      // Find out if a width Table is available
    if (pfnt->ulHdmxPos && !(pfc->fStatus & FD_MORE_THAN_STRETCH) && pfc->Mx11 == pfc->Mx00)
    {
      unsigned    i;
      HDMXHEADER  FAR *pHdmx;
      HDMXTABLE   FAR *pHdmxTable;

      if (pHdmx = (HDMXHEADER  FAR *) SfntReadFragment (pfc->fgi.clientID, pfnt->ulHdmxPos, pfnt->uHdmxSize))
      {
        if (pHdmx->Version == 0)
        {
          pHdmxTable = pHdmx->HdmxTable;

            // Init the the glyph count
          pfc->cHdmxRecord = (unsigned) SWAPL (pHdmx->cbSizeRecord);

           // look through the table if the size is available
          for (i = 0; i < (unsigned) SWAPW (pHdmx->cbRecord); i++, pHdmxTable = (HDMXTABLE FAR *)((char FAR *) pHdmxTable + pfc->cHdmxRecord))
            if (pfc->Mx11 == (int) pHdmxTable->ucEmY)
            {
              pfc->ulHdmxPosTable = pfnt->ulHdmxPos + (i * pfc->cHdmxRecord + sizeof (HDMXHEADER));
              break;
            }
        }
        ReleaseSFNT (pHdmx);
      }
    }

#endif // THIS_IS_WIN31_CODE_INTENDED_AS_COMMENT

STATIC VOID vFindHdmxTable(PFONTCONTEXT pfc)
{
    HDMXHEADER  *phdr = (HDMXHEADER  *)(
        (pfc->ptp->ateOpt[IT_OPT_HDMX].dp)                                   ?
        ((BYTE *)pfc->pff->pvView + pfc->ptp->ateOpt[IT_OPT_HDMX].dp) :
        NULL
        );

    UINT         cRecords;
    ULONG        cjRecord;

    HDMXTABLE    *phdmx, *phdmxEnd;
    LONG         yEmHt = pfc->lEmHtDev;

// assume failure, no hdmx table can be used:

    pfc->phdmx = NULL;

// first see if hdmx table is there at all:

    if (!phdr)
        return;

// if transform is not such as to allow the use of hdmx table, return;

    ASSERTDD(pfc->flXform & XFORM_POSITIVE_SCALE,
        "vFindHdmxTable, bogus xform\n");

    if (!bValidRangeHDMX(phdr, pfc->pff, pfc->ptp->ateOpt[IT_OPT_HDMX].cj, &cRecords, &cjRecord))
    {
        WARNING("vFindHdmxTable: bogus hdmx table\n");
        return;
    }


// if yEmHt > 255, can not fit in the byte, so there is no need to
// to search for the hdmx entry:

    if (yEmHt > 255)
        return;

// Finally, find out if there is something useful there.  Note that the
// table is sorted by size, so we can take an early out.

    phdmx = (HDMXTABLE *)(phdr + 1);
    phdmxEnd = (HDMXTABLE *)((PBYTE)phdmx + cRecords * cjRecord);

    for
    (
        ;
        phdmx < phdmxEnd;
        phdmx = (HDMXTABLE *)((PBYTE)phdmx + cjRecord)
    )
    {
        if (((BYTE) yEmHt) <= phdmx->ucEmY)
        {
            if (((BYTE) yEmHt) == phdmx->ucEmY)
                pfc->phdmx = phdmx; // We found it.
            break;
        }
    }
}

/******************************Public*Routine******************************\
*
* bGrabXform
*
*  updates buffers 0 and 4, those that save the state of the transform.
*  also for "buggy" fonts (URW FONTS) some of the transform dependent
*  info (twightlight points) may be stored in the buffer 3, which otherwise would be shareable
*  this is unfortunate, more memory is required
*
*
* History:
*  24-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL
bGrabXform (
    PFONTCONTEXT pfc,
    USHORT usOverScale,
    BOOL bBitmapEmboldening,
    BOOL bRequestedClearType
)
{
    BOOL bLastClearType;
    BOOL bOk = TRUE;

    if((pfc->pgin->param.newtrans.flSubPixel & (SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH)) == SP_SUB_PIXEL)
        bLastClearType = -1;
    else if((pfc->pgin->param.newtrans.flSubPixel & (SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH)) == (SP_SUB_PIXEL | SP_COMPATIBLE_WIDTH))
        bLastClearType = 1;
    else 
        bLastClearType = 0;

    if ((pfc->pff->pfcLast != pfc) || (pfc->overScale != usOverScale) ||
        ( bLastClearType != bRequestedClearType)||
        (bBitmapEmboldening != (BOOL)(!!(pfc->flXform & XFORM_BITMAP_SIM_BOLD)) ) )
    {
    // set the overscale to the current one

        pfc->overScale = usOverScale;

    // have to refresh the transform, somebody has changed it on us

        if (bOk = bSetXform(pfc, bBitmapEmboldening, bRequestedClearType))
        {
            if ((pfc->pff->pfcLast != pfc) && (pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH))
            {
                /* we need to set pfc->SBCDWidth */

	            if (pfc->mx.transform[0][0] > 0)
	            {
	                pfc->SBCSWidth = F16_16TOLROUND(pfc->mx.transform[0][0] * pfc->pff->ifi.fwdAveCharWidth);
	            }
	            else
	            {
	                pfc->SBCSWidth = -F16_16TOLROUND(-pfc->mx.transform[0][0] * pfc->pff->ifi.fwdAveCharWidth);
	            }

            }
        // affirm that we are the ones who have set the transform last

            pfc->pff->pfcLast = pfc;
        }
        else // make sure to restore the old current transform
        {
            if (pfc->pff->pfcLast)
            {
            #if DBG
                BOOL bOkXform;
            #endif
                        
            #if DBG
                bOkXform =
            #endif
                bSetXform (
                    pfc->pff->pfcLast,
                    (BOOL)(!!(pfc->pff->pfcLast->flXform & XFORM_BITMAP_SIM_BOLD)),
                    bLastClearType
                );
                ASSERTDD(bOkXform, "bOkXform\n");
            }
        }

    }
    return (bOk);
}

/******************************Public*Routine******************************\
* vSetGrayState__FONTCONTEXT                                               *
*                                                                          *
* This routine set the FO_GRAY16 bit in pfc->flFontType and                *
* pfc->pfo->flFontType as is appropriate. If the bit is set                *
* then, later on, we shall make calls to the fs_FindGraySize and           *
* fs_ContourGrayScan pair instead of the usual monochrome pair of          *
* calls, fs_FindBitmapSize and fs_ContourScan.                             *
*                                                                          *
* The only effect that this routine could have is to clear                 *
* the FO_GRAY16 flags in pfc->flFontType and pfc->pfo->flFontType.         *
*                                                                          *
* The only way in which this clearing could occur is if all of the         *
* following conditions are met: 1) the caller has not set the              *
* FO_NO_CHOICE bit; 2) the font has a 'gasp' table; 3) the 'gasp'          *
* table indicates that for the requested number of pixels per em           *
* the 'gasp' table indicates that the font should not be grayed; 4)        *
* the glyphs of the font are not acted upon by a simple scaling            *
* transformation.                                                          *
*                                                                          *
* On Entry                                                                 *
*                                                                          *
*   pfc->flFontType & FO_GRAY16      != 0                                  *
*   pfc->pfo->flFontType & FO_GRAY16 != 0                                  *
*                                                                          *
* Procedure                                                                *
*                                                                          *
*   1. if the force bit is on then go to 6.                                *
*   2. if the transformation is not axial then go to 6.                    *
*   3. if the font does not gave a 'gasp' table then go to 6.              *
*   4. if the gasp table says that this size is ok for graying then        *
*      go to 6.                                                            *
*   5. clear the FO_GRAY16 flags in both places                            *
*   6. return                                                              *
*                                                                          *
* History:                                                                 *
*  Fri 10-Feb-1995 14:02:51 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID vSetGrayState__FONTCONTEXT(FONTCONTEXT *this)
{
    #if DBG
        void vPrintGASPTABLE(GASPTABLE*);
    #endif

    ptrdiff_t dp;               // offset from the beginning of the font to the
                                // 'gasp' table
    GASPTABLE *pgasp;           // pointer to the 'gasp' table
    GASPRANGE *pgr, *pgrOut;

    ASSERTDD(
        this->flFontType == this->pfo->flFontType
      ,"flFontType value should be identical here\n"
    );
    ASSERTDD(
        !(this->flFontType & FO_CHOSE_DEPTH)
       ,"We should not have chosen a level at this time\n"
    );

    this->flFontType |= FO_CHOSE_DEPTH;
    if (this->flFontType & FO_GRAY16)
    {
        this->flFontType &= ~(FO_GRAY16);
        if (this->flFontType & FO_NO_CHOICE)
        {
            this->flFontType |= FO_GRAY16;
        }
        else
        {
            UINT16 cRanges;
            dp = (ptrdiff_t) this->ptp->ateOpt[IT_OPT_GASP].dp;
            pgasp = (GASPTABLE*) (((BYTE *)(this->pff->pvView)) + dp);

            if( (dp == 0) || !bValidRangeGASP(pgasp, this->ptp->ateOpt[IT_OPT_GASP].cj,&cRanges) )
            {
                USHORT fs;

                // Win95 lifts the default GASP tables from the registry
                // We should have the same behavior. Bug #11755

                #define US2BE(x)     ((((x) >> 8) | ((x) << 8)) & 0xFFFF)
                static CONST USHORT gaspDefaultRegular[] = {
                    US2BE(0)    // version
                  , US2BE(3)    // numRanges
                  , US2BE(8)         , US2BE(GASP_DOGRAY)
                  , US2BE(17)        , US2BE(GASP_GRIDFIT)
                  , US2BE(USHRT_MAX) , US2BE(GASP_GRIDFIT + GASP_DOGRAY)
                };
                static CONST USHORT gaspDefaultBold[] = {
                    US2BE(0)     // version
                  , US2BE(2)     // numRanges
                  , US2BE(8)         , US2BE(GASP_DOGRAY)
                  , US2BE(USHRT_MAX) , US2BE(GASP_GRIDFIT + GASP_DOGRAY)
                };
                static CONST USHORT *gaspDefaultItalic = gaspDefaultRegular;

                #if DBG
                if (gflTtfdDebug & DEBUG_GRAY)
                {
                    TtfdDbgPrint("Supplying default GASPTABLE\n");
                }
                #endif // DBG

                fs = this->pff->ifi.fsSelection;
                if (fs & FM_SEL_ITALIC)
                {
                    pgasp = (GASPTABLE*) gaspDefaultItalic;
                    cRanges = 3;
                }
                else if (fs & FM_SEL_BOLD)
                {
                    pgasp = (GASPTABLE*) gaspDefaultBold;
                    cRanges = 2;
                }
                else
                {
                    pgasp = (GASPTABLE*) gaspDefaultRegular;
                    cRanges = 3;
                }
            }
            #if DBG
            if (gflTtfdDebug & DEBUG_GRAY)
            {
                vPrintGASPTABLE(pgasp);
                EngDebugBreak();
            }
            #endif
            if (this->lEmHtDev > USHRT_MAX)
            {
                WARNING("vSetGrayScale: lEmHtDev > USHRT_MAX\n");
            }
            else
            {
                int iLow, iHt, iHigh;

                // Search the gasp table for the instructions
                // for this particular em height. I have assumed that there
                // are not too many GASP tables (typically 3 or less) so
                // I use a linear search.

                pgr     = pgasp->gaspRange;
                if (cRanges > 8)
                {
                    WARNING("Unusual GASPTABLE : cRanges > 8\n");
                    cRanges = 8;
                }
                pgrOut = pgr + cRanges;
                iLow = -1;
                iHt  = this->lEmHtDev;
                for ( ; pgr < pgrOut; pgr++)
                {
                    iHigh = (int) BE_UINT16(&(pgr->rangeMaxPPEM));
                    if (iLow < iHt && iHt <= iHigh)
                    {
                        if (GASP_DOGRAY & BE_UINT16(&(pgr->rangeGaspBehavior)))
                        {
                            this->flFontType |= FO_GRAY16;
                        }
                        break;
                    }
                    iLow = iHigh;
                }
            }
        }

        if (this->flFontType & FO_GRAY16)
        {
#if DBG
            if (gflTtfdDebug & DEBUG_GRAY)
            {
                TtfdDbgPrint("Choosing 16-Level Glyphs\n");
            }
#endif
        }
        else
        {
#if DBG
            if (gflTtfdDebug & DEBUG_GRAY)
            {
                TtfdDbgPrint(
                    "\n"
                    "We came into the routine with the FO_GRAY16 bit set.\n"
                    "However, for some reason it is not possible to has\n"
                    "anti-aliased the text. Therefore we must adjust the\n"
                    "font context and inform it that that antialiasing \n"
                    "is out of the picture. We will continue and create\n"
                    "a monochrome font.\n"
                );
            }
#endif
            this->flFontType |= FO_NOGRAY16;
            this->pfo->flFontType = this->flFontType;
        }
    }
}

/******************************Public*Routine******************************\
* vSetClearTypeState__FONTCONTEXT                                          *
*                                                                          *
* This routine set the FO_GRAY16 bit in pfc->flFontType and                *
* pfc->pfo->flFontType as is appropriate. If the bit is set                *
*                                                                          *
* History:                                                                 *
*  15-Nov-1999 by Claude Betrisey [claudebe]                               *
* Wrote it.                                                                *
\**************************************************************************/
/**********************************************************************/

/*  Find a strike that matches ppem in the bloc table, simplified from scaler\sfntaccs.c */

BOOL fd_FindBlocStrike (
	const uint8 *pbyBloc,
	uint16 usPpem,
       uint32 uSizeOfEBLC)
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;

	ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;

    if( !bValidRangeEBLC(pbyBloc, uSizeOfEBLC, &ulNumStrikes)	)
            return FALSE;

	while (ulNumStrikes > 0)
	{
		if ((usPpem == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
			(usPpem == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
		{
					return TRUE;
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
	}

	return FALSE;                                   /* match not found */
}

VOID vSetClearTypeState__FONTCONTEXT(FONTCONTEXT *this)
{

    /* we want to disable ClearType at any size that has an embedded bitmap */

    ptrdiff_t dp;               // offset from the beginning of the font to the
                                // 'EBLC' table
    uint8 *pEBLC;           // pointer to the 'EBLC' table

    ASSERTDD(
        this->flFontType == this->pfo->flFontType
      ,"flFontType value should be identical here\n"
    );
    ASSERTDD(
        !(this->flFontType & FO_CHOSE_DEPTH)
       ,"We should not have chosen a level at this time\n"
    );

    this->flFontType |= FO_CHOSE_DEPTH;


    if (this->pff->ffca.fl & FF_DBCS_CHARSET)
    {
    /* we test for embedded bitmaps only for fonts that support FE charsets */
        if ((this->flXform & (XFORM_HORIZ | XFORM_VERT)) && 
            ((this->mx.transform[0][0] == this->mx.transform[1][1]) || (this->mx.transform[0][0] == -this->mx.transform[1][1]) ) &&
            ((this->mx.transform[0][1] == this->mx.transform[1][0]) || (this->mx.transform[0][1] == -this->mx.transform[1][0])) )
        {
            /* we only want to look for embedded bitmap if we are in a square transformation that is a multiple of 90 degree rotation */
            if ((dp = (ptrdiff_t)(this->ptp->ateOpt[IT_OPT_EBLC].dp)))
            {

                pEBLC = (uint8*) (((BYTE *)(this->pff->pvView)) + dp);

		        if (fd_FindBlocStrike (pEBLC, (uint16)this->lEmHtDev, this->ptp->ateOpt[IT_OPT_EBLC].cj) )
		        {
	                this->flFontType &= ~(FO_GRAY16 | FO_CLEARTYPE_X);
	                this->flFontType |= FO_NOCLEARTYPE;
	                this->pfo->flFontType = this->flFontType;
	            }
            }
        }
    }

    if (this->pff->ffca.fl & FF_TYPE_1_CONVERSION)
    {
        this->flFontType &= ~(FO_GRAY16 | FO_CLEARTYPE_X);
	    this->flFontType |= FO_NOCLEARTYPE;
	    this->pfo->flFontType = this->flFontType;
    }
    else if (!_wcsicmp((PWSTR)((BYTE*)&this->pff->ifi + this->pff->ifi.dpwszFamilyName),L"Marlett"))
    {
        /* we want to disable ClearType for the Marlett font */
	    this->flFontType &= ~(FO_GRAY16 | FO_CLEARTYPE_X);
	    this->flFontType |= FO_NOCLEARTYPE;
	    this->pfo->flFontType = this->flFontType;
    }

}

#if DBG
/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vPrintGASPTABLE                                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps a GASPTABLE to the debug screen                                  *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgasp   --  pointer to a big endian GASPTABLE                          *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vPrintGASPTABLE(GASPTABLE *pgasp)
{
    GASPRANGE *pgr, *pgrOut;

    TtfdDbgPrint(
        "\n"
        "-------------------------------------\n"
        "GASPTABLE HEADER\n"
        "-------------------------------------\n"
        "pgasp     = %-#x\n"
        "version   = %d\n"
        "numRanges = %d\n"
        "-------------------------------------\n"
        "    rangeMaxPPEM    rangeGaspBehavior\n"
        "-------------------------------------\n"
       , pgasp
       , BE_UINT16(&(pgasp->version))
       , BE_UINT16(&(pgasp->numRanges))
    );
    pgr     = pgasp->gaspRange;
    pgrOut  = pgr + BE_UINT16(&(pgasp->numRanges));
    for (pgr = pgasp->gaspRange; pgr < pgrOut; pgr++)
    {
        char *psz;
        USHORT us = BE_UINT16(&(pgr->rangeGaspBehavior));
        us &= (GASP_GRIDFIT | GASP_DOGRAY);
        switch (us)
        {
        case 0:
            psz = "";
            break;
        case GASP_GRIDFIT:
            psz = "GASP_GRIDFIT";
            break;
        case GASP_DOGRAY:
            psz = "GASP_DOGRAY";
            break;
        case GASP_GRIDFIT | GASP_DOGRAY:
            psz = "GASP_GRIDFIT | GASP_DOGRAY";
            break;
        }
        TtfdDbgPrint(
            "    %12d    %s\n"
          , BE_UINT16(&(pgr->rangeMaxPPEM))
          , psz
        );
    }
    TtfdDbgPrint(
        "-------------------------------------\n\n\n"
    );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\dbg.h ===
/******************************Module*Header*******************************\
* Module Name: dbg.h
*
* several debug routines
*
* Created: 20-Feb-1992 16:00:36
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/




// all the routines in this file MUST BE under DBG

#define DEBUG_GRAY  1

#if DBG

extern int ttfdDebugLevel;

VOID TtfdDbgPrint(PCHAR DebugMessage,...);

#define KPRINT(x)

VOID  vDbgCurve(TTPOLYCURVE *pcrv);
VOID  vDbgGridFit(fs_GlyphInfoType *pout);
VOID  vDbgGlyphset(PFD_GLYPHSET pgset);


#define RIP(x)        { TtfdDbgPrint(x); EngDebugBreak();}
#define ASSERTDD(x,y) { if (!(x)) { TtfdDbgPrint(y); EngDebugBreak();} }
#define WARNING(x)    TtfdDbgPrint(x)

#define TTFD_PRINT(x,_y_) if (ttfdDebugLevel >= (x)) TtfdDbgPrint _y_


#else

#define KPRINT(x)

#define RIP(x)
#define ASSERTDD(x,y)
#define WARNING(x)
#define TTFD_PRINT(x,y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\scaler\subpixel.c ===
/*********************************************************************

	  subpixel.c -- sub pixel rendering

	  (c) Copyright 1999-2000  Microsoft Corp.  All rights reserved.

 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "scentry.h"             /* for own function prototypes */

#ifdef FSCFG_SUBPIXEL

#ifdef FSCFG_SUBPIXEL_STANDALONE

// this should be considered a temporary solution. currently, the rasterizer is plumbed for 8 bpp output in SubPixel,
// and appears to have John Platt's filter hard-wired in. In the future, we would rather have the overscaled b/w bitmap
// as output, such that we can do any color filtering and gamma correction outside and independent of the rasterizer

// Index values for wRGBColors and awColorIndexTable

#define RED_INDEX	0
#define GREEN_INDEX	1
#define	BLUE_INDEX	2

// The abColorIndexTable datastructure contains one entry for each virtual subpixel.
// We index into this table to determine which color is assigned to that subpixel.
// To create the table, we set the first number of subpixels assigned to red to the red index,
// and likewise for green and blue.

static const uint8 abColorIndexTable[2][RGB_OVERSCALE] = // 2 Tables to indicate color for each subpixel, 0 = RGB striping order, 1 = BGR striping order
	{{RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,														// R_Subpixels, hard-wired
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,	// G_Subpixels, hard-wired
	  BLUE_INDEX, BLUE_INDEX},																						// B_Subpixels, hard-wired
	 {BLUE_INDEX, BLUE_INDEX,
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,
	  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX}};

#define PIXEL_ON	1
#define PIXEL_OFF	0
#define CHAR_BIT	8         /* number of bits in a char */

char GetInputPixel( char *pbyInputRowData, uint32 ulWidthIndex )
{
	uint32	ulRowIndex;
	char	byPixelMask;
	
	ulRowIndex = ulWidthIndex / CHAR_BIT;			// Determines which byte to check out
	byPixelMask = 0x80 >> ulWidthIndex % CHAR_BIT; // Determine offset within byte
	return ( (pbyInputRowData[ ulRowIndex ] & byPixelMask)?PIXEL_ON:PIXEL_OFF );
}


FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
	char byPixel;						// Contents of one pixel from the rasterizer
	uint16 usRGBColors[ 3 ];				// Contains sum of each color based on number of subpixels
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;
    uint32 ulBytes;
	
	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = ulOverscaledBitmapWidth + sBitmapSubPixelStart;

    /* clear the resulting bitmap */
	ulBytes = (uint32)SubPixelBitMap->sRowBytes * (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				
		// Initialize RGBColors

		usRGBColors[RED_INDEX] = 0;
		usRGBColors[GREEN_INDEX] = 0;
		usRGBColors[BLUE_INDEX] = 0;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = sBitmapSubPixelStart; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            byPixel = GetInputPixel( pbyInputRowData, ulWidthIndex - sBitmapSubPixelStart );
			FS_ASSERT((byPixel <= 1),"Input Pixel greater than one");
			usRGBColors[abColorIndexTable[bgrOrder][ulWidthIndex % RGB_OVERSCALE]] += byPixel;

			// If we've finished one pixel or the scanline, write out pixel 

			if((( ulWidthIndex % RGB_OVERSCALE ) == (uint32)(RGB_OVERSCALE - 1)) || // Finish one pixel
				ulWidthIndex == ( ulOverscaledBitmapWidth + sBitmapSubPixelStart - 1) ) // Finish row
			{
                /* write out current pixel, 8 bits in range 0 through 179 = (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) */

                usColorIndex = usRGBColors[RED_INDEX]   * (G_Subpixels + 1) * (B_Subpixels + 1) +
                               usRGBColors[GREEN_INDEX] * (B_Subpixels + 1) +
                               usRGBColors[BLUE_INDEX];

                        FS_ASSERT((usColorIndex < 256),"Resulting pixel doesn't fit in a byte");

                *pbyOutputRowData = (char) usColorIndex;
                pbyOutputRowData++;
				usRGBColors[RED_INDEX] = 0;
				usRGBColors[GREEN_INDEX] = 0;
				usRGBColors[BLUE_INDEX] = 0;
            }
		}
	}
}

#else // !FSCFG_SUBPIXEL_STANDALONE


#define CHAR_BIT      8         /* number of bits in a char */

unsigned char ajRGBToWeight222[64] = {
    0,1,1,2,4,5,5,6,4,5,5,6,8,9,9,10,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    32,33,33,34,36,37,37,38,36,37,37,38,40,41,41,42};

    unsigned char ajRGBToWeightMask[CHAR_BIT] = { 
        0xFC, 0x7E, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01};

FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;

    uint16 usSubPixelIndex;
    int16 uSubPixelRightShift, uSubPixelLeftShift;
    char * pbyInputEndRowData;


	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = (uint32)(SubPixelBitMap->rectBounds.right - SubPixelBitMap->rectBounds.left);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
        pbyInputEndRowData = pbyInputRowData + OverscaledBitmap->sRowBytes;
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				

        /* do the first partial byte : */

        usColorIndex = (unsigned char)(*pbyInputRowData) >> (sBitmapSubPixelStart + (8 - RGB_OVERSCALE));
        usColorIndex = ajRGBToWeight222[usColorIndex];

        *pbyOutputRowData = (char) usColorIndex;

        pbyOutputRowData++;

        usSubPixelIndex = (CHAR_BIT + RGB_OVERSCALE - sBitmapSubPixelStart) % CHAR_BIT;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = 1; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            uSubPixelLeftShift = 0;
            uSubPixelRightShift = CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;
            if (uSubPixelRightShift < 0) 
            {
                uSubPixelLeftShift = - uSubPixelRightShift;
                uSubPixelRightShift = 0;
            }

            usColorIndex = ((unsigned char)(*pbyInputRowData) & ajRGBToWeightMask[usSubPixelIndex]) >> uSubPixelRightShift << uSubPixelLeftShift;

            if (pbyInputRowData+1 < pbyInputEndRowData)
            {
                /* avoid reading too far for the partial pixel at the end */
                uSubPixelRightShift = CHAR_BIT + CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;

                usColorIndex += (unsigned char)(*(pbyInputRowData+1)) >> uSubPixelRightShift;
            }
            usColorIndex = ajRGBToWeight222[usColorIndex];

            *pbyOutputRowData = (char) usColorIndex;

            pbyOutputRowData++;

            usSubPixelIndex = (usSubPixelIndex + RGB_OVERSCALE);
            if (usSubPixelIndex >= CHAR_BIT)
            {
                usSubPixelIndex = usSubPixelIndex % CHAR_BIT;
                pbyInputRowData ++;
            }
		}
	}
}

#endif // FSCFG_SUBPIXEL_STANDALONE

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\dbg.c ===
/******************************Module*Header*******************************\
* Module Name: dbg.c
*
* several debug routines
*
* Created: 20-Feb-1992 16:00:36
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/

#include "fd.h"
#include "fdsem.h"


#if DBG


int ttfdDebugLevel = 1;

VOID
TtfdDbgPrint(
    PCHAR DebugMessage,
    ...
    )
{

    va_list ap;

    va_start(ap, DebugMessage);

    EngDebugPrint("",DebugMessage, ap);

    va_end(ap);

}


/******************************Public*Routine******************************\
*
*     vDbgCurve
*
* Effects: prints curve contensts
*
*
* History:
*  20-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID  vDbgCurve(TTPOLYCURVE *pcrv)
{
    PSZ               psz;
    POINTFIX        * pptfix, * pptfixEnd;

    if (pcrv->wType == TT_PRIM_QSPLINE)
    {
        psz = "TT_PRIM_QSPLINE";
    }
    else if (pcrv->wType == TT_PRIM_LINE)
    {
        psz = "TT_PRIM_LINE";
    }
    else
    {
        psz = "BOGUS CURVE TYPE";
    }
    TtfdDbgPrint("\n\nCurve: %s, cpfx = %ld\n", psz, pcrv->cpfx);


    pptfixEnd = (POINTFIX *)pcrv->apfx + pcrv->cpfx;
    for (pptfix = (POINTFIX *)pcrv->apfx; pptfix < pptfixEnd; pptfix++)
        TtfdDbgPrint("x = 0x%lx, y = 0x%lx \n", pptfix->x, pptfix->y);


}


/******************************Public*Routine******************************\
*
* vDbgGridFit(fs_GlyphInfoType *pout)
*
*
* Effects:
*
* Warnings:
*
* History:
*  17-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vDbgGridFit(fs_GlyphInfoType *pout)
{
// this is spline data returned that we want to print

    uint32       cpt, cptTotal;     // total number of points:
    uint32       cptContour;        // total number of points in a contour:

    F26Dot6     *xPtr, *yPtr;
    int16       *startPtr;
    int16       *endPtr;
    uint8       *onCurve;

    uint32      c, cContours;
    int32       ipt;

    xPtr      = pout->xPtr;
    yPtr      = pout->yPtr;
    startPtr  = pout->startPtr;
    endPtr    = pout->endPtr;
    onCurve   = pout->onCurve;
    cContours = pout->numberOfContours;

    cptTotal = (uint32)(pout->endPtr[cContours - 1] + 1);

    TtfdDbgPrint("\n outlinesExist = %ld, numberOfCountours = %ld, cptTotal = %ld\n",
        (uint32)pout->outlinesExist,
        (uint32)pout->numberOfContours,
        cptTotal
        );

    if (!pout->outlinesExist)
        return;

// both statPtr and endPtr are inclusive: so that the folowing rule applies:
//  startPtr[i + 1] = endPtr[i] + 1;

    cpt = 0;   // initialize total number of points

    for (c = 0; c < cContours; c++, startPtr++, endPtr++)
    {
        cptContour = (uint32)(*endPtr - *startPtr + 1);
        TtfdDbgPrint ("start = %ld, end = %ld \n", (int32)*startPtr, (int32)*endPtr);

        for (ipt = (int32)*startPtr; ipt <= (int32)*endPtr; ipt++)
        {
            TtfdDbgPrint("x = 0x%lx, y = 0x%lx, onCurve = 0x%lx\n",
                    xPtr[ipt], yPtr[ipt], (uint32)onCurve[ipt]);
        }
        cpt += cptContour;
    }

    ASSERTDD(cpt == cptTotal, "cptTotal\n");
}

/******************************Public*Routine******************************\
*
* vDbgGlyphset
*
* Effects:
*
* Warnings:
*
* History:
*  20-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vDbgGlyphset(PFD_GLYPHSET pgset)
{
    ULONG i;

    TtfdDbgPrint("\n\n cRuns = %ld, cGlyphsSupported = %ld \n\n",
                   pgset->cRuns, pgset->cGlyphsSupported);
    for (i = 0; i < pgset->cRuns; i++)
        TtfdDbgPrint("wcLow = 0x%lx, wcHi = 0x%lx\n",
                  (ULONG)pgset->awcrun[i].wcLow,
                  (ULONG)pgset->awcrun[i].wcLow + (ULONG)pgset->awcrun[i].cGlyphs - 1);
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\fdfon.c ===
/******************************Module*Header*******************************\
* Module Name: fdfon.c
*
* basic file claim/load/unload font file functions
*
* Created: 08-Nov-1991 10:09:24
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/
#include "fd.h"
#include <stdlib.h>
#include <winerror.h>

#define SZ_GLYPHSET_CACHE(r, g) ( offsetof(FD_GLYPHSET,awcrun) + (r)*sizeof(WCRUN) + (g)*sizeof(USHORT))

#define SZ_GLYPHSET_WRUN(r) ( offsetof(FD_GLYPHSET,awcrun) + (r)*sizeof(WCRUN))

BOOL
bLoadTTF (
    ULONG_PTR iFile,
    PVOID     pvView,
    ULONG     cjView,
    ULONG     ulTableOffset,
    ULONG     ulLangId,
    HFF       *phff,
    PTTF_CACHE  pCache,
    ULONG     ulFastCheckSum
    );

#define NOEMCHARSETS 16
void vFillIFICharsets(FONTFILE *pff, IFIMETRICS *pifi, BYTE *aCharSets, BYTE *pjView, BYTE * pjOS2, fs_GlyphInputType *pgin);
VOID vGetVerticalGSet(PFD_GLYPHSET pgsetv, PFONTFILE pff);

// CMI_2219_PRESENT set if 2219 is     supported in a font
// CMI_B7_ABSENT    set if b7   is NOT supported in a font
// CMI_5C_SPLIT     set for TT shell font and current system locale is Japanese or Korean

#define CMI_2219_PRESENT 1
#define CMI_B7_ABSENT    2
#define CMI_5C_SPLIT     4

// Those 2 value is for NT shell font, if we change the font name \
// Then we need to update these 2 values.

#define PSZ_MICROSS_SHELLFONT       "Microsoft Sans Serif Regular"
#define MICROSS_SHELLFONT_SIZE      (sizeof(PSZ_MICROSS_SHELLFONT) - 1)
#define PSZ_TAHOMA_SHELLFONT        "Microsoft Tahoma Regular"
#define TAHOMA_SHELLFONT_SIZE       (sizeof(PSZ_TAHOMA_SHELLFONT) - 1)
#define PSZ_TAHOMA_BOLD_SHELLFONT   "Microsoft Tahoma Bold"
#define TAHOMA_BOLD_SHELLFONT_SIZE  (sizeof(PSZ_TAHOMA_BOLD_SHELLFONT) - 1)
#define MICROSS_SHELLFONT           0x1
#define TAHOMA_SHELLFONT            0x2
#define TAHOMA_BOLD_SHELLFONT       0x3

#define PSZ_MS_MINCHO               L"Microsoft:MS Mincho:1995"
#define PSZ_MS_PMINCHO              L"Microsoft:MS PMincho:1995"
#define PSZ_MS_GOTHIC               L"Microsoft:MS Gothic:1995"
#define PSZ_MS_PGOTHIC              L"Microsoft:MS PGothic:1995"

extern DWORD fs[];  // charset/fs table
extern UINT  nCharsets;
extern UINT  charsets[];
extern UINT  codepages[];

// this routine checks if any dbcs charsets are supported in a font
// gre\pfeobj.cxx

extern BOOL IsAnyCharsetDbcs(IFIMETRICS *pifi);



BOOL IsCurrentCodePageDBCS()
{
    USHORT AnsiCodePage, OemCodePage;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

    return(AnsiCodePage == 932  || AnsiCodePage == 949  ||
           AnsiCodePage == 1361 || AnsiCodePage == 936  || AnsiCodePage == 950 );
}

STATIC BOOL  bContainGlyphSet
(
WCHAR                 wc,
PFD_GLYPHSET          pgset
);

// Windows 95-J and Windows NT 3.51J shipped some fonts with buggy signatures.
// These fonts are shift-jis fonts but have just one entry in the signature
// saying the are Chinese fonts.  NT 4.0 also shipped one of these fonts in
// a lang pack and NEC based some fonts on these fonts and shipped them with
// their systems.  This routine detects these bogus signatures so that we
// will ignore them when computing charset and so that we can put the right
// signature value in the ifimetrics.


BOOL IsBogusSignature(ULONG ulCodePageRange, PFONTFILE pff)
{
    if((!(ulCodePageRange & FS_JISJAPAN))                             &&
       (pff->ffca.ui16SpecificID == BE_SPEC_ID_SHIFTJIS)                   &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_A , pff->pgset ) &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_I , pff->pgset ) &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_U , pff->pgset ) &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_E , pff->pgset ) &&
       bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_O , pff->pgset ))
    {
        return(TRUE);
    }
    else
    {
        if (ulCodePageRange & FS_CHINESESIMP)
        {
            PWCHAR pszUnique; 
            pszUnique = (PWCHAR) (pff->ifi.dpwszUniqueName + (PBYTE) &pff->ifi);
            if (!_wcsicmp(pszUnique, PSZ_MS_MINCHO) || !_wcsicmp(pszUnique, PSZ_MS_PMINCHO)
                || !_wcsicmp(pszUnique, PSZ_MS_GOTHIC) || !_wcsicmp(pszUnique, PSZ_MS_PGOTHIC))                
                return (TRUE);                
            else
                return (FALSE);
        }
        else
        {
            return(FALSE);
        }
    }
}

STATIC UINT GetCodePageFromSpecId( uint16 ui16SpecId )
{
    USHORT AnsiCodePage, OemCodePage;
    UINT iCodePage;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

    iCodePage = AnsiCodePage;

    switch( ui16SpecId )
    {
        case BE_SPEC_ID_SHIFTJIS :
            iCodePage = 932;
            break;

        case BE_SPEC_ID_GB :
            iCodePage = 936;
            break;

        case BE_SPEC_ID_BIG5 :
            iCodePage = 950;
            break;

        case BE_SPEC_ID_WANSUNG :
            iCodePage = 949;
            break;

        default :
            WARNING("TTFD!:Unknown SPECIFIC ID\n");
            break;
    }

    return( iCodePage );
}

STATIC BOOL bVerifyMsftHighByteTable
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
CMAPINFO          * pcmi,
uint16              ui16SpecID,
uint32 sizeOfCmap,
uint32 offset
);

STATIC ULONG cjComputeGLYPHSET_HIGH_BYTE
(
sfnt_mappingTable     *pmap,
ULONG                **ppgset,
CMAPINFO              *pcmi
);

STATIC BOOL bVerifyMsftTableGeneral
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
CMAPINFO          * pcmi,
uint16              ui16SpecID,
uint32 sizeOfCmap,
uint32 offset,
sfnt_char2IndexDirectory * pcmap
);

STATIC ULONG cjComputeGLYPHSET_MSFT_GENERAL
(
sfnt_mappingTable     *pmap,
ULONG                  cGlyphs,
ULONG                **ppgset,
CMAPINFO              *pcmi
);



STATIC ULONG cjComputeGLYPHSET_TEMPLATE
(
fs_GlyphInputType     *pgin,
FD_GLYPHSET          **pgset,
ULONG                  ul_wcBias,
ULONG                  iGsetType
);

STATIC ULONG cjComputeGLYPHSET_OLDBIDI     // Old BiDi (win 31) TTF font pages
(
 fs_GlyphInputType  *pgin,
 FD_GLYPHSET        **ppgset,
 ULONG              ul_wcBias
 ) ;


STATIC uint16 ui16BeLangId(ULONG ulPlatId, ULONG ulLangId)
{
    ulLangId = CV_LANG_ID(ulPlatId,ulLangId);
    return BE_UINT16(&ulLangId);
}


STATIC FSHORT  fsSelectionTTFD(BYTE *pjView, TABLE_POINTERS *ptp)
{
    PBYTE pjOS2 = (ptp->ateOpt[IT_OPT_OS2].dp)        ?
                  pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                  NULL                                ;

    sfnt_FontHeader * phead = (sfnt_FontHeader *)(pjView + ptp->ateReq[IT_REQ_HEAD].dp);

//
// fsSelection
//
    ASSERTDD(TT_SEL_ITALIC     == FM_SEL_ITALIC     , "ITALIC     \n");
    ASSERTDD(TT_SEL_UNDERSCORE == FM_SEL_UNDERSCORE , "UNDERSCORE \n");
    ASSERTDD(TT_SEL_NEGATIVE   == FM_SEL_NEGATIVE   , "NEGATIVE   \n");
    ASSERTDD(TT_SEL_OUTLINED   == FM_SEL_OUTLINED   , "OUTLINED   \n");
    ASSERTDD(TT_SEL_STRIKEOUT  == FM_SEL_STRIKEOUT  , "STRIKEOUT  \n");
    ASSERTDD(TT_SEL_BOLD       == FM_SEL_BOLD       , "BOLD       \n");

    if (pjOS2)
    {
        return((FSHORT)BE_UINT16(pjOS2 + OFF_OS2_usSelection));
    }
    else
    {
    #define  BE_MSTYLE_BOLD       0x0100
    #define  BE_MSTYLE_ITALIC     0x0200

        FSHORT fsSelection = 0;

        if (phead->macStyle & BE_MSTYLE_BOLD)
            fsSelection |= FM_SEL_BOLD;
        if (phead->macStyle & BE_MSTYLE_ITALIC)
            fsSelection |= FM_SEL_ITALIC;

        return fsSelection;
    }
}



STATIC BOOL  bComputeIFISIZE
(
BYTE             *pjView,
TABLE_POINTERS   *ptp,
uint16            ui16PlatID,
uint16            ui16SpecID,
uint16            ui16LangID,
PIFISIZE          pifisz,
BOOL             *pbType1,
ULONG            *pulShellFont
);

static BOOL bConvertExtras(PIFIMETRICS  pifi,
                           PIFISIZE pifisz,
                           uint16 ui16LanguageID);


STATIC BOOL  bCheckLocaTable
(
int16   indexToLocFormat,
BYTE    *pjView,
TABLE_POINTERS   *ptp,
uint16  numGlyphs
);

STATIC BOOL  bCheckHdmxTable
(
sfnt_hdmx      *phdmx,
ULONG           size
);

STATIC BOOL bCvtUnToMac(BYTE *pjView, TABLE_POINTERS *ptp, uint16 ui16PlatformID);

STATIC BOOL  bVerifyTTF
(
PVOID               pvView,
ULONG               cjView,
PBYTE               pjOffsetTable,
ULONG               ulLangId,
PTABLE_POINTERS     ptp,
PIFISIZE            pifisz,
uint16             *pui16PlatID,
uint16             *pui16SpecID,
sfnt_mappingTable **ppmap,
ULONG              *pulGsetType,
ULONG              *pul_wcBias,
CMAPINFO           *pcmi,
BOOL               *pbType1,
ULONG              *pulShellFont
);

STATIC BOOL  bGetTablePointers
(
PVOID               pvView,
ULONG               cjView,
PBYTE               pjOffsetTable,
PTABLE_POINTERS  ptp
);

STATIC BOOL IsValidFormat4TableSize
(
uint16   cRuns,
sfnt_char2IndexDirectory * pcmap,
uint32      offsetOfSubTable,
uint32      sizeOfCmap
);

STATIC BOOL bVerifyMsftTable
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
ULONG             * pul_wcBias,
CMAPINFO          * pcmi,
uint16              ui16SpecID,
ULONG             * pul_startCount,
uint32 sizeOfCmap,
uint32 offset,
sfnt_char2IndexDirectory * pcmap
);


STATIC BOOL  bVerifyMacTable(sfnt_mappingTable * pmap, uint32 sizeOfCmap, uint32 offset);


STATIC BOOL bComputeIDs
(
BYTE                     * pjView,
TABLE_POINTERS           * ptp,
uint16                   * pui16PlatID,
uint16                   * pui16SpecID,
sfnt_mappingTable       ** ppmap,
ULONG                    * pulGsetType,
ULONG                    * pul_wcBias,
CMAPINFO                 * pcmi
);


STATIC VOID vFill_IFIMETRICS
(
PFONTFILE       pff,
PIFIMETRICS     pifi,
PIFISIZE        pifisz,
fs_GlyphInputType     *pgin
);

BYTE jIFIMetricsToGdiFamily (PIFIMETRICS pifi);


BOOL
ttfdUnloadFontFileTTC (
    HFF hff
    )
{
    ULONG i;
    BOOL  bRet = TRUE;
    #if DBG
    ULONG ulTrueTypeResource = PTTC(hff)->ulTrueTypeResource;
    #endif

    // free hff for this ttc file.

    for( i = 0; i < PTTC(hff)->ulNumEntry; i++ )
    {
        if(PTTC(hff)->ahffEntry[i].iFace == 1)
        {
            if( !ttfdUnloadFontFile(PTTC(hff)->ahffEntry[i].hff) )
            {
                WARNING("TTFD!ttfdUnloadFontFileTTC(): ttfdUnloadFontFile fail\n");
                bRet = FALSE;
            }

            #if DBG
            ulTrueTypeResource--;
            #endif
        }
    }

    if (PTTC(hff)->pga)
        V_FREE(PTTC(hff)->pga);

    // finally free the memory for the ttc itself

    vFreeTTC(PTTC(hff));

    ASSERTDD(ulTrueTypeResource == 0L,
              "TTFD!ttfdUnloadFontFileTTC(): ulTrueTypeResource != 0\n");

    return(bRet);
}

/******************************Public*Routine******************************\
*
* ttfdUnloadFontFile
*
*
* Effects: done with using this tt font file. Release all system resources
* associated with this font file
*
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
ttfdUnloadFontFile (
    HFF hff
    )
{


    if (hff == HFF_INVALID)
        return(FALSE);

// check the reference count, if not 0 (font file is still
// selected into a font context) we have a problem

    ASSERTDD(PFF(hff)->cRef == 0L, "ttfdUnloadFontFile: cRef\n");

// no need to unmap the file at this point
// it has been unmapped when cRef went down to zero

// assert that pff->pkp does not point to the allocated mem

    ASSERTDD(!PFF(hff)->pkp, "UnloadFontFile, pkp not null\n");

    if(PFF(hff)->cRefGSet  != 0)
        WARNING("TTFD!cRefGSet is not 0\n");
    if(PFF(hff)->cRefGSetV != 0)
        WARNING("TTFD!cRefGSetV is not 0\n");
    if(PFF(hff)->pgset  != NULL)
        WARNING("TTFD!pgset is not NULL\n");
    if(PFF(hff)->pgsetv != NULL)
        WARNING("TTFD!pgsetv is not NULL\n");
    

// just in case we goofed up, we force free this memory

    if (PFF(hff)->pgset)
    {
        V_FREE(PFF(hff)->pgset);
        PFF(hff)->pgset = NULL;
    }

    if (PFF(hff)->pgsetv)
    {
        V_FREE(PFF(hff)->pgsetv);
        PFF(hff)->pgsetv = NULL;
    }

// free vertical ifimetrics and the vertical glyphset that are allocated of the same chunk

    if (PFF(hff)->pifi_vertical)
        V_FREE(PFF(hff)->pifi_vertical);

// free memory associated with this FONTFILE object

    vFreeFF(hff);
    return(TRUE);
}

/******************************Public*Routine******************************\
*
* BOOL bVerifyTTF
*
*
* Effects: verifies that a ttf file contains consistent tt information
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define SIZEOFHEAD      54
#define SIZEOFHHEAD     36
#define SIZEOFMAXP      32

STATIC BOOL
bVerifyTTF (
    PVOID               pvView,
    ULONG               cjView,
    PBYTE               pjOffsetTable,
    ULONG               ulLangId,
    PTABLE_POINTERS     ptp,
    PIFISIZE            pifisz,
    uint16             *pui16PlatID,
    uint16             *pui16SpecID,
    sfnt_mappingTable **ppmap,
    ULONG              *pulGsetType,
    ULONG              *pul_wcBias,
    CMAPINFO           *pcmi,
    BOOL               *pbType1,
    ULONG              *pulShellFont
    )
{
    // extern BOOL bCheckSumOK( void *pvView, ULONG cjView, sfnt_FontHeader *phead );
    sfnt_FontHeader      *phead;

    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    sfnt_maxProfileTable   *pmaxp;
    sfnt_hdmx              *phdmx;  
    sfnt_OS2               *pOS2;
    ULONG  cHMTX;

// if attempted a bm *.fon file this will fail, so do not print
// warning, but if passes this, and then fails, something is wrong

    if (!bGetTablePointers(pvView, cjView,pjOffsetTable,ptp))
    {
        return( FALSE );
    }

    phead = (sfnt_FontHeader *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HEAD].dp);
    phhea = (sfnt_HorizontalHeader *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)((BYTE *)pvView + ptp->ateReq[IT_REQ_HMTX].dp);
    pmaxp = (sfnt_maxProfileTable *)((BYTE *)pvView + ptp->ateReq[IT_REQ_MAXP].dp);
    phdmx = ptp->ateOpt[IT_OPT_HDMX].dp ? 
        (sfnt_hdmx *)((BYTE *)pvView + ptp->ateOpt[IT_OPT_HDMX].dp) : NULL;
    pOS2 = ptp->ateOpt[IT_OPT_OS2].dp ? 
        (sfnt_OS2 *)((BYTE *)pvView + ptp->ateOpt[IT_OPT_OS2].dp) : NULL;

    if(ptp->ateReq[IT_REQ_HEAD].cj < SIZEOFHEAD)
        RET_FALSE("TTFD!_bVerifyTTF, Invalid size of head table\n");

    if(ptp->ateReq[IT_REQ_HHEAD].cj < SIZEOFHHEAD)
        RET_FALSE("TTFD!_bVerifyTTF, Invalid size of hhead table\n");

    if(ptp->ateReq[IT_REQ_MAXP].cj < SIZEOFMAXP)
        RET_FALSE("TTFD!_bVerifyTTF, Invalid size of maxp table\n");

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);
 
    if (sizeof(sfnt_HorizontalMetrics) * cHMTX > ptp->ateReq[IT_REQ_HMTX].cj)
    {
        RET_FALSE("TTFD!_bVerifyTTF, Invalid size of hmtx table\n");
    }

    if (pOS2 && !bValidRangeOS2(
                    pOS2,
                    ptp->ateOpt[IT_OPT_OS2].cj )
        )
        {
            // this is an optional table we will ignore it if it's bad
            ptp->ateOpt[IT_OPT_OS2].cj = 0;
            ptp->ateOpt[IT_OPT_OS2].dp = 0;

            WARNING("TTFD!_bVerifyTTF, bCheckOS2Table failed\n");
        }

#define SFNT_MAGIC   0x5F0F3CF5
    if (BE_UINT32((BYTE*)phead + SFNT_FONTHEADER_MAGICNUMBER) != SFNT_MAGIC)
        RET_FALSE("TTFD: bVerifyTTF: SFNT_MAGIC \n");

    if (!bComputeIDs(pvView,
                     ptp,
                     pui16PlatID,
                     pui16SpecID,
                     ppmap,
                     pulGsetType,
                     pul_wcBias,
                     pcmi)
        )
        RET_FALSE("TTFD!_bVerifyTTF, bComputeIDs failed\n");


    if (!bComputeIFISIZE (
                    pvView,
                    ptp,
                    *pui16PlatID,
                    *pui16SpecID,
                    ui16BeLangId(*pui16PlatID,ulLangId),
                    pifisz,             // return results here
                    pbType1,
                    pulShellFont)
        )
        {
            RET_FALSE("TTFD!_bVerifyTTF, bComputeIFISIZE failed\n");
        }

    if (!bCheckLocaTable (
                    SWAPW(phead->indexToLocFormat),
                    pvView,
                    ptp,
                    (uint16) SWAPW(pmaxp->numGlyphs) )
        )
        {
            RET_FALSE("TTFD!_bVerifyTTF, bCheckLocaTable failed\n");
        }

    if (phdmx && !bCheckHdmxTable (
                    phdmx,
                    ptp->ateOpt[IT_OPT_HDMX].cj )
        )
        {
            // this is an optional table we will ignore it if it's bad
            ptp->ateOpt[IT_OPT_HDMX].cj = 0;
            ptp->ateOpt[IT_OPT_HDMX].dp = 0;

            WARNING("TTFD!_bVerifyTTF, bCheckHdmxTable failed\n");
        }

// all checks passed

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* PBYTE pjGetPointer(LONG clientID, LONG dp, LONG cjData)
*
* this function is required by scaler. It is very simple
* Returns a pointer to the position in a ttf file which is at
* offset dp from the top of the file:
*
* Effects:
*
* Warnings:
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


voidPtr   FS_CALLBACK_PROTO
pvGetPointerCallback(
    ULONG_PTR clientID,
    long     dp,
    long     cjData
    )
{
    cjData;

// clientID is FONTFILE structure...

    if(dp)
        if ((dp > 0) && (cjData >= 0) && (dp + cjData <= (long)PFF(clientID)->cjView))
        {
            return(voidPtr)((PBYTE)(PFF(clientID)->pvView) + dp);
        }
        else
        {
            return NULL;
        }
     else
        return(voidPtr)((PBYTE)(PFF(clientID)->pvView) +
                               (PFF(clientID)->ffca.ulTableOffset));
}


/******************************Public*Routine******************************\
*
* void vReleasePointer(voidPtr pv)
*
*
* required by scaler, the type of this function is ReleaseSFNTFunc
*
*
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void FS_CALLBACK_PROTO
vReleasePointerCallback(
    voidPtr pv
    )
{
    pv;
}


/******************************Public*Routine******************************\
*
* PBYTE pjTable
*
* Given a table tag, get a pointer and a size for the table
*
* History:
*  11-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


PBYTE pjTable(ULONG ulTag, PFONTFILE pff, ULONG *pcjTable)
{
    INT                 cTables;
    sfnt_OffsetTable    *pofft;
    register sfnt_DirectoryEntry *pdire, *pdireEnd;

// offset table is at the very top of the file,

    pofft = (sfnt_OffsetTable *) ((PBYTE) (pff->pvView) + pff->ffca.ulTableOffset);

    cTables = (INT) SWAPW(pofft->numOffsets);

// do linear search, this is usually small list and it is NOT always
// ordered by the tag as ttf spec says it should be.

    pdireEnd = &pofft->table[cTables];

    for
    (
        pdire = &pofft->table[0];
        pdire < pdireEnd;
        ((PBYTE)pdire) += SIZE_DIR_ENTRY
    )
    {

        if (ulTag == pdire->tag)
        {
            ULONG ulOffset = (ULONG)SWAPL(pdire->offset);
            ULONG ulLength = (ULONG)SWAPL(pdire->length);

        // check if the ends of all tables are within the scope of the
        // tt file. If this is is not the case trying to access the field in the
        // table may result in an access violation, as is the case with the
        // spurious FONT.TTF that had the beginning of the cmap table below the
        // end of file, which was resulting in the system crash reported by beta
        // testers. [bodind]

            if
            (
             !ulLength ||
             ((ulOffset + ulLength) > pff->cjView)
            )
            {
                RETURN("TTFD: pjTable: table offset/length \n", NULL);
            }
            else // we found it
            {
                *pcjTable = ulLength;
                return ((PBYTE)(pff->pvView) + ulOffset);
            }
        }
    }

// if we are here, we did not find it.

    return NULL;
}

/******************************Public*Routine******************************\
*
* bGetTablePointers - cache the pointers to all the tt tables in a tt file
*
* IF a table is not present in the file, the corresponding pointer is
* set to NULL
*
*
* //   tag_CharToIndexMap              // 'cmap'    0
* //   tag_GlyphData                   // 'glyf'    1
* //   tag_FontHeader                  // 'head'    2
* //   tag_HoriHeader                  // 'hhea'    3
* //   tag_HorizontalMetrics           // 'hmtx'    4
* //   tag_IndexToLoc                  // 'loca'    5
* //   tag_MaxProfile                  // 'maxp'    6
* //   tag_NamingTable                 // 'name'    7
* //   tag_Postscript                  // 'post'    9
* //   tag_OS_2                        // 'OS/2'    10
*
* // optional
*
* //   tag_ControlValue                // 'cvt '    11
* //   tag_FontProgram                 // 'fpgm'    12
* //   tag_HoriDeviceMetrics           // 'hdmx'    13
* //   tag_Kerning                     // 'kern'    14
* //   tag_LTSH                        // 'LTSH'    15
* //   tag_PreProgram                  // 'prep'    16
* //   tag_GlyphDirectory              // 'gdir'    17
* //   tag_Editor0                     // 'edt0'    18
* //   tag_Editor1                     // 'edt1'    19
* //   tag_Encryption                  // 'cryp'    20
*
*
* returns false if all of required pointers are not present
*
* History:
*  05-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bGetTablePointers (
    PVOID            pvView,
    ULONG            cjView,
    PBYTE            pjOffsetTable,
    PTABLE_POINTERS  ptp
    )
{
    INT                 iTable;
    INT                 cTables;
    sfnt_OffsetTable    *pofft;
    register sfnt_DirectoryEntry *pdire, *pdireEnd;
    ULONG                ulTag;
    BOOL                 bRequiredTable;

    if ((PBYTE)pvView > pjOffsetTable ||
        pjOffsetTable > pjOffsetTable+offsetof(sfnt_OffsetTable, table) ||
        pjOffsetTable+offsetof(sfnt_OffsetTable, table) > (PBYTE)pvView + cjView
       )
        RET_FALSE("ttfd!font corruption: table directory header is out of file\n");


// offset table is at the very top of the file,

    pofft = (sfnt_OffsetTable *)pjOffsetTable;

// check version number, if wrong exit before doing
// anything else. This line rejects bm FON files
// if they are attempted to be loaed as TTF files
// Version #'s are in big endian.

#define BE_VER1     0x00000100
#define BE_VER2     0x00000200

    if ((pofft->version != BE_VER1) && (pofft->version !=  BE_VER2))
        return (FALSE); // *.fon files fail this check, make this an early out

// clean up the pointers

    RtlZeroMemory((VOID *)ptp, sizeof(TABLE_POINTERS));

    cTables = (INT) SWAPW(pofft->numOffsets);

    if (cTables > MAX_TABLES)
        WARNING ("TTFD!cTables > MAX_TABLES\n");

    pdireEnd = &pofft->table[cTables];

    if (pjOffsetTable+offsetof(sfnt_OffsetTable, table) > (PBYTE)pdireEnd ||
        (PBYTE)pdireEnd > (PBYTE)pvView + cjView
       )
        RET_FALSE("ttfd!font corruption: table directory is out of file\n");

    for
    (
        pdire = &pofft->table[0];
        pdire < pdireEnd;
        ((PBYTE)pdire) += SIZE_DIR_ENTRY
    )
    {
        ULONG ulOffset = (ULONG)SWAPL(pdire->offset);
        ULONG ulLength = (ULONG)SWAPL(pdire->length);

        ulTag = (ULONG)SWAPL(pdire->tag);

    // check if the ends of all tables are within the scope of the
    // tt file. If this is is not the case trying to access the field in the
    // table may result in an access violation, as is the case with the
    // spurious FONT.TTF that had the beginning of the cmap table below the
    // end of file, which was resulting in the system crash reported by beta
    // testers. [bodind]

        if ((ulOffset + ulLength) > cjView)
            RET_FALSE("TTFD: bGetTablePointers : table offset/length \n");

        if (bGetTagIndex(ulTag, &iTable, &bRequiredTable))
        {
            if (bRequiredTable)
            {
                ptp->ateReq[iTable].dp = ulOffset;
                ptp->ateReq[iTable].cj = ulLength;
            }
            else // optional table
            {
                ptp->ateOpt[iTable].dp = ulOffset;
                ptp->ateOpt[iTable].cj = ulLength;

            // here we are fixing a possible bug in in the tt file.
            // In lucida sans font they claim that pj != 0 with cj == 0 for
            // vdmx table. Attempting to use this vdmx table was
            // resulting in an access violation in bSearchVdmxTable

                if (ptp->ateOpt[iTable].cj == 0)
                    ptp->ateOpt[iTable].dp = 0;
            }
        }

    }

// now check that all required tables are present

    for (iTable = 0; iTable < C_REQ_TABLES; iTable++)
    {
        if ((ptp->ateReq[iTable].dp == 0) || (ptp->ateReq[iTable].cj == 0))
            RET_FALSE("TTFD!_required table absent\n");
    }

    return(TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bGetTagIndex
*
* Determines whether the table is required or optional, assiciates the index
* into TABLE_POINTERS  with the tag
*
* returns FALSE if ulTag is not one of the recognized tags
*
* History:
*  09-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bGetTagIndex (
    ULONG  ulTag,      // tag
    INT   *piTable,    // index into a table
    BOOL  *pbRequired  // requred or optional table
    )
{
    *pbRequired = FALSE;  // default set for optional tables, change the
                          // value if required table

    switch (ulTag)
    {
    // reqired tables:

    case tag_CharToIndexMap:
        *piTable = IT_REQ_CMAP;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_GlyphData:
        *piTable = IT_REQ_GLYPH;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_FontHeader:
        *piTable = IT_REQ_HEAD;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_HoriHeader:
        *piTable = IT_REQ_HHEAD;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_HorizontalMetrics:
        *piTable = IT_REQ_HMTX;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_IndexToLoc:
        *piTable = IT_REQ_LOCA;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_MaxProfile:
        *piTable = IT_REQ_MAXP;
        *pbRequired = TRUE;
        return (TRUE);
    case tag_NamingTable:
        *piTable = IT_REQ_NAME;
        *pbRequired = TRUE;
        return (TRUE);

// optional tables

    case tag_OS_2:
        *piTable = IT_OPT_OS2;
        return (TRUE);
    case tag_HoriDeviceMetrics:
        *piTable = IT_OPT_HDMX;
        return (TRUE);
    case tag_Vdmx:
        *piTable = IT_OPT_VDMX;
        return (TRUE);
    case tag_Kerning:
        *piTable = IT_OPT_KERN;
        return (TRUE);
    case tag_LinearThreshold:
        *piTable = IT_OPT_LTSH;
        return (TRUE);
    case tag_Postscript:
        *piTable = IT_OPT_POST;
        return (TRUE);
    case tag_GridfitAndScanProc:
        *piTable = IT_OPT_GASP;
        return (TRUE);
    case tag_mort:
        *piTable = IT_OPT_MORT;
        return (TRUE);
    case tag_GSUB:
        *piTable = IT_OPT_GSUB;
        return (TRUE);
    case tag_VerticalMetrics:
        *piTable = IT_OPT_VMTX;
        return(TRUE);
    case tag_VertHeader:
        *piTable = IT_OPT_VHEA;
        return(TRUE);
    case tag_BitmapLocation:
        *piTable = IT_OPT_EBLC;
        return (TRUE);
    default:
        return (FALSE);
    }
}

// Open type name table definitions
#define BE_NAME_ID_COPYRIGHT   0x0000
#define BE_NAME_ID_FAMILY      0x0100
#define BE_NAME_ID_SUBFAMILY   0x0200
#define BE_NAME_ID_UNIQNAME    0x0300
#define BE_NAME_ID_FULLNAME    0x0400
#define BE_NAME_ID_VERSION     0x0500
#define BE_NAME_ID_PSCRIPT     0x0600
#define BE_NAME_ID_TRADEMARK   0x0700

STATIC const CHAR  pszType1[] = "Converter: Windows Type 1 Installer";

// big endian unicode version of the above string

STATIC const CHAR  awszType1[] = {
0,'C',
0,'o',
0,'n',
0,'v',
0,'e',
0,'r',
0,'t',
0,'e',
0,'r',
0,':',
0,' ',
0,'W',
0,'i',
0,'n',
0,'d',
0,'o',
0,'w',
0,'s',
0,' ',
0,'T',
0,'y',
0,'p',
0,'e',
0,' ',
0,'1',
0,' ',
0,'I',
0,'n',
0,'s',
0,'t',
0,'a',
0,'l',
0,'l',
0,'e',
0,'r',
0, 0
};

// helper routine for bComputeIFISIZE()

BOOL    bShellFontFace(PBYTE pszShellFontFace, PBYTE pszFamilyName, ULONG ulShellFont)
{
    UINT    i;
    BOOL    bShellFont;

// Now it is Microsoft Sans Serif, we will change it later.

    bShellFont = TRUE;

    for(i = 0; i < ulShellFont; i++)
    {
        pszFamilyName++;
        if(*pszFamilyName != *pszShellFontFace++)
        {
            bShellFont = FALSE;
            break;
        }
        pszFamilyName++;
    }
    
    return bShellFont;
}

ULONG ConvertLangIDtoCodePage(uint16 uiLangID)
{
    uint16  uiCodePage;

    uiCodePage = 0;

    switch(uiLangID)
    {
        case 0x0404:   // Taiwan
        case 0x040c:   // Hongkong
        case 0x0414:   // mckou
            uiCodePage = 950; // CHINESEBIG5_CHARSET
            break;
        case 0x0408:    // PRC
        case 0x0410:    // Singapore
            uiCodePage = 936; // GB2312_CHARSET
            break;
        default:
            break;
    }

    return uiCodePage;
}


/**************************************************************************\
*
* STATIC BOOL  bComputeIFISIZE
*
* Effects:  scans the name table and fills the given IFISIZE structure.
*
* Warnings:
*
* History:
*  10-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
*  3/5/2 mikhaill: fixed bug 565287
*
\**************************************************************************/

STATIC BOOL  bComputeIFISIZE
(
BYTE             *pjView,
TABLE_POINTERS   *ptp,
uint16            ui16PlatID,
uint16            ui16SpecID,
uint16            ui16LangID,
PIFISIZE          pifisz,
BOOL             *pbType1,
ULONG            *pulShellFont
)
{

    sfnt_OS2 * pOS2;

    // get the pointer to the name table
    sfnt_NamingTable *pname = (sfnt_NamingTable *)(pjView + ptp->ateReq[IT_REQ_NAME].dp);

    // get the pointer above the end of the table
    BYTE* pTableLimit = (PBYTE)pname + ptp->ateReq[IT_REQ_NAME].cj;

    BYTE* pjStorage;
    UINT_PTR sizeStorage;

    PBYTE pjVersion = NULL;
    ULONG cjVersion;

    sfnt_NameRecord * pnrecInit, *pnrec, *pnrecEnd;
    sfnt_NameRecord * pnrecFamily = (sfnt_NameRecord *)NULL;

    BOOL    bMatchLangId, bFoundAllNames, bFoundEverything;
    INT     iNameLoop;

    USHORT  AnsiCodePage, OemCodePage;
    UINT offsetAcc;

    uint32 sizeOfName = ptp->ateReq[IT_REQ_NAME].cj;

    if (sizeOfName < SIZE_NAMING_TABLE)
        RET_FALSE("ttfd!_bComputeIFISIZE :  name table size is too small 1\n");

// get out if this is not one of the platID's we know what to do with

    if ((ui16PlatID != BE_PLAT_ID_MS) && (ui16PlatID != BE_PLAT_ID_MAC))
        RET_FALSE("ttfd!_ do not know how to handle this plat id\n");

// first clean the output structure:

    RtlZeroMemory((PVOID)pifisz, sizeof(IFISIZE));

// remember call arguments for use in bConvertExtras
    pifisz->ui16PlatID = ui16PlatID;
    pifisz->ui16SpecID = ui16SpecID;

// first name record is layed just below the naming table

    pnrecInit = (sfnt_NameRecord *)((PBYTE)pname + SIZE_NAMING_TABLE);

    // check the various possible corruptions in name table header:
    // first ensure that at leasr header fit into the table

    if ((BYTE*)pname     > (BYTE*)pnrecInit || 
        (BYTE*)pnrecInit > (BYTE*)pTableLimit)
         RETURN("ttfd!corrupted name table header in a file\n", FALSE);

    // now we can use the header

    // get the ptr above record array
    pnrecEnd = &pnrecInit[BE_UINT16(&pname->count)];

    // get the pointer to the beginning of the storage area for strings
    pjStorage = (PBYTE)pname + BE_UINT16(&pname->stringOffset);

     if ((BYTE*)pnrecInit > (BYTE*)pnrecEnd  || 
         (BYTE*)pnrecEnd  > (BYTE*)pjStorage || 
         (BYTE*)pjStorage > (BYTE*)pTableLimit)
          RETURN("ttfd!corrupted(2) name table header in a file\n", FALSE);

    sizeStorage = (UINT_PTR)(pTableLimit - pjStorage);

// in the first iteration of the loop we want to match lang id to our
// favorite lang id. If we find all 4 strings in that language we are
// done. If we do not find all 4 string with matching lang id we will try to
// language only, but not sublanguage. For instance if Canadian French
// is requested, but the file only contains "French" French names, we will
// return the names in French French. If that does not work either
// we shall go over name records again and try to find
// the strings in English. If that does not work either we
// shall resort to total desperation and just pick any language.
// therefore we may go up to 4 times through the NAME_LOOP

    bFoundAllNames = FALSE;
    bFoundEverything = FALSE;

    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

    if( sizeOfName < SIZE_NAMING_TABLE + BE_UINT16(&pname->count) * sizeof(sfnt_NameRecord)  )
    RET_FALSE("ttfd!_bComputeIFISIZE :  name table size is too small 2\n");

// find the name record with the desired ID's
// NAME_LOOP:

    for (iNameLoop = 0; iNameLoop < 4 && !bFoundEverything; iNameLoop++)
    {
        for (pnrec = pnrecInit; pnrec < pnrecEnd && !bFoundEverything; pnrec++)
        {
            UINT nameOffset = BE_UINT16(&pnrec->offset);
            UINT nameLength = BE_UINT16(&pnrec->length);

            // ignore incorrect records
            if (nameLength == 0 || nameOffset + nameLength > sizeStorage) continue;

            switch (iNameLoop)
            {
            case 0:
            // match BOTH language and sublanguage

                bMatchLangId = (pnrec->languageID == ui16LangID);
                break;

            case 1:
            // match language but not sublanguage
            // except if we are dealing with LANG_CHINESE then we need to see 
            // the font code page is same as system defaul or not

                if ((ui16LangID & 0xff00) == 0x0400) // LANG_CHINESE == 0x0400
                {
                    if ((ConvertLangIDtoCodePage(pnrec->languageID) != AnsiCodePage))
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                    }
                    else
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                    }
                }
                else
                {
                    bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                }
                break;

            case 2:
            // try to find english names if desired language is not available

                if ((ui16LangID & 0xff00) == 0x0400) // LANG_CHINESE == 0x0400
                {
                    if ((ConvertLangIDtoCodePage(pnrec->languageID) != AnsiCodePage))
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == (ui16LangID & 0xff00));
                    }
                    else
                    {
                        bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                    }
                }
                else
                {
                    bMatchLangId = ((pnrec->languageID & 0xff00) == 0x0900);
                }
                break;

            case 3:
            // do not care to match language at all, just give us something

                bMatchLangId = TRUE;
                break;

            default:
                RIP("ttfd! must not have more than 3 loop iterations\n");
                break;
            }

            if
            (
                (pnrec->platformID == ui16PlatID) &&
                (pnrec->specificID == ui16SpecID) &&
                bMatchLangId
            )
            {
                switch (pnrec->nameID)
                {
                case BE_NAME_ID_FAMILY:

                    if (!pifisz->pjFamilyName) // if we did not find it before
                    {
                        pifisz->pjFamilyName = pjStorage + nameOffset;
                        pifisz->cjFamilyName =             nameLength;

                        pnrecFamily = pnrec; // keep it to distinguish from alias
                    }   
                    break;

                case BE_NAME_ID_SUBFAMILY:

                    if (!pifisz->pjSubfamilyName) // if we did not find it before
                    {
                        pifisz->pjSubfamilyName = pjStorage + nameOffset;
                        pifisz->cjSubfamilyName =             nameLength;
                    }
                    break;

                case BE_NAME_ID_UNIQNAME:

                    if (!pifisz->pjUniqueName) // if we did not find it before
                    {
                        pifisz->pjUniqueName    = pjStorage + nameOffset;
                        pifisz->cjUniqueName    =             nameLength;
                    }
                    break;

                case BE_NAME_ID_FULLNAME:

                    if (!pifisz->pjFullName)    // if we did not find it before
                    {
                        pifisz->pjFullName      = pjStorage + nameOffset;
                        pifisz->cjFullName      =             nameLength;
                    }
                    break;

                case BE_NAME_ID_VERSION:

                    if (!pjVersion)    // if we did not find it before
                    {
                        pjVersion = pjStorage + nameOffset;
                        cjVersion =             nameLength;
                    }
                    break;
                }

            }

            bFoundAllNames = pifisz->pjFamilyName
                          && pifisz->pjSubfamilyName
                          && pifisz->pjUniqueName
                          && pifisz->pjFullName;

            bFoundEverything = bFoundAllNames && pjVersion;
        }

    } // end of iNameLoop

    if (!bFoundAllNames)
    {
    // we have gone through the all 3 iterations of the NAME loop
    // and still have not found all the names. We have singled out
    // VersionName because it is not required for the font to be
    // loaded, we only need it to check if this a ttf converted from t1

        RETURN("ttfd!can not find all name strings in a file\n", FALSE);
    }

// let us check if there  is a family alias, usually only exists in
// FE tt fonts, where there might be a western and fe family name.
// Do not do this for MAC case.

    if (ui16PlatID == BE_PLAT_ID_MS)
    {
        for (pnrec = pnrecInit; pnrec < pnrecEnd; pnrec++)
        {
            UINT nameOffset = BE_UINT16(&pnrec->offset);
            UINT nameLength = BE_UINT16(&pnrec->length);
            
            // ignore incorrect records
            if (nameLength == 0 || nameOffset + nameLength > sizeStorage) continue;
            
            if ((pnrec->platformID == ui16PlatID)    &&
                (pnrec->specificID == ui16SpecID)    &&
                (pnrec->nameID == BE_NAME_ID_FAMILY) &&
                (pnrecFamily != pnrec)
                )
            {
                pifisz->pjFamilyNameAlias = pjStorage + nameOffset;
                pifisz->cjFamilyNameAlias =             nameLength;
                break;
            }
        }

    }

    // calculate unicode string lengths
    if (!bConvertExtras(0, pifisz, 0))
         RETURN("ttfd!corrupted name table fail at bConvertExtras\n", FALSE);

    // now all the cb* lengths are known.
    // Calculate positions of names, relative to beginning
    // of IFIMETRICS structure
    // lay the strings below the ifimetrics
    // but insert IFIEXTRA below ifimetrics itself and before strings

    offsetAcc = sizeof(IFIMETRICS) + offsetof(IFIEXTRA, dpDesignVector);

    pifisz->dpFamilyName = offsetAcc;
    offsetAcc += pifisz->cbFamilyName;

    if(pifisz->pjFamilyNameAlias)
    {
        pifisz->dpFamilyNameAlias = offsetAcc;
        offsetAcc += pifisz->cbFamilyNameAlias;

        // Reserve space for two '@' for vertical face name, one for facename and one for family name
        offsetAcc += 2*sizeof(WCHAR);
    }

    // reserve space for second terminating zero
    offsetAcc += sizeof(WCHAR);

    pifisz->dpUniqueName = offsetAcc;
    offsetAcc += pifisz->cbUniqueName;

    pifisz->dpFullName = offsetAcc;
    offsetAcc += pifisz->cbFullName;

    // we may need to add an '@' to facename (== fullname)
    offsetAcc += sizeof(WCHAR);

    pifisz->dpSubfamilyName = offsetAcc;
    offsetAcc += pifisz->cbSubfamilyName;

    offsetAcc = DWORD_ALIGN(offsetAcc);

// check out if this is a converted Type 1 font:

    *pbType1 = FALSE; // default

    if (pjVersion)
    {
        ULONG ulLen = cjVersion;
        if (ui16PlatID == BE_PLAT_ID_MS)
        {
            if (ulLen > sizeof(awszType1))
                ulLen = sizeof(awszType1);
            ulLen -= sizeof(WCHAR); // minus terminating zero

            *pbType1 = !memcmp(pjVersion, awszType1, ulLen);
        }
        else // mac id
        {
            if (ulLen > sizeof(pszType1))
                ulLen = sizeof(pszType1);
            ulLen -= 1; // minus terminating zero

            *pbType1 = !strncmp(pjVersion, pszType1, ulLen);
        }
    }

    {
        ULONG cSims = 0;

        switch (fsSelectionTTFD(pjView,ptp) & (FM_SEL_BOLD | FM_SEL_ITALIC))
        {
        case 0:
            cSims = 3;
            break;

        case FM_SEL_BOLD:
        case FM_SEL_ITALIC:
            cSims = 1;
            break;
        }

        if (cSims)
        {
            pifisz->dpSims = offsetAcc;
            offsetAcc += (DWORD_ALIGN(sizeof(FONTSIM)) + cSims * DWORD_ALIGN(sizeof(FONTDIFF)));
        }
        else
        {
            pifisz->dpSims = 0;
        }
    }

// add charset info:

    pifisz->dpCharSets = offsetAcc;
    offsetAcc += DWORD_ALIGN(NOEMCHARSETS);

// finally check if FONTSIGNATURE info is needed

    pOS2 = (sfnt_OS2 *)((ptp->ateOpt[IT_OPT_OS2].dp)         ?
                         pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                         NULL)                               ;

    if (pOS2)
    {
    // used to 1.0 or higher is TT open
    // but version 0 already contain some of those flags, changed to fix problem with Tamil fonts

        pifisz->dpFontSig = offsetAcc;
        offsetAcc += sizeof(FONTSIGNATURE); // 6 dwords, no need to add dword align
    }

// Here is the code to know it is a shell font or not

// Most of case, we do not need to check it.

    *pulShellFont = 0;

    if (pifisz->cjUniqueName  == (MICROSS_SHELLFONT_SIZE * 2))
    {
        if (bShellFontFace(PSZ_MICROSS_SHELLFONT, pifisz->pjUniqueName, MICROSS_SHELLFONT_SIZE))
        {
            *pulShellFont = MICROSS_SHELLFONT;
        }
    }
    else if (pifisz->cjUniqueName  == (TAHOMA_SHELLFONT_SIZE * 2))
    {
        if (bShellFontFace(PSZ_TAHOMA_SHELLFONT, pifisz->pjUniqueName, TAHOMA_SHELLFONT_SIZE))
        {
            *pulShellFont = TAHOMA_SHELLFONT;
        }
    }
    else if (pifisz->cjUniqueName  == (TAHOMA_BOLD_SHELLFONT_SIZE * 2))
    {
        if (bShellFontFace(PSZ_TAHOMA_BOLD_SHELLFONT, pifisz->pjUniqueName, TAHOMA_BOLD_SHELLFONT_SIZE))
        {
            *pulShellFont = TAHOMA_BOLD_SHELLFONT;
        }
    }

    pifisz->cjIFI = NATURAL_ALIGN(offsetAcc);
    return TRUE;
}

// Helpers for bConvertExtras()
static BOOL bConvertMBCS(WCHAR* pDst, UINT* pSizDst, const BYTE* pSrc, UINT sizSrc, UINT iCodePage)
{
    // The source string is given in a specific format.
    // Basically it is DBCS (double byte character system)
    // but each single-byte char is represented by
    // WORD that's the original byte extended with zero.
    // So before calling MultiByteToWideChar we need
    // to squeeze off these extra zeros

    CHAR sqzBuf[256];
    WCHAR convertBuf[256];
    UINT sqzSiz = 0, i;
    int cb;
    
    if (sizSrc & 1) return FALSE;

    for (i = 0; i < sizSrc; i += 2)
    {
        if (pSrc[i])
        {
            if (sqzSiz+2 >= sizeof(sqzBuf)) return FALSE;
            sqzBuf[sqzSiz  ] = pSrc[i  ];
            sqzBuf[sqzSiz+1] = pSrc[i+1];
            sqzSiz += 2;
        }
        else
        {
            if (sqzSiz+1 >= sizeof(sqzBuf)) return FALSE;
            sqzBuf[sqzSiz++] = pSrc[i+1];
        }
    }

    // set terminating zero
    sqzBuf[sqzSiz++] = 0;
    

    if (*pSizDst == 0)
    {   // we are called in bConvertExtras() first pass
        cb = EngMultiByteToWideChar(iCodePage, convertBuf, sizeof(convertBuf), sqzBuf, sqzSiz);
        if (cb == -1) 
        {
            WARNING("TTFD!bConvertMBCS: EngMultiByteToWideChar fail\n");
            return FALSE;
        }
        *pSizDst = cb;
    }
    else
    {   // second pass
        cb = EngMultiByteToWideChar(iCodePage, pDst, *pSizDst, sqzBuf, sqzSiz);
        if (cb == -1) 
        {
            WARNING("TTFD!bConvertMBCS: EngMultiByteToWideChar fail, second pass\n");
            return FALSE;
        }

        if (cb != *pSizDst) 
        {
            WARNING("TTFD!bConvertMBCS: wrong size in second pass\n");
            return FALSE;
        }
        if ((WCHAR*)((PBYTE)pDst + cb)[-1] != 0)
        {
            WARNING("TTFD!bConvertMBCS: string not terminated in second pass\n");
            return FALSE;
        }
    }
    return TRUE;
}

static BOOL bConvertSwap(WCHAR* pDst, UINT* pSizDst, const BYTE* pSrc, UINT sizSrc)
{
    if (*pSizDst == 0)
    {   // was called in bConvertExtras() first pass
//        if (sizSrc%sizeof(WCHAR) != 0) return FALSE; fontographer 4.0 create font with odd size
        *pSizDst = (sizSrc /sizeof(WCHAR)) * sizeof(WCHAR) + sizeof(WCHAR);
    }
    else
    {   // was called in bConvertExtras() second pass
        vCpyBeToLeUnicodeString(pDst, (LPWSTR)pSrc, *pSizDst/sizeof(WCHAR));
    }
    return TRUE;
}
                
static BOOL bConvertMac(WCHAR* pDst, UINT* pSizDst, const BYTE* pSrc, UINT sizSrc, uint16 ui16LanguageID)
{
    if (*pSizDst == 0)
    {   // was called in bConvertExtras() first pass
        *pSizDst = (sizSrc + 1)*sizeof(WCHAR);
    }
    else
    {   // was called in bConvertExtras() second pass
        vCpyMacToLeUnicodeString(ui16LanguageID, pDst, pSrc, *pSizDst/sizeof(WCHAR));
    }
    return TRUE;
}
                
// Routine: bConvertExtras
// Executes the convertion of names in strict IFISIZE
// from internal font representation to Unicode.
// Works in two modes, depending on given "pifi" argument.
// When it is null, (preliminary pass) then no convertions
// are executed but the sizes of buffers are calculated and
// stored in IFISIZE.cc* fields.
// The IFISIZE.cjIFI value is calculated during this pass.
// The IFISIZE.cjIFI value means the total amount of memory,
// in bytes, required for PIFIMETRICS with extra structures
// that follow it.
// 
// The second pass is called when PIFIMETRICS is already
// allocated, so given pifi is nonzero.
// This pass uses the data accumulated in IFISIZE
// during first pass and actually converts the names,
// filling corresponding pointers in PIFIMETRICS.

static BOOL bConvertExtras(PIFIMETRICS  pifi,
                           PIFISIZE pifisz,
                           uint16 ui16LanguageID)
{
    if (pifisz->ui16PlatID == BE_PLAT_ID_MS)
    {

        if (pifisz->ui16SpecID == BE_SPEC_ID_BIG5     ||
            pifisz->ui16SpecID == BE_SPEC_ID_WANSUNG  ||
            pifisz->ui16SpecID == BE_SPEC_ID_GB)
        {
            // Convert MBCS string to Unicode..

            UINT iCodePage = GetCodePageFromSpecId(pifisz->ui16SpecID);

            // Do for FamilyName....
            if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyName),
                                                    &pifisz->cbFamilyName,
                                                     pifisz->pjFamilyName,
                                                     pifisz->cjFamilyName, iCodePage))
                return FALSE;


            // Do for FamilyNameAlias....
            if (pifisz->pjFamilyNameAlias)
            {   // this case requires double null terminating.

                if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyNameAlias),
                                                        &pifisz->cbFamilyNameAlias,
                                                         pifisz->pjFamilyNameAlias,
                                                         pifisz->cjFamilyNameAlias, iCodePage))
                    return FALSE;

                // on the second pass, put the second terminator
                if (pifi)
                {
                    *(WCHAR*)((PBYTE)pifi
                               + pifisz->dpFamilyNameAlias
                               + pifisz->cbFamilyNameAlias) = 0;
                }
            }

            // Do for FullName....
            if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpFullName),
                                                    &pifisz->cbFullName,
                                                     pifisz->pjFullName,
                                                     pifisz->cjFullName, iCodePage))
                return FALSE;

            // Do for UniqueName....
            if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpUniqueName),
                                                    &pifisz->cbUniqueName,
                                                     pifisz->pjUniqueName,
                                                     pifisz->cjUniqueName, iCodePage))
                return FALSE;


            // Do for SubfamilyName....
            if(pifisz->ui16SpecID == BE_SPEC_ID_WANSUNG  ||
               pifisz->ui16SpecID == BE_SPEC_ID_BIG5 )
            {
                // MingLi.TTF's bug, Style use Unicode encoding, not BIG5 encodingi, GB??
                if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpSubfamilyName),
                                                        &pifisz->cbSubfamilyName,
                                                         pifisz->pjSubfamilyName,
                                                         pifisz->cjSubfamilyName))
                    return FALSE;
            }
            else
            {
                if (!bConvertMBCS((WCHAR*)((PBYTE)pifi + pifisz->dpSubfamilyName),
                                                        &pifisz->cbSubfamilyName,
                                                         pifisz->pjSubfamilyName,
                                                         pifisz->cjSubfamilyName, iCodePage))
                    return FALSE;
            }
        }
        else
        {
            // Do for FamilyName....
            if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyName),
                                                    &pifisz->cbFamilyName,
                                                     pifisz->pjFamilyName,
                                                     pifisz->cjFamilyName))
                return FALSE;

            // Do for FamilyNameAlias....
            if (pifisz->pjFamilyNameAlias)
            {   // this case requires double null terminating.

                if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyNameAlias),
                                                        &pifisz->cbFamilyNameAlias,
                                                         pifisz->pjFamilyNameAlias,
                                                         pifisz->cjFamilyNameAlias))
                    return FALSE;

                // on the second pass, put the second terminator
                if (pifi)
                {
                    *(WCHAR*)((PBYTE)pifi
                               + pifisz->dpFamilyNameAlias
                               + pifisz->cbFamilyNameAlias) = 0;
                }
            }

            // Do for FullName....
            if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpFullName),
                                                    &pifisz->cbFullName,
                                                     pifisz->pjFullName,
                                                     pifisz->cjFullName))
                return FALSE;

            // Do for UniqueName....
            if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpUniqueName),
                                                    &pifisz->cbUniqueName,
                                                     pifisz->pjUniqueName,
                                                     pifisz->cjUniqueName))
                return FALSE;


            // Do for SubfamilyName....
            if (!bConvertSwap((WCHAR*)((PBYTE)pifi + pifisz->dpSubfamilyName),
                                                    &pifisz->cbSubfamilyName,
                                                     pifisz->pjSubfamilyName,
                                                     pifisz->cjSubfamilyName))
                return FALSE;

        }
    }
    else
    {
        ASSERTDD(pifisz->ui16PlatID == BE_PLAT_ID_MAC, "bConvertExtras: not mac id \n");

        // Do for FamilyName....
        if (!bConvertMac((WCHAR*)((PBYTE)pifi + pifisz->dpFamilyName),
                                               &pifisz->cbFamilyName,
                                                pifisz->pjFamilyName,
                                                pifisz->cjFamilyName, ui16LanguageID))
            return FALSE;

        // Do for FullName....
        if (!bConvertMac((WCHAR*)((PBYTE)pifi + pifisz->dpFullName),
                                               &pifisz->cbFullName,
                                                pifisz->pjFullName,
                                                pifisz->cjFullName, ui16LanguageID))
            return FALSE;

        // Do for UniqueName....
        if (!bConvertMac((WCHAR*)((PBYTE)pifi + pifisz->dpUniqueName),
                                               &pifisz->cbUniqueName,
                                                pifisz->pjUniqueName,
                                                pifisz->cjUniqueName, ui16LanguageID))
            return FALSE;


        // Do for SubfamilyName....
        if (!bConvertMac((WCHAR*)((PBYTE)pifi + pifisz->dpSubfamilyName),
                                               &pifisz->cbSubfamilyName,
                                                pifisz->pjSubfamilyName,
                                                pifisz->cjSubfamilyName, ui16LanguageID))
            return FALSE;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* STATIC BOOL  bCheckLocaTable
*
* Effects:
*
* Warnings:
*
* History:
*  20-June-2000 -by- Sung-Tae Yoo [styoo]
* Wrote it.
\**************************************************************************/

STATIC BOOL  bCheckLocaTable
(
int16   indexToLocFormat,
BYTE    *pjView,
TABLE_POINTERS   *ptp,
uint16  numGlyphs
)
{
    uint16  i;
    uint32  lSizeOfLoca = ptp->ateReq[IT_REQ_LOCA].cj;

    if(indexToLocFormat){   //For Long Offsets
        uint32* pLongOffSet;

        // it should be: 
        // if((numGlyphs+1) * sizeof(uint32) > lSizeOfLoca)
        // but there are a few Japanese fonts like fadpop7.ttf that don't
        // have the additional entry for the size of the last glyph
        // we need to check and fail the last glyph of those fonts at
        // vGetNotionalGlyphMetrics and in the TrueType rasterizer
        // instead of failing the whole font here
        if((numGlyphs) * sizeof(uint32) > lSizeOfLoca)
            return(FALSE);

        pLongOffSet = (uint32 *)(pjView + ptp->ateReq[IT_REQ_LOCA].dp);

        for(i=0; i<numGlyphs-1; i++)
            if( (uint32)SWAPL(pLongOffSet[i]) > (uint32)SWAPL(pLongOffSet[i+1]) )
                return (FALSE);
    }
    else{   //For Short Offsets
        uint16* pShortOffSet;

        // same comment as above apply here
        if((numGlyphs) * sizeof(uint16) > lSizeOfLoca)
            return(FALSE);

        pShortOffSet = (uint16 *)(pjView + ptp->ateReq[IT_REQ_LOCA].dp);

        for(i=0; i<numGlyphs-1; i++)
            if( (uint16)SWAPW(pShortOffSet[i]) > (uint16)SWAPW(pShortOffSet[i+1]) )
                return (FALSE);
    }

    return (TRUE);
}

/******************************Public*Routine******************************\
*
* STATIC BOOL  bCheckHdmxTable
*
* Effects:
*
* Warnings:
*
* History:
*  20-Sep-2000 -by- Sung-Tae Yoo [styoo]
* Wrote it.
\**************************************************************************/

STATIC BOOL  bCheckHdmxTable
(
    sfnt_hdmx      *phdmx,
    ULONG           tableSize
)
{
    USHORT numRecords;
    ULONG sizeOfRecord;

    if (offsetof(sfnt_hdmx, HdmxTable) > tableSize) 
        return FALSE;

    numRecords = SWAPW(phdmx->sNumRecords);
    sizeOfRecord = SWAPL(phdmx->lSizeRecord);

    if (offsetof(sfnt_hdmx, HdmxTable)+ numRecords * sizeOfRecord > tableSize) 
        return FALSE;
    else 
        return TRUE;
}

/******************************Public*Routine******************************\
*
* STATIC void vDetectOldBiDiFonts
*
* Effects:
*
* Warnings:
*
* History:
*  10-May-1999 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/

STATIC void
vDetectOldBiDiFonts(
    sfnt_OS2 *pOS2,
    ULONG     ul_startCount,
    ULONG    *pulGsetType,
    ULONG    *pul_wcBias
    )
{

    if (EngLpkInstalled())
    {
    // Treat old BiDi fonts correctly, if langpack is installed
    
        if (pOS2 &&
            ((ul_startCount & 0xff00) >= 0xf000) &&
            ((ul_startCount & 0xff00) <= 0xf2ff) )
        {
            switch (pOS2->usSelection & 0x00ff)     // win 31 foreign charsets
            {
                case 0xb1:
                case 0xb2:
                case 0xb3:
                case 0xb4:
                case 0xb5:

                    *pulGsetType = GSET_TYPE_OLDBIDI ;
                    *pul_wcBias  = ul_startCount & 0xff00;
                break ;
            }
        }
    }
}


/******************************Public*Routine******************************\
*
* STATIC BOOL bComputeIDs
*
* Effects:
*
* Warnings:
*
* History:
*  13-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bComputeIDs (
    BYTE              * pjView,
    TABLE_POINTERS     *ptp,
    uint16             *pui16PlatID,
    uint16             *pui16SpecID,
    sfnt_mappingTable **ppmap,
    ULONG              *pulGsetType,
    ULONG              *pul_wcBias,
    CMAPINFO           *pcmi
    )
{
    ULONG ul_startCount=0L;
    uint16 numTables, version;
    sfnt_platformEntry * pplat;
    sfnt_platformEntry * pplatEnd;
    sfnt_platformEntry * pplatMac;

    sfnt_char2IndexDirectory * pcmap =
            (sfnt_char2IndexDirectory *)(pjView + ptp->ateReq[IT_REQ_CMAP].dp);

    uint32 sizeOfCmap = ptp->ateReq[IT_REQ_CMAP].cj;

    if (sizeOfCmap < OFF_cmap_SubTableDir)
        RET_FALSE("TTFD!_bComputeIDs: cmap size too small for table header\n");

    numTables = BE_UINT16(&pcmap->numTables);
    version = BE_UINT16(&pcmap->version); // we always need to swap the bytes, in IA64 tables might be unaligned

    if (sizeOfCmap < (uint16)(OFF_cmap_SubTableDir + (numTables * CMAP_sizeof_SubTableDir)))
        RET_FALSE("TTFD!_bComputeIDs: cmap size too small for sub-table header\n");

    pplat = &pcmap->platform[0];
    pplatEnd = pplat + numTables;
    pplatMac = (sfnt_platformEntry *)NULL;

    *ppmap = (sfnt_mappingTable  *)NULL;
    *pul_wcBias  = 0;

    if (version != 0) // no need to swap bytes, 0 == be 0
        RET_FALSE("TTFD!_bComputeIDs: version number\n");
    if (numTables > 30)
    {
        RET_FALSE("Number of cmap tables greater than 30 -- probably a bad font\n");
    }

// find the first sfnt_platformEntry with platformID == PLAT_ID_MS,
// if there was no MS mapping table, go for the mac one
    for (; pplat < pplatEnd; pplat++)
    {
        uint16 platformID = BE_UINT16(&pplat->platformID);
        uint16 specificID = BE_UINT16(&pplat->specificID);
        uint16 format;

        if (platformID == PLAT_ID_MS)
        {
            BOOL bRet;
            uint32 offset = (uint32) SWAPL(pplat->offset);

            *pui16PlatID = BE_PLAT_ID_MS;
            *pui16SpecID = pplat->specificID;

            if( offset + SIZEOF_CMAPTABLE > sizeOfCmap ) 
            { // include the minimal size of a subtable
                WARNING("TTFD!_bComputeIDs: Start position of cmap subtable is out of cmap size -- mustbe bad font\n");
                continue;
            }

            *ppmap = (sfnt_mappingTable  *) ((PBYTE)pcmap + offset);

            // we cannot check the length of the subtable (*ppmap)->length, it's redundant and often wrong

            format = BE_UINT16(&((*ppmap)->format));
            switch(format)
            {
              case FORMAT_MSFT_UNICODE :
                switch(specificID)
                {
                  case SPEC_ID_SHIFTJIS :
                  case SPEC_ID_GB :
                  case SPEC_ID_BIG5 :
                  case SPEC_ID_WANSUNG :

                    bRet = bVerifyMsftTableGeneral(*ppmap,pulGsetType,pcmi, pplat->specificID,
                                                        sizeOfCmap, offset, pcmap);
                    break;

                  case SPEC_ID_UGL :
                  default :

                // this will set *pulGsetType to GSET_TYPE_GENERAL

                    bRet = bVerifyMsftTable(*ppmap,pulGsetType,pul_wcBias,pcmi,
                                             pplat->specificID,&ul_startCount,
                                             sizeOfCmap, offset, pcmap);
                    break;
                }
                break;

              case FORMAT_HIGH_BYTE :

                bRet = bVerifyMsftHighByteTable(*ppmap,
                                                pulGsetType,pcmi,pplat->specificID,
                                             sizeOfCmap, offset);
                break;

                default :

                bRet = FALSE;
                break;
            }

            if(!bRet)
            {
        WARNING("TTFD!_bComputeIDs: bVerifyMsftTable failed \n");
               *ppmap = (sfnt_mappingTable  *)NULL;
              continue;
            }

            // keep specific ID in CMAPINFO

            pcmi->ui16SpecID = pplat->specificID;

            if (pplat->specificID == BE_SPEC_ID_UNDEFINED)
            {
            // correct the value of the glyph set, we cheat here

                sfnt_OS2 * pOS2 = (sfnt_OS2 *)(
                               (ptp->ateOpt[IT_OPT_OS2].dp)    ?
                               pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                               NULL
                               );

                BOOL bSymbol = FALSE;
                if (pOS2)
                {
                    if (((pOS2->usSelection & 0x00ff) == ANSI_CHARSET) &&
                        (pOS2->Panose[0]==PAN_FAMILY_PICTORIAL)) // means symbol
                        bSymbol = TRUE;
                }

            // this code is put here because of the need to differentiate
            // between msicons2.ttf and bahamn1.ttf.
            // Both of them have Bias = 0, but msicons2 is a symbol font.

                if (*pul_wcBias || bSymbol)
                    *pulGsetType = GSET_TYPE_SYMBOL;

                vDetectOldBiDiFonts( pOS2,
                                     ul_startCount,
                                     pulGsetType,
                                     pul_wcBias );
            }
            else if (pplat->specificID == BE_SPEC_ID_UGL)
            {

                if (*pul_wcBias)  // we are really using f0?? range to put in a symbol font
                {
                    sfnt_OS2 * pOS2 = (sfnt_OS2 *)(
                                   (ptp->ateOpt[IT_OPT_OS2].dp)    ?
                                   pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                                   NULL
                               );

                    *pulGsetType = GSET_TYPE_SYMBOL;

                //
                // some bidi fonts claims they're Unicode (plat=3, specid = 1), however
                // they've a fixed fp like ghaim.ttf
                //
                    vDetectOldBiDiFonts( pOS2,
                                         ul_startCount,
                                         pulGsetType,
                                         pul_wcBias );
                }
            }

         // 
         // Here we found the first sound MS encoding cmap sub table and return
         //
            return (TRUE);
        }

        if ((pplat->platformID == BE_PLAT_ID_MAC)  &&
            (pplat->specificID == BE_SPEC_ID_UNDEFINED))
        {
            pplatMac = pplat;
        }
    }

    if (pplatMac != (sfnt_platformEntry *)NULL)
    {
    //
    // We couldn't find any sound MS encoding cmap sub table but found Mac encoding cmap sub table  
    //
    
        uint32 offset = (uint32) SWAPL(pplatMac->offset);
        *pui16PlatID = BE_PLAT_ID_MAC;
        *pui16SpecID = BE_SPEC_ID_UNDEFINED;

        if( offset > sizeOfCmap )
            RET_FALSE("Offset of cmap subtable is out of cmap size -- mustbe bad font\n");

        *ppmap = (sfnt_mappingTable  *) ((PBYTE)pcmap + offset);

        if( offset + (uint16) SWAPW((*ppmap)->length) > sizeOfCmap )
            WARNING("TTFD!_bComputeIDs: End position of cmap subtable is out of cmap size -- maybe bad font or bogus length value\n");

        if (!bVerifyMacTable(*ppmap,sizeOfCmap, offset))
        {
            *ppmap = (sfnt_mappingTable  *)NULL;
            RET_FALSE("TTFD!_bComputeIDs: bVerifyMacTable failed \n");
        }

    //!!! lang issues, what if not roman but thai mac char set ??? [bodind]

    // see if it is necessary to convert unicode to mac code points, or we
    // shall cheat in case of symbol char set for win31 compatiblity

        if (bCvtUnToMac(pjView, ptp, *pui16PlatID))
        {
            *pulGsetType = GSET_TYPE_MAC_ROMAN;
        }
        else
        {
            *pulGsetType = GSET_TYPE_PSEUDO_WIN;
        }
        return(TRUE);
    }
    else
    {
      //
      // We couldn't find any sound MS encoding nor Mac encoding cmap sub table 
      //
      
       RET_FALSE("TTFD!_bComputeIDs: unknown platID or all corrupted cmap sub table\n");
    }

}


/******************************Public*Routine******************************\
*
* STATIC VOID vComputeGLYPHSET_MSFT_UNICODE
*
* computes the glyphset structure for the cmap table that has
* format 4 = MSFT_UNICODE
*
* History:
*  22-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC ULONG
cjComputeGLYPHSET_MSFT_UNICODE (
    sfnt_mappingTable     *pmap,
    fs_GlyphInputType     *pgin,
    FD_GLYPHSET           *pgset,
    CMAPINFO              *pcmi
    )
{
    uint16 * pstartCount;
    uint16 * pendCount;
    uint16   cRuns, cRuns5cSplit;
    PWCRUN   pwcrun, pwcrunEnd, pwcrunInit, pwcrun_b7, pwcrun5cFirst;
    HGLYPH  *phg;
    ULONG    cjRet;
    FS_ENTRY iRet;
    BOOL     bInsert_b7;

    #if DBG
    ULONG    cGlyphsSupported = 0;
    #endif

    cRuns5cSplit = 0;

    if(pcmi->fl & CMI_5C_SPLIT)
    {
        cRuns5cSplit = 1;
    }

    cjRet = SZ_GLYPHSET((pcmi->cRuns + cRuns5cSplit), pcmi->cGlyphs);


    if (!pgset)
    {
        return cjRet;
    }

// check if need to insert an extra run for b7 only

    bInsert_b7 = ((pcmi->fl & (CMI_2219_PRESENT | CMI_B7_ABSENT)) == (CMI_2219_PRESENT | CMI_B7_ABSENT));

    cRuns = BE_UINT16((PBYTE)pmap + OFF_segCountX2) >> 1;

// get the pointer to the beginning of the array of endCount code points

    pendCount = (uint16 *)((PBYTE)pmap + OFF_endCount);

// the final endCode has to be 0xffff;
// if this is not the case, there is a bug in the tt file or in our code:

    ASSERTDD( ((uint16 UNALIGNED *)pendCount)[cRuns - 1] == 0xFFFF,
              "pendCount[cRuns - 1] != 0xFFFF\n");

// Get the pointer to the beginning of the array of startCount code points
// For resons known only to tt designers, startCount array does not
// begin immediately after the end of endCount array, i.e. at
// &pendCount[cRuns]. Instead, they insert an uint16 padding which has to
// set to zero and the startCount array begins after the padding. This
// padding in no way helps alignment of the structure

//    ASSERTDD(pendCount[cRuns] == 0, "TTFD!_padding != 0\n");

    pstartCount = &pendCount[cRuns + 1];

// here we shall check if the last run is just a terminator for the
// array of runs or a real nontrivial run. If just a terminator, there is no
// need to report it. This will save some memory in the cache plus
// pifi->wcLast will represent the last glyph that is truly supported in
// font:

// Autocad fonts and old fonts created by Fontographer, have a bogus idRangeOffset
// for the last segment see WinBug 571081, trying to decode run with start = 0xffff
// can result in reading data out of valid memory

    if ((((uint16 UNALIGNED *)pstartCount)[cRuns-1] == 0xffff) && (cRuns > 1))
        cRuns -= 1; // do not report trivial run

// real no of runs, including the range for b7: If b7 is already supportred
// then the same as number of runs reported in a font. If b7 is not supported
// we will have to add a range [b7,b7] to the glyphset structure for win31
// compatibility reasons. win31 maps b7 to 2219 and we will have b7 point to 2219

    if (bInsert_b7)  // if b7 not supported in a font but 2219 is
    {
        pcmi->i_b7 += cRuns5cSplit;
        cRuns++;              // add a run with b7 only
    }

// by default we will not have to simulate the presence of b7 by adding
// an extra run containing single glyph

    pwcrun_b7 = NULL;

    pwcrunInit = &pgset->awcrun[0];

// Add one more run for 5c split

    pwcrun5cFirst = NULL;

    if(cRuns5cSplit)
    {
        cRuns++;
        pwcrun5cFirst = pwcrunInit;
    }

    phg = (HGLYPH *)((PBYTE)pgset + offsetof(FD_GLYPHSET,awcrun) + cRuns*sizeof(WCRUN));

    if (bInsert_b7)  // if b7 not supported in a font, will have to add it
    {
        pwcrun_b7 = pwcrunInit + pcmi->i_b7;
    }

    ASSERTDD((pcmi->cRuns+cRuns5cSplit) == cRuns, "cRuns\n");

    for
    (
         pwcrun = pwcrunInit, pwcrunEnd = pwcrunInit + cRuns;
         pwcrun < pwcrunEnd;
         pwcrun++, pstartCount++, pendCount++
    )
    {
        WCHAR   wcFirst, wcLast;

    // check if we need to skip a run and a handle space for b7:

        if (bInsert_b7 && (pwcrun == pwcrun_b7))
        {
        #if DBG
            cGlyphsSupported += 1;   // list b7 as a supported glyph
        #endif

            pwcrun->wcLow = 0xb7;
            pwcrun->cGlyphs = 1;
            pwcrun->phg = phg;         // will be initialized later
            phg++;                     // skip to the next handle
            pwcrun++;                  // go to the next run
            if (pwcrun == pwcrunEnd)   // check if done
            {
                break; // done
            }
        }

        wcFirst = (WCHAR)BE_UINT16(pstartCount);
        wcLast  = (WCHAR)BE_UINT16(pendCount);

        pwcrun->cGlyphs = (USHORT)(wcLast - wcFirst + 1);

    // is this a run which contains b7 ?

        if ((0xb7 >= wcFirst) && (0xb7 <= wcLast))
            pwcrun_b7 = pwcrun;

    // add the default glyph at the end of the first run, if possible, i.e.
    // if wcLast < 0xffff for the first run, and if we are not in the collision
    // with the run we have possibly added for b7
    // Above adding default glyph has been removed since nobody use that default
    // glyph and adding default glyph broke font link.        katsumiy 8/15/2000


    #if DBG
        cGlyphsSupported += pwcrun->cGlyphs;
    #endif

        pwcrun->wcLow   = wcFirst;
        pwcrun->phg     = phg;

        if(pwcrun == pwcrun5cFirst)
        {
            USHORT  cGlyphs;

            cGlyphs = pwcrun->cGlyphs;
            pwcrun->cGlyphs = 0x5c - pwcrun->wcLow;

            if ((iRet = fs_WinNTGetGlyphIDs (pgin, pwcrun->cGlyphs, wcFirst, 0, NULL, phg)) != NO_ERR)
            {
                V_FSERROR(iRet);
                RET_FALSE("TTFD!_cjComputeGLYPHSET_MSFT_UNICODE, fs_WinNTGetGlyphIDs\n");
            }
            phg += pwcrun->cGlyphs;

            // For the split run
            cGlyphs = cGlyphs - pwcrun->cGlyphs - 1;
            pwcrun++;
            pwcrun->wcLow   = 0x5d;
            pwcrun->phg     = phg;
            pwcrun->cGlyphs = cGlyphs;

            if ((iRet = fs_WinNTGetGlyphIDs (pgin, pwcrun->cGlyphs, 0x5d, 0, NULL, phg)) != NO_ERR)
            {
                V_FSERROR(iRet);
                RET_FALSE("TTFD!_cjComputeGLYPHSET_MSFT_UNICODE, fs_WinNTGetGlyphIDs\n");
            }

            phg += pwcrun->cGlyphs;
            
#if DBG
            cGlyphsSupported--;
#endif
            pcmi->cGlyphs--;
        }
        else
        {
            if (wcFirst < 0xffff)
            {
              // this test allow bogous font that have duplicate stopper run in the cmap to get installed
              // nt bug #277787, font Isocp2.ttf form Autocad
                if ((iRet = fs_WinNTGetGlyphIDs (pgin, pwcrun->cGlyphs, wcFirst, 0, NULL, phg)) != NO_ERR)
                {
                     V_FSERROR(iRet);
                     RET_FALSE("TTFD!_cjComputeGLYPHSET_MSFT_UNICODE, fs_WinNTGetGlyphIDs\n");
                }
            }

            phg += pwcrun->cGlyphs;
        }
    }

// fix a handle for b7:

    if (bInsert_b7)
    {
        PWCRUN   pwcrun_2219;

        pcmi->i_2219 += cRuns5cSplit;

        pwcrun_2219 = pwcrunInit + pcmi->i_2219;

        ASSERTDD(pwcrun_b7,"these ptrs must not be 0\n");
        ASSERTDD(0x2219 >= pwcrun_2219->wcLow, "pwcrun_2219->wcLow\n");
        ASSERTDD(0x2219 < (pwcrun_2219->wcLow + pwcrun_2219->cGlyphs),
            "pwcrun_2219->wcHi\n"
            );

        pwcrun_b7->phg[0xb7 - pwcrun_b7->wcLow] =
            pwcrun_2219->phg[0x2219 - pwcrun_2219->wcLow];
    }

    ASSERTDD(pcmi->cGlyphs == cGlyphsSupported, "cGlyphsSupported\n");

    pgset->cjThis  = cjRet;
    pgset->flAccel = GS_16BIT_HANDLES;
    pgset->cGlyphsSupported = pcmi->cGlyphs;
    pgset->cRuns = cRuns;

    return cjRet;
}



/******************************Public*Routine******************************\
*
* STATIC ULONG  cjGsetGeneral
*
* computes the size of FD_GLYPHSET structure for the font represented
* by this mapping Table
*
* History:
*  21-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

//!!! this needs some review [bodind]

STATIC ULONG
cjGsetGeneral(
    sfnt_mappingTable      *pmap,
    CMAPINFO               *pcmi
    )
{
    switch(pmap->format)
    {
    case BE_FORMAT_MAC_STANDARD:

        return 20; // return(ggsetMac->cjThis);

    case BE_FORMAT_MSFT_UNICODE:

        switch(pcmi->ui16SpecID)
        {
          case BE_SPEC_ID_SHIFTJIS :
          case BE_SPEC_ID_GB :
          case BE_SPEC_ID_BIG5 :
          case BE_SPEC_ID_WANSUNG :
            return cjComputeGLYPHSET_MSFT_GENERAL (pmap,0,NULL,pcmi);

          case BE_SPEC_ID_UGL :
            default :

            return cjComputeGLYPHSET_MSFT_UNICODE (pmap,NULL,NULL,pcmi);
        }

    case BE_FORMAT_TRIMMED:

        WARNING("TTFD!_cjGsetGeneral: TRIMMED format\n");
        return 0;

    case BE_FORMAT_HIGH_BYTE:

        WARNING("TTFD!_cjGsetGeneral: HIGH_BYTE format\n");
        return 0;

    default:

        WARNING("TTFD!_cjGsetGeneral: illegal format\n");
        return 0;

    }
}


/******************************Public*Routine******************************\
*
* BOOL IsValidFormat4TableSize
*
*
* Effects: Calculate real Cmap format4 subtable size
*
*   USHORT  format  Format number is set to 4. 
*   USHORT  length  Length in bytes. 
*   USHORT  version Version number (starts at 0).
*   USHORT  segCountX2  2 x segCount.
*   USHORT  searchRange     2 x (2**floor(log2(segCount)))
*   USHORT  entrySelector   log2(searchRange/2)
*   USHORT  rangeShift  2 x segCount - searchRange
*   USHORT  endCount[segCount]  End characterCode for each segment,last =0xFFFF.
*   USHORT  reservedPad Set to 0.
*   USHORT  startCount[segCount]    Start character code for each segment.
*   USHORT  idDelta[segCount]   Delta for all character codes in segment.
*   USHORT  idRangeOffset[segCount] Offsets into glyphIdArray or 0
*   USHORT  glyphIdArray[ ] Glyph index array (arbitrary length)
*   
*
* History:
*  09-aug-2001 -by- styoo
* Wrote it.
\**************************************************************************/

STATIC BOOL IsValidFormat4TableSize(
    uint16   cRuns,
    sfnt_char2IndexDirectory * pcmap,
    uint32      offsetOfSubTable,
    uint32      sizeOfCmap
)
{
    uint32  uEndOfGlyphIdArray;
    uint16  *pstartCount, *pendCount, *pidRangeOffset, i;

    uint32 idRangeTableOffset  = (uint32)(offsetOfSubTable + OFF_endCount + (cRuns * 6) + 2);
    uint32 endCount = 0;
    uint32 startCount; 
    uint16 idRangeOffset;

    if ((cRuns == 0) || ((uint32)(idRangeTableOffset + (cRuns * 2)) > sizeOfCmap ))
        return FALSE;

    pendCount = (uint16 *)((PBYTE)pcmap + offsetOfSubTable + OFF_endCount);
    pstartCount = (uint16 *)((PBYTE)pcmap + offsetOfSubTable + OFF_endCount + (cRuns * 2) + 2);
    pidRangeOffset = (uint16 *)((PBYTE)pcmap + offsetOfSubTable + OFF_endCount + (cRuns * 6) + 2);

    // Autocad fonts and old fonts created by Fontographer, have a bogus idRangeOffset
    // for the last segment see WinBug 571081
    if ((((uint16 UNALIGNED *)pstartCount)[cRuns-1] == 0xffff) && (cRuns > 1))
        cRuns -= 1; // do not report trivial run

    for( i=0; i<cRuns;  i++, pstartCount++, pendCount++, pidRangeOffset++){
        startCount = BE_UINT16(pstartCount); 
        idRangeOffset = BE_UINT16(pidRangeOffset);

        // The search algorithm defined in the TrueType font file
        // specification for format 4 says 'You search for the first endcode
        // that is greater than or equal to the character code you want to
        // map'. A side effect of this is that we need to ignore codepoints
        // from the StartCount up to and including the EndCount of the
        // previous segment. Although you might not expect the StartCount of
        // a segment to be less than the EndCount of the previous segment,
        // it does happen (Arial Unicode MS), presumably to help in the
        // arithmetic of the lookup.

        if (startCount < endCount)
        {
            startCount = endCount + 1;
        }
        endCount = BE_UINT16(pendCount); 
        if(idRangeOffset != 0){

            uEndOfGlyphIdArray =    (uint32)(idRangeOffset
                +  ((endCount - startCount + 1) * sizeof(uint16))
                +  idRangeTableOffset + (i*2));

            if( uEndOfGlyphIdArray > sizeOfCmap )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* STATIC BOOL bVerifyMsftTable
*
*
* Effects: checks whether the table is consistent with what tt
*          spec claims it should be
*
*
* History:
*  22-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define PMAPRESERVEDPAD     2

STATIC BOOL
bVerifyMsftTable (
    sfnt_mappingTable *pmap,
    ULONG             *pulGsetType,
    ULONG             *pul_wcBias,
    CMAPINFO          *pcmi,
    uint16             ui16SpecID,
    ULONG             * pul_startCount,
    uint32      sizeOfCmap,
    uint32      offsetOfSubTable,
    sfnt_char2IndexDirectory * pcmap
    )
{
    uint16 * pstartCount, * pstartCountBegin;
    uint16 * pendCount, * pendCountEnd;
    uint16   cRuns;
    uint16   usLo, usHi, usHiPrev;
    BOOL     bInsert_b7;

// Check minimun size before to get cRuns 
    if( offsetOfSubTable + OFF_endCount > sizeOfCmap )
        RET_FALSE("TTFD!_bVerifyMsftTable, sizeOfCmap1\n");

// WINBUG 537635 claudebe 2/11/02 we need to swap the bytes, IA 64 unaligned font tables
    if (pmap->format != BE_FORMAT_MSFT_UNICODE)
        RET_FALSE("TTFD!_bVerifyMsftTable, format\n");

    cRuns = BE_UINT16((PBYTE)pmap + OFF_segCountX2);

    if (cRuns & 1)
        RET_FALSE("TTFD!_bVerifyMsftTable, segCountX2 is odd\n");

    cRuns >>= 1;

// Check if subtable except variable length glyphIdArray is in valid range
    if( sizeOfCmap < offsetOfSubTable + (OFF_endCount +PMAPRESERVEDPAD + 4 * cRuns * sizeof(uint16)))
        RET_FALSE("TTFD!_bVerifyMsftTable, sizeOfCmap2\n");

// get the pointer to the beginning of the array of endCount code points

    pendCount = (uint16 *)((PBYTE)pmap + OFF_endCount);

// the final endCode has to be 0xffff;
// if this is not the case, there is a bug in the tt file or in our code:

    if ( ((uint16 UNALIGNED *)pendCount)[cRuns - 1] != 0xFFFF)
        RET_FALSE("TTFD!_bVerifyMsftTable, pendCount[cRuns - 1] != 0xFFFF\n");

    if(!IsValidFormat4TableSize(cRuns, pcmap,offsetOfSubTable,sizeOfCmap)){
        RET_FALSE("TTFD!_bVerifyMsftTable, corrupted pmap\n");
    }
    

// Get the pointer to the beginning of the array of startCount code points
// For resons known only to tt designers, startCount array does not
// begin immediately after the end of endCount array, i.e. at
// &pendCount[cRuns]. Instead, they insert an uint16 padding which has to
// set to zero and the startCount array begins after the padding. This
// padding in no way helps alignment of the structure nor it is useful
// for anything else. Moreover, there are fonts which forget to set the
// padding to zero and are otherwise ok (bodoni), which load under win31
// so that I have to remove this check:


// set the default, change only as needed

    *pulGsetType = GSET_TYPE_GENERAL;

// check whether the runs are well ordered, find out if b7
// is supported in one of the ranges in a font by checking complimetary ranges
// of glyphs that are NOT SUPPORTED

    usHiPrev = 0;
    pendCountEnd = &pendCount[cRuns];
    pstartCountBegin = pstartCount = &pendCount[cRuns + 1];
// check if this is a candidate for a symbol font
// stored in the unicode range 0xf000 - 0xf0ff that has to be
// mapped to 0x0000-0x00ff range, or maybe if this is a crazy arabic font
// which has glyphs in the range f200-f2ff.
// We have seen several fonts broken in the past as a result od touching the
// next few lines of code that compute wcBias.
// Here are all of these cases:

#if 0

originally, in 3.51 the code was as follows:

   if ((*pul_wcBias & 0xFF00) == 0xF000)
       *pul_wcBias =  0xF000;
   else
       *pul_wcBias = 0;
This did not work for arabic trad.ttf font:

trad.ttf. (arabic) format (3,0), range [f200,f2ff],
wcBias needs to be f200-20 for compat. It can be computed as follows:

<     if ((*pul_wcBias & 0xFF00) == 0xF000)
<         *pul_wcBias =  0xF000;
<     else
<         *pul_wcBias = 0;
---
>     *pul_wcBias = (BE_UINT16(pstartCount)) & 0xFF00;

for some reason this did not work, perhaps because of msicons2.ttf,
had to do fix to a fix

<     *pul_wcBias = (BE_UINT16(pstartCount)) & 0xFF00;
---
>     *pul_wcBias = BE_UINT16(pstartCount) - 0x20; // = f200 - 20 = f1e0.

This is a pathological case, had to be put in so that this font
can work the same way as it does under win95

msicons2.ttf, format (3,0), ranges are [0001,0004], [0007,0007], etc.
wcBias needs to be ?


garam4.ttf. This is a regular (3,1) font with one anomaly which is that the
first range is anomalous [00, 00], the second range is [20,ff] etc.
wcBias needs to be 0 in this case. so the fix is as follows:

<     *pul_wcBias = BE_UINT16(pstartCount) - 0x20;
---
>     *pul_wcBias = BE_UINT16(pstartCount);
>     if (*pul_wcBias & 0xff00) // one of these
>         *pul_wcBias = *pul_wcBias - 0x20;  // covers arabic case
>     else
>         *pul_wcBias = 0; // garam4 case

this is how we arrive at our present code which seems to be breaking
fonts obtained by conversion from Type 1 fonts with custom encoding,
examples being cmr10.ttf (yy font)

cmr10.ttf, format (3,0), ranges [f000, f080], etc,
wcBias needs to be f000 in this case.

also

gotbx__2.ttf, format (3,0), ranges [f005, f006], [f008,f008], etc,
wcBias needs to be f000 in this case.

bahamn1.ttf: format (3,0), ranges [0020, 007E], etc.

#endif

    *pul_wcBias = BE_UINT16(pstartCount);

    *pul_startCount = *pul_wcBias;     // save it to identify BiDi fonts later

    if (ui16SpecID == BE_SPEC_ID_UGL)  // ie. specific id = 1, regular case
    {
        if ((*pul_wcBias & 0xff00) == 0xf000)
        {
            *pul_wcBias = 0xf000; // chess figurine fonts hack, they have spec id == 1, force them to symbol font case.
        }
        else // all other normal fonts:
        {
            *pul_wcBias = 0; // garam4.ttf is in this class
        }
    }
    else // specific id = 0; // symbol font case
    {
    // trad.ttf, msicons2.ttf, cmr10.ttf, gotbx__2.ttf
    // Another interesting font is corel's font Bahamn1.ttf.
    // This font is really not symbol font, it has specific id errorneously
    // set to zero. This font contains some Eastern European characters.
    // For this font we do NOT want to use
    // GSET_TYPE_SYMBOL. This font has the opposite problem from chess figurine
    // font which is a symbol font with specific id set to 1 instead of zero.
        switch (*pul_wcBias & 0xff00)
        {
        case 0xf000:

        // custom encoding t1 fonts converted to tt (cmr10.ttf, gotbx__2.ttf)
        // and and all other "reasonable" tt symbol fonts.
        // Examples of other "reasonable" symbol fonts are
        // marlett.ttf, symbol.ttf and wingding.ttf where for all these fonts
        // the first range is [f020, ???], so that, either formula would work

            *pul_wcBias = 0xf000;
            break;

        case 0: // msicons2.ttf,bahamn1.ttf. How to differentiate between them?

           *pul_wcBias = 0;
           break;

         case 0xe000: // eudc fonts
           *pul_wcBias = 0;
           break;

        case 0xf200:          // trad.ttf FP
        default:
            *pul_wcBias = *pul_wcBias - 0x20;
            break;
        }
    }

// here we shall check if the last run is just a terminator for the
// array of runs or a real nontrivial run. If just a terminator, there is no
// need to report it. This will save some memory in the cache plus
// pifi->wcLast will represent the last glyph that is truly supported in
// font:

    if ((((uint16 UNALIGNED *)pstartCountBegin)[cRuns-1] == 0xffff) && (cRuns > 1))
    {
        cRuns -= 1; // do not report trivial run
        pendCountEnd--;
    }

// init the cmap info:

    pcmi->fl         = 0;
    pcmi->i_b7       = 0;       // index for [b7,b7] wcrun in FD_GLYPHSET if b7 is NOT supported
    pcmi->i_2219     = 0;       // cmap index for 2219 if 2219 IS supported
    pcmi->cRuns      = cRuns;   // number of runs in a font, excluding the last run if equal to [ffff,ffff]
    pcmi->cGlyphs    = 0;       // total number of glyphs in a font
    for (
         ;
         pendCount < pendCountEnd;
         pstartCount++, pendCount++, usHiPrev = usHi
        )
    {
        usLo = BE_UINT16(pstartCount);
        usHi = BE_UINT16(pendCount);

        if (usHi < usLo)
            RET_FALSE("TTFD!_bVerifyMsftTable: usHi < usLo\n");
        if (usHiPrev > usLo)
            RET_FALSE("TTFD!_bVerifyMsftTable: usHiPrev > usLo\n");

        pcmi->cGlyphs += (ULONG)(usHi + 1 - usLo);

    // check if b7 is in one of the ranges of glyphs that are NOT SUPPORTED

        if ((0xb7 > usHiPrev) && (0xb7 < usLo))
        {
        // store the index of the run that b7 is going to occupy in FD_GLYPHSET
        // Just in case this index is zero we will store it in the upper word
        // of b7Absent and store 1 in the lower word

            pcmi->fl |= CMI_B7_ABSENT;
            pcmi->i_b7 = (ULONG)(pstartCount - pstartCountBegin);
        }

    // check if 2219 is supported in a font, if not then there is
    // no need to make a handle for b7 equal to the handle for 2219.
    // In other words if 0x2219 is not supported in a font, there will be no
    // need to hack FD_GLYPHSET to make hg(b7) == hg(2219) and possibly add a
    // [b7,b7] range if b7 is not already supported in a font:

        if ((0x2219 >= usLo) && (0x2219 <= usHi))
        {
            pcmi->fl |= CMI_2219_PRESENT;
            pcmi->i_2219 = (ULONG)(pstartCount - pstartCountBegin);
        }
    }

// this is what we will do

// b7 supported       2219 supported  => hg(b7) = hg(2219)
// b7 not supported   2219 supported  => add [b7,b7] range and hg(b7) = hg(2219)
// b7 supported       2219 not supported  => do nothing
// b7 not supported   2219 not supported  => do nothing

    bInsert_b7 = (pcmi->fl & (CMI_2219_PRESENT | CMI_B7_ABSENT)) == (CMI_2219_PRESENT | CMI_B7_ABSENT);

    if (bInsert_b7)
    {
    // will have to insert [b7,b7] run, one more run, one more glyph, i_2219
    // has to be incremented because the run for b7 will be inserted before the
    // run which contains 2219

        pcmi->cRuns++;
        pcmi->cGlyphs++;
        pcmi->i_2219++;
    }

// add a default glyph at the end of the first run if not in collision with
// the run for b7 that we may have possibly inserted and if the first run is
// not the last run at the same time;
// Above adding default glyph has been removed since nobody use that default
// glyph and adding default glyph broke font link.        katsumiy 8/15/2000

    return (TRUE);
}


/******************************Public*Routine******************************\
*
* STATIC BOOL bVerifyMacTable(sfnt_mappingTable * pmap)
*
* just checking consistency of the format
*
* History:
*  23-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bVerifyMacTable(
    sfnt_mappingTable * pmap,
    uint32 sizeOfCmap,
    uint32 offsetOfSubTable
    )
{
    if( offsetOfSubTable + SIZEOF_SFNT_MAPPINGTABLE + 256 > sizeOfCmap )
        RET_FALSE("TTFD!bVerifyMacTable, sizeOfCmap\n");

    if (pmap->format != BE_FORMAT_MAC_STANDARD)
        RET_FALSE("TTFD!_bVerifyMacTable, format \n");

// sfnt_mappingTable is followed by <= 256 byte glyphIdArray

    if (BE_UINT16(&pmap->length) > DWORD_ALIGN(SIZEOF_SFNT_MAPPINGTABLE + 256))
        RET_FALSE("TTFD!_bVerifyMacTable, length \n");

    return (TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bLoadTTF
*
* Effects:
*
* Warnings:
*
* History:
*  29-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

//!!! SHOUD BE RETURNING hff


#define OFF_TTC_Sign           0x0000
#define OFF_TTC_Version        0x0004
#define OFF_TTC_DirectoryCount 0x0008
#define OFF_TTC_DirectoryEntry 0x000C

#define DSIG_LONG_TAG          0x44534947

#define TTC_VERSION_1_0     0x00010000



ULONG GetUlong( PVOID pvView, ULONG ulOffset)
{
    ULONG ulReturn;

    ulReturn = (  (ULONG)*((PBYTE) pvView + ulOffset +3)              |
                (((ULONG)*((PBYTE) pvView + ulOffset +2)) << 8)  |
                (((ULONG)*((PBYTE) pvView + ulOffset +1)) << 16) |
                (((ULONG)*((PBYTE) pvView + ulOffset +0)) << 24)
               );
    return ( ulReturn );
}


BOOL bVerifyTTC (
    PVOID pvView
    )
{
    ULONG ulVersion;
// Check TTC ID.

    #define TTC_ID      0x66637474

    if(*((PULONG)((BYTE*) pvView + OFF_TTC_Sign)) != TTC_ID)
        return(FALSE);

// Check TTC verson.

    ulVersion = SWAPL(*((PULONG)((BYTE*) pvView + OFF_TTC_Version)));

    if (ulVersion < TTC_VERSION_1_0)
        RETURN("TTFD!ttfdLoadFontFileTTC(): wrong TTC version\n", FALSE);

    return(TRUE);
}

void vFontFileCache(PTTC_FONTFILE pttc, ULONG ulFastCheckSum, ULONG flTTCFormat)
{
    PTTC_CACHE  pCache_TTC;
    PTTF_CACHE  pCache_TTF;
    PBYTE       pbCache;
    HFF         hff;
    ULONG       i;
    ULONG       ulSize;
    DWORD       dpTTF;
    DWORD       dpGlyphAttr = 0;

    if (!ulFastCheckSum)
        return;

    ulSize = 0;

// compute how much space we need in cache to store ifimetrics

    for ( i = 0; i < pttc->ulNumEntry; i++ )
    {
        if (pttc->ahffEntry[i].iFace == 1)
        {
            hff = pttc->ahffEntry[i].hff;

            ulSize += offsetof(TTF_CACHE, acIfi) + QWORD_ALIGN(PFF(hff)->ifi.cjThis);
        }
    }

    dpTTF = QWORD_ALIGN(offsetof(TTC_CACHE, dpTTF) + (pttc->ulTrueTypeResource * sizeof (DWORD)));

    ulSize += dpTTF;

    if (PFF(pttc->ahffEntry[0].hff)->ffca.fl & FF_DBCS_CHARSET)
    {
        ASSERTDD(pttc->pga, "vFontFileCache: pga is NULL\n");
        dpGlyphAttr = ulSize;
        ulSize += QWORD_ALIGN(pttc->pga->cjThis);
    }

    if (pCache_TTC = (PTTC_CACHE) EngFntCacheAlloc(ulFastCheckSum, ulSize))
    {
        BOOL bException = FALSE;

#ifndef TTFD_NO_TRY_EXCEPT
        try
        {
#endif
            DWORD iTTF = 0;

            pCache_TTC->flTTCFormat = flTTCFormat;
            pCache_TTC->cTTFsInTTC = pttc->ulTrueTypeResource ;
            pCache_TTC->dpGlyphAttr = dpGlyphAttr;
            
        // Now IFI metrices will be cached into TTCACHE file
            pbCache = (PBYTE) pCache_TTC + dpTTF;

            for( i = 0; i < pttc->ulNumEntry; i++ )
            {
                hff = pttc->ahffEntry[i].hff;

                if (pttc->ahffEntry[i].iFace == 1)
                {
                    // start of TTF_CACHE

                    pCache_TTF = (PTTF_CACHE) pbCache;
    
                    // Get the disp for TTF

                    pCache_TTC->dpTTF[iTTF] = (DWORD)((PBYTE) pCache_TTF - (PBYTE)pCache_TTC);

                // IFI Cache will do for normal font face
                // @font face will be copied after normal face finish

                    pCache_TTF->ffca = PFF(hff)->ffca;

                // Copy the IFI into cache

                    RtlCopyMemory((PBYTE) &pCache_TTF->acIfi, (PBYTE) &PFF(hff)->ifi, PFF(hff)->ifi.cjThis);

                // offset of GSET, the offset is calculated from TTF_CACHE

                    pbCache = (PBYTE) &pCache_TTF->acIfi + QWORD_ALIGN (PFF(hff)->ifi.cjThis);

                    if (PFF(hff)->ffca.ulNumFaces == 2)
                    {
                    // Cache the info computed by bCheckVerticalTable:
                        if (PFF(hff)->hgSearchVerticalGlyph == SearchMortTable)
                            pCache_TTF->iSearchVerticalGlyph = SUB_FUNCTION_MORT;
                        else if (PFF(hff)->hgSearchVerticalGlyph == SearchGsubTable)
                            pCache_TTF->iSearchVerticalGlyph = SUB_FUNCTION_GSUB;
                        else
                            pCache_TTF->iSearchVerticalGlyph = SUB_FUNCTION_DUMMY;
                    }
                    else
                    {
                        pCache_TTF->iSearchVerticalGlyph  = SUB_FUNCTION_DUMMY;
                    }

                    iTTF++; // go to the next ttf file
                }
            }

            if (pCache_TTC->dpGlyphAttr)
            {
                ASSERTDD(pttc->pga, "vFontFileCache: pttc->pga is NULL\n");
                RtlCopyMemory((PBYTE)((PBYTE)pCache_TTC + pCache_TTC->dpGlyphAttr), (PBYTE) pttc->pga, pttc->pga->cjThis);
            }
                
#ifndef TTFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
        // There is something that FAULTed during IFI cache write.

            bException = TRUE;
        }
#endif

        if (bException)
        {
            EngFntCacheFault(ulFastCheckSum, ENG_FNT_CACHE_WRITE_FAULT);
        }
    }
}

VOID vCopy_IFIV ( PIFIMETRICS pifi, PIFIMETRICS pifiv)
{
    PWCHAR pwchSrc, pwchDst;

    RtlCopyMemory(pifiv, pifi, pifi->cjThis);

//
// modify facename so that it has '@' at the beginning of facename.
//
    pwchSrc = (PWCHAR)((PBYTE)pifiv + pifiv->dpwszFaceName);
    pwchDst = (PWCHAR)((PBYTE)pifi + pifi->dpwszFaceName);

    *pwchSrc++ = L'@';
    while ( *pwchDst )
    {
        *pwchSrc++ = *pwchDst++;
    }

    *pwchSrc = L'\0';

    // modify familyname so that it has '@' at the beginning of familyname

    pwchSrc = (PWCHAR)((PBYTE)pifiv + pifiv->dpwszFamilyName);
    pwchDst = (PWCHAR)((PBYTE)pifi + pifi->dpwszFamilyName);

    *pwchSrc++ = L'@';

    while ( *pwchDst )
    {
        *pwchSrc++ = *pwchDst++;
    }

    *pwchSrc = L'\0';

    if(pifiv->flInfo & FM_INFO_FAMILY_EQUIV)
    {
        pwchSrc++;
        pwchDst++;

        *pwchSrc++ = L'@';

        while ( *pwchDst )
        {
            *pwchSrc++ = *pwchDst++;
        }

        *pwchSrc++ = L'\0';
        *pwchSrc = L'\0';
    }

}

BOOL bLoadTTF_Cache(
    ULONG_PTR   iFile,
    PVOID       pvView,
    ULONG       cjView,
    HFF         *phff,
    PTTF_CACHE  pCache,
    ULONG       ulFastCheckSum
    )
{
    PIFIMETRICS         pifiCache;
    PFONTFILE           pff;
    ULONG               cjff;
    PIFIMETRICS         pifiv = NULL; // ifimetrics for the vertical face
    BOOL                bRet;

    ASSERTDD(pCache, "pCache is not allocate \n");

    *phff = HFF_INVALID;

    pifiCache = (PIFIMETRICS) pCache->acIfi;

    cjff = offsetof(FONTFILE,ifi) + pifiCache->cjThis;

    if ((pff = pffAlloc(cjff)) == PFF(NULL))
    {
        RET_FALSE("TTFD!bLoadTTF_Cache(): memory allocation error\n");
    }

    bRet = TRUE;
    *phff = (HFF)pff;

    /* we need to clean the beginning of pff to ensure correct cleanup in case of error/exception */

    RtlZeroMemory((PVOID)pff, offsetof(FONTFILE,ifi));

// init fields of pff structure
// store the ttf file name at the bottom of the strucutre

    pff->pfcToBeFreed = NULL;

// initialize count of HFC's associated with this HFF

    pff->cRef    = 0L;

// remember which file this is

    pff->iFile = iFile;
    pff->pvView = pvView;
    pff->cjView = cjView;

// The kerning pair array is allocated and filled lazily.  So set to NULL
// for now.

    pff->pkp = (FD_KERNINGPAIR *) NULL;

    pff->pj034   = (PBYTE)NULL;
    pff->pfcLast = (FONTCONTEXT *)NULL;

// By default the number of faces is 1L.  The vert facename code may change this.

    pff->pifi_vertical = NULL;
    pff->pgsetv = NULL;
    pff->pgset  = NULL;

    if (pCache->ffca.ulNumFaces == 2)
    {
        ASSERTDD(pCache->ffca.fl & FF_DBCS_CHARSET, "IFI cache: pff->ffca.fl & FF_DBCS_CHARSET == 0\n");

        pifiv = (PIFIMETRICS)PV_ALLOC( NATURAL_ALIGN(pifiCache->cjThis));

        if (pifiv == NULL)
        {
            bRet = FALSE;
            WARNING("TTFD! TTF Cache can not allocate enough memory for @face \n");
            goto retError;

        }

    }

#ifndef TTFD_NO_TRY_EXCEPT
    try
    {
#endif
    // Copy the pff cache
        pff->ffca = pCache->ffca;

        RtlCopyMemory((PBYTE) &pff->ifi, (PBYTE)pifiCache, pifiCache->cjThis);

        if (pifiv)
        {

            ASSERTDD(pff->ffca.fl & FF_DBCS_CHARSET, "Font file cache something wrong in DBCS charset \n");

            vCopy_IFIV(&pff->ifi, pifiv);

        // save a pointer to the vertical ifimetrics.
        // now we have two faces( normal, @face ) for the fontfile.

            pff->pifi_vertical = pifiv;

        // now we init the fields that are initialized by bCheckVerticalTable in the usual case

            switch (pCache->iSearchVerticalGlyph)
            {
            case SUB_FUNCTION_MORT:
                pff->hgSearchVerticalGlyph = SearchMortTable;
                break;

            case SUB_FUNCTION_GSUB:
                pff->hgSearchVerticalGlyph = SearchGsubTable;
                break;

            case SUB_FUNCTION_DUMMY:
            default:
                pff->hgSearchVerticalGlyph = SearchDummyTable;
                break;
            }
        }

        pff->cRefGSet = 0;
        pff->cRefGSetV = 0;
#ifndef TTFD_NO_TRY_EXCEPT
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }
#endif

    if (!bRet)
    {
        EngFntCacheFault(ulFastCheckSum, ENG_FNT_CACHE_READ_FAULT);
    }

retError:
    if (!bRet)
    {

    // Free FONTFILE * pff
        if (*phff)
        {
            vFreeFF(*phff);
            *phff = (HFF)NULL;
        }

    //  Free IFI for  @face
        if (pifiv)
        {
            V_FREE(pifiv);
            pifiv = NULL;
        }

    }

    return bRet;
}

BOOL bLoadFontFile (
    ULONG_PTR iFile,
    PVOID pvView,
    ULONG cjView,
    ULONG ulLangId,
    ULONG ulFastCheckSum,
    HFF   *phttc
    )
{
    BOOL            bRet = FALSE;

    BOOL           bTTCFormat;
    PTTC_FONTFILE  pttc;
    ULONG          cjttc,i;

    HFF hff;

    PTTC_CACHE      pCache_TTC;
    PTTF_CACHE      pCache_TTF;
    BOOL            bCached;
    ULONG           ulSize;

    *phttc = (HFF)NULL; // Important for clean up in case of exception

// How mamy TrueType resources in this file if TTC file.

// Look up the fontcache for IFI metrices

    pCache_TTC = NULL;
    pCache_TTF = NULL;
    bCached = FALSE;   // flag that info is not in the cache

// ulCheckSum means, Font file Cache now is active and we need to read or write from TTCACHE

    if (sizeof(sfnt_OffsetTable) > cjView)
            RETURN("TTFD!bLoadFontFile(): size of font file too small\n", FALSE);


    if (ulFastCheckSum)
    {
        pCache_TTC = (PTTC_CACHE) EngFntCacheLookUp(ulFastCheckSum, &ulSize);

        if (pCache_TTC)
        {

        // Check this is a TrueType collection format or not.
        
            bTTCFormat = pCache_TTC->flTTCFormat;
            
            bCached = TRUE;
        }
    }
    
    if (!bCached)
    {
    // Check this is a TrueType collection format or not.

        bTTCFormat = bVerifyTTC(pvView);
    }

    if(bTTCFormat)
    {
        ULONG     ulTrueTypeResource;
        ULONG     ulEntry;
        BOOL      bCanBeLoaded = TRUE;

    // Get Directory count.

        if (bCached)
            ulTrueTypeResource = pCache_TTC->cTTFsInTTC;
        else
            ulTrueTypeResource = GetUlong(pvView,OFF_TTC_DirectoryCount);

        // defense against overflow in cjttc calculations

        {   // defense against overflow in cjttc calculations
            static const ULONG ulTrueTypeResourceMax =
                (ULONG_MAX - offsetof(TTC_FONTFILE,ahffEntry))/(sizeof(TTC_HFF_ENTRY) * 2);
            if (ulTrueTypeResource >= ulTrueTypeResourceMax ||
                ulTrueTypeResource > (cjView - OFF_TTC_DirectoryEntry)/sizeof(ULONG))
                RETURN("TTFD!bLoadFontFile(): size of font file too small for ttc directory\n", FALSE);
        }

   // Allocate TTC_FONTFILE structure

        cjttc =  offsetof(TTC_FONTFILE,ahffEntry);
        cjttc += sizeof(TTC_HFF_ENTRY) * ulTrueTypeResource * 2; // *2 for Vertical face

        *phttc = (HFF)pttcAlloc(cjttc);

        pttc = (PTTC_FONTFILE)*phttc;

        if(pttc == (HFF)NULL)
            RETURN("TTFD!ttfdLoadFontFileTTC(): pttcAlloc failed\n", FALSE);

        
    // fill hff array in TTC_FONTFILE struture

        ulEntry = 0;

        for( i = 0; i < ulTrueTypeResource; i++ )
        {
            ULONG    ulOffset;


        // get the starting offset of a TrueType font resource.
            if (bCached)
            {
                pCache_TTF = (PTTF_CACHE) ((PBYTE) pCache_TTC + pCache_TTC->dpTTF[i]);
                ulOffset = pCache_TTF->ffca.ulTableOffset;
            }
            else
            {
                pCache_TTF = NULL;
                ulOffset = GetUlong(pvView,(OFF_TTC_DirectoryEntry + (4 * i)));
            }

        // load font..

            pttc->ahffEntry[ulEntry].iFace = 1; // start from 1.
            pttc->ahffEntry[ulEntry].ulOffsetTable = ulOffset;

            if (bLoadTTF(iFile,pvView,cjView,ulOffset,ulLangId,&pttc->ahffEntry[ulEntry].hff,pCache_TTF, ulFastCheckSum))
            {
                hff = pttc->ahffEntry[ulEntry].hff;

            // set pointer to TTC_FONTFILE in FONTFILE structure

                PFF(hff)->pttc = pttc;

                ASSERTDD(
                    PFF(hff)->ffca.ulNumFaces <= 2,
                    "TTFD!ulNumFaces > 2\n"
                    );

                if (PFF(hff)->ffca.ulNumFaces == 2)
                {
                    pttc->ahffEntry[ulEntry + 1].hff    = hff;
                    pttc->ahffEntry[ulEntry + 1].iFace = 2; // start from 1.
                    pttc->ahffEntry[ulEntry + 1].ulOffsetTable = ulOffset;
                }

                ulEntry += PFF(hff)->ffca.ulNumFaces;
            }
            else
            {
                bCanBeLoaded = FALSE;
                break;
            }
        }

    // Is there a font that could be loaded ?

        if(bCanBeLoaded)
        {
            ASSERTDD(
                (ulTrueTypeResource * 2) >= ulEntry,
                "TTFD!ulTrueTypeResource * 2 < ulEntry\n"
                );

            pttc->ulTrueTypeResource = ulTrueTypeResource;
            pttc->ulNumEntry         = ulEntry;
            pttc->cRef               = 0;
            pttc->fl                 = 0;
            pttc->pga                = NULL;

            bRet = TRUE;
        }
        else
        {
            for (i = 0; i < ulEntry; i++)
            {
                if(pttc->ahffEntry[i].iFace == 1)
                    ttfdUnloadFontFile(pttc->ahffEntry[i].hff);
            }
            
            WARNING("TTFD!No TrueType resource in this TTC file\n");
            vFreeTTC(*phttc);
            *phttc = (HFF)NULL;
        }
    }
    else
    {
    // This is the case of the single TTF being loaded (NOT TTC)
    // Allocate TTC_FONTFILE structure

        cjttc =  offsetof(TTC_FONTFILE,ahffEntry) + sizeof(TTC_HFF_ENTRY) * 2; // *2 for Vertical face

        *phttc = (HFF)pttcAlloc(cjttc);

        pttc = (PTTC_FONTFILE)*phttc;

        if(pttc != (HFF)NULL)
        {
            pttc->ahffEntry[0].iFace = 1;
            pttc->ahffEntry[0].ulOffsetTable = 0;

            if (bCached)
            {
                pCache_TTF = (PTTF_CACHE) ((PBYTE) pCache_TTC + pCache_TTC->dpTTF[0]);
            }

            if(bLoadTTF(iFile,pvView,cjView,0,ulLangId,&pttc->ahffEntry[0].hff, pCache_TTF, ulFastCheckSum))
            {
                hff = pttc->ahffEntry[0].hff;

            // set pointer to TTC_FONTFILE in FONTFILE structure

                PFF(hff)->pttc = pttc;

            // fill hff array in TTC_FONTFILE struture

                pttc->ulTrueTypeResource = 1;
                pttc->ulNumEntry         = PFF(hff)->ffca.ulNumFaces;
                pttc->cRef               = 0;
                pttc->fl                 = 0;
                pttc->pga                = NULL;

            // fill up TTC_FONTFILE structure for each faces.

                ASSERTDD(
                    PFF(hff)->ffca.ulNumFaces <= 2,
                    "TTFD!ulNumFaces > 2\n"
                    );

                if (PFF(hff)->ffca.ulNumFaces == 2)
                {
                    pttc->ahffEntry[1].hff   = hff;
                    pttc->ahffEntry[1].iFace = 2;
                    pttc->ahffEntry[1].ulOffsetTable = 0;
                }

            // now, everything is o.k.

                bRet = TRUE;
            }
            else
            {
                vFreeTTC(*phttc);
                *phttc = (HFF)NULL;
            }
        }
        else
        {
            WARNING("TTFD!ttfdLoadFontFileTTC(): pttcAlloc failed\n");
        }
    }

    if(bRet)
    {
    // now that everything is ok we need to cache the IFIMETRICS info for this file.
    // we only do this if this is happening during boot and if the IFI's are not in the cache
    // already.

        if (!bCached)
        {
            if (PFF(pttc->ahffEntry[0].hff)->ffca.fl & FF_DBCS_CHARSET)
            {
                if (!bComputeGlyphAttrBits(pttc, PFF(pttc->ahffEntry[0].hff)))
                {
                    ttfdUnloadFontFileTTC (*phttc);
                    *phttc = (HFF) NULL;

                    return FALSE;
                }
            }
            
            if (ulFastCheckSum)
            {
                vFontFileCache(pttc, ulFastCheckSum, (ULONG) bTTCFormat);
            }
        }
        else
        {
            if (pCache_TTC->dpGlyphAttr)
            {
                PFD_GLYPHATTR   pga;
                BOOL            bOk = TRUE;

                pga = (PFD_GLYPHATTR)((PBYTE) pCache_TTC + pCache_TTC->dpGlyphAttr);

#ifndef TTFD_NO_TRY_EXCEPT
                try
                {
#endif
                    pttc->pga = PV_ALLOC(pga->cjThis);

                    if (pttc->pga)
                    {
                        RtlCopyMemory(pttc->pga, pga, pga->cjThis);
                    }
                    else
                    {
                        bOk = FALSE;
                    }
#ifndef TTFD_NO_TRY_EXCEPT
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    bOk = FALSE;
                }
#endif

                if (!bOk)
                {
                    ttfdUnloadFontFileTTC (*phttc);
                    *phttc = (HFF) NULL;
                    return FALSE;
                }
            }
        }

    // Free FD_GLYPHSET

        for (i = 0; i < pttc->ulNumEntry ; i++)
        {
            PFONTFILE pff = PFF(pttc->ahffEntry[i].hff);

            if (pttc->ahffEntry[i].iFace == 1)
            {
                if (pff->pgset)
                {
                    V_FREE(pff->pgset);
                    pff->pgset = NULL;
                }

                if (pff->pgsetv)
                {
                    V_FREE(pff->pgsetv);
                    pff->pgsetv = NULL;
                }
            }
        }   
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* VOID vGetVerticalGset(PFD_GLYPHSET pgsetv) 
*
* Make every vertical glyph index to right glyph in font
* 
* History:
*  9-2-1998 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

VOID vGetVerticalGSet(PFD_GLYPHSET pgsetRef, PFONTFILE pff)
{
    PWCRUN          pwcruns, pwcrunsEnd;
    PHGLYPH         phg;
    WCHAR           wcLow, wcHigh;

    ASSERTDD(pff->hgSearchVerticalGlyph, "vert font with zero hgSearchVerticalGlyph routine\n");

    pwcruns = &pff->pgsetv->awcrun[0];
    pwcrunsEnd = pwcruns + pff->pgsetv->cRuns;

    while (pwcruns < pwcrunsEnd)
    {
        wcLow = pwcruns->wcLow;
        wcHigh = pwcruns->wcLow + pwcruns->cGlyphs - 1;

        phg = (PHGLYPH) (((PBYTE) pwcruns->phg - (PBYTE) pgsetRef) + (PBYTE) pff->pgsetv);
        pwcruns->phg = phg;

        while (wcLow <= wcHigh)
        {
            *phg = (*pff->hgSearchVerticalGlyph)( pff, *phg);

            phg++;
            wcLow++;
        }

        pwcruns++;
    }
}

STATIC BOOL bLoadGlyphSet(
    PFONTFILE               pff,
    sfnt_mappingTable       *pmap,
    fs_GlyphInputType       *pgin,
    CMAPINFO                *pcmi,
    FD_GLYPHSET            **ppgset
)
{
    ULONG cGlyphs; 
    sfnt_maxProfileTable * pmaxp =
        (sfnt_maxProfileTable *)((BYTE*)pff->pvView + pff->ffca.tp.ateReq[IT_REQ_MAXP].dp);
    *ppgset = NULL;

    switch (pff->ffca.iGlyphSet)
    {
    case GSET_TYPE_GENERAL:
        #ifdef  DBG_GLYPHSET
            WARNING("GSET_TYPE_GENERAL\n");
        #endif

        *ppgset = (FD_GLYPHSET *) PV_ALLOC(cjGsetGeneral(pmap,pcmi));

        if (*ppgset)
        {
            if (!cjComputeGLYPHSET_MSFT_UNICODE( pmap, pgin, *ppgset, pcmi))
            {
                V_FREE(*ppgset );
                *ppgset = NULL;
            }
        }

        break;

    case GSET_TYPE_GENERAL_NOT_UNICODE:

        cGlyphs = BE_UINT16(&pmaxp->numGlyphs);
        cjComputeGLYPHSET_MSFT_GENERAL(
            pmap,
            cGlyphs,
            (ULONG **)ppgset, // == (FD_GLYPHSET **)
            pcmi
            );

        break;

    case GSET_TYPE_HIGH_BYTE:
        #ifdef  DBG_GLYPHSET
            WARNING("GSET_TYPE_HIGH_BYTE\n");
        #endif

    // Create GlyphSet

        cjComputeGLYPHSET_HIGH_BYTE(
            pmap,
            (ULONG **)ppgset, // == (FD_GLYPHSET **)
            pcmi
            );
        break;


    case GSET_TYPE_MAC_ROMAN:

        #ifdef  DBG_GLYPHSET
            WARNING("GSET_TYPE_MAC_ROMAN\n");
        #endif

        cjComputeGLYPHSET_TEMPLATE(pgin, ppgset, 0, GSET_TYPE_MAC_ROMAN);
        break;

    case GSET_TYPE_PSEUDO_WIN:

    // we are cheating, report windows code page even though it is
    // a mac font

        cjComputeGLYPHSET_TEMPLATE(pgin, ppgset, 0, GSET_TYPE_PSEUDO_WIN);

        break;

    case GSET_TYPE_SYMBOL:

    // we are cheating, report windows code page even though it is
    // a symbol font where symbols live somewhere high in unicode

        cjComputeGLYPHSET_TEMPLATE(pgin, ppgset, pff->ffca.wcBiasFirst, GSET_TYPE_SYMBOL);

        break;

    // case we have an old BiDi font

    case GSET_TYPE_OLDBIDI:
        cjComputeGLYPHSET_OLDBIDI(pgin, ppgset, pff->ffca.wcBiasFirst);
        break;

    default:
        RIP("TTFD!_ulGsetType\n");
        *ppgset = NULL;
        break;
    }

    return (*ppgset != NULL);
}

VOID vReleaseGlyphSet(PFONTFILE pff, ULONG iFace)
{
    if (iFace == 1)
    {
        ASSERTDD(pff->cRefGSet != 0, " vReleaseGlyphSet incorrect cRefGSet \n");

        pff->cRefGSet--;
        if (pff->cRefGSet == 0)
        {
            ASSERTDD(pff->pgset, " vReleaseGlyphSet incorrect pGset \n");
            V_FREE(pff->pgset);
            pff->pgset = NULL;
        }

    }
    else
    {
        ASSERTDD(pff->cRefGSetV, " vReleaseGlyphSet incorrect cRefGSetV \n");

        pff->cRefGSetV--;

        if (pff->cRefGSetV == 0)
        {
            ASSERTDD(pff->pgsetv, " vReleaseGlyphSet incorrect pGsetv \n");
            V_FREE(pff->pgsetv);
            pff->pgsetv = NULL;
        }

    }
}

BOOL bReloadGlyphSet(PFONTFILE pff, ULONG iFace)
{
    fs_GlyphInputType   *pgin;
    fs_GlyphInputType   gin;
    fs_GlyphInfoType    gout;
    sfnt_mappingTable   *pmap;
    CMAPINFO            cmi;
    FS_ENTRY            iRet;

    BOOL bRet;

    ASSERTDD(iFace == 1 || iFace == 2, "bReloadGlyphSet: iFace \n");

    if (iFace == 1)
    {
        if (pff->cRefGSet)
        {
            ASSERTDD(pff->pgset, "pff->pgset\n")
            pff->cRefGSet++;
            return TRUE;
        }
    }
    else
    {
        if (pff->cRefGSetV)
        {
            ASSERTDD(pff->pgsetv, "pff->pgset\n")
            pff->cRefGSetV++;
            return TRUE;
        }
    }

// at this point we know we will have to allocate either gset or gsetv
// let us see if the app is asking for gsetv and gset is already allocated.
// The next if statement is just a performance optimization, if we deleted this
// the code would work just fine.

    if ((iFace != 1) && pff->pgset)
    {
        if (pff->cRef == 0)
        {
        // have to remap the file.

            pff->pvView = pff->pttc->pvView;
            pff->cjView = pff->pttc->cjView;
        }

   // pff->pgsetv == NULL, otherwise we would have hit the early exit

        pff->pgsetv = PV_ALLOC(pff->pgset->cjThis);

        if (pff->pgsetv)
        {
            BOOL bTmp = FALSE;
            RtlCopyMemory((PVOID) pff->pgsetv, (PVOID) pff->pgset, pff->pgset->cjThis);
#ifndef TTFD_NO_TRY_EXCEPT
            try
            {
#endif
                vGetVerticalGSet(pff->pgset, pff);
                bTmp = TRUE;
#ifndef TTFD_NO_TRY_EXCEPT
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("TTFD!bReloadGlyphSet exception for vGetVerticalGSet\n");
            }
#endif

            if (bTmp)
            {
                pff->cRefGSetV = 1;
            }
            else
            {
                V_FREE(pff->pgsetv);
                pff->pgsetv = NULL;
            }
        }

        return (pff->pgsetv != NULL);
    }

    if (pff->cRef == 0)
    {
        BOOL bTmp = FALSE;

    // the size of this structure is sizeof(fs_SplineKey) + STAMPEXTRA.
    // It is because of STAMPEXTRA that we are not just putting the strucuture
    // on the stack such as fs_SplineKey sk; we do not want to overwrite the
    // stack at the bottom when putting a stamp in the STAMPEXTRA field.
    // [bodind]. The other way to obtain the correct alignment would be to use
    // union of fs_SplineKey and the array of bytes of length CJ_0.

        NATURAL             anat0[CJ_0 / sizeof(NATURAL)];

    // have to remap the file.

        pff->pvView = pff->pttc->pvView;
        pff->cjView = pff->pttc->cjView;

   /* we need to initialize a gin for the TrueType rasterizer */

        if ((iRet = fs_OpenFonts(&gin, &gout)) != NO_ERR)
        {
            V_FSERROR(iRet);
            return FALSE;
        }

        ASSERTDD(NATURAL_ALIGN(gout.memorySizes[0]) == CJ_0, "mem size 0\n");
        ASSERTDD(gout.memorySizes[1] == 0,  "mem size 1\n");

        gin.memoryBases[0] = (char *)anat0;
        gin.memoryBases[1] = NULL;
        gin.memoryBases[2] = NULL;

    // initialize the font scaler, notice no fields of gin are initialized [BodinD]

        if ((iRet = fs_Initialize(&gin, &gout)) != NO_ERR)
        {
            V_FSERROR(iRet);
            return FALSE;
        }

    // initialize info needed by NewSfnt function

        gin.sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of
                                                   // the ttf file
        gin.clientID = (ULONG_PTR)pff;  // pointer to the top of the view of the ttf file

        gin.GetSfntFragmentPtr = pvGetPointerCallback;
        gin.ReleaseSfntFrag  = vReleasePointerCallback;

        gin.param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
        gin.param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

#ifndef TTFD_NO_TRY_EXCEPT
        try
        {
#endif
            if ((iRet = fs_NewSfnt(&gin, &gout)) != NO_ERR)
            {
                V_FSERROR(iRet);
            }
            else
            {
                bTmp = TRUE;
            }
#ifndef TTFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!bReloadGlyphSet exception in fs_NewSfnt \n");
        }
#endif

        if (!bTmp)
            return FALSE;

        pgin = &gin;
    }
    else
    {
        pgin = (fs_GlyphInputType *)pff->pj034;
    }

    pmap = (sfnt_mappingTable  *) ((PBYTE) pff->pvView + pff->ffca.dpMappingTable);
    cmi = pff->ffca.cmi;

    bRet = FALSE;
#ifndef TTFD_NO_TRY_EXCEPT
    try
    {
#endif
        if (bLoadGlyphSet(pff, pmap, pgin, &cmi, (iFace == 1) ? &pff->pgset : &pff->pgsetv))
        {
            if (iFace != 1)
            {
                vGetVerticalGSet(pff->pgsetv, pff);
            }
            bRet = TRUE;
        }
#ifndef TTFD_NO_TRY_EXCEPT
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("TTFD!bReloadGlyphSet: exception in bLoadGlyphSet or in vGetVerticalGset \n");
    }
#endif


    if (bRet)
    {
        if (iFace != 1)
        {
            pff->cRefGSetV = 1;
        }
        else
        {
            pff->cRefGSet = 1;
        }
    }
    else // do clean up in case we allocated memory
    {
        if (iFace != 1)
        {
            if (pff->pgsetv)
            {
                V_FREE(pff->pgsetv);
                pff->pgsetv = NULL;
            }

        }
        else
        {
            if (pff->pgset)
            {
                V_FREE(pff->pgset);
                pff->pgset = NULL;
            }
        }
    }

    return bRet;
}


STATIC BOOL
bLoadTTF (
    ULONG_PTR iFile,
    PVOID     pvView,
    ULONG     cjView,
    ULONG     ulTableOffset,
    ULONG     ulLangId,
    HFF       *phff,
    PTTF_CACHE pCache,
    ULONG     ulFastCheckSum
    )
{
    PFONTFILE      pff;
    FS_ENTRY       iRet;
    TABLE_POINTERS tp;
    IFISIZE        ifisz;
    fs_GlyphInputType   gin;
    fs_GlyphInfoType    gout;

    sfnt_FontHeader * phead;
    sfnt_HorizontalHeader *phhea;

    uint16 ui16PlatID, ui16SpecID;
    sfnt_mappingTable *pmap;
    ULONG              ulGsetType;
    ULONG              cjff, dpwszTTF;
    ULONG              ul_wcBias;

// the size of this structure is sizeof(fs_SplineKey) + STAMPEXTRA.
// It is because of STAMPEXTRA that we are not just putting the strucuture
// on the stack such as fs_SplineKey sk; we do not want to overwrite the
// stack at the bottom when putting a stamp in the STAMPEXTRA field.
// [bodind]. The other way to obtain the correct alignment would be to use
// union of fs_SplineKey and the array of bytes of length CJ_0.

    NATURAL             anat0[CJ_0 / sizeof(NATURAL)];

    CMAPINFO           cmi;
    BOOL               bType1 = FALSE; // if Type1 conversion
    BOOL               ulShellFont = 0; // If it is not a shell font
    PBYTE pjOffsetTable = (BYTE*) pvView + ulTableOffset;
    PIFIMETRICS        pifiv = NULL; // ifimetrics for the vertical face
    PFD_GLYPHSET       pgsetv = NULL;
    
    ASSERTDD(sizeof(FONTFILE) == offsetof(FONTFILE,ifi) + sizeof(IFIMETRICS), "ttfd! IFIMETRICS is not the last field of FONTFILE\n");

    *phff = HFF_INVALID;

    if (pCache)
    {
        return bLoadTTF_Cache(iFile,
                             pvView,
                             cjView,
                             phff,
                             pCache,
                             ulFastCheckSum);
    }


    if
    (
        !bVerifyTTF(
            pvView,
            cjView,
            pjOffsetTable,
            ulLangId,
            &tp,
            &ifisz,
            &ui16PlatID,
            &ui16SpecID,
            &pmap,
            &ulGsetType,
            &ul_wcBias,
            &cmi,
            &bType1,
            &ulShellFont
            )
    )
    {
        return(FALSE);
    }

    cjff = offsetof(FONTFILE,ifi) + ifisz.cjIFI;

    if(ulShellFont)
    {
        USHORT AnsiCodePage, OemCodePage;

    // Microsoft Sans Serif is a new shell font for NT 5.0,
    // Here, we need to hack for 2 problems

    // This issue is language dependcy
    // Within Japanese and Korean code page, we need to replace 0x5c glyph

        EngGetCurrentCodePage(&OemCodePage, &AnsiCodePage);
        if (AnsiCodePage == 932 || AnsiCodePage == 949)
        {
            cmi.fl |= CMI_5C_SPLIT;
        }
    }

   

// at this point cjff is equal to the offset to the full path
// name of the ttf file

    dpwszTTF = cjff;


    if ((pff = pffAlloc(cjff)) == PFF(NULL))
    {
        RET_FALSE("TTFD!ttfdLoadFontFile(): memory allocation error\n");
    }

    *phff = (HFF)pff;

    /* we need to clean the beginning of pff to ensure correct cleanup in case of error/exception */

    RtlZeroMemory((PVOID)pff, offsetof(FONTFILE,ifi));

// init fields of pff structure
// store the ttf file name at the bottom of the strucutre

    phead = (sfnt_FontHeader *)((BYTE *)pvView + tp.ateReq[IT_REQ_HEAD].dp);

// remember which file this is

    pff->iFile = iFile;
    pff->pvView = pvView;
    pff->cjView = cjView;

    pff->ffca.ui16EmHt = BE_UINT16(&phead->unitsPerEm);
    if (pff->ffca.ui16EmHt < 16 || pff->ffca.ui16EmHt > 16384)
    {
        vFreeFF(*phff);
        *phff = (HFF)NULL;
        RET_FALSE("TTFD!bLoadTTF(): invalid unitsPerEm value\n");
    }
    pff->ffca.ui16PlatformID = ui16PlatID;
    pff->ffca.ui16SpecificID = ui16SpecID;

// few new fields for user's private api:

    phhea = (sfnt_HorizontalHeader *)((BYTE *)pvView + tp.ateReq[IT_REQ_HHEAD].dp);

    pff->ffca.usMinD = 0;          // flag that it has not been initialized
    pff->ffca.igMinD = USHRT_MAX; // flag that it has not been initialized
    pff->ffca.sMinA  = BE_INT16(&phhea->minLeftSideBearing);
    pff->ffca.sMinC  = BE_INT16(&phhea->minRightSideBearing);

// so far no exception

    pff->ffca.fl = bType1 ? FF_TYPE_1_CONVERSION : 0;

    if(ulShellFont & MICROSS_SHELLFONT)
    {
    // Microsoft Sans Serif is a new shell font for NT 5.0,
    // Here, we need to hack for 2 problems

    // It is a backward compatibility issue to make
    // Max Neg A, C will be 0 at 11 & 13 ppem

        pff->ffca.fl |= FF_NEW_SHELL_FONT;
    }

    pff->pfcToBeFreed = NULL;

// convert Language id to macintosh style if this is mac style file
// else leave it alone, store it in be format, ready to be compared
// with the values in the font files

    pff->ffca.ui16LanguageID = ui16BeLangId(ui16PlatID,ulLangId);
    pff->ffca.dpMappingTable = (ULONG)((BYTE*)pmap - (BYTE*)pvView);

// initialize count of HFC's associated with this HFF

    pff->cRef    = 0L;

// cache pointers to ttf tables and ifi metrics size info

    pff->ffca.tp    = tp;

// The kerning pair array is allocated and filled lazily.  So set to NULL
// for now.

    pff->pkp = (FD_KERNINGPAIR *) NULL;

// used for TTC fonts

    pff->ffca.ulTableOffset = ulTableOffset;

// Used for reload glyphset
    pff->ffca.cmi = cmi;

    pff->ffca.wcBiasFirst = ul_wcBias;

// Notice that this information is totaly independent
// of the font file in question, seems to be right according to fsglue.h
// and compfont code

    if ((iRet = fs_OpenFonts(&gin, &gout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        vFreeFF(*phff);
        *phff = (HFF)NULL;
        return (FALSE);
    }

    ASSERTDD(NATURAL_ALIGN(gout.memorySizes[0]) == CJ_0, "mem size 0\n");
    ASSERTDD(gout.memorySizes[1] == 0,  "mem size 1\n");


    #if DBG
    if (gout.memorySizes[2] != 0)
        TtfdDbgPrint("TTFD!_mem size 2 = 0x%lx \n", gout.memorySizes[2]);
    #endif

    gin.memoryBases[0] = (char *)anat0;
    gin.memoryBases[1] = NULL;
    gin.memoryBases[2] = NULL;

// initialize the font scaler, notice no fields of gin are initialized [BodinD]

    if ((iRet = fs_Initialize(&gin, &gout)) != NO_ERR)
    {
    // clean up and return:

        V_FSERROR(iRet);
        vFreeFF(*phff);
        *phff = (HFF)NULL;
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_Initialize \n");
    }

// initialize info needed by NewSfnt function

    gin.sfntDirectory  = (int32 *)pff->pvView; // pointer to the top of the view of
                                               // the ttf file

    gin.clientID = (ULONG_PTR)pff;  // pointer to the top of the view of the ttf file

    gin.GetSfntFragmentPtr = pvGetPointerCallback;
    gin.ReleaseSfntFrag  = vReleasePointerCallback;

    gin.param.newsfnt.platformID = BE_UINT16(&pff->ffca.ui16PlatformID);
    gin.param.newsfnt.specificID = BE_UINT16(&pff->ffca.ui16SpecificID);

    if ((iRet = fs_NewSfnt(&gin, &gout)) != NO_ERR)
    {
    // clean up and exit

        V_FSERROR(iRet);
        vFreeFF(*phff);
        *phff = (HFF)NULL;
        RET_FALSE("TTFD!_ttfdLoadFontFile(): fs_NewSfnt \n");
    }

    pff->pj034   = (PBYTE)NULL;
    pff->pfcLast = (FONTCONTEXT *)NULL;

    pff->ffca.cj3 = NATURAL_ALIGN(gout.memorySizes[3]);
    pff->ffca.cj4 = NATURAL_ALIGN(gout.memorySizes[4]);

// By default the number of faces is 1L.  The vert facename code may change this.

    pff->ffca.ulNumFaces = 1L;
    pff->pifi_vertical = NULL;
    pff->pgsetv = NULL;

// compute the gset or set a pointer to one of the precomputed gsets

    pff->ffca.iGlyphSet = ulGsetType;

// if we failed to create the glyphset bail out now

    if (!bLoadGlyphSet(pff, pmap, &gin, &cmi, &pff->pgset))
    {
        // clean up and exit

        vFreeFF(*phff);
        *phff = (HFF)NULL;
        RET_FALSE("ttfdLoadFontFile(): failed to create glyphset or invalid glyphset\n");
    }

// finally compute the ifimetrics for this font, this assumes that gset has
// also been computed

// if ifimetrics are stored in the boot cache, copy them out, else compute ifimetrics

    vFill_IFIMETRICS(pff,&pff->ifi,&ifisz, &gin);

    if ((pff->ffca.fl & FF_DBCS_CHARSET) && bCheckVerticalTable(pff))
    {

        ASSERTDD( pff->hgSearchVerticalGlyph != NULL ,
                  "pff->hgSearchVerticalGlyph == NULL for vertical font\n");

        pifiv = (PIFIMETRICS)PV_ALLOC( NATURAL_ALIGN(ifisz.cjIFI));
        pgsetv = (PFD_GLYPHSET)PV_ALLOC(pff->pgset->cjThis);

        if ( pifiv != NULL && pgsetv != NULL)
        {

            vCopy_IFIV(&pff->ifi, pifiv);

        // save a pointer to the vertical ifimetrics.
        // now we have two faces( normal, @face ) for the fontfile.

            pff->pifi_vertical = pifiv;
            pff->ffca.ulNumFaces = 2L;

        }
        else
        {
        // Something wrong in read cache file

            if (pifiv)
            {
                V_FREE(pifiv);
            }

        // Free pgset

            if (pff->pgset)
            {
                V_FREE(pff->pgset);
            }

            if (pgsetv)
            {
                V_FREE(pgsetv);
            }

        // Free FONTFILE * pff

            if (*phff)
            {
                vFreeFF(*phff);
                *phff = (HFF)NULL;
            }

            RET_FALSE("ttfdLoadFontFile(): failed to create pifiv\n");

        }
    }

    if (pifiv)
    {
    // now compute the vertical glyphset
        RtlCopyMemory((PVOID) pgsetv, (PVOID) pff->pgset, pff->pgset->cjThis);
        pff->pgsetv = pgsetv;
        vGetVerticalGSet(pff->pgset, pff);
    }

    pff->cRefGSet = 0;
    pff->cRefGSetV = 0;
    return (TRUE);
}

/******************************Public*Routine******************************\
*
* STATIC BOOL bCvtUnToMac
*
* the following piece of code is stolen from JeanP and
* he claims that this piece of code is lousy and checks whether
* we the font is a SYMBOL font in which case unicode to mac conversion
* should be disabled, according to JeanP (??? who understands this???)
* This piece of code actually applies to symbol.ttf [bodind]
*
*
* History:
*  24-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

STATIC BOOL
bCvtUnToMac(
    BYTE           *pjView,
    TABLE_POINTERS *ptp,
    uint16 ui16PlatformID
    )
{
// Find out if we have a Mac font and if the Mac charset translation is needed

    BOOL bUnToMac = (ui16PlatformID == BE_PLAT_ID_MAC);

    if (bUnToMac) // change your mind if needed
    {
        sfnt_PostScriptInfo *ppost;

        ppost =  (ptp->ateOpt[IT_OPT_POST].dp && bValidRangePOST(ptp->ateOpt[IT_OPT_POST].cj) ) ?
               (sfnt_PostScriptInfo *)(pjView + ptp->ateOpt[IT_OPT_POST].dp):
                NULL;

        if
        (
            ppost &&
            (BE_UINT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_VERSION) == 0x00020000)
        )
        {
            INT i;
            UINT16 cGlyphs;

            if( !bValidRangePOSTFormat2(ppost, ptp->ateOpt[IT_OPT_POST].cj,&cGlyphs)) 
                return bUnToMac;

            for (i = 0; i < cGlyphs; i++)
            {
                uint16 iNameIndex = ppost->postScriptNameIndices.glyphNameIndex[i];
                if ((int8)(iNameIndex & 0xff) && ((int8)(iNameIndex >> 8) > 1))
                    break;
            }

            if (i < cGlyphs)
                bUnToMac = FALSE;
        }
    }
    return bUnToMac;
}


// Weight (must convert from IFIMETRICS weight to Windows LOGFONT.lfWeight).

// !!! [Windows 3.1 compatibility]
//     Because of some fonts shipped with WinWord, if usWeightClass is 10
//     or above, then usWeightClass == lfWeight.  All other cases, use
//     the conversion table.

// pan wt -> Win weight converter:

STATIC const USHORT ausIFIMetrics2WinWeight[10] = {
            0, 100, 200, 300, 350, 400, 600, 700, 800, 900
            };

STATIC const BYTE
ajPanoseFamily[16] = {
     FF_DONTCARE       //    0 (Any)
    ,FF_DONTCARE       //    1 (No Fit)
    ,FF_ROMAN          //    2 (Cove)
    ,FF_ROMAN          //    3 (Obtuse Cove)
    ,FF_ROMAN          //    4 (Square Cove)
    ,FF_ROMAN          //    5 (Obtuse Square Cove)
    ,FF_ROMAN          //    6 (Square)
    ,FF_ROMAN          //    7 (Thin)
    ,FF_ROMAN          //    8 (Bone)
    ,FF_ROMAN          //    9 (Exaggerated)
    ,FF_ROMAN          //   10 (Triangle)
    ,FF_SWISS          //   11 (Normal Sans)
    ,FF_SWISS          //   12 (Obtuse Sans)
    ,FF_SWISS          //   13 (Perp Sans)
    ,FF_SWISS          //   14 (Flared)
    ,FF_SWISS          //   15 (Rounded)
    };


static const BYTE
ajPanoseFamilyForJapanese[16] = {
     FF_DONTCARE       //    0 (Any)
    ,FF_DONTCARE       //    1 (No Fit)
    ,FF_ROMAN          //    2 (Cove)
    ,FF_ROMAN          //    3 (Obtuse Cove)
    ,FF_ROMAN          //    4 (Square Cove)
    ,FF_ROMAN          //    5 (Obtuse Square Cove)
    ,FF_ROMAN          //    6 (Square)
    ,FF_ROMAN          //    7 (Thin)
    ,FF_ROMAN          //    8 (Bone)
    ,FF_ROMAN          //    9 (Exaggerated)
    ,FF_ROMAN          //   10 (Triangle)
    ,FF_MODERN         //   11 (Normal Sans)
    ,FF_MODERN         //   12 (Obtuse Sans)
    ,FF_MODERN         //   13 (Perp Sans)
    ,FF_MODERN         //   14 (Flared)
    ,FF_MODERN         //   15 (Rounded)
    };


/******************************Public*Routine******************************\
*
* vFill_IFIMETRICS
*
* Effects: Looks into the font file and fills IFIMETRICS
*
* History:
*  Mon 09-Mar-1992 10:51:56 by Kirk Olynyk [kirko]
* Added Kerning Pair support.
*  18-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC VOID
vFill_IFIMETRICS(
    PFONTFILE       pff,
    PIFIMETRICS     pifi,
    PIFISIZE        pifisz,
    fs_GlyphInputType     *pgin
    )
{
    BYTE           *pjView = (BYTE*)pff->pvView;
    PTABLE_POINTERS ptp = &pff->ffca.tp;
    BYTE            jWinCharset;
    IFIEXTRA       *pifiex;

// ptrs to various tables of tt files

    sfnt_FontHeader *phead =
        (sfnt_FontHeader *)(pjView + ptp->ateReq[IT_REQ_HEAD].dp);

    sfnt_maxProfileTable * pmaxp =
        (sfnt_maxProfileTable *)(pjView + ptp->ateReq[IT_REQ_MAXP].dp);

    sfnt_HorizontalHeader *phhea =
        (sfnt_HorizontalHeader *)(pjView + ptp->ateReq[IT_REQ_HHEAD].dp);

    sfnt_PostScriptInfo   *ppost = (sfnt_PostScriptInfo *) (
                           (ptp->ateOpt[IT_OPT_POST].dp && bValidRangePOST(ptp->ateOpt[IT_OPT_POST].cj) ) ?
                           pjView + ptp->ateOpt[IT_OPT_POST].dp :
                           NULL
                           );

    PBYTE  pjOS2 = (ptp->ateOpt[IT_OPT_OS2].dp)        ?
                   pjView + ptp->ateOpt[IT_OPT_OS2].dp :
                   NULL                                ;

    pifi->cjThis    = pifisz->cjIFI;
    pifi->cjIfiExtra =
                    offsetof(IFIEXTRA, dpDesignVector);

// lay pifiextra below ifimetrics
    pifiex = (IFIEXTRA *)(pifi + 1);
    pifiex->ulIdentifier = 0;

// enter the number of distinct font indicies

    pifiex->cig = BE_UINT16(&pmaxp->numGlyphs);

// get name strings info
    {
#if DBG 
        BOOL ok =
#endif
        bConvertExtras(pifi, pifisz, pff->ffca.ui16LanguageID);
        ASSERTDD(ok, "bConvertExtras returned FALSE on second pass\n");

        pifi->dpwszFamilyName = pifisz->dpFamilyName;
        pifi->dpwszUniqueName = pifisz->dpUniqueName;
        pifi->dpwszFaceName   = pifisz->dpFullName;
        pifi->dpwszStyleName  = pifisz->dpSubfamilyName;
    }

//
// flInfo
//
    pifi->flInfo = (
                     FM_INFO_TECH_TRUETYPE    |
                     FM_INFO_ARB_XFORMS       |
                     FM_INFO_RETURNS_OUTLINES |
                     FM_INFO_RETURNS_BITMAPS  |
                     FM_INFO_1BPP             | // monochrome
                     FM_INFO_4BPP             | // anti-aliased too
                     FM_INFO_RIGHT_HANDED
                   );
    {
        ULONG cjDSIG;

        if (pff->ffca.ulTableOffset == 0)
        {
            if (pjTable('GISD', pff, &cjDSIG) && cjDSIG)
            {
                pifi->flInfo |= FM_INFO_DSIG;
            }
        }
        else
        {
            ULONG     ulValue;
            ULONG     ulOffset;

            // Get Directory count.

            ulValue = GetUlong(pff->pvView,OFF_TTC_DirectoryCount);

            ulOffset = OFF_TTC_DirectoryEntry + (sizeof(ULONG) * ulValue);

            // Read the DSIG_LONG_TAG

            ulValue = GetUlong(pff->pvView,ulOffset);

            if (ulValue == DSIG_LONG_TAG)
            {
                pifi->flInfo |= FM_INFO_DSIG;
            }
        }
    }

    if (pifisz->pjFamilyNameAlias )
    {
        pifi->flInfo |= FM_INFO_FAMILY_EQUIV;
    }

    if (ppost && BE_UINT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_ISFIXEDPITCH))
    {
        ULONG  cHMTX;
        int16  aw,xMin,xMax;
        sfnt_HorizontalMetrics *phmtx;

        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;

    // CHECK IF THE FONT HAS NONNEGATIVE A AND C SPACES

        xMin = (int16) BE_UINT16(&phead->xMin);
        xMax = (int16) BE_UINT16(&phead->xMax);

        phmtx = (sfnt_HorizontalMetrics *)(pjView + ptp->ateReq[IT_REQ_HMTX ].dp);
        cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);
        aw = (int16)BE_UINT16(&phmtx[cHMTX-1].advanceWidth);

        if ((xMin >= 0) && (xMax <= aw))
        {

        //    TtfdDbgPrint("%ws\n:",(PBYTE)pifi + pifi->dpwszUniqueName);
        //    TtfdDbgPrint("xMin = %d, xMax = %d, aw = %d\n", xMin, xMax, aw);

            pifi->flInfo |= FM_INFO_NONNEGATIVE_AC;
        }
    }

    pifi->dpCharSets = 0; // for now

    pifi->lEmbedId = 0; // not used, stored in pff.

// fsSelection

    pifi->fsSelection = fsSelectionTTFD(pjView, ptp);

// some of the old windows fonts contain the char set in the upper byte of
// the fsSelection field of the os2 table.

    jWinCharset = (BYTE)(pifi->fsSelection >> 8);

// fsType

    pifi->fsType = (pjOS2) ? (BE_UINT16(pjOS2 + OFF_OS2_fsType)) & TT_FSDEF_MASK : 0;

// em height

    pifi->fwdUnitsPerEm = (FWORD) BE_INT16(&phead->unitsPerEm);
    pifi->fwdLowestPPEm = BE_UINT16(&phead->lowestRecPPEM);

// ascender, descender, linegap

    pifi->fwdMacAscender    = (FWORD) BE_INT16(&phhea->yAscender);
    pifi->fwdMacDescender   = (FWORD) BE_INT16(&phhea->yDescender);
    pifi->fwdMacLineGap     = (FWORD) BE_INT16(&phhea->yLineGap);

    if (pjOS2)
    {
        pifi->fwdWinAscender    = (FWORD) BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        pifi->fwdWinDescender   = (FWORD) BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
        pifi->fwdTypoAscender   = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoAscender);
        pifi->fwdTypoDescender  = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoDescender);
        pifi->fwdTypoLineGap    = (FWORD) BE_INT16(pjOS2 + OFF_OS2_sTypoLineGap);
    }
    else
    {
        pifi->fwdWinAscender    = pifi->fwdMacAscender;
        pifi->fwdWinDescender   = -(pifi->fwdMacDescender);
        pifi->fwdTypoAscender   = pifi->fwdMacAscender;
        pifi->fwdTypoDescender  = pifi->fwdMacDescender;
        pifi->fwdTypoLineGap    = pifi->fwdMacLineGap;
    }

// font box

    pifi->rclFontBox.left   = (LONG)((FWORD)BE_INT16(&phead->xMin));
    pifi->rclFontBox.top    = (LONG)((FWORD)BE_INT16(&phead->yMax));
    pifi->rclFontBox.right  = (LONG)((FWORD)BE_INT16(&phead->xMax));
    pifi->rclFontBox.bottom = (LONG)((FWORD)BE_INT16(&phead->yMin));

// fwdMaxCharInc -- really the maximum character width
//
// [Windows 3.1 compatibility]
// Note: Win3.1 calculates max char width to be equal to the width of the
// bounding box (Font Box).  This is actually wrong since the bounding box
// may pick up its left and right max extents from different glyphs,
// resulting in a bounding box that is wider than any single glyph.  But
// this is the way Windows 3.1 does it, so that's the way we'll do it.

    // pifi->fwdMaxCharInc = (FWORD) BE_INT16(&phhea->advanceWidthMax);

    pifi->fwdMaxCharInc = (FWORD) (pifi->rclFontBox.right - pifi->rclFontBox.left);

// fwdAveCharWidth

    if (pjOS2)
    {
        pifi->fwdAveCharWidth = (FWORD)BE_INT16(pjOS2 + OFF_OS2_xAvgCharWidth);

    // This is here for Win 3.1 compatibility since some apps expect non-
    // zero widths and Win 3.1 does the same in this case.

        if( pifi->fwdAveCharWidth == 0 )
            pifi->fwdAveCharWidth = (FWORD)(pifi->fwdMaxCharInc / 2);
    }
    else
    {
        pifi->fwdAveCharWidth = (FWORD)((pifi->fwdMaxCharInc * 2) / 3);
    }

// !!! New code needed [kirko]
// The following is done for Win 3.1 compatibility
// reasons. The correct thing to do would be to look for the
// existence of the 'PCLT'Z table and retieve the XHeight and CapHeight
// fields, otherwise use the default Win 3.1 behavior.

    pifi->fwdCapHeight   = pifi->fwdUnitsPerEm/2;
    pifi->fwdXHeight     = pifi->fwdUnitsPerEm/4;

// Underscore, Subscript, Superscript, Strikeout

    if (ppost)
    {
        pifi->fwdUnderscoreSize     = (FWORD)BE_INT16(&ppost->underlineThickness);
        pifi->fwdUnderscorePosition = (FWORD)BE_INT16(&ppost->underlinePosition);
    }
    else
    {
    // must provide reasonable defaults, when there is no ppost table,
    // win 31 sets these quantities to zero. This does not sound reasonable.
    // I will supply the (relative) values the same as for arial font. [bodind]

        pifi->fwdUnderscoreSize     = (pifi->fwdUnitsPerEm + 7)/14;
        pifi->fwdUnderscorePosition = -((pifi->fwdUnitsPerEm + 5)/10);
    }

    if (pjOS2)
    {
        pifi->fwdSubscriptXSize     = BE_INT16(pjOS2 + OFF_OS2_ySubscriptXSize    );
        pifi->fwdSubscriptYSize     = BE_INT16(pjOS2 + OFF_OS2_ySubscriptYSize    );
        pifi->fwdSubscriptXOffset   = BE_INT16(pjOS2 + OFF_OS2_ySubscriptXOffset  );
        pifi->fwdSubscriptYOffset   = BE_INT16(pjOS2 + OFF_OS2_ySubscriptYOffset  );
        pifi->fwdSuperscriptXSize   = BE_INT16(pjOS2 + OFF_OS2_ySuperScriptXSize  );
        pifi->fwdSuperscriptYSize   = BE_INT16(pjOS2 + OFF_OS2_ySuperScriptYSize  );
        pifi->fwdSuperscriptXOffset = BE_INT16(pjOS2 + OFF_OS2_ySuperScriptXOffset);
        pifi->fwdSuperscriptYOffset = BE_INT16(pjOS2 + OFF_OS2_ySuperScriptYOffset);
        pifi->fwdStrikeoutSize      = BE_INT16(pjOS2 + OFF_OS2_yStrikeOutSize    );
        pifi->fwdStrikeoutPosition  = BE_INT16(pjOS2 + OFF_OS2_yStrikeOutPosition);
    }
    else
    {
        pifi->fwdSubscriptXSize     = 0;
        pifi->fwdSubscriptYSize     = 0;
        pifi->fwdSubscriptXOffset   = 0;
        pifi->fwdSubscriptYOffset   = 0;
        pifi->fwdSuperscriptXSize   = 0;
        pifi->fwdSuperscriptYSize   = 0;
        pifi->fwdSuperscriptXOffset = 0;
        pifi->fwdSuperscriptYOffset = 0;
        pifi->fwdStrikeoutSize      = pifi->fwdUnderscoreSize;
        pifi->fwdStrikeoutPosition  = (FWORD)(pifi->fwdMacAscender / 3) ;
    }


//
// panose
//
    pifi->ulPanoseCulture = FM_PANOSE_CULTURE_LATIN;
    if (pjOS2)
    {
        pifi->usWinWeight = BE_INT16(pjOS2 + OFF_OS2_usWeightClass);

    // now comes a hack from win31. Here is the comment from fonteng2.asm:

    // MAXPMWEIGHT equ ($ - pPM2WinWeight)/2 - 1

    //; Because winword shipped early TT fonts, - only index usWeightClass
    //; if between 0 and 9.  If above 9 then treat as a normal Windows lfWeight.
    //
    //        cmp     bx,MAXPMWEIGHT
    //        ja      @f                      ;jmp if weight is ok as is
    //        shl     bx, 1                   ;make it an offset into table of WORDs
    //        mov     bx, cs:[bx].pPM2WinWeight
    //@@:     xchg    ax, bx
    //        stosw                           ;store font weight

    // we emulate this in NT:

#define MAXPMWEIGHT ( sizeof(ausIFIMetrics2WinWeight) / sizeof(ausIFIMetrics2WinWeight[0]) )

        if (pifi->usWinWeight < MAXPMWEIGHT)
            pifi->usWinWeight = ausIFIMetrics2WinWeight[pifi->usWinWeight];

        RtlCopyMemory((PVOID)&pifi->panose,
                      (PVOID)(pjOS2 + OFF_OS2_Panose), sizeof(PANOSE));
    }
    else  // os2 table is not present
    {
        pifi->panose.bFamilyType       = PAN_FAMILY_TEXT_DISPLAY;
        pifi->panose.bSerifStyle       = PAN_ANY;
        pifi->panose.bWeight           = (BYTE)
           ((phead->macStyle & BE_MSTYLE_BOLD) ?
            PAN_WEIGHT_BOLD                    :
            PAN_WEIGHT_BOOK
           );
        pifi->panose.bProportion       = (BYTE)
            ((pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH) ?
             PAN_PROP_MONOSPACED                     :
             PAN_ANY
            );
        pifi->panose.bContrast         = PAN_ANY;
        pifi->panose.bStrokeVariation  = PAN_ANY;
        pifi->panose.bArmStyle         = PAN_ANY;
        pifi->panose.bLetterform       = PAN_ANY;
        pifi->panose.bMidline          = PAN_ANY;
        pifi->panose.bXHeight          = PAN_ANY;

    // have to fake it up, cause we can not read it from the os2 table
    // really important to go through this table for compatibility reasons [bodind]

        pifi->usWinWeight =
            ausIFIMetrics2WinWeight[pifi->panose.bWeight];
    }


// first, last, break, defalut

#define LAST_CHAR  255
#define SPACE_CHAR  32

    // Assume character bias is zero.

    pifi->lCharBias = 0;

    if (!(pff->ffca.fl & FF_TYPE_1_CONVERSION))
    {
        if (pjOS2 && *((uint16 UNALIGNED *)(pjOS2+SFNT_OS2_VERSION)) &&
            (DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1) &&
            !IsBogusSignature((DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1),pff))
        {
            DWORD  fontSig;

            fontSig = (DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1);

            // We only supports ANSI/SHIFTJIS/BIG5/WANSANG/GB2312 charset for
            // FarEast version.
            //
            // [NOTE:]
            //
            // We will have TRUE world wide support in NT 4.0 with TranslateCharsetInfo()

            if( fontSig & ( FS_JISJAPAN | FS_CHINESETRAD | FS_CHINESESIMP |  FS_WANSUNG))
            {
                if(fontSig & gfsCurSignature)
                {
                    USHORT AnsiCodePage, OemCodePage;
                    EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

                    pifi->jWinCharSet = gjCurCharset;
                    pff->ffca.uiFontCodePage = AnsiCodePage;
                }
                else
                {
                // Here we try to make the code compatible with NT 4.0

                    if(fontSig & FS_LATIN1)
                    {
                        pifi->jWinCharSet = ANSI_CHARSET;
                        pff->ffca.uiFontCodePage = 1252;
                    }
                    else if (fontSig & FS_JISJAPAN)
                    {
                        pifi->jWinCharSet   = SHIFTJIS_CHARSET;
                        pff->ffca.uiFontCodePage = 932;
                    }
                    else if (fontSig & FS_CHINESETRAD)
                    {
                        pifi->jWinCharSet   = CHINESEBIG5_CHARSET;
                        pff->ffca.uiFontCodePage = 950;
                    }
                    else if (fontSig & FS_CHINESESIMP)
                    {
                       pifi->jWinCharSet   = GB2312_CHARSET;
                        pff->ffca.uiFontCodePage = 936;
                    }
                    else if (fontSig & FS_WANSUNG)
                    {
                        pifi->jWinCharSet   = HANGEUL_CHARSET;
                        pff->ffca.uiFontCodePage = 949;
                    }
                }
            }
            else
            {
                pifi->jWinCharSet = jWinCharset;

            // Added this next line of garbage for Win 3.1 compatability sake.
            // The WatchTower Library depends on for the charset to be set properly
            // on a set of fonts that comes with it.  [gerritv] 3-6-95

                if (!jWinCharset && (pifi->panose.bFamilyType==PAN_FAMILY_PICTORIAL) && (pff->ffca.iGlyphSet == GSET_TYPE_SYMBOL))
                   pifi->jWinCharSet = SYMBOL_CHARSET;

                pff->ffca.uiFontCodePage = 1252;
            }
        }
        else
        {
        // Determine character set.
            if (pff->ffca.iGlyphSet == GSET_TYPE_HIGH_BYTE)
            {
                switch (pff->ffca.ui16SpecificID)
                {
                case BE_SPEC_ID_SHIFTJIS:
                    pifi->jWinCharSet   = SHIFTJIS_CHARSET;
                    pff->ffca.uiFontCodePage = 932;
                   break;

                case BE_SPEC_ID_GB:
                    pifi->jWinCharSet   = GB2312_CHARSET;
                    pff->ffca.uiFontCodePage = 936;
                    break;

                case BE_SPEC_ID_BIG5:
                    pifi->jWinCharSet   = CHINESEBIG5_CHARSET;
                    pff->ffca.uiFontCodePage = 950;
                    break;

                case BE_SPEC_ID_WANSUNG:
                    pifi->jWinCharSet   = HANGEUL_CHARSET;
                    pff->ffca.uiFontCodePage = 949;
                    break;

                default: // default to the old code
                    ASSERTDD(FALSE, "illegal high byte charset");
                    pifi->jWinCharSet   = ANSI_CHARSET;
                    pff->ffca.uiFontCodePage = 1252;
                    break;
                }
            }
            else if(bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_A , pff->pgset ) &&
               bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_I , pff->pgset ) &&
               bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_U , pff->pgset ) &&
               bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_E , pff->pgset ) &&
               bContainGlyphSet( U_HALFWIDTH_KATAKANA_LETTER_O , pff->pgset )
               )
            {
                pifi->jWinCharSet   = SHIFTJIS_CHARSET;
                pff->ffca.uiFontCodePage = 932;

            }
            else if( bContainGlyphSet( U_FULLWIDTH_HAN_IDEOGRAPHIC_61D4 , pff->pgset ) &&
                    bContainGlyphSet( U_FULLWIDTH_HAN_IDEOGRAPHIC_9EE2 , pff->pgset )
                    )
            {
                pifi->jWinCharSet   = GB2312_CHARSET;
                pff->ffca.uiFontCodePage = 936;
            }
            else if( bContainGlyphSet( U_FULLWIDTH_HAN_IDEOGRAPHIC_9F98 , pff->pgset ) &&
                    bContainGlyphSet( U_FULLWIDTH_HAN_IDEOGRAPHIC_9F79 , pff->pgset )
                    )
            {
                pifi->jWinCharSet   = CHINESEBIG5_CHARSET;
                pff->ffca.uiFontCodePage = 950;
            }
            else if( bContainGlyphSet( U_FULLWIDTH_HANGUL_LETTER_GA  , pff->pgset ) &&
                    bContainGlyphSet( U_FULLWIDTH_HANGUL_LETTER_HA , pff->pgset )
                    )
            {
                pifi->jWinCharSet   = HANGEUL_CHARSET;
                pff->ffca.uiFontCodePage = 949;
            }
            else if(bContainGlyphSet( U_PRIVATE_USER_AREA_E000 , pff->pgset ) &&
                    IsCurrentCodePageDBCS())
            {
                USHORT AnsiCodePage, OemCodePage;
                EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

                // !!! I claim that what we really want to do is
                // return the proper DBCS charset (based on the current code page)
                // if there are characters in the EUDC range.  If the current
                // code page is not a DBCS code page then we shouldn't be here
                // and should fall through to the old behavior.  Hence I've added
                // a check above making sure the current code page is a DBCS
                // code page  in order to get here.  The old code didn't have
                // this check and had the following functionality instead of
                // my switch statement.
                // GreTranslateCharSetInfo from the engine I will implement that
                // functionality here [gerritv]
                //
                //if( GreTranslateCharsetInfo((DWORD *)GetACP(),&csi,TCI_SRCCODEPAGE) )
                //    pifi->jWinCharSet = csi.ciCharset;
                //else
                //    pifi->jWinCharSet = ANSI_CHARSET;

                switch(AnsiCodePage)
                {
                  case 932:
                    pifi->jWinCharSet = SHIFTJIS_CHARSET;
                    break;
                  case 949:
                    pifi->jWinCharSet = HANGEUL_CHARSET;
                    break;
                  case 1361:
                    pifi->jWinCharSet = JOHAB_CHARSET;
                    break;
                  case 936:
                    pifi->jWinCharSet = GB2312_CHARSET;
                    break;
                  case 950:
                    pifi->jWinCharSet = CHINESEBIG5_CHARSET;
                    break;
                  default:
                    ASSERTDD(FALSE, "shouldn't be here if non DBCS code page\n");
                }

                pff->ffca.uiFontCodePage = AnsiCodePage;
            }
            else
            {
                pifi->jWinCharSet = jWinCharset;

            // Added this next line of garbage for Win 3.1 compatability sake.
            // The WatchTower Library depends on for the charset to be set properly
            // on a set of fonts that comes with it.  [gerritv] 3-6-95

                if (!jWinCharset && (pifi->panose.bFamilyType==PAN_FAMILY_PICTORIAL) &&  (pff->ffca.iGlyphSet == GSET_TYPE_SYMBOL))
                    pifi->jWinCharSet = SYMBOL_CHARSET;
                pff->ffca.uiFontCodePage = 1252;
            }
        }

        if (pff->ffca.ui16PlatformID == BE_PLAT_ID_MS && (pjOS2))
        {
        // win 31 compatibility behavior, ask kirko about the origin

            USHORT usF, usL;

            usF = BE_UINT16(pjOS2 + OFF_OS2_usFirstChar);
            usL = BE_UINT16(pjOS2 + OFF_OS2_usLastChar);

            if (usL > LAST_CHAR)
            {
                if (usF > LAST_CHAR)
                {
                    pifi->lCharBias = (LONG) (usF - (USHORT) SPACE_CHAR);

                    pifi->jWinCharSet = SYMBOL_CHARSET;
                    pifi->chFirstChar = SPACE_CHAR;
                    pifi->chLastChar  = (BYTE)min(LAST_CHAR, usL - usF + SPACE_CHAR);
                }
                else
                {
                    pifi->chFirstChar = (BYTE) usF;
                    pifi->chLastChar = LAST_CHAR;
                }
            }
            else
            {
                pifi->chFirstChar = (BYTE) usF;
                pifi->chLastChar  = (BYTE) usL;
            }
        //
        // if chFirstChar is less-than 2.. we do not substract...
        //
            if( pifi->chFirstChar >= 2 )
                pifi->chFirstChar   -= 2;


            //
            //  In SHIFTJIS TrueType font, We use 0xa5 ( U+ff65 ) character
            // as a SBCS default character accoring to Microsoft Standard
            // character set specification ( SHIFTJIS version )
            //  font file's default char ( 0x1f ) is a DBCS(Full Width)
            // defalt character.
            // in NT, we won't use DBCS default character
            //

            if( pifi->jWinCharSet == SHIFTJIS_CHARSET )
            {
                pifi->chDefaultChar = 0xa5;
                pifi->chBreakChar   = pifi->chFirstChar + 2;
            }
            else if ( pifi->jWinCharSet == CHINESEBIG5_CHARSET ||
                     pifi->jWinCharSet == GB2312_CHARSET         )
            {

                pifi->chDefaultChar = 0x20; // Space
                pifi->chBreakChar   = pifi->chFirstChar + 2;
            }
            else if ( pifi->jWinCharSet == HANGEUL_CHARSET )
            {
                    pifi->chDefaultChar = 0x7f;
                    pifi->chBreakChar   = 0x1f;
            }
            else
            {
                pifi->chDefaultChar = pifi->chFirstChar + 1;
                pifi->chBreakChar   = pifi->chDefaultChar + 1;
            }

            //!!! little bit dangerous, what if 32 and 31 do not exhist in the font?
            //!!! we must not lie to the engine, these two have to exhist in
            //!!! some of the runs reported to the engine [bodind]

            // Pls refer above comment

            if( pifi->jWinCharSet == SHIFTJIS_CHARSET )
            {
                pifi->wcDefaultChar = (WCHAR) 0xff65;
                pifi->wcBreakChar   = (WCHAR) pifi->chBreakChar;
            }
            else if( IS_ANY_DBCS_CHARSET(pifi->jWinCharSet) )
            {
                pifi->wcDefaultChar = (WCHAR) 0x25a1;
                pifi->wcBreakChar   = (WCHAR) pifi->chBreakChar;
            }
            else
            {
                pifi->wcDefaultChar = (WCHAR) pifi->chDefaultChar;
                pifi->wcBreakChar   = (WCHAR) pifi->chBreakChar  ;
            }
        }
        else
        {
        // win 31 compatibility behavior

            pifi->chFirstChar   = SPACE_CHAR - 2;
            pifi->chLastChar    = LAST_CHAR;

            //
            //  In SHIFTJIS TrueType font, We use 0xa5 ( U+ff65 ) character
            // as a SBCS default character according to Microsoft Standard
            // character set specification ( SHIFTJIS version )
            //  font file's default char ( 0x1f ) is a DBCS defalt character.
            // in NT, we won't use DBCS default character.
            //

            if( pifi->jWinCharSet == SHIFTJIS_CHARSET )
            {
                pifi->chDefaultChar = 0xa5;
                pifi->chBreakChar   = SPACE_CHAR;
            }
            else if (pifi->jWinCharSet == CHINESEBIG5_CHARSET ||
                     pifi->jWinCharSet == GB2312_CHARSET         )
            {
                pifi->chDefaultChar = 0x20; // Space
                pifi->chBreakChar   = SPACE_CHAR;
            }
            else
            {
                pifi->chBreakChar   = SPACE_CHAR;
                pifi->chDefaultChar = SPACE_CHAR - 1;
            }

            //!!! little bit dangerous, what if 32 and 31 do not exhist in the font?
            //!!! we must not lie to the engine, these two have to exhist in
            //!!! some of the runs reported to the engine [bodind]

            if( pifi->jWinCharSet == SHIFTJIS_CHARSET )
            {
                pifi->wcBreakChar   = SPACE_CHAR;
                pifi->wcDefaultChar = (WCHAR) 0xff65;
            }
            else if( pifi->jWinCharSet == CHINESEBIG5_CHARSET ||
                     pifi->jWinCharSet == GB2312_CHARSET         )
            {
                pifi->wcBreakChar   = SPACE_CHAR;
                pifi->wcDefaultChar = (WCHAR) 0x25a1;
            }
            else
            {
                pifi->wcBreakChar   = SPACE_CHAR;
                pifi->wcDefaultChar = SPACE_CHAR - 1;
            }
        }
    }
    else // t1 conversion, have to be compatible with ps driver:
    {
        pifi->chFirstChar   = ((BYTE *)phhea)[SFNT_HORIZONTALHEADER_RESERVED0];
        pifi->chLastChar    = ((BYTE *)phhea)[SFNT_HORIZONTALHEADER_RESERVED1];
        pifi->chDefaultChar = 149;
        pifi->chBreakChar   = ((BYTE *)phhea)[SFNT_HORIZONTALHEADER_RESERVED3] + pifi->chFirstChar;

    // charset has the highest weight. This will ensure that the charset of the
    // tt font is the same as charset of the original type 1 font, ensuring the
    // correct mapping. That is we will always get the tt conversion for the
    // screen and the corresponding t1 original on the printer.
    // The CharSet value got stored to hhead straight from .pfm file

        pifi->jWinCharSet = ((BYTE *)phhea)[SFNT_HORIZONTALHEADER_RESERVED4];

    // this is win31 hack. to understand look at pslib\pfmtontm.c

        #define NO_TRANSLATE_CHARSET 200 /* djm 12/20/87 */ // WIN31 HACK

        if (pifi->jWinCharSet == NO_TRANSLATE_CHARSET)
             pifi->jWinCharSet = ANSI_CHARSET;

    // adobe has handed out zapfdingbats with ansi charset in the pfm file.
    // ps resident version of zapfdingbats has charset = symbol.
    // For this reason only we override the value we have just written with
    // symbol charset. (In wow16 they force charset for zapfdingbats to SYMBOL)

        if
        (
         (!_wcsicmp((PWSTR)((BYTE*)pifi + pifi->dpwszFamilyName),L"ZapfDingbats") ||
          !_wcsicmp((PWSTR)((BYTE*)pifi + pifi->dpwszFamilyName),L"Symbol"))
         && (pifi->jWinCharSet == ANSI_CHARSET)
        )
        {
            pifi->jWinCharSet = SYMBOL_CHARSET;
        }
    }

// this is always done in the same fashion, regardless of the glyph set type

    {
        WCRUN *pwcRunLast = &pff->pgset->awcrun[pff->pgset->cRuns - 1];
        pifi->wcFirstChar = pff->pgset->awcrun[0].wcLow;
        pifi->wcLastChar  = pwcRunLast->wcLow + pwcRunLast->cGlyphs - 1;
    }


//!!! one should look into directional hints here, this is good for now

    pifi->ptlBaseline.x   = 1;
    pifi->ptlBaseline.y   = 0;
    pifi->ptlAspect.x     = 1;
    pifi->ptlAspect.y     = 1;

// this is what win 31 is doing, so we will do the same thing [bodind]

    pifi->ptlCaret.x = (LONG)BE_INT16(&phhea->horizontalCaretSlopeDenominator);
    pifi->ptlCaret.y = (LONG)BE_INT16(&phhea->horizontalCaretSlopeNumerator);

// We have to use one of the reserved fields to return the italic angle.

    if (ppost)
    {
    // The italic angle is stored in the POST table as a 16.16 fixed point
    // number.  We want the angle expressed in tenths of a degree.  What we
    // can do here is multiply the entire 16.16 number by 10.  The most
    // significant 16-bits of the result is the angle in tenths of a degree.
    //
    // In the conversion below, we don't care whether the right shift is
    // arithmetic or logical because we are only interested in the lower
    // 16-bits of the result.  When the 16-bit result is cast back to LONG,
    // the sign is restored.

        int16 iTmp;

        iTmp = (int16) ((BE_INT32((BYTE*)ppost + POSTSCRIPTNAMEINDICES_ITALICANGLE) * 10) >> 16);
        pifi->lItalicAngle = (LONG) iTmp;
    }
    else
        pifi->lItalicAngle = 0;

//
// vendor id
//
    if (pjOS2)
    {
        char *pchSrc = (char*)(pjOS2 + OFF_OS2_achVendID);

        pifi->achVendId[0] = *(pchSrc    );
        pifi->achVendId[1] = *(pchSrc + 1);
        pifi->achVendId[2] = *(pchSrc + 2);
        pifi->achVendId[3] = *(pchSrc + 3);
    }
    else
    {
        pifi->achVendId[0] = 'U';
        pifi->achVendId[1] = 'n';
        pifi->achVendId[2] = 'k';
        pifi->achVendId[3] = 'n';
    }

//
// kerning pairs
//
    {
        PBYTE pj =  (ptp->ateOpt[IT_OPT_KERN].dp)         ?
                    (pjView + ptp->ateOpt[IT_OPT_KERN].dp):
                    NULL;

        if (!pj)
        {
            pifi->cKerningPairs = 0;
        }
        else
        {
            if (!bValidRangeKERN(pj,ptp->ateOpt[IT_OPT_KERN].cj,&pifi->cKerningPairs))
            {
                // this is an optional table, if it's bad, disable it
                ptp->ateOpt[IT_OPT_KERN].dp = 0;
                ptp->ateOpt[IT_OPT_KERN].cj = 0;
            }
        }
    }


// jWinPitchAndFamily

#ifdef THIS_IS_WIN31_SOURCE_CODE

; record family type

    mov ah, pIfiMetrics.ifmPanose.bFamilyKind
    or  ah,ah
    jz  @F
    .errnz  0 - PANOSE_FK_ANY
    dec ah
    jz  @F
    .errnz  1 - PANOSE_FK_NOFIT
    dec ah
    jz  @F
    .errnz  2 - PANOSE_FK_TEXT
    mov al, FF_SCRIPT
    dec ah
    jz  MFDSetFamily
    .errnz  3 - PANOSE_FK_SCRIPT
    mov al, FF_DECORATIVE
    dec ah
    jz  MFDSetFamily
    .errnz  4 - PANOSE_FK_DECORATIVE
    .errnz  5 - PANOSE_FK_PICTORIAL
@@:
    mov al, FF_MODERN
    cmp pIfiMetrics.ifmPanose.bProportion, PANOSE_FIXED_PITCH
    jz  MFDSetFamily
    mov al, pIfiMetrics.ifmPanose.bSerifStyle
    sub ah, ah
    mov si, ax
    add si, MiscSegOFFSET pPansoseSerifXlate
    mov al, cs:[si]     ;get serif style
MFDSetFamily:
    cmp pIfiMetrics.ifmPanose.bProportion, PANOSE_FIXED_PITCH
    je  @f
;    test    pIfiMetrics.fsType, IFIMETRICS_FIXED
;    jnz     @F
    inc al          ;hack: var pitch: 1, fixed pitch: 0
    .errnz  VARIABLE_PITCH-FIXED_PITCH-1
@@:
    or  al, PF_ENGINE_TYPE SHL PANDFTYPESHIFT ;mark font as engine
    stosb               ;copy pitch and font family info
    .errnz  efbPitchAndFamily-efbPixHeight-2

#endif  // end of win31 source code,

    if((pifi->jWinCharSet == SHIFTJIS_CHARSET) ||
        (pifi->jWinCharSet == HANGEUL_CHARSET))
    {   
          //
          // Following Code is Win3.1J compatibility
          //
          // ajPanoseFamilyForJapanese is defined as following
          //
          // static BYTE
          // ajPanoseFamilyForJapanese[16] = {
          //     FF_DONTCARE       //    0 (Any)
          //    ,FF_DONTCARE       //    1 (No Fit)
          //    ,FF_ROMAN          //    2 (Cove)
          //    ,FF_ROMAN          //    3 (Obtuse Cove)
          //    ,FF_ROMAN          //    4 (Square Cove)
          //    ,FF_ROMAN          //    5 (Obtuse Square Cove)
          //    ,FF_ROMAN          //    6 (Square)
          //    ,FF_ROMAN          //    7 (Thin)
          //    ,FF_ROMAN          //    8 (Bone)
          //    ,FF_ROMAN          //    9 (Exaggerated)
          //    ,FF_ROMAN          //   10 (Triangle)
          //    ,FF_MODERN         //   11 (Normal Sans)
          //    ,FF_MODERN         //   12 (Obtuse Sans)
          //    ,FF_MODERN         //   13 (Perp Sans)
          //    ,FF_MODERN         //   14 (Flared)
          //    ,FF_MODERN         //   15 (Rounded)
          //      };
          //
          //  Win3.1J determine the font is fixed pitch or not by
          // Proportion in PANOSE. if Proportion is PAN_PROP_MONOSPACED (9)
          // Win3.1J treat the font as fixed pitch font
          //
          // In detail, Please refer to following document
          //
          //  GDI TrueType Extension for Far East version Rev 1.02
          //     Author : Shusuke Uehara [ ShusukeU ]
          //
          //  30.Aug.1993 -By- Hideyuki Nagase [ hideyukn ]
          //

        if(pifi->panose.bFamilyType == PAN_FAMILY_SCRIPT)
        {
            pifi->jWinPitchAndFamily = FF_SCRIPT;
        }
        else
        {
            if (pifi->panose.bSerifStyle >= sizeof(ajPanoseFamilyForJapanese))
            {
                pifi->jWinPitchAndFamily = ajPanoseFamily[0];
            }
            else
            {
                pifi->jWinPitchAndFamily =
                    ajPanoseFamilyForJapanese[pifi->panose.bSerifStyle];
            }
        }

        if(pifi->panose.bProportion == PAN_PROP_MONOSPACED)
        {
            pifi->flInfo |= (FM_INFO_OPTICALLY_FIXED_PITCH | FM_INFO_DBCS_FIXED_PITCH);
        }

    }
    else
    {

        // verified that the translation to c is correct [bodind]
        // Set the family type in the upper nibble

        switch (pifi->panose.bFamilyType)
        {
        case PAN_FAMILY_DECORATIVE:

            pifi->jWinPitchAndFamily = FF_DECORATIVE;
            break;

        case PAN_FAMILY_SCRIPT:

            pifi->jWinPitchAndFamily = FF_SCRIPT;
            break;

        default:

            if (pifi->panose.bProportion == PAN_PROP_MONOSPACED)
            {
                pifi->jWinPitchAndFamily = FF_MODERN;
            }
            else
            {
                if (pifi->panose.bSerifStyle >= sizeof(ajPanoseFamily))
                {
                    pifi->jWinPitchAndFamily = ajPanoseFamily[0];
                }
                else
                {
                    pifi->jWinPitchAndFamily = ajPanoseFamily[pifi->panose.bSerifStyle];
                }
            }
            break;
        }
    
    }

// simulation information:

    if (pifi->dpFontSim = pifisz->dpSims)
    {
        FONTDIFF FontDiff;
        FONTSIM * pfsim = (FONTSIM *)((BYTE *)pifi + pifi->dpFontSim);
        FONTDIFF *pfdiffBold       = NULL;
        FONTDIFF *pfdiffItalic     = NULL;
        FONTDIFF *pfdiffBoldItalic = NULL;

        switch (pifi->fsSelection & (FM_SEL_ITALIC | FM_SEL_BOLD))
        {
        case 0:
        // all 3 simulations are present

            pfsim->dpBold       = DWORD_ALIGN(sizeof(FONTSIM));
            pfsim->dpItalic     = pfsim->dpBold + DWORD_ALIGN(sizeof(FONTDIFF));
            pfsim->dpBoldItalic = pfsim->dpItalic + DWORD_ALIGN(sizeof(FONTDIFF));

            pfdiffBold       = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBold);
            pfdiffItalic     = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpItalic);
            pfdiffBoldItalic = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBoldItalic);

            break;

        case FM_SEL_ITALIC:
        case FM_SEL_BOLD:

        // only bold italic variation is present:

            pfsim->dpBold       = 0;
            pfsim->dpItalic     = 0;

            pfsim->dpBoldItalic = DWORD_ALIGN(sizeof(FONTSIM));
            pfdiffBoldItalic = (FONTDIFF *)((BYTE*)pfsim + pfsim->dpBoldItalic);

            break;

        case (FM_SEL_ITALIC | FM_SEL_BOLD):
            RIP("ttfd!another case when flags have been messed up\n");
            break;
        }

    // template reflecting a base font:
    // (note that the FM_SEL_REGULAR bit is masked off because none of
    // the simulations generated will want this flag turned on).

        FontDiff.jReserved1      = 0;
        FontDiff.jReserved2      = 0;
        FontDiff.jReserved3      = 0;
        FontDiff.bWeight         = pifi->panose.bWeight;
        FontDiff.usWinWeight     = pifi->usWinWeight;
        FontDiff.fsSelection     = pifi->fsSelection & ~FM_SEL_REGULAR;
        FontDiff.fwdAveCharWidth = pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc   = pifi->fwdMaxCharInc;
        FontDiff.ptlCaret        = pifi->ptlCaret;

    //
    // Create FONTDIFFs from the base font template
    //
        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBoldItalic->bWeight    = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;

        // really only true if ntod transform is unity

        // for backwards compatibility we increase the width only by one pixel in emboldening

            pfdiffBold->fwdAveCharWidth += 1;
            pfdiffBold->fwdMaxCharInc   += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection     |= FM_SEL_ITALIC;

            pfdiffItalic->ptlCaret.x = CARET_X;
            pfdiffItalic->ptlCaret.y = CARET_Y;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;

            pfdiffBoldItalic->ptlCaret.x       = CARET_X;
            pfdiffBoldItalic->ptlCaret.y       = CARET_Y;

            // for backwards compatibility we increase the width only by one pixel in emboldening

            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
        }

    }

// offset to charesets

    pifi->dpCharSets = pifisz->dpCharSets;
    vFillIFICharsets(pff,
                     pifi,
                     (BYTE *)pifi + pifi->dpCharSets,
                     pjView,
                     pjOS2,
                     pgin);

// check if there is font signiture info

    pifiex->dpFontSig = pifisz->dpFontSig;

// fill in the font signature, for now, non-trivial only for tt fonts
// The following if is equivalent to
// if (pjOS2 && ((sfnt_OS2 *)pjOS2)->Version)

    if (pifiex->dpFontSig)
    {

        FONTSIGNATURE *pfsig = (FONTSIGNATURE *)((BYTE *)pifi + pifiex->dpFontSig);

        pfsig->fsUsb[0] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCharRange[0]);
        pfsig->fsUsb[1] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCharRange[1]);
        pfsig->fsUsb[2] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCharRange[2]);
        pfsig->fsUsb[3] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCharRange[3]);

        if ( ((sfnt_OS2 *)pjOS2)->Version != 0)
        {
            // 1.0 or higher contain those additional flags :
            if(IsBogusSignature((DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1),pff))
            {
                pfsig->fsCsb[0] = FS_JISJAPAN;
            }
            else
            {
                pfsig->fsCsb[0] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCodePageRange[0]);
            }

            pfsig->fsCsb[1] = SWAPL(((sfnt_OS2 *)pjOS2)->ulCodePageRange[1]);
        }
        else
        {
            pfsig->fsCsb[0] = 0;
            pfsig->fsCsb[1] = 0;
        }
    }

// if this is a far east vertical font we may create a vertical face

    if (IsAnyCharsetDbcs(&pff->ifi))
    {
        pff->ffca.fl |= FF_DBCS_CHARSET;

        if(pifi->panose.bProportion == PAN_PROP_MONOSPACED)
        {
            pifi->flInfo |= (FM_INFO_OPTICALLY_FIXED_PITCH | FM_INFO_DBCS_FIXED_PITCH);

        }
    }

    // Defining the pitch
    // set the lower 4 bits according to the LOGFONT convention
    pifi->jWinPitchAndFamily |= (pifi->flInfo & FM_INFO_OPTICALLY_FIXED_PITCH) ?
                                     FIXED_PITCH : VARIABLE_PITCH;

}


/*************************************************************************\
*
* BOOL bVerifyMsftHighByteTable
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

typedef struct _subHeader
{
    uint16  firstCode;
    uint16  entryCount;
    int16   idDelta;
    uint16  idRangeOffset;
} subHeader;

STATIC BOOL bVerifyMsftHighByteTable
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
CMAPINFO          * pcmi,
uint16              ui16SpecID,
uint32              sizeOfCmap,
uint32              offsetOfSubTable
)
{
    uint16    *pui16SubHeaderKeys = (uint16 *)((PBYTE)pmap + 6);
    subHeader *pSubHeaderArray    = (subHeader *)(pui16SubHeaderKeys + 256);
    USHORT     maxSubHeaderIndex = 0; 
    USHORT ii,jj;
    uint32  uEndOfGlyphIdArray;
    uint32 idRangeTableOffset;

// Now, we only support SHIFTJIS encoding

    if( ui16SpecID != BE_SPEC_ID_SHIFTJIS &&
        ui16SpecID != BE_SPEC_ID_GB       &&
        ui16SpecID != BE_SPEC_ID_BIG5     &&
        ui16SpecID != BE_SPEC_ID_WANSUNG
      ) return( FALSE );

    // Init stuff

    *pgset = GSET_TYPE_HIGH_BYTE;

    pcmi->fl         = 0;
    pcmi->i_b7       = 0;
    pcmi->i_2219     = 0;
    pcmi->cRuns      = 0;
    pcmi->cGlyphs    = 0;

    if( offsetOfSubTable + CMAP_minimal_sizeof_SubTableDir_Format2 > sizeOfCmap )
        RET_FALSE("TTFD!bVerifyMsftHighByteTable, sizeOfCmap1\n");

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        jj = BE_UINT16( &pui16SubHeaderKeys[ii] ); // this value is already index * 8
        if( jj > maxSubHeaderIndex )
        {
            maxSubHeaderIndex = jj;
        }
    }

    if( offsetOfSubTable + CMAP_minimal_sizeof_SubTableDir_Format2 + maxSubHeaderIndex  > sizeOfCmap )
        RET_FALSE("TTFD!bVerifyMsftHighByteTable, sizeOfCmap2\n");

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        USHORT entryCount, firstCode, idRangeOffset;
        subHeader *CurrentSubHeader;

        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );

        CurrentSubHeader = (subHeader *)((PBYTE)pSubHeaderArray + jj);

        firstCode     = BE_UINT16(&(CurrentSubHeader->firstCode));
        entryCount    = BE_UINT16(&(CurrentSubHeader->entryCount));
        idRangeOffset = BE_UINT16(&(CurrentSubHeader->idRangeOffset));

        idRangeTableOffset = offsetOfSubTable + 6 + 256 * sizeof(uint16) + jj + offsetof(subHeader,idRangeOffset);

        if (jj == 0)
        {
            if (firstCode > ii)
                RET_FALSE("TTFD!bVerifyMsftHighByteTable, firstCode too big\n");

            uEndOfGlyphIdArray =    (uint32)(idRangeOffset
                +  ( (ii - firstCode + 1) * sizeof(uint16))
                +  idRangeTableOffset);
        }
        else
        {
            uEndOfGlyphIdArray =    (uint32)(idRangeOffset
                +  (entryCount * sizeof(uint16))
                +  idRangeTableOffset);
        }

        if( uEndOfGlyphIdArray  > sizeOfCmap )
            RET_FALSE("TTFD!bVerifyMsftHighByteTable, GlyphIdArray overflow\n");
    }

    return( TRUE );
}

/*************************************************************************\
*
* BOOL bVerifyMsftTableGeneral
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC BOOL bVerifyMsftTableGeneral
(
sfnt_mappingTable * pmap,
ULONG             * pgset,
CMAPINFO          * pcmi,
uint16              ui16SpecID,
uint32 sizeOfCmap,
uint32 offsetOfSubTable,
sfnt_char2IndexDirectory * pcmap

)
{
    uint16 * pstartCount;
    uint16 * pendCount, * pendCountEnd;
    uint16   cRuns;
    uint16   usLo, usHi, usHiPrev;

// Now, we only support SHIFTJIS encoding

    if( ui16SpecID != BE_SPEC_ID_SHIFTJIS &&
        ui16SpecID != BE_SPEC_ID_GB       &&
        ui16SpecID != BE_SPEC_ID_BIG5     &&
        ui16SpecID != BE_SPEC_ID_WANSUNG
      ) return( FALSE );

    if (pmap->format != BE_FORMAT_MSFT_UNICODE)
        RET_FALSE("TTFD!_bVerifyMsftTableGeneral, format\n");

    cRuns = BE_UINT16((PBYTE)pmap + OFF_segCountX2);

    if (cRuns & 1)
        RET_FALSE("TTFD!_bVerifyMsftTableGeneral, segCountX2 is odd\n");

    cRuns >>= 1;


    if(!IsValidFormat4TableSize(cRuns, pcmap,offsetOfSubTable,sizeOfCmap)){
        RET_FALSE("TTFD!_bVerifyMsftTable, corrupted pmap\n");
    }

// get the pointer to the beginning of the array of endCount code points

    pendCount = (uint16 *)((PBYTE)pmap + OFF_endCount);

// the final endCode has to be 0xffff;
// if this is not the case, there is a bug in the tt file or in our code:

    if (pendCount[cRuns - 1] != 0xFFFF)
        RET_FALSE("TTFD!_bVerifyMsftTableGeneral, pendCount[cRuns - 1] != 0xFFFF\n");
   
    usHiPrev = 0;
    pendCountEnd = &pendCount[cRuns];
    pstartCount = &pendCount[cRuns + 1];

// Init stuff

    *pgset = GSET_TYPE_GENERAL_NOT_UNICODE;

    pcmi->fl         = 0;
    pcmi->i_b7       = 0;
    pcmi->i_2219     = 0;
    pcmi->cRuns      = 0;
    pcmi->cGlyphs    = 0;

    for (
         ;
         pendCount < pendCountEnd;
         pstartCount++, pendCount++, usHiPrev = usHi
        )
    {
        usLo = BE_UINT16(pstartCount);
        usHi = BE_UINT16(pendCount);

        if (usHi < usLo)
            RET_FALSE("TTFD!_bVerifyMsftTable: usHi < usLo\n");
        if (usHiPrev > usLo)
            RET_FALSE("TTFD!_bVerifyMsftTable: usHiPrev > usLo\n");
    }
    return( TRUE );
}

/*************************************************************************\
*
* ULONG CreateGlyphSetFromMITable
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC ULONG CreateGlyphSetFromMITable
(
CMAPINFO        *pcmi,
MbcsToIndex     *MITable,
USHORT           MICount,
ULONG          **ppgset
)
{
    USHORT     ii;
    INT        iCodePage;
    WcharToIndex *WITable;
    ULONG       cRuns;
    ULONG       cGlyphsSupported;
    ULONG       cjThis;
    BOOL bInRun = FALSE;
    FD_GLYPHSET *pgset;
    WcharToIndex *WINow;
    PWCRUN  pwcrun;
    HGLYPH *phg;


// Alloc WcharToIndex table

    WITable = PV_ALLOC( sizeof(WcharToIndex) * 0xFFFF );

    if( WITable == NULL )
    {
        WARNING("TTFD!CreateGlyphSetFromMITable() PV_ALLOC() fail\n");
        if (ppgset)
            *ppgset = NULL;

        return( 0 );
    }

    RtlZeroMemory( WITable , sizeof(WcharToIndex) * 0xFFFF );

// Set CodePage

    iCodePage = GetCodePageFromSpecId( pcmi->ui16SpecID );

// Fill up WcharToIndex table

    for( ii = 0 ; ii < MICount ; ii++ )
    {
        WCHAR wChar[2];
        int   iRet;

    // Convert Mbcs to Wide char

        iRet = EngMultiByteToWideChar(iCodePage ,
                                      wChar,
                                      2 * sizeof(WCHAR),
                                      MITable[ii].MbcsChar,
                                      2);

        if( iRet == -1 )
        {
            WARNING("TTFD!MultiByteToWideChar fail\n");
            V_FREE(WITable);
            if (ppgset)
                *ppgset = NULL;
            return( 0 );
        }

        if( !WITable[wChar[0]].bValid )
        {
            WITable[wChar[0]].bValid = TRUE;
            WITable[wChar[0]].wChar  = wChar[0];
            WITable[wChar[0]].hGlyph = MITable[ii].hGlyph;
        }
    }

// Dump WITable

#ifdef DBG_GLYPHSET
    for( ii = 0 ; ii < 0xFFFF ; ii++ )
    {
        if(WITable[ii].bValid)
        {
            TtfdDbgPrint("WideChar - %x : hGlyph - %x \n",
                         WITable[ii].wChar , WITable[ii].hGlyph );
        }
    }
#endif // DBG_GLYPHSET

// Compute cRuns and cGlyphsSupported

    cRuns = 0;
    cGlyphsSupported = 0;

    for( ii = 0 ; ii < 0xFFFF ; ii++ )
    {
        if( !WITable[ii].bValid )
        {
            if( bInRun )
            {
                bInRun = FALSE;
                cRuns++;
            }
        }
        else
        {
            bInRun = TRUE;
            cGlyphsSupported++;
        }
    }
    if( bInRun )
      cRuns++;


#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cRuns - %x , cGlyphsSupported - %x\n",cRuns,cGlyphsSupported);
#endif // DBG_GLYPHSET

// Compute needed size for FD_GLYPHSET

    cjThis =   sizeof ( FD_GLYPHSET )  + (cRuns - 1) * sizeof ( WCRUN )
      + cGlyphsSupported * sizeof( HGLYPH );

    if( ppgset == NULL ) return( cjThis );

// Alloc FD_GLYPHSET table

    pgset = PV_ALLOC( cjThis );

    if( pgset == NULL )
    {
        WARNING("TTFD!cjComputeGLYPHSET_HIGH_BYTE() PV_ALLOC() fail\n");
        V_FREE(WITable);
        *ppgset = NULL;
        return( 0 );
    }

    RtlZeroMemory( pgset , cjThis );
    pgset->cjThis   = cjThis;
    pgset->flAccel  = 0;
    pgset->cRuns    = cRuns;
    pgset->cGlyphsSupported = cGlyphsSupported;

// Fill UP FD_GLYPHSET


    pwcrun = &(pgset->awcrun[0]);
    phg = (HGLYPH *)((PBYTE)pgset + sizeof( FD_GLYPHSET ) + (cRuns - 1) *
                      sizeof(WCRUN));

    WINow  = &WITable[0];

    for( ii = 0 ; ii < cRuns ; ii++ )
    {
        while( !WINow->bValid ) WINow++;

        pwcrun->wcLow   = WINow->wChar;
        pwcrun->cGlyphs = 0;
        pwcrun->phg     = phg;
        while( WINow->bValid )
        {
            pwcrun->cGlyphs++;
            *phg++ = WINow->hGlyph;
            WINow++;
        }
        pwcrun++;
    }

    V_FREE(WITable);

    *ppgset = (ULONG *)pgset;

    return( cjThis );
}

/*************************************************************************\
*
* ULONG cjComputeGLYPHSET_HIGH_BYTE
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC ULONG cjComputeGLYPHSET_HIGH_BYTE
(
sfnt_mappingTable     *pmap,
ULONG                **ppgset,
CMAPINFO              *pcmi
)
{
    uint16    *pui16SubHeaderKeys = (uint16 *)((PBYTE)pmap + 6);
    subHeader *pSubHeaderArray    = (subHeader *)(pui16SubHeaderKeys + 256);

    UINT       cjChar = 0;
    USHORT     ii , jj;

    MbcsToIndex *MITable;
    USHORT       MICount;

    ULONG        cjGlyphSet;

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("pui16SubHeaderKeys - %x\n",pui16SubHeaderKeys);
    TtfdDbgPrint("pSubHeaderArray    - %x\n",pSubHeaderArray);
#endif // DBG_GLYPHSET

// Compute how many chars in this cmap ?

// for single-byte char

    cjChar = (BE_UINT16(&(((subHeader *)((PBYTE)pSubHeaderArray))->entryCount)));

// for double-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );
        if( jj != 0 )
          cjChar +=
            (BE_UINT16(&(((subHeader *)((PBYTE)pSubHeaderArray + jj))->entryCount)));
    }

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cjChar - %x\n",cjChar);
#endif // DBG_GLYPHSET

// Alloc memory for MbcsToIndex table

    MITable = PV_ALLOC( sizeof(MbcsToIndex) * cjChar );

    if( MITable == NULL )
    {
        WARNING("TTFD!cjComputeGLYPHSET_HIGH_BYTE() PV_ALLOC() fail\n");
        *ppgset = NULL;
        return( 0 );
    }

// Fill up MbcsToIndex table

    MICount = 0;

// Process single-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        USHORT entryCount, firstCode, idDelta, idRangeOffset;
        subHeader *CurrentSubHeader;
        uint16 *pui16GlyphArray;
        HGLYPH hGlyph;

        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );

        if( jj != 0 ) continue;

        CurrentSubHeader = pSubHeaderArray;

        firstCode     = BE_UINT16(&(CurrentSubHeader->firstCode));
        entryCount    = BE_UINT16(&(CurrentSubHeader->entryCount));
        idDelta       = BE_UINT16(&(CurrentSubHeader->idDelta));
        idRangeOffset = BE_UINT16(&(CurrentSubHeader->idRangeOffset));

        pui16GlyphArray = (uint16 *)((PBYTE)&(CurrentSubHeader->idRangeOffset) +
                                     idRangeOffset);

#ifdef DBG_GLYPHSET
        TtfdDbgPrint("\n");
        TtfdDbgPrint("firstCode - %x , entryCount - %x\n",firstCode,entryCount);
        TtfdDbgPrint("idDelta   - %x , idROffset  - %x\n",idDelta,idRangeOffset);
        TtfdDbgPrint("GlyphArray - %x\n",pui16GlyphArray);
        TtfdDbgPrint("\n");
#endif // DBG_GLYPHSET

        // ASSERTDD( idDelta == 0 , "TTFD!cjComputeGLYPHSET_HIGH_BYTE:entryCount != 0\n" );

        hGlyph = (HGLYPH)BE_UINT16(&pui16GlyphArray[ii-firstCode]);

        if( hGlyph == 0 ) continue;

        MITable[MICount].MbcsChar[0] =  (UCHAR) ii;
        MITable[MICount].MbcsChar[1] =  (UCHAR) 0;
        MITable[MICount].hGlyph      =  hGlyph;
        MICount++;
    }

// Process double-byte char

    for( ii = 0 ; ii < 256 ; ii ++ )
    {
        USHORT entryCount, firstCode, idDelta, idRangeOffset;
        subHeader *CurrentSubHeader;
        uint16 *pui16GlyphArray;

        jj = BE_UINT16( &pui16SubHeaderKeys[ii] );

        if( jj == 0 ) continue;

        CurrentSubHeader = (subHeader *)((PBYTE)pSubHeaderArray + jj);

        firstCode     = BE_UINT16(&(CurrentSubHeader->firstCode));
        entryCount    = BE_UINT16(&(CurrentSubHeader->entryCount));
        idDelta       = BE_UINT16(&(CurrentSubHeader->idDelta));
        idRangeOffset = BE_UINT16(&(CurrentSubHeader->idRangeOffset));

        pui16GlyphArray = (uint16 *)((PBYTE)&(CurrentSubHeader->idRangeOffset) +
                                     idRangeOffset);

#ifdef DBG_GLYPHSET
        TtfdDbgPrint("\n");
        TtfdDbgPrint("firstCode - %x , entryCount - %x\n",firstCode,entryCount);
        TtfdDbgPrint("idDelta   - %x , idROffset  - %x\n",idDelta,idRangeOffset);
        TtfdDbgPrint("GlyphArray - %x\n",pui16GlyphArray);
        TtfdDbgPrint("\n");
#endif // DBG_GLYPHSET

        for( jj = firstCode ; jj < firstCode + entryCount ; jj++ )
        {
            HGLYPH hGlyph;

            hGlyph = (HGLYPH)(BE_UINT16(&pui16GlyphArray[jj-firstCode]));

            if( hGlyph == 0 ) continue;

            MITable[MICount].MbcsChar[0] = (UCHAR) ii;
            MITable[MICount].MbcsChar[1] = (UCHAR) jj;
            MITable[MICount].MbcsChar[2] = (UCHAR) 0;
            MITable[MICount].hGlyph      = hGlyph + idDelta;
            MICount++;
        }
    }

#ifdef DBG_GLYPHSET
// Dump MITable
//    for( ii = 0 ; ii < MICount ; ii++ )
    for( ii = 0 ; ii < 10 ; ii++ )
    {
        TtfdDbgPrint("MbcsChar - %2x%2x : hGlyph - %x \n"
                     ,MITable[ii].MbcsChar[0],
                     MITable[ii].MbcsChar[1] , MITable[ii].hGlyph );
    }
#endif // DBG_GLYPHSET

    cjGlyphSet = CreateGlyphSetFromMITable( pcmi, MITable, MICount, ppgset );

    V_FREE( MITable );

    return( cjGlyphSet );
}

/*************************************************************************\
*
* ULONG cjComputeGLYPHSET_MSFT_GENERAL
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC ULONG cjComputeGLYPHSET_MSFT_GENERAL
(
sfnt_mappingTable     *pmap,
ULONG                  cGlyphs,
ULONG                **ppgset,
CMAPINFO              *pcmi
)
{
    USHORT  cSegments, cValidSegments;
    uint16 *pendCountKeep , *pstartCountKeep , *pendCount , *pstartCount;
    uint16 *pidDelta, *pRangeOffset, *pGlyphArray;

    USHORT  cChars;

    USHORT  ii;

    MbcsToIndex *MITable;
    USHORT       MICount;

    ULONG   cjGlyphSet;

    cSegments       = BE_UINT16((PBYTE)pmap + OFF_segCountX2) / 2;
    pendCountKeep   = pendCount   = (uint16 *)((PBYTE)pmap + OFF_endCount);
    pstartCountKeep = pstartCount = (uint16 *)(pendCount + (cSegments + 1));
    pidDelta                      = (uint16 *) pstartCount + (cSegments * 1);
    pRangeOffset                  = (uint16 *) pstartCount + (cSegments * 2);
    pGlyphArray                   = (uint16 *) pstartCount + (cSegments * 3);

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cSegments   - %x\n",cSegments   );
    TtfdDbgPrint("pstart      - %x\n",pstartCount );
    TtfdDbgPrint("pGlyphArray - %x\n",pGlyphArray );
    TtfdDbgBreakPoint();
#endif // DBG_GLYPHSET

// Compute valid segments : This is fix for love.ttf which has bogus cmap table
    cValidSegments = cSegments;
    if(pendCount[cSegments-1] != 0xFFFF){
        WARNING("TTFD!cjComputeGLYPHSET_MSFT_GENERAL() : Last endCount is not 0xFFFF in cmap table\n");

        for( ii = cSegments-2 ; ii >= 0 ; ii--){
            if(pendCount[ii] == 0xFFFF){
                cValidSegments = ii+1;
                break;
            }
        }
        
        ASSERTDD(cSegments != cValidSegments, "TTFD!cjComputeGLYPHSET_MSFT_GENERAL() : no 0xFFFF in endCount\n");
    }

// Compute how many chars in this table

    cChars = 0;
    
    for( ii = 0 ; ii < cValidSegments - 1 ; ii ++ , pendCount ++ , pstartCount ++ )
    {
        USHORT usStart = BE_UINT16(pstartCount);
        USHORT usEnd = BE_UINT16(pendCount);

        if( (usEnd >= usStart) && (usStart != 0xFFFF))
        {
            cChars += (usEnd - usStart + 1);
        }
    }

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cChars - %x\n",cChars);
#endif // DBG_GLYPHSET

// Alloc memory for MbcsToIndex table

    MITable = PV_ALLOC( sizeof(MbcsToIndex) * cChars );

    if( MITable == NULL )
    {
        WARNING("TTFD!cjComputeGLYPHSET_MSFT_GENERAL() PV_ALLOC() fail\n");
        *ppgset = NULL;
        return( 0 );
    }

// Fill up MbcsToIndex table

    pendCount   = pendCountKeep;
    pstartCount = pstartCountKeep;

    MICount = 0;

    for( ii = 0 ; ii < cValidSegments - 1 ; ii ++ , pendCount ++ , pstartCount ++ )
    {
        USHORT usStart , usEnd;
        USHORT jj;

        usStart = BE_UINT16(pstartCount);
        usEnd   = BE_UINT16(pendCount);

#ifdef DBG_GLYPHSET
        TtfdDbgPrint("usStart - %x\n",usStart);
        TtfdDbgPrint("usEnd   - %x\n",usEnd);
#endif // DBG_GLYPHSET

    // Check order

        if ( (usEnd >= usStart) && (usStart != 0xFFFF))
        {
            for( jj = usStart ; jj <= usEnd ; jj ++ )
            {
                *(ULONG  *)(MITable[MICount].MbcsChar) = (LONG)0;

                if( usStart > 0xFF )
                    *(USHORT *)(MITable[MICount].MbcsChar) = ((jj >> 8) | (jj << 8));
                else
                    *(USHORT *)(MITable[MICount].MbcsChar) = jj;

                if( pRangeOffset[ii] == 0 )
                    MITable[MICount].hGlyph = (USHORT)(jj + BE_UINT16(pidDelta + ii));
                else
                MITable[MICount].hGlyph =
                    (USHORT)(BE_UINT16((USHORT *)&pRangeOffset[ii] +
                            BE_UINT16(&pRangeOffset[ii])/2+(jj-usStart)) +
                            BE_UINT16( pidDelta + ii ));

                if (MITable[MICount].hGlyph >= cGlyphs)
                {
                    MITable[MICount].hGlyph = 0;  /* in case a character is mapped to glyph ID our of range, map it to the missing glyph */
                }
                MICount++;
            }
        }
        else
        {
            WARNING("TTFD!usStart > usEnd or usStart == 0xFFFF\n");
        }
    }

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("MICount - %x\n",MICount);
#endif

    ASSERTDD( cChars == MICount , "cChars != MICount - 1\n" );

#ifdef DBG_GLYPHSET
// Dump MITable
    for( ii = 0 ; ii < MICount ; ii++ )
    {
        TtfdDbgPrint("MbcsChar - %2x%2x : hGlyph - %x \n"
                     ,MITable[ii].MbcsChar[0] ,
                     MITable[ii].MbcsChar[1] ,
                     MITable[ii].hGlyph );
    }
#endif // DBG_GLYPHSET

    cjGlyphSet = CreateGlyphSetFromMITable( pcmi, MITable, MICount, ppgset );

    V_FREE( MITable );

    return( cjGlyphSet );
}

/******************************Public*Routine******************************\
*
* STATIC ULONG cjComputeGLYPHSET_TEMPLATE
*
* History:
*  07-Mar-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


STATIC ULONG cjComputeGLYPHSET_TEMPLATE
(
fs_GlyphInputType     *pgin,
FD_GLYPHSET          **ppgset,
ULONG                  ul_wcBias,
ULONG                  iGsetType
)
{
    ULONG iRun;
    HGLYPH *phg;
    FS_ENTRY iRet;
    FD_GLYPHSET  *pgset = NULL;

// zero out just the result in case somebody tries to use it when we fail:

    *ppgset = NULL;

// go on to produce template set:

    switch (iGsetType)
    {
    case GSET_TYPE_SYMBOL:
        pgset = pgsetComputeSymbolCP();
        break;

    case GSET_TYPE_PSEUDO_WIN:
        pgset = EngComputeGlyphSet(0, 0, 256);
        break;

    case GSET_TYPE_MAC_ROMAN:
        pgset = EngComputeGlyphSet(10000, 0, 256); // mac code page
        break;

    default:
        RIP("wrong iGsetType passed to cjComputeGLYPHSET_TEMPLATE\n");
        return 0;
    }


    if (!pgset)
    {
        return 0;
    }

// override whatever was there before:

    pgset->flAccel = GS_16BIT_HANDLES;

// now fix the handles to be glyph indices:

    for (iRun = 0; iRun < pgset->cRuns; iRun++)
    {
        phg = pgset->awcrun[iRun].phg;

        if ((iRet = fs_WinNTGetGlyphIDs (pgin, pgset->awcrun[iRun].cGlyphs, 0, ul_wcBias, phg, phg)) != NO_ERR)
        {
             V_FSERROR(iRet);
             WARNING("TTFD!_cjComputeGLYPHSET_TEMPLATE, fs_WinNTGetGlyphIDs\n");
             V_FREE(pgset);
             return 0;
        }


    }

    *ppgset = pgset;
    return pgset->cjThis;
}


/******************************Module*Header*******************************\
* Defines the Unicode to GlyphIndex map of the old BiDi font pages.
* These fonts have a fixed page layout and are identified by
* pOS2->ufSelection&0xff00 == (0xb1 or 0xb2 or 0xb3 or 0xb4 or 0xb5)
* &&
* pCmap->puStartCount&0xff00 is true
\**************************************************************************/

#define C_MAX_OLDBIDI_CHARS   256        // Max char/FP

// Creating the FD_GLYPHSET for the Old Arabic/Hebrew TTF fonts
// structure used to walk through the hard-coded font tables
// Any change here should accompany a change in the hard-coded tables below
typedef struct _UNICODE_TO_HGLYPH
{
  WCHAR  wcLow ;
  USHORT cGlyphs ;
  USHORT gi[1] ;
} WC_GI, *PWC_GI ;



// The structure of the following FontPages is based on the above structure
static const WCHAR wc_giArabicSimplifiedFP[]=
{
  // wcLow   cGlyphs   gi[..]
  0x0020 ,   0x03   ,  0x20,0x21,0x22,
  0x0025 ,   0x01   ,  0x25,
  0x0028 ,   0x04   ,  0x28,0x29,0x2a,0x2b,
  0x002d ,   0x0d   ,  0x2d,0x2e,0x2f,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,
  0x003d ,   0x01   ,  0x3d,
  0x005b ,   0x03   ,  0x5b,0x5c,0x5d,
  0x00ab ,   0x01   ,  0x23,
  0x00bb ,   0x01   ,  0x24,
  0x00d7 ,   0x01   ,  0x26,
  0x060c ,   0x01   ,  0x2c,
  0x061b ,   0x01   ,  0x3b,
  0x061f ,   0x01   ,  0x3f,
  0x0621 ,   0x1a   ,  0xad,0x45,0x43,0xbb,0x47,0xba,0x41,0x4a,0xa9,0x4c,0x4e,0x51,0x54,
                       0x57,0x58,0x59,0x5a,0x60,0x62,0x64,0x66,0x68,0x69,0x6a,0x6e,0x72,
  0x0640 ,   0x13   ,  0x40,0x75,0x78,0x7a,0x7c,0x7e,0xe1,0xa4,0xa5,0xac,0xa8,0xd5,0xd6,
                       0xd9,0xd2,0xd3,0xd8,0xd7,0xd4,
  0x0660 ,   0x0a   ,  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,
  0x066b ,   0x02   ,  0x5e,0x5e,
  0x200c ,   0x04   ,  0x0c,0x0d,0x0e,0x0f,
  0x2018 ,   0x02   ,  0x3c,0x3e,

  0xffff ,   0x00   ,  0x00,    // terminator
} ;


static const WCHAR wc_giArabicTraditionalFP[]=
{
  // wcLow   cGlyphs   gi[..]
  0x0020 ,   0x03   ,  0x20,0x21,0x22,
  0x0025 ,   0x01   ,  0x25,
  0x0028 ,   0x04   ,  0x28,0x29,0x2a,0x2b,
  0x002c ,   0x04   ,  0x5e,0x2d,0x2e,0x2f,
  0x003a ,   0x01   ,  0x3a,
  0x003d ,   0x01   ,  0x3d,
  0x005b ,   0x01   ,  0x5b,
  0x005d ,   0x01   ,  0x5d,
  0x00ab ,   0x01   ,  0x23,
  0x00bb ,   0x01   ,  0x24,
  0x00d7 ,   0x01   ,  0x26,
  0x00f7 ,   0x01   ,  0x27,
  0x060c ,   0x01   ,  0x2c,
  0x061b ,   0x01   ,  0x3b,
  0x061f ,   0x01   ,  0x3f,
  0x0621 ,   0x1a   ,  0xd5,0x45,0x43,0xda,0x47,0xd9,0x41,0x4c,0xd1,0x50,0x54,0x58,0x60,
                       0x64,0x65,0x67,0x69,0x6b,0x70,0x74,0x78,0x7e,0x7f,0xa3,0xaa,0xae,
  0x0640 ,   0x13   ,  0x40,0xb2,0xb6,0xba,0xbe,0xc3,0xc6,0xca,0xcb,0xd4,0xd0,0xe7,0xe8,
                       0xeb,0xe4,0xe5,0xea,0xe9,0xe6,
  0x0660 ,   0x0a   ,  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,
  0x066b ,   0x02   ,  0x5e,0x5e,
  0x200c ,   0x04   ,  0x0c,0x0d,0x0e,0x0f,
  0x201c ,   0x02   ,  0x3c,0x3e,

  0xffff ,   0x00   ,  0x00,    // terminator
} ;

static const WCHAR wc_giHebrewFP[]=
{
  // wcLow   cGlyphs   gi[..]
  0x0020 ,   0x21   ,  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,
                       0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,
                       0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,
  0x005b ,   0x05   ,  0x5b,0x5c,0x5d,0x5e,0x5f,
  0x007b ,   0x04   ,  0x7b,0x7c,0x7d,0x7e,
  0x00a3 ,   0x01   ,  0xa3,
  0x00a7 ,   0x01   ,  0xa7,
  0x00b0 ,   0x01   ,  0xb0,
  0x00b2 ,   0x02   ,  0x82,0x83,
  0x00b7 ,   0x01   ,  0xb7,
  0x00b9 ,   0x01   ,  0x81,
  0x00bc ,   0x03   ,  0xbc,0xbd,0xbe,
  0x00d7 ,   0x01   ,  0xaa,
  0x00f7 ,   0x01   ,  0xba,
  0x05b0 ,   0x14   ,  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,
                       0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,
  0x05d0 ,   0x1b   ,  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,
                       0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,
                       0xfa,
  0x200e ,   0x02   ,  0xfd,0xfe,
  0x2070 ,   0x01   ,  0x80,
  0x2074 ,   0x06   ,  0x84,0x85,0x86,0x87,0x88,0x89,
  0x20aa ,   0x01   ,  0xa4,

  0xffff ,   0x00   ,  0x00,    // terminator
} ;

/******************************Public*Routine******************************\
* cjComputeGLYPHSET_OLDBIDI
*
*
* Compute the FD_GLYPHSET for old Arabic/Hebrew TTFs which have fsSelection
* equal 0xb1, 0xb2, 0xb3 0xb4 or 0xb5 and puStartCount&0xFF00 is true
*
*
* History:
*  14-Aug-1997 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/
STATIC ULONG cjComputeGLYPHSET_OLDBIDI(
    fs_GlyphInputType *pgin,
    FD_GLYPHSET      **ppgset,
    ULONG              ul_wcBias
)
{
  ULONG         cjOldBiDiCP ;
  PWC_GI        pwc_gi=NULL,pwc_giTEMP ;
  INT           cGlyphsSupported=0, cRuns=0 ;
  PFD_GLYPHSET  pgsetOldBiDiCP=NULL ;
  uint16        characterCode;
  uint16        glyphIndex;
  ULONG         cjThis = 0;

  *ppgset = NULL ;    // to start with

  // Parse the proper table

  switch (ul_wcBias & 0xff00)
  {
    case 0xf000:       // Old Hebrew FP
    {
      pwc_giTEMP = pwc_gi= (PWC_GI)wc_giHebrewFP;
    }
    break;

    case 0xf100:       // Old Arabic Simplified FP
    {
      pwc_giTEMP = pwc_gi= (PWC_GI)wc_giArabicSimplifiedFP;
    }
    break;

    case 0xf200:       // Old Arabic Traditional FP
    {
      pwc_giTEMP = pwc_gi= (PWC_GI)wc_giArabicTraditionalFP;
    }
    break;

    default:
    {
      WARNING("TTFD!_ciComputeGLYPHSET_OLDBIDI, Invalid ul_wcBias\n");
      return 0;
    }
    break;
  }

  // Count number of runs

  while( pwc_gi->cGlyphs )
  {
    cRuns++ ;
    cGlyphsSupported += pwc_gi->cGlyphs ;
    pwc_gi = (PWC_GI)&pwc_gi->gi[pwc_gi->cGlyphs] ;
  }

  // add the U+FX00 page

  cGlyphsSupported += C_MAX_OLDBIDI_CHARS ;

  pwc_gi = pwc_giTEMP ;

  // Generate the FD_GLYPHSET for the claimed and non-claimed

  cjOldBiDiCP  = SZ_GLYPHSET(cRuns+1 ,  cGlyphsSupported );
  pgsetOldBiDiCP = (FD_GLYPHSET *)PV_ALLOC(cjOldBiDiCP);

  if( pgsetOldBiDiCP )
  {
    INT iRun ;
    INT iGlyph;
    HGLYPH *phgD,*phgDLastRun;
    FS_ENTRY iRet;

    pgsetOldBiDiCP->cjThis = cjOldBiDiCP;
    pgsetOldBiDiCP->flAccel = GS_16BIT_HANDLES;
    pgsetOldBiDiCP->cGlyphsSupported = cGlyphsSupported ;
    pgsetOldBiDiCP->cRuns = cRuns+1 ;

    // Let's fill in the Unicode content of the font

    phgD = (HGLYPH *)&pgsetOldBiDiCP->awcrun[cRuns+1] ;

    phgDLastRun = phgD+(cGlyphsSupported-C_MAX_OLDBIDI_CHARS);
    RtlZeroMemory( phgDLastRun , sizeof(HGLYPH)*(C_MAX_OLDBIDI_CHARS) );

    for( iRun = 0; iRun < cRuns; iRun++ )
    {
      uint16 usCh = pwc_gi->wcLow ;

      pgsetOldBiDiCP->awcrun[iRun].wcLow = usCh ;
      pgsetOldBiDiCP->awcrun[iRun].cGlyphs = pwc_gi->cGlyphs ;
      pgsetOldBiDiCP->awcrun[iRun].phg = phgD ;

      // Now let's fill phg area with true GIs

      for( iGlyph=0 ; iGlyph<pwc_gi->cGlyphs ; iGlyph++ )
      {
        characterCode = (uint16)(pwc_gi->gi[iGlyph]+ul_wcBias) ;

        if ((iRet = fs_GetGlyphIDs(pgin, 1, characterCode, NULL, &glyphIndex)) != NO_ERR)   // get the true GI
        {
          V_FSERROR(iRet);
          WARNING("TTFD!_pgsetComputeOldBiDiCP, fs_GetGlyphIDs\n");
          V_FREE(pgsetOldBiDiCP);
          return 0 ;
        }

        *phgD = (HGLYPH)glyphIndex ;
        phgDLastRun[pwc_gi->gi[iGlyph]] = *phgD;
        phgD++ ;
      }

      pwc_gi = (PWC_GI)&pwc_gi->gi[pwc_gi->cGlyphs] ;
    }

    // Now, let's reflect the U+FX00 range as the last one
    pgsetOldBiDiCP->awcrun[cRuns].wcLow = (WCHAR)ul_wcBias ;
    pgsetOldBiDiCP->awcrun[cRuns].cGlyphs = C_MAX_OLDBIDI_CHARS ;
    pgsetOldBiDiCP->awcrun[cRuns].phg = phgD ;

    // Now let's phg area with true GIs

    for( iGlyph=0 ; iGlyph<C_MAX_OLDBIDI_CHARS ; iGlyph++ )
    {
      characterCode = (uint16)(iGlyph+ul_wcBias) ;

      // make sure no redundant calls to the rasterizer

      if ( !(*phgD) )
      {
        if ((iRet = fs_GetGlyphIDs(pgin, 1, characterCode, NULL, &glyphIndex)) != NO_ERR)   // get the true GI
        {
          V_FSERROR(iRet);
          WARNING("TTFD!_pgsetComputeOldBiDiCP, fs_GetGlyphIDs\n");
          V_FREE(pgsetOldBiDiCP);
          return 0 ;
        }

        *phgD = glyphIndex ;
      }
      phgD++ ;
    }

    cjThis = pgsetOldBiDiCP->cjThis; 
    *ppgset = pgsetOldBiDiCP ;
  }

  return cjThis ;
}


/*************************************************************************\
*
* BOOL bContainGlyphSet()
*
* History:
*  11-Oct-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
*
**************************************************************************/

STATIC BOOL  bContainGlyphSet
(
WCHAR                 wc,
PFD_GLYPHSET          pgs
)
{
    WCRUN *pwcRun = pgs->awcrun;

// binary search over awcrun, looking for correct run, if any

    WCRUN *pwcRunLow = pgs->awcrun;
    WCRUN *pwcRunHi = pgs->awcrun + (pgs->cRuns - 1);

    while ( 1 )
    {
        int nwc;

    // if run exists, it is in [pwcRunLow, pwcRunHi]

        pwcRun = pwcRunLow + (pwcRunHi-pwcRunLow)/2;
        nwc = wc - pwcRun->wcLow;

        if ( nwc < 0)
        {
        // if correct run exists, it is in [pwcRunLow, pwcRun)
            pwcRunHi = pwcRun - 1;

        }
        else if ( nwc >= (int)pwcRun->cGlyphs)
        {
        // if correct run exists, it is in (pwcRun, pwcHi]
            pwcRunLow = pwcRun + 1;
        }
        else
        {
        // pwcRun is correct run
        if ( pwcRun->phg != NULL )
            return TRUE;
        else
            return FALSE;
        }

        if ( pwcRunLow > pwcRunHi )
        {
        // wc is not in any run
            return FALSE;
        }
    } // while
}

//*****************************************************************************
//*****************   F I L L   I F I   C H A R S E T S   *********************
//*****************************************************************************
//
//   Now determine how many charsets are supported in the TTF file. If
//    the family isn't pictorial, then I assume it is at least an WANSI
//    font. Then I see if a Unicode 0x2206 (Mac Increment char) is present
//   in the font, if it is then I assume the MAC_CHARSET is supported.
//    Finally, I check if Unicode 0x2592 (IBM medium shade char) is in
//   the font, if so then I assume the OEM_CHARSET is supported.
//
//   If the family is pictorial, then assume only the SYMBOL_CHARSET is
//    supported.
//
//  Wed 25-Jan-1995 -by- Bodin Dresevic [BodinD]
//  update: stolen from win95 code
//*****************************************************************************

// these are in descending order in the font signature.  there are no holes
// as defined in the spec. we go backwards so that 437 will be found first
// (usa/english)

static const UINT oemPages[] = {437, 850, 708, 737, 775, 852, 855, 857,
                   860, 861, 862, 863, 864, 865, 866, 869};

#define FEOEM_CHARSET 254

void vFillIFICharsets(
    FONTFILE *pff,
    IFIMETRICS *pifi,
    BYTE *aCharSets,
    BYTE *pjView,
    BYTE * pjOS2,
    fs_GlyphInputType *pgin)
{
    UINT   iCS = 0;
    DWORD  fsig;
    UINT   i;
    DWORD  fsigOEM;
    BYTE   cs;
    uint8 *pCmap = pjView + pff->ffca.dpMappingTable + sizeof(sfnt_mappingTable);
    uint16 giFirstChar = pjOS2 ? BE_UINT16(pjOS2+OFF_OS2_usFirstChar) : 0;

    // This routine is to be replaced by a routine that searches the registry
    // for the names of fonts that have bogus os2 table signatures:


    BOOL   bDBCSFont = IS_ANY_DBCS_CHARSET(pifi->jWinCharSet);
    DWORD CSfs = FS_HEBREW | FS_ARABIC | FS_THAI;

    // Far East versions of Windows 95 ignore the charset array for far east
    // fonts.  Instead they jam the charset of the font, the value 254
    // (which the call FEOEM_CHARSET), and DEFAULT_CHARSET into the array.
    // The following code comes from t2api.asm
    //
    // ifdef    DBCS                            ;DBCS T2 output
    //;-----------------  Set charset and family for DBCS font  -------------------
    //
    //  test    bptr fEmbed, FEM_WIN31  ; Want new format?
    //  .errnz  (FEM_WIN31 and 0FF00h)  ;
    //  jnz     @f                      ; No,
    //  sub     di, MAXCHARSETS
    //@@:
        //  Save        <es, bx>
        //  cCall       GetCharSetFromLanguage, <lhFontFile>
        //  or      ax, ax         <-- this will be zero if non-far east font
        //  jz      @f
    //
    //  test    bptr fEmbed, FEM_WIN31  ; Want new format?
    //  .errnz  (FEM_WIN31 and 0FF00h)  ;
    //  jnz     MFDOldCharSetOnly       ; No, skip charset array
    //
        //  and     eax, 0ffh
        //  or      eax, (FEOEM_CHARSET shl 8) + (DEFAULT_CHARSET shl 16)
    //  mov     dwptr es:[di], eax
    //MFDOldCharSetOnly:
    //  mov     es:[di-efbaCharSets-1].efbCharSet, al
    //
    // For WIN 95-J compatibility sake I will do the same here [gerritv]
    // If you remove this code in the future be sure to put a check in here
    // to handle the buggy msmincho and msgothic fonts that have FS_CHINESESIMP
    // instead of FS_JAPANESE in the signature. [gerritv]
    //


    if (bDBCSFont &&  pjOS2 &&
        (!(*((uint16*)(pjOS2+SFNT_OS2_VERSION))) ||
        IsBogusSignature((DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1),pff))
    )
    {
        aCharSets[iCS++] = pifi->jWinCharSet;
    }
    else if (pjOS2 && *((uint16 UNALIGNED *)(pjOS2+SFNT_OS2_VERSION)))
    {
        // font signature

        fsig = (DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange1);

    // Jam in the current one first if it is supported:

        if ( (fsig & gfsCurSignature) && !(CSfs & gfsCurSignature) )
          aCharSets[iCS++] = gjCurCharset;

    // now jam in the rest of them:

        for (i=0; i<nCharsets; i++)
        {
          if ( (fs[i] != gfsCurSignature) || (CSfs & gfsCurSignature) )
          {
            if (fsig & fs[i])
              aCharSets[iCS++] = (BYTE)charsets[i];
          }
        }

        // get the codepage value if any.

        fsig = (DWORD)BE_UINT32(pjOS2+OFF_OS2_ulCodePageRange2);
        if (fsig)
        {
            USHORT OemCodePage, AnsiCodePage;

            EngGetCurrentCodePage(&OemCodePage,&AnsiCodePage);

            fsigOEM = 0x80000000L;
            for (i=0; i<NOEMCHARSETS; i++)
            {
                if ((UINT) OemCodePage == oemPages[i])
                {
                    if (fsigOEM & fsig)
                        aCharSets[iCS++] = OEM_CHARSET;
                    break;
                }
                fsigOEM >>= 1;          // move to next OEM page
            }
        }

    // make sure that ifi.jWinCharSet is consistent with whatever we have put in
    // the dpCharSet array. If ifi.jWinCharSet is not one of the charsets in the
    // array fix it so that it is.

    // Example of the font which was not fully consistent and was having enum problems
    // because we were setting jWinCharSet to zero while dpCharSets array was
    // not claiming zero was trado.ttf, arabic font with os/2 table of version 1.0.
    // Signature only claimed arabic charset, but we put zero (rather than arabic)

        for (i = 0; i < iCS; i++)
        {
            if (aCharSets[i] == pifi->jWinCharSet)
                break;
        }

        if (i == iCS) // did not fid it, have to fix it up:
        {
            if( iCS > 0 )
                pifi->jWinCharSet = aCharSets[0];
    // Indic fonts such as Mangal doesn't have charset so aCharSets have garbage values.
    // For this problem, we use DEFAULT_CHARSET instead. This also let Fonts that do not 
    // support any charset be enumerated with DEFAULT_CHARSET
            else
                pifi->jWinCharSet = DEFAULT_CHARSET;        
        }
    }
    else if ((pifi->panose.bFamilyType != PAN_FAMILY_PICTORIAL ) && (giFirstChar < 256))
    {
        if (pCmap)
        {
            if( pifi->fsSelection & 0xff00 )
            {
            // backward compatability. If a value exists here then this is a
            // Win 3.1 foreign font.

                cs = (BYTE)((pifi->fsSelection >> 8) & 0xff) ;
                switch (cs)
                {
                case 0xB2:
                case 0xB3:
                case 0xB4:
                    aCharSets[iCS++] = pifi->jWinCharSet =
                      (EngLpkInstalled() ? 0xb2 : SYMBOL_CHARSET);
                    break;
                default:
                    aCharSets[iCS++] = cs;
                    break;
                }

            }
            else
            {
                FS_ENTRY iRet;
                uint16 glyphIndex, glyphIndex2;
                aCharSets[iCS++] = ANSI_CHARSET;    // 0

                iRet = fs_GetGlyphIDs(pgin, 1, 0x2206, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = MAC_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x03cb, NULL, &glyphIndex);
                iRet = fs_GetGlyphIDs(pgin, 1, 0x03a9, NULL, &glyphIndex2); // upper case omega
                if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
                    aCharSets[iCS++] = GREEK_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x0130, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = TURKISH_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x05d0, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = HEBREW_CHARSET;

            // 451 is obscure glyph, should not require it,
            // we shall keep this for for compat. sake.
            // We shall request 42f which is inverted R as in Toy'R'Us

                iRet = fs_GetGlyphIDs(pgin, 1, 0x0451, NULL, &glyphIndex);
                iRet = fs_GetGlyphIDs(pgin, 1, 0x042F, NULL, &glyphIndex2);
                if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
                    aCharSets[iCS++] = RUSSIAN_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x0148, NULL, &glyphIndex);
                iRet = fs_GetGlyphIDs(pgin, 1, 0x010c, NULL, &glyphIndex2); // C^ ie. Ch
                if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
                    aCharSets[iCS++] = EASTEUROPE_CHARSET;

            // lower case u with accent sign underneath, not present in EE charset

                iRet = fs_GetGlyphIDs(pgin, 1, 0x0173, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = BALTIC_CHARSET;

                iRet = fs_GetGlyphIDs(pgin, 1, 0x2592, NULL, &glyphIndex);
                if (iRet == NO_ERR && glyphIndex != 0)
                    aCharSets[iCS++] = OEM_CHARSET;     // ff
            }
        }
    }
    else if( (giFirstChar >= 0xf000) && (pifi->fsSelection & 0xff00))
    {
    // its a 3.1 oldstyle font. For some reason best known to
    // themselves they decided to put all the fonts in the symbol area and
    // to ignore unicode.
    //
    // HACK! As we know that GDI16 never looks beyond the DEFAULT_CHARSET
    // flag we shove at the end, and we know that there are 14 spare locations
    // in the array, we will use these to store the symbol location where
    // the font is loaded from.  This is a hardcoded value taken from
    // win3.1/Heb/ara/far
    //
    // this isn't the cleanest way to do this, but this affects nothing else
    // in the system so there is no core affected code and it's fast for the
    // LPK. (This is good cause then Chico apps aren't dragged down by bogus
    // 3.1 stuff).

            switch ((BYTE)((pifi->fsSelection >> 8) & 0xff))
            {
            case 0xB1 :               // hebrew case
            case 0xB5 :
                aCharSets[iCS++] = pifi->jWinCharSet =
                  EngLpkInstalled() ? 0xB1 : SYMBOL_CHARSET;
            break;

            case 0xB2 :               // arabic
            case 0xB3 :
            case 0xB4 :
                aCharSets[iCS++] = pifi->jWinCharSet =
                  EngLpkInstalled() ? 0xB2 : SYMBOL_CHARSET;
            }
    }
    else
    {
        aCharSets[iCS++] = pifi->jWinCharSet;
    }


    if (bDBCSFont && (iCS < 16))
    {
        aCharSets[iCS++] = FEOEM_CHARSET;
    }

// Terminate with all DEFAULT_...

    while ( iCS < 16 )
        aCharSets[iCS++] = DEFAULT_CHARSET;

// Mangal.ttf doesn't have support for Latin alphabet
//    ASSERTDD(aCharSets[0] != DEFAULT_CHARSET, "IFI charset array bogus\n");
}

/*************************************************************************\
*
* range validation routines for TrueType tables
*
**************************************************************************/

ULONG GetNumGlyphs(PFONTFILE pff)
{
    PIFIMETRICS     pifi;
    IFIEXTRA        *pifiex;

    /* get maxp->numGlyphs out of IFIEXTRA */
    pifi = &pff->ifi;
    pifiex = (IFIEXTRA *)(pifi + 1);
    return(pifiex->cig);
}

BOOL bValidRangeHDMX(const HDMXHEADER *pHDMXHeader, PFONTFILE pff, ULONG tableSize, ULONG *pulNumRecords, ULONG *pulRecordSize)
{
    if ((sizeof(SIZEOF_SFNT_HDMX) > tableSize) || (BE_UINT16(&pHDMXHeader->Version) != 0))
    {
        WARNING("TTFD:bValidRangeHDMX table too small for header\n");
        return FALSE;
    }

    *pulNumRecords = BE_UINT16(&pHDMXHeader->cRecords);
    *pulRecordSize = (ULONG)SWAPL(pHDMXHeader->cjRecord);
 
    if ( (*pulRecordSize < (SIZEOF_SFNT_HDMXRECORD + GetNumGlyphs(pff))) || ( (*pulRecordSize & 3) != 0) || ( *pulRecordSize == 0) ||
                (*pulNumRecords > (tableSize - sizeof(SIZEOF_SFNT_HDMX)) / (*pulRecordSize) ))
    {
        WARNING("TTFD:bValidRangeHDMX table too small\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeVMTX(ULONG tableSize, ULONG glyphID, ULONG uLongVerticalMetrics)
{
    ULONG currEndPos;

    if (glyphID < uLongVerticalMetrics)
    {
        currEndPos = (glyphID + 1) * (sizeof(USHORT)+sizeof(SHORT));
    }
    else
    {
        currEndPos = uLongVerticalMetrics * (sizeof(USHORT)+sizeof(SHORT)) + (glyphID-uLongVerticalMetrics+1) * sizeof(SHORT);
    }

    if(currEndPos > tableSize)
    {
        WARNING("TTFD:bValidRangeVMTX table too small for header\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeVHEA(ULONG tableSize)
{
    if(sizeof(sfnt_vheaTable) > tableSize)
    {
        WARNING("TTFD:bValidRangeVHEA table too small for header\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeVDMXHeader(const PBYTE pjVdmx, ULONG tableSize, USHORT* numRatios)
{
    if (sizeof(VDMX_HDR) > tableSize) 
    {
        WARNING("TTFD:bValidRangeVDMXHeader table too small for header\n");
        return FALSE;
    }

    *numRatios = SWAPW(((VDMX_HDR  *) pjVdmx)->numRatios);

    if (sizeof(VDMX_HDR)+ *numRatios * ( sizeof(RATIOS)+sizeof(USHORT) ) > tableSize) 
    {
        WARNING("TTFD:bValidRangeVDMXHeader table too small\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeVDMXRecord(ULONG tableSize, ULONG offsetToTableStart)
{
    if ((offsetToTableStart + sizeof(VDMX)) > tableSize) 
    {
        WARNING("TTFD:bValidRangeVDMXRecord table too small for header\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeVDMXvTable(ULONG tableSize, ULONG offsetToTableStart, USHORT numVtable)
{
    if ((offsetToTableStart + sizeof(VDMX) + numVtable * sizeof(VTABLE)) > tableSize) 
    {
        WARNING("TTFD:bValidRangeVDMXvTable table too small for header\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeLTSH(PFONTFILE pff, ULONG tableSize)
{
    // header + one byte per glyph
    if ((offsetof(LTSHHEADER,PelsHeight) + GetNumGlyphs(pff)) > tableSize)
    {
        WARNING("TTFD:bValidRangeLTSH table too small for header\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangePOST(ULONG tableSize)
{
    if (offsetof(sfnt_PostScriptInfo,minMemType42)  > tableSize)
    {
        WARNING("TTFD:bValidRangePOST table too small for header\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangePOSTFormat2(const sfnt_PostScriptInfo *ppost, ULONG tableSize, UINT16 * numGlyphs)
{
    if (offsetof(sfnt_PostScriptInfo,postScriptNameIndices) > tableSize)
    {
        WARNING("TTFD:bValidRangePOSTFormat2 table too small for header\n");
        return FALSE;
    }

    *numGlyphs = BE_UINT16(&ppost->numberGlyphs);

    if ((offsetof(sfnt_PostScriptInfo,postScriptNameIndices) + (*numGlyphs * sizeof(USHORT)))  > tableSize)
    {
        WARNING("TTFD:bValidRangePOSTFormat2 table too small\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeGASP(const GASPTABLE *pgasp, ULONG tableSize, UINT16 * numRanges)
{
    if (offsetof(GASPTABLE,gaspRange) > tableSize)
    {
        WARNING("TTFD:bValidRangeGASP table too small for header\n");
        return FALSE;
    }

    *numRanges = BE_UINT16(&(pgasp->numRanges));

    if ((offsetof(GASPTABLE,gaspRange) + (*numRanges * sizeof(GASPRANGE)))  > tableSize)
    {
        WARNING("TTFD:bValidRangeGASP table too small\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeEBLC(const uint8 *pbyBloc, ULONG tableSize, uint32 * ulNumStrikes)
{
    if (SFNT_BLOC_FIRSTSTRIKE > tableSize)
    {
        WARNING("TTFD:bValidRangeEBLC table too small for header\n");
        return FALSE;
    }

    *ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));

    if (*ulNumStrikes  > (tableSize - SFNT_BLOC_FIRSTSTRIKE) / SIZEOF_BLOC_SIZESUBTABLE)
    {
        WARNING("TTFD:bValidRangeEBLC table too small\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeMORT(PFONTFILE pff)
{
    MortTable      *pMortTable;
    BinSrchHeader  *pHeader;
    USHORT          nEntries;


    if (offsetof(MortTable,entries) > pff->ffca.tp.ateOpt[ IT_OPT_MORT ].cj)
    {
        WARNING("TTFD:bValidRangeMORT table too small for header\n");
        return FALSE;
    }

    pMortTable = (MortTable *)((BYTE *)(pff->pvView) +
                                       (pff->ffca.tp.ateOpt[ IT_OPT_MORT ].dp));

    pHeader = &pMortTable->SearchHeader;

    nEntries = BE_UINT16(&pHeader->nEntries);

    if ((offsetof(MortTable,entries) + (nEntries * sizeof(LookupSingle)))  > pff->ffca.tp.ateOpt[ IT_OPT_MORT ].cj)
    {
        WARNING("TTFD:bValidRangeMORT table too small\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeGSUB(PFONTFILE pff, ULONG *verticalSubtableOffset)
{
    //
    // Check this GSUB table is for Vertical Glyphs ?
    //

    GsubTable   *pGsubTable;
    ScriptList  *pScriptList;
    FeatureList *pFeatureList;
    LookupList  *pLookupList;

    ULONG dpGsubTable;
    ULONG dpScriptList;
    ULONG dpFeatureList;
    ULONG dpLookupList;

    INT    ii;
    USHORT LookupIndex;
    ULONG  VerticalLookupOffset = 0;
    ULONG  VerticalFeatureOffset = 0;
    ULONG tableSize = pff->ffca.tp.ateOpt[ IT_OPT_GSUB ].cj;

    Feature *pFeature;
    Lookup  *pLookup;
    uint16  featureCount;
    SingleSubst *pSingleSubst;
    ULONG  coverageOffset;
    Coverage *pCoverage;
    uint16  glyphCount;

    *verticalSubtableOffset = 0;

    dpGsubTable   = pff->ffca.tp.ateOpt[ IT_OPT_GSUB ].dp;
    pGsubTable    = (GsubTable *)((BYTE *)(pff->pvView) + dpGsubTable);

    if (sizeof(GsubTable) > tableSize)
    {
        WARNING("TTFD:bValidRangeGSUB table too small for header\n");
        return FALSE;
    }

    dpScriptList  = BE_UINT16(&pGsubTable->ScriptListOffset);
    dpFeatureList = BE_UINT16(&pGsubTable->FeatureListOffset);
    dpLookupList  = BE_UINT16(&pGsubTable->LookupListOffset);

    pScriptList  = (ScriptList *)((BYTE *)pGsubTable + dpScriptList);
    pFeatureList = (FeatureList *)((BYTE *)pGsubTable + dpFeatureList);
    pLookupList  = (LookupList *)((BYTE *)pGsubTable + dpLookupList);

    if ((dpScriptList + sizeof(GsubTable) > tableSize) || (dpFeatureList + sizeof(FeatureList) > tableSize) 
        || (dpLookupList + sizeof(LookupList) > tableSize)) 
    {
        WARNING("TTFD:bValidRangeGSUB table too small for feature list\n");
        return FALSE;
    }

    #if DBG_MORE
    TtfdDbgPrint("TTFD!GsubTable   - %x\n",pGsubTable);
    TtfdDbgPrint("TTFD!ScriptList  - %x\n",pScriptList);
    TtfdDbgPrint("TTFD!FeatureList - %x\n",pFeatureList);
    TtfdDbgPrint("TTFD!LookupList  - %x\n",pLookupList);
    #endif

    //
    // Search 'vert' Tag from FeatureList....
    //
    #define tag_vert 0x74726576

    featureCount = BE_INT16(&pFeatureList->FeatureCount);

    if (dpFeatureList + offsetof(FeatureList,FeatureRecord) + featureCount * sizeof(FeatureRecord) > tableSize) 
    {
        WARNING("TTFD:bValidRangeGSUB table too small for FeatureRecord\n");
        return FALSE;
    }

    for( ii = 0;
            ii < featureCount;
            ii++ )
    {
        if( pFeatureList->FeatureRecord[ii].FeatureTag == tag_vert )
        {
            VerticalFeatureOffset = BE_UINT16(
                                        &(pFeatureList->FeatureRecord[ii].FeatureOffset)
                                    );
            #if DBG_MORE
            TtfdDbgPrint("TTFD:VerticalFeature - %x\n",VerticalFeatureOffset);
            #endif
            break;
        }
    }

    //
    // if we could not find out 'vert' tag, this is a not vertical font.
    //

    if( VerticalFeatureOffset == 0 )
    {
        WARNING("TTFD!Could not find 'vert' tag in FeatureList\n");
        return(FALSE);
    }

    //
    // Vertical feature offset contains offset from FeatureList...
    // adjust it to offset from GsubTable..
    //

    VerticalFeatureOffset += dpFeatureList;

    //
    // Compute pointer to Feature offset.
    //

    if (VerticalFeatureOffset + sizeof(Feature) > tableSize) 
    {
        WARNING("TTFD:bValidRangeGSUB table too small for VerticalFeatureOffset\n");
        return FALSE;
    }

    pFeature = (Feature *)((BYTE *)pGsubTable + VerticalFeatureOffset);

    //
    // for Vertical glyph substitution, the lookup count should be 1.
    //

    if( BE_UINT16(&pFeature->LookupCount) != 1 )
    {
        WARNING("TTFD:bValidRangeGSUB pFeature->LookupCount != 1\n");
        return(FALSE);
    }

    //
    // make sure the Lookup list has a entry for this feature....
    //

    LookupIndex = BE_UINT16(&(pFeature->LookupListIndex[0]));

    if( BE_UINT16(&pLookupList->LookupCount) < LookupIndex )
    {
        WARNING("TTFD:bValidRangeGSUB LookupIndex < LookupCount\n");
        return(FALSE);
    }

    //
    // Compute pointer to Lookup..
    //

    if (dpLookupList + sizeof(LookupList) + LookupIndex * sizeof(Offset) > tableSize)
    {
        WARNING("TTFD:bValidRangeGSUB table too small for LookupList\n");
        return FALSE;
    }

    VerticalLookupOffset = BE_UINT16(&(pLookupList->Lookup[LookupIndex]));

    if (dpLookupList + VerticalLookupOffset + sizeof(Lookup) > tableSize)
    {
        WARNING("TTFD:bValidRangeGSUB table too small for Lookup\n");
        return FALSE;
    }

    pLookup = (Lookup *)((BYTE *)pLookupList + VerticalLookupOffset);

    #if DBG_MORE
    TtfdDbgPrint("pLookup - %x\n",pLookup);
    #endif

    //
    // Check Lookup Type, it should be 1 (='Single') for vertical font.
    //

    if( BE_UINT16(&pLookup->LookupType) != 1 )
    {
        WARNING("TTFD!bValidRangeGSUB LookupType != 1\n");
        return(FALSE);
    }

    //
    // Check subtable count.. it should be 1 for vertical font.
    //

    if( BE_UINT16(&pLookup->SubtableCount) != 1 )
    {
        WARNING("TTFD!bValidRangeGSUB SubTableCount != 1\n");
        return(FALSE);
    }

    //
    // Compute offset to subtable from FileTop...
    //

    *verticalSubtableOffset = BE_UINT16(&(pLookup->Subtable[0])) + VerticalLookupOffset + dpLookupList;

    if (*verticalSubtableOffset + offsetof(SingleSubst,Format.Type2.Substitute) > tableSize)
    {
        WARNING("TTFD:bValidRangeGSUB table too small for SingleSubst\n");
        return FALSE;
    }

    pSingleSubst = (SingleSubst *)((BYTE *)(pff->pvView) + dpGsubTable +
                                           (*verticalSubtableOffset));

    //
    // Check subtable format...
    //
    if( BE_UINT16(&pSingleSubst->SubstFormat) != 2 )
    {
        WARNING("TTFD:bValidRangeGSUB SubstFormat != 2\n");
        return FALSE;
    }

    coverageOffset = BE_UINT16(&(pSingleSubst->Format.Type2.Coverage));

    if (*verticalSubtableOffset + coverageOffset + offsetof(Coverage,Format.Type1.GlyphArray) > tableSize)
    {
        WARNING("TTFD:bValidRangeGSUB table too small for Coverage\n");
        return FALSE;
    }

    pCoverage = (Coverage *)
                    ((BYTE *)pSingleSubst +
                    BE_UINT16(&(pSingleSubst->Format.Type2.Coverage)));

    if( BE_UINT16(&pCoverage->CoverageFormat) != 1 )
    {
        WARNING("TTFD:bValidRangeGSUB CoverageFormat != 1\n");
        return FALSE;
    }

    glyphCount = BE_UINT16(&(pCoverage->Format.Type1.GlyphCount));

    if ((*verticalSubtableOffset + coverageOffset + offsetof(Coverage,Format.Type1.GlyphArray) + glyphCount * sizeof(GlyphID) > tableSize) || 
        (*verticalSubtableOffset + offsetof(SingleSubst,Format.Type2.Substitute) + glyphCount * sizeof(GlyphID) > tableSize))
    {
        WARNING("TTFD:bValidRangeGSUB table too small for Substitute list\n");
        return FALSE;
    }
    else
    {
        *verticalSubtableOffset = *verticalSubtableOffset + dpGsubTable;
        return TRUE;
    }
    
}
    
BOOL bValidRangeKERN(const uint8 *pbyKern, ULONG tableSize, uint32 *kerningPairs)
{
    USHORT cTables, subTableLength;
    ULONG subTableOffset = KERN_SIZEOF_TABLE_HEADER;
    *kerningPairs = 0;

    if (KERN_SIZEOF_TABLE_HEADER > tableSize)
    {
        WARNING("TTFD!vFill_IFIMETRICS font has bad kerning table, table header\n");
        return FALSE;
    }

    cTables  = BE_UINT16(pbyKern+KERN_OFFSETOF_TABLE_NTABLES);
    pbyKern += KERN_SIZEOF_TABLE_HEADER;

    while (cTables)
    {
    //
    // Windows will only recognize KERN_WINDOWS_FORMAT
    //

    // make sure this doesn't put us past the file view

        if (subTableOffset + KERN_OFFSETOF_SUBTABLE_FORMAT > tableSize)
        {
            WARNING("TTFD!vFill_IFIMETRICS font has bad kerning table, subTableOffset\n");
            cTables = 0;
            break;
        }

        if ((*(pbyKern+KERN_OFFSETOF_SUBTABLE_FORMAT)) == KERN_WINDOWS_FORMAT)
        {
            break;
        }
        subTableLength = BE_UINT16(pbyKern+KERN_OFFSETOF_SUBTABLE_LENGTH);
        pbyKern += subTableLength;
        subTableOffset += subTableLength;
        cTables -= 1;
    }

    if ((cTables == 0) || (subTableOffset + KERN_SIZEOF_SUBTABLE_HEADER > tableSize))
    {
        WARNING("TTFD!vFill_IFIMETRICS font has bad kerning sub-table, subtableHeaders\n");
        return FALSE;
    }

    *kerningPairs = BE_UINT16(pbyKern+KERN_OFFSETOF_SUBTABLE_NPAIRS);

    if (subTableOffset + KERN_SIZEOF_SUBTABLE_HEADER + (*kerningPairs * KERN_SIZEOF_ENTRY)  > tableSize)
    {
        WARNING("TTFD!vFill_IFIMETRICS font has bad kerning sub-table, entries\n");
        return FALSE;
    }
    else 
        return TRUE;
}

BOOL bValidRangeOS2(const sfnt_OS2 *pOS2, ULONG tableSize)
{
    USHORT version;

    if ( SIZEOF_SFNT_OS2 > tableSize)
    {
        WARNING("TTFD!bValidRangeOS2 table too small\n");
        return FALSE;
    }

    version = BE_UINT16(pOS2+SFNT_OS2_VERSION);

    if ((version > 0) && ( SIZE_OS2_VERSION_1 > tableSize))
    {
        WARNING("TTFD!bValidRangeOS2 table too small, version 1\n");
        return FALSE;
    }
    else 
        return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\fd.h ===
/******************************Module*Header*******************************\
* Module Name: fd.h
*
* file which is going to be included by the most *.c files in this directory.
* Supplies basic types, debugging stuff, error logging and checking stuff,
* error codes, usefull macros etc.
*
* Created: 22-Oct-1990 15:23:44
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#define  IFI_PRIVATE

#include <stddef.h>
#include <stdarg.h>
#include <excpt.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>

typedef ULONG W32PID;

#include "mapfile.h"

#include "fot16.h"
#include "service.h"     // string service routines
#include "tt.h"          // interface to the font scaler
//#include "common.h"

#include "fontfile.h"
#include "cvt.h"
#include "dbg.h"

#define RETURN(x,y)   {WARNING((x)); return(y);}
#define RET_FALSE(x)  {WARNING((x)); return(FALSE);}


#if defined(_AMD64_) || defined(_IA64_)

#define  vLToE(pe,l)           (*(pe) = (FLOATL)(l))

#else   // i386

ULONG  ulLToE (LONG l);
VOID   vLToE(FLOATL * pe, LONG l);

#endif

#define STATIC
#define DWORD_ALIGN(x) (((x) + 3L) & ~3L)
#define QWORD_ALIGN(x) (((x) + 7L) & ~7L)

#if defined(i386)
// natural alignment for x86 is on 32 bit boundary

#define NATURAL           DWORD
#define NATURAL_ALIGN(x)  DWORD_ALIGN(x)

#else
// for mips and alpha we want 64 bit alignment

#define NATURAL           DWORDLONG
#define NATURAL_ALIGN(x)  QWORD_ALIGN(x)

#endif



#define ULONG_SIZE(x)  (((x) + sizeof(ULONG) - 1) / sizeof(ULONG))


// MACROS FOR converting 16.16 BIT fixed numbers to LONG's


#define F16_16TOL(fx)            ((fx) >> 16)
#define F16_16TOLFLOOR(fx)       F16_16TOL(fx)
#define F16_16TOLCEILING(fx)     F16_16TOL((fx) + (Fixed)0x0000FFFF)
#define F16_16TOLROUND(fx)       ((((fx) >> 15) + 1) >> 1)


// MACROS FOR GOING THE OTHER WAY ARROUND

#define LTOF16_16(l)   (((LONG)(l)) << 16)
#define BLTOF16_16OK(l)  (((l) < 0x00007fff) && ((l) > -0x00007fff))

// 16.16 --> 28.4

#define F16_16TO28_4(X)   ((X) >> 12)

// going back is not always legal

#define F28_4TO16_16(X)   ((X) << 12)
#define B28_4TO16_16OK(X) (((X) < 0x0007ffff) && ((X) > -0x0007ffff))

// 26.6 --> 16.16, never go the other way

#define F26_6TO16_16(X)   ((X) << 10)
#define B26_6TO16_16OK(X) (((X) < 0x003fffff) && ((X) > -0x003fffff))

// sin of 20 degrees in 16.16 notation, however computed only with
// 8.8 presission to be fully win31 compatible, SEE gdifeng.inc, SIM_ITALIC
// SIM_ITALIC equ 57h

#define FX_SIN20 0x5700
#define FX_COS20 0xF08F

// CARET_Y/CARET_X = tan 12
// these are the values for arial italic from hhead table

#define CARET_X  0X07
#define CARET_Y  0X21


#if DBG
VOID vFSError(FS_ENTRY iRet);
#define V_FSERROR(iRet) vFSError((iRet))
#else
#define V_FSERROR(iRet)
#endif

#pragma pack(1)
typedef struct
{
  unsigned short  Version;
  unsigned short  cGlyphs;
  unsigned char   PelsHeight[1];
} LTSHHEADER;

typedef struct
{
  BYTE    bCharSet;       // Character set (0=all glyphs, 1=Windows ANSI subset
  BYTE    xRatio;         // Value to use for x-Ratio
  BYTE    yStartRatio;    // Starting y-Ratio value
  BYTE    yEndRatio;      // Ending y-Ratio value
}  RATIOS;

typedef struct
{
  USHORT  version;        // Version number for table (starts at 0)
  USHORT  numRecs;        // Number of VDMX groups present
  USHORT  numRatios;      // Number of aspect ratio groupings
} VDMX_HDR;

typedef struct
{
  USHORT  yPelHeight;     // yPelHeight (PPEM in Y) to which values apply
  SHORT   yMax;           // yMax (in pels) for this yPelHeight
  SHORT   yMin;           // yMin (in pels) for this yPelHeight
} VTABLE;

typedef struct
{
  USHORT  recs;           // Number of height records in this group.
  BYTE    startsz;        // Starting yPelHeight
  BYTE    endsz;          // Ending yPelHeight
} VDMX;

//
// Glyph Metamorphosis table (mort) structures
//
typedef struct {
    uint16  entrySize;      // size in bytes of a lookup entry ( should be 4 )
    uint16  nEntries;       // number of lookup entries to be searched
    uint16  searchRange;
    uint16  entrySelector;
    uint16  rangeShift;
} BinSrchHeader;

typedef struct {
    uint16  glyphid1;       // the glyph index for the horizontal shape
    uint16  glyphid2;       // the glyph index for the vertical shape
} LookupSingle;

typedef struct {
    BYTE           constants1[12];
    uint32         length1;
    BYTE           onstants2[16];
    BYTE           constants3[16];
    BYTE           constants4[8];
    uint16         length2;
    BYTE           constants5[8];
    BinSrchHeader  SearchHeader;
    LookupSingle   entries[1];
} MortTable;

//
// Glyph Substitution table (GSUB) structures
//

typedef uint16  Offset;
typedef uint16  GlyphID;
typedef ULONG   Tag;

typedef struct {
    GlyphID         Start;
    GlyphID         End;
    uint16          StartCoverageIndex;
} RangeRecord;

typedef struct {
    uint16          CoverageFormat;
    union {
        struct {
            uint16  GlyphCount;
            GlyphID GlyphArray[1];
        } Type1;
        struct {
            uint16  RangeCount;
            RangeRecord RangeRecord[1];
        } Type2;
    } Format;
} Coverage;

typedef struct {
    uint16          SubstFormat;
    union {
        struct {
            Offset  Coverage;
            uint16  DeltaGlyphID;
        } Type1;
        struct {
            Offset  Coverage;
            uint16  GlyphCount;
            GlyphID Substitute[1];
        } Type2;
    } Format;
} SingleSubst;

typedef struct {
    uint32         Version;
    Offset         ScriptListOffset;
    Offset         FeatureListOffset;
    Offset         LookupListOffset[1];
} GsubTable;

typedef struct {
    uint16         LookupType;
    uint16         LookupFlag;
    uint16         SubtableCount;
    Offset         Subtable[1];
} Lookup;

typedef struct {
    uint16         LookupCount;
    Offset         Lookup[1];
} LookupList;

typedef struct {
    Offset         FeatureParams;
    uint16         LookupCount;
    uint16         LookupListIndex[1];
} Feature;

typedef struct {
    Tag            FeatureTag;
    Offset         FeatureOffset;
} FeatureRecord;

typedef struct {
    uint16         FeatureCount;
    FeatureRecord  FeatureRecord[1];
} FeatureList;

typedef struct {
    Offset         LookupOrderOffset;
    uint16         ReqFeatureIndex;
    uint16         FeatureCount;
    uint16         FeatureIndex[1];
} LangSys;

typedef struct {
    Tag            LangSysTag;
    Offset         LangSysOffset;
} LangSysRecord;

typedef struct {
    Offset         DefaultLangSysOffset;
    uint16         LangSysCount;
    LangSysRecord  LangSysRecord[1];
} Script;

typedef struct {
    Tag            ScriptTag;
    Offset         ScriptOffset;
} ScriptRecord;

typedef struct {
    uint16         ScriptCount;
    ScriptRecord   ScriptRecord[1];
} ScriptList;

#pragma pack()

FD_GLYPHSET *pgsetComputeSymbolCP();

DHPDEV
ttfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver
    );

VOID
ttfdDisablePDEV(
    DHPDEV  dhpdev
    );

VOID
ttfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev
    );

LONG
ttfdQueryFontCaps (
    ULONG culCaps,
    PULONG pulCaps
    );

BOOL
ttfdUnloadFontFile (
    HFF hff
    );

BOOL
ttfdUnloadFontFileTTC (
    HFF hff
    );

PFD_GLYPHATTR
ttfdQueryGlyphAttrs (
    FONTOBJ *pfo
    );

LONG
ttfdQueryFontFile (
    HFF     hff,
    ULONG   ulMode,
    ULONG   cjBuf,
    PULONG  pulBuf
    );

PIFIMETRICS
ttfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR *pid
    );

PVOID
ttfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
    );

LONG
ttfdQueryFontData (
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

VOID
ttfdFree (
    PVOID pv,
    ULONG_PTR id
    );

VOID
ttfdDestroyFont (
    FONTOBJ *pfo
    );

LONG
ttfdQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifyint the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    PBYTE   pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in otf file
    ULONG  *cjTable  // size of table
    );


LONG
ttfdQueryTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // glyph for which info is wanted
    BOOL       bMetricsOnly,   // only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // this is where the metrics should be returned
    ULONG      cjBuf,          // size in bytes of the ppoly buffer
    TTPOLYGONHEADER *ppoly
    );

PVOID ttfdGetTrueTypeFile(HFF hff,ULONG *pcj);

LONG ttfdQueryFontFile
(
    HFF     hff,
    ULONG   ulMode,
    ULONG   cjBuf,
    ULONG  *pulBuf
);

BOOL
bQueryAdvanceWidths (
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
    );

BOOL bLoadFontFile (
    ULONG_PTR iFile,
    PVOID pvView,
    ULONG cjView,
    ULONG ulLangId,
    ULONG ulFastCheckSum,
    HFF   *phttc
    );

FD_GLYPHSET *
pgsetRunSplitFor5C(
    FD_GLYPHSET * pOldgset
    );

typedef struct _NOT_GM  // ngm, notional glyph metrics
{
    SHORT xMin;
    SHORT xMax;
    SHORT yMin;   // char box in notional
    SHORT yMax;
    SHORT sA;     // a space in notional
    SHORT sD;     // char inc in notional

} NOT_GM, *PNOT_GM;

extern BYTE  gjCurCharset;
extern DWORD gfsCurSignature;

/*************************************************************************\
*
* range validation routines for TrueType tables
*
**************************************************************************/

ULONG GetNumGlyphs(PFONTFILE pff);
BOOL bValidRangeHDMX(const HDMXHEADER *pHDMXHeader, PFONTFILE pff, ULONG tableSize, ULONG *pulNumRecords, ULONG *pulRecordSize);
BOOL bValidRangeVMTX(ULONG tableSize, ULONG glyphID, ULONG uLongVerticalMetrics);
BOOL bValidRangeVHEA(ULONG tableSize);
BOOL bValidRangeVDMXHeader(const PBYTE pjVdmx, ULONG tableSize, USHORT* numRatios);
BOOL bValidRangeVDMXRecord(ULONG tableSize, ULONG offsetToTableStart);
BOOL bValidRangeVDMXvTable(ULONG tableSize, ULONG offsetToTableStart, USHORT numVtable);
BOOL bValidRangeLTSH(PFONTFILE pff, ULONG tableSize);
BOOL bValidRangePOST(ULONG tableSize);
BOOL bValidRangePOSTFormat2(const sfnt_PostScriptInfo *ppost, ULONG tableSize, UINT16 * numGlyphs);
BOOL bValidRangeGASP(const GASPTABLE *pgasp, ULONG tableSize, UINT16 * numRanges);
BOOL bValidRangeEBLC(const uint8 *pbyBloc, ULONG tableSize, uint32 * ulNumStrikes);
BOOL bValidRangeMORT(PFONTFILE pff);
BOOL bValidRangeGSUB(PFONTFILE pff, ULONG *verticalSubtableOffset);
BOOL bValidRangeKERN(const uint8 *pbyKern, ULONG tableSize, uint32 *kerningPairs);
BOOL bValidRangeOS2(const sfnt_OS2 *pOS2, ULONG tableSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\fd_poly.c ===
/******************************Module*Header*******************************\
* Module Name: fd_poly.c
*
* stolen from win31 tt code
*
* Created: 10-Feb-1992 17:10:39
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/

#include "fd.h"
#include "winerror.h"

STATIC VOID vQsplineToPolyBezier (
    ULONG      cBez,          // IN  count of curves to convert to beziers format
    POINTFIX * pptfixStart,   // IN  starting point on the first curve
    POINTFIX * pptfixSpline,  // IN  array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
    POINTFIX * pptfixBez      // OUT buffer to be filled with 3 * cBez poly bezier control points
    );


BOOL bGeneratePath (
    PATHOBJ         * ppo,        // IN OUT pointer to the path object to be generated
    TTPOLYGONHEADER * ppolyStart, // IN     pointer to the buffer with outline data
    ULONG             cj,         // IN     size of the buffer
    ULONG           * pcjOut,      // OUT   size of needed bezier buffer
    TTPOLYGONHEADER * ppolyBeziers // OUT   buffer with Bezier outline data
    );

#if DBG

// #define DBG_POLYGON

#endif

VOID vFillSingularGLYPHDATA(HGLYPH,ULONG,FONTCONTEXT*,GLYPHDATA*);
VOID vFillGLYPHDATA(HGLYPH,ULONG,FONTCONTEXT*,fs_GlyphInfoType*,GLYPHDATA*,GMC*,POINTL*);
BOOL bGetGlyphMetrics(FONTCONTEXT*,HGLYPH,FLONG,FS_ENTRY*);

/******************************Public*Routine******************************\
*
* void Scale_16DOT16
*
*
* Effects: 26.6 -> 16.16
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* stole it from jeanp and modified for nt
\**************************************************************************/

//!!! some checks should be put in so as to verify that 26.6 -> 16.16
//!!! conversion can be done without loosing information [bodind]

void Scale_16DOT16 (POINTFX  *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
    LONG lTmp;

#ifdef  DBG_POLYGON

    xLsb2Org;
    yLsb2Org;

    lTmp = (LONG)x;
    ppfx->x = * (FIXED *) &lTmp;

    lTmp = (LONG)y;
    ppfx->y = * (FIXED *) &lTmp;

#else // true version

// for this to work the following assert must be true:

    ASSERTDD(sizeof(LONG) == sizeof(FIXED), "_Scale 16.16 \n");

    lTmp = (LONG) ((x - xLsb2Org) << 10);
    ppfx->x = * (FIXED *) &lTmp;

    lTmp = (LONG) ((y - yLsb2Org) << 10);
    ppfx->y = * (FIXED *) &lTmp;

#endif //  DBG_POLYGON
}


/******************************Public*Routine******************************\
*
* void Scale_28Dot4
*
*
* Effects: 26.6 -> 28.4
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* wrote it
\**************************************************************************/

void Scale_28DOT4 (POINTFX  *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
    LONG lTmp;

// for this to work the following assert must be true:

    ASSERTDD(sizeof(LONG) == sizeof(FIXED), "Scale, 28.4\n");

    lTmp = (LONG) ((x - xLsb2Org) >> 2);
    ppfx->x = * (FIXED *) &lTmp;

// note that the sign of y coordinate differs from the 16.16 case

    lTmp = - (LONG) ((y - yLsb2Org) >> 2);
    ppfx->y = * (FIXED *) &lTmp;
}


/******************************Public*Routine******************************\
*
* Scale_None
*
* Called when only the size of the ppoly buffer is wanted
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void Scale_None (POINTFX *ppfx, F26Dot6 x, F26Dot6 y, int xLsb2Org, int yLsb2Org)
{
  ppfx;
  x;
  y;
  xLsb2Org;
  yLsb2Org;

  return;
}


/******************************Public*Routine******************************\
*
* cjFillPolygon
*
* Effects: fills in the array of structures that describe glyph's
*          outline. There is one polygonheader stuct for every closed contour
*          that composes the glyph. A polygon headed structure is followed
*          by an array of polycurve structure that describe composite curves
*          of a closed contour.
*
* Note: if pBuffer is NULL or cb is 0, then it is assumed that the caller
*       only wants the size of the buffer required.
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it. (stole it from JeanP's win31 code and addapted for NT)
\**************************************************************************/

UINT cjFillPolygon(
    PFONTCONTEXT pfc,
    BOOL         b16Dot16,  // FORMAT of the points, 16.16 or 28.4
    PBYTE        pBuffer,
    UINT         cb
    )
{
  BOOL            bGetLength = ( (pBuffer == (PBYTE)NULL) || (cb == 0) );
  uint16          nc = pfc->pgout->numberOfContours;
  uint8           *pbOnCurve = pfc->pgout->onCurve;
  int16           *sp = pfc->pgout->startPtr;
  int16           *ep = pfc->pgout->endPtr;
  F26Dot6         *x = pfc->pgout->xPtr;
  F26Dot6         *y = pfc->pgout->yPtr;
  BYTE            *pBuf = pBuffer;
  BYTE            *pStart = pBuf;
  BYTE            *pEnd = pStart + (bGetLength ? -1 : cb);
  TTPOLYGONHEADER *pPoly;
  TTPOLYCURVE     *pCurve;
  POINTFX         *ppfxStart;
  POINTFX         *pptfx;

  uint16      iContour;   //  index into a contour
  int16       iptEnd, cpt;
  int16       ipt = 0; // follows the points on the contour

  uint8        ucMask;
  void        (*Scale)(POINTFX *ppfx, F26Dot6 x, F26Dot6 y, int xlsb, int ylsb);

  int       xLsb2Org;
  int       yLsb2Org;

  if (!pfc->pgout->outlinesExist)
    return 0;

  if (!bGetLength) // we are actually filling in the information
  {

  #ifdef  DBG_POLYGON
    TtfdDbgPrint(" BEGIN NEW GLYPH \n\n");
    vDbgGridFit(pfc->pgout);
  #endif //  DBG_POLYGON

    if (b16Dot16)
    {
      Scale = Scale_16DOT16;
    }
    else  // scale to 28.4 format
    {
      Scale = Scale_28DOT4;
    }
  }
  else // just computing the size of the buffer needed to store the information
  {
    Scale = Scale_None;
  }

// Compute the delta between the referencial origin and dev left bearing

  cpt = (int16)(ep[nc - 1] + 1);  // total number of points in a contour

  xLsb2Org = x [cpt];  // LEFTSIDEBEARING == 0
  yLsb2Org = y [cpt];  // LEFTSIDEBEARING == 0

  for (iContour = 0; iContour < nc; iContour++)
  {
     // make sure that ipt points to the firts point on a contour upon entry
     // to the loop

    ipt    = sp [iContour];
    iptEnd = ep [iContour];

      // skip contour made of one point
    if (ipt == iptEnd)
    {
      continue; // go to the starting point of the next contour,
    }

    x = &pfc->pgout->xPtr[ipt];
    y = &pfc->pgout->yPtr[ipt];

    if (!bGetLength)
    {
      pPoly = (TTPOLYGONHEADER *) pBuf; //!!! dangerous, alignment [bodind]
      pPoly->dwType = TT_POLYGON_TYPE;
      ppfxStart = &pPoly->pfxStart;

    #ifdef  DBG_POLYGON
      TtfdDbgPrint("Begin Polygon\n\n");
    #endif //  DBG_POLYGON
    }

    pBuf += sizeof (TTPOLYGONHEADER);

      // The first point on the curve
    if (pbOnCurve[ipt] & 1)
    {
        //Easy case
      (*Scale) (ppfxStart, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
      ++ipt;
    }
    else
    {
        // Is last contour point on the curve
      if (pbOnCurve[iptEnd] & 1)
      {
          //Make the last point the first point and decrement the last point
        (*Scale) (ppfxStart, x[iptEnd - ipt], y[iptEnd - ipt], xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
      }
      else
      {
          //First and last point are off the countour, fake a mid point
        (*Scale) (ppfxStart, (x[iptEnd - ipt] + *x) >> 1, (y[iptEnd - ipt] + *y) >> 1, xLsb2Org, yLsb2Org);
      }
    }

    while (ipt <= iptEnd)
    {
      pCurve = (TTPOLYCURVE *) pBuf;
      pptfx = pCurve->apfx;
      ucMask = (int8) (1 & (~pbOnCurve[ipt]));
      if (!bGetLength)
      {
          // if mid point not on the curve this is qspline, this is midpoint
          // because the starting point is in the previous record [bodind]
        pCurve->wType = (WORD)((ucMask == 0) ? TT_PRIM_LINE : TT_PRIM_QSPLINE);
      }
        // Set up the POLYCURVE
      while ((ipt <= iptEnd) && ((pbOnCurve[ipt] & 1) ^ ucMask))
      {
          // Check overflow
        if (pEnd < (BYTE *)(pptfx + 1))
          return FD_ERROR;

        (*Scale) (pptfx++, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
        ipt++;
      }

      if (ucMask == 1) // if this curve is a qspline
      {
          // Check overflow
        if (pEnd < (BYTE *)(pptfx + 1))
          return FD_ERROR;

         // Set up the end point
        if (ipt <= iptEnd)
        {
          ASSERTDD(pbOnCurve[ipt] & 1, " end point not on the curve\n");
          (*Scale) (pptfx, *x++, *y++, xLsb2Org, yLsb2Org);  // 26.6 -> 16.16
          ipt++;
        }
        else
        {
           // close the contour
          if (!bGetLength)
             *pptfx = *ppfxStart;
        }
        pptfx++;
      }
      if (!bGetLength)
      {
        pCurve->cpfx = (WORD)(pptfx - pCurve->apfx);
      #ifdef DBG_POLYGON
        vDbgCurve(pCurve);
      #endif // DBG_POLYGON
      }

      pBuf = (BYTE *) pptfx;
    }

    if (!bGetLength)
    {
      pPoly->cb = (DWORD) (pBuf - (BYTE *) pPoly);
      #ifdef DBG_POLYGON
        TtfdDbgPrint("\n end polygon, pPoly->cb = %ld\n\n", pPoly->cb);
      #endif // DBG_POLYGON
    }
  }
  #ifdef  DBG_POLYGON
    if (!bGetLength)
        TtfdDbgPrint("\n END NEW GLYPH \n\n");
  #endif //  DBG_POLYGON

  return (UINT) (pBuf - pStart);
}


/******************************Public*Routine******************************\
*
* lQuerySingularTrueTypeOutline
*
* Effects:
*
* Warnings:
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




LONG lQuerySingularTrueTypeOutline(
    PFONTCONTEXT pfc,            // IN
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    GLYPHDATA *   pgldt          // OUT this is where the metrics should be returned
    )
{
    FS_ENTRY     iRet;
    ULONG        ig; // <--> hglyph

// hglyph is valid, either asking about the size for that particular
// glyph bitmap, or want the bitmap itself

    vCharacterCode(hglyph,pfc->pgin);

// compute the glyph index from the character code:

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        RET_FALSE("TTFD!_lQuerySingularTrueTypeOutline, fs_NewGlyph\n");
    }

// return the glyph index corresponding to this hglyph:

    ig = pfc->pgout->glyphIndex;

// must call cjFillPolygon now since fsFindBitmapSize messes up outline
// data in pgout

// fill all of GLYPHDATA structure

    if (pgldt != (GLYPHDATA *)NULL)
    {
        vFillSingularGLYPHDATA(hglyph,ig,pfc,pgldt);
    }

// now check whether the caller is asking about the size of the buffer
// needed to store the array of POLYGONHEADER structures:

    return 0; // nothing written to the ppoly buffer
}


/******************************Public*Routine******************************\
*
* LONG lQueryTrueTypeOutline
*
*
* Effects:
*
* Warnings:
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lQueryTTOutline(
    PFONTCONTEXT pfc,            // IN
    BOOL         b16Dot16,       // IN  format of the points, 16.16 or 28.4
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    BOOL         bMetricsOnly,   // IN  only metrics is wanted, not the outline
    BOOL         bUnhinted,      //     unhinted
    GLYPHDATA *   pgldt,          // OUT this is where the metrics should be returned
    ULONG        cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly      // OUT output buffer
    )
{
    FS_ENTRY     iRet;
    LONG         cjRet;
    ULONG        ig = pfc->gstat.igLast;

// check if the rasterizer would behave unpolitely for this xform:

    if (pfc->flXform & XFORM_SINGULAR)
        return lQuerySingularTrueTypeOutline(
                    pfc,
                    hglyph,
                    pgldt);

// check the last glyph processed to determine
// whether we have to register the glyph as new and compute its size

    if ((pfc->gstat.hgLast != hglyph) || bUnhinted || pfc->gstat.bOutlineIsMessed)
    {
        extern BOOL bGetGlyphOutline(FONTCONTEXT*,HGLYPH,ULONG*,FLONG,FS_ENTRY*);

        FLONG flOutline = bUnhinted ? FL_FORCE_UNHINTED : 0;

        // DO NOT skip grid fitting even if embedded bitmpas are found,
        // for we will be interested in outlines -+
        //                                        |
        //                                        |
        if ( !bGetGlyphOutline(pfc, hglyph , &ig, flOutline, &iRet) )
        {
            V_FSERROR(iRet);
            RETURN("lQueryTTOutline: bGetGlyphOutline failed\n", FD_ERROR);
        }
        pfc->gstat.bOutlineIsMessed = FALSE;
    }

// we know that at this point pfc->gstat.bOutlineIsMessed == FALSE

// must call cjFillPolygon now since fsFindBitmapSize messes up outline
// data in pgout

    if (!(bMetricsOnly & TTO_METRICS_ONLY))
    {
        if ((cjRet = cjFillPolygon(pfc, b16Dot16, (PBYTE)ppoly, cjBuf)) == FD_ERROR)
            RETURN("TTFD!_cjFillPolygon failed\n", FD_ERROR);

        if (cjRet && ppoly && pfc->bVertical && (pfc->ulControl & VERTICAL_MODE))
        {
            ULONG        igTemp = pfc->gstat.igLast;

            pfc->gstat.igLast = ig; 

            // vShiftOutlineInfo is using metrics that are computed in fs_FindBitMapSize

            pfc->gstat.bOutlineIsMessed = TRUE; // fs_FindBitMapSize might mess the outline by calling fsc_RemoveDups

            if ((iRet = fs_FindBitMapSize(pfc->pgin, pfc->pgout)) != NO_ERR)
            {
                EngSetLastError(ERROR_CAN_NOT_COMPLETE);
                V_FSERROR(iRet);
                RETURN("lQueryTTOutline: fs_FindBitMapSize failed\n", FD_ERROR);
            }

            vShiftOutlineInfo(pfc, b16Dot16, (PBYTE)ppoly, cjRet);
            pfc->gstat.igLast = igTemp;
        }
    }
    else // nothing will be written to ppoly buffer
    {
        cjRet = 0;
    }

// fill all of GLYPHDATA structure

    if (pgldt != (GLYPHDATA *)NULL)
    {
        // we only need to call fs_FindBitMapSize if GLYPHDATA is requested

        if (!pfc->gstat.bOutlineIsMessed)
        {
        // we haven't meesed the outline yet (ie called fs_FindBitMapSize for vertical writing vShiftOutlineInfo)
        // now is the time to do it
            pfc->gstat.bOutlineIsMessed = TRUE; // fs_FindBitMapSize might mess the outline by calling fsc_RemoveDups

            if ((iRet = fs_FindBitMapSize(pfc->pgin, pfc->pgout)) != NO_ERR)
            {
                EngSetLastError(ERROR_CAN_NOT_COMPLETE);
                V_FSERROR(iRet);
                RETURN("lQueryTTOutline: fs_FindBitMapSize failed\n", FD_ERROR);
            }
        }

        if ( pfc->bVertical && pfc->ulControl & VERTICAL_MODE )
        {
        // Vertical case
            fs_GlyphInfoType  my_gout;

            vShiftBitmapInfo( pfc, &my_gout, pfc->pgout );
            vFillGLYPHDATA(
                pfc->hgSave,         // this is a little bit tricky. we wouldn't like to
                ig,                  // tell GDI about vertical glyph index.
                pfc,
                &my_gout,
                pgldt,
                (PGMC)NULL, NULL);
        }
        else
        {
        // Normal case
            vFillGLYPHDATA(
                hglyph,
                ig,
                pfc,
                pfc->pgout,
                pgldt,
                (PGMC)NULL, NULL);
        }
    }

    // now that everything is computed sucessfully, we can update
    // glyphstate (hg data stored in pj3) and return

    if (!bUnhinted)
    {
        pfc->gstat.hgLast = hglyph;
        pfc->gstat.igLast = ig;
    }
    else
    {
        vInitGlyphState(&pfc->gstat);
    }

    return cjRet;
}


LONG lQueryTrueTypeOutlineVertical(
    PFONTCONTEXT pfc,            // IN
    BOOL         b16Dot16,       // IN  format of the points, 16.16 or 28.4
    HGLYPH       hglyph,         // IN  glyph for which info is wanted
    BOOL         bMetricsOnly,   // IN  only metrics is wanted, not the outline
    BOOL         bUnhinted,      // IN  hinted or unhinted outlines
    GLYPHDATA   *pgd,            // OUT this is where the metrics should be returned
    ULONG        cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly      // OUT output buffer
    )
{
    LONG     cjGlyphData;

    if (!IsFullWidthCharacter (pfc->pff, hglyph))
    {
        return (lQueryTTOutline(pfc,
                                      b16Dot16,
                                      hglyph,
                                      bMetricsOnly,bUnhinted,
                                      pgd, cjBuf, ppoly ));
    }

    // change the transformation

    if (!bChangeXform( pfc, TRUE ) )
    {
        WARNING("TTFD!bChangeXform(TRUE) failed\n");
        return FD_ERROR;
    }

    // set vertical mode

    pfc->ulControl |= VERTICAL_MODE;

    pfc->hgSave = hglyph;

    // call ordinary function

    cjGlyphData = lQueryTTOutline(pfc,
                                        b16Dot16,
                                        hglyph,
                                        bMetricsOnly, bUnhinted,
                                        pgd, cjBuf, ppoly );


    // restore the transformation and return

    if ( ! bChangeXform( pfc, FALSE ) )
    {
        WARNING("TTFD!bChangeXform(FALSE) failed\n");
    }
    pfc->ulControl &= ~VERTICAL_MODE;
    return(cjGlyphData);
}




/******************************Public*Routine******************************\
*
* LONG ttfdQueryTrueTypeOutline
*
*
* Effects:
*
* Warnings:
*
* History:
*  12-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryQuadTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // IN  glyph for which info is wanted
    BOOL       bMetricsOnly,   // IN  only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // OUT this is where the metrics should be returned
    ULONG      cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly    // IN OUT  output buffer
    )
{
    FONTCONTEXT *pfc;
	USHORT usOverScale;
    BOOL     bUnhinted = (bMetricsOnly & TTO_UNHINTED) ? TRUE : FALSE;

    bMetricsOnly = (bMetricsOnly & ~TTO_UNHINTED);

    ASSERTDD(pfo->iFile, "ttfdQueryTrueTypeOutline, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("TTFD!ttfdQueryTrueTypeOutline: file is gone\n");
        return FD_ERROR;
    }
//
// If pfo->pvProducer is NULL, then we need to open a font context.
//
    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        WARNING("TTFD!gdisrv!ttfdQueryTrueTypeOutline(): cannot create font context\n");
        return FD_ERROR;
    }
    pfc->pfo = pfo;

// call fs_NewTransformation if needed:

// ClaudeBe 1/22/98 :
//
// for backwards compatibility, we always return the BW version of the outline
// (TrueType rasterizer 1.7 allow specific grayscale hinting)
//
// the code could be :
//
//	if (IS_GRAY(pfc))
//	{
//		usOverScale = 4;
//	}
//	else
//	{
//		usOverScale = 0;
//	}
//
// but then we would need to copy the outline from gout, before calling fs_FindBitmapSize
// to avoid getting an overscaled outline
// For the same reason we force bClearType to FALSE

    usOverScale = 0;

    if (!bGrabXform(
           pfc,
           usOverScale, // zero usOverScale, do not want overscaled outline
           FALSE,  // outline code path, no bitmap emboldening simulation
           FALSE   // outline code path, bClearType set to FALSE
           ))
        RETURN("gdisrv!ttfd  bGrabXform failed\n", FD_ERROR);

    if( pfc->bVertical )
    {
        return  lQueryTrueTypeOutlineVertical(pfc,
                                              TRUE, // b16Dot16 is true, this is the
                                                    //  desired format
                                              hglyph,
                                              bMetricsOnly, bUnhinted,
                                              pgldt,
                                              cjBuf,
                                              ppoly);
    }
    else
    {
        return  lQueryTTOutline(pfc,
                                      TRUE, // b16Dot16 is true, this is the desired
                                            // format
                                      hglyph,
                                      bMetricsOnly, bUnhinted,
                                      pgldt,
                                      cjBuf,
                                      ppoly);
    }
}



/******************************Public*Routine******************************\
*
*  now supports returning data in bezier format as well
*
* ttfdQueryTrueTypeOutline
*
* History:
*  24-Oct-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



LONG ttfdQueryTrueTypeOutline (
    FONTOBJ   *pfo,
    HGLYPH     hglyph,         // IN  glyph for which info is wanted
    BOOL       bMetricsOnly,   // IN  only metrics is wanted, not the outline
    GLYPHDATA *pgldt,          // OUT this is where the metrics should be returned
    ULONG      cjBuf,          // IN  size in bytes of the ppoly buffer
    TTPOLYGONHEADER * ppoly    // IN OUT  output buffer
    )
{

    LONG lRet = FD_ERROR;

    if (bMetricsOnly & TTO_QUBICS)
    {
    // in this case we have to get the quadratic data first:

        LONG cjBufQuad, cjBufQuad2;
        TTPOLYGONHEADER * ppolyQuad;

        cjBufQuad = ttfdQueryQuadTrueTypeOutline (pfo,
                                          hglyph,
                                          (bMetricsOnly & TTO_UNHINTED),
                                          pgldt,
                                          0,     // cjBufQuad
                                          NULL); // ppolyQuad

        if (cjBufQuad && (cjBufQuad != FD_ERROR))
        {
            if (ppolyQuad = (TTPOLYGONHEADER *)PV_ALLOC(cjBufQuad))
            {

                cjBufQuad2 = ttfdQueryQuadTrueTypeOutline (pfo,
                                          hglyph,
                                          (bMetricsOnly & TTO_UNHINTED),
                                          pgldt,
                                          cjBufQuad,  // cjBufQuad
                                          ppolyQuad); // ppolyQuad


                if (cjBufQuad2 && (cjBufQuad2 != FD_ERROR))
                {
                    ULONG cjBufBez;

                    ASSERTDD(cjBufQuad == cjBufQuad2, "ttfd, cjBufQuad != cjBufQuad2\n");
                    if (bGeneratePath(NULL, // ppo
                                      ppolyQuad,
                                      (ULONG)cjBufQuad,
                                      &cjBufBez,
                                      ppoly))
                    {
                        lRet = (LONG)cjBufBez;
                    }
                }

                V_FREE(ppolyQuad);
            }
        }
    }
    else
    {
        lRet = ttfdQueryQuadTrueTypeOutline (pfo,
                                             hglyph,
                                             bMetricsOnly,
                                             pgldt,
                                             cjBuf,
                                             ppoly);
    }

    return lRet;
}



/******************************Public*Routine******************************\
*
* ttfdQueryGlyphOutline
*
*
*
* History:
*  12-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL ttfdQueryGlyphOutline (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgldt,
    PATHOBJ     *ppo        // pointer to path to be built
    )
{
    LONG             cjAllPolygons, cjAllPolygons2;
    BOOL             bOk;

    if (ppo == NULL)
    {
    // if ppo == NULL, the caller wants metrics only:

        ASSERTDD(pgldt, "ttfdQueryGlyphOutline, pgldt NULL\n");

        if(pfc->bVertical)
        {
            cjAllPolygons =
              lQueryTrueTypeOutlineVertical
                (
                 pfc,              // lpMat2 is incorporated into this fc
                 FALSE,            // NOT 16.16 i.e. 28.4
                 hglyph,           // glyph for which info is wanted
                 TTO_METRICS_ONLY,             // DO just metrics, do NOT do outline
                 FALSE,            // hinted
                 pgldt,            // STORE the result here
                 0,                // size in bytes of the ppoly buffer
                 (TTPOLYGONHEADER *)NULL // do not need it
                );
        }
        else
        {
            cjAllPolygons =
              lQueryTTOutline
                (
                 pfc,              // lpMat2 is incorporated into this fc
                 FALSE,            // NOT 16.16 i.e. 28.4
                 hglyph,           // glyph for which info is wanted
                 TTO_METRICS_ONLY, // DO just metrics, do NOT do outline
                 FALSE,            // hinted
                 pgldt,            // STORE the result here
                 0,                // size in bytes of the ppoly buffer
                 (TTPOLYGONHEADER *)NULL // do not need it
                 );
        }

    // interpret the result, if zero for polygons, we succeded
    // glyph data was filled in and no polygon computation has been
    // performed.
    // if FD_ERROR we did not, no other result should be possible

        if (cjAllPolygons == 0)
            return TRUE;
        else
        {
            ASSERTDD(cjAllPolygons == FD_ERROR,
                     "ttfdQueryGlyphOutline, pgldt == NULL\n");
            return FALSE;
        }

    }

// first learn how big a buffer we need for all polygons:

    if( pfc->bVertical )
    {
        cjAllPolygons =
          lQueryTrueTypeOutlineVertical
            (
             pfc,              // lpMat2 is incorporated into this fc
             FALSE,            // NOT 16.16 i.e. 28.4
             hglyph,           // glyph for which info is wanted
             FALSE,            //  DO more than just metrics
             FALSE,            // hinted
             (GLYPHDATA *)NULL,// do not need glyphdata
             0,                // size in bytes of the ppoly buffer
             (TTPOLYGONHEADER *)NULL
             );
    }
    else
    {
        cjAllPolygons = lQueryTTOutline
          (
           pfc,              // lpMat2 is incorporated into this fc
           FALSE,            // NOT 16.16 i.e. 28.4
           hglyph,           // glyph for which info is wanted
           FALSE,            //  DO more than just metrics
           FALSE,            // hinted
           (GLYPHDATA *)NULL,// do not need glyphdata
           0,                // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)NULL
           );
    }

    if (cjAllPolygons == FD_ERROR)
        RET_FALSE("TTFD! cjAllPolygons\n");

    if (cjAllPolygons != 0)
    {
        if ((pfc->gstat.pv = PV_ALLOC(cjAllPolygons)) == NULL)
        {
            RET_FALSE("TTFD_cjAllPolygons or ppoly\n");
        }
    }
    else
    {
        pfc->gstat.pv = NULL;
    }

// get all the polygons in the buffer we just allocated:

    if( pfc->bVertical )
    {
        cjAllPolygons2 = lQueryTrueTypeOutlineVertical
          (
           pfc,            // lpMat2 is incorporated into this fc
           FALSE,          // NOT 16.16 i.e. 28.4
           hglyph,         // glyph for which info is wanted
           FALSE,          //  DO more than just metrics
           FALSE,            // hinted
           pgldt,          // this is where the metrics should be returned
           cjAllPolygons,  // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)pfc->gstat.pv
           );
    }
    else
    {
        cjAllPolygons2 = lQueryTTOutline
          (
           pfc,            // lpMat2 is incorporated into this fc
           FALSE,          // NOT 16.16 i.e. 28.4
           hglyph,         // glyph for which info is wanted
           FALSE,          //  DO more than just metrics
           FALSE,            // hinted
           pgldt,          // this is where the metrics should be returned
           cjAllPolygons,  // size in bytes of the ppoly buffer
           (TTPOLYGONHEADER *)pfc->gstat.pv
           );
    }

    if (cjAllPolygons2 == FD_ERROR)
    {
        if (pfc->gstat.pv)
        {
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;
        }
        RET_FALSE("TTFD_ QueryTrueTypeOutline failed\n");
    }

    ASSERTDD(cjAllPolygons == cjAllPolygons2,
              "cjAllPolygons PROBLEM\n");

// now that we have all the info in ppoly buffer we can generate the path

    bOk = bGeneratePath(
            (PATHOBJ *)ppo,
            (TTPOLYGONHEADER *)pfc->gstat.pv,
            cjAllPolygons, NULL, NULL
            );

    if (pfc->gstat.pv)
    {
        V_FREE(pfc->gstat.pv);
        pfc->gstat.pv = NULL;
    }

    return (bOk);
}


/******************************Public*Routine******************************\
*
* bGeneratePath
*
* Effects: Adds control points of the glyph to the gluph path
*
*
* History:
*  18-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// macro that computes the size of the polycurve record:

#define CJ_CRV(pcrv)                                            \
(                                                               \
    offsetof(TTPOLYCURVE,apfx) + (pcrv)->cpfx * sizeof(POINTFX) \
)

#define CJ_BEZCRV(cBezPts)                                       \
(                                                                \
    offsetof(TTPOLYCURVE,apfx) + (cBezPts) * sizeof(POINTFX)     \
)


// reasonable guess that in most cases a contour will not consist of more
// than this many beziers

#define C_BEZIER 6


BOOL bGeneratePath(
    PATHOBJ         * ppo,        // IN OUT pointer to the path object to be generated
    TTPOLYGONHEADER * ppolyStart, // IN OUT pointer to the buffer with outline data
    ULONG             cjTotal,    // IN     size of the buffer
    ULONG           * pcjOut,      // OUT   size of needed bezier buffer
    TTPOLYGONHEADER * ppolyBeziers // OUT   buffer with Bezier outline data
    )
{
    TTPOLYGONHEADER * ppoly, * ppolyEnd, *ppolyBez;
    TTPOLYCURVE     * pcrv, * pcrvEnd, *pcrvBez;
    POINTFIX          aptfixBez[3 * C_BEZIER];  // 3 points per bezier
    POINTFIX        * pptfixBez;
    ULONG             cBez;
    POINTFIX        * pptfixStart;
    ULONG             cjPolyBez = 0;
    ULONG             cjCrv, cjCrvBez;

    if (pcjOut)
        *pcjOut = 0; // to begin with

    // The code is no problem with NULL.
    ppolyBez = NULL;
    
    if (ppolyBeziers)
        ppolyBez = ppolyBeziers;

    for (
         ppoly = ppolyStart, ppolyEnd = (TTPOLYGONHEADER *)((PBYTE)ppolyStart + cjTotal);
         ppoly < ppolyEnd;
         ppoly = (TTPOLYGONHEADER *)((PBYTE)ppoly + ppoly->cb),
         ppolyBez = (TTPOLYGONHEADER *)((PBYTE)ppolyBez + cjPolyBez)
        )
    {
        ASSERTDD(ppoly->dwType == TT_POLYGON_TYPE, "TT_POLYGON_TYPE\n");

    // begin new closed contour

        if (ppo && !PATHOBJ_bMoveTo(ppo, *(POINTFIX *)&ppoly->pfxStart))
            RET_FALSE("TTFD!_PATHOBJ_bMoveTo failed\n");

    // init a loop over curves


        pptfixStart = (POINTFIX *)&ppoly->pfxStart;
        pcrvEnd = (TTPOLYCURVE *)((PBYTE)ppoly + ppoly->cb);

        for (
             pcrv = (TTPOLYCURVE *)(ppoly + 1),
             pcrvBez = (TTPOLYCURVE *)(ppolyBez + 1),
             cjPolyBez = sizeof(TTPOLYGONHEADER);
             pcrv < pcrvEnd;
             pcrv = (TTPOLYCURVE *)((PBYTE)pcrv + cjCrv),
             pcrvBez = (TTPOLYCURVE *)((PBYTE)pcrvBez + cjCrvBez),
             cjPolyBez += cjCrvBez
            )
        {
        // must compute the size of this curve first

            cjCrv = CJ_CRV(pcrv);

            if (pcrv->wType == TT_PRIM_LINE)
            {
                if (ppo && !PATHOBJ_bPolyLineTo(ppo,(POINTFIX *)pcrv->apfx, pcrv->cpfx))
                    RET_FALSE("TTFD!_bPolyLineTo()\n");

                cjCrvBez = cjCrv;

            // in the case of poly lines, we just copy the data out

                if (ppolyBeziers)
                    RtlCopyMemory(pcrvBez, pcrv, cjCrv);
            }
            else // qspline
            {
                BOOL bOk;
                ULONG cBezPts;

                ASSERTDD(pcrv->wType == TT_PRIM_QSPLINE, "TT_PRIM_QSPLINE\n");
                ASSERTDD(pcrv->cpfx > 1, "_TT_PRIM_QSPLINE, cpfx <= 1\n");
                cBez = pcrv->cpfx - 1;
                cBezPts = 3 * cBez;

                if (cBez > C_BEZIER) // must allocate buffer for the bezier points
                {
                    if ((pptfixBez = (POINTFIX *)PV_ALLOC(cBezPts * sizeof(POINTFIX))) == (POINTFIX *)NULL)
                    {
                        return (FALSE);
                    }
                }
                else // enough memory on the stack
                {
                    pptfixBez = aptfixBez;
                }

                vQsplineToPolyBezier (
                    cBez,                     // count of curves to convert to beziers format
                    pptfixStart,              // starting point on the first curve
                    (POINTFIX *)pcrv->apfx,   // array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
                    pptfixBez);               // buffer to be filled with 3 * cBez poly bezier control points

                bOk = !ppo || PATHOBJ_bPolyBezierTo(ppo, pptfixBez, cBezPts);

            // compute the size of the corresponding bezier curve

                cjCrvBez = CJ_BEZCRV(cBezPts);

            // may need to fill bezier data out

                if (ppolyBeziers)
                {
                    pcrvBez->wType = TT_PRIM_CSPLINE;
                    pcrvBez->cpfx  = (WORD) cBezPts;
                    RtlCopyMemory(pcrvBez->apfx, pptfixBez,
                                  cBezPts * sizeof(POINTFIX));
                }

            // free mem if needed

                if (cBez > C_BEZIER)
                    V_FREE(pptfixBez);

                if (!bOk)
                    RET_FALSE("TTFD!_bPolyBezierTo() failed\n");
            }

        // get to the next curve in this polygon

            pptfixStart = (POINTFIX *) &pcrv->apfx[pcrv->cpfx - 1];
        }
        ASSERTDD(pcrv == pcrvEnd, "pcrv problem\n");

    // close the path

        if (ppo && (!PATHOBJ_bPolyLineTo(ppo, (POINTFIX *)&ppoly->pfxStart, 1) ||
            !PATHOBJ_bCloseFigure(ppo)))
            RET_FALSE("TTFD!_bPolyLineTo()\n");

    // add the size of the bezier polygon to the total bezier buffer size

        if (pcjOut)
            *pcjOut += cjPolyBez;

    // write polygon header to the out buffer

        if (ppolyBeziers)
        {
            ppolyBez->dwType = TT_POLYGON_TYPE;
            ppolyBez->cb = cjPolyBez;
            ppolyBez->pfxStart = ppoly->pfxStart;
        }
    }                                             // loop over polygons

    ASSERTDD(ppoly == ppolyEnd, "poly problem\n");
    return (TRUE);
}


/******************************Public*Routine******************************\
*
*    vQsplineToPolyBezier
*
* Effects:
*
* Warnings:
*
* History:
*  20-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define DIV_BY_2(x) (((x) + 0x00000001) / 2)
#define DIV_BY_3(x) (((x) + 0x00000002) / 3)

STATIC VOID vQsplineToPolyBezier(
    ULONG      cBez,          //IN  count of curves to convert to beziers format
    POINTFIX * pptfixStart,   //IN  starting point on the first curve
    POINTFIX * pptfixSpline,  //IN  array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
    POINTFIX * pptfixBez      //OUT buffer to be filled with 3 * cBez poly bezier control points
    )
{
    ULONG    iBez,cMidBez;
    POINTFIX ptfixA;

// cMidBez == # of beziers for whom the last point on the bezier is computed
// as a mid point of the two consecutive points in the input array. Only the
// last bezier is not a mid bezier, the last point for that bezier is equal
// to the last point in the input array

    ASSERTDD(cBez > 0, "cBez == 0\n");

    cMidBez = cBez - 1;
    ptfixA = *pptfixStart;

    for (iBez = 0; iBez < cMidBez; iBez++, pptfixSpline++)
    {
    // let us call the three spline points
    // A,B,C;
    // B = *pptfix;
    // C = (pptfix[0] + pptfix[1]) / 2; // mid point, unless at the end
    //
    // if we decide to call the two intermediate control points for the
    // bezier M,N (i.e. full set of control points for the bezier is
    // A,M,N,C), the points M,N are determined by following formulas:
    //
    // M = (2*B + A) / 3  ; two thirds along the segment AB
    // N = (2*B + C) / 3  ; two thirds along the segment CB
    //
    // this is the computation we are doing in this loop:

    // M point for this bezier

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // compute C point for this bezier, which is also the A point for the next
    // bezier

        ptfixA.x = DIV_BY_2(pptfixSpline[0].x + pptfixSpline[1].x);
        ptfixA.y = DIV_BY_2(pptfixSpline[0].y + pptfixSpline[1].y);

    // now compute N point for this bezier:

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // finally record the C point for this curve

        *pptfixBez++ = ptfixA;
    }

// finally do the last bezier. If the last bezier is the only one, the loop
// above has been skipped

// M point for this bezier

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// compute C point for this bezier, its end point is the last point
// in the input array

    ptfixA = pptfixSpline[1];

// now compute N point for this bezier:

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// finally record the C point for this curve, no need to increment pptfixBez

    *pptfixBez = ptfixA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\fd_query.c ===
/******************************Module*Header*******************************\
* Module Name: fd_query.c                                                  *
*                                                                          *
* QUERY functions.                                                         *
*                                                                          *
* Created: 18-Nov-1991 14:37:56                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
#include "winfont.h"
#include "fdsem.h"
#include "winerror.h"

extern HSEMAPHORE ghsemTTFD;

#if DBG
extern ULONG gflTtfdDebug;
#endif

#ifdef _X86_
//
// For x86, FLOATL is actually DWORD, but the value is IEEE format floating
// point, then check sign bit.
//
#define IS_FLOATL_MINUS(x)   ((DWORD)(x) & 0x80000000)
#else
//
// For RISC, FLOATL is FLOAT.
//
#define IS_FLOATL_MINUS(x)   (((FLOATL)(x)) < 0.0f)
#endif // _X86_

//
// Monochrome: 1  bit per pixel
// Gray:       8 bits per pixel
// ClearType   8 bits per pixel also, no modification needed for CLEARTYPE
///            because FO_GRAY16 will be set along with FO_CLEARTYPE_X
//
// CJ_TT_SCAN rounds up to a 32-bit boundary
//
#define CJ_TT_SCAN(cx,p) \
    (4*((((((p)->flFontType & FO_GRAY16)?(8):(1))*(cx))+31)/32))

// Each scan of a glyph bitmap is BYTE aligned (except for the
// top (first) scan which is DWORD aligned. The last scan is
// padded out with zeros to the nearest DWORD boundary. These
// statements apply to monochrome and 4-bpp gray glyphs images.
// The number of bytes per scan will depend upon the number of
// pixels in a scan and the depth of the image. For monochrome
// glyphs the number of bytes per scan is ceil(cx/8) = floor((cx+7)/8)
// For the case of 4-bpp bitmaps the count of bytes in a scan
// is ceil( 4*cx/8 ) = ceil(cx/2)

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)
#define CJ_GRAY_SCAN(cx)        (((cx)+1)/2)
#define CJ_CLEARTYPE_SCAN(cx)   (cx)

BOOL bReloadGlyphSet(PFONTFILE pff, ULONG iFace);
VOID vReleaseGlyphSet(PFONTFILE pff, ULONG iFace);

#if DBG
// #define  DEBUG_OUTLINE
// #define  DBG_CHARINC
#endif

BOOL gbJpn98FixPitch = FALSE;

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewContourGridFit(fs_GlyphInputType *gin, fs_GlyphInfoType *gout)
{
// this routine needs to be improved to only attempt to use
// nonhinted outline when hints are at fault for not being able to produce the
// hinted outline

    FS_ENTRY iRet = fs_ContourGridFit(gin, gout);

    if (iRet != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        iRet = fs_ContourNoGridFit(gin, gout);
    }
    return iRet;
}

// notional space metric data for an individual glyph

/******************************Public*Routine******************************\
* vAddPOINTQF
*
*
\**************************************************************************/

VOID vAddPOINTQF( POINTQF *pptq1, POINTQF *pptq2)
{
    pptq1->x.LowPart  += pptq2->x.LowPart;
    pptq1->x.HighPart += pptq2->x.HighPart + (pptq1->x.LowPart < pptq2->x.LowPart);

    pptq1->y.LowPart  += pptq2->y.LowPart;
    pptq1->y.HighPart += pptq2->y.HighPart + (pptq1->y.LowPart < pptq2->y.LowPart);
}


/******************************Public*Routine******************************\
* VOID vCharacterCode
*
* History:
*  07-Dec-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCharacterCode (
    HGLYPH             hg,
    fs_GlyphInputType *pgin
    )
{
    ASSERTDD((hg & 0xffff0000) == 0, "hg not unicode\n");

    pgin->param.newglyph.characterCode = NONVALID;
    pgin->param.newglyph.glyphIndex = (uint16)hg;
    pgin->param.newglyph.bMatchBBox  = FALSE;
    pgin->param.newglyph.bNoEmbeddedBitmap = FALSE;
    return;
}


/******************************Public*Routine******************************\
*
* LONG ttfdQueryCaps
*
*
* Effects: returns the capabilities of this driver.
*          Only mono bitmaps are supported.
*
*
* History:
*  27-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryFontCaps (
    ULONG  culCaps,
    ULONG *pulCaps
    )
{
    ULONG culCopied = min(culCaps,2);
    ULONG aulCaps[2];

    aulCaps[0] = 2L; // number of ULONG's in a complete array

//!!! make sure that outlines are really supported in the end, when this driver
//!!! is completed, if not, get rid of FD_OUTLINES flag [bodind]

    aulCaps[1] = (QC_1BIT | QC_OUTLINES);   // 1 bit per pel bitmaps only are supported

    RtlCopyMemory((PVOID)pulCaps,(PVOID)aulCaps, culCopied * 4);
    return( culCopied );
}


/******************************Public*Routine******************************\
* PIFIMETRICS ttfdQueryFont
*
* Return a pointer to the IFIMETRICS for the specified face of the font
* file.  Also returns an id (via the pid parameter) that is later used
* by ttfdFree.
*
* History:
*  21-Oct-1992 Gilman Wong [gilmanw]
* IFI/DDI merge
*
*  18-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

IFIMETRICS *ttfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR *pid
    )
{
    HFF    httc = hff;

// Validate handle.

    ASSERTDD(hff, "ttfdQueryFaces(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PTTC(hff)->ulNumEntry,
             "gdisrv!ttfdQueryFaces(): iFace out of range\n");

// get real hff from ttc array.

    hff   = PTTC(httc)->ahffEntry[iFace-1].hff;
    iFace = PTTC(httc)->ahffEntry[iFace-1].iFace;

    dhpdev;

//
// Validate handle.
//
    ASSERTDD(hff, "ttfdQueryFaces(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PFF(hff)->ffca.ulNumFaces,
             "ttfdQueryFaces(): iFace out of range\n");

//
// ttfdFree can ignore this.  IFIMETRICS will be deleted with the FONTFILE
// structure.
//
    *pid = (ULONG_PTR) NULL;

//
// Return the pointer to the precomputed IFIMETRICS in the PFF.
//

    if ( iFace == 1L )
        return ( &(PFF(hff)->ifi) ); // Normal face
    else
      return ( PFF(hff)->pifi_vertical ); // Vertical face
}


/******************************Public*Routine******************************\
* vFillSingularGLYPHDATA
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFillSingularGLYPHDATA (
    HGLYPH       hg,
    ULONG        ig,
    FONTCONTEXT *pfc,
    GLYPHDATA   *pgldt   // OUT
    )
{
    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);
    NOT_GM ngm;  // notional glyph data

    // may get changed by the calling routine if bits requested too
    pgldt->gdf.pgb = NULL;
    pgldt->hg = hg;

// this is a fake 1x1 bitmap

    pgldt->rclInk.left   = 0;
    pgldt->rclInk.top    = 0;
    pgldt->rclInk.right  = 0;
    pgldt->rclInk.bottom = 0;

// go on to compute the positioning info:

// here we will just xform the notional space data:

    vGetNotionalGlyphMetrics(pfc,ig,&ngm);

// xforms are computed by simple multiplication

    pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);
    pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
    pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

    pgldt->fxInkTop    = - fxLTimesEf(&pfc->efSide, (LONG)ngm.yMin);
    pgldt->fxInkBottom = - fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax);

    vLTimesVtfl((LONG)ngm.sD, &pfc->vtflBase, &pgldt->ptqD);
}


/******************************Public*Routine******************************\
* lGetSingularGlyphBitmap
*
* History:
*  22-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetSingularGlyphBitmap (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    VOID        *pv
    )
{
    LONG         cjGlyphData;
    ULONG        ig;
    FS_ENTRY     iRet;


    vCharacterCode(hglyph,pfc->pgin);

// Compute the glyph index from the character code:

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

        WARNING("TTFD!gdisrv!lGetSingularGlyphBitmap(): fs_NewGlyph failed\n");
        return FD_ERROR;
    }

// Return the glyph index corresponding to this hglyph.

    ig = pfc->pgout->glyphIndex;

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
    cjGlyphData = CJGD(1,1,pfc);

// If prg is NULL, caller is requesting just the size.

// At this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.
// In either case we shall reject the caller if he did not
// provide sufficiently big buffer

// fill all of GLYPHDATA structure except for bitmap bits

    if ( pgd != (GLYPHDATA *)NULL )
    {
        vFillSingularGLYPHDATA( hglyph, ig, pfc, pgd );
    }

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

    // By returning a small 1x1 bitmap, we save device drivers from having
    // to special case this.

        // The corresponding GLYPHDATA structure has been modified
        // by vFillGlyphData. See the statement "pgldt->fxA = 0"
        // in vFillGlyphData.

        pgb->ptlOrigin.x = pfc->ptlSingularOrigin.x;
        pgb->ptlOrigin.y = pfc->ptlSingularOrigin.y;

        pgb->sizlBitmap.cx = 1;    // cheating
        pgb->sizlBitmap.cy = 1;    // cheating

        // This is where we fill in the blank 1x1 dib
        // it turns out that a single zero'ed byte
        // covers both the 1-bpp and 4-bpp cases

        *((ULONG *)pgb->aj) = 0;  // fill in a blank 1x1 dib
    }

    if ( pgd != (GLYPHDATA *)NULL )
    {
        pgd->gdf.pgb = (GLYPHBITS *)pv;
    }


// Return the size.

    return(cjGlyphData);
}


/******************************Public*Routine******************************\
* lGetGlyphBitmap
*
* History:
*  20-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetGlyphBitmap (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    VOID        *pv,
    FS_ENTRY    *piRet
    )
{
    PVOID pvSetMemoryBases(fs_GlyphInfoType*, fs_GlyphInputType*, int);
    VOID vCopyAndZeroOutPaddingBits(FONTCONTEXT*, GLYPHBITS*, BYTE*, GMC*);
    VOID vCopyGrayBits(FONTCONTEXT*, GLYPHBITS*, BYTE*, GMC*);
    VOID vCopyClearTypeBits(FONTCONTEXT *, GLYPHBITS *, BYTE *, GMC *);
    VOID vFillGLYPHDATA(HGLYPH, ULONG, FONTCONTEXT*, fs_GlyphInfoType*, GLYPHDATA*, GMC*, POINTL*);
    BOOL bGetGlyphMetrics(FONTCONTEXT*, HGLYPH, FLONG, FS_ENTRY*);
    LONG  lGetGlyphBitmapVertical(FONTCONTEXT*,HGLYPH,GLYPHDATA*,PVOID,FS_ENTRY*);

    LONG         cjGlyphData;
    ULONG        cx,cy;
    GMC          gmc;
    GLYPHDATA    gd;
    POINTL       ptlOrg;
    BOOL         bBlankGlyph = FALSE; // initialization essential;

    ASSERTDD(hglyph != HGLYPH_INVALID, "lGetGlyphBitmap, hglyph == -1\n");
    ASSERTDD(pfc == pfc->pff->pfcLast, "pfc! = pfcLast\n");

    *piRet = NO_ERR;

// check the last glyph processed to determine
// whether we have to register the glyph as new and compute its size

    if (pfc->gstat.hgLast != hglyph)
    {
    // DO skip grid fitting if embedded bitmpas are found,
    // for we will NOT be interested in outlines

        if (!bGetGlyphMetrics(pfc,hglyph,FL_SKIP_IF_BITMAP,piRet))
        {
            return(FD_ERROR);
        }
    }


    cx = pfc->pgout->bitMapInfo.bounds.right
       - pfc->pgout->bitMapInfo.bounds.left;
    cy = pfc->pgout->bitMapInfo.bounds.bottom
       - pfc->pgout->bitMapInfo.bounds.top;

// here we shall endulge in cheating. If cx or cy is zero
// (ususally space character - no bits to set, but there is a nontrivial
// positioning information) we shall cheat and instead of retrning no bits
// for bimtap we shall
// return a small 1x1 bitmap, which will be blank, i.e. all bits will be off
// this prevents having to insert an if(cx && cy) check to a time critical
// loop in all device drivers before calling DrawGlyph routine.

    if ((cx == 0) || (cy == 0)) // cheat here
    {
        bBlankGlyph = TRUE;
    }

    if (bBlankGlyph)
    {
        ASSERTDD(
            pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
        cjGlyphData = CJGD(1,1,pfc);
    }
    else
    {
    // this is quick and dirty computation, the acutal culGlyphData
    // written to the buffer may be little smaller if we had to shave
    // off a few scans off the glyph bitmap that extended over
    // the pfc->yMin or pfc->yMax bounds. Notice that culGlyphData
    // computed this way may be somewhat bigger than pfc->culGlyphMax,
    // but the actual glyph written to the buffer will be smaller than
    // pfc->culGlyphMax

        // really win31 hack, shold not always be shifting right [bodind]
        // Win95 FE hack

        ASSERTDD(
            pfc->flFontType & FO_CHOSE_DEPTH,
            "Depth Not Chosen Yet!\n"
        );
        cjGlyphData = CJGD(cx,cy,pfc);

    // since we will shave off any extra rows if there are any,
    // we can fix culGlyphData so as not extend over the max value

        if ((ULONG)cjGlyphData > pfc->cjGlyphMax)
            cjGlyphData = (LONG)pfc->cjGlyphMax;
    }

    if ( (pgd == NULL) && (pv == NULL))
        return cjGlyphData;

// at this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.

// fill all of GLYPHDATA structure except for bitmap bits
// !!! Scummy hack - there appears to be no way to get just the
// !!! bitmap, without getting the metrics, since the origin for the
// !!! bitmap is computed from the rclink field in the glyphdata.
// !!! this is surely fixable but I have neither the time nor the
// !!! inclination to pursue it.
// !!!
// !!! We should fix this when we have time.

    if ( pgd == NULL )
    {
        pgd = &gd;
    }


    if ( pfc->bVertical && ( pfc->ulControl & VERTICAL_MODE ) )
    {
        // Vertical case
        fs_GlyphInfoType  my_gout;

        vShiftBitmapInfo( pfc, &my_gout, pfc->pgout );
        vFillGLYPHDATA(
            pfc->hgSave,         // this is a little bit tricky. we wouldn't like to
            pfc->gstat.igLast,   // tell GDI about vertical glyph index.
            pfc,
            &my_gout,
            pgd,
            &gmc,
            &ptlOrg);
    }
    else
    {

        // Normal case
        vFillGLYPHDATA(
            hglyph,
            pfc->gstat.igLast,
            pfc,
            pfc->pgout,
            pgd,
            &gmc,
            &ptlOrg);
    }

    // the caller wants the bits too


    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

    // allocate mem for the glyph, 5-7 are magic #s required by the spec
    // remember the pointer so that the memory can be freed later in case
    // of exception

        pfc->gstat.pv = pvSetMemoryBases(pfc->pgout, pfc->pgin, IS_GRAY(pfc));
        if (!pfc->gstat.pv)
           RETURN("TTFD!_ttfdQGB, mem allocation failed\n",FD_ERROR);

    // initialize the fields needed by fs_ContourScan,
    // the routine that fills the outline, do the whole
    // bitmap at once, do not want banding

        pfc->pgin->param.scan.bottomClip = pfc->pgout->bitMapInfo.bounds.top;
        pfc->pgin->param.scan.topClip = pfc->pgout->bitMapInfo.bounds.bottom;
        pfc->pgin->param.scan.outlineCache = (int32 *)NULL;


    // make sure that our state is ok: the ouline data in the shared buffer 3
    // must correspond to the glyph we are processing, and the last
    // font context that used the shared buffer pj3 to store glyph outlines
    // has to be the pfc passed to this function:

        ASSERTDD(hglyph == pfc->gstat.hgLast, "hgLast trashed \n");

        *piRet = fs_ContourScan(pfc->pgin,pfc->pgout);

        pfc->gstat.hgLast = HGLYPH_INVALID;


        if (*piRet != NO_ERR)
        {
        // just to be safe for the next time around, reset pfcLast to NULL

            V_FSERROR(*piRet);
            V_FREE(pfc->gstat.pv);
            pfc->gstat.pv = NULL;

            return(FD_ERROR);
        }

        if (!bBlankGlyph && gmc.cxCor && gmc.cyCor)
        {
        // copy to the engine's buffer and zero out the bits
        // outside of the black box

#if DBG
if ((pfc->flXform & XFORM_POSITIVE_SCALE) )
{
ASSERTDD(gmc.cxCor == (ULONG)((pgd->fxAB - pgd->fxA) >> 4),
    "TTFD!vCopyAndZeroOutPaddingBits, SUM RULE\n");
}
#endif

        // Call either the monochrome or the gray level function
        // depending upon the gray bit in the font context

            (*(IS_GRAY(pfc) ? ((pfc->flFontType & FO_CLEARTYPE_X) ? vCopyClearTypeBits : vCopyGrayBits) : vCopyAndZeroOutPaddingBits))(
                pfc
              , pgb
              , (BYTE*) pfc->pgout->bitMapInfo.baseAddr
              , &gmc
            );

        // bitmap origin, i.e. the upper left corner of the bitmap, bitmap
        // is as big as its black box

            if (!(pfc->flXform & (XFORM_HORIZ | XFORM_VERT)))
            {
                pgb->ptlOrigin = ptlOrg;

            }
            else
            {
            // In HORIZ or VERT case there is no need to shift origin
            // when emboldening. The point is that we have already fixed
            // rclInk, and therefore this is all we need to do

                pgb->ptlOrigin.x = pgd->rclInk.left;
                pgb->ptlOrigin.y = pgd->rclInk.top;
            }
        }
        else // blank glyph, cheat and return a blank 1x1 bitmap
        {
            if (bBlankGlyph)
            {
                ASSERTDD(
                    pfc->flFontType & FO_CHOSE_DEPTH
                   ,"Depth Not Chosen Yet!\n");
                ASSERTDD(
                    cjGlyphData == (LONG) CJGD(1,1,pfc),
                    "TTFD!_bBlankGlyph, cjGlyphData\n");
            }
            else
            {
                ASSERTDD(
                    cjGlyphData >= (LONG) CJGD(1,1,pfc),
                    "TTFD!_corrected blank glyph, cjGlyphData\n"
                    );
            }


            pgb->ptlOrigin.x = pfc->ptlSingularOrigin.x;
            pgb->ptlOrigin.y = pfc->ptlSingularOrigin.y;

            pgb->sizlBitmap.cx = 1;    // cheating
            pgb->sizlBitmap.cy = 1;    // cheating

            pgb->aj[0] = (BYTE)0;  // fill in a blank 1x1 bmp

        }

        pgd->gdf.pgb = pgb;


    // free memory and return

        V_FREE(pfc->gstat.pv);
        pfc->gstat.pv = NULL;
    }

    return(cjGlyphData);
}


/******************************Public*Routine******************************\
*
* bIndexToWchar
*
* Effects:
*
*   Converts glyph index to the wchar that corresponds to that glyph
*   index. returns true if succeeds, the function will fail only if
*   there happens to be a bug in the font file, otherwise it should
*   always succeed.
*
* Comments:
*
*   The Win 3.1 algorithm generates a table for glyph index to Unicode
*   translation.  The table consists of an array of Unicode codepoints
*   indexed by the corresponding glyph index.  The table is built by
*   scanning the ENTIRE cmap table.  As each glyph index is encountered,
*   its corresponding Unicode codepoint is put into the table EVEN IF
*   THIS MEANS OVERWRITING A PREVIOUS VALUE.  The effect of this is that
*   Win 3.1, in the situation where there is a one-to-many mapping of
*   glyph index to Unicode codepoint, always picks the last Unicode
*   character encountered in the cmap table.  We emulate this behavior
*   by scanning the cmap table BACKWARDS and terminating the search at
*   the first match encountered.    [GilmanW]
*
* Returns:
*   TRUE if conversion succeeded, FALSE otherwise.
*
* History:
*  16-May-1993 Gilman Wong [gilmanw]
* Re-wrote.  Changed translation to be Win 3.1 compatible.  Win 3.1 does
* not terminate the search as soon as the first Unicode character is found
* with the proper glyph index.  Instead, its algorithm finds the LAST
* Unicode character with the proper glyph index.
*
*  06-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bIndexToWchar(FONTFILE *pff, WCHAR *pwc, uint16 usIndex, BOOL bVertical)
{
    uint16 *pstartCount, *pendCount,            // Arrays that define the
           *pidDelta, *pidRangeOffset;          // Unicode runs supported
                                                // by the CMAP table.
    uint16 *pendCountStart;                     // Beginning of arrays.
    uint16  cRuns;                              // Number of Unicode runs.
    uint16  usLo, usHi, idDelta, idRangeOffset; // Current Unicode run.
    uint16 *pidStart, *pid;                     // To parse glyph index array.
    uint16  usIndexBE;                          // Big endian ver of usIndex.
    sfnt_mappingTable *pmap = (sfnt_mappingTable *)(
        (BYTE *)pff->pvView + pff->ffca.dpMappingTable
        );

    uint16 *pusEnd = (uint16 *)((BYTE *)pmap + (uint16)SWAPW(pmap->length));

// First must check if this is an MSFT style tt file or a Mac style file.
// Each case is handled separately.

    if (pff->ffca.ui16PlatformID == BE_PLAT_ID_MAC)
    {
        PBYTE pjGlyphIdArray;
        PBYTE pjGlyph;
        BYTE  jIndex;

    // This is an easy case, GlyphIdArray is indexed into by mac code point,
    // all we have to do is to convert it to UNICODE:
    //
    // Scan backwards for Win 3.1 compatibility.

        ASSERTDD(pmap->format == BE_FORMAT_MAC_STANDARD,
                  "bIndexToWchar cmap format for mac\n");
        ASSERTDD(usIndex < 256, "bIndexToWchar mac usIndex > 255\n");

        jIndex = (BYTE) usIndex;

        pjGlyphIdArray = (PBYTE)pmap + SIZEOF_CMAPTABLE;
        pjGlyph = &pjGlyphIdArray[255];

        for ( ; pjGlyph >= pjGlyphIdArray; pjGlyph--)
        {
            if (*pjGlyph == jIndex)
            {
            // Must convert the Mac code point to Unicode.  The Mac code
            // point is a BYTE; indeed, it is the index of the glyph id in
            // the table and may be computed as the current offset from
            // the beginning of the table.

                jIndex = (BYTE) (pjGlyph - pjGlyphIdArray);
                vCvtMacToUnicode((ULONG)pff->ffca.ui16LanguageID,pwc,&jIndex,1);

                return TRUE;
            }
        }

    // If we are here, this is an indication of a bug in the font file
    // (well, or possibly in my code [bodind])

        WARNING("TTFD!_bIndexToWchar invalid kerning index\n");
        return FALSE;
    }

// !!!
// !!! This code is NOT good, We have to get more performance
// !!!

    if( pff->ffca.ui16PlatformID == BE_PLAT_ID_MS &&
       (pff->ffca.iGlyphSet == GSET_TYPE_GENERAL_NOT_UNICODE ||
        pff->ffca.iGlyphSet == GSET_TYPE_HIGH_BYTE )
       )
    {
        UINT            ii,jj;
        PFD_GLYPHSET    pgset;

        if (bVertical)
            pgset = pff->pgsetv;
        else
            pgset = pff->pgset;

        for( ii = 0; ii < pgset->cRuns; ii++)
        {
            HGLYPH *phg = pgset->awcrun[ii].phg;
            USHORT cGlyphs = pgset->awcrun[ii].cGlyphs;

            for( jj = 0; jj < cGlyphs; jj++ )
            {
                if( phg[jj] == usIndex )
                {
                    *pwc = pgset->awcrun[ii].wcLow + jj;
                    return(TRUE);
                }
            }
        }
        return( FALSE );
    }

// !!! 17-May-1993 [GilmanW]
// !!! Why doesn't this code handle Format 6 (Trimmed table mapping)?  The
// !!! code below only handles Format 4.  Format 0 would be the Mac TT file
// !!! specific code above.

// If we get to this point, we know that this is an MSFT style TT file.

    ASSERTDD(pff->ffca.ui16PlatformID == BE_PLAT_ID_MS,
              "bIndexToWchar plat ID messed up\n");
    ASSERTDD(pmap->format == BE_FORMAT_MSFT_UNICODE,
              "bIndexToWchar cmap format for unicode table\n");

    cRuns = BE_UINT16((PBYTE)pmap + OFF_segCountX2) >> 1;

// Get the pointer to the beginning of the array of endCount code points

    pendCountStart = (uint16 *)((PBYTE)pmap + OFF_endCount);

// The final endCode has to be 0xffff; if this is not the case, there
// is a bug in the TT file or in our code:

    ASSERTDD(pendCountStart[cRuns - 1] == 0xFFFF,
              "bIndexToWchar pendCount[cRuns - 1] != 0xFFFF\n");

// Loop through the four paralel arrays (startCount, endCount, idDelta, and
// idRangeOffset) and find wc that usIndex corresponds to.  Each iteration
// scans a continuous range of Unicode characters supported by the TT font.
//
// To be Win3.1 compatible, we are looking for the LAST Unicode character
// that corresponds to usIndex.  So we scan all the arrays backwards,
// starting at the end of each of the arrays.
//
// Please note the following:
// For resons known only to the TT designers, startCount array does not
// begin immediately after the end of endCount array, i.e. at
// &pendCount[cRuns]. Instead, they insert an uint16 padding which has to
// set to zero and the startCount array begins after the padding. This
// padding in no way helps alignment of the structure.
//
// Here is the format of the arrays:
// ________________________________________________________________________________________
// | endCount[cRuns] | skip 1 | startCount[cRuns] | idDelta[cRuns] | idRangeOffset[cRuns] |
// |_________________|________|___________________|________________|______________________|

    // ASSERTDD(pendCountStart[cRuns] == 0, "TTFD!_bIndexToWchar, padding != 0\n");

    pendCount      = &pendCountStart[cRuns - 1];
    pstartCount    = &pendCount[cRuns + 1];   // add 1 because of padding
    pidDelta       = &pstartCount[cRuns];
    pidRangeOffset = &pidDelta[cRuns];

    for ( ;
         pendCount >= pendCountStart;
         pstartCount--, pendCount--,pidDelta--,pidRangeOffset--
        )
    {
        usLo          = BE_UINT16(pstartCount);     // current Unicode run
        usHi          = BE_UINT16(pendCount);       // [usLo, usHi], inclusive
        idDelta       = BE_UINT16(pidDelta);
        idRangeOffset = BE_UINT16(pidRangeOffset);

        ASSERTDD(usLo <= usHi, "bIndexToWChar: usLo > usHi\n");

    // Depending on idRangeOffset for the run, indexes are computed
    // differently.
    //
    // If idRangeOffset is zero, then index is the Unicode codepoint
    // plus the delta value.
    //
    // Otherwise, idRangeOffset specifies the BYTE offset of an array of
    // glyph indices (elements of which correspond to the Unicode range
    // [usLo, usHi], inclusive).  Actually, each element of the array is
    // the glyph index minus idDelta, so idDelta must be added in order
    // to derive the actual glyph indices from the array values.
    //
    // Notice that the delta arithmetic is always mod 65536.

        if (idRangeOffset == 0)
        {
        // Glyph index == Unicode codepoint + delta.
        //
        // If (usIndex-idDelta) is within the range [usLo, usHi], inclusive,
        // we have found the glyph index.  We'll overload usIndexBE
        // to be usIndex-idDelta == Unicode codepoint.

            usIndexBE = usIndex - idDelta;

            if ( (usIndexBE >= usLo) && (usIndexBE <= usHi) )
            {
                *pwc = (WCHAR) usIndexBE;

                return TRUE;
            }
        }
        else
        {
        // We are looking for usIndex in an array in which each element
        // is stored in big endian format.  Rather than convert each
        // element in the array to little endian, lets turn usIndex into
        // a big endian number.
        //
        // The idDelta is subtracted from usIndex before the conversion
        // because the values in the table we are searching are actually
        // the glyph indices minus idDelta.

            usIndexBE = usIndex - idDelta;
            usIndexBE = (uint16) ( (usIndexBE << 8) | (usIndexBE >> 8) );

        // Find the address of the glyph index array.  Since we're doing
        // pointer arithmetic with a uint16 ptr and idRangeOffset is a
        // BYTE offset, we need to divide idRangeOffset by sizeof(uint16).

            pidStart = pidRangeOffset + (idRangeOffset/sizeof(uint16));

            if (pidStart <= pusEnd) // this will always be the case except for buggy files
            {
            // Search the glyph index array backwards.  The range of the search
            // is [usLo, usHi], inclusive, which corresponds to pidStart[0]
            // through pidStart[usHi-usLo].

                for (pid = &pidStart[usHi - usLo]; pid >= pidStart; pid--)
                {
                    if ( usIndexBE == *pid )
                    {
                    // (pid-pidStart) == current offset into the glyph index
                    // array.  Glyph index array[0] corresponds to Unicode
                    // codepoint usLo.
                    // Therefore, (pid-pidStart)+usLo == current
                    // Unicode codepoint.

                        *pwc = (WCHAR) ((pid - pidStart) + usLo);

                        return TRUE;
                    }
                }
            }
        }
    }

    WARNING("TTFD!_bIndexToWchar: wonky TT file, index not found\n");
    return FALSE;
}

BOOL bIndexToWcharKern(FONTFILE *pff, WCHAR *pwc, uint16 usIndex, BOOL bVertical)
{
    BOOL bRet = bIndexToWchar(pff, pwc, usIndex, bVertical);

    if (bRet && (pff->ffca.fl & (FF_SPACE_EQUAL_NBSPACE|FF_HYPHEN_EQUAL_SFTHYPHEN)))
    {
        if ((*pwc == NBSPACE) && (pff->ffca.fl & FF_SPACE_EQUAL_NBSPACE))
        {
            *pwc = SPACE;
        }

        if ((*pwc == SFTHYPHEN) && (pff->ffca.fl & FF_HYPHEN_EQUAL_SFTHYPHEN))
        {
            *pwc = HYPHEN;
        }
    }

    return bRet;
}






/******************************Public*Routine******************************\
* cQueryKerningPairs                                                       *
*                                                                          *
*   Low level routine that pokes around inside the truetype font file      *
*   an gets the kerning pair data.                                         *
*                                                                          *
* Returns:                                                                 *
*                                                                          *
*   If pkp is NULL then return the number of kerning pairs in              *
*   the table If pkp is not NULL then return the number of                 *
*   kerning pairs copied to the buffer. In case of error,                  *
*   the return value is FD_ERROR.                                          *
*                                                                          *
* Called by:                                                               *
*                                                                          *
*   ttfdQueryFaceAttr                                                      *
*                                                                          *
* History:                                                                 *
*  Mon 17-Feb-1992 15:39:21 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

ULONG cQueryKerningPairs(FONTFILE *pff, ULONG cPairsInBuffer, FD_KERNINGPAIR *pkp, BOOL bVertical)
{
    FD_KERNINGPAIR *pkpTooFar;
    ULONG     cTables, cPairsInTable, cPairsRet;
    BYTE     *pj  =
            pff->ffca.tp.ateOpt[IT_OPT_KERN].dp                                ?
            ((BYTE *)pff->pvView +  pff->ffca.tp.ateOpt[IT_OPT_KERN].dp):
            NULL                                                          ;

    if (pj == (BYTE*) NULL)
    {
        return(0);
    }
    cTables  = BE_UINT16(pj+KERN_OFFSETOF_TABLE_NTABLES);
    pj      += KERN_SIZEOF_TABLE_HEADER;
    while (cTables)
    {
    //
    // if the subtable is of format KERN_WINDOWS_FORMAT then we can use it
    //
        if ((*(pj+KERN_OFFSETOF_SUBTABLE_FORMAT)) == KERN_WINDOWS_FORMAT)
        {
            break;
        }
        pj += BE_UINT16(pj+KERN_OFFSETOF_SUBTABLE_LENGTH);
        cTables -= 1;
    }

//
// If you have gone through all the tables and haven't
// found one of the format we like ... KERN_WINDOWS_FORMAT,
// then return no kerning info.
//
    if (cTables == 0)
    {
        return(0);
    }

    cPairsInTable = BE_UINT16(pj+KERN_OFFSETOF_SUBTABLE_NPAIRS);

    if (pkp == (FD_KERNINGPAIR*) NULL)
    {
    //
    // If the pointer to the buffer was null, then the caller
    // is asking for the number of pairs in the table. In this
    // case the size of the buffer must be zero. This assures
    // consistency
    //
        return (cPairsInBuffer ? FD_ERROR : cPairsInTable);
    }

    cPairsRet = min(cPairsInTable,cPairsInBuffer);

    pj       += KERN_SIZEOF_SUBTABLE_HEADER;
    pkpTooFar = pkp + cPairsRet;

    while (pkp < pkpTooFar)
    {
    // the routines that convert tt glyph index into a WCHAR only can fail
    // if there is a bug in the tt font file. but we check for this anyway

        if (!bIndexToWcharKern(
                 pff,
                 &pkp->wcFirst ,
                 (uint16)BE_UINT16(pj+KERN_OFFSETOF_ENTRY_LEFT),
                 bVertical
                )
            ||
            !bIndexToWcharKern(
                 pff,
                 &pkp->wcSecond,
                 (uint16)BE_UINT16(pj+KERN_OFFSETOF_ENTRY_RIGHT),
                 bVertical
                 )
           )
        {
            WARNING("TTFD!_bIndexToWchar failed\n");
            return (FD_ERROR);
        }

        pkp->fwdKern =  (FWORD)BE_UINT16(pj+KERN_OFFSETOF_ENTRY_VALUE);

    // update pointers

        pkp    += 1;
        pj     += KERN_SIZEOF_ENTRY;
    }

    return (cPairsRet);
}




/******************************Public*Routine******************************\
* pvHandleKerningPairs                                                     *
*                                                                          *
*   This routine sets up a DYNAMIC data structure to hold the kerning pair *
*   data and then calls cQueryKerning pairs to fill it up.  It also points *
*   *pid to the dynamic data structure.                                    *
*                                                                          *
* Returns:                                                                 *
*                                                                          *
*   If succesful this returns a pointer to the kerning pair data.  If not  *
*   it returns NULL.                                                       *
*                                                                          *
* Called by:                                                               *
*                                                                          *
*   ttfdQueryFontTree                                                      *
*                                                                          *
* History:                                                                 *
*  Tue 1-Mar-1994 10:39:21 by Gerrit van Wingerden [gerritv]               *
* Wrote it.                                                                *
\**************************************************************************/

VOID *pvHandleKerningPairs(HFF hff, ULONG_PTR *pid, BOOL bVertical)
{
    DYNAMICDATA *pdd;
    FS_ENTRY iRet;

// set *pid to NULL right now that way if we except the exception handler
// in the calling routine will know not to deallocate any memory

    *pid = (ULONG_PTR) NULL;


// ttfdFree must deal with the memory allocated for kerning pairs.
// We will pass a pointer to the DYNAMICDATA structure as the id.

    ASSERTDD (
        sizeof(ULONG_PTR) == sizeof(DYNAMICDATA *),
        "gdisrv!ttfdQueryFontTree(): "
        "BIG TROUBLE--pointers are not ULONG size\n"
        );

//
// Does the kerning pair array already exist?
//
    if ( PFF(hff)->pkp == (FD_KERNINGPAIR *) NULL )
    {
        ULONG   cKernPairs;     // number of kerning pairs in font
        FD_KERNINGPAIR *pkpEnd;

    // see if the file is mapped already, if not we will have to
    // map it in temporarily:

        if (PFF(hff)->cRef == 0)
        {
            //
            // have to remap the file.
            //

            PFF(hff)->pvView = PFF(hff)->pttc->pvView;
            PFF(hff)->cjView = PFF(hff)->pttc->cjView;
        }
    // Construct the kerning pairs array.
    // Determine number of kerning pairs in the font.

        if ( (cKernPairs = cQueryKerningPairs(PFF(hff), 0, (FD_KERNINGPAIR *) NULL, bVertical))
              == FD_ERROR )
        {
            return ((PVOID) NULL);
        }

    // make sure to mark the situation where SPACE and NBSPACE map to the same
    // glyph and also when HYPHEN and SFTHYPHEN map to the same glyph.

        if (cKernPairs &&
            (PFF(hff)->ffca.ui16PlatformID == BE_PLAT_ID_MS) &&
            (PFF(hff)->ffca.ui16SpecificID == BE_SPEC_ID_UGL) )
        {
            uint16 glyphIndex, glyphIndex2;
            fs_GlyphInputType *pgin = (fs_GlyphInputType *)PFF(hff)->pj034;
            fs_GlyphInputType gin;
            fs_GlyphInfoType  gout;
            // the size of this structure is sizeof(fs_SplineKey) + STAMPEXTRA.
            // It is because of STAMPEXTRA that we are not just putting the strucuture
            // on the stack such as fs_SplineKey sk; we do not want to overwrite the
            // stack at the bottom when putting a stamp in the STAMPEXTRA field.
            // [bodind]. The other way to obtain the correct alignment would be to use
            // union of fs_SplineKey and the array of bytes of length CJ_0.

            NATURAL            anat0[CJ_0 / sizeof(NATURAL)];

            if (PFF(hff)->cRef == 0)
            {
                /* we need to initialize a gin for the TrueType rasterizer */
                if ((iRet = fs_OpenFonts(&gin, &gout)) != NO_ERR)
                {
                    return ((PVOID) NULL);
                }

                ASSERTDD(NATURAL_ALIGN(gout.memorySizes[0]) == CJ_0, "mem size 0\n");
                ASSERTDD(gout.memorySizes[1] == 0,  "mem size 1\n");

                gin.memoryBases[0] = (char *)anat0;
                gin.memoryBases[1] = NULL;
                gin.memoryBases[2] = NULL;

                // initialize the font scaler, notice no fields of gin are initialized [BodinD]

                if ((iRet = fs_Initialize(&gin, &gout)) != NO_ERR)
                {
                    return ((PVOID) NULL);
                }

                // initialize info needed by NewSfnt function

                gin.sfntDirectory  = (int32 *)PFF(hff)->pvView; // pointer to the top of the view of
                                               // the ttf file

                gin.clientID = (ULONG_PTR)PFF(hff);  // pointer to the top of the view of the ttf file

                gin.GetSfntFragmentPtr = pvGetPointerCallback;
                gin.ReleaseSfntFrag  = vReleasePointerCallback;

                gin.param.newsfnt.platformID = BE_UINT16(&PFF(hff)->ffca.ui16PlatformID);
                gin.param.newsfnt.specificID = BE_UINT16(&PFF(hff)->ffca.ui16SpecificID);

                if ((iRet = fs_NewSfnt(&gin, &gout)) != NO_ERR)
                {
                    return ((PVOID) NULL);
                }

                pgin = &gin;
            }
            ASSERTDD(pgin,"pvHandleKerningPairs(): pgin is NULL\n");

            iRet = fs_GetGlyphIDs(pgin, 1, SPACE, NULL, &glyphIndex);
            iRet = fs_GetGlyphIDs(pgin, 1, NBSPACE, NULL, &glyphIndex2);
            if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
            {
                PFF(hff)->ffca.fl |= FF_SPACE_EQUAL_NBSPACE;
            }

            iRet = fs_GetGlyphIDs(pgin, 1, HYPHEN, NULL, &glyphIndex);
            iRet = fs_GetGlyphIDs(pgin, 1, SFTHYPHEN, NULL, &glyphIndex2);
            if (iRet == NO_ERR && (glyphIndex != 0 || glyphIndex2 != 0))
            {
                PFF(hff)->ffca.fl |= FF_HYPHEN_EQUAL_SFTHYPHEN;
            }
        }

    // Allocate memory for the kerning pair array.  Leave room to terminate
    // array with a zeroed FD_KERNINGPAIR structure.  Also, make room at
    // the beginning of the buffer for the DYNAMICDATA structure.
    //
    // Buffer:
    //
    //     __________________________________________________________
    //     |                 |                         |            |
    //     | DYNAMICDATA     | FD_KERNINPAIR array ... | Terminator |
    //     |_________________|_________________________|____________|
    //

        pdd =
            (DYNAMICDATA *)
            PV_ALLOC((cKernPairs + 1) * sizeof(FD_KERNINGPAIR) + sizeof(DYNAMICDATA));
        if (pdd == (DYNAMICDATA *) NULL)
        {
            return ((PVOID) NULL);
        }

    // Adjust kerning pair array pointer to point at the actual array.

        PFF(hff)->pkp = (FD_KERNINGPAIR *) (pdd + 1);

    // record to which font this data refers to:

        pdd->pff = PFF(hff); // important for consistency checking

    // set the data type

        pdd->ulDataType = ID_KERNPAIR;

    // set this here so that if we except the exception handler will know to
    // deallocate the data just allocated.

        *pid = (ULONG_PTR) pdd;

    // Fill in the array.

        if ( (cKernPairs = cQueryKerningPairs(PFF(hff), cKernPairs, PFF(hff)->pkp, bVertical))
             == FD_ERROR )
        {
        // Free kerning pair array.

            V_FREE(pdd);
            PFF(hff)->pkp = (FD_KERNINGPAIR *) NULL;
            return ((PVOID) NULL);
        }

    // Terminate the array.  (Terminating entry defined as an
    // FD_KERNINGPAIR with all fields set to zero).

        pkpEnd = PFF(hff)->pkp + cKernPairs;    // point to end of array
        pkpEnd->wcFirst  = 0;
        pkpEnd->wcSecond = 0;
        pkpEnd->fwdKern  = 0;
    }
    else
    {
        *pid = (ULONG_PTR) (((DYNAMICDATA*) PFF(hff)->pkp) - 1);
    }
//
// Return pointer to the kerning pair array.
//
    return ((PVOID) PFF(hff)->pkp);
}




/******************************Public*Routine******************************\
* ttfdQueryFontTree
*
* This function returns pointers to per-face information.
*
* Parameters:
*
*   dhpdev      Not used.
*
*   hff         Handle to a font file.
*
*   iFace       Index of a face in the font file.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFT_LIGATURES -- returns a pointer to the ligature map.
*
*       QFT_KERNPAIRS -- return a pointer to the kerning pair table.
*
*       QFT_GLYPHSET  -- return a pointer to the WC->HGLYPH mapping table.
*
*   pid         Used to identify data that ttfdFree will know how to deal
*               with it.
*
* Returns:
*   Returns a pointer to the requested data.  This data will not change
*   until BmfdFree is called on the pointer.  Caller must not attempt to
*   modify the data.  NULL is returned if an error occurs.
*
* History:
*  21-Oct-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID ttfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
    )
{
    PVOID pvRet;

    VOID vMarkFontGone(TTC_FONTFILE*, DWORD);

    HFF     hffTTC = hff;

    ASSERTDD(hff,"ttfdQueryFontTree(): invalid iFile (hff)\n");

    ASSERTDD(iFace <= PTTC(hff)->ulNumEntry,
             "gdisrv!ttfdQueryFontTree(): iFace out of range\n");

// get real hff from ttc array.

    hff   = PTTC(hffTTC)->ahffEntry[iFace-1].hff;
    iFace = PTTC(hffTTC)->ahffEntry[iFace-1].iFace;


    dhpdev;

    ASSERTDD(hff,"ttfdQueryFontTree(): invalid iFile (hff)\n");
    ASSERTDD(iFace <= PFF(hff)->ffca.ulNumFaces ,
             "ttfdQueryFaces(): iFace out of range\n");

//
// Which mode?
//
    switch (iMode)
    {
    case QFT_LIGATURES:
    //
    // !!! Ligatures not currently supported.
    //
    // There are no ligatures currently not supported,
    // therefore we return NULL.
    //
        *pid = (ULONG_PTR) NULL;

        return ((PVOID) NULL);

    case QFT_GLYPHSET:
    //
    // ttfdFree can ignore this because the glyph set will be deleted with
    // the FONTFILE structure.
    //
        *pid = (ULONG_PTR) NULL;

        if (!bReloadGlyphSet(PFF(hff), iFace))
        {
            return ((PVOID) NULL);
        }

        if (iFace == 1)
        {
            return( (PVOID) PFF(hff)->pgset );
        }
        else
        {
            ASSERTDD(PFF(hff)->pgsetv, " PFF(hff)->pgsetv should not be NULL \n");
            return( (PVOID) PFF(hff)->pgsetv );
        }

    case QFT_KERNPAIRS:

        pvRet = NULL;

        if (!bReloadGlyphSet(PFF(hff), iFace)) // inc ref counts if succeeded
        {
            return ((PVOID) NULL);
        }

#ifndef TTFD_NO_TRY_EXCEPT
        try
        {
#endif
        // make sure the file is still around

            if ((PTTC(hffTTC))->fl & FF_EXCEPTION_IN_PAGE_ERROR)
            {

                WARNING("TTFD!pvHandleKerningPairs(): file is gone\n");
            }
            else
            {
                pvRet = pvHandleKerningPairs (hff, pid, (iFace != 1));
            }

#ifndef TTFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in ttfdQueryFontTree\n");

            vMarkFontGone((TTC_FONTFILE *)PTTC(hffTTC), GetExceptionCode());

        // possibly free memory that was allocated and reset the pkp pointer
        // to NULL

            ttfdFree( NULL, *pid );
        }
#endif

    // decrement ref counts

        vReleaseGlyphSet(PFF(hff), iFace);

        return pvRet;

    default:

    //
    // Should never get here.
    //
        RIP("gdisrv!ttfdQueryFontTree(): unknown iMode\n");
        return ((PVOID) NULL);
    }
}

VOID ttfdFreeGlyphset(
    HFF     hff,
    ULONG   iFace
    )
{
    HFF     hffTTC = hff;
    EngAcquireSemaphore(ghsemTTFD);

    ASSERTDD(hff,"ttfdQueryFontTree(): invalid iFile (hff)\n");

    ASSERTDD(iFace <= PTTC(hff)->ulNumEntry,
             "gdisrv!ttfdQueryFontTree(): iFace out of range\n");

// get real hff from ttc array.

    hff   = PTTC(hffTTC)->ahffEntry[iFace-1].hff;
    iFace = PTTC(hffTTC)->ahffEntry[iFace-1].iFace;

    vReleaseGlyphSet((PFONTFILE) hff, iFace);
    
    EngReleaseSemaphore(ghsemTTFD);

}

/******************************Public*Routine******************************\
*
* BOOL bGetGlyphOutline
*
* valid outline points are in pfc->gout after this call
*
* History:
*  19-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetGlyphOutline (
    FONTCONTEXT *pfc,
    HGLYPH       hg,
    ULONG       *pig,
    FLONG        fl,
    FS_ENTRY    *piRet
    )
{
// new glyph coming in or the metric has to be recomputed
// because the contents of the gin,gout strucs have been destroyed

    vInitGlyphState(&pfc->gstat);

    ASSERTDD((hg != HGLYPH_INVALID) && ((hg & (HGLYPH)0xFFFF0000) == 0),
              "ttfdQueryGlyphBitmap: hg\n");

    vCharacterCode(hg,pfc->pgin);

// compute the glyph index from the character code:

    if ((*piRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphOutline, fs_NewGlyph\n");
    }

// return the glyph index corresponding to this hglyph:

    *pig = pfc->pgout->glyphIndex;

// these two field must be initialized before calling fs_ContourGridFit

    pfc->pgin->param.gridfit.styleFunc = 0; //!!! do some casts here

    pfc->pgin->param.gridfit.traceFunc = (FntTraceFunc)NULL;

// if bitmap is found for this glyph and if we are ultimately interested
// in bitmaps only and do not care about intermedieate outline, then set the
// bit in the "in" structure to hint the rasterizer that grid fitting
// will not be necessary:

    if (!IS_GRAY(pfc) && pfc->pgout->usBitmapFound && (fl & FL_SKIP_IF_BITMAP))
        pfc->pgin->param.gridfit.bSkipIfBitmap = 1;
    else
        pfc->pgin->param.gridfit.bSkipIfBitmap = 0; // must do hinting

// fs_ContourGridFit hints the glyph (executes the instructions for the glyph)
// and converts the glyph data from the tt file into an outline for this glyph

    if (!(fl & FL_FORCE_UNHINTED))
    {
        if ((*piRet = fs_NewContourGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
            V_FSERROR(*piRet);
            RET_FALSE("TTFD!_bGetGlyphOutline, fs_NewContourGridFit\n");
        }
    }
    else // unhinted glyphs are desired
    {
        if ((*piRet = fs_ContourNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
            V_FSERROR(*piRet);
            RET_FALSE("TTFD!_bGetGlyphOutline, fs_ContourNoGridFit\n");
        }
    }


#ifdef  DEBUG_OUTLINE
    vDbgGridFit(pfc->pgout);
#endif // DEBUG_OUTLINE

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* b_fxA_and_fxAB_are_Ok:
* This function checks if the fxA and fxAB
* that are computed by linear scaling are big enough in the following sense:
*
* The bounding box of the background parallelogram for the glyph which
* is spanned by ptfxLeft, Right, Top, Bottom (as defined by the code below)
* must fully contain the glyph bitmap.
*
* Warnings: slow function, not executed often
*
* History:
*  13-Mar-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if defined(_X86_)

VOID    ftoef_c(FLOATL, EFLOAT *);
#define vEToEF(e, pef)      ftoef_c((e), (pef))

#else // not X86

#define vEToEF(e, pef)      ( *(pef) = (e) )

#endif

// lExL is same as (LONG)(e*l), but do not want to use floating point
// math on pentium machines

LONG lExL(FLOATL e, LONG l)
{
    EFLOAT  ef;
    vEToEF(e, &ef);
    return lCvt(ef, l);
}

BOOL b_fxA_and_fxAB_are_Ok(
    FONTCONTEXT *pfc,
    GLYPHDATA   *pgldt,
    POINTL      *pptlOrigin,
    LONG         cx,
    LONG         cy
    )
{
    BOOL bRet = TRUE;
    POINTFIX ptfxLeft,ptfxRight, aptfx[4];
    LONG     xLeft, yTop, xRight, yBottom;
    INT      i;

    ptfxLeft.x   = lExL(pfc->pteUnitBase.x, pgldt->fxA);
    ptfxLeft.y   = lExL(pfc->pteUnitBase.y, pgldt->fxA);
    ptfxRight.x  = lExL(pfc->pteUnitBase.x, pgldt->fxAB);
    ptfxRight.y  = lExL(pfc->pteUnitBase.y, pgldt->fxAB);

// note that here we do not use fxInkTop and fxInkBottom
// for the individual glyph, instead we use global asc and desc,
// in parallel with G2 and G3 layout routines in the engine.
// We are adjusting fxA and fxAB so that the code for G2 and G3
// cases together with bOpaqueArea computes the bounding box of the text

    aptfx[0].x = ptfxLeft.x  + pfc->ptfxTop.x;
    aptfx[0].y = ptfxLeft.y  + pfc->ptfxTop.y;
    aptfx[1].x = ptfxRight.x + pfc->ptfxTop.x;
    aptfx[1].y = ptfxRight.y + pfc->ptfxTop.y;
    aptfx[2].x = ptfxRight.x + pfc->ptfxBottom.x;
    aptfx[2].y = ptfxRight.y + pfc->ptfxBottom.y;
    aptfx[3].x = ptfxLeft.x  + pfc->ptfxBottom.x;
    aptfx[3].y = ptfxLeft.y  + pfc->ptfxBottom.y;

// bound the paralelogram

    xLeft = xRight  = aptfx[0].x;
    yTop  = yBottom = aptfx[0].y;

    for (i = 1; i < 4; i++)
    {
        if (aptfx[i].x < xLeft)
            xLeft = aptfx[i].x;
        if (aptfx[i].x > xRight)
            xRight = aptfx[i].x;
        if (aptfx[i].y < yTop)
            yTop = aptfx[i].y;
        if (aptfx[i].y > yBottom)
            yBottom = aptfx[i].y;
    }

// Here we are following the prescription of the bOpaqueArea in textobj.cxx.
// We add a fudge factor of 1, 1/2 of the fuge factor in bOpaqueArea,
// and than check if glyph fits in the bounding rectangle.
// We add fudge factor in order to execute this function
// as few times as possible, but for glyph to still fit in the background
// rectangle computed by bOpaqueArea

    #define FUDGE 1

    xLeft   = FXTOLFLOOR(xLeft) - FUDGE;
    yTop    = FXTOLFLOOR(yTop)  - FUDGE;
    xRight  = FXTOLCEILING(xRight)  + FUDGE;
    yBottom = FXTOLCEILING(yBottom) + FUDGE;

// now check if glyph bitmap fits in the bounding rectangle, if not
// we need to augment fxA and fxAB and try again.

    if (xLeft > pptlOrigin->x)
        pptlOrigin->x = xLeft;

    if (yTop > pptlOrigin->y)
        pptlOrigin->y = yTop;

    if
    (
        (xRight  < (pptlOrigin->x + cx)) ||
        (yBottom < (pptlOrigin->y + cy))
    )
    {
    // this code path is executed very rarely, that is only
    // in case of really wierd transforms. Yet, because such
    // transforms exist and used to crash machines, we needed to add
    // this routine. That is, in most cases this routine will be called
    // only once in the loop to confirm that fxA and fxAB as computed
    // by linear scaling are fine. When they are not fine the routine
    // will be called again with new augmented values of fxA and fxAB.

    #ifdef DEBUG_FXA_FXAB
        TtfdDbgPrint("need to fix rcfxInkBox: %ld, %ld, %ld, %ld\n",
            xLeft,
            yTop,
            xRight,
            yBottom);
        TtfdDbgPrint("glyph cell            : %ld, %ld, %ld, %ld\n\n",
            pptlOrigin->x,
            pptlOrigin->y,
            pptlOrigin->x + cx,
            pptlOrigin->y + cy);
    #endif

        bRet = FALSE; // not big enough.
    }

    return bRet;
}



/******************************Public*Routine******************************\
*
* BOOL bGetGlyphMetrics
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetGlyphMetrics (
    PFONTCONTEXT pfc,
    HGLYPH       hg,
    FLONG        fl,
    FS_ENTRY    *piRet
    )
{
    ULONG  ig;
    FS_ENTRY i;

    if (!bGetGlyphOutline(pfc,hg,&ig,fl,piRet))
    {
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphMetrics, bGetGlyphOutline failed \n");
    }

// get the metric info for this glyph,

    i = fs_FindBitMapSize(pfc->pgin, pfc->pgout);

    if (i != NO_ERR)
    {
        *piRet = i;
        V_FSERROR(*piRet);
        RET_FALSE("TTFD!_bGetGlyphMetrics, fs_FindBitMapSize \n");
    }


// now that everything is computed sucessfully, we can update
// glyphstate (hg data stored in pj3) and return

    pfc->gstat.hgLast = hg;
    pfc->gstat.igLast = ig;

    return(TRUE);
}


VOID vGetVertNotionalMetrics
(
FONTCONTEXT *pfc,       // in
ULONG        ig,        // in
SHORT        yMin,      // in, ngm.yMin
LONG         *plAH,     // out, advance height
LONG         *plTSB     // out, tsb
)
{
    ULONG cVMTX = pfc->pff->ffca.uLongVerticalMetrics;
    int16 sAH, sTSB;

    ASSERTDD(pfc->bVertical, "vGetVertNotionalMetrics, bVertical = 0\n");
    ASSERTDD(pfc->pgout->glyphIndex == ig, "vGetVertNotionalMetrics, ig wrong\n");

    if (cVMTX && bValidRangeVMTX(pfc->ptp->ateOpt[IT_OPT_VMTX].cj,ig, cVMTX) ) 
    {
        uint8 *pvmtx = (uint8*) pfc->pff->pvView +
                       pfc->pff->ffca.tp.ateOpt[IT_OPT_VMTX].dp;

        if (ig < cVMTX)
        {
            sAH  = SWAPW(*((int16 *)&pvmtx[ig*4]));
            sTSB = SWAPW(*((int16 *)&pvmtx[ig*4+2]));
        }
        else
        {
            int16 * psTSB = (int16 *) (&pvmtx[cVMTX * 4]); /* first entry after[AW,TSB] array */

            sAH  = SWAPW(*((int16 *)&pvmtx[(cVMTX-1)*4]));
            sTSB = SWAPW(psTSB[ig - cVMTX]);
        }
    }
    else // few buggy fonts do not have vmtx table
    {
    // default AdvanceHeight and TopSideBearing from Ascender and Descender

        sAH  = pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender;
        sTSB = pfc->pff->ifi.fwdWinAscender + yMin; // y points down!!!

    // at this point sTSB should be bigger than 0. But because of the bugs in
    // our fonts, mingliu.ttc etc, it turns out that there are glyphs that
    // have their tops significanly above the descender so sTSB becomes
    // negative, even though it should not be. So we hack it now:

        if (sTSB < 0)
            sTSB = 0;
    }

    *plAH  = sAH;
    *plTSB = sTSB;
}




/******************************Public*Routine******************************\
* VOID vFillGLYPHDATA
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vFillGLYPHDATA(
    HGLYPH            hg,
    ULONG             ig,
    FONTCONTEXT      *pfc,
    fs_GlyphInfoType *pgout,   // outputed from fsFind bitmap size
    GLYPHDATA        *pgldt,   // OUT
    GMC              *pgmc,    // optional, not used if doing outline only
    POINTL           *pptlOrigin
    )
{
    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);

    BOOL bOutOfBounds = FALSE;

    vectorType     * pvtD;  // 16.16 point
    LONG lA,lAB;      // *pvtA rounded to the closest integer value

    BOOL bVert = pfc->bVertical && (pfc->ulControl & VERTICAL_MODE);

    ULONG  cx = (ULONG)(pgout->bitMapInfo.bounds.right - pgout->bitMapInfo.bounds.left);
    ULONG  cy = (ULONG)(pgout->bitMapInfo.bounds.bottom - pgout->bitMapInfo.bounds.top);

    LONG lAdvanceHeight;
    LONG lTopSideBearing;

    pgldt->gdf.pgb = NULL; // may get changed by the calling routine if bits requested too
    pgldt->hg = hg;

// fs_FindBitMapSize returned  the the following information in gout:
//
//  1) gout.metricInfo // left side bearing and advance width
//
//  2) gout.bitMapInfo // black box info
//
//  3) memory requirement for the bitmap,
//     returned in gout.memorySizes[5] and gout.memorySizes[6]
//
// Notice that fs_FindBitMapSize is exceptional scaler interface routine
// in that it returns info in several rather than in a single
// substructures of gout

// Check if hinting produced totally unreasonable result:

    bOutOfBounds = ( (pgout->bitMapInfo.bounds.left > pfc->xMax)    ||
                     (pgout->bitMapInfo.bounds.right < pfc->xMin)   ||
                     (-pgout->bitMapInfo.bounds.bottom > pfc->yMax) ||
                     (-pgout->bitMapInfo.bounds.top < pfc->yMin)    );

    #if DBG
        if (bOutOfBounds)
            TtfdDbgPrint("TTFD! Glyph out of bounds: ppem = %ld, gi = %ld\n",
                pfc->lEmHtDev, hg);
    #endif

out_of_bounds:

    if ((cx == 0) || (cy == 0) || bOutOfBounds)
    {
    // will be replaced by a a fake 1x1 bitmap

        pgldt->rclInk.left   = pfc->ptlSingularOrigin.x;
        pgldt->rclInk.top    = pfc->ptlSingularOrigin.y;
        pgldt->rclInk.right  = pgldt->rclInk.left + 1; // ink white for this glyph!
        pgldt->rclInk.bottom = pgldt->rclInk.top + 1;  // ink white for this glyph!

    // more of hackorama forced upon me by DaveC so that suppossedly
    // video drivers do not have to do a check on cx and cy.
    // By setting right = bottom = 1 for blank glyph we are slightly
    // incompatible with win31 in that they would return zero cx and cy
    // when calling GGO, as well as B space equal to 0 in GetCharABCWidths.
    // NT will return 1 for all of these quantities. I think we want to fix
    // our drivers for Cairo to be able to accept cx = cy = 0.

        if (pgmc != (PGMC)NULL)
        {
            pgmc->cxCor = 0;  // forces blank glyph case when filling the bits
            pgmc->cyCor = 0;  // forces blank glyph case when filling the bits
        }
    }
    else // non empty bitmap
    {
        lA = (LONG)pgout->bitMapInfo.bounds.left;
        lAB = lA + (LONG)cx;

    // black box info, we have to transform y coords to ifi specifications

        pgldt->rclInk.bottom = - pgout->bitMapInfo.bounds.top;
        pgldt->rclInk.top    = - pgout->bitMapInfo.bounds.bottom;

        if (pgmc != (PGMC)NULL)
        {
            LONG dyTop, dyBottom, dxLeft, dxRight;
            LONG dxError, dyError;

        #define MAXERROR 10

            dyTop    = (pgldt->rclInk.top < pfc->yMin) ?
                       (pfc->yMin - pgldt->rclInk.top) :
                       0;

            dyBottom = (pgldt->rclInk.bottom > pfc->yMax) ?
                       (pgldt->rclInk.bottom - pfc->yMax) :
                       0;

            if (dyTop || dyBottom)
            {
            // will have to chop off a few scans, infrequent

            #if DBG
                if ((LONG)cy < (dyTop + dyBottom))
                {
                    TtfdDbgPrint("TTFD!_dcy: ppem = %ld, gi = %ld, cy: %ld, dyTop: %ld, dyBottom: %ld\n",
                        pfc->lEmHtDev, hg, cy, dyTop,dyBottom);
                    EngDebugBreak();
                }
            #endif

                cy -= (dyTop + dyBottom);
                pgldt->rclInk.top += dyTop;
                pgldt->rclInk.bottom -= dyBottom;

                dyError = max(pfc->lEmHtDev, MAXERROR);
                if ((dyTop > dyError) || (dyBottom > dyError))
                {
                // something is really bogus, let us bail out:

                    bOutOfBounds = TRUE;
                    goto out_of_bounds;
                }
            }

        // let us see how good is scaling with appropriate rounding
        // to determine xMin and xMax:

            dxLeft = dxRight = 0;
            if (lA < pfc->xMin)
                dxLeft = pfc->xMin - lA;
            if (lAB > pfc->xMax)
                dxRight = lAB - pfc->xMax;

            if (dxLeft || dxRight)
            {
            #if DBG
                TtfdDbgPrint("TTFD! ppem = %ld"
                  ", gi = %ld,  dxLeft: %ld, dxRight: %ld\n"
                  , pfc->lEmHtDev, hg, dxLeft,dxRight
                );
                if ((LONG)cx  < (dxLeft + dxRight))
                {
                    TtfdDbgPrint(
                        "TTFD!_dcx: ppem = %ld, gi = %ld, cx: %ld"
                        ", dxLeft: %ld, dxRight: %ld\n",
                        pfc->lEmHtDev, hg, cx, dxLeft, dxRight);
                    EngDebugBreak();
                }
            #endif // DBG

                cx  -= (dxLeft + dxRight);
                lA  += dxLeft;
                lAB -= dxRight;

                dxError = (LONG)max((pfc->cxMax/4),MAXERROR);
                if ((dxLeft > dxError) || (dxRight > dxError))
                {
                // something is really bogus, let us bail out:

                    bOutOfBounds = TRUE;
                    goto out_of_bounds;
                }
            }
            ASSERTDD(cx <= pfc->cxMax, "cx > cxMax\n");

            pgmc->dyTop    = (ULONG)dyTop   ;
            pgmc->dyBottom = (ULONG)dyBottom;
            pgmc->dxLeft   = (ULONG)dxLeft  ;
            pgmc->dxRight  = (ULONG)dxRight ;
            pgmc->cxCor    = cx;
            pgmc->cyCor    = cy;

        // only corrected values have to obey this condition:

            ASSERTDD(
                pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
            ASSERTDD(
                CJGD(pgmc->cxCor,pgmc->cyCor,pfc) <= pfc->cjGlyphMax,
                "ttfdQueryGlyphBitmap, cjGlyphMax \n"
                );
        }

    // x coords do not transform, just shift them

        pgldt->rclInk.left = lA;
        pgldt->rclInk.right = lAB;

    } // end of the non empty bitmap clause

// go on to compute the positioning info:
    pvtD = & pgout->metricInfo.devAdvanceWidth;

    if (pfc->flXform & XFORM_HORIZ)  // scaling only
    {
        FIX fxTmp;

    // We shall lie to the engine and store integer
    // pre and post bearings and char inc vectors because
    // win31 also rounds, but we should not round for nondiag xforms


    // bGetFastAdvanceWidth returns the same aw that would get
    // computed by bQueryAdvanceWidths and propagated to an api
    // level through GetTextExtent and GetCharWidths. We have to
    // fill in the same aw for consistency reasons.
    // This also has to be done for win31 compatibility.

        if (bVert)
        {
            lAdvanceHeight = F16_16TOLROUND(pgout->verticalMetricInfo.devAdvanceHeight.y);

            pgldt->fxD = LTOFX(lAdvanceHeight);

            /* metrics from the rasterizer are already adjusted for embolding simulation */
        }
        else
        {
            if (!bGetFastAdvanceWidth(pfc,ig, &pgldt->fxD))
            {
            // not possible to get the fast value, use the "slow" value
            // supplied by the rasterizer.

                pgldt->fxD = F16_16TOLROUND(pvtD->x);
                pgldt->fxD = LTOFX(pgldt->fxD);
            } else {
                USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards compatibility reason, we inclease the width only by one pixel */
                if (pgldt->fxD != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                {
                    if (pfc->mx.transform[0][0] < 0)
                    {
                        pgldt->fxD -= cxExtra;
                    } 
                    else 
                    {
                        pgldt->fxD += cxExtra;
                    }
                }
            }
        #ifdef DEBUG_AW

        // this should alsmost never happen, one example when it does
        // is Lucida Sans Unicode at 14 pt, glyph 'a', try from winword
        // the possible source of discrepancy is a bug in hdmx or ltsh
        // tables or a loss of precission in some of mult. math routines

            else
            {
                fxTmp = F16_16TOLROUND(pvtD->x);
                fxTmp = LTOFX(fxTmp);
                if (fxTmp != pgldt->fxD)
                {
                // print out a warning

                    fxTmp -= pgldt->fxD;
                    if (fxTmp < 0)
                        fxTmp = - fxTmp;

                    if (fxTmp > 16)
                    {
                        TtfdDbgPrint("ttfd! fxDSlow = 0x%lx\n", pgldt->fxD);
                    }
                }
            }

        #endif // DEBUG_AW

        }
        pgldt->ptqD.x.HighPart = (LONG)pgldt->fxD;
        pgldt->ptqD.x.LowPart  = 0;

        if (pfc->mx.transform[0][0] < 0)
            pgldt->fxD = - pgldt->fxD;  // this is an absolute value

    // make CharInc.y zero even if the rasterizer messed up

        pgldt->ptqD.y.HighPart = 0;
        pgldt->ptqD.y.LowPart  = 0;

#if DBG
        // if (pvtD->y) {TtfdDbgPrint("TTFD!_ pvtD->y = 0x%lx\n", pvtD->y);}
#endif

        if (bVert)
        {
            LONG lWidthOfBitmap = pgldt->rclInk.right-pgldt->rclInk.left;

            lTopSideBearing = F16_16TOLROUND(pgout->verticalMetricInfo.devTopSideBearing.x);

            if(pfc->mx.transform[0][0] < 0)
            {
                lTopSideBearing = - lTopSideBearing - lWidthOfBitmap;
                pgldt->rclInk.right = -lTopSideBearing;
                pgldt->rclInk.left = pgldt->rclInk.right - lWidthOfBitmap;
            }
            else
            {
                pgldt->rclInk.left = lTopSideBearing;
                pgldt->rclInk.right = pgldt->rclInk.left + lWidthOfBitmap;
            }

            pgldt->fxA = LTOFX(lTopSideBearing);
            pgldt->fxAB = LTOFX(lWidthOfBitmap) + pgldt->fxA;

        }
        else
        {
            pgldt->fxA = LTOFX(pgldt->rclInk.left);
            pgldt->fxAB = LTOFX(pgldt->rclInk.right);

            if (pfc->mx.transform[0][0] < 0)
            {
                fxTmp = pgldt->fxA;
                pgldt->fxA = -pgldt->fxAB;
                pgldt->fxAB = -fxTmp;
            }
        }


    // - is used here since ascender points in the negative y direction

        pgldt->fxInkTop    = -LTOFX(pgldt->rclInk.top);
        pgldt->fxInkBottom = -LTOFX(pgldt->rclInk.bottom);

        if (pfc->mx.transform[1][1] < 0)
        {
            fxTmp = pgldt->fxInkTop;
            pgldt->fxInkTop = -pgldt->fxInkBottom;
            pgldt->fxInkBottom = -fxTmp;
        }
    }
    else // non trivial information
    {
    // here we will just xform the notional space data:

        NOT_GM ngm;  // notional glyph data
        USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards compatibility reason, we increase the width only by one pixel */

        vGetNotionalGlyphMetrics(pfc,ig,&ngm);

    // xforms are computed by simple multiplication

        pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);

        if (pfc->flXform & XFORM_VERT)
        {
            if (bVert)
            {
                LONG lHeightOfBox;

                lAdvanceHeight = F16_16TOLROUND(pgout->verticalMetricInfo.devAdvanceHeight.x);
                lTopSideBearing = F16_16TOLROUND(pgout->verticalMetricInfo.devTopSideBearing.y);
                lHeightOfBox = pgldt->rclInk.bottom - pgldt->rclInk.top;

                if( pfc->mx.transform[0][1] < 0 )
                {
                    lTopSideBearing = -lTopSideBearing;
                    pgldt->rclInk.top = lTopSideBearing;
                    pgldt->rclInk.bottom = pgldt->rclInk.top + lHeightOfBox;
                }
                else
                {
                    lTopSideBearing = lTopSideBearing - lHeightOfBox;
                    pgldt->rclInk.bottom = -lTopSideBearing;
                    pgldt->rclInk.top = pgldt->rclInk.bottom - lHeightOfBox;

                    lAdvanceHeight = - lAdvanceHeight; // this is an absolute value
                }

                pgldt->fxD = LTOFX(lAdvanceHeight);
                pgldt->ptqD.x.LowPart  = 0;
                pgldt->ptqD.x.HighPart = 0;
                pgldt->ptqD.y.LowPart  = 0;

                /* metrics from the rasterizer are already adjusted for embolding simulation */
            }
            else
            {

                pgldt->fxD = FXTOLROUND(pgldt->fxD);
                pgldt->fxD = LTOFX(pgldt->fxD);

                pgldt->ptqD.x.LowPart  = 0;
                pgldt->ptqD.x.HighPart = 0;
                pgldt->ptqD.y.LowPart  = 0;

                /* adjust for embolding simulation */
                if (pgldt->fxD != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                    pgldt->fxD += cxExtra;
            }

            if (IS_FLOATL_MINUS(pfc->pteUnitBase.y)) // base.y < 0
            {
                pgldt->fxA  = -LTOFX(pgldt->rclInk.bottom);
                pgldt->fxAB = -LTOFX(pgldt->rclInk.top);
                pgldt->ptqD.y.HighPart = -(LONG)pgldt->fxD;
            }
            else
            {
                pgldt->fxA  = LTOFX(pgldt->rclInk.top);
                pgldt->fxAB = LTOFX(pgldt->rclInk.bottom);
                pgldt->ptqD.y.HighPart = (LONG)pgldt->fxD;
            }

            if (IS_FLOATL_MINUS(pfc->pteUnitSide.x)) // asc.x < 0
            {
                pgldt->fxInkTop    = -LTOFX(pgldt->rclInk.left);
                pgldt->fxInkBottom = -LTOFX(pgldt->rclInk.right);
            }
            else
            {
                pgldt->fxInkTop    = LTOFX(pgldt->rclInk.right);
                pgldt->fxInkBottom = LTOFX(pgldt->rclInk.left);
            }
        }
        else // most general case, totally arb. xform.
        {
            POINTL         ptlOrigin;

            if (bVert)
            {
                vGetVertNotionalMetrics(pfc, ig, ngm.yMin, &lAdvanceHeight, &lTopSideBearing);

                vLTimesVtfl(lAdvanceHeight, &pfc->vtflBase, &pgldt->ptqD);

                pgldt->fxD = fxLTimesEf(&pfc->efBase, lAdvanceHeight);

                ptlOrigin.x =  F16_16TOLROUND(pgout->metricInfo.devLeftSideBearing.x);
                ptlOrigin.y = -F16_16TOLROUND(pgout->metricInfo.devLeftSideBearing.y);

                pgldt->fxA         = fxLTimesEf(&pfc->efBase, lTopSideBearing);
                pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.yMax - (LONG)ngm.yMin + lTopSideBearing);

                pgldt->fxInkTop    = - fxLTimesEf(&pfc->efSide, (LONG)ngm.xMax);
                pgldt->fxInkBottom = - fxLTimesEf(&pfc->efSide, (LONG)ngm.xMin);

            }
            else
            {
                vLTimesVtfl((LONG)ngm.sD, &pfc->vtflBase, &pgldt->ptqD);


                ptlOrigin.x =  F16_16TOLROUND(pgout->metricInfo.devLeftSideBearing.x);
                ptlOrigin.y = -F16_16TOLROUND(pgout->metricInfo.devLeftSideBearing.y);

                pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
                pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

                pgldt->fxInkTop    = - fxLTimesEf(&pfc->efSide, (LONG)ngm.yMin);
                pgldt->fxInkBottom = - fxLTimesEf(&pfc->efSide, (LONG)ngm.yMax);

            }

            if (pfc->flFontType & FO_SIM_BOLD) 
            {

                if ((pgldt->ptqD.x.HighPart != 0) || (pgldt->ptqD.y.HighPart != 0)) /* we don't increase the width of a zero width glyph, problem with indic script */
                {
                        vAddPOINTQF(&pgldt->ptqD,&pfc->ptqUnitBase);
                    pgldt->fxD += LTOFX(1);
                }
	// the emboldening is done by dBase but the advance width is increased only by one pixel
                pgldt->fxAB += LTOFX(pfc->dBase);
            }

            // just to be safe let us round these up and down appropriately

            #define ROUND_DOWN(X) ((X) & ~0xf)
            #define ROUND_UP(X)   (((X) + 15) & ~0xf)

            pgldt->fxA         = ROUND_DOWN(pgldt->fxA);
            pgldt->fxAB        = ROUND_UP(pgldt->fxAB);

            pgldt->fxInkTop    = ROUND_UP(pgldt->fxInkTop);
            pgldt->fxInkBottom = ROUND_DOWN(pgldt->fxInkBottom);

            if (pgmc && pgmc->cxCor && pgmc->cyCor)
            {
                int iCutoff = 0;
                while (!b_fxA_and_fxAB_are_Ok(
                                   pfc,
                                   pgldt,
                                   &ptlOrigin,
                                   (LONG)pgmc->cxCor,
                                   (LONG)pgmc->cyCor) && (iCutoff++ < 2000))
                {
                    pgldt->fxA  -= 16;
                    pgldt->fxAB += 16;

                    if ((pgldt->fxInkTop + 16) < LTOFX(pfc->lAscDev))
                        pgldt->fxInkTop += 16;
                    if ((pgldt->fxInkBottom - 16) > -LTOFX(pfc->lDescDev))
                        pgldt->fxInkTop -= 16;
                }
            }

            if (pptlOrigin)
                *pptlOrigin = ptlOrigin;

        }

    }

    // If the caller requests a minimal bitmap and the bitmap or the
    // corrected bimap has a zero extent in any dimension then
    // the font driver will replace the original bitmap by a
    // phony 1 x 1 blank bitmap. See lGetGlyphBitmap near
    // the code  "pgb->sizlBitmap.cx = 1".

    if ((cx == 0 || cy == 0) ||
        (pgmc && (pgmc->cxCor == 0 || pgmc->cyCor == 0)))
    {
        pgldt->fxA           = 0;
        pgldt->fxAB          = 16;
        pgldt->fxInkTop      = 0;
        pgldt->fxInkBottom   = 16;
        pgldt->rclInk.left   = 0;
        pgldt->rclInk.top    = 0;
        pgldt->rclInk.right  = 1;
        pgldt->rclInk.bottom = 1;
    }

}


/******************************Public*Routine******************************\
*
* ttfdQueryTrueTypeTable
*
* copies cjBytes starting at dpStart from the beginning of the table
* into the buffer
*
* if pjBuf == NULL or cjBuf == 0, the caller is asking how big a buffer
* is needed to store the info from the offset dpStart to the table
* specified by ulTag to the end of the table
*
* if pjBuf != 0  the caller wants no more than cjBuf bytes from
* the offset dpStart into the table copied into the
* buffer.
*
* if table is not present or if dpScart >= cjTable 0 is returned
*
* tag 0 means that the data has to be retrieved from the offset dpStart
* from the beginning of the file. The lenght of the whole file
* is returned if pBuf == nULL
*
* History:
*  09-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


PBYTE pjTable(ULONG ulTag, PFONTFILE pff, ULONG *pcjTable);

LONG ttfdQueryTrueTypeTable2 (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    BYTE   *pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in the mapped file
    ULONG  *pcjTable // size of the whole table
    )
{
    PBYTE     pjBegin;  // ptr to the beginning of the table
    LONG      cjTable;
    HFF       hffTTC = hff;

    ASSERTDD(hff, "ttfdQueryTrueTypeTable\n");

    if (dpStart < 0)
        return (FD_ERROR);

// if this font file is gone we are not gonna be able to answer any questions
// about it

    if (PTTC(hffTTC)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("TTFD!ttfdQueryTrueTypeTable: file is gone\n");
        return FD_ERROR;
    }

    ASSERTDD(ulFont <= PTTC(hffTTC)->ulNumEntry,
             "gdisrv!ttfdQueryFaces(): iFace out of range\n"
             );

// get real hff from ttc array.

    hff    = PTTC(hffTTC)->ahffEntry[ulFont-1].hff;
    ulFont = PTTC(hffTTC)->ahffEntry[ulFont-1].iFace;

    ASSERTDD(ulFont <= PFF(hff)->ffca.ulNumFaces,
             "TTFD!_ttfdQueryTrueTypeTable: ulFont != 1\n");

// verify the tag, determine whether this is a required or an optional
// table:

#define tag_TTCF  0x66637474    // 'ttcf'

    if(ulTag == tag_TTCF)
    {
    // if the table offset is 0 it can't be a TTC and we should fail.

        if(PFF(hff)->ffca.ulTableOffset)
        {
            pjBegin = (PBYTE)PFF(hff)->pvView;
            cjTable = PFF(hff)->cjView;
        }
        else
        {
            return(FD_ERROR);
        }
    }
    else
    if (ulTag == 0)  // requesting the whole file
    {
        pjBegin = (PBYTE)PFF(hff)->pvView + PFF(hff)->ffca.ulTableOffset;
        cjTable = PFF(hff)->cjView - PFF(hff)->ffca.ulTableOffset; // cjView == cjFile
    }
    else // some specific table is requested
    {
        pjBegin = pjTable(ulTag, PFF(hff), &cjTable);

        if (pjBegin == (PBYTE)NULL)  // table not present
            return (FD_ERROR);
    }

// if we are succesfull now is the time to return
// the pointer to the whole table in the file and its size:

    if (ppjTable)
    {
        *ppjTable = pjBegin;
    }
    if (pcjTable)
    {
        *pcjTable = cjTable;
    }

// adjust pjBegin to point to location from where the data is to be copied

    pjBegin += dpStart;
    cjTable -= (LONG)dpStart;

    if (cjTable <= 0) // dpStart offsets into mem after the end of table
        return (FD_ERROR);

    if ( (pjBuf == (PBYTE)NULL) || (cjBuf == 0) )
    {
    // the caller is asking how big a buffer it needs to allocate to
    // store the bytes from the offset dpStart into the table to
    // the end of the table (or file if tag is zero)

        return (cjTable);
    }

// at this point we know that pjBuf != 0, the caller wants cjBuf bytes copied
// into his buffer:

    if ((ULONG)cjTable > cjBuf)
        cjTable = (LONG)cjBuf;

    RtlCopyMemory((PVOID)pjBuf, (PVOID)pjBegin, cjTable);

    return (cjTable);
}



LONG
ttfdQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    BYTE   *pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// pointer in the file
    ULONG  *pcjTable // size of the whole table
    )
{
    LONG lRet;
    HFF hffTTF;

    // update the HFF with the remapped view

    hffTTF   = PTTC(hff)->ahffEntry[ulFont-1].hff;

    if (PFF(hffTTF)->cRef == 0)
    {

        PFF(hffTTF)->pvView = PTTC(hff)->pvView;
        PFF(hffTTF)->cjView = PTTC(hff)->cjView;
    }

    lRet = ttfdQueryTrueTypeTable2(
               hff, ulFont, ulTag, dpStart,
               cjBuf, pjBuf, ppjTable, pcjTable);

    return lRet;
}




/******************************Public*Routine******************************\
*
* ttfdGetTrueTypeFile
*
*  private entry point for the engine, supported only off of ttfd to expose
*  the pointer to the memory mapped file to the device drivers
*
* History:
*  04-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID *ttfdGetTrueTypeFile( HFF hff, ULONG *pcj )
{
    PVOID pvView = NULL; // essential to initialize
    *pcj  = 0;

    ASSERTDD(hff, "ttfdGetTrueTypeFile, hff\n");

    if (PTTC(hff)->cRef)
    {
        pvView = PTTC(hff)->pvView;
        *pcj   = PTTC(hff)->cjView;
    }
    return (pvView);
}


/******************************Public*Routine******************************\
* ttfdQueryGlyphAttrs
*
* Get glyph attributes
*
\**************************************************************************/

PFD_GLYPHATTR  ttfdQueryGlyphAttrs (FONTOBJ *pfo)
{

    FONTCONTEXT *pfc;

    ASSERTDD(pfo->iFile, "ttfdQueryGlyphAttrs, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("TTFD!ttfdQueryGlyphAttrs: file is gone\n");
        return NULL;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
    }

    if (pfc == (FONTCONTEXT *) NULL)
    {
        WARNING("TTFD!gdisrv!ttfdQueryGlyphAttrs(): cannot create font context\n");
        return NULL;
    }

    return pfc->pff->pttc->pga;
}


/******************************Public*Routine******************************\
* ttfdQueryFontFile
*
* A function to query per font file information.
*
* Parameters:
*
*   hff         Handle to a font file.
*
*   ulMode      This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFF_DESCRIPTION -- copies a UNICODE string in the buffer
*                          that describes the contents of the font file.
*
*       QFF_NUMFACES   -- returns number of faces in the font file.
*
*   cjBuf       Maximum number of BYTEs to copy into the buffer.  The
*               driver will not copy more than this many BYTEs.
*
*               This should be zero if pulBuf is NULL.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
*   pulBuf      Pointer to the buffer to receive the data
*               If this is NULL, then the required buffer size
*               is returned as a count of BYTEs.  Notice that this
*               is a PULONG, to enforce 32-bit data alignment.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
* Returns:
*
*   If mode is QFF_DESCRIPTION, then the number of BYTEs copied into
*   the buffer is returned by the function.  If pulBuf is NULL,
*   then the required buffer size (as a count of BYTEs) is returned.
*
*   If mode is QFF_NUMFACES, then number of faces in font file is returned.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  22-Oct-1992 -by- Gilman Wong [gilmanw]
* Added QFF_NUMFACES mode (IFI/DDI merge).
*
*  09-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryFontFile (
    HFF     hff,        // handle to font file
    ULONG   ulMode,     // type of query
    ULONG   cjBuf,      // size of buffer (in BYTEs)
    ULONG  *pulBuf      // return buffer (NULL if requesting size of data)
    )
{
    PIFIMETRICS pifi;

    ASSERTDD(hff != HFF_INVALID, "ttfdQueryFontFile(): invalid HFF\n");

    switch (ulMode)
    {
      case QFF_DESCRIPTION:
      {
          ULONG ulIndex;
          LPWSTR  pwszDesc = (LPWSTR)pulBuf;
          LONG  lBuffer = 0;

          for( ulIndex = 0;
              ulIndex < PTTC(hff)->ulNumEntry;
              ulIndex++
              )
          {
              LONG wchlen;

          // if this is a entry for vertical face font, just skip it...

              if( !((PTTC(hff)->ahffEntry[ulIndex].iFace) & 0x1) )
                continue;

              pifi = &((PFF(PTTC(hff)->ahffEntry[ulIndex].hff))->ifi);

              wchlen = (LONG)(pifi->dpwszStyleName - pifi->dpwszFaceName) / sizeof(WCHAR);

              if (ulIndex != 0)
              {
                  if (pwszDesc != (LPWSTR) NULL)
                  {
                      wcscpy((LPWSTR)pwszDesc, (LPWSTR) L" & ");
                      pwszDesc += 3;
                  }
                  lBuffer += (3 * sizeof(WCHAR));
              }

              if (pwszDesc != (LPWSTR) NULL)
              {
                  wcscpy((LPWSTR)pwszDesc, (LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName));
                  pwszDesc += (wchlen-2); // -2 for overwrite NULL at next time.
              }
              lBuffer += (wchlen * sizeof(WCHAR));
          }

          return( lBuffer );
      }

    case QFF_NUMFACES:
    //
    // Currently, only one face per TrueType file.  This may one day change!
    //

      return (PTTC(hff))->ulNumEntry;

    default:
        WARNING("TTFD!ttfdQueryFontFile(): invalid mode\n");
        return FD_ERROR;
    }
}


/******************************Public*Routine******************************\
*
* vCopyAndZeroOutPaddingBits
*
* copies the bits of the bitmap and zeroes out padding bits
*
* History:
*  18-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

// array of masks for the last byte in a row

static const BYTE gjMask[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static const BYTE gjMaskHighBit[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1F, 0X3F, 0X7F};

VOID vCopyAndZeroOutPaddingBits(
    FONTCONTEXT *pfc,
    GLYPHBITS   *pgb,
    BYTE        *pjSrc,
    GMC         *pgmc
    )
{
    BYTE   jMask = gjMask[pgmc->cxCor & 7];
    ULONG  cjScanSrc = CJ_TT_SCAN(pgmc->cxCor+pgmc->dxLeft+pgmc->dxRight,pfc);
    ULONG  cxDst = pgmc->cxCor;
    ULONG  cjScanDst = CJ_MONOCHROME_SCAN(cxDst);      // includes emboldening if any
    ULONG  cjDst = CJ_MONOCHROME_SCAN(pgmc->cxCor);    // does not include emboldening
    BYTE   *pjScan, *pjScanEnd;
    ULONG  iByteLast = cjDst - 1;

// sanity checks

    ASSERTDD(!IS_GRAY(pfc),"Monochrome Images Only Please!\n");
    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,
        "We haven't decided about pixel depth\n"
    );
    ASSERTDD(pgmc->cxCor < LONG_MAX, "TTFD!vCopyAndZeroOutPaddingBits, cxCor\n");
    ASSERTDD(pgmc->cyCor < LONG_MAX, "TTFD!vCopyAndZeroOutPaddingBits, cyCor\n");
    ASSERTDD(pgmc->cxCor > 0, "vCopyAndZeroOutPaddingBits, cxCor == 0\n");
    ASSERTDD(pgmc->cyCor > 0, "vCopyAndZeroOutPaddingBits, cyCor == 0\n");

    pgb->sizlBitmap.cx = cxDst;

    pgb->sizlBitmap.cy = pgmc->cyCor;

// skip the rows at the top that we want to chop off

    if (pgmc->dyTop)
    {
        pjSrc += (pgmc->dyTop * cjScanSrc);
    }

// if must chop off a few columns (on the right, this should almost
// never happen), put the warning for now to detect these
// situations and look at them, it does not matter if this is slow

    pjScan = pgb->aj;


    if ((pgmc->dxLeft & 7) == 0) // common fast case
    {
        pjSrc += (pgmc->dxLeft >> 3); // adjust the source
        for (
             pjScanEnd = pjScan + (pgmc->cyCor * cjScanDst);
             pjScan < pjScanEnd;
             pjScan += cjScanDst, pjSrc += cjScanSrc
            )
        {
            RtlCopyMemory((PVOID)pjScan,(PVOID)pjSrc,cjDst);
            pjScan[iByteLast] &= jMask; // mask off the last byte
        }
    }
    else // must shave off from the left:
    {
        BYTE   *pjD, *pjS, *pjDEnd, *pjSrcEnd;
        ULONG   iShiftL, iShiftR;

        iShiftL = pgmc->dxLeft & 7;
        iShiftR = 8 - iShiftL;

        pjSrcEnd = pjSrc + (pgmc->cyCor * cjScanSrc);
        pjSrc += (pgmc->dxLeft >> 3); // adjust the source
        for (
             pjScanEnd = pjScan + (pgmc->cyCor * cjScanDst);
             pjScan < pjScanEnd;
             pjScan += cjScanDst, pjSrc += cjScanSrc
            )
        {
            pjS = pjSrc;
            pjD = pjScan;
            pjDEnd = pjD + iByteLast;

        // the last byte has to be done outside the loop

            for (;pjD < pjDEnd; pjD++)  // loop for the bytes in the middle
            {
                *pjD  = (*pjS << iShiftL);
                pjS++;
                *pjD |= (*pjS >> iShiftR);
            }

        // do the last byte outside of the loop

            *pjD  = (*pjS << iShiftL);
            if (++pjS < pjSrcEnd)
                *pjD |= (*pjS >> iShiftR);

            *pjD &= jMask; // mask off the last byte
        }
    }

}


/******************************Public*Routine******************************\
* vGetNotionalGlyphMetrics
*
*
\**************************************************************************/

// be values for the format of the indexToLocation table

#define BE_ITOLOCF_SHORT   0X0000
#define BE_ITOLOCF_LONG    0X0100

// offsets to the non scaled glyphdata

#define OFF_nc    0
#define OFF_xMin  2
#define OFF_yMin  4
#define OFF_xMax  6
#define OFF_yMax  8


VOID vGetNotionalGlyphMetrics(
    FONTCONTEXT *pfc,  // IN
    ULONG        ig,   // IN , glyph index
    NOT_GM      *pngm  // OUT, notional glyph metrics
    )
{
    sfnt_FontHeader        * phead;
    sfnt_HorizontalHeader  * phhea;
    sfnt_HorizontalMetrics * phmtx;
    PBYTE                    pjGlyph;
    PBYTE                    pjLoca;
    ULONG                    numberOf_LongHorMetrics;
    BYTE                   * pjView = pfc->pff->pvView;

#if DBG
    sfnt_maxProfileTable   * pmaxp;
    ULONG                    cig;

    pmaxp = (sfnt_maxProfileTable *)(pjView + pfc->ptp->ateReq[IT_REQ_MAXP].dp);
    cig = BE_UINT16(&pmaxp->numGlyphs) + 1;
    ASSERTDD(ig < cig, "ig >= numGlyphs\n");
#endif

// compute the relevant pointers:

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    pjGlyph = pjView + pfc->ptp->ateReq[IT_REQ_GLYPH].dp;
    pjLoca  = pjView + pfc->ptp->ateReq[IT_REQ_LOCA].dp;
    numberOf_LongHorMetrics = BE_UINT16(&phhea->numberOf_LongHorMetrics);

// get the pointer to the beginning of the glyphdata for this glyph
// if short format, offset divided by 2 is stored in the table, if long format,
// the actual offset is stored. Offsets are measured from the beginning
// of the glyph data table, i.e. from pjGlyph

    switch (phead->indexToLocFormat)
    {
    case BE_ITOLOCF_SHORT:
        pjGlyph += 2 * BE_UINT16(pjLoca + (sizeof(uint16) * ig));
        break;

    case BE_ITOLOCF_LONG :
        pjGlyph += BE_UINT32(pjLoca + (sizeof(uint32) * ig));
        break;

    default:
        WARNING("TTFD!_illegal phead->indexToLocFormat\n");
        break;
    }

// get the bounds, flip y

    pngm->xMin = BE_INT16(pjGlyph + OFF_xMin);
    pngm->xMax = BE_INT16(pjGlyph + OFF_xMax);
    pngm->yMin = - BE_INT16(pjGlyph + OFF_yMax);
    pngm->yMax = - BE_INT16(pjGlyph + OFF_yMin);

// get the adwance width and the lsb
// the piece of code stolen from the rasterizer [bodind]

    if (ig < numberOf_LongHorMetrics)
    {
        pngm->sD = BE_INT16(&phmtx[ig].advanceWidth);
        pngm->sA = BE_INT16(&phmtx[ig].leftSideBearing);
    }
    else
    {
    // first entry after[AW,LSB] array

        int16 * psA = (int16 *) &phmtx[numberOf_LongHorMetrics];

        pngm->sD = BE_INT16(&phmtx[numberOf_LongHorMetrics-1].advanceWidth);
        pngm->sA = BE_INT16(&psA[ig - numberOf_LongHorMetrics]);
    }

// redefine x coords so that they correspond to being measured relative to
// the real character origin

    pngm->xMax = pngm->xMax - pngm->xMin + pngm->sA;
    pngm->xMin = pngm->sA;

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // IF there is italic simulation A,B,C spaces change

        pngm->sA   -= (SHORT)FixMul(pngm->yMax, FX_SIN20);
        pngm->xMax -= (SHORT)FixMul(pngm->yMin, FX_SIN20);
    }
}

LONG lFFF(LONG l);
#define FFF(e,l) *(LONG*)(&(e)) = lFFF(l)

/******************************Public*Routine******************************\
* lQueryDEVICEMETRICS
*
* History:
*  08-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lQueryDEVICEMETRICS (
         FONTCONTEXT *pfc,
               ULONG  cjBuffer,
    FD_DEVICEMETRICS *pdevm
    )
{
    sfnt_FontHeader *phead;

    LONG  lULThickness,
          lSOThickness,
          lStrikeoutPosition,
          lUnderscorePosition,
          lTotalLeading;

    BYTE *pjView =  (BYTE *)pfc->pff->pvView;

    PBYTE pjOS2 = (pfc->pff->ffca.tp.ateOpt[IT_OPT_OS2].dp)         ?
                  (pjView + pfc->pff->ffca.tp.ateOpt[IT_OPT_OS2].dp):
                  NULL                                         ;

   Fixed fxXScale = pfc->mx.transform[0][0];
   if (fxXScale < 0)
       fxXScale = - fxXScale;

// actually requesting the data

    ASSERTDD (
        sizeof(FD_DEVICEMETRICS) <= cjBuffer,
        "FD_QUERY_DEVICEMETRICS: buffer too small\n");

// get the pointers to needed tables in the tt file

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);

// first store precomputed quantities

    pdevm->pteBase = pfc->pteUnitBase;
    pdevm->pteSide = pfc->pteUnitSide;
    pdevm->cxMax = pfc->cxMax;

    pdevm->fxMaxAscender  = LTOFX(pfc->lAscDev);
    pdevm->fxMaxDescender = LTOFX(pfc->lDescDev);

// get the notional space values for the strike out and underline quantities:

    lSOThickness        = (LONG)pfc->pff->ifi.fwdStrikeoutSize;
    lStrikeoutPosition  = (LONG)pfc->pff->ifi.fwdStrikeoutPosition;

    lULThickness        = (LONG)pfc->pff->ifi.fwdUnderscoreSize;
    lUnderscorePosition = (LONG)pfc->pff->ifi.fwdUnderscorePosition;

// compute the accelerator flags for this font

    pdevm->flRealizedType = 0;

    pdevm->lD = 0;

// things interesting for private user apis:

    if (pfc->flXform & XFORM_MAX_NEG_AC_HACK)
    {
        pdevm->lMinA = 0;
        pdevm->lMinC = 0;
    }
    else
    {
        pdevm->lMinA = (LONG)pfc->pff->ffca.sMinA;
        pdevm->lMinC = (LONG)pfc->pff->ffca.sMinC;
    }

    if (pfc->flFontType & FO_SIM_ITALIC)
    {
    // need to fix lMinA and lMinC

        LONG              yMinN, yMaxN;

        if (pjOS2 && (pfc->flXform & (XFORM_HORIZ | XFORM_VERT)))
        {
        // win 31 compatibility: we only take the max over win 31 char set.
        // All the glyphs outside this set, if they stand out will get shaved
        // off to match the height of the win31 char subset. Also notice that
        // for nonhorizontal cases we do not use os2 values because shaving
        // only applies to horizontal case, otherwise our bounding box values
        // will not be computed properly for nonhorizontal cases.

            yMinN =  - BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
            yMaxN =    BE_INT16(pjOS2 + OFF_OS2_usWinDescent);
        }
        else
        {
            yMinN = - BE_INT16(&phead->yMax);
            yMaxN = - BE_INT16(&phead->yMin);
        }

        ASSERTDD(yMinN < yMaxN, "yMinN >= yMaxN\n");

        // IF there is italic simulation
        //     xMin -> xMin - yMaxN * sin20
        //     xMax -> yMax - yMinN * sin20

        pdevm->lMinA -= FixMul(yMaxN, FX_SIN20);
        pdevm->lMinC += FixMul(yMinN, FX_SIN20);
    }

    pdevm->lMinD = (LONG)pfc->pff->ffca.usMinD;

    if (pfc->flXform & XFORM_HORIZ)
    {
        Fixed fxYScale = pfc->mx.transform[1][1];

    // strike out and underline size:

        lULThickness *= fxYScale;
        lULThickness = F16_16TOLROUND(lULThickness);
        if (lULThickness == 0)
            lULThickness = (fxYScale > 0) ? 1 : -1;

        pdevm->ptlULThickness.x = 0;
        pdevm->ptlULThickness.y = lULThickness;

        lSOThickness *= fxYScale;
        lSOThickness = F16_16TOLROUND(lSOThickness);
        if (lSOThickness == 0)
            lSOThickness = (fxYScale > 0) ? 1 : -1;

        pdevm->ptlSOThickness.x = 0;
        pdevm->ptlSOThickness.y = lSOThickness;

    // strike out and underline position

        lStrikeoutPosition *= fxYScale;
        pdevm->ptlStrikeOut.y = -F16_16TOLROUND(lStrikeoutPosition);

        lUnderscorePosition *= fxYScale;
        pdevm->ptlUnderline1.y = -F16_16TOLROUND(lUnderscorePosition);

        pdevm->ptlUnderline1.x = 0L;
        pdevm->ptlStrikeOut.x  = 0L;

    // things needed for private a user api:

        pdevm->lMinA = F16_16TOLROUND(fxXScale * pdevm->lMinA);
        pdevm->lMinC = F16_16TOLROUND(fxXScale * pdevm->lMinC);
        pdevm->lMinD = F16_16TOLROUND(fxXScale * pdevm->lMinD);
    }
    else // nontrivial transform
    {
        POINTL   aptl[4];
        POINTFIX aptfx[4];
        BOOL     b;

        pdevm->lD = 0;

    // xform so and ul vectors

        aptl[0].x = 0;
        aptl[0].y = lSOThickness;

        aptl[1].x = 0;
        aptl[1].y = -lStrikeoutPosition;

        aptl[2].x = 0;
        aptl[2].y = lULThickness;

        aptl[3].x = 0;
        aptl[3].y = -lUnderscorePosition;

        // !!! [GilmanW] 27-Oct-1992
        // !!! Should change over to engine user object helper functions
        // !!! instead of the fontmath.cxx functions.

        b = bFDXform(&pfc->xfm, aptfx, aptl, 4);
        if (!b) {RIP("TTFD!_bFDXform, fd_query.c\n");}

        pdevm->ptlSOThickness.x = FXTOLROUND(aptfx[0].x);
        pdevm->ptlSOThickness.y = FXTOLROUND(aptfx[0].y);

        pdevm->ptlStrikeOut.x = FXTOLROUND(aptfx[1].x);
        pdevm->ptlStrikeOut.y = FXTOLROUND(aptfx[1].y);

        pdevm->ptlULThickness.x = FXTOLROUND(aptfx[2].x);
        pdevm->ptlULThickness.y = FXTOLROUND(aptfx[2].y);

        pdevm->ptlUnderline1.x = FXTOLROUND(aptfx[3].x);
        pdevm->ptlUnderline1.y = FXTOLROUND(aptfx[3].y);

        if ((pfc->flXform & XFORM_VERT) &&
            ((pdevm->ptlSOThickness.x == 0) || (pdevm->ptlULThickness.x == 0)))
        {
            Fixed fxXScale10 = pfc->mx.transform[1][0];

            if (pdevm->ptlSOThickness.x == 0)
            {
                pdevm->ptlSOThickness.x = (fxXScale10 > 0) ? -1 : 1;
            }
            
            if (pdevm->ptlULThickness.x == 0)
            {
                pdevm->ptlULThickness.x = (fxXScale10 > 0) ? -1 : 1;
            }
        }

    // things needed for private a user api:

        pdevm->lMinA = FXTOLROUND(fxLTimesEf(&pfc->efBase, pdevm->lMinA));
        pdevm->lMinC = FXTOLROUND(fxLTimesEf(&pfc->efBase, pdevm->lMinC));
        pdevm->lMinD = FXTOLROUND(fxLTimesEf(&pfc->efBase, pdevm->lMinD));
    }

// Compute the device metrics.
// HACK ALLERT, overwrite the result if the transformation
// to be really used has changed as a result of "vdmx" quantization.
// Not a hack any more, this is even documented now in DDI spec:

    if (pfc->flXform & (XFORM_HORIZ | XFORM_2PPEM))
    {
        FFF(pdevm->fdxQuantized.eXX, pfc->mx.transform[0][0]);
        FFF(pdevm->fdxQuantized.eYY, pfc->mx.transform[1][1]);

        if (!(pfc->flXform & XFORM_HORIZ))
        {
            FFF(pdevm->fdxQuantized.eXY,-pfc->mx.transform[0][1]);
            FFF(pdevm->fdxQuantized.eYX,-pfc->mx.transform[1][0]);
        }
    }

// finally we have to do nonlinear external leading for type 1 conversions

    if (pfc->pff->ffca.fl & FF_TYPE_1_CONVERSION)
    {
        LONG lPtSize = F16_16TOLROUND(pfc->fxPtSize);

        LONG lIntLeading = pfc->lAscDev + pfc->lDescDev - pfc->lEmHtDev;

    // I need this, PS driver does it and so does makepfm utility.

        if (lIntLeading < 0)
            lIntLeading = 0;

        switch (pfc->pff->ifi.jWinPitchAndFamily & 0xf0)
        {
        case FF_ROMAN:

            lTotalLeading = (pfc->sizLogResPpi.cy + 18) / 32;  // 2 pt leading;
            break;

        case FF_SWISS:

            if (lPtSize <= 12)
                lTotalLeading = (pfc->sizLogResPpi.cy + 18) / 32;  // 2 pt
            if (lPtSize < 14)
                lTotalLeading = (pfc->sizLogResPpi.cy + 12) / 24;  // 3 pt
            else
                lTotalLeading = (pfc->sizLogResPpi.cy + 9) / 18;   // 4 pt
            break;

        default:

        // use 19.6% of the Em height for leading, do not do any rounding.

            lTotalLeading = (pfc->lEmHtDev * 196) / 1000;
            break;
        }

        pdevm->lNonLinearExtLeading = (lTotalLeading - lIntLeading) << 4; // TO 28.4
        if (pdevm->lNonLinearExtLeading < 0)
            pdevm->lNonLinearExtLeading = 0;
    }

// for emboldened fonts MaxCharWidth and AveCharWidth can not be computed
// by linear scaling. These nonlinarly transformed values we will store in
// pdevm->lNonLinearMaxCharWidth // max and pdevm->lNonLinearAvgCharWidth // avg.

    if (pfc->flFontType & FO_SIM_BOLD)
    {

         if (pfc->flXform & XFORM_HORIZ)
        {
        // notice +1 we are adding: this is the nonlinearity we are talking about

            pdevm->lNonLinearMaxCharWidth = fxXScale * (LONG)pfc->pff->ifi.fwdMaxCharInc;
            pdevm->lNonLinearMaxCharWidth = F16_16TO28_4(pdevm->lNonLinearMaxCharWidth) + (1 << 4);

            pdevm->lNonLinearAvgCharWidth = fxXScale * ((LONG)pfc->pff->ifi.fwdAveCharWidth);
            pdevm->lNonLinearAvgCharWidth = F16_16TO28_4(pdevm->lNonLinearAvgCharWidth) + (1 << 4);
        }
        else // nontrivial transform
        {
            pdevm->lNonLinearMaxCharWidth =
                fxLTimesEf(&pfc->efBase, (LONG)pfc->pff->ifi.fwdMaxCharInc) + (1 << 4);

            pdevm->lNonLinearAvgCharWidth =
                fxLTimesEf(&pfc->efBase, (LONG)pfc->pff->ifi.fwdAveCharWidth) + (1 << 4);
        }
    }

// add new fields:


// If singular transform, the TrueType driver will provide a blank
// 1x1 bitmap.  This is so device drivers will not have to implement
// special case code to handle singular transforms.

    if ( pfc->flXform & XFORM_SINGULAR )
    {
        ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
        pdevm->cyMax      = 1;
        pdevm->cjGlyphMax = (CJGD(1,1,pfc));
    }
    else // Otherwise, the max glyph size is cached in the FONTCONTEXT.
    {
        pdevm->cyMax      = pfc->yMax - pfc->yMin;
        pdevm->cjGlyphMax = pfc->cjGlyphMax;
    }

// we are outa here

    return sizeof(FD_DEVICEMETRICS);
}



/******************************Public*Routine******************************\
* ttfdQueryFontData
*
*   dhpdev      Not used.
*
*   pfo         Pointer to a FONTOBJ.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFD_GLYPH           -- return glyph metrics only
*
*       QFD_GLYPHANDBITMAP  -- return glyph metrics and bitmap
*
*       QFD_GLYPHANDOUTLINE -- return glyph metrics and outline
*
*       QFD_MAXEXTENTS      -- return FD_DEVICEMETRICS structure
*
*   pgd        Buffer to hold glyphdata structure, if any
*
*   pv         Output buffer to hold glyphbits or pathobj, if any.
*
* Returns:
*
*   Otherwise, returns the size of the glyphbits
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  31-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG ttfdQueryFontData (
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
extern LONG lGetSingularGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID);
extern STATIC LONG lQueryDEVICEMETRICS(FONTCONTEXT*, ULONG, FD_DEVICEMETRICS*);
extern LONG ttfdGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, VOID*, ULONG);
extern LONG lGetGlyphBitmapErrRecover(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID);
extern LONG lGetGlyphBitmap(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PVOID, FS_ENTRY*);
extern BOOL ttfdQueryGlyphOutline(FONTCONTEXT*, HGLYPH, GLYPHDATA*, PATHOBJ*);

// declare the locals

    PFONTCONTEXT pfc;
    USHORT usOverScale;
    LONG cj = 0;

    cjSize; // bizzare, why is this passed in ? [bodind]

// if this font file is gone we are not gonna be able to answer any questions
// about it

    ASSERTDD(pfo->iFile, "ttfdQueryFontData, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("TTFD!ttfdQueryFontData(): file is gone\n");
        return FD_ERROR;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        WARNING("TTFD!gdisrv!ttfdQueryFontData(): cannot create font context\n");
        return FD_ERROR;
    }

    pfc->pfo = pfo;

    switch ( iMode )
    {
        case QFD_TT_GRAY1_BITMAP: // monochrome

            usOverScale = 0;  /// !!! 0 for monochrome
            break;

        case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4

            usOverScale = 2;
            break;

        case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16

            usOverScale = 4;
            break;

        case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64

            usOverScale = 8;
            break;

        default:
            if (IS_GRAY(pfc) && !(pfc->flFontType & FO_CLEARTYPE_X))
            {
                usOverScale = 4;
            }
            else
            {
                usOverScale = 0;
            }
            break;
    }

// call fs_NewTransformation if needed:
    {
        BOOL bClearType = FALSE;
        BOOL bBitmapEmboldening = FALSE;

        if ( (pfc->flFontType & FO_SIM_BOLD) &&
            (pfc->flXform & (XFORM_HORIZ | XFORM_VERT)) &&
            (iMode != QFD_GLYPHANDOUTLINE))
        {
            /* for backwards compatibility and to get better bitmaps at screen resolution, we are doing
               bitmap emboldening simulation (as opposed to outline emboldening simulation) if we are
               emboldening only by one pixel and we are under no rotation or 90 degree rotation and not asking for path */
            bBitmapEmboldening = TRUE;
        }

        switch ( iMode )
        {
        case QFD_TT_GRAY1_BITMAP: // monochrome
        case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4
        case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16
        case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64
            bClearType = FALSE;
            break;
        default:	// We use tri-mode bClearType
        	if((pfc->flFontType & FO_CLEARTYPE_X) == FO_CLEARTYPE_X){
	        	if((pfc->flFontType & FO_CLEARTYPENATURAL_X) == FO_CLEARTYPENATURAL_X)
	        		bClearType = -1;	
	        	else
	        		bClearType = TRUE;
        	}
            break;
        }

        if (!bGrabXform(
                pfc,
                usOverScale,
                bBitmapEmboldening,
                bClearType
                ))
        {
            RETURN("gdisrv!ttfd  bGrabXform failed\n", FD_ERROR);
        }
    }

    switch ( iMode )
    {
    case QFD_TT_GRAY1_BITMAP: // monochrome
    case QFD_TT_GRAY2_BITMAP: // one byte per pixel: 0..4
    case QFD_TT_GRAY4_BITMAP: // one byte per pixel: 0..16
    case QFD_TT_GRAY8_BITMAP: // one byte per pixel: 0..64

         return( ttfdGlyphBitmap( pfc, hg, pgd, pv, cjSize) );
         break;

    case QFD_GLYPHANDBITMAP:
    case QFD_TT_GLYPHANDBITMAP:
        {
        // Engine should not be querying on the HGLYPH_INVALID.

            ASSERTDD (
                hg != HGLYPH_INVALID,
                "ttfdQueryFontData(QFD_GLYPHANDBITMAP): HGLYPH_INVALID \n"
                );

        // If singular transform, the TrueType driver will provide a blank
        // 1x1 bitmap.  This is so device drivers will not have to implement
        // special case code to handle singular transforms.
        //
        // So depending on the transform type, choose a function to retrieve
        // bitmaps.

            if (pfc->flXform & XFORM_SINGULAR)
            {
                cj = lGetSingularGlyphBitmap(pfc, hg, pgd, pv);
            }
            else
            {
                FS_ENTRY iRet;

                if ( pfc->bVertical )
                {
                    cj = lGetGlyphBitmapVertical( pfc, hg, pgd, pv, &iRet);
                }
                else
                {
                    cj = lGetGlyphBitmap(pfc,
                                         hg,
                                         pgd,
                                         pv,
                                         &iRet);
                }

                if ((cj == FD_ERROR) && (iRet == POINT_MIGRATION_ERR))
                {
                // this is buggy glyph where hinting has so severly distorted
                // the glyph that one of the points went out of range.
                // We will just return a blank glyph but with correct
                // abcd info. That way only that buggy glyph will not be printed
                // correctly, the rest will of glyphs will.
                // More importantly, if psciprt driver tries to
                // download this font, the download operation will not fail just because
                // one glyph in a font is buggy. [BodinD]

                    cj = lGetGlyphBitmapErrRecover(pfc, hg, pgd, pv);
                }
            }

        #if DBG
            if (cj == FD_ERROR)
            {
                WARNING("TTFD!ttfdQueryFontData(QFD_GLYPHANDBITMAP): get bitmap failed\n");
            }
        #endif
        }
        return cj;

    case QFD_GLYPHANDOUTLINE:

        ASSERTDD (
            hg != HGLYPH_INVALID,
            "ttfdQueryFontData(QFD_GLYPHANDOUTLINE): HGLYPH_INVALID \n"
            );

        if (!ttfdQueryGlyphOutline(pfc, hg, pgd, (PATHOBJ *) pv))
        {
            WARNING("TTFD!ttfdQueryFontData(QFD_GLYPHANDOUTLINE): failed to get outline\n");
            return FD_ERROR;
        }
        return sizeof(GLYPHDATA);

    case QFD_MAXEXTENTS:

        return lQueryDEVICEMETRICS(
                   pfc,
                   sizeof(FD_DEVICEMETRICS),
                   (FD_DEVICEMETRICS *) pv
                   );


    default:

        WARNING("TTFD!gdisrv!ttfdQueryFontData(): unsupported mode\n");
        return FD_ERROR;
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   ttfdGlyphBitmap
*
* Routine Description:
*
* Arguments:
*
* Routines called:
*
*   EngSetLastError
*   lGGOBitmap
*
* Called by:
*
*   ttfdQueryFontData
*
* Return Value:
*
*   If pv is zero then then return the size of the required buffer
*   in bytes. If pv is not zero, then return the number of bytes
*   copied to the buffer. An error is indicated by a return value
*   of FD_ERROR.
*
\**************************************************************************/

LONG ttfdGlyphBitmap(
    FONTCONTEXT *pfc,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    VOID       *pv,
    ULONG       cjSize
    )
{
    extern LONG lGGOBitmap(FONTCONTEXT*,HGLYPH,GLYPHDATA*,VOID*,unsigned);

    LONG lRet;

    // RIP("ttfdGlypBitmap\n");

    lRet = 0;
    if ( hg == HGLYPH_INVALID )
    {
        WARNING( "TTFD!GlyphBitamp -- invalid hg\n" );
        EngSetLastError( ERROR_INVALID_PARAMETER );
        lRet = FD_ERROR;
    }
    else
    {
        if (lRet != FD_ERROR)
        {
            if (pfc->bVertical)
            {
                if (IsFullWidthCharacter(pfc->pff, hg))
                {

                    lRet = FD_ERROR;
                    if (bChangeXform(pfc, TRUE))
                    {
                        pfc->ulControl |= VERTICAL_MODE;
                        pfc->hgSave = hg;
                        lRet = ~FD_ERROR;
                    }
                }
            }
            if (lRet != FD_ERROR)
            {
                lRet = lGGOBitmap(pfc, hg, pgd, pv, cjSize);
                if (pfc->ulControl & VERTICAL_MODE)
                {
                    pfc->ulControl &= ~VERTICAL_MODE;
                    if (!bChangeXform(pfc, FALSE))
                    {
                        lRet = FD_ERROR;
                    }
                }
            }
        }
    }
    return( lRet );
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   lGGOBitmap
*
* Routine Description:
*
*   For returning bitmaps in the format as required by GetGlyphOutline
*
* Routines called:
*
*   EngSetLastError
*   vCharacterCode
*   fs_NewGlyph
*   fs_FindBitmapSize
*   fs_FindGraySize
*   pvSetMemoryBases
*   V_FREE
*
* Arguments:
*
* Return Value:
*
*   if (pv == 0)
*       <return the size of buffer needed to receive the bitmap>;
*   else
*       <return the number of bytes written to the recieving buffer>;
*
\**************************************************************************/

LONG lGGOBitmap(
    FONTCONTEXT *pfc,
    HGLYPH       hg,
    GLYPHDATA   *pgd,
    VOID        *pv,
    unsigned     cjSize
    )
{

  LONG lRet;                                    // returned to caller
  ULONG iError;                                 // for EngSetLastError
  ULONG ig;                                     // index of glyph (fs_NewGlyph)
  BitMap *pbm;                                  // pointer into fs_ structure
  Rect   *pRect;                                // pointer into fs_ structure
  fs_GlyphInputType *pin  = pfc->pgin;          // used a lot
  fs_GlyphInfoType  *pout = pfc->pgout;         // used a lot
  int isMonochrome = ( pfc->overScale == 0 );       // TRUE iff monochrome glyph
  FS_ENTRY     iRet;

  // RIP("lGGOBitmap\n");

  iError = NO_ERROR;                            // keep going until this changes
  vInitGlyphState( &pfc->gstat );               // invalidate cache
  vCharacterCode(hg, pin );          // translate the glyph handle
  if ((iRet = fs_NewGlyph(pin, pout)) != NO_ERR )       // inform the rasterizer of new glyph
  {                                             // rasterizer not happy, get out
    V_FSERROR(iRet);
    WARNING("TTFD!lGGOBitmap -- fs_NewGlyph failed\n");
    iError = ERROR_CAN_NOT_COMPLETE;
  }
  else
  {
    ig = pfc->pgout->glyphIndex;
    pin->param.gridfit.styleFunc = 0;
    pin->param.gridfit.traceFunc = 0;

    pin->param.gridfit.bSkipIfBitmap = FALSE; // if embedded bitmap then no hints

    if ((iRet = fs_NewContourGridFit(pin, pout)) != NO_ERR ) // have rasterizer generate outlines
    {                                             // something went wrong, get out
      V_FSERROR(iRet);
      WARNING("TTFD!lGGOBitmap -- fs_ContourGridFit failed\n");
      iError = ERROR_CAN_NOT_COMPLETE;
    }
    else
    { // if you get here, the rasterizer has accepted the new glyph now we must
      // get glyph metrics and initialize pgin for later rasterization calls
      // of the required bitmaps

        if ((iRet = fs_FindBitMapSize(pin, pout)) != NO_ERR )
        {                                         // no, get out
          V_FSERROR(iRet);
          WARNING("TTFD!lGGOBitmap -- fs_FindBitMapSize failed\n");
          iError = ERROR_CAN_NOT_COMPLETE;
        }
     }

    if ( iError == NO_ERROR )                     // everything OK so far?
    {                                             // yes
      if ( pgd )                                  // caller provided GLYPHDATA?
      {                                           // yes, fill it in
        GMC gmc;                                  // necessary scratch space
        POINTL ptlOrg;                            // necessary scratch space
        fs_GlyphInfoType gout, *pgout;
        HGLYPH hgTemp;

        if ( pfc->bVertical && ( pfc->ulControl & VERTICAL_MODE ) ) // vertical?
        {                                                           // yes
            hgTemp = pfc->hgSave;
            pgout = &gout;
            vShiftBitmapInfo( pfc, pgout, pfc->pgout );
        }
        else
        {                                         // not vertical
            hgTemp = hg;
            pgout  = pfc->pgout;
        }

        // fill the GLYPHDATA structure
 
        vFillGLYPHDATA(hgTemp,ig,pfc,pgout,pgd,&gmc,&ptlOrg);
      }

      if ( pv == 0 )                              // buffer provided for bits?
      {                                           // no, return necessary size
        if ( cjSize )                             // is the input size zero?
        {                                         // no, caller is a fool, get out
          WARNING("TTFD!lGGOBitmap -- pv == 0 && cjRet != 0\n");
          iError = ERROR_INVALID_PARAMETER;
        }
        else                                      // input size zero
        {                                         // so caller is not a fool
          pbm   = &pfc->pgout->bitMapInfo;        // calculate necessary size
          pRect = &pbm->bounds;                   // and return
          lRet = (LONG) (pRect->bottom - pRect->top) * (LONG) pbm->rowBytes;
        }
      }
      else
      {                                           // buffer for bits is provided
        if ( cjSize == 0 )                        // is the size reasonable?
        {                                         // no
          WARNING("TTFD!lGGOBitmap -- pv != 0 && cjRet == 0\n");
          iError = ERROR_INVALID_PARAMETER;
        }
        else                                      // caller provided a buffer for
        {                                         // the bits representing the glyph
          if (pfc->flXform & XFORM_SINGULAR)      // is the transform bad?
          {                                       // yes! Make a blank 1 x 1 bitmap
            *(BYTE*)pv = 0;                       // legal for both monochrome
          }                                       //                 and gray glyphs
          else                                    // notional to device transform ok
          {                                       // prepare to rasterize glyph
            pfc->gstat.pv =                       // allocate scratch space
              pvSetMemoryBases(pfc->pgout, pin, !isMonochrome );
                                                  // be sure you free this!
            if ( pfc->gstat.pv == 0 )             // successful allocation?
            {                                     // no, get out
              WARNING("TTFD!lGGOBitmap -- pfc->gstat.pv == 0\n");
              iError = ERROR_NOT_ENOUGH_MEMORY;
            }
            else                                  // memory has been allocated!
            {                                     // free it when leaving this scope
              if ((iRet = fs_ContourScan(pin, pout)) != NO_ERR )
              {                                 // no, get out
                V_FSERROR(iRet);
                WARNING("TTFD!lGGOBitmap -- fs_ContourScan failed\n");
                iError = ERROR_CAN_NOT_COMPLETE;
              }

              if ( iError == NO_ERROR )           // everthing ok so far?
              {                                   // yes
                pbm   = &pfc->pgout->bitMapInfo;  // calculate size of bitmap
                pRect = &pbm->bounds;             // just in case it changed
                lRet = (LONG) (pRect->bottom - pRect->top) * (LONG) pbm->rowBytes;
                lRet = min((LONG) cjSize, lRet);  // don't overwrite buffer
                if ( pfc->pgout->bitMapInfo.baseAddr )  // bitmap there?
                {                                 // yes, copy to caller's buffer
                  RtlCopyMemory(pv, pfc->pgout->bitMapInfo.baseAddr, lRet);
                }
                else
                {                                 // bitmap not there, get out
                  WARNING("TTFD!lGGOBitmap -- invalid pointer to bitmap\n");
                  iError = ERROR_CAN_NOT_COMPLETE;
                }
              }
              V_FREE(pfc->gstat.pv);              // free memory before leaving scope
              pfc->gstat.pv = NULL;
            }
          }
        }
      }
    }
  }
  if ( iError != NO_ERROR )                       // has an error occurred?
  {                                               // yes
    EngSetLastError( iError );                    // regitster the error
    lRet = FD_ERROR;                              // return value indicates error
  }
  vInitGlyphState( &pfc->gstat );                 // invalidate cache
  return( lRet );
}

/******************************Public*Routine******************************\
*
* pvSetMemoryBases
*
* To release this memory simply do vFreeMemoryBases(&pv); where pv is
* returned from bSetMemoryBases in ppv
*
* Looks into memory request in fs_GlyphInfoType and allocates this memory
* , than it fills memoryBases in fs_GlyphInputType with pointers to the
* requested memory
*
* History:
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


void *pvSetMemoryBases(fs_GlyphInfoType *pgout,fs_GlyphInputType *pgin,int isGray)
{
    FS_MEMORY_SIZE adp[MEMORYFRAGMENTS];
    FS_MEMORY_SIZE cjTotal;
    INT i;
    PBYTE pjMem;

#define I_LO 5
#define I_HI 7

    cjTotal = 0;    // total memory to allocate for all fragments


// unroll the loop:

//     for (i = I_LO; i <= I_HI; i++)
//     {
//         adp[i] = cjTotal;
//         cjTotal += NATURAL_ALIGN(pgin->memorySizes[i]);
//     }

    adp[5] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[5]);
    adp[6] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[6]);
    adp[7] = cjTotal;
    cjTotal += NATURAL_ALIGN(pgout->memorySizes[7]);
    if (isGray)
    {
        adp[8] = cjTotal;
        cjTotal += NATURAL_ALIGN(pgout->memorySizes[8]);
    }

    if (cjTotal == 0)
    {
        cjTotal = 4;
    }

    if ((pjMem = (PBYTE)PV_ALLOC((ULONG)cjTotal)) == (PBYTE)NULL)
    {
        for (i = I_LO; i <= I_HI; i++)
            pgin->memoryBases[i] = (PBYTE)NULL;

        RETURN("TTFD!_bSetMemoryBases mem alloc failed\n",NULL);
    }

// unroll the loop:
// set the pointers

//    for (i = I_LO; i <= I_HI; i++)
//    {
//        if (pgin->memorySizes[i] != (FS_MEMORY_SIZE)0)
//        {
//            pgout->memoryBases[i] = pjMem + adp[i];
//        }
//        else
//        {
//        // if no mem was required set to NULL to prevent accidental use
//
//            pgout->memoryBases[i] = (PBYTE)NULL;
//        }
//    }

    if (pgout->memorySizes[5] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[5] = pjMem + adp[5];
    }
    else
    {
        pgin->memoryBases[5] = (PBYTE)NULL;
    }

    if (pgout->memorySizes[6] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[6] = pjMem + adp[6];
    }
    else
    {
        pgin->memoryBases[6] = (PBYTE)NULL;
    }

    if (pgout->memorySizes[7] != (FS_MEMORY_SIZE)0)
    {
        pgin->memoryBases[7] = pjMem + adp[7];
    }
    else
    {
        pgin->memoryBases[7] = (PBYTE)NULL;
    }

    if (isGray && (pgout->memorySizes[8] != (FS_MEMORY_SIZE)0))
    {
        pgin->memoryBases[8] = pjMem + adp[8];
    }
    else
    {
        pgin->memoryBases[8] = (PBYTE)NULL;
    }

    return pjMem;
}

/******************************Public*Routine******************************\
* VOID vFreeMemoryBases()                                                  *
*                                                                          *
* Releases the memory allocated by bSetMemoryBases.                        *
*                                                                          *
* History:                                                                 *
*  08-Nov-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

VOID vFreeMemoryBases(PVOID * ppv)
{
    if (*ppv != (PVOID) NULL)
    {
        V_FREE(*ppv);
        *ppv = (PVOID) NULL; // clean up the state and prevent accidental use
    }
}




/******************************Public*Routine******************************\
* bQueryAdvanceWidths                                                      *
*                                                                          *
* A routine to compute advance widths, as long as they're simple enough.   *
                                                                           *
* Warnings: !!! if a bug is found in bGetFastAdvanceWidth this routine has *
*           !!! to be changed as well                                      *
*                                                                          *
*  Sun 17-Jan-1993 21:23:30 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bQueryAdvanceWidths(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
    )
{

    FONTCONTEXT *pfc;
    USHORT      *psWidths = (USHORT *) plWidths;   // True for the cases we handle.
    HDMXTABLE   *phdmx;
    sfnt_FontHeader        *phead;
    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    LTSHHEADER             *pltsh;
    ULONG  cHMTX;
    USHORT dxLastWidth;
    LONG   dx;
    ULONG  ii;
    BOOL   bRet;
    BYTE   *pjView;

// if this font file is gone we are not gonna be able to answer any questions
// about it

    ASSERTDD(pfo->iFile, "bQueryAdvanceWidths, pfo->iFile\n");

    if (((TTC_FONTFILE *)pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        WARNING("TTFD!bQueryAdvanceWidths, file is gone\n");
        return FALSE;
    }

// make sure that there is the font context is initialized

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        pfo->pvProducer = pfc = ttfdOpenFontContext(pfo);
    }
    else
    {
        pfc = (FONTCONTEXT*) pfo->pvProducer;
        pfc->flFontType = (pfc->flFontType & FO_CHOSE_DEPTH) | pfo->flFontType;
    }

    if ( pfc == (FONTCONTEXT *) NULL )
    {
        WARNING("TTFD!winsrv!bQueryAdvanceWidths(): cannot create font context\n");
        return FD_ERROR;
    }
    pfc->pfo = pfo;

    if( ((pfc->flFontType & (FO_CLEARTYPENATURAL_X | FO_NOCLEARTYPE)) == FO_CLEARTYPENATURAL_X) && !(pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) )
    {
        for (ii=0; ii<cGlyphs; ii++,psWidths++)
	        *psWidths  = 0xFFFF;
        return(FALSE);
    }


    phdmx = pfc->phdmx;

// Make sure we understand the call.

    if (iMode > QAW_GETEASYWIDTHS)
        return FALSE;

// Try to use the HDMX table.

    if (phdmx != (HDMXTABLE *) NULL)
    {
        USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards conpatibility reason, we inclease the widht only by one pixel */

    //    while (cGlyphs)
    //        *psWidths++ = ((USHORT) phdmx->aucInc[*phg++]) << 4;

    unroll_here:
        switch (cGlyphs)
        {
        default:
              if (phdmx->aucInc[phg[7]] != 0)
              {
                  psWidths[7] = (((USHORT) phdmx->aucInc[phg[7]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[7] = (((USHORT) phdmx->aucInc[phg[7]]) << 4);
              }
        case 7:
               if (phdmx->aucInc[phg[6]] != 0)
              {
                  psWidths[6] = (((USHORT) phdmx->aucInc[phg[6]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[6] = (((USHORT) phdmx->aucInc[phg[6]]) << 4);
              }
        case 6:
              if (phdmx->aucInc[phg[5]] != 0)
              {
                  psWidths[5] = (((USHORT) phdmx->aucInc[phg[5]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[5] = (((USHORT) phdmx->aucInc[phg[5]]) << 4);
              }
        case 5:
              if (phdmx->aucInc[phg[4]] != 0)
              {
                  psWidths[4] = (((USHORT) phdmx->aucInc[phg[4]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[4] = (((USHORT) phdmx->aucInc[phg[4]]) << 4);
              }
        case 4:
              if (phdmx->aucInc[phg[3]] != 0)
              {
                  psWidths[3] = (((USHORT) phdmx->aucInc[phg[3]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[3] = (((USHORT) phdmx->aucInc[phg[3]]) << 4);
              }
        case 3:
              if (phdmx->aucInc[phg[2]] != 0)
              {
                  psWidths[2] = (((USHORT) phdmx->aucInc[phg[2]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[2] = (((USHORT) phdmx->aucInc[phg[2]]) << 4);
              }
        case 2:
              if (phdmx->aucInc[phg[1]] != 0)
              {
                  psWidths[1] = (((USHORT) phdmx->aucInc[phg[1]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[1] = (((USHORT) phdmx->aucInc[phg[1]]) << 4);
              }
        case 1:
              if (phdmx->aucInc[phg[0]] != 0)
              {
                  psWidths[0] = (((USHORT) phdmx->aucInc[phg[0]]) << 4) + cxExtra;
              }
              else
              {
                  psWidths[0] = (((USHORT) phdmx->aucInc[phg[0]]) << 4);
              }
        case 0:
              break;
        }
        if (cGlyphs > 8)
        {
            psWidths += 8;
            phg      += 8;
            cGlyphs  -= 8;
            goto unroll_here;
        }
        return(TRUE);
    }

// Otherwise, try to scale.  Pick up the tables.

    pjView = (BYTE *)pfc->pff->pvView;
    ASSERTDD(pjView, "pjView is NULL 1\n");

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD ].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    pltsh = (LTSHHEADER *)(
              (pfc->ptp->ateOpt[IT_OPT_LTSH].dp && bValidRangeLTSH(pfc->pff, pfc->ptp->ateOpt[IT_OPT_LTSH].cj) ) ?
              (pjView + pfc->ptp->ateOpt[IT_OPT_LTSH ].dp):
              NULL
              );

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);
    dxLastWidth = BE_UINT16(&phmtx[cHMTX-1].advanceWidth);

// Try a simple horizontal scaling.

    if (pfc->flXform & XFORM_HORIZ)
    {
        USHORT cxExtra;
        LONG xScale;
        LONG lEmHt = pfc->lEmHtDev;
	    BOOL bNonLinear = TRUE;

        cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards compatibility reason, we increase the width only by one pixel */

    // See if there is cause for worry.

        if
        (
          !(pfc->flXform & XFORM_POSITIVE_SCALE)
          || ((((BYTE *) &phead->flags)[1] & 0x14)==0) // Bits indicating nonlinearity.
          || (pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) // DBCS fixed pitch font
        )
        {
	        bNonLinear = FALSE;  // we are linear regardless of the size
        }

    // OK, let's scale using the FIXED transform.

        xScale = pfc->mx.transform[0][0];
        if (xScale < 0)
            xScale = -xScale;

        bRet = TRUE;
        for (ii=0; ii<cGlyphs; ii++,phg++,psWidths++)
        {
            if
            ( ( ((pfc->flFontType & (FO_CLEARTYPENATURAL_X | FO_NOCLEARTYPE )) == FO_CLEARTYPENATURAL_X) && 
                  !IsFullWidthCharacter(pfc->pff, *phg) ) ||
              (bNonLinear &&
                  ( (pltsh == (LTSHHEADER *) NULL)
                  || (lEmHt < pltsh->PelsHeight[*phg]) ))
            )
            {
                *psWidths = 0xFFFF;
                bRet = FALSE;
            }
            else
            {
                if (*phg < cHMTX)
                    dx = (LONG) BE_UINT16(&phmtx[*phg].advanceWidth);
                else
                    dx = (LONG) dxLastWidth;

                *psWidths = (USHORT) (((xScale * dx + 0x8000L) >> 12) & 0xFFF0);

                if (!gbJpn98FixPitch && (pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) && IsFullWidthCharacter(pfc->pff, *phg))
                {
                    /* DBCS FixedPitch Full Width glyph */
                    /* we need to use the width 2*pfc->SBCDWidth */
                    /* some glyphs are flagged as FullWidth for the rotation of FE vertical writing but designed as single width */
                    if (pfc->mx.transform[0][0] > 0)
                    {
                        if (*psWidths != pfc->SBCSWidth << 4) 
                            *psWidths = (USHORT) ((2* pfc->SBCSWidth) << 4);
                    } else {
                        if (*psWidths != -pfc->SBCSWidth << 4) 
                            *psWidths = (USHORT) ((2* -pfc->SBCSWidth) << 4);
                    }
                }
                
                if (*psWidths != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                    *psWidths += cxExtra;
            }
        }
        return(bRet);
    }

// Must be some random transform.  In this case, vComputeMaxGlyph computes
// pfc->efBase, which we will use here.

    else
    {
        USHORT cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? (1 << 4) : 0; /* for backwards compatibility reason, we increase the width only by one pixel */

        for (ii=0; ii<cGlyphs; ii++,phg++,psWidths++)
        {
            if (*phg < cHMTX)
                dx = BE_UINT16(&phmtx[*phg].advanceWidth);
            else
                dx = dxLastWidth;

            if (dx != 0)
            {
                *psWidths = (USHORT)(lCvt(*(EFLOAT *) &pfc->efBase,(LONG) dx) + cxExtra);
            }
            else
            { /* we don't increase the width of a zero width glyph, problem with indic script */
                *psWidths = (USHORT)(lCvt(*(EFLOAT *) &pfc->efBase,(LONG) dx));
            }

        }
        return(TRUE);
    }
}


/******************************Public*Routine******************************\
*
* BOOL bGetFastAdvanceWidth
*
*
* Effects: retrieves the same result as bQueryAdvanceWidth, except it
*          ignores adding 1 for EMBOLDENING and it does not do anything
*          for non horiz. xforms
*
* Warnings: !!! if a bug is found in bQueryAdvanceWidth this routine has to
*           !!! changed as well
*
* History:
*  25-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL bGetFastAdvanceWidth(
    FONTCONTEXT *pfc,
    ULONG        ig,    // glyph index
    FIX         *pfxD   // result in 28.4
    )
{
    HDMXTABLE   *phdmx = pfc->phdmx;
    sfnt_FontHeader        *phead;
    sfnt_HorizontalHeader  *phhea;
    sfnt_HorizontalMetrics *phmtx;
    LTSHHEADER             *pltsh;
    ULONG  cHMTX;
    USHORT dxLastWidth;
    LONG   dx;
    BOOL   bRet;
    BOOL   bNonLinear = TRUE;
    BYTE  *pjView;

    ASSERTDD(pfc->flXform & XFORM_HORIZ, "bGetFastAdvanceWidth xform\n");

    if((pfc->flFontType & (FO_CLEARTYPENATURAL_X | FO_NOCLEARTYPE)) == FO_CLEARTYPENATURAL_X){
        if ( !((pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) && IsFullWidthCharacter(pfc->pff, ig)) )
        {
            *pfxD  = 0xFFFFFFFF;
            return( FALSE);
        }
    }

    if (phdmx != (HDMXTABLE *) NULL)
    {
        *pfxD = (((FIX) phdmx->aucInc[ig]) << 4);
        return(TRUE);
    }

// Otherwise, try to scale.  Pick up the tables.


    pjView = (BYTE *)pfc->pff->pvView;
    ASSERTDD(pjView, "pjView is NULL 1\n");

    phead = (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD ].dp);
    phhea = (sfnt_HorizontalHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HHEAD].dp);
    phmtx = (sfnt_HorizontalMetrics *)(pjView + pfc->ptp->ateReq[IT_REQ_HMTX].dp);
    pltsh = (LTSHHEADER *)(
              (pfc->ptp->ateOpt[IT_OPT_LTSH].dp && bValidRangeLTSH(pfc->pff, pfc->ptp->ateOpt[IT_OPT_LTSH].cj) ) ?
              (pjView + pfc->ptp->ateOpt[IT_OPT_LTSH ].dp):
              NULL
              );

    cHMTX = (ULONG) BE_UINT16(&phhea->numberOf_LongHorMetrics);
    dxLastWidth = BE_UINT16(&phmtx[cHMTX-1].advanceWidth);

// See if there is cause for worry.

    if
    (
      !(pfc->flXform & XFORM_POSITIVE_SCALE)
      || ((((BYTE *) &phead->flags)[1] & 0x14)==0) // Bits indicating nonlinearity.
      || ((pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) && IsFullWidthCharacter(pfc->pff, ig)) // glyph may need to be forced to 2*singleWidth
    )
    {
        bNonLinear = FALSE; // we are linear regardless of the size
    }

    bRet = TRUE;

    if 
    (
        bNonLinear &&
        ( (pltsh == (LTSHHEADER *) NULL)
        || (pfc->lEmHtDev < pltsh->PelsHeight[ig]) )
        )
    {
        *pfxD  = 0xFFFFFFFF;
        bRet = FALSE;
    }
    else
    {
    // OK, let's scale using the FIXED transform.

        if (ig < cHMTX)
            dx = (LONG) BE_UINT16(&phmtx[ig].advanceWidth);
        else
            dx = (LONG) dxLastWidth;

	    if (pfc->mx.transform[0][0] > 0)
	    {
	        *pfxD = (FIX) (((pfc->mx.transform[0][0] * dx + 0x8000L) >> 12) & 0xFFFFFFF0);
	    }
	    else
	    {
	        *pfxD = -(FIX) (((-pfc->mx.transform[0][0] * dx + 0x8000L) >> 12) & 0xFFFFFFF0);
	    }

        if ((pfc->pff->ifi.flInfo & FM_INFO_DBCS_FIXED_PITCH) && IsFullWidthCharacter(pfc->pff, ig))
        {
            /* DBCS FixedPitch Full Width glyph */
            /* we need to use the width 2*pfc->SBCDWidth */
            /* some glyphs are flagged as FullWidth for the rotation of FE vertical writing but designed as single width */
            if ( !gbJpn98FixPitch && *pfxD && *pfxD != pfc->SBCSWidth << 4) 
                *pfxD = (2* pfc->SBCSWidth) << 4;
        }

    }
    return(bRet);
}


/******************************Public*Routine******************************\
*
*  vFillGLYPHDATA_ErrRecover
*
* Effects: error recovery routine, if rasterizer messed up just
*          provide linearly scaled values with blank bitmap.
*
* History:
*  24-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vFillGLYPHDATA_ErrRecover(
    HGLYPH        hg,
    ULONG         ig,
    FONTCONTEXT  *pfc,
    GLYPHDATA    *pgldt    // OUT
    )
{

    extern VOID vGetNotionalGlyphMetrics(FONTCONTEXT*, ULONG, NOT_GM*);
    NOT_GM ngm;  // notional glyph data

    pgldt->gdf.pgb = NULL; // may get changed by the calling routine if bits requested too
    pgldt->hg = hg;

// this is a fake blank 1x1 bitmap, no ink

    pgldt->rclInk.left   = 0;
    pgldt->rclInk.top    = 0;
    pgldt->rclInk.right  = 0;
    pgldt->rclInk.bottom = 0;

    pgldt->fxInkTop    = 0;
    pgldt->fxInkBottom = 0;

// go on to compute the positioning info:

    vGetNotionalGlyphMetrics(pfc,ig,&ngm);

    if (pfc->flXform & XFORM_HORIZ)  // scaling only
    {
        Fixed fxMxx =  pfc->mx.transform[0][0];
        if (fxMxx < 0)
            fxMxx = -fxMxx;

    // bGetFastAdvanceWidth returns the same aw that would get
    // computed by bQueryAdvanceWidths and propagated to an api
    // level through GetTextExtent and GetCharWidths. We have to
    // fill in the same aw for consistency reasons.
    // This also has to be done for win31 compatibility.

        if (!bGetFastAdvanceWidth(pfc,ig, &pgldt->fxD))
        {
        // just provide something reasonable, force linear scaling
        // even if we would not normally do it.

            pgldt->fxD = FixMul(ngm.sD,pfc->mx.transform[0][0]) << 4;
        }

        pgldt->ptqD.x.HighPart = (LONG)pgldt->fxD;
        pgldt->ptqD.x.LowPart  = 0;

        if (pfc->mx.transform[0][0] < 0)
            pgldt->fxD = - pgldt->fxD;  // this is an absolute value

        pgldt->ptqD.y.HighPart = 0;
        pgldt->ptqD.y.LowPart  = 0;

        pgldt->fxA   = FixMul(fxMxx, (LONG)ngm.sA) << 4;
        pgldt->fxAB  = FixMul(fxMxx, (LONG)ngm.xMax) << 4;

    }
    else // non trivial information
    {
    // here we will just xform the notional space data:

    // xforms are computed by simple multiplication

        pgldt->fxD         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sD);
        pgldt->fxA         = fxLTimesEf(&pfc->efBase, (LONG)ngm.sA);
        pgldt->fxAB        = fxLTimesEf(&pfc->efBase, (LONG)ngm.xMax);

        vLTimesVtfl((LONG)ngm.sD, &pfc->vtflBase, &pgldt->ptqD);
    }

// finally check if the glyphdata will need to get modified because of the
// emboldening simulation:

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        if (pgldt->fxD != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
                pgldt->fxD += (1 << 4);  // for backwards compatibility reason, the width inclease only by one pixel

    // go on to compute the positioning info:

        if (pfc->flXform & XFORM_HORIZ)  // scaling only
        {
            pgldt->ptqD.x.HighPart = (LONG)pgldt->fxD;

            if (pfc->mx.transform[0][0] < 0)
                pgldt->ptqD.x.HighPart = - pgldt->ptqD.x.HighPart;

        }
        else // non trivial information
        {
        // add a correction vector in baseline direction to each char inc vector.
        // This is consistent with fxD += LTOFX(1) and compatible with win31.

            if ((pgldt->ptqD.x.HighPart != 0) || (pgldt->ptqD.y.HighPart != 0)) /* we don't increase the width of a zero width glyph, problem with indic script */
            {
                    vAddPOINTQF(&pgldt->ptqD,&pfc->ptqUnitBase);
            }

        }
    }
}



/******************************Public*Routine******************************\
*
* LONG lGetGlyphBitmapErrRecover
*
* Effects: error recovery routine, if rasterizer messed up just
*          provide linearly scaled values with blank bitmap.
*
* History:
*  Thu 24-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG lGetGlyphBitmapErrRecover (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    PVOID        pv
    )
{
    LONG         cjGlyphData;
    GLYPHDATA    gd;      // Scummy hack
    FS_ENTRY     iRet;
    ULONG        ig; // <--> hglyph


    ASSERTDD(hglyph != HGLYPH_INVALID, "lGetGlyphBitmap, hglyph == -1\n");
    ASSERTDD(pfc == pfc->pff->pfcLast, "pfc! = pfcLast\n");

// return a small 1x1 bitmap, which will be blank, i.e. all bits will be off
// this prevents having to insert an if(cx && cy) check to a time critical
// loop in all device drivers before calling DrawGlyph routine.

    ASSERTDD(pfc->flFontType & FO_CHOSE_DEPTH,"Depth Not Chosen Yet!\n");
    cjGlyphData = CJGD(1,1,pfc);

    if ( (pgd == NULL) && (pv == NULL))
        return cjGlyphData;

// at this time we know that the caller wants the whole GLYPHDATA with
// bitmap bits, or maybe just the glypdata without the bits.

    if ( pgd == NULL )
    {
        pgd = &gd;
    }

// compute the glyph index from the character code:

    vCharacterCode(hglyph,pfc->pgin);

    if ((iRet = fs_NewGlyph(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);
        return FD_ERROR; // even backup funcion can fail
    }

// return the glyph index corresponding to this hglyph:

    ig = pfc->pgout->glyphIndex;

    vFillGLYPHDATA_ErrRecover(
        hglyph,
        ig,
        pfc,
        pgd
        );

// the caller wants the bits too

    if ( pv != NULL )
    {
        GLYPHBITS *pgb = (GLYPHBITS *)pv;

        // return blank 1x1 bitmap

        pgb->ptlOrigin.x = pfc->ptlSingularOrigin.x;
        pgb->ptlOrigin.y = pfc->ptlSingularOrigin.y;

        pgb->sizlBitmap.cx = 1;    // cheating
        pgb->sizlBitmap.cy = 1;    // cheating

        pgb->aj[0] = (BYTE)0;  // fill in a blank 1x1 bmp

        pgd->gdf.pgb = pgb;
    }

    return(cjGlyphData);
}


#if DBG
/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vDumpGrayGLYPHBITS
*
* Routine Description:
*
*   Dumps a 4bpp gray glyph bitmap to the debugging screen
*
* Arguments:
*
*   pgb -- pointer to a gray GLYPHBITS structure
*
* Return Value:
*
*   None.
*
\**************************************************************************/

void vDumpGrayGLYPHBITS(GLYPHBITS *pgb)
{
    #define CH_TOP_LEFT_CORNER '\xDA'
    #define CH_HORIZONTAL_BAR  '\xC4'
    #define CH_VERTICAL_BAR    '\xB3'
    #define CH_PIXEL_ON        '\x02'
    #define CH_PIXEL_OFF       '\xFA'

    BYTE *pj8, *pj, *pjNext, *pjEnd;
    int cjScan, i, k, c8, c4, cj;
    static const char achGray[16] = {
        CH_PIXEL_OFF,
        '1','2','3','4','5','6','7','8','9','a','b','c','d','e',
        CH_PIXEL_ON
    };

    TtfdDbgPrint(
        "\n\n"
        "ptlOrigin  = (%d,%d)\n"
        "sizlBitmap = (%d,%d)\n"
        "\n\n"
        , pgb->ptlOrigin.x
        , pgb->ptlOrigin.y
        , pgb->sizlBitmap.cx
        , pgb->sizlBitmap.cy
    );
    cjScan = (pgb->sizlBitmap.cx + 1)/2;
    cj = cjScan * pgb->sizlBitmap.cy;
    TtfdDbgPrint("\n\n  ");
    for (i = 0, k = 0; i < pgb->sizlBitmap.cx; i++, k++)
    {
        k = (k > 9) ? 0 : k;
        TtfdDbgPrint("%1d", k);
    }
    TtfdDbgPrint("\n %c",CH_TOP_LEFT_CORNER);
    for (i = 0; i < pgb->sizlBitmap.cx; i++)
    {
        TtfdDbgPrint("%c",CH_HORIZONTAL_BAR);
    }
    TtfdDbgPrint("\n");
    c8 = pgb->sizlBitmap.cx / 2;
    c4 = pgb->sizlBitmap.cx % 2;
    for (
        pj = pgb->aj, pjNext=pj+cjScan , pjEnd=pjNext+cj, k=0
        ; pjNext < pjEnd
        ; pj=pjNext , pjNext+=cjScan, k++
    )
    {
        k = (k > 9) ? 0 : k;
        TtfdDbgPrint("%1d%c",k,CH_VERTICAL_BAR);
        for (pj8 = pj+c8 ; pj < pj8; pj++)
        {
            TtfdDbgPrint("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
        }
        if (c4)
        {
            TtfdDbgPrint("%c%c", achGray[*pj>>4], achGray[*pj & 0xf]);
        }
        TtfdDbgPrint("\n");
    }
}
#endif


/******************************Public*Routine******************************\
* vGCGB
*
* Called by: vCopyGrayBits
*
* void General Copy Gray Bits
*
* History:
*  Wed 22-Feb-1995 13:14:36 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID vGCGB(
    FONTCONTEXT *pfc,   // pointer to the FONTCONTEXT this is used
                        // to determine if the font is bold simulated
    GLYPHBITS   *pgb,   // pointer to destination GRAY GLYPHBITS structure
                        // In the case where dY is zero, all the fields
                        // of the GLYPHBITS structure must be filled
                        // this includes sizlBitmap and the bits; in
                        // the case where dY is non-zero, the
                        // sizlBitmap components are precomputed and
                        // must not be touched.
    BYTE        *pjSrc, // pointer to TT gray scale bitmap
                        // This is 8-bit per pixel bitmap whose scans
                        // are aligned on 4-byte multiples. The values
                        // stored in the bitmaps are in the range
                        // 0-16. In order to fit 17 levels in the 4 bit
                        // per pixel destination we reduce the level
                        // value by 1, except for zero which is left alone.
    GMC         *pgmc,  // pointer to the glyph-metric-correction structure
                        // which has information on how to "shave" the
                        // bitmap so that it does not get above a guaranteed
                        // value
    LONG dY             // vertical offset into destination bitmap used
                        // for "special fixed pitch fonts" like Lucida
                        // Console.
    )
{
    unsigned cxDst;     // width of destination bitmap
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    static const BYTE ajGray[17] = {0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};

    #if DBG
    if (gflTtfdDebug & DEBUG_GRAY)
    {
        typedef struct _FLAGDEF {
            char *psz;      // description
            FLONG fl;       // flag
        } FLAGDEF;
        const FLAGDEF *pfd;
        FLONG fl;

        static const FLAGDEF afdFO[] = {
            {"FO_TYPE_RASTER  ", FO_TYPE_RASTER  },
            {"FO_TYPE_DEVICE  ", FO_TYPE_DEVICE  },
            {"FO_TYPE_TRUETYPE", FO_TYPE_TRUETYPE},
            {"FO_SIM_BOLD     ", FO_SIM_BOLD     },
            {"FO_SIM_ITALIC   ", FO_SIM_ITALIC   },
            {"FO_EM_HEIGHT    ", FO_EM_HEIGHT    },
            {"FO_GRAY16       ", FO_GRAY16       },
            {"FO_NOGRAY16     ", FO_NOGRAY16     },
            {"FO_NOHINTS      ", FO_NOHINTS      },
            {"FO_NO_CHOICE    ", FO_NO_CHOICE    },
            {                 0, 0               }
        };

        TtfdDbgPrint(
            "vGCGB(\n"
            "   FONTCONTEXT *pfc = %-#x\n"
            "   GLYPHBITS   *pgb = %-#x\n"
            "   BYTE      *pjSrc = %-#x\n"
            "   GMC        *pgmc = %-#x\n"
            "   LONG          dY = %d\n"
            ")\n"
          , pfc, pgb, pjSrc, pgmc, dY
        );
        TtfdDbgPrint(
            "---"
            " GMC\n"
            "\n"
            "   dyTop    = %u\n"
            "   dyBottom = %u\n"
            "   dxLeft   = %u\n"
            "   dxRight  = %u\n"
            "   cxCor    = %u\n"
            "   cyCor    = %u\n"
            "---\n\n"
          , pgmc->dyTop
          , pgmc->dyBottom
          , pgmc->dxLeft
          , pgmc->dxRight
          , pgmc->cxCor
          , pgmc->cyCor
        );
        fl = pfc->flFontType;
        TtfdDbgPrint("pfc->flFontType = %-#x\n",pfc->flFontType);
        for ( pfd=afdFO; pfd->psz; pfd++ )
        {
            if (fl & pfd->fl)
            {
                TtfdDbgPrint("    %s\n", pfd->psz);
                fl &= ~pfd->fl;
            }
        }
        if ( fl )
        {
            TtfdDbgPrint("    UNKNOWN FLAGS\n");
        }
    }
    #endif

    ASSERTDD(
        pfc->flFontType & FO_CHOSE_DEPTH
       ,"We haven't decided about pixel depth\n"
    );
    ASSERTDD(pgmc->cxCor < LONG_MAX && pgmc->cyCor < LONG_MAX
     , "vCopyGrayBits -- bad gmc\n"
    );

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor+pgmc->dxLeft+pgmc->dxRight,pfc);

    cxDst = pgmc->cxCor;

    cjDstScan = CJ_GRAY_SCAN(cxDst);

    // correct source pointer for shaving

    if (pgmc->dyTop)
    {
        pjSrc += pgmc->dyTop * cjSrcScan;
    }
    pjSrc += pgmc->dxLeft;
    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    // destination correction for special fixed pitch fonts

    if (dY)
    {
        // Console font
        // the size of the bitmap has been established already
        pjDstScan += dY * cjDstScan;
    }
    else
    {
        // Extended with Embold
        pgb->sizlBitmap.cx = cxDst;
        pgb->sizlBitmap.cy = pgmc->cyCor;
    }
    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    #if DBG
    if (gflTtfdDebug & DEBUG_GRAY)
    {
        BYTE *pjScan, *pjScanEnd;

        TtfdDbgPrint(
            "cjSrcScan          = %u\n"
            "cjDstScan          = %u\n"
            "cxDst              = %u\n"
            "pgb->sizlBitmap.cx = %u\n"
            "pgb->sizlBitmap.cy = %u\n"
            "pjSrc              = %-#x\n"
            "pjSrcScan          = %-#x\n"
            "pjDstScan          = %-#x\n"
            "pjDstScanEnd       = %-#x\n"
          ,  cjSrcScan
          ,  cjDstScan
          ,  cxDst
          ,  pgb->sizlBitmap.cx
          ,  pgb->sizlBitmap.cy
          ,  pjSrc
          ,  pjSrcScan
          ,  pjDstScan
          ,  pjDstScanEnd
        );

        // scan the source for gray values greater than 16

        pjScan    = pjSrcScan;
        pjScanEnd = pjSrcScan + cjSrcScan * pgmc->cyCor;
        for (; pjScan < pjScanEnd; pjScan+=cjSrcScan) {
            BYTE *pj;
            BYTE *pjEnd = pjScan + cjSrcScan;
            for (pj = pjScan; pj < pjEnd; pj++) {
                if (*pj > 16)
                    break;
            }
            if (pj != pjEnd)
                break;
        }
        if (pjScan != pjScanEnd) {
            TtfdDbgPrint("\n\nBad Source Gray Bitmap\n\n");
            pjScan    = pjSrcScan;
            pjScanEnd = pjSrcScan + cjSrcScan * pgmc->cyCor;
            for (; pjScan < pjScanEnd; pjScan+=cjSrcScan) {
                BYTE *pj;
                BYTE *pjEnd = pjScan + cjSrcScan;
                for (pj = pjScan; pj < pjEnd; pj++) {
                    TtfdDbgPrint("%02x ", *pj);
                }
                TtfdDbgPrint("\n");
            }
            EngDebugBreak();
        }

        TtfdDbgPrint(
            "\n"
            "Source 8-bit-per-pixel-bitmap\n"
            "\n"
        );
        pjScan    = pjSrcScan;
        pjScanEnd = pjSrcScan + cjSrcScan * pgmc->cyCor;
        for (; pjScan < pjScanEnd; pjScan+=cjSrcScan) {
            BYTE *pj;
            BYTE *pjEnd = pjScan + cjSrcScan;
            for (pj = pjScan; pj < pjEnd; pj++) {
                TtfdDbgPrint("%1x", ajGray[*pj]);
            }
            TtfdDbgPrint("\n");
        }
        TtfdDbgPrint("\n");

        EngDebugBreak();
    }
    #endif
    for (
        ; pjDstScan < pjDstScanEnd                  // whole byte loop
        ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for (
            pjSrc = pjSrcScan, pjDst = pjDstScan
          ; pjDst < pjDstScan + (pgmc->cxCor  / 2)
          ; pjDst += 1
        )
        {
            *pjDst  = 16*ajGray[*pjSrc++];  // set high nyble
            *pjDst += ajGray[*pjSrc++];     // set low nyble
        }

        // The dxAbsBold has been enhanced >= 1

        if (pgmc->cxCor & 1)                // one more pixel in source?
        {                                   // yes
            *pjDst++  = 16*ajGray[*pjSrc];    // set high nyble
        }                                   // low nyble is cleared

        while ( pjDst < (pjDstScan + cjDstScan) )    // embodening is taken care of
            *pjDst++ = 0;                           // emboldened?
                                                    // yes; clear last byte
                                                    //
   }


    #if DBG
    if (gflTtfdDebug & DEBUG_GRAY)
    {
        vDumpGrayGLYPHBITS(pgb);
    }
    #endif

}

VOID
vCopyGrayBits(
    FONTCONTEXT *pfc
  , GLYPHBITS *pgb
  , BYTE *pjSrc
  , GMC *pgmc
)
{
    vGCGB(pfc, pgb, pjSrc, pgmc, 0);
}



VOID vCopyClearTypeBits(
    FONTCONTEXT *pfc,   // pointer to the FONTCONTEXT this is used
                        // to determine if the font is bold simulated
    GLYPHBITS   *pgb,   // pointer to destination CLEARTYPE GLYPHBITS structure
                        // All the fields
                        // of the GLYPHBITS structure must be filled
                        // this includes sizlBitmap and the bits;
                        // The sizlBitmap components are precomputed and
                        // must not be touched.
    BYTE        *pjSrc, // pointer to TT ClearType bitmap
                        // This is 8-bit per pixel bitmap whose scans
                        // are aligned on 4-byte multiples. The values
                        // stored in the bitmaps are in the range
                        // 0-252.
    GMC         *pgmc   // pointer to the glyph-metric-correction structure
                        // which has information on how to "shave" the
                        // bitmap so that it does not get above a guaranteed
                        // value
    )
{
    unsigned cjSrcScan; // count of bytes in a source scan including
                        // padding out to nearest 4-byte multiple boundary
    unsigned cjDstScan; // count of bytes in a desintation scan including
                        // padding out to nearest byte boundary

    BYTE   *pjDst, *pjSrcScan, *pjDstScan, *pjDstScanEnd;

    cjSrcScan = CJ_TT_SCAN(pgmc->cxCor+pgmc->dxLeft+pgmc->dxRight,pfc);
    cjDstScan = CJ_CLEARTYPE_SCAN(pgmc->cxCor);  // should be the same as cxCor

    // correct source pointer for shaving

    if (pgmc->dyTop)
    {
        pjSrc += pgmc->dyTop * cjSrcScan;
    }
    pjSrc += pgmc->dxLeft;
    pjSrcScan = pjSrc;
    pjDstScan = pgb->aj;

    pgb->sizlBitmap.cx = pgmc->cxCor;
    pgb->sizlBitmap.cy = pgmc->cyCor;

    pjDstScanEnd = pjDstScan + pgmc->cyCor * cjDstScan;

    for ( ; pjDstScan < pjDstScanEnd ; pjDstScan += cjDstScan, pjSrcScan += cjSrcScan)
    {
        for
        (
          pjSrc = pjSrcScan, pjDst = pjDstScan;
          pjDst < (pjDstScan + pgmc->cxCor);
          pjDst++, pjSrc++
        )
        {
            *pjDst  = *pjSrc;
        }
    }
}

/******************************Public*Routine******************************\
*
* LONG lGetBitmapVertical
*
* History:
*  20-Mar-1993 -by- Takao Kitano [TakaoK]
* grabbed lGetBitmap() and modified
*
\**************************************************************************/

LONG lGetGlyphBitmapVertical (
    FONTCONTEXT *pfc,
    HGLYPH       hglyph,
    GLYPHDATA   *pgd,
    PVOID        pv,
    FS_ENTRY    *piRet
    )
{
    LONG cjGlyphData;

    if ( !IsFullWidthCharacter( pfc->pff, hglyph) )
    {
        return (lGetGlyphBitmap(pfc, hglyph, pgd, pv, piRet));
    }

    //
    // change the transformation
    //

    if ( !bChangeXform( pfc, TRUE ) )
    {
        WARNING("TTFD!bChangeXform(TRUE) failed\n");
        return FD_ERROR;
    }


    //
    // set vertical mode
    //
    pfc->ulControl |= VERTICAL_MODE;
    pfc->hgSave = hglyph;

    // call ordinary function

    cjGlyphData = lGetGlyphBitmap( pfc, hglyph, pgd, pv, piRet);

    //
    // restore the transformation and return
    //
    if ( ! bChangeXform( pfc, FALSE ) )
    {
        WARNING("TTFD!bChangeXform(FALSE) failed\n");
    }

    pfc->ulControl &= ~VERTICAL_MODE;
    return(cjGlyphData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\service.h ===
/******************************Module*Header*******************************\
* Module Name: service.h
*
* routines in service.c
*
* Created: 15-Nov-1990 13:00:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/



VOID vCpyBeToLeUnicodeString(LPWSTR pwcLeDst, LPWSTR pwcBeSrc, ULONG c);


VOID  vCpyMacToLeUnicodeString
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
const BYTE*  pjSrcMac,
ULONG  c
);

VOID  vCvtMacToUnicode
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
const BYTE*  pjSrcMac,
ULONG  c
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\sources.inc ===
MAJORCOMP=windows
MINORCOMP=ttfd

TARGETNAME=ttfd
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

C_DEFINES=$(C_DEFINES) -DFE_SB

INCLUDES=..;..\..\..\..\inc;..\..\scaler


NTPROFILEINPUT=yes

SOURCES=..\fdfon.c     \
        ..\fdfc.c      \
        ..\fd_query.c  \
        ..\fontfile.c  \
        ..\service.c   \
        ..\fd_poly.c   \
        ..\vdmx.c      \
        ..\vertical.c  \
        ..\dbg.c

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\fontfile.c ===
/******************************Module*Header*******************************\
* Module Name: fontfile.c                                                  *
*                                                                          *
* "Methods" for operating on FONTCONTEXT and FONTFILE objects              *
*                                                                          *
* Created: 18-Nov-1990 15:23:10                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
#include "fdsem.h"


#define C_ANSI_CHAR_MAX 256

HSEMAPHORE ghsemTTFD;

// The driver function table with all function index/address pairs


DRVFN gadrvfnTTFD[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) ttfdEnablePDEV             },
    {   INDEX_DrvDisablePDEV,           (PFN) ttfdDisablePDEV            },
    {   INDEX_DrvCompletePDEV,          (PFN) ttfdCompletePDEV           },
    {   INDEX_DrvQueryFont,             (PFN) ttfdQueryFont              },
    {   INDEX_DrvQueryFontTree,         (PFN) ttfdSemQueryFontTree       },
    {   INDEX_DrvQueryFontData,         (PFN) ttfdSemQueryFontData       },
    {   INDEX_DrvDestroyFont,           (PFN) ttfdSemDestroyFont         },
    {   INDEX_DrvQueryFontCaps,         (PFN) ttfdQueryFontCaps          },
    {   INDEX_DrvLoadFontFile,          (PFN) ttfdSemLoadFontFile        },
    {   INDEX_DrvUnloadFontFile,        (PFN) ttfdSemUnloadFontFile      },
    {   INDEX_DrvQueryFontFile,         (PFN) ttfdQueryFontFile          },
    {   INDEX_DrvQueryGlyphAttrs,       (PFN) ttfdSemQueryGlyphAttrs     },
    {   INDEX_DrvQueryAdvanceWidths,    (PFN) ttfdSemQueryAdvanceWidths  },
    {   INDEX_DrvFree,                  (PFN) ttfdSemFree                },
    {   INDEX_DrvQueryTrueTypeTable,    (PFN) ttfdSemQueryTrueTypeTable  },
    {   INDEX_DrvQueryTrueTypeOutline,  (PFN) ttfdSemQueryTrueTypeOutline},
    {   INDEX_DrvGetTrueTypeFile,       (PFN) ttfdGetTrueTypeFile        }
};





/******************************Public*Routine******************************\
* ttfdEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
*  Sun 25-Apr-1993 -by- Patrick Ha1luptzok [patrickh]
* Change to be same as DDI Enable.
*
* History:
*  12-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL ttfdEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

    if ((ghsemTTFD = EngCreateSemaphore()) == (HSEMAPHORE) 0)
    {
        return(FALSE);
    }

    pded->pdrvfn = gadrvfnTTFD;
    pded->c = sizeof(gadrvfnTTFD) / sizeof(DRVFN);
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;

// init global data:

    return(TRUE);
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI
*
\**************************************************************************/

DHPDEV
ttfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver)
{

    PVOID*   ppdev;

    //
    // Allocate a four byte PDEV for now
    // We can grow it if we ever need to put information in it.
    //

    ppdev = (PVOID*) EngAllocMem(0, sizeof(PVOID), 'dftT');

    return ((DHPDEV) ppdev);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID
ttfdDisablePDEV(
    DHPDEV  dhpdev)
{
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID
ttfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev)
{
    return;
}



/******************************Public*Routine******************************\
*
* VOID vInitGlyphState(PGLYPHSTAT pgstat)
*
* Effects: resets the state of the new glyph
*
* History:
*  22-Nov-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vInitGlyphState(PGLYPHSTATUS pgstat)
{
    pgstat->hgLast  = HGLYPH_INVALID;
    pgstat->igLast  = 0xffffffff;
    pgstat->bOutlineIsMessed = TRUE;
}



VOID vMarkFontGone(TTC_FONTFILE *pff, DWORD iExceptionCode)
{
    ULONG i;

    ASSERTDD(pff, "ttfd!vMarkFontGone, pff\n");

// this font has disappeared, probably net failure or somebody pulled the
// floppy with ttf file out of the floppy drive

    if (iExceptionCode == STATUS_IN_PAGE_ERROR) // file disappeared
    {
    // prevent any further queries about this font:

        pff->fl |= FF_EXCEPTION_IN_PAGE_ERROR;

        for( i = 0; i < pff->ulNumEntry ; i++ )
        {
            PFONTFILE pffReal;

        // get real pff.

            pffReal = PFF(pff->ahffEntry[i].hff);

        // if memoryBases 0,3,4 were allocated free the memory,
        // for they are not going to be used any more

            if (pffReal->pj034)
            {
                V_FREE(pffReal->pj034);
                pffReal->pj034 = NULL;
            }

        // if memory for font context was allocated and exception occured
        // after allocation but before completion of ttfdOpenFontContext,
        // we have to free it:

            if (pffReal->pfcToBeFreed)
            {
                V_FREE(pffReal->pfcToBeFreed);
                pffReal->pfcToBeFreed = NULL;
            }
        }
    }

    if (iExceptionCode == STATUS_ACCESS_VIOLATION)
    {
        RIP("TTFD!this is probably a buggy ttf file\n");
    }
}

/**************************************************************************\
*
* These are semaphore grabbing wrapper functions for TT driver entry
* points that need protection.
*
*  Mon 29-Mar-1993 -by- Bodin Dresevic [BodinD]
* update: added try/except wrappers
*
*   !!! should we also do some unmap file clean up in case of exception?
*   !!! what are the resources to be freed in this case?
*   !!! I would think,if av files should be unmapped, if in_page exception
*   !!! nothing should be done
*
 *
\**************************************************************************/

ULONG ExceptionFilter_TtfdLoadFontFile(ULONG ExceptionCode)
{
    ASSERTDD(ExceptionCode == STATUS_IN_PAGE_ERROR,
                  "ttfdSemLoadFontFile, strange exception code\n");

    return EXCEPTION_EXECUTE_HANDLER;
}

HFF
ttfdSemLoadFontFile (
    ULONG cFiles,
    ULONG_PTR *piFile,
    PVOID *ppvView,
    ULONG *pcjView,
    DESIGNVECTOR *pdv,
    ULONG ulLangId,
    ULONG ulFastCheckSum
    )
{
    HFF   hff = (HFF)NULL;
    ULONG_PTR iFile;
    PVOID pvView;
    ULONG cjView;
    BOOL     bRet = FALSE;

    if ((cFiles != 1) || pdv)
        return hff;

    iFile  = *piFile;
    pvView = *ppvView;
    cjView = *pcjView;

    EngAcquireSemaphore(ghsemTTFD);

#ifndef TTFD_NO_TRY_EXCEPT
    try
    {
#endif

        bRet = bLoadFontFile(iFile,
                             pvView,
                             cjView,
                             ulLangId,
                             ulFastCheckSum,
                             &hff
                             );

        if (!bRet)
        {
            ASSERTDD(hff == (HFF)NULL, "LoadFontFile, hff not null\n");
        }
#ifndef TTFD_NO_TRY_EXCEPT
    }
    except (ExceptionFilter_TtfdLoadFontFile(GetExceptionCode()))
    {
        WARNING("TTFD!_ exception in ttfdLoadFontFile\n");

        if (hff)
        {
            ttfdUnloadFontFileTTC(hff);
            hff = (HFF)NULL;
        }
    }
#endif

    EngReleaseSemaphore(ghsemTTFD);
    return hff;
}

BOOL
ttfdSemUnloadFontFile (
    HFF hff
    )
{
    BOOL bRet;
    EngAcquireSemaphore(ghsemTTFD);

#ifndef TTFD_NO_TRY_EXCEPT
    try
    {
#endif
        bRet = ttfdUnloadFontFileTTC(hff);
#ifndef TTFD_NO_TRY_EXCEPT
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("TTFD!_ exception in ttfdUnloadFontFile\n");
        bRet = FALSE;
    }
#endif

    EngReleaseSemaphore(ghsemTTFD);
    return bRet;
}

BOOL bttfdMapFontFileFD(PTTC_FONTFILE pttc)
{
    return (pttc ? (EngMapFontFileFD(PFF(pttc->ahffEntry[0].hff)->iFile,
                                     (PULONG*)&pttc->pvView,
                                     &pttc->cjView))
                 : FALSE);
}


PFD_GLYPHATTR  ttfdSemQueryGlyphAttrs (FONTOBJ *pfo, ULONG iMode)
{

    PFD_GLYPHATTR pRet = NULL;

    if (iMode == FO_ATTR_MODE_ROTATE)
    {
        if (!(pRet = PTTC(pfo->iFile)->pga) &&
            bttfdMapFontFileFD((PTTC_FONTFILE)pfo->iFile))
        {
            EngAcquireSemaphore(ghsemTTFD);
        
#ifndef TTFD_NO_TRY_EXCEPT
            try
            {
#endif
                pRet = ttfdQueryGlyphAttrs(pfo);
#ifndef TTFD_NO_TRY_EXCEPT
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("TTFD!_ exception in ttfdQueryGlyphAttrs\n");
            
                vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
            }
#endif
        
            EngReleaseSemaphore(ghsemTTFD);
    
            EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
        }
    }

    return pRet;
}



LONG
ttfdSemQueryFontData (
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    LONG lRet = FD_ERROR;

    dhpdev;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemTTFD);

#ifndef TTFD_NO_TRY_EXCEPT
        try
        {
#endif
            lRet = ttfdQueryFontData (
                       pfo,
                       iMode,
                       hg,
                       pgd,
                       pv,
                       cjSize
                       );
#ifndef TTFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in ttfdQueryFontData\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
#endif
        
        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return lRet;
}


VOID
ttfdSemFree (
    PVOID pv,
    ULONG_PTR id
    )
{
    EngAcquireSemaphore(ghsemTTFD);

    ttfdFree (
        pv,
        id
        );

    EngReleaseSemaphore(ghsemTTFD);
}


VOID
ttfdSemDestroyFont (
    FONTOBJ *pfo
    )
{
    EngAcquireSemaphore(ghsemTTFD);

    ttfdDestroyFont (
        pfo
        );

    EngReleaseSemaphore(ghsemTTFD);
}


LONG
ttfdSemQueryTrueTypeOutline (
    DHPDEV     dhpdev,
    FONTOBJ   *pfo,
    HGLYPH     hglyph,
    BOOL       bMetricsOnly,
    GLYPHDATA *pgldt,
    ULONG      cjBuf,
    TTPOLYGONHEADER *ppoly
    )
{
    LONG lRet = FD_ERROR;

    dhpdev;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemTTFD);
    
#ifndef TTFD_NO_TRY_EXCEPT
        try
        {
#endif
             lRet = ttfdQueryTrueTypeOutline (
                        pfo,
                        hglyph,
                        bMetricsOnly,
                        pgldt,
                        cjBuf,
                        ppoly
                        );
    
#ifndef TTFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in ttfdQueryTrueTypeOutline\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
#endif
    
        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return lRet;
}




/******************************Public*Routine******************************\
* BOOL ttfdQueryAdvanceWidths
*
* History:
*  29-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL ttfdSemQueryAdvanceWidths
(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    BOOL               bRet = FD_ERROR;

    dhpdev;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemTTFD);
    
#ifndef TTFD_NO_TRY_EXCEPT
        try
        {
#endif
            bRet = bQueryAdvanceWidths (
                       pfo,
                       iMode,
                       phg,
                       plWidths,
                       cGlyphs
                       );
#ifndef TTFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in bQueryAdvanceWidths\n");
    
            vMarkFontGone((TTC_FONTFILE *)pfo->iFile, GetExceptionCode());
        }
#endif
    
        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(pfo->iFile)->ahffEntry[0].hff)->iFile);
    }
    return bRet;
}



LONG
ttfdSemQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    PBYTE   pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,// ptr to table in mapped font file
    ULONG  *pcjTable // size of the whole table in the file
    )
{
    LONG lRet;
    lRet = FD_ERROR;

    if (bttfdMapFontFileFD((TTC_FONTFILE *)hff))
    {
        EngAcquireSemaphore(ghsemTTFD);
    
#ifndef TTFD_NO_TRY_EXCEPT
        try
        {
#endif
            lRet = ttfdQueryTrueTypeTable (
                        hff,
                        ulFont,  // always 1 for version 1.0 of tt
                        ulTag,   // tag identifying the tt table
                        dpStart, // offset into the table
                        cjBuf,   // size of the buffer to retrieve the table into
                        pjBuf,   // ptr to buffer into which to return the data
                        ppjTable,
                        pcjTable
                        );
#ifndef TTFD_NO_TRY_EXCEPT
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("TTFD!_ exception in ttfdQueryTrueTypeTable\n");
            vMarkFontGone((TTC_FONTFILE *)hff, GetExceptionCode());
        }
#endif
    
        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(hff)->ahffEntry[0].hff)->iFile);
    }

    return lRet;
}



FD_GLYPHSET *pgsetComputeSymbolCP()
{
    ULONG cjSymbolCP;

    PFD_GLYPHSET pgsetCurrentCP;
    PFD_GLYPHSET pgsetSymbolCP  = NULL; // current code page + symbol area


// pgsetCurrentCP contains the unicode runs for the current ansi code page
// It is going to be used for fonts with PlatformID for Mac, but for which
// we have determined that we are going to cheat and pretend that the code
// page is NOT mac but windows code page. Those are the fonts identified
// by bCvtUnToMac = FALSE

    pgsetCurrentCP = EngComputeGlyphSet(0,0,256);

    if (pgsetCurrentCP)
    {
    // for symbol fonts we report both the current code page plus
    // the range 0xf000-0xf0ff.

        INT cRuns = (INT)pgsetCurrentCP->cRuns;

        cjSymbolCP  = SZ_GLYPHSET(cRuns + 1, 2 * C_ANSI_CHAR_MAX - 32);


        pgsetSymbolCP = (FD_GLYPHSET *)PV_ALLOC(cjSymbolCP);

        if (pgsetSymbolCP)
        {
        // now use pgsetCurrentCP to manufacture symbol character set:

            pgsetSymbolCP->cjThis = cjSymbolCP;
            pgsetSymbolCP->flAccel = GS_16BIT_HANDLES;

            pgsetSymbolCP->cGlyphsSupported = 2 * C_ANSI_CHAR_MAX - 32;
            pgsetSymbolCP->cRuns = cRuns + 1;

            {
                INT iRun, ihg;
                HGLYPH *phgD;

                phgD = (HGLYPH *)&pgsetSymbolCP->awcrun[cRuns+1];
                for
                (
                    iRun = 0;
                    (iRun < cRuns) && (pgsetCurrentCP->awcrun[iRun].wcLow < 0xf000);
                    iRun++
                )
                {
                    pgsetSymbolCP->awcrun[iRun].wcLow =
                        pgsetCurrentCP->awcrun[iRun].wcLow;
                    pgsetSymbolCP->awcrun[iRun].cGlyphs =
                        pgsetCurrentCP->awcrun[iRun].cGlyphs;
                    pgsetSymbolCP->awcrun[iRun].phg = phgD;
                    RtlCopyMemory(
                        phgD,
                        pgsetCurrentCP->awcrun[iRun].phg,
                        sizeof(HGLYPH) * pgsetCurrentCP->awcrun[iRun].cGlyphs
                        );
                    phgD += pgsetCurrentCP->awcrun[iRun].cGlyphs;
                }

            // now insert the user defined area:

                pgsetSymbolCP->awcrun[iRun].wcLow   = 0xf020;
                pgsetSymbolCP->awcrun[iRun].cGlyphs = C_ANSI_CHAR_MAX - 32;
                pgsetSymbolCP->awcrun[iRun].phg = phgD;
                for (ihg = 32; ihg < C_ANSI_CHAR_MAX; ihg++)
                    *phgD++ = ihg;

            // and now add the remaining ranges if any from the current code page:

                for ( ; iRun < cRuns; iRun++)
                {
                    pgsetSymbolCP->awcrun[iRun+1].wcLow =
                        pgsetCurrentCP->awcrun[iRun].wcLow;
                    pgsetSymbolCP->awcrun[iRun+1].cGlyphs =
                        pgsetCurrentCP->awcrun[iRun].cGlyphs;
                    pgsetSymbolCP->awcrun[iRun+1].phg = phgD;

                    RtlCopyMemory(
                        phgD,
                        pgsetCurrentCP->awcrun[iRun].phg,
                        sizeof(HGLYPH) * pgsetCurrentCP->awcrun[iRun].cGlyphs
                        );
                    phgD += pgsetCurrentCP->awcrun[iRun].cGlyphs;
                }
            }

        }

        V_FREE(pgsetCurrentCP);
    }

    return pgsetSymbolCP;

}


PVOID ttfdSemQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
)
{
    PVOID   pRet = NULL;

    if (bttfdMapFontFileFD(PTTC(hff)))
    {
        EngAcquireSemaphore(ghsemTTFD);

        pRet = ttfdQueryFontTree (
                    dhpdev,
                    hff,
                    iFace,
                    iMode,
                    pid
                    );

        EngReleaseSemaphore(ghsemTTFD);

        EngUnmapFontFileFD(PFF(PTTC(hff)->ahffEntry[0].hff)->iFile);
    }

    return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\fontfile.h ===
/******************************Module*Header*******************************\
* Module Name: fontfile.h
*
* FONTFILE and FONTCONTEXT objects
*
* Created: 25-Oct-1990 09:20:11
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/


#include "xform.h"

// for high-byte mapping support

typedef struct _MbcsToIndex
{
    BYTE    MbcsChar[4];
    HGLYPH  hGlyph;
} MbcsToIndex;

typedef struct _WcharToIndex
{
    BOOL    bValid;
    WCHAR   wChar;
    HGLYPH  hGlyph;
} WcharToIndex;


// cjIFI - size of the whole ifimetrics struct, with all strings appended
// cjFamilyName
// cjFaceName
// cjUniqueName
// cjSubfamilyName

#if DBG
#define DEBUG_GRAY 1
#endif

typedef struct _IFISIZE  // ifisz
{
    ULONG cjIFI;
    ULONG dpSims;          // offset of the FONTSIM struct
    PBYTE pjFamilyName;    // pointer to the location in the ttf file
    ULONG cjFamilyName;
    PBYTE pjFamilyNameAlias;    // pointer to the location in the ttf file
    ULONG cjFamilyNameAlias;
    PBYTE pjSubfamilyName; // pointer to the location in the ttf file
    ULONG cjSubfamilyName;
    PBYTE pjUniqueName;    // pointer to the location in the ttf file
    ULONG cjUniqueName;
    PBYTE pjFullName;      // pointer to the location in the ttf file
    ULONG cjFullName;
    ULONG dpCharSets;      // offset to array of charsets
    ULONG dpFontSig;       // offset to FONTSIGNATURE

    // offsets, in bytes, relative to IFIMETRICS
    ULONG dpFamilyName;
    ULONG dpFamilyNameAlias;
    ULONG dpSubfamilyName;
    ULONG dpUniqueName;
    ULONG dpFullName;

    // sizes, in bytes, of the names converted to unicode, including terminating zero
    ULONG cbFamilyName;
    ULONG cbFamilyNameAlias;
    ULONG cbSubfamilyName;
    ULONG cbUniqueName;
    ULONG cbFullName;

    // bComputeIFISIZE call arguments
    USHORT ui16PlatID;
    USHORT ui16SpecID;
} IFISIZE, *PIFISIZE;


typedef struct _TT_FONTFILE       *PFONTFILE;     // pff
typedef struct _TT_FONTCONTEXT    *PFONTCONTEXT;  // pfc
typedef struct _TTC_FONTFILE   *PTTC_FONTFILE; // pttc


// in the debug version of the rasterizer STAMPEXTRA shoud be added to the
// sizes. strictly speaking this is illegal, but nevertheless very useful.
// it assumes the knowlege of rasterizer internalls [bodind],
// see fscaler.c

#define STAMPEXTRA 4


#define CJ_0  NATURAL_ALIGN(sizeof(fs_SplineKey) + STAMPEXTRA)

#define FF_EXCEPTION_IN_PAGE_ERROR 1
#define FF_TYPE_1_CONVERSION       2


// BEGIN hack for kerning pairs, if these two map to same glyph index
// than space and hyphen should be returned.

#define FF_SPACE_EQUAL_NBSPACE     16
#define FF_HYPHEN_EQUAL_SFTHYPHEN  32

// Hack for new shell font for NT 5.0.
// Max Neg A will be forced to 0, it is same as MS Sans Serif
// 0x50 will not support in Korean and Japanese language

#define FF_NEW_SHELL_FONT           64

// If the font is signed

#define FF_SIGNATURE_VALID     128

// set if any DBCS charset is supported

#define FF_DBCS_CHARSET        256


#define SPACE        0X20
#define NBSPACE      0xA0
#define HYPHEN       0X2D
#define SFTHYPHEN    0XAD

typedef struct _CMAPINFO // cmi
{
    FLONG  fl;       // flags, see above
    ULONG  i_b7;     // index for [b7,b7] wcrun in FD_GLYPHSET if b7 is NOT supported
    ULONG  i_2219;   // cmap index for 2219 if 2219 IS supported
    ULONG  cRuns;    // number of runs in a font, excluding the last run
                     // if equal to [ffff,ffff]
    uint16 ui16SpecID; // for keep encoding ID
    ULONG  cGlyphs;  // total number of glyphs in a font
} CMAPINFO;


typedef struct _FFCACHE
{
//
// Move it from FONTFILE. We will cache it into TTCACHE.
//

    TABLE_POINTERS  tp;

    ULONG           ulTableOffset;

// FE vertical facename support

    ULONG           ulVerticalTableOffset; 
    uint16          uLongVerticalMetrics;

    ULONG           ulNumFaces;       // 1 or at most 2 if this is a FE font, (foo and @foo)

    UINT            uiFontCodePage; // 

    ULONG           cj3;     // request memorySizes[3],   
    ULONG           cj4;     // request memorySizes[4],     

// some general flags, for now only exception info, such as in_page_err

    FLONG           fl;

    ULONG           dpMappingTable;

// make it simple to access the ttf file

    uint16          ui16EmHt;
    uint16          ui16PlatformID;
    uint16          ui16SpecificID;
    uint16          ui16LanguageID;

// pointer to a glyphset for this file. It may be pointing to one of the
// shared glyphset structures, if this is appropriate, or to a
// glyphset structure that is very specific to this file and is stored
// at the bottom of GLYPH_IN_OUT

    ULONG           iGlyphSet;         // type of the glyphset  
    ULONG           wcBiasFirst;       // only used if ffca.iGlyphSet == SYMBOL 

// support for GeCharWidthInfo, private user api:

    USHORT          usMinD; // needs to be computed on the first font realization
    USHORT          igMinD; // index in hmtx table that points to usMinD
    SHORT           sMinA;  // from hhea
    SHORT           sMinC;  // from hhea

    CMAPINFO        cmi;    

} FFCACHE;

typedef struct _TT_FONTFILE    // ff
{
    PTTC_FONTFILE pttc;

// these are set by bCheckVerticalTable

    ULONG       (*hgSearchVerticalGlyph)(PFONTFILE,ULONG);

    PIFIMETRICS pifi_vertical;

    PBYTE        pj034;   // 0,3,4 buffers
    PFONTCONTEXT pfcLast; // last fc that set 034 buffers

// mem to be freed if file disappeared while trying to open font context
// only used in exception scenarios

    PFONTCONTEXT pfcToBeFreed;

    ULONG cRef;    // # no of times this font file is selected into fnt context

    ULONG_PTR iFile; // contains a pointer
    PVOID  pvView;   // contains the pointer to the top of ttf
    ULONG  cjView;  // contains size of the font file

// Pointer to an array of FD_KERNINGPAIR structures (notional units).
// The array is terminated by a zeroed FD_KERNINGPAIR structure.
// NULL until computed.  If there are no kerning pairs, then this will
// point to a zeroed (terminating) FD_KERNINGPAIR structure.

    FD_KERNINGPAIR *pkp;      // pointer to array of kerning pairs

    PFD_GLYPHSET    pgset;

//  for vertical gset


    PFD_GLYPHSET    pgsetv;

    ULONG           cRefGSet;
    ULONG           cRefGSetV;

    FFCACHE ffca;

// Note:
// The way memory is allocated for the FONTFILE structure, the IFIMETRICS
// MUST BE THE LAST ELEMENT of the structure!

    IFIMETRICS   ifi;         //!!! should it not this be put on the disk??? [bodind]

} FONTFILE;


typedef struct _TTC_CACHE
{
    FLONG       flTTCFormat;
    ULONG       cTTFsInTTC;       // number of TTF's in this TTC (or one if this is a TTF file)
    DWORD       dpGlyphAttr; // Cache for Glyphset;
    DWORD       dpTTF[1];         // there will be cTTFsInTTC of these offsets in the array
} TTC_CACHE,    *PTTC_CACHE;

// we will have one of these for every TTF in a TTC. Therefore ulNumFaces can be at most 2,
// for foo and @foo faces. cjIFI is the size of either IFIMETRICS corresponding
// to foo or @foo faces (we allocate the same size for foo and @foo IFIMETRICS structures).
// cjIFI is is NOT the sum of the sizes of the two IFIMETRICS.

typedef struct _TTF_CACHE
{
    ULONG        iSearchVerticalGlyph;  // (*hgSearchVerticalGlyph)(PFONTFILE,ULONG);
    FFCACHE      ffca;       // shared data between foo and @foo faces

// we store the ifimetrics for foo face starting here, followed by the the ifimetrics for
// @foo face if there is one, followed by gset for foo face. For now we do not store gsetv,
// but compute it dynamically

    double      acIfi[1];    // really a byte array but now compiler guarantees QUAD alignment

} TTF_CACHE, *PTTF_CACHE;

// the values for iSearchVerticalGlyph

#define SUB_FUNCTION_DUMMY 0
#define SUB_FUNCTION_GSUB  1
#define SUB_FUNCTION_MORT  2

//
// TrueType collection 'ttc' font file support
//

typedef struct _TTC_HFF_ENTRY
{
    ULONG     ulOffsetTable;
    ULONG     iFace;
    HFF       hff;
} TTC_HFF_ENTRY, *PTTC_HFF_ENTRY;

typedef struct _TTC_FONTFILE    // ttcff
{
    ULONG         cRef;
    FLONG         fl;
    ULONG         ulTrueTypeResource;
    ULONG         ulNumEntry;
    PVOID         pvView;
    ULONG         cjView;
    PFD_GLYPHATTR pga;
    TTC_HFF_ENTRY ahffEntry[1];
} TTC_FONTFILE, *PTTC_FONTFILE;


#define CJ_IN      NATURAL_ALIGN(sizeof(fs_GlyphInputType))
#define CJ_OUT     NATURAL_ALIGN(sizeof(fs_GlyphInfoType))


// types of FD_GLYPHSET's, one of the predefined ones, or some
// general type

// mac

#define GSET_TYPE_MAC_ROMAN  1

// mac, but we pretend it is windows ansi

#define GSET_TYPE_PSEUDO_WIN 2

// honest to God msft unicode font

#define GSET_TYPE_GENERAL    3

// this is windows 31 hack. This is intened for fonts that have
// platid = 3 (msft), spec id (0), cmap format 4. In this case
// char codes are converted as
// charCode = iAnsi + (wcFirst - 0x20)

#define GSET_TYPE_SYMBOL     4

#define GSET_TYPE_HIGH_BYTE  5

#define GSET_TYPE_GENERAL_NOT_UNICODE  6


// win 31 BiDi fonts (Arabic Simplified, Arabic Traditional and Hebrew)
// These fonts have the HIBYTE(pOS2->usSelection) = 0xB1, 0xB2, 0xB3 or 0xB4
// and the puStartCount&0xFF00 is TRUE

#define GSET_TYPE_OLDBIDI    7


/**************************************************************************\

         GLYPHSTATUS structure

// handle of the last glyph that has been processed and a boolean
// which indicates whether metric info for a bitmap corresponding
// to that glyph has been computed

\**************************************************************************/

typedef struct _GLYPHSTATUS
{
    HGLYPH hgLast;
    ULONG  igLast;       // corresponding glyph index, rasterizer likes it better
    PVOID  pv;           // pointer to mem allocated just for the purpose of
                         // or producing bitmap or the outline for this glyph
    BOOL   bOutlineIsMessed;  // outline generated by bGetGlyphOutline might get messed by fs_FindBitMapSize
} GLYPHSTATUS, *PGLYPHSTATUS;

// "method" acting on this "object"

VOID vInitGlyphState(PGLYPHSTATUS pgstat);

// HDMX stuff, from fd_royal.h in win31 sources:

typedef struct
{
  BYTE     ucEmY;
  BYTE     ucEmX;          // MAX advance width for this EmHt;
  BYTE     aucInc [1];     // maxp->numGlyphs of entries
} HDMXTABLE;        // hdmx

typedef struct
{
  uint16            Version;    // table version number, starts at zero
  uint16            cRecords;
  uint32            cjRecord;   // dword aligned size of individual record,
                                // all of them have the same size

// after this records follow:

  // HDMXTABLE         HdmxTable [cRecords]
} HDMXHEADER;  // hdhdr

// to get to the next record one does the following:
// phdmx = (HDMXTABLE *)((BYTE *)phdmx + phdhdr->cjRecord);

// 'gasp' structures

typedef struct
{
    uint16  rangeMaxPPEM;
    uint16  rangeGaspBehavior;
} GASPRANGE;

typedef struct
{
    uint16  version;
    uint16  numRanges;
    GASPRANGE   gaspRange[1];
} GASPTABLE;

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002


/**************************************************************************\
 *  FONTCONTEXT structure
\**************************************************************************/

typedef struct _TT_FONTCONTEXT     // fc
{
    FONTOBJ*  pfo;          // points back to calling FONTOBJ
    PFONTFILE pff;          // handle of the font file selected into this context

// handle of the last glyph that has been processed and a boolean
// which indicates whether metric info for a bitmap corresponding
// to that glyph has been computed

    GLYPHSTATUS gstat;

// parts of FONTOBJ that are important

    FLONG   flFontType;
    SIZE    sizLogResPpi;
    ULONG   ulStyleSize;

// transform matrix in the format as requested by the font scaler
// the FONTOBJ and XFORMOBJ (in the form of the XFORM) fully specify
// the font context for the realization

    XFORML      xfm;          // cached xform
    transMatrix mx;           // the same as above, just a different format
    FLONG       flXform;

// if it were not for win31 vdmx hacks this field would not be necessary,

    LONG   lEmHtDev;          // em height in pixels in device space
    Fixed  fxPtSize;          // em height in points on the rendering device

// pointer to the hdmx table that applies if any, else NULL

    HDMXTABLE *phdmx;

// asc and desc measured along unit ascender vector in device coords.
// Unit ascender vector in device coords == xForm(0,-1)/|xForm(0,-1)|

    LONG  lAscDev;
    LONG  lDescDev;

// xMin and xMax in device coords for grid fitted glyphs, cxMax = xMax - xMin

    LONG  xMin;
    LONG  xMax;

// asender and descender in device coords for grid fitted glyphs
// cyMax = yMax - yMin;

    LONG  yMin;
    LONG  yMax;

// max width in pixels of all rasterized bitmaps

    ULONG cxMax;

// the size of the GLYPHDATA structure necessary to store the largest
// glyph bitmap with the header info. This is value is cashed at the
// time the font context is opened and used later in FdQueryGlyphBitmap

    ULONG cjGlyphMax;  // in BYTE's

// tt structures, they live in pff->cj034

    fs_GlyphInputType *pgin;
    fs_GlyphInfoType  *pgout;

    PTABLE_POINTERS     ptp;

// This is used for the glyph origin of singular bitmaps to make sure they don't
// get placed outside of the text bounding box for fonts with positive max
// descent or negative max ascent.

    POINTL ptlSingularOrigin;

// a few fields that are realy only necessary if the xform is
// non trivial, cached here to speed up metric computations for glyphs:

    VECTORFL vtflBase;      // ptqBase = Xform(e1)
    POINTE   pteUnitBase;   // ptqBase/|ptqBase|
    EFLOAT   efBase;        // |ptqBase|, enough precission

    POINTQF  ptqUnitBase;   // pteUnitBase in POINTQF format,
                            // has to be added to all ptqD's if emboldening

    VECTORFL vtflSide;      // ptqSide = Xform(-e2)
    POINTE   pteUnitSide;   // ptqSide/|ptqSide|
    EFLOAT   efSide;        // |ptqSide|, enough precission

    POINTQF  ptqUnitSide;   // pteUnitSide in POINTQF format,

// data added to speed up bBigEnough computation

    POINTFIX ptfxTop;
    POINTFIX ptfxBottom;

// for FE vertical support

    ULONG    ulControl;     // to signal if we need a rotated glyph or use bitmap
    BOOL     bVertical;     // TRUE if it's @face
    ULONG    hgSave;
    Fixed    pointSize;     // for fs_NewTransformation
    transMatrix mxv;        // mx for vertical glyphs
    transMatrix mxn;        // mx for normal glyphs
    Fixed    fxdevShiftX;   // x shift value in device space
    Fixed    fxdevShiftY;   // y shift value in device space

// for font emboldening, most glyphs will use global emboldening info,
// only those glyphs which extend to descender will have to
// use different emb.

    USHORT dBase;

// TrueType Rasterizer 1.7 require the overScale (for antialiazed text) to be passed to fs_NewTransformation
// we need to keep track of this value to pass it at fs_NewTransform

	USHORT overScale;

// for FE DBCS fixed pitch, we store the SBCS width so that we can enforce DBCS width = 2 * SBCS width
// value set for fonts that have  (pifi->flInfo & FM_INFO_DBCS_FIXED_PITCH)

    LONG SBCSWidth;


} FONTCONTEXT;

/* fc->overscale get first set to FF_UNDEFINED_OVERSCALE and at fs_NewTransform get set to the current one */
#define FF_UNDEFINED_OVERSCALE 0x0FFFF

// flags describing the transform, may change a bit,
// quantized bit means that the original xform has been
// changed a bit to take into account vdmx quantization

#define XFORM_HORIZ           1
#define XFORM_VERT            2
#define XFORM_VDMXEXTENTS     4
#define XFORM_SINGULAR        8
#define XFORM_POSITIVE_SCALE 16
#define XFORM_2PPEM	     32
#define XFORM_MAX_NEG_AC_HACK  64
#define XFORM_BITMAP_SIM_BOLD  128

// unicode code points used to detect charset of FE fonts

#define U_HALFWIDTH_KATAKANA_LETTER_A      0xFF71 // SJIS B1
#define U_HALFWIDTH_KATAKANA_LETTER_I      0xFF72 // SJIS B2
#define U_HALFWIDTH_KATAKANA_LETTER_U      0xFF73 // SJIS B3
#define U_HALFWIDTH_KATAKANA_LETTER_E      0xFF74 // SJIS B4
#define U_HALFWIDTH_KATAKANA_LETTER_O      0xFF75 // SJIS B5

#define U_FULLWIDTH_HAN_IDEOGRAPHIC_9F98   0x9F98 // BIG5 F9D5
#define U_FULLWIDTH_HAN_IDEOGRAPHIC_9F79   0x9F79 // BIG6 F96A

#define U_FULLWIDTH_HAN_IDEOGRAPHIC_61D4   0x61D4 // GB   6733
#define U_FULLWIDTH_HAN_IDEOGRAPHIC_9EE2   0x9EE2 // GB   8781

#define U_FULLWIDTH_HANGUL_LETTER_GA       0xAC00 // WS   B0A1
#define U_FULLWIDTH_HANGUL_LETTER_HA       0xD558 // WS   C7CF

#define U_PRIVATE_USER_AREA_E000           0xE000 // SJIS F040

// basic "methods" that act on the FONTFILE object  (in fontfile.c)

#define   PFF(hff)      ((PFONTFILE)hff)
#define   pffAlloc(cj)  ((PFONTFILE)EngAllocMem(0, cj, 'dftT'))
#define   vFreeFF(hff)  EngFreeMem((PVOID)hff)

// basic "methods" that act on the TTC_FONTFILE object

#define   PTTC(httc)     ((PTTC_FONTFILE)httc)
#define   pttcAlloc(cj)  ((PTTC_FONTFILE)EngAllocMem(FL_ZERO_MEMORY, cj, 'dftT'))
#define   vFreeTTC(httc) V_FREE(httc)

// basic "methods" that act on the FONTCONTEXT object  (in fontfile.c)

#define   PFC(hfc)      ((PFONTCONTEXT)hfc)
#define   pfcAlloc(cj)  ((PFONTCONTEXT)EngAllocMem(0, cj, 'dftT'))
#define   vFreeFC(hfc)  EngFreeMem((PVOID)hfc)

#define   V_FREE(pv)    EngFreeMem((PVOID)pv)
#define   PV_ALLOC(cj)  EngAllocMem(0, cj, 'dftT')


// tt required functions, callbacks

voidPtr FS_CALLBACK_PROTO pvGetPointerCallback    (ULONG_PTR  clientID, long dp, long cjData);
void    FS_CALLBACK_PROTO vReleasePointerCallback (voidPtr pv);

BOOL bGetFastAdvanceWidth(FONTCONTEXT *, ULONG, FIX *);


//
// Used to identify data dynamically allocated that will be
// freed via the ttfdFree function.  The ulDataType specifies
// the type of dynamic data.
//

typedef struct _DYNAMICDATA
{
    ULONG     ulDataType;   // data type
    FONTFILE *pff;          // identifies font file this data corresponds to
} DYNAMICDATA;


//
// Data types allocated dynamically:
//
//  ID_KERNPAIR dynamically allocated array of FD_KERNINGPAIR structures
//

#define ID_KERNPAIR 0
#define FO_CHOSE_DEPTH   0x80000000

#define CJGD(w,h,p)                                                      \
  ALIGN4(offsetof(GLYPHBITS,aj)) +                                       \
  ALIGN4((h)*(((p)->flFontType & FO_GRAY16)?(((p)->flFontType & FO_CLEARTYPE_X)?(w):(((w)+1)/2)):(((w)+7)/8)))

LONG lExL(FLOATL e, LONG l);


// for FE vertical support

// pfc->ulControl

#define VERTICAL_MODE       0x02

VOID  vCalcXformVertical( FONTCONTEXT *pfc);
BOOL  bChangeXform( FONTCONTEXT *pfc, BOOL bRotation );
BOOL  IsFullWidthCharacter(FONTFILE *pff, HGLYPH hg);
VOID  vShiftBitmapInfo(FONTCONTEXT *pfc, fs_GlyphInfoType *pgoutDst, fs_GlyphInfoType *pgoutSrc);
VOID  vShiftOutlineInfo(FONTCONTEXT *pfc, BOOL b16Dot16, BYTE* ppoly, ULONG cjBuf );
ULONG SearchMortTable( FONTFILE *pff, ULONG  ig);
ULONG SearchGsubTable( FONTFILE *pff, ULONG  ig);
ULONG SearchDummyTable( FONTFILE *pff, ULONG ig);
BOOL  bCheckVerticalTable( PFONTFILE pff );

#if DBG
// #define DBCS_VERT_DEBUG
#define DEBUG_VERTICAL_XFORM              0x1
#define DEBUG_VERTICAL_CALL               0x2
#define DEBUG_VERTICAL_GLYPHDATA          0x4
#define DEBUG_VERTICAL_NOTIONALGLYPH      0x8
#define DEBUG_VERTICAL_BITMAPINFO        0x10
#define DEBUG_VERTICAL_DEVICERECT        0x20
#define DEBUG_VERTICAL_MAXGLYPH          0x40

extern ULONG DebugVertical;

VOID vDumpGlyphData( GLYPHDATA *pgldg );
#endif // DBG

VOID vCharacterCode (HGLYPH hg, fs_GlyphInputType *pgin);
BOOL bGetGlyphOutline(FONTCONTEXT*,HGLYPH, ULONG*, FLONG, FS_ENTRY*);
BOOL bIndexToWchar (PFONTFILE pff, PWCHAR pwc, uint16 usIndex, BOOL bVertical);

BOOL bComputeGlyphAttrBits(PTTC_FONTFILE pttc, PFONTFILE pff);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\fdsem.h ===
/******************************Module*Header*******************************\
* Module Name: fdsem.h
*
* declarations for the wrappers that serialize access to the rasterizer
*
* Created: 11-Apr-1992 19:37:49
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


// EXPORTED FUNCTIONS OF THE IFI INTERFACE


HFF
ttfdSemLoadFontFile (
    ULONG cFiles,
    ULONG_PTR *piFile,
    PVOID *ppvView,
    ULONG *pcjView,
    DESIGNVECTOR *pdv,
    ULONG ulLangId,
    ULONG ulFastCheckSum
    );

BOOL
ttfdSemUnloadFontFile (
    HFF hff
    );

LONG
ttfdSemQueryFontData (
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH   hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    );

VOID
ttfdSemFree (
    PVOID pv,
    ULONG_PTR id
    );

VOID
ttfdSemDestroyFont (
    FONTOBJ *pfo
    );

LONG
ttfdSemQueryTrueTypeOutline (
    DHPDEV     dhpdev,
    FONTOBJ   *pfo,
    HGLYPH     hglyph,
    BOOL       bMetricsOnly,
    GLYPHDATA *pgldt,
    ULONG      cjBuf,
    TTPOLYGONHEADER *ppoly
    );



BOOL
ttfdSemQueryAdvanceWidths (
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
    );


LONG
ttfdSemQueryTrueTypeTable (
    HFF     hff,
    ULONG   ulFont,  // always 1 for version 1.0 of tt
    ULONG   ulTag,   // tag identifying the tt table
    PTRDIFF dpStart, // offset into the table
    ULONG   cjBuf,   // size of the buffer to retrieve the table into
    PBYTE   pjBuf,   // ptr to buffer into which to return the data
    PBYTE  *ppjTable,
    ULONG  *pcjTable
    );

PFD_GLYPHATTR  ttfdSemQueryGlyphAttrs (FONTOBJ *pfo, ULONG iMode);

PVOID ttfdSemQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\service.c ===
/******************************Module*Header*******************************\
* Module Name: service.c
*
* set of service routines for converting between ascii and  unicode strings
*
* Created: 15-Nov-1990 11:38:31
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#include "fd.h"

/******************************Public*Routine******************************\
*
* vCpyBeToLeUnicodeString,
*
* convert (c - 1) WCHAR's in big endian format to little endian and
* put a terminating zero at the end of the dest string
*
* History:
*  11-Dec-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vCpyBeToLeUnicodeString(LPWSTR pwcLeDst, LPWSTR pwcBeSrc, ULONG c)
{
    LPWSTR pwcBeSrcEnd;

    ASSERTDD(c > 0, "vCpyBeToLeUnicodeString: c == 0\n");

    for
    (
        pwcBeSrcEnd = pwcBeSrc + (c - 1);
        pwcBeSrc < pwcBeSrcEnd;
        pwcBeSrc++, pwcLeDst++
    )
    {
        *pwcLeDst = BE_UINT16(pwcBeSrc);
    }
    *pwcLeDst = (WCHAR)(UCHAR)'\0';

}



/******************************Public*Routine******************************\
*
* VOID  vCvtMacToUnicode
*
* Effects:
*
* Warnings:
*
* History:
*  07-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID  vCvtMacToUnicode
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
const BYTE*  pjSrcMac,
ULONG  c
)
{
    const BYTE* pjSrcEnd;

//!!! I believe that LangId should be used to select the proper conversion
//!!! routine, this is a stub [bodind]

    ulLangId;

    for
    (
        pjSrcEnd = pjSrcMac + c;
        pjSrcMac < pjSrcEnd;
        pjSrcMac++, pwcLeDst++
    )
    {
        *pwcLeDst = (WCHAR)(*pjSrcMac);
    }
}

/******************************Public*Routine******************************\
*
* VOID  vCpyMacToLeUnicodeString
*
*
* Ensures that string is zero terminated so that other cool things can be
* done to it such as wcscpy, wcslen e.t.c.
*
* History:
*  13-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID  vCpyMacToLeUnicodeString
(
ULONG  ulLangId,
LPWSTR pwcLeDst,
const BYTE*  pjSrcMac,
ULONG  c
)
{
    ASSERTDD(c > 0, "vCpyMacToLeUnicodeString: c == 0\n");

    c -= 1;
    vCvtMacToUnicode (ulLangId, pwcLeDst, pjSrcMac, c);
    pwcLeDst[c] = (WCHAR)(UCHAR)'\0';
}


/**************************************************************************\
* The rest of the file is stolen from JeanP's win31 code in fd_mac.c
*
* Conversion routines from Mac character code and Mac langageID to
* Unicode character code and OS2 langage ID
*
* Public routines:
*   Unicode2Mac
*   Mac2Lang
*
\**************************************************************************/



/*
** Converts the OS2 langageID to the to the Mac langage ID
*/

static const uint16  aCvLang [32] =
{
   0,     //  0 -> 0  (0           -> english == default)
  12,     //  1 -> 12 (arabic      -> arabic)
   0,     //  2 -> 0  (bulgarian   -> english == default)
   0,     //  3 -> 0  (catalon     -> english == default)
   0,     //  4 -> 0  (Chinese     -> english == default)
   0,     //  5 -> 0  (Czeh        -> english == default)
   7,     //  6 -> 7  (Danish      -> Danish)
   2,     //  7 -> 2  (German      -> German)
  14,     //  8 -> 14 (Greek       -> Greek)
   0,     //  9 -> 0  (English     -> english)
   6,     //  a -> 6  (spanish     -> spanish)
  13,     //  b -> 13 (finnish     -> finnish)
   1,     //  c -> 1  (french      -> french)
  10,     //  d -> 10 (hebrew      -> hebrew)
   0,     //  e -> 0  (hungarian   -> english == default)
  15,     //  f -> 15 (icelandic   -> icelandic)
   3,     // 10 -> 3  (Italian     -> italian)
  11,     // 11 -> 11 (japanese    -> japanese)
  21,     // 12 -> 21 (korean      -> hindi, this seems to be a bug?????????)
   4,     // 13 -> 4  (dutch       -> dutch)
   9,     // 14 -> 9  (norweign    -> norweign)
   0,     // 15 -> 0  (Polish      -> english == default)
   8,     // 16 -> 8  (portugese   -> portugese)
   0,     // 17 -> 0  (rhaeto-romanic -> english == default)
   0,     // 18 -> 0  (romanian    -> english == default)
   0,     // 19 -> 0  (russian     -> english == default)
  18,     // 1a -> 18 (Yugoslavian -> Yugoslavian), lat or cyr ????
   0,     // 1b -> 0  (slovakian   -> english == default)
   0,     // 1c -> 0  (albanian    -> english == default)
   5,     // 1d -> 5  (swedish     -> swedish)
  22,     // 1e -> 22 (thai        -> thai)
  17      // 1f -> 17 (turkish     -> turkish)
};



/************************** Public Routine *****************************\
*  Mac2Lang
*
* Converts the OS2 langageID to the to the Mac langage ID
*
* History:
*  Fri Dec 08 11:28:35 1990    -by-    Jean-Francois Peyroux [jeanp]
* Wrote it.
\***********************************************************************/

uint16 ui16Mac2Lang (uint16 Id)
{
// this is just a way to bail out if an incorrect lang id is passed to
// this routine [bodind]
// Note that Id & 1f < 32 == sizeof(aCvLang)/sizeof(aCvLang[0]), no gp-fault

    return aCvLang[Id & 0x1f];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\vtfd\fd.h ===
/******************************Module*Header*******************************\
* Module Name: fd.h
*
* file which is going to be included by the most *.c files in this directory.
* Supplies basic types, debugging stuff, error logging and checking stuff,
* error codes, usefull macros etc.
*
* Copyright (c) 1990-1995 Microsoft Corporation
\**************************************************************************/
#define  SUPPORT_OEM
#define  IFI_PRIVATE

#include <stddef.h>
#include <stdarg.h>
#include <excpt.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>

typedef ULONG W32PID;

#include "mapfile.h"

#include "winres.h"
#include "service.h"     // string service routines
#include "fontfile.h"
#include "winfont.h"
#include "fondrv.h"

#define abs(x) max((x),-(x))


#if DBG

VOID
VtfdDebugPrint(
    PCHAR DebugMessage,
    ...
    );

#define RIP(x)        { VtfdDebugPrint(x); EngDebugBreak();}
#define ASSERTDD(x,y) { if (!(x)) { VtfdDebugPrint(y); EngDebugBreak();} }
#define WARNING(x)    VtfdDebugPrint(x)

#else

#define RIP(x)
#define ASSERTDD(x,y)
#define WARNING(x)

#endif

BOOL vtfdLoadFontFile (
        ULONG_PTR iFile, PVOID pvView, ULONG cjView, HFF *phff
    );

BOOL
vtfdUnloadFontFile (
    HFF hff
    );

LONG
vtfdQueryFontCaps (
    ULONG culCaps,
    PULONG pulCaps
    );

LONG
vtfdQueryFontFile (
        HFF     hff,
        ULONG   ulMode,
        ULONG   cjBuf,
        PULONG  pulBuf
        );

PIFIMETRICS
vtfdQueryFont (
        DHPDEV dhpdev,
        HFF    hff,
        ULONG  iFace,
        ULONG_PTR  *pid
        );

PVOID
vtfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR   *pid
    );

LONG vtfdQueryFontData
(
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
);

VOID vtfdDestroyFont(FONTOBJ *pfo);

HFC  vtfdOpenFontContext(FONTOBJ *pfo);

BOOL vtfdCloseFontContext(HFC hfc);

BOOL vtfdQueryAdvanceWidths
(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
);




extern HSEMAPHORE ghsemVTFD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\vdmx.c ===
/******************************Module*Header*******************************\
* Module Name: vdmx.c
*
* Created: 03-Oct-1991 10:58:34
* Author: Jean-francois Peyroux [jeanp]
*
*     Microsoft Confidential
*
*         Copyright (c) Microsoft Corporation 1989, 1991
*
*         All Rights Reserved
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/


#include "fd.h"
#include "winfont.h"

#define LINEAR_TRESHOLD 255


/******************************Public Routine*******************************
*
* BOOL   bSearchVdmxTable
*
* Description:
*
*   if em > 0
*       searches vdmx table for vA+vD == em. returns vA,vD (== em - vA), vEm
*   else // em < 0
*       searches vdmx table for vEm == em. returns vA,vD, vEm
*
* History:
*
*  Tue 21-Jul-1992 -by- Bodin Dresevic [BodinD]
* update: ported to NT
*   15 Nov 1991 -by-    Raymond E. Endres   [rayen]
* Added aspect ratio option and optimized the function.
*   3  Oct 1991 -by-    Jean-francois Peyroux   [jeanp]
* Wrote it.
**************************************************************************/

BOOL
bSearchVdmxTable (
    PBYTE     pjVdmx,
    ULONG     ResX,
    ULONG     ResY,
    INT       EM,     // NOT really EM, could be asc + desc wish in pixel units
    VTABLE    *pVTAB,  // out put structure
    PFONTCONTEXT pfc
    )
{
    USHORT    numRatios;        // VDMX_HDR.numRatios
    USHORT    numVtable;        // VDMX.recs, not VDMX_HDR.numRecs

    RATIOS   *pRatios;
    VDMX     *pVdmx;
    VTABLE   *pVtable;
    LONG      lRet, lRet2;
    UINT      i;
    BYTE      Abs_EM;
    ULONG   ulSizeVdmx = pfc->ptp->ateOpt[IT_OPT_VDMX].cj;
    ULONG offsetToTableStart;


// do not call us if pjVdmx is null

    ASSERTDD (pjVdmx != (PBYTE)NULL, "pjVdmx == NULL\n");

    if(!bValidRangeVDMXHeader(pjVdmx, ulSizeVdmx, &numRatios))
        return FALSE; 

// The following line is odd, but we keep it here for win31 compatibility.
// It is possible to have EM = +256, which corresponds to |ppem| < 256
// such that there is an entry for this -|ppem| in the table but
// yMax-yMin for this entry may be equal to 256. This in fact is the case
// with symbol.ttf font [bodind]

    if ((EM >= LINEAR_TRESHOLD) || (EM <= -LINEAR_TRESHOLD)) // assume EM > LINEAR_TRESHOLD scales linearly
        return FALSE;

// need to proceed to search vdmx table

    pRatios = (RATIOS  *) &((VDMX_HDR  *) pjVdmx)[1];

    for(i = 0; i < numRatios; i++)
    {
        if (pRatios[i].bCharSet == 1)
        {
        // must be Windows ANSI subset

            if (pRatios[i].xRatio == 0)
            {
                break;
            }           // auto match if 0
            else
            {                   // is it within aspect ratios
                lRet = ResY * pRatios[i].xRatio;
                lRet2= ResX * pRatios[i].yStartRatio;
                if (lRet >= lRet2)
                {
                    lRet2 = ResX * pRatios[i].yEndRatio;
                    if (lRet <= lRet2)
                        break;
                }
            }
        }
    }

    if (i == numRatios)  // did not find an aspect ratio match
        return FALSE;

// found an aspect ratio match

    offsetToTableStart = SWAPW(((USHORT  *) &pRatios[numRatios])[i]);
    pVdmx = (VDMX  *) (pjVdmx + offsetToTableStart); 

    if(  !bValidRangeVDMXRecord(ulSizeVdmx, offsetToTableStart) ){
        return FALSE;
    }    

    Abs_EM = (BYTE) (EM >=0 ? EM : - EM);

    if (EM > 0 || Abs_EM >= pVdmx->startsz && Abs_EM <= pVdmx->endsz)
    {
    // is there a Vtable for this EM

        pVtable = (VTABLE  *) &pVdmx[1];
        numVtable = SWAPW(pVdmx->recs);

        if(  !bValidRangeVDMXvTable(ulSizeVdmx, offsetToTableStart, numVtable) ){
            return FALSE;
        }    

        if (EM > 0)
        {
        // return the original yPelHeight

            for (i = 0; i < numVtable; i++)
            {
                pVTAB->yPelHeight = SWAPW(pVtable[i].yPelHeight);
                pVTAB->yMax       = SWAPW(pVtable[i].yMax);
                pVTAB->yMin       = SWAPW(pVtable[i].yMin);

            if ((pVTAB->yMax - pVTAB->yMin) == EM)
                {
                    return TRUE;
            }
            else if ((pVTAB->yMax - pVTAB->yMin) > EM)
                {
                    return FALSE;
            }
            }
        }
        else // return the actual em height in pixels
        {
            for (i = 0; i < numVtable; i++)
            {
                pVTAB->yPelHeight = SWAPW(pVtable[i].yPelHeight);
                pVTAB->yMax       = SWAPW(pVtable[i].yMax);
                pVTAB->yMin       = SWAPW(pVtable[i].yMin);

            if ((INT)pVTAB->yPelHeight == -EM)
                {
                    return TRUE;
            }
            else if ((INT)pVTAB->yPelHeight > -EM)
                {
                    return FALSE;
            }
            }
        }
    }
    return FALSE;
}

#ifdef THIS_IS_COMMENTED_PSEUDOCODE

// BASED ON THE DISCUSSION OF KIRKO, BODIND AND GILMANW WITH GUNTERZ

|INPUT:  hWish = wish height in pixel units
|
|OUTPUT: ascender, descender, ppem (all in pixel units) (dA,dD,dEm)
|
|
|    NOTATION:
|
|        dA = ascender in device/pixel space
|        nA = ascender in notional space
|        vA = ascender in vdmx table
|
|        dD = descender in device/pixel space
|        nD = descender in notional space
|        vD = descender in vdmx table
|
|        dEm = pixels per em in device space
|        nEm = em height in notional space
|        vEm = pixels per em in vdmx table
|
|
|LOCALS
|
|    LONG hTrial
|    LONG hEqualOrBelow
|    BOOL wasAbove
|    BOOL wasBelow
|
|PROCEDURE
|{
|    if (hWish < 0) then
|    {
|        <look in the vdmx and look for a vEm that matches -hWish>;
|        if (a match is found) then
|        {
|            dA = vA;
|            dD = vD;
|        }
|        else
|        {
|        //
|        // No Match is found in vdmx table, assume linear scaling
|        //
|            dA = round(nA * (-hWish) / nEm);
|            dD = round(nD * (-hWish) / nEm);
|        }
|        ppEm = -hWish;
|        return;
|    }
|
|//
|// hWish > 0
|//
|    <search the vdmx table for (vA + vD) that matches hWish>;
|    if (a match is found)
|    {
|        dA  = vA;
|        dCs = vD;
|        dEm = vEm;
|        return;
|    }
|
|//
|// Note, that from this point forward vA + vD never equals hWish
|// otherwise we would have found it in the step above
|//
|    ppemTrial = round(nEm * hWish / (nA + nD));
|
|    wasAbove = FALSE;
|    wasBelow = FALSE;
|
|    while (TRUE)
|    {
|        <search the vdmx table for vEm that matches ppemTrial>;
|        if (a match is found)
|        {
|            hTrial = vA + vD;
|        //
|        // This can't equal hWish (see above) so don't bother
|        // checking
|        }
|        else
|        {
|            hTrial = round(ppemTrial * (nA + nD) / nEm);
|            if (hTrial == hWish)
|            {
|                hEqualOrBelow = hTrial;
|                break;
|            }
|        }
|
|        if (hTrial < hWish)
|        {
|            hEqualOrBelow = hTrial;
|            if (wasAbove)
|                break;
|            ppemTrial = ppemTrial + 1;
|            wasBelow  = TRUE;
|        }
|        else
|        {
|            ppemTrial = ppemTrial - 1;   // <==== NEW POSITION
|            if (wasBelow)
|                break;
|                                         // <==== OLD POSITION
|            wasAbove = TRUE
|        }
|    }
|    dA  = round(ppemTrial * nA / nEm);
|    dD  = hEqualOrBelow - dA;
|    dEm = ppemTrial;
|    return;
|}.
|

#endif // THIS_IS_COMMENTED_PSEUDOCODE


/******************************Public*Routine******************************\
*
* VOID vQuantizeXform
*
* Effects: quantize the xform according to win31 recipe. as side effects
*          this routine may compute ascender and descener in device space
*          from vdmx table as well as number of pixels per M in device space.
*
* History:
*  25-Jul-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vQuantizeXform (
    PFONTCONTEXT pfc
    )
{
    BYTE  *pjView =  (BYTE *)pfc->pff->pvView;
    Fixed  fxMyy = pfc->mx.transform[1][1];
    PBYTE  pjVdmx  = (pfc->ptp->ateOpt[IT_OPT_VDMX].dp)          ?
                     (pjView + pfc->ptp->ateOpt[IT_OPT_VDMX].dp) :
                     NULL                                        ;

    LONG   hWish;
    VTABLE vtb, vtbPrev;

    LONG   ppemTrial, hTrial, yEmN, yHeightN;

    BOOL   bWasAbove, bWasBelow, bFound, bFoundPrev;

    UINT   numIterations;

    sfnt_FontHeader * phead =
                      (sfnt_FontHeader *)(pjView + pfc->ptp->ateReq[IT_REQ_HEAD].dp);
    BYTE * pjOS2 = (pfc->ptp->ateOpt[IT_OPT_OS2].dp)         ?
                   (pjView + pfc->ptp->ateOpt[IT_OPT_OS2].dp):
                   NULL                                      ;

    yEmN = pfc->pff->ifi.fwdUnitsPerEm;

    if (!((pfc->flXform & XFORM_HORIZ) && (fxMyy > 0) && (pjVdmx != (PBYTE)NULL)))
    {
    // nothing to do, just return.

        return;
    }

// compute hWish in pixel coords. This is lfHeight from the logfont, except
// that it has been transformed to device pixel units and the sign is preserved

    if (pfc->flFontType & FO_EM_HEIGHT)
    {
        hWish = FixMul(fxMyy, -yEmN);
    }
    else // use tmp variable
    {
        yHeightN = pfc->pff->ifi.fwdWinAscender + pfc->pff->ifi.fwdWinDescender;
        hWish = FixMul(fxMyy, yHeightN);
    }

// quick out, all bSearchVdmxTable routines will fail if hWish is too big:


    if (bSearchVdmxTable(pjVdmx,
                         pfc->sizLogResPpi.cx,
                         pfc->sizLogResPpi.cy,
                         hWish,
                         &vtb,
                         pfc)
    )
    {
        pfc->yMax = - vtb.yMin;
        pfc->yMin = - vtb.yMax;
        pfc->lEmHtDev = vtb.yPelHeight;

    // flag that dA and dD have been computed, do not scale linerly:

        pfc->flXform |= XFORM_VDMXEXTENTS;
    }
    else
    {
    // dA and dD will have to be computed using linear scaling
    // after the xform is quantized using win31 hacked recipe
    // get the notional space values which are needed for scaling

    // get the notional space values

        if (pjOS2)
        {
        // win 31 compatibility: we only take the max over win 31 char set:
        // all the glyphs outside this set, if they stand out will get chopped
        // off to match the height of the win31 char subset:

            yHeightN = BE_INT16(pjOS2 + OFF_OS2_usWinDescent) +
                       BE_INT16(pjOS2 + OFF_OS2_usWinAscent);
        }
        else
        {
            yHeightN = BE_INT16(&phead->yMax) - BE_INT16(&phead->yMin);
        }

        if (hWish < 0)
        {
            pfc->lEmHtDev = -hWish;
        }
        else // hWish > 0
        {
        // Note, that from this point forward vA + vD never equals hWish
        // otherwise we would have found it in the step above. This claim
        // is WRONG for only one reason. suppose hWish is 256. bSearchVdmxTable
        // will return FALSE because of the early exit test |EM| <= LINEAR_TRESHOLD
        // at the begininig of the routine. We have to keep this test in the
        // code for compatibility reasons. Now it is possible to have
        // ppemTrial <= LINEAR_TRESHOLD, so that bSearchVdmxTable will not hit the
        // early exit, and such that there exists an entry in the vdmx table
        // for this -ppemTrial, but with yMax-yMin == 256 == hWish.

            // ppemTrial = F16_16TOLROUND(yEmN * fxMyy);
            ppemTrial = FixMul(fxMyy, yEmN);

            bWasAbove  = FALSE;
            bWasBelow  = FALSE;
            bFound     = FALSE;
            bFoundPrev = FALSE; // save the value from the prev. loop

        // init the strucs

            vtb.yMin       = 0;
            vtb.yMax       = 0;
            vtb.yPelHeight = 0;
            vtbPrev        = vtb;

            // security code review, I could not convince myself that this legacy code
            // would never loop around with an unexpected buggy font
            // adding a max iteration check to be sure
            // VDMX tables contain pixel sizes stored in a byte (value 0-255)
            // if we are looping through the iterations more than 256, something is really wrong
            #define MAX_ITERATIONS 256

            for (numIterations = 0 ;numIterations < MAX_ITERATIONS; numIterations++, bFoundPrev = bFound, vtbPrev = vtb)
            {
            // search the vdmx table for vEm that matches ppemTrial

                if
                (
                    bFound = bSearchVdmxTable(
                                     pjVdmx,
                                     pfc->sizLogResPpi.cx,
                                     pfc->sizLogResPpi.cy,
                                     -ppemTrial,
                                     &vtb,
                                     pfc)
                )
                {
                    hTrial = vtb.yMax - vtb.yMin;
                //
                // This can't equal hWish (see above) so don't bother
                // checking? WRONG!!! see teh comment above.

                    if (hTrial == hWish)
                    {
                    // This assert would be correct if it were not
                    // for occasional bugs in vdmx tables.
                    // In the case of Bell MT Regular, vA+vD = 0x13 for
                    // lEmHt = 0x0f which is STRICTLY bigger than
                    // vA+vD = 0x12 for lEmHt = 0x10 which is absurd.
                    // For this reason the first
                    // bSearchVdmxTable(EM = 0X12) fails to find an entry
                    // while the second bSearchVdmxTable(EM =- 0X10)
                    // DOES FIND an entry
                    // in vdmx table such that vA+vD=0x12, generating
                    // the commented assertion to bark. That is why we converted
                    // assertion to just print out a warning message.


                    #if DBG

                        // ASSERTGDI(hWish > LINEAR_TRESHOLD, "TTFD! hWish <= LINEAR_TRESHOLD\n");

                        if (hWish <= LINEAR_TRESHOLD)
                            TtfdDbgPrint("TTFD! hWish <= LINEAR_TRESHOLD\n");

                    #endif

                    /*   Bell MT Table:

    pVtable  -->    f800 ff08       //  F8 entries = numVtable,
                                    //  startsz = 8, endsz = ff
                    0800 0800 feff
                    0900 0900 feff
                    0a00 0900 fdff
                    0b00 0a00 fdff
                    0c00 0c00 fdff
                    0d00 0c00 fdff
                    0e00 0d00 fcff
                    0f00 0e00 fbff  <- yMax-yMin = 14-(-5) = 19 == 0X13
                    1000 0e00 fcff  <- yMax-yMin = 14-(-4) = 18 // problem
                    1100 0f00 fbff
                    1200 1100 fbff
                    1300 1100 fbff
                    ..............

                    */

                        pfc->yMax = - vtb.yMin;
                        pfc->yMin = - vtb.yMax;
                        pfc->lEmHtDev = vtb.yPelHeight;

                    // flag that dA and dD have been computed, do not scale linerly:

                        pfc->flXform |= XFORM_VDMXEXTENTS;
                        break;
                    }
                }
                else
                {
                    hTrial = LongMulDiv(ppemTrial, yHeightN, yEmN);

                    if (hTrial == hWish)
                    {
                        // hEqualOrBelow = hTrial;
                        break;
                    }
                }

                if (hTrial < hWish)
                {
                    // hEqualOrBelow = hTrial;
                    if (bWasAbove)
                    {
                        if (bFound) // just found this hTrial in the search above
                        {
                            pfc->yMax = - vtb.yMin;
                            pfc->yMin = - vtb.yMax;

                        // flag that dA and dD have been computed, do not scale linerly:

                            pfc->flXform |= XFORM_VDMXEXTENTS;
                        }
                        break;
                    }
                    ppemTrial = ppemTrial + 1;
                    bWasBelow  = TRUE;
                }
                else
                {
                    ppemTrial = ppemTrial - 1;   // <==== NEW POSITION
                    if (bWasBelow)
                    {
                        if (bFoundPrev) // just found this hTrial in the search above
                        {
                            ASSERTDD (ppemTrial == vtbPrev.yPelHeight,
                                      "vdmx logic screwed up");

                            pfc->yMax = - vtbPrev.yMin;
                            pfc->yMin = - vtbPrev.yMax;

                        // flag that dA and dD have been computed, do not scale linerly:

                            pfc->flXform |= XFORM_VDMXEXTENTS;
                        }
                        break;
                    }
                                             // <==== OLD POSITION
                    bWasAbove = TRUE;
                }
            } // for loop
            if (numIterations >= MAX_ITERATIONS)
            {
                 RIP("TTFD:vQuantizeXform bogus font cause a lot of iterations\n");
                 return;
            }
            pfc->lEmHtDev = ppemTrial;
        }
    }

// the following line means quantizing:

    pfc->mx.transform[1][1] = FixDiv(pfc->lEmHtDev, yEmN);

// now fix xx component accordingly: xxNew = xxOld * (yyNew/yyOld)

// we do one final tweak with the transform here:
// If the difference between
// horizontal and vertical scaling is so small that the resulting
// avg font width is the same if we replace x scaling by y scaling
// than we will do it, which will result in diag transform and we will
// be able to use hdmx tables for this realization. By doing so
// we ensure that we get the same realization when we enumerate font
// and then use the logfont returned from enumeration to realize this font
// again.

    if
    (
        (pfc->mx.transform[0][0] == fxMyy) ||
        (FixMul(pfc->mx.transform[0][0] - pfc->mx.transform[1][1],
                (Fixed)pfc->pff->ifi.fwdAveCharWidth) == 0)
    )
    {
        pfc->mx.transform[0][0] = pfc->mx.transform[1][1];
    }
    else
    {
        pfc->mx.transform[0][0] = LongMulDiv(
                                      pfc->mx.transform[0][0],
                                      pfc->mx.transform[1][1],
                                      fxMyy
                                      );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\vertical.c ===
/******************************Module*Header*******************************\
* Module Name: vertical.c                                                  *
*                                                                          *
* vertical writing (@face) support functions                               *
* whole file should be #ifdef-ed with DBCS_VERT                            *
*                                                                          *
* Created: 18-Mar-1993 11:55:38                                            *
* Author: Takao Kitano [TakaoK]                                            *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"
//#include "fontfile.h"
//#include "cvt.h"
//#include "limits.h"
//#include "winnls.h"


#ifdef DBCS_VERT_DEBUG
     ULONG DebugVertical = 0x0;

#endif

/******************************Public*Routine******************************\
*
* bCheckVerticalTable()
*
* History:
*  12-Apr-1995 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

BOOL bCheckVerticalTable(
 PFONTFILE pff
 )
{

// Get vertical metrics information if this font has it.  Don't use the
// the vertical metrics table for a fixed pitch DBCS font because
// a) we don't need it and
// b) embeded bitmaps for these fonts can't be layed
//    out using the vertical metrics table.

// !!! for NT 5.0 we need to elminate the hacks for embeded bitmaps
// (such as gulim fix) and do something to detect when we are using
// embeded bitmaps and use the appropriate tables, etc to compute metrics
// and the like. [gerritv]

    if(pff->ffca.tp.ateOpt[IT_OPT_VHEA].dp != 0 && bValidRangeVHEA(pff->ffca.tp.ateOpt[IT_OPT_VHEA].cj) &&
       pff->ffca.tp.ateOpt[IT_OPT_VMTX].dp != 0 )
    {
        sfnt_vheaTable *pvheaTable;

        pvheaTable = (sfnt_vheaTable *)((BYTE *)(pff->pvView) +
                                       pff->ffca.tp.ateOpt[IT_OPT_VHEA].dp);
        pff->ffca.uLongVerticalMetrics = (uint16) SWAPW(pvheaTable->numOfLongVerMetrics);
    }
    else
    {
        pff->ffca.uLongVerticalMetrics = 0;
    }


    //
    // Is GSUB table present ?
    //
    if( pff->ffca.tp.ateOpt[ IT_OPT_GSUB ].dp != 0 && bValidRangeGSUB(pff, &pff->ffca.ulVerticalTableOffset))
    {
        pff->hgSearchVerticalGlyph = SearchGsubTable;
        return(TRUE);
    }

    else if( pff->ffca.tp.ateOpt[ IT_OPT_MORT ].dp != 0 && bValidRangeMORT(pff))
    {
        pff->ffca.ulVerticalTableOffset = pff->ffca.tp.ateOpt[ IT_OPT_MORT ].dp;
        pff->hgSearchVerticalGlyph = SearchMortTable;
        return(TRUE);
    }
     else
    {
        //
        // Set dummy..
        //
        pff->ffca.ulVerticalTableOffset = 0;
        pff->hgSearchVerticalGlyph = SearchDummyTable;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* SearchDummyTable()
*
* History:
*  14-Jan-1996 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

ULONG SearchDummyTable(
 FONTFILE   *pff,
 ULONG      ig              // glyph index
 )
{
    return ig;
}

/******************************Public*Routine******************************\
*
* SearhVerticalGlyphIndex( FONTCONTEXT *pfc, ULONG ig )
*
* If there is glyph index for the vertical shape, returns
* the glyph index of vertical shape, else returns same
* glyph index as specified.
*
* History:
*  04-Apr-1993 -by- Takao Kitano [TakaoK]
* Wrote it.
\**************************************************************************/

ULONG SearchMortTable(
 FONTFILE   *pff,
 ULONG      ig              // glyph index
 )
{
    MortTable      *pMortTable;
    BinSrchHeader  *pHeader;
    LookupSingle   *pLookup;
    USHORT         n;

    pMortTable = (MortTable *)((BYTE *)(pff->pvView) +
                                       (pff->ffca.ulVerticalTableOffset));

    #if DBG
    if ( pMortTable == NULL )
    {
        WARNING("TTFD!pMortTable == NULL\n");
        return ig;
    }
    #endif

    pHeader = &pMortTable->SearchHeader;

//
// If you have time, you may want to change the loop from the straight search
// to the binary search. Currently kanji truetype font has about 110 entries
// for alternative glyphs. [takaok]
//
    for ( pLookup = &pMortTable->entries[0], n = BE_UINT16(&pHeader->nEntries);
            n > 0;
            n--, pLookup++
        )
    {
        if ( ig == (ULONG)BE_UINT16( &pLookup->glyphid1 ) )
            return ( BE_UINT16( &pLookup->glyphid2 ) );
    }
    return ( ig );
}

/******************************Public*Routine******************************\
*
* SearchGsubTable()
*
* History:
*  12-Apr-1995 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

ULONG SearchGsubTable(
 FONTFILE    *pff,
 ULONG       ig              // glyph index
 )
{
    SingleSubst *pSingleSubst;

    pSingleSubst = (SingleSubst *)((BYTE *)(pff->pvView) +
                                           (pff->ffca.ulVerticalTableOffset));

    //
    // Check subtable format...
    //

    if( BE_UINT16(&pSingleSubst->SubstFormat) == 2 )
    {
        Coverage *pCoverage;

        pCoverage = (Coverage *)
                     ((BYTE *)pSingleSubst +
                      BE_UINT16(&(pSingleSubst->Format.Type2.Coverage)));

        //
        // Check Coverage format...
        //

        if( BE_UINT16(&pCoverage->CoverageFormat) == 1 )
        {
            USHORT  ii;
            GlyphID *pGlyphArray;
            GlyphID *pGlyphSubstArray;

            pGlyphArray = pCoverage->Format.Type1.GlyphArray;
            pGlyphSubstArray = pSingleSubst->Format.Type2.Substitute;

            for( ii = 0;
                    ii < BE_UINT16(&(pCoverage->Format.Type1.GlyphCount)) ;
                    ii ++ )
            {
                if( ig == (ULONG)BE_UINT16(&(pGlyphArray[ii])) )
                    return( (ULONG)BE_UINT16(&(pGlyphSubstArray[ii])) );
            }
        }
         else
        {
            WARNING("TTFD:Unsupported CoverageFormat\n");
        }
    }
     else
    {
        WARNING("TTFD:Unsupported SubstFormat\n");
    }

    return(ig);
}

/******************************Public*Routine******************************\
*
* vCalcXformVertical
*
* Right now, we assume all the width of glyphs that need to be rotated
* for @face are same. ( I mean all kanji character has same width. )
* So a single transformation is applied to all rotated glyphs.
*
* Before the final release, we need to change this scheme. We will
* check the advanceWidth in notional space ( please refer to
* vGetNotionalGlyphMetrics ). If the advanceWidth of specified
* glyph is different than the maxCharInc, we will compute the
* transformation matrix dynamically. [takaok]
*
* History:
*  19-Mar-1993 -by- Takao Kitano [TakaoK]
* Wrote it.
\**************************************************************************/

VOID vCalcXformVertical(FONTCONTEXT  *pfc)
{
    LONG lAscender, lDescender;

    lAscender  = (LONG)pfc->pff->ifi.fwdTypoAscender;
    lDescender = (LONG)pfc->pff->ifi.fwdTypoDescender;


#ifdef DBCS_VERT_DEBUG
    if ( DebugVertical & DEBUG_VERTICAL_CALL )
    {
        TtfdDbgPrint("TTFD!bGetNotionalHeightAndWidth(Ascent=%ld, Descent=%ld )\n",
                 lAscender, lDescender);
    }
#endif

// old comment, here just for historic reasons [bodind]
//
// [ 90 degree rotation ]
//
// In the truetype rasterizer, 90 degree rotation matrix looks like this:
//
//   A
//  Y|             [  cos90  sin90 ]   [ 0   1 ]
//   |             [               ] = [       ]
//   |      X      [ -sin90  cos90 ]   [ -1  0 ]
//   +------->
//
// [ X-Y scaling ]
//
// We don't want to change the character box shape after the rotation.
//
//   [ h/w   0  ]   where  w: notional space width = IFIMETRICS.aveCharWidth
//   [          ]
//   [  0   w/h ]          h: notional space height = IFIMETRICS.Ascender +
//                                                    IFIMETRICS.Descender
//
// We are multiplying the scaling matrix from the left because the
// scaling matrix acts first on the notinal space vectors on the left
//
//  ((x,y)*A)*B = (x,y)*(A*B)
//
//  [ h/w   0  ]   [  0   1 ]   [  0    h/w ]
//  [          ] * [        ] = [           ]
//  [  0   w/h ]   [ -1   0 ]   [ -w/h   0  ] ... this is it! [rotation] * [scaling] matrix
//
// We are multiplying from the left because the [ scaling * rotation ] matrix
// acts first on the notional space vectors on the left
//
//  [ 0      h/w ]   [ m00  m01 ]   [   m10 * h / w        m11 * h / w  ]
//  [            ] * [          ] = [                                   ]
//  [-w/h     0  ]   [ m10  m11 ]   [  -m00 * w / h       -m01 * w / h  ]
//
// old comment, end

// old comment, here just for historic reasons [bodind]
//
// compute shift parameters in device space
// coordinate system is truetype coordinate.
//
// At early stage of development, I put the following shift
// information into the matrix passed to the scaler.
// However I don't know why but the scaler just ignores
// the X and Y shift values. In windows 3.1J, they
// changes the scaler interface ( fs_xxx ) and give the scaler
// X and Y shift information. For NT-J, I don't want to change
// the scaler interface. Following shift values are applied
// after we got bitmap information from scaler. [takaok]
//
// old comment, end


// new comment:
// When we rotate dbcs characters we do not want to deform them,
// we want to leave the natural aspect ratio of these glyphs.
// For vertical writing the base line for dbcs glyphs that need to be rotated
// goes through the middle of the glyphs, for sbcs characters stays the same.
// Shift vector computed below does this job. Also, for older fixed pitch fe
// fonts, where dbcs glyphs have the w == h and sbcs glyphs have width = w/2 for
// dbcs and height the same for as for dbcs, these formulas become the old
// formulas we used to have.

    pfc->mxv.transform[0][0] =  pfc->mxn.transform[1][0];
    pfc->mxv.transform[0][1] =  pfc->mxn.transform[1][1];
    pfc->mxv.transform[1][0] =  -pfc->mxn.transform[0][0];
    pfc->mxv.transform[1][1] =  -pfc->mxn.transform[0][1];

// ClaudeBe, from the client interface Doc :
// Please note that although the third column of the matrix is defined as Fixed numbers 
// you will actually need to use  Fract numbers in that column. The higher resolution provided 
// by Fracts is required to change the perspective of a glyph. Fracts are 2.30 fixed point numbers.

    pfc->mxv.transform[2][2] = ONEFRAC;
    pfc->mxv.transform[0][2] = (Fixed)0;
    pfc->mxv.transform[1][2] = (Fixed)0;
    pfc->mxv.transform[2][0] = (Fixed)0;
    pfc->mxv.transform[2][1] = (Fixed)0;

    {
        Fixed lX;
        Fixed lY;

    // shift value in notional space
    // We will position dbcs glyphs so that the centers of dbcs glyphs
    // are aligned with the mid line going through Height of sbcs glyphs.
    // fxdevShift computation below does exactly that. [bodind]

        lX = LTOF16_16(lAscender);
        lY = LTOF16_16(lDescender);
    // shift value in device space

        pfc->fxdevShiftX = FixMul(pfc->mx.transform[0][0], lX) +
                           FixMul(pfc->mx.transform[1][0], lY);
        pfc->fxdevShiftY = FixMul(pfc->mx.transform[0][1], lX) +
                           FixMul(pfc->mx.transform[1][1], lY);
    }

#ifdef DBCS_VERT_DEBUG
    if ( DebugVertical & DEBUG_VERTICAL_XFORM )
    {
        TtfdDbgPrint("vCalcXformVertical pfc->mx00 =0x%lx, 11=0x%lx, 01=0x%lx, 10=0x%lx \n",
                  pfc->mx.transform[0][0],
                  pfc->mx.transform[1][1],
                  pfc->mx.transform[0][1],
                  pfc->mx.transform[1][0] );
        TtfdDbgPrint("vCalcXformVertical mxn:00=0x%lx, 11=0x%lx, 01=0x%lx, 10=0x%lx \n",
                  pfc->mxn.transform[0][0],
                  pfc->mxn.transform[1][1],
                  pfc->mxn.transform[0][1],
                  pfc->mxn.transform[1][0] );
        TtfdDbgPrint("                  mxv:00=0x%lx, 11=0x%lx, 01=0x%lx, 10=0x%lx \n",
                  pfc->mxv.transform[0][0],
                  pfc->mxv.transform[1][1],
                  pfc->mxv.transform[0][1],
                  pfc->mxv.transform[1][0] );
        TtfdDbgPrint("                   devShiftX=%ld, devShiftY=%ld \n",
                  F16_16TOLROUND(pfc->fxdevShiftX),F16_16TOLROUND(pfc->fxdevShiftY));
    }
#endif
}

/******************************Public*Routine******************************\
*
* BOOL IsFullWidth( WCHAR wc)
*
* Returns TRUE if specified unicode codepoint is corresponding to
* double byte character in multibyte codepage.
*
* History:
*  10-Nov-1995 Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

typedef struct _VERTICAL_UNICODE {
    WCHAR Start;
    WCHAR End;
} VERTICAL_UNICODE, *PVERTICAL_UNICODE;

#define NUM_VERTICAL_UNICODES  (sizeof(VerticalUnicodes)/sizeof(VerticalUnicodes[0]))

// A sorted range from the specification
// But this range will not be the optimized
// So just for the reference
/*
VERTICAL_UNICODE VerticalUnicodes[] = {
    { 0x1100, 0x11f9 },     // Hangul Jamo
    { 0x2010, 0x206f },     // General Punctuation, 
    { 0x2100, 0x2138 },     // Letterlike Symbols 
    { 0x2460, 0x24EA },     // Enclosed Alphanumerics
    { 0x25A0, 0x25EF },     // Geometric Shapes
    { 0x2600, 0x266F },     // Miscellaneious Symbols 
    { 0x2700, 0x27BE },     // Dingbats 
    { 0x3001, 0x303f },     // CJK Symbols and Punctuation 
    { 0x3040, 0x309F },     // HIRAGANA
    { 0x30A0, 0x30FF },     // KATAKANA
    { 0x3105, 0x312c },     // Bopomofo
    { 0x3131, 0x318e },     // Hangul Compatibility Jamo         
    { 0x3190, 0x319f },     // Kanbun (CJK Miscellaneous) 
    { 0x3200, 0x32ff },     // Enclosed CJK Letters & Months 
    { 0x3300, 0x33ff },     // CJK Compatibility, 
    { 0x3400, 0x4Dff },     // ExtA range
    { 0x4E00, 0x9FFF },     // CJK_UNIFIED_IDOGRAPHS
    { 0xAC00, 0xD7A3 },     // HANGUL
    { 0xe000, 0xf8ff },     // Private Use Area (PUA)
    { 0xf900, 0xfaff },     // CJK Compatibility Ideographs
    { 0xfe30, 0xfe4f },     // CJK Compatibility forms 
    { 0xff01, 0xff5e },     // Halfwidth  
                            // Note: halfwidth Katakana and hangul are not included. 
    { 0xffe0, 0xffee }      // Fullwidth forms 

};
*/


// Most frequent used rang
VERTICAL_UNICODE VerticalUnicodes[] = {
    { 0x1100, 0x11ff },     // Hangul Jamo
    { 0x2000, 0x206f },     // General Punctuation, 
    { 0x2100, 0x214f },     // Letterlike Symbols 
    { 0x2460, 0x24ff },     // Enclosed Alphanumerics
//    { 0x25A0, 0x25FF },     // Geometric Shapes
//    { 0x2600, 0x26FF },     // Miscellaneious Symbols 
    { 0x25A0, 0x27FF },      // Dingbats 
//    { 0x3001, 0x303f },     // CJK Symbols and Punctuation 
//    { 0x3040, 0x309F },     // HIRAGANA
//    { 0x30A0, 0x30FF },     // KATAKANA
//    { 0x3100, 0x312f },     // Bopomofo
//    { 0x3130, 0x318f },     // Hangul Compatibility Jamo         
//    { 0x3190, 0x319f },     // Kanbun (CJK Miscellaneous) 
    { 0x3001, 0x319F },     // KATA merged with the above 3 items
//    { 0x3200, 0x32ff },     // Enclosed CJK Letters & Months 
//    { 0x3300, 0x33ff },     // CJK Compatibility, 
//    { 0x3400, 0x4Dff },     // ExtA range
    { 0x3200, 0x4Dff },     // Merge above 3 sub-range
    { 0x4E00, 0x9FFF },     // CJK_UNIFIED_IDOGRAPHS
    { 0xAC00, 0xD7A3 },     // HANGUL
//    { 0xe000, 0xf8ff },     // Private Use Area (PUA)
//    { 0xf900, 0xfaff },     // CJK Compatibility Ideographs
    { 0xe000, 0xfaff },     // Merged with the above 2 items
    { 0xfe30, 0xfe4f },     // CJK Compatibility forms 
    { 0xff01, 0xff5e },     // Halfwidth  
                            // Note: halfwidth Katakana and hangul are not included. 
    { 0xffe0, 0xffee }      // Fullwidth forms 
};


BYTE glyphBits[8] = {0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};

BOOL IsLocalDbcsCharacter(ULONG uiFontCodePage, WCHAR wc)
{
    INT             index;
    int             cwc;
    char            ach[2];

    // Error handling in case, we do not have enough memory to allocate.
    // Then we will process through the old code.

    if ((wc >= VerticalUnicodes[0].Start) && (wc <= VerticalUnicodes[NUM_VERTICAL_UNICODES - 1].End))
    {
        for (index = 0; index < NUM_VERTICAL_UNICODES; index++)
        {
            if ((wc >= VerticalUnicodes[index].Start) &&
                 (wc <= VerticalUnicodes[index].End)      )
            {
                return (TRUE);
            }
        }
    }

    // if this Unicode character is mapped to Double-Byte character,
    // this is also full-width character..

    cwc = EngWideCharToMultiByte(uiFontCodePage,&wc,sizeof(WCHAR),ach,2);

    return( cwc > 1 ? TRUE : FALSE );

}

BOOL IsFullWidthCharacter(FONTFILE *pff, HGLYPH hg)
{
    ASSERTDD(pff->pttc->pga, "pga must not be NULL\n");

    // The glyph index could be invalid in some fonts
    if (hg < pff->pttc->pga->cGlyphs)
    {
        return(pff->pttc->pga->aGlyphAttr[hg / 8] & (glyphBits[hg % 8]));
    }
    else
    {
        return FALSE;
    }
}


/******************************Public*Routine******************************\
*
* BOOL bComputeGlyphAttrBits(PTTC_FONTFILE pttc, PFONTFILE pff)
*
* Make a bit array, when each bit is on, it indicate the glyph no need to rotate
*                                    off, the glyph is DBCS and need to ratate       
* 
* History:
*  5-28-1998 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

BOOL bComputeGlyphAttrBits(PTTC_FONTFILE pttc, PFONTFILE pff)
{
    PIFIMETRICS     pifi;
    IFIEXTRA        *pifiex;
    PFONTFILE       pffTmp;
    PFD_GLYPHATTR   pga;
    PWCRUN          pwcruns, pwcrunsEnd;
    PHGLYPH         phg;
    WCHAR           wcLow, wcHigh;
    PFD_GLYPHSET    pgset;
    ULONG           cj;
    ULONG           i;

    ASSERTDD(!pttc->pga, "error calling bComputeGlyphAttrBits\n");

    pffTmp = PFF(pttc->ahffEntry[0].hff);

    pifi = (PIFIMETRICS) &pffTmp->ifi;
    pifiex = (IFIEXTRA *)(pifi + 1);

    cj = offsetof(FD_GLYPHATTR,aGlyphAttr) + ((pifiex->cig + 7) / 8);

    pga = PV_ALLOC(cj);

// Alloc memory failed, need to return faliure

    if (!pga)
        return FALSE;

// first set all the bits to 0

    RtlZeroMemory((PVOID)pga, cj);

// Alloc the total glyph bits

    pga->cjThis = cj;
    pga->cGlyphs = pifiex->cig;
    pga->iMode = FO_ATTR_MODE_ROTATE;

    for( i = 0; i < pttc->ulNumEntry; i++ )
    {

    // go only through horizontal faces, the bits for the glyphs in the @faces will be set
    // by looking into substitution tables.

        if (pttc->ahffEntry[i].iFace == 1)
        {
            BOOL        bVertical = FALSE;
            PWCRUN      pwcrunsv = NULL;
            PHGLYPH     phgv = NULL;

            pffTmp = PFF(pttc->ahffEntry[i].hff);
            pgset = pffTmp->pgset;
            pwcruns = &pffTmp->pgset->awcrun[0];
            pwcrunsEnd = pwcruns + pgset->cRuns;

            if (pffTmp->pgsetv)
            {
                pwcrunsv = &pffTmp->pgsetv->awcrun[0];
                bVertical = TRUE;
            }

            while ((pwcruns < pwcrunsEnd))
            {
                wcLow = pwcruns->wcLow;
                wcHigh = pwcruns->wcLow + pwcruns->cGlyphs - 1;
                phg = pwcruns->phg;

                if (bVertical)
                    phgv = pwcrunsv->phg;

                if (wcLow < 0xffff)
                {
                    while (wcLow <= wcHigh)
                    {
                        if (IsLocalDbcsCharacter(pff->ffca.uiFontCodePage, wcLow))
                        {
                            // Buggy font might break it, so we need to guard it.
                            if( *phg < pga->cGlyphs)
                            {
                                pga->aGlyphAttr[*phg / 8] |= glyphBits[*phg % 8];

                                // we can optimize this part of code
                                if ( bVertical && (*phg != *phgv) && (*phgv < pga->cGlyphs))
                                {
                                    pga->aGlyphAttr[*phgv / 8] |= glyphBits[*phgv % 8];
                                }
                            }
                        }
                        phg++;
                        wcLow++;
                        // A tricky step, we do not care about it if bVertical != TRUE
                        phgv++;
                    }
                }

                pwcruns++;
                pwcrunsv++; // same trick as phgv
            }
       }
    }

    pttc->pga = pga;

    return TRUE;
}

/******************************Public*Routine******************************\
*
* BOOL bChangeXform( PFONTCONTEXT pfc, BOOL bRotation )
*
*
* if bRotation is TRUE: call the scaler with rotated transform.
*                FALSE: call the scaler with normal transform.
*
* History:
*  19-Mar-1993 -by- Takao Kitano [TakaoK]
* Wrote it.
\**************************************************************************/

BOOL bChangeXform( PFONTCONTEXT pfc, BOOL bRotation)
{
    FS_ENTRY    iRet;

#ifdef DBCS_VERT_DEBUG
    if ( DebugVertical & DEBUG_VERTICAL_CALL )
    {
        TtfdDbgPrint("TTFD!bChangeXform:bRotation=%s\n", bRotation ? "TRUE":"FALSE");
    }
#endif

    vInitGlyphState(&pfc->gstat);

    if ( bRotation )
    {
        pfc->pgin->param.newtrans.transformMatrix = &(pfc->mxv);
    }
    else
    {
        pfc->pgin->param.newtrans.transformMatrix = &(pfc->mxn);
    }

    pfc->pgin->param.newtrans.pointSize = pfc->pointSize;
    pfc->pgin->param.newtrans.xResolution = (int16)pfc->sizLogResPpi.cx;
    pfc->pgin->param.newtrans.yResolution = (int16)pfc->sizLogResPpi.cy;
    pfc->pgin->param.newtrans.pixelDiameter = FIXEDSQRT2;
    pfc->pgin->param.newtrans.usOverScale = pfc->overScale;
    ASSERTDD( pfc->overScale != FF_UNDEFINED_OVERSCALE , "Undefined Overscale\n" );


    pfc->pgin->param.newtrans.traceFunc = (FntTraceFunc)NULL;

    if (pfc->flFontType & FO_SIM_BOLD)
    {
        /* 2% + 1 pixel along baseline, 2% along descender line */

        pfc->pgin->param.newtrans.usEmboldWeightx = 20;
        pfc->pgin->param.newtrans.usEmboldWeighty = 20;
        pfc->pgin->param.newtrans.lDescDev = pfc->lDescDev;

        if (pfc->flXform & XFORM_BITMAP_SIM_BOLD)
        {
            pfc->pgin->param.newtrans.bBitmapEmboldening = TRUE;
        } else
        {
            pfc->pgin->param.newtrans.bBitmapEmboldening = FALSE;
        }
    }
    else
    {
        pfc->pgin->param.newtrans.usEmboldWeightx = 0;
        pfc->pgin->param.newtrans.usEmboldWeighty = 0;
        pfc->pgin->param.newtrans.lDescDev = 0;
        pfc->pgin->param.newtrans.bBitmapEmboldening = FALSE;
    }

    pfc->pgin->param.newtrans.bHintAtEmSquare = FALSE;

    if ((iRet = fs_NewTransformation(pfc->pgin, pfc->pgout)) != NO_ERR)
    {
        V_FSERROR(iRet);

    // try to recover, most likey bad hints, just return unhinted glyph

        if ((iRet = fs_NewTransformNoGridFit(pfc->pgin, pfc->pgout)) != NO_ERR)
        {
           V_FSERROR(iRet);
           #if DBG
           TtfdDbgPrint("bChangeXform(%-#x,%d) failed\n", pfc, bRotation);
           #endif
            return(FALSE);
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* VOID vShiftBitmapInfo( FONTCONTEXT *pfc, fs_GlyphInfoType *pgout )
*
*
* Modifies following values.
*
* Using pfc->devShiftX and pfc->devShiftY:
*
*  gout.bitMapInfo.bounds.right
*  gout.bitMapInfo.bounds.left
*  gout.bitMapInfo.bounds.top
*  gout.bitMapInfo.bounds.bottom
*  gout.metricInfo.devLeftSideBearing.x
*  gout.metricInfo.devLeftSideBearing.y
*
* Using -90 degree rotation
*
*  gout.metricInfo.devAdvanceWidth.x
*  gout.metricInfo.devAdvanceWidth.y
*
* History:
*  04-Apr-1993 -by- Takao Kitano [TakaoK]
* Wrote it.
\**************************************************************************/

VOID vShiftBitmapInfo(
    FONTCONTEXT *pfc,
    fs_GlyphInfoType *pgoutDst,
    fs_GlyphInfoType *pgoutSrc)
{
    SHORT sdevShiftX = (SHORT) F16_16TOLROUND(pfc->fxdevShiftX);
    SHORT sdevShiftY = (SHORT) F16_16TOLROUND(pfc->fxdevShiftY);

    pgoutDst->bitMapInfo.bounds.right =  pgoutSrc->bitMapInfo.bounds.right + sdevShiftX;
    pgoutDst->bitMapInfo.bounds.left = pgoutSrc->bitMapInfo.bounds.left + sdevShiftX;
    pgoutDst->bitMapInfo.bounds.top = pgoutSrc->bitMapInfo.bounds.top + sdevShiftY;
    pgoutDst->bitMapInfo.bounds.bottom = pgoutSrc->bitMapInfo.bounds.bottom + sdevShiftY;

    pgoutDst->metricInfo.devLeftSideBearing.x = pgoutSrc->metricInfo.devLeftSideBearing.x + pfc->fxdevShiftX;
    pgoutDst->metricInfo.devLeftSideBearing.y = pgoutSrc->metricInfo.devLeftSideBearing.y + pfc->fxdevShiftY;

    //
    // -90degree rotation in truetype coordinate system
    //
    //                            [ 0  -1 ]
    //  (newX, newY) = ( x, y ) * [       ]  = (y, -x )
    //                            [ 1   0 ]
    //       A
    //      Y|
    //       |
    //       |
    //       +----->
    //            X
    //

    pgoutDst->metricInfo.devAdvanceWidth.x = pgoutSrc->metricInfo.devAdvanceWidth.y;
    pgoutDst->metricInfo.devAdvanceWidth.y = - pgoutSrc->metricInfo.devAdvanceWidth.x;

    pgoutDst->verticalMetricInfo.devAdvanceHeight.x = pgoutSrc->verticalMetricInfo.devAdvanceHeight.y;
    pgoutDst->verticalMetricInfo.devAdvanceHeight.y = - pgoutSrc->verticalMetricInfo.devAdvanceHeight.x;

    pgoutDst->verticalMetricInfo.devTopSideBearing.x = pgoutSrc->verticalMetricInfo.devTopSideBearing.x;
    pgoutDst->verticalMetricInfo.devTopSideBearing.y = pgoutSrc->verticalMetricInfo.devTopSideBearing.y;
    
#ifdef DBCS_VERT_DEBUG
    if ( DebugVertical & DEBUG_VERTICAL_BITMAPINFO )
    {
        TtfdDbgPrint("=====TTFD:vShiftBitmapInfo() before \n");
        TtfdDbgPrint("bitMapInfo.bounds:right=%ld, left=%ld, top=%ld, bottom=%ld\n",
                   pgoutSrc->bitMapInfo.bounds.right,
                   pgoutSrc->bitMapInfo.bounds.left,
                   pgoutSrc->bitMapInfo.bounds.top,
                   pgoutSrc->bitMapInfo.bounds.bottom);
        TtfdDbgPrint("metricInfo.devLeftSideBearing x = %ld, y=%ld \n",
                  F16_16TOLROUND(pgoutSrc->metricInfo.devLeftSideBearing.x),
                  F16_16TOLROUND(pgoutSrc->metricInfo.devLeftSideBearing.y));
        TtfdDbgPrint("metricInfo.devAdvanceWidth x = %ld, y=%ld \n",
                  F16_16TOLROUND(pgoutSrc->metricInfo.devAdvanceWidth.x),
                  F16_16TOLROUND(pgoutSrc->metricInfo.devAdvanceWidth.y));

        TtfdDbgPrint("=====TTFD:vShiftBitmapInfo() after \n");
        TtfdDbgPrint("bitMapInfo.bounds:right=%ld, left=%ld, top=%ld, bottom=%ld\n",
                   pgoutDst->bitMapInfo.bounds.right,
                   pgoutDst->bitMapInfo.bounds.left,
                   pgoutDst->bitMapInfo.bounds.top,
                   pgoutDst->bitMapInfo.bounds.bottom);
        TtfdDbgPrint("metricInfo.devLeftSideBearing x = %ld, y=%ld \n",
                  F16_16TOLROUND(pgoutDst->metricInfo.devLeftSideBearing.x),
                  F16_16TOLROUND(pgoutDst->metricInfo.devLeftSideBearing.y));
        TtfdDbgPrint("metricInfo.devAdvanceWidth x = %ld, y=%ld \n",
                  F16_16TOLROUND(pgoutDst->metricInfo.devAdvanceWidth.x),
                  F16_16TOLROUND(pgoutDst->metricInfo.devAdvanceWidth.y));
    }
#endif
}

/******************************Public*Routine******************************\
*
* vShiftOutlineInfo()
*
* History:
*  04-Apr-1993 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

#define CJ_CRV(pcrv)                                              \
(                                                                 \
    offsetof(TTPOLYCURVE,apfx) + ((pcrv)->cpfx * sizeof(POINTFX)) \
)

VOID vAdd16FixTo16Fix(
    FIXED *A ,
    FIXED *B ,
    BOOL  bForceMinus
)
{
    A->fract += B->fract;
    A->value += B->value;
}

VOID vAdd16FixTo28Fix(
    FIXED *A ,
    FIXED *B ,
    BOOL  bForceMinus
)
{
    Fixed longA , longB;

    ASSERTDD( sizeof(FIXED) == sizeof(Fixed) , "TTFD:FIXED != ULONG\n" );

    longA = *(Fixed *)A;
    longB = *(Fixed *)B;

// WINBUG 82937 claudebe 2-11-2000 , if we rewrite or modify the vertical writing code, we need to be careful about :
//
// if outline request from PostScript printer driver, the driver
// can not get correct outline without following super hack.
// we most need feather investigation.
//
// propably, we should compute shift value accoring
// to device coordinate ???. Y axis is different
// between device and truetype coordinate.
// how about GetGlyphOutline() ???
// I just tested using gdi\test\fonttest.nt\fonttest.exe
// It seems work fine.
//
// start super-hack.

    if(bForceMinus) longB = -longB;

// end super-hack.

    longB = longB >> 12;

    longA += longB;

    *A = *(FIXED *)&longA;
}

VOID vShiftOutlineInfo(
    FONTCONTEXT     *pfc,        // IN  font context
    BOOL             b16Dot16,   // IN  Fixed format 16.16 or 28.4
    BYTE            *pBuffer,    // OUT output buffer
    ULONG            cjTotal     // IN  buffer size
)
{
    VOID vFillGLYPHDATA(
                     HGLYPH,
                     ULONG,
                     FONTCONTEXT*,
                     fs_GlyphInfoType*,
                     GLYPHDATA*,
                     GMC*,
                     POINTL*
                     );

    TTPOLYGONHEADER *ppoly, *ppolyStart, *ppolyEnd;
    TTPOLYCURVE     *pcrv, * pcrvEnd;
    LONG             fxShiftX, fxShiftY;
    ULONG            cSpli , cSpliMax;
    POINTFX         *pptfix;
    VOID             (*vAddFunc)(FIXED *A,FIXED *B,BOOL bForceMinus);
    BOOL             bForceMinus;
    fs_GlyphInfoType Info, *pInfo = pfc->pgout;
    GLYPHDATA        Data;

    //
    // In order to calculate the shift I will call the routine
    // that calculates the shift for the equivalent bitmap. This
    // will cost some unnecessary cycles since we will be calculating
    // some information that will be ignored. However, this approach
    // has the advantage of using working code without a lot of
    // re-writing. Since this routine is called relatively infrequently
    // I am willing to paying this relatively small price.
    //

    //
    // First
    //
    // Call the routine that calculates the shift for the bitmap. Note
    // Info is a dummy fs_GlyphInfoType that must be supplied
    // but is not used here.
    //

    vShiftBitmapInfo(pfc, &Info, pInfo);
    vFillGLYPHDATA(pfc->hgSave, pfc->gstat.igLast, pfc, &Info, &Data, 0, 0);

    //
    // Then
    //
    // Use that information to calculate the shift for the font space outline
    // Note that the shift in the x-direction and the shift in the y-direction
    // are calculated with a different sign. This arises because the shift
    // is calculated in a coordinate system where y increases downward while
    // the shift is applied to a curve whose y-coordinates are assumed to
    // increase in the upward direction.
    //

    fxShiftX  = Data.rclInk.left << 16;
    fxShiftX -= ((pInfo->metricInfo.devLeftSideBearing.x + 0x8000) & 0xFFFF0000);
    fxShiftY = -((Data.rclInk.top + pInfo->bitMapInfo.bounds.bottom) << 16);


    if( b16Dot16 ) {
        vAddFunc = vAdd16FixTo16Fix;
        bForceMinus = FALSE;
    } else {
        vAddFunc = vAdd16FixTo28Fix;
        bForceMinus = TRUE;
    }

    #ifdef DBCS_VERT_DEBUG
    TtfdDbgPrint("====== START DUMP VERTICAL POLYGON ======\n");
    TtfdDbgPrint("devShiftX=%ld, devShiftY=%ld \n"
                  ,F16_16TOLROUND(fxShiftX),
                   F16_16TOLROUND(fxShiftY));
    #endif // DBCS_VERT_DEBUG

    ppolyStart = (TTPOLYGONHEADER *)pBuffer;
    ppolyEnd   = (TTPOLYGONHEADER *)(pBuffer + cjTotal);

    for (
         ppoly = ppolyStart;
         ppoly < ppolyEnd;
         ppoly = (TTPOLYGONHEADER *)((PBYTE)ppoly + ppoly->cb)
        )
    {
        ASSERTDD(ppoly->dwType == TT_POLYGON_TYPE,"ppoly->dwType != TT_POLYGON_TYPE\n");

        #ifdef DBCS_VERT_DEBUG
        TtfdDbgPrint("ppoly->cb  - %d\n",ppoly->cb);
        #endif // DBCS_VERT_DEBUG

        (*vAddFunc)( &ppoly->pfxStart.x , (FIXED*)&fxShiftX , FALSE );
        (*vAddFunc)( &ppoly->pfxStart.y , (FIXED*)&fxShiftY , bForceMinus );

        #ifdef DBCS_VERT_DEBUG
        TtfdDbgPrint("StartPoint - ( %x , %x )\n",ppoly->pfxStart.x,ppoly->pfxStart.y);
        #endif // DBCS_VERT_DEBUG

        for (
             pcrv = (TTPOLYCURVE *)(ppoly + 1),pcrvEnd = (TTPOLYCURVE *)((PBYTE)ppoly + ppoly->cb);
             pcrv < pcrvEnd;
             pcrv = (TTPOLYCURVE *)((PBYTE)pcrv + CJ_CRV(pcrv))
            )
        {
            #ifdef DBCS_VERT_DEBUG
            TtfdDbgPrint("Contents of TTPOLYCURVE (%d)\n",pcrv->cpfx);
            #endif // DBCS_VERT_DEBUG

            for (
                 cSpli = 0,cSpliMax = pcrv->cpfx,pptfix = &(pcrv->apfx[0]);
                 cSpli < cSpliMax;
                 cSpli ++,pptfix ++
                )
            {
                (*vAddFunc)( &pptfix->x , (FIXED*) &fxShiftX , FALSE );
                (*vAddFunc)( &pptfix->y , (FIXED*) &fxShiftY , bForceMinus );

                #ifdef DBCS_VERT_DEBUG
                TtfdDbgPrint("           - ( %x , %x )\n",pptfix->x,pptfix->y);
                #endif // DBCS_VERT_DEBUG
            }
        }

        #ifdef DBCS_VERT_DEBUG
        TtfdDbgPrint("\n");
        #endif // DBCS_VERT_DEBUG
    }

    #ifdef DBCS_VERT_DEBUG
    TtfdDbgPrint("====== END DUMP VERTICAL POLYGON ======\n");
    #endif // DBCS_VERT_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\xform.h ===
/******************************Module*Header*******************************\
* Module Name: xform.h
*
* (Brief description)
*
* Created: 05-Apr-1992 11:06:23
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#if defined(_AMD64_) || defined(_IA64_)

typedef FLOAT EFLOAT;
#ifndef TT_DEBUG_EXTENSIONS
#define lCvt(ef, l) ((LONG) (ef * l))
#endif

#else // i386

typedef struct  _EFLOAT
{
    LONG    lMant;
    LONG    lExp;
} EFLOAT;

#ifndef TT_DEBUG_EXTENSIONS
LONG lCvt(EFLOAT ef,LONG l);
#endif

#endif // i386

typedef EFLOAT *PEFLOAT;

typedef struct _VECTORFL
{
    EFLOAT x;
    EFLOAT y;
} VECTORFL, *PVECTORFL;


BOOL bFDXform
(
XFORML   *pxf,
POINTFIX *pptfxDst,
POINTL   *pptlSrc,
ULONG     c
);

BOOL bXformUnitVector
(
POINTL       *pptl,           // IN,  incoming unit vector
XFORML       *pxf,            // IN,  xform to use
PVECTORFL     pvtflXformed,   // OUT, xform of the incoming unit vector
POINTE       *ppteUnit,       // OUT, *pptqXormed/|*pptqXormed|, POINTE
POINTQF      *pptqUnit,       // OUT, optional
EFLOAT       *pefNorm         // OUT, |*pptqXormed|
);

VOID vLTimesVtfl     // *pptq = l * pvtfl, *pptq is in 28.36 format
(
LONG       l,
VECTORFL  *pvtfl,
POINTQF   *pptq
);


FIX  fxLTimesEf  //!!! SHOULD BE MOVED TO TTFD and VTFD
(
EFLOAT *pef,
LONG    l
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\vtfd\fdcvt.c ===
/******************************Module*Header*******************************\
* Module Name: fdcvt.c
*
* Font file loading and unloadking.  Adapted from BodinD's bitmap font driver.
*
* Created: 26-Feb-1992 20:23:54
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

// points to the linked list of glyphset strucs

CP_GLYPHSET *gpcpVTFD = NULL;



ULONG cjVTFDIFIMETRICS(PBYTE ajHdr);

// !!! put prototype in common area for all font drivers so change
// !!! in 1 is reflected in all.


FSHORT fsSelectionFlags(PBYTE ajHdr); // in bmfd

extern BOOL bDbgPrintAndFail(PSZ psz);

#if DBG

extern BOOL bDbgPrintAndFail(PSZ psz);

#else

#define bDbgPrintAndFail(psz) FALSE

#endif

ULONG iDefaultFace(PBYTE ajHdr) // similar to vDefFace, should not be duplicated
{
    ULONG iDefFace;

    if (READ_WORD(&ajHdr[OFF_Weight]) <= FW_NORMAL)
    {
        if (ajHdr[OFF_Italic])
        {
            iDefFace = FF_FACE_ITALIC;
        }
        else
        {
            iDefFace = FF_FACE_NORMAL;
        }
    }
    else
    {
        if (ajHdr[OFF_Italic])
        {
            iDefFace = FF_FACE_BOLDITALIC;
        }
        else
        {
            iDefFace = FF_FACE_BOLD;
        }
    }
    return iDefFace;
}


/******************************Private*Routine*****************************\
* BOOL bVerifyVTFD
*
* CHECK whether header contains file info which corresponds to
* the raster font requirements, go into the file and check
* the consistency of the header data
*
* History:
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL bVerifyVTFD(PRES_ELEM pre)
{
    PBYTE ajHdr  = (PBYTE)pre->pvResData;

    if (pre->cjResData < OFF_OffTable20)
        return(bDbgPrintAndFail("VTFD! resource size too small for OFF_OffTable20\n"));         // supported.

    if (!(READ_WORD(&ajHdr[OFF_Type]) & TYPE_VECTOR))   // Vector bit has to
        return(bDbgPrintAndFail("VTFD!fsType \n"));          // be on.

    if ((READ_WORD(&ajHdr[OFF_Version]) != 0x0100) &&     // The only version
        (READ_WORD(&ajHdr[OFF_Version]) != 0x0200) )      // The only version
        return(bDbgPrintAndFail("VTFD!iVersion\n"));         // supported.

    if ((ajHdr[OFF_BitsOffset] & 1) != 0)               // Must be an even
        return(bDbgPrintAndFail("VTFD!dpBits odd \n"));      // offset.

// file size must be <= than the size of the view

    if (READ_DWORD(&ajHdr[OFF_Size]) > pre->cjResData)
        return(bDbgPrintAndFail("VTFD!cjSize \n"));

// make sure that the reserved bits are all zero

    if ((READ_WORD(&ajHdr[OFF_Type]) & BITS_RESERVED) != 0)
        return(bDbgPrintAndFail("VTFD!fsType, reserved bits \n"));

    if (abs(READ_WORD(&ajHdr[OFF_Ascent])) > READ_WORD(&ajHdr[OFF_PixHeight]))
        return(bDbgPrintAndFail("VTFD!sAscent \n")); // Ascent Too Big

    if (READ_WORD(&ajHdr[OFF_IntLeading]) > READ_WORD(&ajHdr[OFF_Ascent]))
        return(bDbgPrintAndFail("VTFD! IntLeading too big\n")); // Int Lead Too Big;

// check consistency of character ranges

    if (ajHdr[OFF_FirstChar] > ajHdr[OFF_LastChar])
        return(bDbgPrintAndFail("VTFD! FirstChar\n")); // this can't be

// default and break character are given relative to the FirstChar,
// so that the actual default (break) character is given as
// chFirst + chDefault(Break)

    if ((BYTE)(ajHdr[OFF_DefaultChar] + ajHdr[OFF_FirstChar]) > ajHdr[OFF_LastChar])
        return(bDbgPrintAndFail("VTFD! DefaultChar\n"));

    if ((BYTE)(ajHdr[OFF_BreakChar] + ajHdr[OFF_FirstChar]) > ajHdr[OFF_LastChar])
        return(bDbgPrintAndFail("VTFD! BreakChar\n"));

// finally verify that all the offsets to glyph data point to locations
// within the file and that what they point to is valid glyph data: [BodinD]

    {

        INT iIndex, dIndex, iIndexEnd;
        PBYTE pjCharTable, pjGlyphData,pjFirstChar, pjEndFile;

        iIndexEnd =  (INT)ajHdr[OFF_LastChar] - (INT)ajHdr[OFF_FirstChar] + 1;

    // init out of the loop:

        if (READ_WORD(&ajHdr[OFF_PixWidth]) != 0) // fixed pitch
        {
            iIndexEnd <<= 1;           // each entry is 2-byte long
            dIndex = 2;
        }
        else
        {
            iIndexEnd <<= 2;           // each entry is 4-byte long
            dIndex = 4;
        }

        pjFirstChar = ajHdr + READ_DWORD(ajHdr + OFF_BitsOffset);

    // Vector font file doesn't have the byte filler.  Win31 bug?

        pjCharTable = ajHdr + OFF_jUnused20;
        pjEndFile   = ajHdr + READ_DWORD(ajHdr + OFF_Size);

        if (OFF_jUnused20 + (ULONG)(iIndexEnd * dIndex) > pre->cjResData)
            return(bDbgPrintAndFail("VTFD! OffsetTable out of file \n"));

        for (iIndex = 0; iIndex < iIndexEnd; iIndex += dIndex)
        {
             pjGlyphData = pjFirstChar + READ_WORD(&pjCharTable[iIndex]);

             if ((pjGlyphData >= pjEndFile) || (*pjGlyphData != (BYTE)PEN_UP))
                 return(bDbgPrintAndFail("VTFD!bogus vector font \n"));
        }
    }

    {
        PSZ   pszFaceName = ajHdr + READ_DWORD(&ajHdr[OFF_Face]);
        SIZE_T pszFaceNameLength;

        if (!bMappedViewStrlen(pre->pvResData, pre->cjResData, pszFaceName, &pszFaceNameLength))
                 return(bDbgPrintAndFail("VTFD!bogus FaceName \n"));
    }

    return(TRUE);
}


/******************************Private*Routine*****************************\
* ULONG cVtfdResFaces
*
* Compute the number of faces that the given .FNT file can support.
*
* History:
*  04-Mar-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG cVtfdResFaces(PBYTE ajHdr)
{
// We set the FM_SEL_BOLD flag iff weight is > FW_NORMAL (400).
// We will not allow emboldening simulation on the font that has this
// flag set.

    if (READ_WORD(&ajHdr[OFF_Weight]) <= FW_NORMAL)
    {
        if (ajHdr[OFF_Italic])
            return(2);
        else
            return(4);
    }
    else
    {
        if (ajHdr[OFF_Italic])
            return(1);
        else
            return(2);
    }
}

/******************************Private*Routine*****************************\
* VOID vVtfdFill_IFIMetrics
*
* Looks into the .FNT file and fills the IFIMETRICS structure accordingly.
*
* History:
*  Wed 04-Nov-1992 -by- Bodin Dresevic [BodinD]
* update: new ifimetrics
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/


VOID vVtfdFill_IFIMetrics(PBYTE ajHdr, FD_GLYPHSET * pgset, PIFIMETRICS pifi)
{
    FWORD     fwdHeight;
    FONTSIM  *pFontSim;
    FONTDIFF *pfdiffBold = 0, *pfdiffItalic = 0, *pfdiffBoldItalic = 0;
    PANOSE   *ppanose;
    ULONG    iDefFace;
    ULONG    cjIFI = ALIGN4(sizeof(IFIMETRICS));
    ULONG    cch;
    FWORD     cy;

// compute pointers to the various sections of the converted file

// face name lives in the original file, this is the only place pvView is used

    PSZ   pszFaceName = (PSZ)(ajHdr + READ_DWORD(&ajHdr[OFF_Face]));

    pifi->cjIfiExtra = 0;
    pifi->cjThis    = cjVTFDIFIMETRICS(ajHdr);

// the string begins on a DWORD aligned address.

    pifi->dpwszFaceName = cjIFI;

// face name == family name for vector fonts [Win3.0 compatibility]

    pifi->dpwszFamilyName    = pifi->dpwszFaceName;

// these names don't exist, so point to the NULL char  [Win3.1 compatibility]
// Note: lstrlen() does not count the terminating NULL.

    cch = (ULONG)strlen(pszFaceName);

    pifi->dpwszStyleName = pifi->dpwszFaceName + sizeof(WCHAR) * cch;
    pifi->dpwszUniqueName = pifi->dpwszStyleName;

    cjIFI += ALIGN4((cch + 1) * sizeof(WCHAR));

// copy the strings to their new location. Here we assume that the sufficient
// memory has been allocated

    vToUNICODEN((LPWSTR)((PBYTE)pifi + pifi->dpwszFaceName), cch+1, pszFaceName, cch+1);

// Check to see if simulations are necessary and if they are, fill
// in the offsets to the various simulation fields and update cjThis
// field of the IFIMETRICS structure

    iDefFace = iDefaultFace(ajHdr);

    if (iDefFace == FF_FACE_BOLDITALIC)
    {
        pifi->dpFontSim = 0;
    }
    else
    {
        pifi->dpFontSim = cjIFI;
        pFontSim = (FONTSIM*) ((BYTE*)pifi + pifi->dpFontSim);
        cjIFI += ALIGN4(sizeof(FONTSIM));

        switch (iDefFace)
        {
        case FF_FACE_NORMAL:
        //
        // simulations are needed for bold, italic, and bold-italic
        //
            pFontSim->dpBold  = ALIGN4(sizeof(FONTSIM));
            pFontSim->dpItalic = pFontSim->dpBold + ALIGN4(sizeof(FONTDIFF));
            pFontSim->dpBoldItalic = pFontSim->dpItalic + ALIGN4(sizeof(FONTDIFF));

            pfdiffBold      =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBold);

            pfdiffItalic    =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpItalic);

            pfdiffBoldItalic =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBoldItalic);

            cjIFI += (3 * ALIGN4(sizeof(FONTDIFF)));
            break;

        case FF_FACE_BOLD:
        case FF_FACE_ITALIC:
        //
        // a simulation is needed for bold-italic only
        //
            pFontSim->dpBold       = 0;
            pFontSim->dpItalic     = 0;

            pFontSim->dpBoldItalic = ALIGN4(sizeof(FONTSIM));
            pfdiffBoldItalic       =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBoldItalic);

            cjIFI += ALIGN4(sizeof(FONTDIFF));
            break;

        default:

            RIP("VTFD -- bad iDefFace\n");
            break;
        }
    }

    ASSERTDD(cjIFI == pifi->cjThis, "cjIFI is wrong\n");

    pifi->jWinCharSet        = ajHdr[OFF_CharSet];
    pifi->jWinPitchAndFamily = ajHdr[OFF_Family];

//
// !!![kirko] The next line of code is very scary but it seems to work.
// This will call a font with FIXED_PITCH set, a varible pitch font.
// Or should this be decided upon whether cx == 0 or not? [bodind]
//

// this is the excert from wendy's code:

//    if ((ajHdr[OFF_Family] & 1) == 0)
//        pifi->flInfo |= FM_INFO_CONSTANT_WIDTH;


    if (pifi->jWinPitchAndFamily & 0x0f)
    {
        pifi->jWinPitchAndFamily = ((pifi->jWinPitchAndFamily & 0xf0) | VARIABLE_PITCH);
    }
    else
    {
        pifi->jWinPitchAndFamily = ((pifi->jWinPitchAndFamily & 0xf0) | FIXED_PITCH);
    }

    pifi->usWinWeight = READ_WORD(&ajHdr[OFF_Weight]);

// weight, may have to fix it up if the font contains a garbage value [bodind]

    if ((pifi->usWinWeight > MAX_WEIGHT) || (pifi->usWinWeight < MIN_WEIGHT))
        pifi->usWinWeight = 400;

    pifi->flInfo = (  FM_INFO_TECH_STROKE
                    | FM_INFO_ARB_XFORMS
                    | FM_INFO_RETURNS_STROKES
                    | FM_INFO_RIGHT_HANDED
                   );

    if ((pifi->jWinPitchAndFamily & 0xf) == FIXED_PITCH)
    {
        pifi->flInfo |= (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH);
    }

    pifi->lEmbedId = 0;
    pifi->fsSelection = fsSelectionFlags(ajHdr);

//
// The choices for fsType are FM_TYPE_LICENSED and FM_READONLY_EMBED
// These are TrueType things and do not apply to old fashioned bitmap and vector
// fonts.
//
    pifi->fsType = 0;

    cy = (FWORD)READ_WORD(&ajHdr[OFF_PixHeight]);

    pifi->fwdUnitsPerEm = ((FWORD)READ_WORD(&ajHdr[OFF_IntLeading]) > 0) ?
        cy - (FWORD)READ_WORD(&ajHdr[OFF_IntLeading]) : cy;

    pifi->fwdLowestPPEm    = 0;

    pifi->fwdWinAscender   = (FWORD)READ_WORD(&ajHdr[OFF_Ascent]);
    pifi->fwdWinDescender  = cy - pifi->fwdWinAscender;

    pifi->fwdMacAscender   =  pifi->fwdWinAscender ;
    pifi->fwdMacDescender  = -pifi->fwdWinDescender;
    pifi->fwdMacLineGap    =  (FWORD)READ_WORD(&ajHdr[OFF_ExtLeading]);

    pifi->fwdTypoAscender  = pifi->fwdMacAscender;
    pifi->fwdTypoDescender = pifi->fwdMacDescender;
    pifi->fwdTypoLineGap   = pifi->fwdMacLineGap;

    pifi->fwdAveCharWidth  = (FWORD)READ_WORD(&ajHdr[OFF_AvgWidth]);
    pifi->fwdMaxCharInc    = (FWORD)READ_WORD(&ajHdr[OFF_MaxWidth]);
//
// don't know much about SuperScripts
//
    pifi->fwdSubscriptXSize     = 0;
    pifi->fwdSubscriptYSize     = 0;
    pifi->fwdSubscriptXOffset   = 0;
    pifi->fwdSubscriptYOffset   = 0;

//
// don't know much about SubScripts
//
    pifi->fwdSuperscriptXSize   = 0;
    pifi->fwdSuperscriptYSize   = 0;
    pifi->fwdSuperscriptXOffset = 0;
    pifi->fwdSuperscriptYOffset = 0;

//
// win 30 magic. see the code in textsims.c in the Win 3.1 sources
//
    fwdHeight = pifi->fwdWinAscender + pifi->fwdWinDescender;

    pifi->fwdUnderscoreSize     = (fwdHeight > 12) ? (fwdHeight / 12) : 1;
    pifi->fwdUnderscorePosition = -(FWORD)(pifi->fwdUnderscoreSize / 2 + 1);

    pifi->fwdStrikeoutSize = pifi->fwdUnderscoreSize;

    {
    // We are further adjusting underscore position if underline
    // hangs below char stems.
    // The only font where this effect is noticed to
    // be important is an ex pm font sys08cga.fnt, presently used in console

        FWORD yUnderlineBottom = -pifi->fwdUnderscorePosition
                               + ((pifi->fwdUnderscoreSize + (FWORD)1) >> 1);

        FWORD dy = yUnderlineBottom - pifi->fwdWinDescender;

        if (dy > 0)
        {
        #ifdef CHECK_CRAZY_DESC
            DbgPrint("bmfd: Crazy descender: old = %ld, adjusted = %ld\n\n",
            (ULONG)pifi->fwdMaxDescender,
            (ULONG)yUnderlineBottom);
        #endif // CHECK_CRAZY_DESC

            pifi->fwdUnderscorePosition += dy;
        }
    }

//
// Win 3.1 method
//
//    LineOffset = ((((Ascent-IntLeading)*2)/3) + IntLeading)
//
// [remember that they measure the offset from the top of the cell,
//  where as NT measures offsets from the baseline]
//
    pifi->fwdStrikeoutPosition =
        (FWORD) (((FWORD)READ_WORD(&ajHdr[OFF_Ascent]) - (FWORD)READ_WORD(&ajHdr[OFF_IntLeading]) + 2)/3);

    pifi->chFirstChar   = ajHdr[OFF_FirstChar];
    pifi->chLastChar    = ajHdr[OFF_LastChar];;

// wcDefaultChar
// wcBreakChar

    {
        UCHAR chDefault = ajHdr[OFF_FirstChar] + ajHdr[OFF_DefaultChar];
        UCHAR chBreak   = ajHdr[OFF_FirstChar] + ajHdr[OFF_BreakChar];

    // Default and Break chars are given relative to the first char

        pifi->chDefaultChar = chDefault;
        pifi->chBreakChar   = chBreak;

        EngMultiByteToUnicodeN(&pifi->wcDefaultChar, sizeof(WCHAR), NULL, &chDefault, 1);
        EngMultiByteToUnicodeN(&pifi->wcBreakChar  , sizeof(WCHAR), NULL, &chBreak, 1);
    }

// These have to be taken from the glyph set [bodind]

    {
        WCRUN *pwcrunLast =  &(pgset->awcrun[pgset->cRuns - 1]);
        pifi->wcFirstChar =  pgset->awcrun[0].wcLow;
        pifi->wcLastChar  =  pwcrunLast->wcLow + pwcrunLast->cGlyphs - 1;
    }

    pifi->fwdCapHeight   = 0;
    pifi->fwdXHeight     = 0;

    pifi->dpCharSets = 0; // no multiple charsets in vector fonts

// All the fonts that this font driver will see are to be rendered left
// to right

    pifi->ptlBaseline.x = 1;
    pifi->ptlBaseline.y = 0;

    pifi->ptlAspect.y = (LONG) READ_WORD(&ajHdr[OFF_VertRes ]);
    pifi->ptlAspect.x = (LONG) READ_WORD(&ajHdr[OFF_HorizRes]);

    if (pifi->ptlAspect.y == 0)
    {
        pifi->ptlAspect.y = 1;
        WARNING("VTFD!vVtfdFill_IFIMetrics():ptlAspect.y == 0\n");
    }
    if (pifi->ptlAspect.x == 0)
    {
        pifi->ptlAspect.x = 1;
        WARNING("VTFD!vVtfdFill_IFIMetrics():ptlAspect.x == 0\n");
    }

    if (!(pifi->fsSelection & FM_SEL_ITALIC))
    {
    // The base class of font is not italicized,

        pifi->ptlCaret.x = 0;
        pifi->ptlCaret.y = 1;
    }
    else
    {
    // somewhat arbitrary

        pifi->ptlCaret.x = 1;
        pifi->ptlCaret.y = 2;
    }

//
// The font box reflects the  fact that a-spacing and c-spacing are zero
//
    pifi->rclFontBox.left   = 0;
    pifi->rclFontBox.top    = (LONG) pifi->fwdTypoAscender;
    pifi->rclFontBox.right  = (LONG) pifi->fwdMaxCharInc;
    pifi->rclFontBox.bottom = (LONG) pifi->fwdTypoDescender;

//
// achVendorId, do not bother figuring it out
//

    pifi->achVendId[0] = 'U';
    pifi->achVendId[1] = 'n';
    pifi->achVendId[2] = 'k';
    pifi->achVendId[3] = 'n';

    pifi->cKerningPairs   = 0;

//
// Panose
//
    pifi->ulPanoseCulture = FM_PANOSE_CULTURE_LATIN;
    ppanose = &(pifi->panose);
    ppanose->bFamilyType = PAN_NO_FIT;
    ppanose->bSerifStyle =
        ((pifi->jWinPitchAndFamily & 0xf0) == FF_SWISS) ?
            PAN_SERIF_NORMAL_SANS : PAN_ANY;
    ppanose->bWeight = (BYTE) WINWT_TO_PANWT(READ_WORD(&ajHdr[OFF_Weight]));
    ppanose->bProportion = (READ_WORD(&ajHdr[OFF_PixWidth]) == 0) ? PAN_ANY : PAN_PROP_MONOSPACED;
    ppanose->bContrast        = PAN_ANY;
    ppanose->bStrokeVariation = PAN_ANY;
    ppanose->bArmStyle        = PAN_ANY;
    ppanose->bLetterform      = PAN_ANY;
    ppanose->bMidline         = PAN_ANY;
    ppanose->bXHeight         = PAN_ANY;

//
// Now fill in the fields for the simulated fonts
//

    if (pifi->dpFontSim)
    {
    //
    // Create a FONTDIFF template reflecting the base font
    //
        FONTDIFF FontDiff;

        FontDiff.jReserved1      = 0;
        FontDiff.jReserved2      = 0;
        FontDiff.jReserved3      = 0;
        FontDiff.bWeight         = pifi->panose.bWeight;
        FontDiff.usWinWeight     = pifi->usWinWeight;
        FontDiff.fsSelection     = pifi->fsSelection;
        FontDiff.fwdAveCharWidth = pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc   = pifi->fwdMaxCharInc;
        FontDiff.ptlCaret        = pifi->ptlCaret;

        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBoldItalic->bWeight    = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;

        // in vtfd case this is only true in the notional space

            pfdiffBold->fwdAveCharWidth += 1;
             pfdiffBold->fwdMaxCharInc   += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection     |= FM_SEL_ITALIC;
            pfdiffItalic->ptlCaret.x = 1;
            pfdiffItalic->ptlCaret.y = 2;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;
            pfdiffBoldItalic->ptlCaret.x       = 1;
            pfdiffBoldItalic->ptlCaret.y       = 2;

        // in vtfd case this is only true in the notional space

            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
        }
    }

}





ULONG cjVTFDIFIMETRICS(PBYTE ajHdr)
{
    ULONG cjIFI = ALIGN4(sizeof(IFIMETRICS));
    PSZ   pszFaceName = ajHdr + READ_DWORD(&ajHdr[OFF_Face]);
    ULONG cSims;

    cjIFI += ALIGN4((strlen(pszFaceName) + 1) * sizeof(WCHAR));

// add simulations:

    if (cSims = (cVtfdResFaces(ajHdr) - 1))
        cjIFI += (ALIGN4(sizeof(FONTSIM)) + cSims * ALIGN4(sizeof(FONTDIFF)));

    return cjIFI;
}




/******************************Private*Routine*****************************\
* HFF hffVtfdLoadFont
*
* Loads an *.fon or an *.fnt file, returns handle to a fonfile object
* if successfull.
*
* History:
*  Wed 04-Nov-1992 -by- Bodin Dresevic [BodinD]
* update: rewrote it to reflect the new ifimetrics organization;
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL bVtfdLoadFont(PVOID pvView, ULONG cjView, ULONG_PTR iFile, ULONG iType, HFF *phff)
{
    WINRESDATA  wrd;
    RES_ELEM    re;
    ULONG       dpIFI, cjFF;
    ULONG       ifnt;
    PIFIMETRICS pifi;
    BOOL        bResult;
    BOOL        bCleanupOnError;

    bResult = FALSE;
    bCleanupOnError = FALSE;
    *phff = (HFF)NULL;

    if (iType == TYPE_DLL16)
    {
        if (!bInitWinResData(pvView,cjView, &wrd))
        {
            goto Exit;
        }
    }
    else // TYPE_FNT or TYPE_EXE
    {
        ASSERTDD((iType == TYPE_FNT) || (iType == TYPE_EXE),
                  "hffVtfdLoadFont: wrong iType\n");

        re.pvResData = pvView;
        re.dpResData = 0;
        re.cjResData = cjView;
        re.pjFaceName = NULL;
        wrd.cFntRes = 1;
    }

    cjFF = dpIFI = offsetof(FONTFILE,afd) + wrd.cFntRes * sizeof(FACEDATA);

    for (ifnt = 0; ifnt < wrd.cFntRes; ifnt++)
    {
        if (iType == TYPE_DLL16)
        {
            if (!bGetFntResource(&wrd, ifnt, &re))
            {
                goto Exit;
            }
        }

    // verify that this is a no nonsense resource:

        if (!bVerifyVTFD(&re))
        {
            goto Exit;
        }

        cjFF += cjVTFDIFIMETRICS(re.pvResData);
    }

// now at the bottom of the structure we will store File name

// Let's allocate the FONTFILE struct.

    if ((*phff = (HFF)pffAlloc(cjFF)) == (HFF)NULL)
    {
        WARNING("hffVtfdLoadFont: memory allocation error\n");
        goto Exit;
    }
    bCleanupOnError = TRUE;

// Initialize fields of FONTFILE struct.

    PFF(*phff)->iType      = iType;
    PFF(*phff)->fl         = 0;
    PFF(*phff)->cRef       = 0L;
    PFF(*phff)->iFile      = iFile;
    PFF(*phff)->pvView     = pvView;
    PFF(*phff)->cjView       = cjView;
    PFF(*phff)->cFace      = wrd.cFntRes;

    pifi = (PIFIMETRICS)((PBYTE)PFF(*phff) + dpIFI);

    for (ifnt = 0; ifnt < wrd.cFntRes; ifnt++)
    {
        if (iType == TYPE_DLL16)
        {
            if (!bGetFntResource(&wrd, ifnt, &re))
            {
                goto Exit;
            }
        }

        PFF(*phff)->afd[ifnt].re = re;
        PFF(*phff)->afd[ifnt].iDefFace = iDefaultFace(re.pvResData);
        PFF(*phff)->afd[ifnt].pifi = pifi;

        PFF(*phff)->afd[ifnt].pcp = pcpComputeGlyphset(
                                 &gpcpVTFD,
                                 (UINT)((BYTE *)re.pvResData)[OFF_FirstChar],
                                 (UINT)((BYTE *)re.pvResData)[OFF_LastChar],
                                 ((BYTE*)(re.pvResData))[OFF_CharSet]
                                 );

        if (PFF(*phff)->afd[ifnt].pcp == NULL)
        {
            WARNING("pgsetCompute failed\n");
            goto Exit;
        }

        vVtfdFill_IFIMetrics(re.pvResData, &(PFF(*phff)->afd[ifnt].pcp->gset),pifi);
        pifi = (PIFIMETRICS)((PBYTE)pifi + pifi->cjThis);
    }

    bResult = TRUE;
Exit:
    if (!bResult)
    {
#if DBG
        NotifyBadFont("%s failing\n", __FUNCTION__);
#endif
        if (bCleanupOnError)
        {
            vFree(*phff);    // clean up
            *phff = (HFF)NULL; // do not clean up again in exception code path
        }
    }
    return bResult;
}

/******************************Public*Routine******************************\
* vtfdLoadFontFile
*
* Load the given font file into memory and prepare the file for use.
*
* History:
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL vtfdLoadFontFile(ULONG_PTR iFile, PVOID pvView, ULONG cjView, HFF *phff)
{
    BOOL     bRet = FALSE;

    *phff = (HFF)NULL;

// Try loading it as a fon file, if it does not work, try as an fnt file.

    if (!(bRet = bVtfdLoadFont(pvView, cjView, iFile, TYPE_DLL16,phff)))
        bRet = bVtfdLoadFont(pvView, cjView, iFile, TYPE_FNT, phff);  // try as an *.fnt file

    return bRet;
}

/******************************Public*Routine******************************\
* BOOL vtfdUnloadFontFile
*
* Unload a font file and free all the structures created.
*
* History:
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL vtfdUnloadFontFile(HFF hff)
{
    ULONG iFace;

    if (hff == HFF_INVALID)
        return(FALSE);

// check the reference count, if not 0 (font file is still
// selected into a font context) we have a problem

    ASSERTDD(PFF(hff)->cRef == 0L, "cRef: links are broken\n");

// unload all glyphsets:

    for (iFace = 0; iFace < PFF(hff)->cFace; iFace++)
    {
        vUnloadGlyphset(&gpcpVTFD,
                        PFF(hff)->afd[iFace].pcp);
    }

// the file has been umapped as cRef went back to zero

    vFree(PFF(hff));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\vtfd\fdfc.c ===
/******************************Module*Header*******************************\
* Module Name: fdfc.c
*
* Various font context functions.  Adapted from BodinD's bitmap font driver.
*
* Copyright (c) 1990-1995 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

#define MIN(A,B)    ((A) < (B) ?  (A) : (B))
#define MAX(A,B)    ((A) > (B) ?  (A) : (B))

#if defined(_AMD64_) || defined(_IA64_)
#define MUL16(ef)   {ef *= 16; }
#define lCvt(ef, l) ((LONG) (ef * l))
#else
#define MUL16(ef)   {if (ef.lMant != 0) ef.lExp += 4; }
LONG lCvt(EFLOAT ef,LONG l);
#endif

/******************************Private*Routine*****************************\
* BOOL bInitXform
*
* Initialize the coefficients of the transforms for the given font context.
* It also transforms and saves various measurements of the font in the
* context.
*
* History:
*  25-Feb-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL bInitXform(PFONTCONTEXT pfc, XFORMOBJ *pxo)
{
// !!! bFloatToFix should be replaced with a compare and a type cast.
// Dont update the coefficeints in the font context yet since overflows
// might occur.

    VECTORFL  vtflTmp;
    POINTL    ptl;
    XFORML    xfm;

// Get the transform elements.

    XFORMOBJ_iGetXform(pxo,&xfm);

// Convert elements of the matrix from IEEE float to our EFLOAT.

    vEToEF(xfm.eM11, &pfc->efM11);
    vEToEF(xfm.eM12, &pfc->efM12);
    vEToEF(xfm.eM21, &pfc->efM21);
    vEToEF(xfm.eM22, &pfc->efM22);

// The path we are to construct takes 1/16 pixel per unit.  So lets
// multiply this factor in the transform.

    MUL16(pfc->efM11)
    MUL16(pfc->efM12)
    MUL16(pfc->efM21)
    MUL16(pfc->efM22)

//
// These are the special cases for which we need to clip bottom and right
// edges.  Below is the lower case letter e all posible 90 rotations and
// flips.
//
//
//  ***     ***      **       *****    ***     ***     *****       **
// *   *   *        *  *  *  *  *  *      *   *   *   *  *  *  *  *  *
// *****   *****    *  *  *  *  *  *  *****   *****   *  *  *  *  *  *
// *       *   *    *  *  *  *  *  *  *   *       *   *  *  *  *  *  *
//  ***     ***      *****    **       ***     ***        **    *****
//
// case 1  case 2   case 6   case 5   case 3  case 4   case 7   case 8
//
//


    if (bIsZero(pfc->efM12) && bIsZero(pfc->efM21))
    {
        pfc->flags |= FC_SCALE_ONLY;
        if (!bPositive(pfc->efM11))
            pfc->flags |= FC_X_INVERT;

        if( bPositive(pfc->efM11 ) )
        {
            pfc->flags |= (bPositive(pfc->efM22)) ?  FC_ORIENT_1 : FC_ORIENT_2;
        }
        else
        {
            pfc->flags |= (bPositive(pfc->efM22)) ?  FC_ORIENT_4 : FC_ORIENT_3;
        }

    }


    if( bIsZero(pfc->efM22) && bIsZero(pfc->efM11) )
    {

        if( bPositive(pfc->efM21 ) )
        {
            pfc->flags |= (bPositive(pfc->efM12)) ?  FC_ORIENT_5 : FC_ORIENT_6;
        }
        else
        {
            pfc->flags |= (bPositive(pfc->efM12)) ?  FC_ORIENT_7 : FC_ORIENT_8;
        }
    }



// Transform the base and the side vectors.  Should never overflow.

    ptl.x = 1;
    ptl.y = 0;

    bXformUnitVector(&ptl,
                     &xfm,
                     &pfc->vtflBase,
                     &pfc->pteUnitBase,
                     (pfc->flags & FC_SIM_EMBOLDEN) ? &pfc->ptqUnitBase : NULL,
                     &pfc->efBase);

    pfc->fxEmbolden = 0;

    if (pfc->flags & FC_SIM_EMBOLDEN)
    {
    // emboldening shift for vector fonts in not always one with vector fonts
    // It is computed as 1 * efBase. This is win31 compatible way of doing this

        pfc->fxEmbolden = ((lCvt(pfc->efBase, 1) + 8) & 0xfffffff0);
        if (pfc->fxEmbolden < 24)
        {
        // primitive "hinting", do not let it become zero

            pfc->fxEmbolden      = 16;
            pfc->pfxBaseOffset.x = FXTOL(pfc->ptqUnitBase.x.HighPart + 8);
            pfc->pfxBaseOffset.y = FXTOL(pfc->ptqUnitBase.y.HighPart + 8);

        // resolve mult of 45 degrees situations:

            if ((pfc->pfxBaseOffset.x == pfc->pfxBaseOffset.y) ||
                (pfc->pfxBaseOffset.x == -pfc->pfxBaseOffset.y) )
            {
                pfc->pfxBaseOffset.y = 0;
            }

            pfc->pfxBaseOffset.x = LTOFX(pfc->pfxBaseOffset.x);
            pfc->pfxBaseOffset.y = LTOFX(pfc->pfxBaseOffset.y);

            ASSERTDD(pfc->pfxBaseOffset.x || pfc->pfxBaseOffset.y, "x zero and y zero\n");
            ASSERTDD((pfc->pfxBaseOffset.x && pfc->pfxBaseOffset.y) == 0, "x * y not zero\n");
        }
        else
        {
            pfc->pfxBaseOffset.x = lCvt(pfc->vtflBase.x, 1);
            pfc->pfxBaseOffset.y = lCvt(pfc->vtflBase.y, 1);
        }
    }

// Transform the side vector.

    ptl.x = 0;
    ptl.y = -1;

    bXformUnitVector(&ptl, &xfm, &vtflTmp,
                     &pfc->pteUnitSide, NULL, &pfc->efSide);

    pfc->fxInkTop = fxLTimesEf(&pfc->efSide, pfc->pifi->fwdWinAscender);
    pfc->fxInkBottom = -fxLTimesEf(&pfc->efSide, pfc->pifi->fwdWinDescender);

    pfc->fxItalic = 0;
    if (pfc->flags & FC_SIM_ITALICIZE)
    {
        pfc->fxItalic
            = (fxLTimesEf(
                 &pfc->efBase,
                 (pfc->pifi->fwdWinAscender + pfc->pifi->fwdWinDescender + 1)/2
                 ) + 8) & 0xfffffff0 ;
    }


    return(TRUE);
}

/******************************Public*Routine******************************\
* HFC vtfdOpenFontContext
*
* Open a font context.  Store font transform and other requests for
* the realization of this font.
*
* History:
*  27-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

HFC vtfdOpenFontContext(FONTOBJ *pfo)
{
    PFONTFILE    pff = (PFONTFILE)pfo->iFile;
    PFONTCONTEXT pfc;
    BYTE         *pjView;
    DWORD        dwFirstCharOffset;

#ifdef DEBUGSIM
    DbgPrint("vtfdOpenFontContext, ulFont = %ld\n", ulFont);
#endif // DEBUGSIM

    if (pff == (PFONTFILE) NULL)
        return(HFC_INVALID);

// iFace is 1 based:

    if ((pfo->iFace < 1L) || (pfo->iFace > pff->cFace)) // pfo->iFace values are 1 based
        return(HFC_INVALID);

// increase the reference count of the font file, WE DO THIS ONLY WHEN
// WE ARE SURE that can not fail any more

// need to grab a sem for we will be looking into cRef now.

    if (pff->cRef == 0)
    {
    // need to remap the file into the memory again and update pointers:

        UINT  i;

        if (!EngMapFontFileFD(pff->iFile,(PULONG*)&pff->pvView, &pff->cjView))
        {
            WARNING("somebody removed the file\n");
            return (HFC_INVALID);
        }

        for (i = 0; i < pff->cFace; i++)
        {
            pff->afd[i].re.pvResData = (PVOID) (
                (BYTE*)pff->pvView + pff->afd[i].re.dpResData
                );
        }
    }

// remember this so that we do not have to read from the file
// after we allocate the memory for the font context. This simplifies
// clean up code in case of exception, i.e. disappearing font files.

    pjView = pff->afd[pfo->iFace-1].re.pvResData;
    dwFirstCharOffset = READ_DWORD(pjView + OFF_BitsOffset);

// Allocate memory for the font context.

    if ((pfc = pfcAlloc()) == (PFONTCONTEXT)NULL)
    {
        if (pff->cRef == 0)
        {
            EngUnmapFontFileFD(pff->iFile);
        }
        return(HFC_INVALID);
    }

// we MUST NOT not touch the memory mapped file past this point
// until the end of the routine. This is important for the
// proper clean up code in case of exception. [bodind]

    pfc->pre = &pff->afd[pfo->iFace-1].re;
    pfc->pifi = pff->afd[pfo->iFace-1].pifi;

// SET wendywu style flags

    pfc->flags = 0;

    if (pfo->flFontType & FO_SIM_BOLD)
        pfc->flags |= FC_SIM_EMBOLDEN;

    if (pfo->flFontType & FO_SIM_ITALIC)
        pfc->flags |= FC_SIM_ITALICIZE;

    pfc->dpFirstChar = dwFirstCharOffset;

// !!! Vector font file doesn't have the byte filler.  Win31 bug?

    //pfc->ajCharTable = pjView + OFF_jUnused20;

// Store the transform matrix.

    if ( !bInitXform(pfc, FONTOBJ_pxoGetXform(pfo)) )
    {
        WARNING("vtfdOpenFontContext transform out of range\n");

        if (pff->cRef == 0)
        {
            EngUnmapFontFileFD(pff->iFile);
        }
        vFree(pfc);
        return(HFC_INVALID);
    }

// State that the hff passed to this function is the FF selected in
// this font context.

    pfc->pff = pff;

    (pff->cRef)++;

    return((HFC)pfc);
}

/******************************Public*Routine******************************\
* vtfdDestroyFont
*
* Driver can release all resources associated with this font realization
* (embodied in the FONTOBJ).
*
* History:
*  02-Sep-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
vtfdDestroyFont (
    FONTOBJ *pfo
    )
{
//
// For the vector font driver, this is simply closing the font context.
// We cleverly store the font context handle in the FONTOBJ pvProducer
// field.
//
    EngAcquireSemaphore(ghsemVTFD);
    vtfdCloseFontContext((HFC) pfo->pvProducer);
    EngReleaseSemaphore(ghsemVTFD);
}


/******************************Public*Routine******************************\
* BOOL  vtfdCloseFontContext
*
* Close the font context and update the context link for the associated
* font file.
*
* History:
*  27-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

BOOL vtfdCloseFontContext(HFC hfc)
{
    BOOL bRet;

    if (hfc != HFC_INVALID)
    {
        //
        // decrement the reference count for the corresponding FONTFILE
        //

        if (PFC(hfc)->pff->cRef > 0L)
        {
            (PFC(hfc)->pff->cRef)--;

            //
            // if this file is going out of use we can close it to save memory
            //

            if (PFC(hfc)->pff->cRef == 0L)
            {
                // if FF_EXCEPTION_IN_PAGE_ERROR is set
                // and the font type is TYPE_FNT or TYPE_DLL16
                // the font file must have been unmapped in vVtfdMarkFontGone

                if (!(PFC(hfc)->pff->fl & FF_EXCEPTION_IN_PAGE_ERROR) ||
                    !((PFC(hfc)->pff->iType == TYPE_FNT) || (PFC(hfc)->pff->iType == TYPE_DLL16)))
                {
                    EngUnmapFontFileFD(PFC(hfc)->pff->iFile);
                }
                PFC(hfc)->pff->fl &= ~FF_EXCEPTION_IN_PAGE_ERROR;
            }

            //
            // free the memory associated with hfc
            //

            vFree(PFC(hfc));

            bRet = TRUE;
        }
        else
        {
            WARNING("vtfdCloseFontContext: cRef <= 0\n");
            bRet = FALSE;
        }

    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\tt\ttfd\tt.h ===
/******************************Module*Header*******************************\
* Module Name: tt.h
*
*  interface to the font scaler. Also defines some macros that should
* have been defined in the scaler *.h files
*
* Created: 17-Nov-1991 15:56:21
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/



// turns out that some of the macros that follow are already defined
// in some of the top include files that precede tt.h. Worse, these
// macros are defined DIFFERENTLY than in tt.h.
// We want to enforce that these macros when used in ttfd have the meaning
// defined in tt include files so that we have to kill the definitions
// inherited from anywhere else.


//!!! maybe this should go to scaler\config.h !!!!!!!!

#ifdef SWAPL
#undef SWAPL
#endif

#ifdef SWAPW
#undef SWAPW
#endif

// defined earlier, turns on the garbage in fserror.h

#ifdef XXX
#undef XXX
#endif

// defined earlier, use tt definition

#ifdef HIWORD
#undef HIWORD
#endif

// defined earlier, use tt definition

#ifdef LOWORD
#undef LOWORD
#endif

#include "FSERROR.H"
#include "FSCDEFS.H"    // inlcudes fsconfig.h
#include "FONTMATH.H"
#include "SFNT.H"       // includes sfnt_en.h
#include "FNT.H"
#include "INTERP.H"
#include "FNTERR.H"
#include "SFNTACCS.H"
#include "FSGLUE.H"
#include "SCENTRY.H"
#include "SBIT.H"
#include "FSCALER.H"
#include "SCGLOBAL.H"
#include "SFNTOFF.H"

// allowed specific ID's

#define SPEC_ID_UNDEFINED    0   // undefined char set or indexing scheme
#define SPEC_ID_UGL          1   // UGL char set with UNICODE indexing
#define SPEC_ID_SHIFTJIS     2   // SHIFTJIS mapping
#define SPEC_ID_GB           3   // GB mapping
#define SPEC_ID_BIG5         4   // BIG5 mapping
#define SPEC_ID_WANSUNG      5   // Hangeul WANSUNG mapping

// the same but in big endian format

// WINBUG 537635 claudebe 2/11/02, we should never use the following and always swap the bytes to handle IA64 unaligned tables
#define BE_SPEC_ID_UNDEFINED    0x0000   // undefined char set or indexing scheme
#define BE_SPEC_ID_UGL          0x0100   // UGL char set with UNICODE indexing
#define BE_SPEC_ID_SHIFTJIS     0x0200   // SHIFTJIS mapping
#define BE_SPEC_ID_GB           0x0300   // GB mapping
#define BE_SPEC_ID_BIG5         0x0400   // BIG5 mapping
#define BE_SPEC_ID_WANSUNG      0x0500   // Hangeul WANSUMG mapping

// platform id's, this is copied from sfnt_en.h

/*
*
* typedef enum {
*     plat_Unicode,
*     plat_Macintosh,
*     plat_ISO,
*     plat_MS
* } sfnt_PlatformEnum;
*
*/

#define  PLAT_ID_UNICODE   0
#define  PLAT_ID_MAC       1
#define  PLAT_ID_ISO       2
#define  PLAT_ID_MS        3

// the same but in big endian format

// WINBUG 537635 claudebe 2/11/02, we should never use the following and always swap the bytes to handle IA64 unaligned tables
#define  BE_PLAT_ID_UNICODE   0x0000
#define  BE_PLAT_ID_MAC       0x0100
#define  BE_PLAT_ID_ISO       0x0200
#define  BE_PLAT_ID_MS        0x0300


// language id's that are required to exhist in a ttf file:

#define LANG_ID_USENGLISH   0X0409  // for microsoft records
#define LANG_ID_MAC         0       // ENGLISH FOR MAC RECORDS

// the same but in big endian format

#define BE_LANG_ID_USENGLISH   0X0904  // for microsoft records
#define BE_LANG_ID_MAC         0X0000  // ENGLISH FOR MAC RECORDS


// allowed format values of the cmap tables:

// WINBUG 537635 claudebe 2/11/02, we should never use the following and always swap the bytes to handle IA64 unaligned tables
#define BE_FORMAT_MAC_STANDARD      0X0000
#define BE_FORMAT_HIGH_BYTE         0X0200
#define BE_FORMAT_MSFT_UNICODE      0X0400
#define BE_FORMAT_TRIMMED           0X0600

#define FORMAT_MAC_STANDARD      0
#define FORMAT_HIGH_BYTE         2
#define FORMAT_MSFT_UNICODE      4
#define FORMAT_TRIMMED           6

/*
*
* typedef enum {
*     name_Copyright,
*     name_Family,
*     name_Subfamily,
*     name_UniqueName,
*     name_FullName,
*     name_Version,
*     name_Postscript
* } sfnt_NameIndex;
*
*/

#if  0

#define NAME_ID_COPYRIGHT   0
#define NAME_ID_FAMILY      1
#define NAME_ID_SUBFAMILY   2
#define NAME_ID_UNIQNAME    3
#define NAME_ID_FULLNAME    4
#define NAME_ID_VERSION     5
#define NAME_ID_PSCRIPT     6
#define NAME_ID_TRADEMARK   7

#endif

// there are 19 tables (10 required + 9 optianal) defined in 1.0 revision
// of tt spec. We define this cut off arbitrarily (but bigger than 19)
// to get out of the loops rather than sit there and die;


#define MAX_TABLES 128

// size of some sfnt_xxx Structures as they are layed out on the disk:

#define SIZE_DIR_ENTRY        16
#define SIZE_NAMING_TABLE     6
#define SIZE_NAME_RECORD      12

// offsets into OS2 metrics table. Significant enough to be done by hand
// to ensure portability:

// original structure (from sfnt.h), version 0

/*
*
*
*   typedef struct {
*       uint16  Version;
*       int16   xAvgCharWidth;
*       uint16  usWeightClass;
*       uint16  usWidthClass;
*       int16   fsType;
*       int16   ySubscriptXSize;
*       int16   ySubscriptYSize;
*       int16   ySubscriptXOffset;
*       int16   ySubscriptYOffset;
*       int16   ySuperScriptXSize;
*       int16   ySuperScriptYSize;
*       int16   ySuperScriptXOffset;
*       int16   ySuperScriptYOffset;
*       int16   yStrikeOutSize;
*       int16   yStrikeOutPosition;
*       int16   sFamilyClass;
*       uint8   Panose [10];
*       uint32  ulCharRange [4];
*       char    achVendID [4];
*       uint16  usSelection;
*       uint16  usFirstChar;
*       uint16  usLastChar;
*   } sfnt_OS2;
*
*/



#define     OFF_OS2_Version               0
#define     OFF_OS2_xAvgCharWidth         2
#define     OFF_OS2_usWeightClass         4
#define     OFF_OS2_usWidthClass          6
#define     OFF_OS2_fsType                8
#define     OFF_OS2_ySubscriptXSize       10
#define     OFF_OS2_ySubscriptYSize       12
#define     OFF_OS2_ySubscriptXOffset     14
#define     OFF_OS2_ySubscriptYOffset     16
#define     OFF_OS2_ySuperScriptXSize     18
#define     OFF_OS2_ySuperScriptYSize     20
#define     OFF_OS2_ySuperScriptXOffset   22
#define     OFF_OS2_ySuperScriptYOffset   24
#define     OFF_OS2_yStrikeOutSize        26
#define     OFF_OS2_yStrikeOutPosition    28
#define     OFF_OS2_sFamilyClass          30
#define     OFF_OS2_Panose                32
#define     OFF_OS2_ulCharRange           42
#define     OFF_OS2_achVendID             58
#define     OFF_OS2_usSelection           62
#define     OFF_OS2_usFirstChar           64
#define     OFF_OS2_usLastChar            66


// these fields are defined in the spec but not in the sfnt.h structure above.
// I shall have to check whether these really exhist in tt files or not

#define     OFF_OS2_sTypoAscender         68
#define     OFF_OS2_sTypoDescender        70
#define     OFF_OS2_sTypoLineGap          72
#define     OFF_OS2_usWinAscent           74
#define     OFF_OS2_usWinDescent          76

// these two are added for version 200

#define     OFF_OS2_ulCodePageRange1      78
#define     OFF_OS2_ulCodePageRange2      82

#define     SIZE_OS2_VERSION_1            86

// values of some flags of the flag fields of the OS2 structure
//            taken from the tt spec


// fsType flags, notice bit 0x0001 is not used

#define TT_FSDEF_LICENSED        0x0002
#define TT_FSDEF_READONLY_ENCAPS 0x0004
#define TT_FSDEF_EDITABLE_ENCAPS 0x0008

#define TT_FSDEF_MASK  (TT_FSDEF_LICENSED|TT_FSDEF_READONLY_ENCAPS|TT_FSDEF_EDITABLE_ENCAPS)

// usSelection

#define TT_SEL_ITALIC            0x0001
#define TT_SEL_UNDERSCORE        0x0002
#define TT_SEL_NEGATIVE          0x0004
#define TT_SEL_OUTLINED          0x0008
#define TT_SEL_STRIKEOUT         0x0010
#define TT_SEL_BOLD              0x0020
#define TT_SEL_REGULAR           0x0040

//
// Macro to extract the big endian word at pj, really
// the correct equivalent of SWAPW macro, which does not assume
// that pj is word aligned.
//

#define BE_UINT16(pj)                                \
    (                                                \
        ((USHORT)(((PBYTE)(pj))[0]) << 8) |          \
        (USHORT)(((PBYTE)(pj))[1])                   \
    )


#define BE_INT16(pj)  ((SHORT)BE_UINT16(pj))


//
// macro to extract the big endian dword at pj, really
// a the correct equivalent of SWAPL macro, which does not assume
// that pj is DWORD aligned
//


#define BE_UINT32(pj)                                              \
    (                                                              \
        ((ULONG)BE_UINT16(pj) << 16) |                             \
        (ULONG)BE_UINT16((PBYTE)(pj) + 2)                          \
    )


#define BE_INT32(pj) ((LONG)BE_UINT32(pj))

// number of tt tables may change as we decide to add more tables to
// tt files, this list is extracted from sfnt_en.h

// required tables

//   tag_CharToIndexMap              // 'cmap'    0
//   tag_GlyphData                   // 'glyf'    1
//   tag_FontHeader                  // 'head'    2
//   tag_HoriHeader                  // 'hhea'    3
//   tag_HorizontalMetrics           // 'hmtx'    4
//   tag_IndexToLoc                  // 'loca'    5
//   tag_MaxProfile                  // 'maxp'    6
//   tag_NamingTable                 // 'name'    7
//   tag_Postscript                  // 'post'    8
//   tag_OS_2                        // 'OS/2'    9

// optional

//   tag_ControlValue                // 'cvt '    11
//   tag_FontProgram                 // 'fpgm'    12
//   tag_HoriDeviceMetrics           // 'hdmx'    13
//   tag_Kerning                     // 'kern'    14
//   tag_LTSH                        // 'LTSH'    15
//   tag_PreProgram                  // 'prep'    16
//   tag_GridfitAndScanProc          // 'gasp'    21
//   tag_BitmapLocation              // 'EBLC'    

//!!! not in the tt spec, but in defined in sfnt_en.h

//   tag_GlyphDirectory              // 'gdir'    17
//   tag_Editor0                     // 'edt0'    18
//   tag_Editor1                     // 'edt1'    19
//   tag_Encryption                  // 'cryp'    20

// REQUIRED TABLES

#define IT_REQ_CMAP    0
#define IT_REQ_GLYPH   1
#define IT_REQ_HEAD    2
#define IT_REQ_HHEAD   3
#define IT_REQ_HMTX    4
#define IT_REQ_LOCA    5
#define IT_REQ_MAXP    6
#define IT_REQ_NAME    7

#define C_REQ_TABLES   8

// optional tables

#define IT_OPT_OS2     0
#define IT_OPT_HDMX    1
#define IT_OPT_VDMX    2
#define IT_OPT_KERN    3
#define IT_OPT_LTSH    4
#define IT_OPT_POST    5
#define IT_OPT_GASP    6
#define IT_OPT_MORT    7 
#define IT_OPT_GSUB    8
#define IT_OPT_VMTX    9
#define IT_OPT_VHEA    10
#define IT_OPT_EBLC    11
#define C_OPT_TABLES   12

/*

// there are more optional tables, but ttfd is not
// using them so we are eliminating these from the code

#define IT_OPT_CVT
#define IT_OPT_FPGM
#define IT_OPT_PREP

// these are not mentioned in the spec (unless
// they are mentioned under a different name) but tags
// for them exhist in sfnt_en.h

#define IT_OPT_GDIR
#define IT_OPT_EDT0
#define IT_OPT_EDT1
#define IT_OPT_ENCR
#define IT_OPT_FOCA
#define IT_OPT_WIN

//!!! these ARE mentioned in the spec, but I found no tags for them
//!!! in the sfnt_en.h include file [bodind], I am putting the tags
//!!! here for now, until they are added to sfnt_en.h

*/



#define tag_Vdmx      0x56444d58
#define tag_Foca      0x666f6361
#define tag_Win       0x0077696e
// for far east support
#define tag_mort      0x6d6f7274 
#define tag_GSUB      0x47535542
#define tag_DSIG      'DSIG'

typedef struct _TABLE_ENTRY // te
{
    ULONG dp;  // offset to the beginning of the table
    ULONG cj;  // size of the table
} TABLE_ENTRY, *PTABLE_ENTRY;


typedef struct _TABLE_POINTERS // tptr
{
    TABLE_ENTRY ateReq[C_REQ_TABLES];
    TABLE_ENTRY ateOpt[C_OPT_TABLES];
} TABLE_POINTERS, *PTABLE_POINTERS;


// jeanp's functions

uint16 ui16UnicodeToMac (uint16 wc);
uint16 ui16Mac2Lang (uint16 Id);

#define CHAR_CODE(bToMac,wc)                                \
(                                                           \
(bToMac) ? ui16UnicodeToMac((uint16)(wc)) : (uint16)(wc)    \
)

// convert "os2" language id to the mac style lang id if this is a mac file

#define  CV_LANG_ID(ui16PlatformID, Id)                               \
(                                                                     \
(ui16PlatformID == BE_PLAT_ID_MS) ? (Id) : ui16Mac2Lang((uint16)(Id)) \
)

// magic number in big endian

#define BE_SFNT_MAGIC   0xF53C0F5F

// in order to understand this structure one needs to know
// the format of the table pmap  which is as follows
//
// typedef struct {
//     uint16 format;
//     uint16 length;
//     uint16 version;

// the three fields above are common for all formats

//     uint16 segCountX2;
//     uint16 searchRange;
//     uint16 entrySelector;
//     uint16 rangeShift;
//     uint16 endCount[segCount];
//     uint16 reservedPad;         // only God knows why
//     uint16 startCount[segCount];
//     uint16 idDelta[segCount];
//     uint16 idRangeOffset[segCount];
//     uint16 glyphIdArray[1];     // arbitrary length
// } CMAP_TABLE_IN_MSFT_FORMAT;
//
// Not all of these fields are relevant for us,
// we shall only need few of them. Their offsets
// from the beginning of the structure are as follows:
//

// cmap table  size and offsets

#define SIZEOF_CMAPTABLE  (3 * sizeof(uint16))

#define OFF_cmap_SubTableDir  4
#define CMAP_sizeof_SubTableDir  8

// space for format, subHeaderKeys[256] and one subHeader
#define CMAP_minimal_sizeof_SubTableDir_Format2  (6 + 256 * 2 + 4 * 2)

#define OFF_segCountX2  6
#define OFF_endCount    14


//
// offsets within kerning table
//

#define KERN_OFFSETOF_TABLE_VERSION             0
#define KERN_OFFSETOF_TABLE_NTABLES             1 * sizeof(USHORT)
#define KERN_SIZEOF_TABLE_HEADER                2 * sizeof(USHORT)

//
// offsets within a kerning sub table
//

#define KERN_OFFSETOF_SUBTABLE_VERSION          0
#define KERN_OFFSETOF_SUBTABLE_LENGTH           1 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_COVERAGE         2 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_NPAIRS           3 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_SEARCHRANGE      4 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_ENTRYSELECTOR    5 * sizeof(USHORT)
#define KERN_OFFSETOF_SUBTABLE_RANGESHIFT       6 * sizeof(USHORT)
#define KERN_SIZEOF_SUBTABLE_HEADER             7 * sizeof(USHORT)

#define KERN_OFFSETOF_ENTRY_LEFT                0
#define KERN_OFFSETOF_ENTRY_RIGHT               1 * sizeof(USHORT)
#define KERN_OFFSETOF_ENTRY_VALUE               2 * sizeof(USHORT)
#define KERN_SIZEOF_ENTRY                       2 * sizeof(USHORT) + sizeof(FWORD)

#define KERN_OFFSETOF_SUBTABLE_FORMAT           KERN_OFFSETOF_SUBTABLE_COVERAGE

#define KERN_WINDOWS_FORMAT                     0


// these functions are candidates to be bracketed the try/except


// FS_ENTRY fs_NewSfnt           (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_NewTransformation (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_NewGlyph          (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_GetAdvanceWidth   (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourGridFit    (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourNoGridFit  (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_FindBitMapSize    (fs_GlyphInputType *, fs_GlyphInfoType *);
// FS_ENTRY fs_ContourScan       (fs_GlyphInputType *, fs_GlyphInfoType *);




#define MAX_UINT8    0xff
#define MAX_INT8     0x7f
#define MIN_INT8     (-0x7f)
#define B_INT8(x)    (((x) <= MAX_INT8) && ((x) >= MIN_INT8))

#define MAX_UINT16   0xffff
#define MAX_INT16    0x7fff
#define MIN_INT16    (-0x7fff)
#define B_INT16(x)   (((x) <= MAX_INT16) && ((x) >= MIN_INT16))

#define MAX_UINT32  0xffffffff
#define MAX_INT32   0x7fffffff
#define MIN_INT32   (-0x7fffffff)
#define B_INT32(x)   (((x) <= MAX_INT32) && ((x) >= MIN_INT32))

typedef struct 
{
    int32   version;
    int16   ascent;
    int16   descent;
    int16   lineGap;
    int16   advanceHeightMax;
    int16   minTopSideBearing;
    int16   minBottomSideBearing;
    int16   yMaxExtent;
    int16   caretSlopeRise;
    int16   caretSlopeRun;
    int16   caretOffset;
    int16   reserved1;
    int16   reserved2;
    int16   reserved3;
    int16   reserved4;
    int16   metricDataFormat;
    uint16  numOfLongVerMetrics;
} sfnt_vheaTable;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\vtfd\fdquery.c ===
/******************************Module*Header*******************************\
* Module Name: fdquery.c
*
* Contains all the vtfdQueryXXX functions.  Adapted from BodinD's bitmap font
* driver.
*
* Copyright (c) 1990-1995 Microsoft Corporation
\**************************************************************************/

#include "fd.h"
#include "exehdr.h"

#define OFF_CharWidth   2       //!!!Move to winfont.h
                                //!!!Define OFF_CharTable10

// Retrieve description string from .FON files.

BOOL bDescStr (PVOID pvView, SIZE_T cjView, PSZ pszString);

//
// Function prototypes.
//

ULONG
cjVtfdDeviceMetrics (
    PFONTCONTEXT     pfc,
    FD_DEVICEMETRICS *pdevm
    );

VOID
vFill_GlyphData (
    PFONTCONTEXT pfc,
    GLYPHDATA *pgldt,
    UINT iIndex
    );

BOOL
bCreatePath (
    PCHAR pch,
    PCHAR pchEnd,
    PFONTCONTEXT pfc,
    PATHOBJ *ppo,
    FIX fxAB
    );

VOID
vFill_GlyphData (
    PFONTCONTEXT pfc,
    GLYPHDATA *pgldt,
    UINT iIndex
    );

#if defined(_AMD64_) || defined(_IA64_)
#define lCvt(ef, l) ((LONG) (ef * l))
#else
LONG lCvt(EFLOAT ef,LONG l);
#endif

//!!! this function is living in ttfd. should be moved to the engine [bodind]

VOID vAddPOINTQF(POINTQF *, POINTQF *);



/******************************Public*Routine******************************\
*
* BOOL bReconnectVtfdFont(FONTFILE *pff)
*
*
* Effects: If the file is marked gone, we try to reconnect and see if we can
*          use it again. We clear the exception bit so that the system will
*          be able to use this font again.
*
* History:
*  17-Aug-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bReconnectVtfdFont(FONTFILE *pff)
{
    INT i;

    if ((pff->iType == TYPE_FNT) || (pff->iType == TYPE_DLL16))
    {

        if (!EngMapFontFileFD(pff->iFile, (PULONG*)&pff->pvView, &pff->cjView ))
        {
            WARNING("can not reconnect this vector font !!!\n");
            return FALSE;
        }

        for (i = 0; i < (INT)pff->cFace; i++)
        {
            pff->afd[i].re.pvResData = (PVOID) (
                (BYTE*)pff->pvView + pff->afd[i].re.dpResData
                );
        }
    }
    else
    {
        return FALSE;
    }

// everything is fine again, clear the bit

    pff->fl &= ~FF_EXCEPTION_IN_PAGE_ERROR;
    return TRUE;
}





/******************************Public*Routine******************************\
* PIFIMETRICS vtfdQueryFont
*
* Return a pointer to the IFIMETRICS for the given face.
*
* History:
*  31-Aug-1992 Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

PIFIMETRICS vtfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR  *pid
    )
{
    PFONTFILE pff;

//
// Validate handle.
//
    if (hff == HFF_INVALID)
    {
        WARNING("vtfdQueryFaces(): invalid iFile (hff)\n");
        return (PIFIMETRICS) NULL;
    }

//
// We never unlock FONTFILE since it contains IFIMETRICS that engine
// has a pointer to.  hff is actually a pointer to the FONTFILE struct.
//
    pff = (PFONTFILE)hff;

//
// Assume iFace within bounds.
//
    ASSERTDD((iFace >= 1L) && (iFace <= pff->cFace),
             "vtfdQueryFaces: iFace out of range\n");

//
// Return pointer to IFIMETRICS.
//
    return pff->afd[iFace-1].pifi;
}

/******************************Public*Routine******************************\
* LONG vtfdQueryFontCaps
*
* Retrieve the capabilities of the font driver.
*
* History:
*  26-Feb-1992 -by- Wendy Wu [wendywu]
* Adapted from bmfd.
\**************************************************************************/

LONG vtfdQueryFontCaps (
    ULONG  culCaps,
    PULONG pulCaps
    )
{
    ASSERTDD(culCaps == 2, "ERROR - come on - update the font drivers");
    pulCaps[0] = 2L;

    //
    // The vector font driver only returns outlines.
    //

    pulCaps[1] = QC_OUTLINES;
    return(2);
}

/******************************Public*Routine******************************\
* vtfdQueryFontTree
*
* This function returns pointers to per-face information.
*
* Parameters:
*
*   dhpdev      Not used.
*
*   hff         Handle to a font file.
*
*   iFace       Index of a face in the font file.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFT_LIGATURES -- returns a pointer to the ligature map.
*
*       QFT_KERNPAIRS -- return a pointer to the kerning pair table.
*
*       QFT_GLYPHSET  -- return a pointer to the WC->HGLYPH mapping table.
*
*   pid         Not used.
*
* Returns:
a   Returns a pointer to the requested data.  This data will not change
*   until VtfdfdFree is called on the pointer.  Caller must not attempt to
*   modify the data.  NULL is returned if an error occurs.
*
* History:
*  31-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID
vtfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR   *pid
    )
{
    PFONTFILE pff;

//
// Validate parameters.
//
    if (hff == HFF_INVALID)
    {
        WARNING("vtfdQueryFontTree(): invalid iFile (hff)\n");
        return ((PVOID) NULL);
    }

//
// Convert from handle to pointer.
//
    pff = (PFONTFILE)hff;

    // Note: ulFont values are index-1 based.

    if ((iFace < 1L) || (iFace > pff->cFace))
    {
        WARNING("vtfdQueryFontTree()\n");
        return (NULL);
    }

//
// Which mode?
//
    switch (iMode)
    {
    case QFT_LIGATURES:
    case QFT_KERNPAIRS:

    //
    // There are no ligatures or kerning pairs for the vector fonts,
    // therefore we return NULL
    //
        return ((PVOID) NULL);

    case QFT_GLYPHSET:

        return &pff->afd[iFace - 1].pcp->gset;

    default:

    //
    // Should never get here.
    //
    RIP("gdisrv!vtfdQueryFontTree(): unknown iMode\n");
        return ((PVOID) NULL);
    }
}


/******************************Public*Routine******************************\
* vtfdQueryFontData
*
*   dhpdev      Not used.
*
*   pfo         Pointer to a FONTOBJ.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFD_GLYPH           -- return glyph metrics only
*
*       QFD_GLYPHANDBITMAP  -- return glyph metrics and bitmap
*
*       QFD_GLYPHANDOUTLINE -- return glyph metrics and outline
*
*       QFD_MAXEXTENTS      -- return FD_DEVICEMETRICS structure
*
*       QFD_MAXGLYPHBITMAP  -- return size of largest glyph AND its metrics
*
*   cData       Count of data items in the pvIn buffer.
*
*   pvIn        An array of glyph handles.
*
*   pvOut       Output buffer.
*
* Returns:
*   If mode is QFD_MAXGLYPHBITMAP, then size of glyph metrics plus
*   largest bitmap is returned.
*
*   Otherwise, if pvOut is NULL, function will return size of the buffer
*   needed to copy the data requested; else, the function will return the
*   number of bytes written.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  31-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG
vtfdQueryFontData (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    PFONTCONTEXT pfc;
    PBYTE        ajHdr;
    UINT         iIndex, iIndexNext, offset1, offset2;
    PCHAR        pch, pchEnd;
    PATHOBJ      *ppo;
    PBYTE        pjFirstChar, ajCharTable;
    GLYPHDATA    gd;

// MAKE sure that the file is not gone

    if (PFF(pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // file gone, try to reconnect, if can not reconnect,
    // no questions will be answered about it:

        if (!bReconnectVtfdFont(PFF(pfo->iFile)))
        {
            WARNING("vtfdQueryFontData: EXCEPTION_IN_PAGE_ERROR\n");
            return FD_ERROR;
        }
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
        pfo->pvProducer = (PVOID) vtfdOpenFontContext(pfo);

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        WARNING("vtfdQueryFontData: pvProducer\n");
        return FD_ERROR;
    }

    pfc = (PFONTCONTEXT) pfo->pvProducer;

// Setup local pointers to font file header. Note that these
// could not be saved at fc creation time, for they could have changed
// after net went down and back up again after reconnecting. [bodind]

    ajHdr = pfc->pre->pvResData;
    pjFirstChar = ajHdr + pfc->dpFirstChar;
    ajCharTable = ajHdr + OFF_jUnused20;

// What mode?

    switch (iMode)
    {

    case QFD_GLYPHANDOUTLINE:
        {

        //
        // Grab pointer to PATHOBJ* array.
        //
            ppo = (PATHOBJ *)pv;


        //
        // Assume the engine will not pass an invalid handle.
        //
            ASSERTDD(hg != HGLYPH_INVALID,
                    "vtfdQueryFontData(QFD_GLYPHANDOUTLINE): invalid hglyph\n");

        //
        // Use default glyph if hglyph out of range.
        //
            if (hg > (HGLYPH)(ajHdr[OFF_LastChar] - ajHdr[OFF_FirstChar]))
                iIndex = ajHdr[OFF_DefaultChar];
            else
                iIndex = hg;

        //
        // Fill in the GLYPHDATA structure.
        //
        if( pgd == NULL )
        {
            pgd = &gd;
        }

        vFill_GlyphData(pfc, pgd, iIndex);
        pgd->hg = hg;

        //
        // Construct the path.
        //
            if (ppo != NULL)
            {
                iIndexNext = iIndex + 1;

                if (pfc->pifi->flInfo & FM_INFO_CONSTANT_WIDTH)
                {
                    iIndex <<= 1;           // each entry is 2-byte long
                    iIndexNext <<= 1;
                }
                else
                {
                    iIndex <<= 2;           // each entry is 4-byte long
                    iIndexNext <<= 2;
                }

                offset1 = READ_WORD(&ajCharTable[iIndex]);
                offset2 = READ_WORD(&ajCharTable[iIndexNext]);

                if ((offset2 < offset1) || (pfc->dpFirstChar + offset2 > pfc->pre->cjResData))
                {
                    WARNING("vtfd!vtfdQueryFontData: offset to path out of file\n");
                    return FD_ERROR;
                }

                pch = pjFirstChar + offset1;
                pchEnd = pjFirstChar + offset2;

                ASSERTDD((*pch == PEN_UP),
                   "vtfdQueryFontData(QFD_GLYPHANDOUTLINE): First command is not PEN_UP");

                if ( !bCreatePath(pch, pchEnd, pfc, ppo, pgd->fxAB) )
                {
                    return FD_ERROR;
                }
            }
        }

    //
    // Return buffer size needed for all GLYPHDATA.
    //
        return 0;

    case QFD_MAXEXTENTS:
    //
    // If buffer NULL, return size.
    //
        if ( pv == (PVOID) NULL )
            return (sizeof(FD_DEVICEMETRICS));

    //
    // Otherwise, copy the data structure.
    //
        else
            return cjVtfdDeviceMetrics(pfc, (FD_DEVICEMETRICS *) pv);

    default:

        WARNING("vtfdQueryFontData(): unsupported mode\n");
        return FD_ERROR;
    }
}


/******************************Public*Routine******************************\
* vtfdQueryFontFile
*
* A function to query per font file information.
*
* Parameters:
*
*   hff         Handle to a font file.
*
*   ulMode      This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFF_DESCRIPTION -- copies a UNICODE string in the buffer
*                          that describes the contents of the font file.
*
*       QFF_NUMFACES   -- returns number of faces in the font file.
*
*   cjBuf       Maximum number of BYTEs to copy into the buffer.  The
*               driver will not copy more than this many BYTEs.
*
*               This should be zero if pulBuf is NULL.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
*   pulBuf      Pointer to the buffer to receive the data
*               If this is NULL, then the required buffer size
*               is returned as a count of BYTEs.  Notice that this
*               is a PULONG, to enforce 32-bit data alignment.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
* Returns:
*
*   If mode is QFF_DESCRIPTION, then the number of BYTEs copied into
*   the buffer is returned by the function.  If pulBuf is NULL,
*   then the required buffer size (as a count of BYTEs) is returned.
*
*   If mode is QFF_NUMFACES, then number of faces in font file is returned.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  09-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG vtfdQueryFontFile (
    HFF     hff,        // handle to font file
    ULONG   ulMode,     // type of query
    ULONG   cjBuf,      // size of buffer (in BYTEs)
    PULONG  pulBuf      // return buffer (NULL if requesting size of data)
    )
{
//
// We never unlock FONTFILE since it contains IFIMETRICS that the engine
// has a pointer to.  hff is actually a pointer to the FONTFILE struct.
//
    ULONG     cjDescription;
    PVOID       pvView;
    ULONG       cjView;
    PIFIMETRICS pifi;
    LPWSTR      pwszDescription;

    ASSERTDD(hff, "vtfdQueryFontFile, hff invalid\n");

    if (PFF(hff)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // file gone, try to reconnect, if can not reconnect,
    // no questions will be answered about it:

        if (!bReconnectVtfdFont(PFF(hff)))
        {
            WARNING("vtfdQueryFontFile: EXCEPTION_IN_PAGE_ERROR\n");
            return FD_ERROR;
        }
    }

//
// Which mode?
//
    switch (ulMode)
    {
    case QFF_DESCRIPTION:
    //
    // If .FON format, retrieve the description string from the mapped file view.
    //
        if (PFF(hff)->iType == TYPE_DLL16)
        {
            CHAR achDescription[256];   // max length of string in the 16-bit EXE.

        // check, maybe cRef is 0 so that fvw is not valid:

            if (PFF(hff)->cRef == 0)
            {
                if (!EngMapFontFileFD(PFF(hff)->iFile,(PULONG*)&pvView,&cjView))
                {
                    WARNING("somebody removed the file \n");
                    return FD_ERROR;
                }
            }
            else
            {
                pvView = PFF(hff)->pvView;
                cjView = PFF(hff)->cjView;
            }

            cjDescription = FD_ERROR;
            if (bDescStr(pvView, cjView, achDescription))
            {
                cjDescription = (strlen(achDescription) + 1) * sizeof(WCHAR);

            //
            // If there is a buffer, copy the data.
            //
                if ( pulBuf != (PULONG) NULL )
                {
                //
                // Is buffer big enough?
                //
                    if ( cjBuf < cjDescription )
                    {
                        WARNING("vtfdQueryFontFile(): buffer too small for string\n");
                        return (FD_ERROR);
                    }
                    else
                    {
                        vToUNICODEN((LPWSTR)pulBuf, cjDescription/sizeof(WCHAR), achDescription, cjDescription/sizeof(WCHAR));
                    }
                }

            }

        // clean up if need be

            if (PFF(hff)->cRef == 0)
                EngUnmapFontFileFD(PFF(hff)->iFile);

            return(cjDescription);
        }

    //
    // Otherwise, .FNT files do not have a description string.  We may also
    // get here if its a .FON format but bDescStr failed.  We will have
    // to use the facename.
    //

    //
    // Get ptr to the facename in the IFIMETRICS of the first font
    // in this font file.
    //
        pifi = PFF(hff)->afd[0].pifi;
        pwszDescription = (LPWSTR)((PBYTE) pifi + pifi->dpwszFaceName);
        cjDescription = (wcslen(pwszDescription) + 1) * sizeof(WCHAR);

    //
    // If there is a buffer, copy to it.
    //
        if ( pulBuf != (PULONG) NULL )
        {
        //
        // Is buffer big enough?
        //
            if ( cjBuf < cjDescription )
            {
                WARNING("vtfdQueryFontFile(): buffer too small for face\n");
                return (FD_ERROR);
            }
            else
            {
                RtlCopyMemory((PVOID) pulBuf,
                              (PVOID) pwszDescription,
                              cjDescription);
            }
        }

        return(cjDescription);

    case QFF_NUMFACES:

        return PFF(hff)->cFace;

    default:
        WARNING("vtfdQueryFontFile(): unknown mode\n");
        break;
    }

        // Default return.  We should not get here.
    return FD_ERROR;
}


/******************************Public*Routine******************************\
* cjVtfdDeviceMetrics
*
*
* Effects:
*
* Warnings:
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Stole it from WendyWu's FdQueryFaceAttr() implementation.
\**************************************************************************/

ULONG
cjVtfdDeviceMetrics (
    PFONTCONTEXT     pfc,
    FD_DEVICEMETRICS *pdevm
    )
{
    PIFIMETRICS   pifi;
    EFLOAT efM11, efM12, efM21, efM22;
    BOOL bScaleOnly;

// Compute the accelerator flags for this font.

    pdevm->flRealizedType = 0; // no bitmaps are produced

    if ((pfc->flags & FC_SIM_ITALICIZE) == 0)
        pdevm->flRealizedType |= FDM_TYPE_ZERO_BEARINGS;

// Make sure nobody updates the font context when we're reading from it.
// !!! not possible, ResetFontContext is gone, [BODIND]

    efM11 = pfc->efM11;
    efM12 = pfc->efM12;
    efM21 = pfc->efM21;
    efM22 = pfc->efM22;

    pdevm->pteBase = pfc->pteUnitBase;
    pdevm->pteSide = pfc->pteUnitSide;

// fxMaxAscender/Descender are the distance from the baseline to the
// top/bottom of the glyph.  fxInkTop/Bottom are vectors along the
// ascent direction.  We need to adjust the sign properly.

    pdevm->fxMaxAscender = pfc->fxInkTop;
    pdevm->fxMaxDescender = -pfc->fxInkBottom;

    bScaleOnly = pfc->flags & FC_SCALE_ONLY;

    pdevm->cxMax = (ULONG)
        ((fxLTimesEf(&pfc->efBase, (LONG)pfc->pifi->fwdMaxCharInc) + 8) >> 4);

// Transform the character increment vector.

    if
    (
    // only report accellerators for horiz case

        (pfc->pifi->flInfo & FM_INFO_CONSTANT_WIDTH) &&
        (pfc->flags & FC_SCALE_ONLY)
    )
    {
        pdevm->lD = (LONG)pdevm->cxMax;
    }
    else // var pitch
    {
        pdevm->lD = 0;
    }

// Transform the StrikeOut and Underline vectors.

    pifi = pfc->pifi;
    pdevm->ptlUnderline1.y  = FXTOLROUND(fxLTimesEf(&efM22, -pifi->fwdUnderscorePosition));
    pdevm->ptlStrikeOut.y   = FXTOLROUND(fxLTimesEf(&efM22, -pifi->fwdStrikeoutPosition));

    pdevm->ptlULThickness.y = pdevm->ptlSOThickness.y = 1;
    pdevm->ptlULThickness.x = pdevm->ptlSOThickness.x = 0;

    if (pfc->flags & FC_SIM_EMBOLDEN)
        pdevm->ptlULThickness.y = pdevm->ptlSOThickness.y = 2;

    if (bScaleOnly)
    {
        pdevm->ptlUnderline1.x = pdevm->ptlStrikeOut.x = 0;

        if (!bPositive(efM22))
        {
            pdevm->ptlULThickness.y = -pdevm->ptlULThickness.y;
            pdevm->ptlSOThickness.y = -pdevm->ptlSOThickness.y;
        }
    }
    else
    {
    // !!!Cache this in HDC if underline or strikeout are used often.

        pdevm->ptlULThickness.x = FXTOLROUND(fxLTimesEf(&efM21, pdevm->ptlULThickness.y));
        pdevm->ptlULThickness.y = FXTOLROUND(fxLTimesEf(&efM22, pdevm->ptlULThickness.y));
        pdevm->ptlSOThickness.x = pdevm->ptlULThickness.x;
        pdevm->ptlSOThickness.y = pdevm->ptlULThickness.y;

        pdevm->ptlUnderline1.x  = FXTOLROUND(fxLTimesEf(&efM21, -pifi->fwdUnderscorePosition));
        pdevm->ptlStrikeOut.x   = FXTOLROUND(fxLTimesEf(&efM21, -pifi->fwdStrikeoutPosition));
    }

// devm, no bitmaps are supported;

    pdevm->cyMax = 0;
    pdevm->cjGlyphMax = 0;

    return(sizeof(FD_DEVICEMETRICS));
}


/******************************Private*Routine*****************************\
* VOID vFill_GlyphData
*
* Fill in the GLYPHDATA structure for the given glyph index.
*
* History:
*  18-Feb-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID vFill_GlyphData(PFONTCONTEXT pfc, GLYPHDATA *pgldt, UINT iIndex)
{
    LONG   lCharInc;
    PBYTE  ajCharTable = (PBYTE)pfc->pre->pvResData + OFF_jUnused20;

    pgldt->gdf.pgb = NULL;
    pgldt->hg = iIndex;                                 //!!!????

// Transform the character increment vector.

    if (pfc->pifi->flInfo & FM_INFO_CONSTANT_WIDTH)
    {
        lCharInc = pfc->pifi->fwdMaxCharInc;
    }
    else
    {
    // We're dealing with variable-width font, get the width from
    // the chartable.  Each entry in CharTable is 4-byte long.

        lCharInc = READ_WORD(ajCharTable + OFF_CharWidth + (iIndex << 2));
    }

    pgldt->fxInkTop = pfc->fxInkTop;
    pgldt->fxInkBottom = pfc->fxInkBottom;

    if (pfc->flags & FC_SCALE_ONLY)
    {
    // here we do rounding to be compat with windows 31, and also to
    // so that we can report the accelerator pdevm->lD  for fixed pitch
    // font as being really equal  to fxD's for such a font

        pgldt->fxD = ((fxLTimesEf(&pfc->efBase, lCharInc) + 8) & 0xfffffff0);

    // Simple scaling transform.

        if (pfc->flags & FC_X_INVERT)
            pgldt->ptqD.x.HighPart = -pgldt->fxD;
        else
            pgldt->ptqD.x.HighPart = pgldt->fxD;

        pgldt->ptqD.x.LowPart = 0;
        pgldt->ptqD.y.HighPart = 0;
        pgldt->ptqD.y.LowPart = 0;

    }
    else
    {
    // in this case we do not do rounding, we want everything consistent:

        pgldt->fxD = fxLTimesEf(&pfc->efBase, lCharInc);

    // Non trivial transform.

        vLTimesVtfl(lCharInc, &pfc->vtflBase, &pgldt->ptqD);
    }

//!!! not sure if these should be calculated differently for non-trivial cases.

    pgldt->fxA = 0;
    pgldt->fxAB = pgldt->fxD;

    if (pfc->flags & FC_SIM_EMBOLDEN)
    {
        pgldt->fxAB += pfc->fxEmbolden;
    }

    if (pfc->flags & FC_SIM_ITALICIZE)
    {
        pgldt->fxAB += pfc->fxItalic;
    }

//!!! rclInk is missing, but not needed I guess (bodind)

}

/******************************Public*Routine******************************\
* vtfdQueryAdvanceWidths                                                   *
*                                                                          *
* A routine to compute advance widths.                                     *
*                                                                          *
* History:                                                                 *
*  Mon 18-Jan-1993 08:13:02 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL vtfdQueryAdvanceWidths
(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    FONTCONTEXT *pfc;
    USHORT      *psWidths = (USHORT *) plWidths;   // True for the cases we handle.
    LONG     dx;
    ULONG    ii;
    PBYTE  ajCharTable;

    if (PFF(pfo->iFile)->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
    // file gone, try to reconnect, if can not reconnect,
    // no questions will be answered about it:

        if (!bReconnectVtfdFont(PFF(pfo->iFile)))
        {
            WARNING("vtfdQueryAdvanceWidths: EXCEPTION_IN_PAGE_ERROR\n");
            return FD_ERROR;
        }
    }

// If pfo->pvProducer is NULL, then we need to open a font context.

    if ( pfo->pvProducer == (PVOID) NULL )
        pfo->pvProducer = (PVOID) vtfdOpenFontContext(pfo);

    if ( pfo->pvProducer == (PVOID) NULL )
    {
        WARNING("vtfdQueryAdvanceWidths: pvProducer\n");
        return FD_ERROR;
    }

    pfc = (FONTCONTEXT *) pfo->pvProducer;
    ajCharTable = (PBYTE)pfc->pre->pvResData + OFF_jUnused20;

    ASSERTDD(!(pfc->pifi->flInfo & FM_INFO_CONSTANT_WIDTH),
             "this is a fixed pitch font\n");

    // only report accellerators

    ASSERTDD((pfc->flags & FC_SCALE_ONLY),
             "must not be a rotating xform\n");

// Get the widths.

    for (ii=0; ii<cGlyphs; ii++,phg++,psWidths++)
    {
        dx = READ_WORD(ajCharTable + OFF_CharWidth + (*phg << 2));
        *psWidths = (SHORT) ((lCvt(pfc->efBase,dx) + 8) & 0xfffffff0);
    }
    return(TRUE);
}


/******************************Private*Routine*****************************\
* BOOL bCreatePath
*
* Create a path by reading the vector descriptions contained in the
* memory space pointed to between pch and pchEnd.
*
* History:
*  18-Feb-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

#define CPTS_MAX        5

BOOL
bCreatePath(
    PCHAR pch,
    PCHAR pchEnd,
    PFONTCONTEXT pfc,
    PATHOBJ *ppo,
    FIX fxAB)
{
    UINT        iPt, cPts = 0;
    LONG        lXLast, lDesc;
    POINTL      aptl[CPTS_MAX];
    POINTFIX    aptfx[CPTS_MAX];
    BOOL        bEmbolden, bItalicize, bScaleOnly, bReturn = TRUE;
    EFLOAT      efM11, efM12, efM21, efM22;
    POINTFIX    pfxBaseOffset;
    POINTFIX    ptfxBound;

    efM11 = pfc->efM11;
    efM12 = pfc->efM12;
    efM21 = pfc->efM21;
    efM22 = pfc->efM22;


    lDesc = pfc->pifi->fwdWinDescender;
    bEmbolden = pfc->flags & FC_SIM_EMBOLDEN;
    bItalicize = pfc->flags & FC_SIM_ITALICIZE;
    bScaleOnly = pfc->flags & FC_SCALE_ONLY;

    pfxBaseOffset = pfc->pfxBaseOffset;


// Some points in the glyphs paths may end up on the bottom or right edge of
// the bounding rectangle for a glyph.  Because of GIQ it is possible that
// sometimes these pels will get lit.  However, because our bounding rectangles
// are bottom right exclusive they will never be considered to contain these
// pels.  This is a problem.  We need to adjust by making sure that any points
// which can possibly light a pel on the bottom or right edge of the bounding
// rectangle are adjust either to the right or up.  Note that we only need
// to worry about orientations of 90 degrees because the engine will relax
// the bouding rectangle by one pel at other orientations. There are 8 cases
// altogether when we take flipping into account. [gerritv]


    switch( pfc->flags & ORIENT_MASK )
    {
        case FC_ORIENT_1:
            ptfxBound.x = fxAB - 0x10;
            ptfxBound.y = -pfc->fxInkBottom - 0x10;
            break;
        case FC_ORIENT_2:
            ptfxBound.x = fxAB - 0x10;
            ptfxBound.y = pfc->fxInkTop - 0x10;
            break;
        case FC_ORIENT_3:
            ptfxBound.y = pfc->fxInkTop - 0x10;
            ptfxBound.x = -0x10;
            break;
        case FC_ORIENT_4:
            ptfxBound.y = -pfc->fxInkBottom - 0x10;
            ptfxBound.x = -0x10;
            break;
        case FC_ORIENT_5:
            ptfxBound.x = -pfc->fxInkBottom - 0x10;
            ptfxBound.y = fxAB - 0x10;
            break;
        case FC_ORIENT_6:
            ptfxBound.x = -pfc->fxInkBottom - 0x10;
            ptfxBound.y = -0x10;
            break;
        case FC_ORIENT_7:
            ptfxBound.x = pfc->fxInkTop - 0x10;
            ptfxBound.y = fxAB - 0x10;
            break;
        case FC_ORIENT_8:
            ptfxBound.y = -0x10;
            ptfxBound.x = pfc->fxInkTop - 0x10;
            break;
    }


// The path starts from the top left corner of the cell.

    aptl[0].y = -pfc->pifi->fwdWinAscender;

    aptl[0].x = 0;

    while(pch <= pchEnd)
    {
        if ( (pch != pchEnd) && (*pch != PEN_UP))
        {
        // Check if there is space left.  If not, send this batch of points
        // to engine for path construction.

            if (cPts >= CPTS_MAX)
                goto BUILD_PATH;

        // Attach this point to the end of the pointl array.

        // claudebe, NTRAID#440755 and 440756, PREFIX, we could have cPts == 0 and accessing
        //           aptl[-1], since vector font are becoming obsolete and this is very old code
        //           and no customer ever complain about a problem getting the path of a vector font
        //           I'm just doing a minimal fix to prevent accessing aptl[-1]
            if (cPts > 0)
            {
                aptl[cPts].x = (signed char)*pch++ + aptl[cPts-1].x;
                if (pch == pchEnd)
                {
                    WARNING("vtfd!bCreatePath(): y coordinate out of font file\n");
                    return FALSE;
                }
                aptl[cPts].y = (signed char)*pch++ + aptl[cPts-1].y;
            } else {
                aptl[cPts].x = (signed char)*pch++ ;
                if (pch == pchEnd)
                {
                    WARNING("vtfd!bCreatePath(): y coordinate out of font file\n");
                    return FALSE;
                }
                aptl[cPts].y = (signed char)*pch++ ;
            }

            cPts++;

        }
        else
        {
            if (cPts > 1)
            {
            BUILD_PATH:

                cPts--;

            // If Italic simulation is asked, x coordinates of all the points
            // will be changed.  Save the x of the last point so the next
            // batch will have a correct reference point.

                lXLast = aptl[cPts].x;
#if DEBUG
                {
                    UINT i;
                    DbgPrint("MoveTo (%lx, %lx)\n", aptl[0].x, aptl[0].y);
                    DbgPrint("PolyLineTo cPts = %lx\n",cPts);
                    for (i = 1; i <= cPts; i++)
                    {
                        DbgPrint("   (%lx, %lx)\n",aptl[i].x, aptl[i].y);
                    }
                }
#endif
                if (bItalicize)
                {
                    for (iPt = 0; iPt <= cPts; iPt++)
                        aptl[iPt].x += (lDesc - aptl[iPt].y)>>1;
                }

                if (bScaleOnly)
                {
                    for (iPt = 0; iPt <= cPts; iPt++)
                    {
                        aptfx[iPt].x = (FIX)lCvt(efM11, aptl[iPt].x);
                        aptfx[iPt].y = (FIX)lCvt(efM22, aptl[iPt].y);


                        if( aptfx[iPt].y > ptfxBound.y )
                        {
#if DEBUG
                            DbgPrint("y adjust %x to %x\n", aptfx[iPt].y, ptfxBound.y );
#endif
                            aptfx[iPt].y = ptfxBound.y;
                        }

                        if( aptfx[iPt].x > ptfxBound.x )
                        {
#if DEBUG
                            DbgPrint("x adjust %x %x\n", aptfx[iPt].x, ptfxBound.x );
#endif
                            aptfx[iPt].x = ptfxBound.x;
                        }

                    }
                }
                else
                {
                    for (iPt = 0; iPt <= cPts; iPt++)
                    {
                        aptfx[iPt].x = (FIX)lCvt(efM11, aptl[iPt].x) +
                                       (FIX)lCvt(efM21, aptl[iPt].y);
                        aptfx[iPt].y = (FIX)lCvt(efM12, aptl[iPt].x) +
                                       (FIX)lCvt(efM22, aptl[iPt].y);

                    // only if an orientation flag is set then we must adjust

                        if( pfc->flags & ORIENT_MASK )
                        {

                            if( aptfx[iPt].y > ptfxBound.y )
                            {
#if DEBUG
                                DbgPrint("y adjust %x %x\n", aptfx[iPt].y, ptfxBound.y );
#endif
                                aptfx[iPt].y = ptfxBound.y;
                            }


                            if( aptfx[iPt].x > ptfxBound.x )
                            {
#if DEBUG
                                DbgPrint("x adjust %x %x\n", aptfx[iPt].x, ptfxBound.x );
#endif
                                aptfx[iPt].x = ptfxBound.x;
                            }
                        }
                    }
                }

                bReturn &= PATHOBJ_bMoveTo(ppo, aptfx[0]);
                bReturn &= PATHOBJ_bPolyLineTo(ppo, &aptfx[1], cPts);
#if DEBUG
                {
                    UINT i;
                    DbgPrint("MoveTo (%lx, %lx)\n", aptfx[0].x, aptfx[0].y);
                    DbgPrint("PolyLineTo cPts = %lx\n",cPts);
                    for (i = 1; i <= cPts; i++)
                    {
                        DbgPrint("   (%lx, %lx)\n",aptfx[i].x, aptfx[i].y);
                    }
                }
#endif
                if (bEmbolden)
                {
                    for (iPt = 0; iPt <= cPts; iPt++)
                    {
                    // offset the whole path in the unit base direction

                        aptfx[iPt].x += pfxBaseOffset.x;
                        aptfx[iPt].y += pfxBaseOffset.y;
                    }

                    bReturn &= PATHOBJ_bMoveTo(ppo, aptfx[0]);
                    bReturn &= PATHOBJ_bPolyLineTo(ppo, &aptfx[1], cPts);
                }

                if ((pch != pchEnd) && (*pch != PEN_UP) )
                {
                // We got here because the aptl[] and aptfx[] buffer is
                // not big enough.  Move to the last point in PolyLineTo
                // and start storing the next batch of points.

                    aptl[0].x = lXLast;
                    aptl[0].y = aptl[cPts].y;
                    cPts = 1;
                    continue;
                }

                aptl[cPts].x = lXLast;
            }

            pch++;
            if (pch == pchEnd)
            {
                WARNING("vtfd!bCreatePath(): final x coordinate out of font file\n");
                return FALSE;
            }

            aptl[0].x = (signed char)*pch++ + aptl[cPts].x;
            if (pch == pchEnd)
            {
                WARNING("vtfd!bCreatePath(): final y coordinate out of font file\n");
                return FALSE;
            }
            aptl[0].y = (signed char)*pch++ + aptl[cPts].y;
            cPts = 1;
        }
    }

    return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gdiext\dllinit.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   dllinit.cxx

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

PGDI_SHARED_MEMORY pGdiSharedMemory = NULL;
PENTRY             pGdiSharedHandleTable = NULL;
PDEVCAPS           pGdiDevCaps = NULL;
W32PID             gW32PID;
INT                gbCheckHandleLevel = 0;

/*++

Routine Description:



Arguments



Return Value



--*/


BOOLEAN
GdxDllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext)
{
    NTSTATUS status = 0;
    INT i;
    BOOLEAN  fServer;
    PTEB pteb = NtCurrentTeb();
    BOOL bRet = TRUE;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
        break;

   case DLL_PROCESS_DETACH:
   case DLL_THREAD_DETACH:
        break;

    }

    return(bRet);

    pvDllHandle;
    pcontext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gdiext\alpha.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   alpha.cxx

Abstract:

   alpha blending functions

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

extern "C" {
BOOL
NtGdiAlphaBlt(
      HDC,
      LONG,
      LONG,
      LONG,
      LONG,
      HDC,
      LONG,
      LONG,
      LONG,
      LONG,
      ULONG);
}

BOOL
GdxAlphaBlt(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy,
    ULONG    fAlpha
    )
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdcDest);
    FIXUP_HANDLE(hSrc);

    //
    // metafile
    //

    //
    // emultation
    //

    //
    // Direct Drawing
    //

    #if 1

        bRet = NtGdiAlphaBlt(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      (HDC)hSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      fAlpha );
    #endif

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\vtfd\fontfile.c ===
/******************************Module*Header*******************************\
* Module Name: fontfile.c                                                  *
*                                                                          *
* Contains exported font driver entry points and memory allocation/locking *
* methods from engine's handle manager.  Adapted from BodinD's bitmap font *
* driver.                                                                  *
*                                                                          *
* Copyright (c) 1993-1995 Microsoft Corporation                                 *
\**************************************************************************/

#include "fd.h"

HSEMAPHORE ghsemVTFD;


VOID vVtfdMarkFontGone(FONTFILE *pff, DWORD iExceptionCode)
{

    ASSERTDD(pff, "vVtfdMarkFontGone, pff\n");

// this font has disappeared, probably net failure or somebody pulled the
// floppy with vt file out of the floppy drive

    if (iExceptionCode == STATUS_IN_PAGE_ERROR) // file disappeared
    {
    // prevent any further queries about this font:

        pff->fl |= FF_EXCEPTION_IN_PAGE_ERROR;

        if ((pff->iType == TYPE_FNT) || (pff->iType == TYPE_DLL16))
        {
            EngUnmapFontFileFD(pff->iFile);
        }
    }

    if (iExceptionCode == STATUS_ACCESS_VIOLATION)
    {
        RIP("VTFD!this is probably a buggy vector font file\n");
    }
}

BOOL bvtfdMapFontFileFD(PFONTFILE pff)
{
    return (pff ? (EngMapFontFileFD(pff->iFile, (PULONG*)&pff->pvView, &pff->cjView))
                : FALSE);
}

/******************************Public*Routine******************************\
*
*  vtfdQueryFontDataTE, try except wrapper
*
* Effects:
*
* Warnings:
*
* History:
*  04-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG vtfdQueryFontDataTE (
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    LONG lRet = FD_ERROR;

    if (bvtfdMapFontFileFD((PFONTFILE)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemVTFD);
    
#ifndef VTFD_NO_TRY_EXCEPT
        try
        {
#endif
            lRet = vtfdQueryFontData (
                       pfo,
                       iMode,
                       hg,
                       pgd,
                       pv,
                       cjSize
                       );
#ifndef VTFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("exception in vtfdQueryFontDataTE \n");
            vVtfdMarkFontGone((FONTFILE *)pfo->iFile, GetExceptionCode());
        }
#endif
    
        EngReleaseSemaphore(ghsemVTFD);

        EngUnmapFontFileFD(PFF(pfo->iFile)->iFile);
    }

    return lRet;
}

/******************************Public*Routine******************************\
*
* HFF vtfdLoadFontFileTE, try except wrapper
*
*
* History:
*  05-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG ExceptionFilter_VtfdLoadFontFile(PEXCEPTION_POINTERS ExceptionPointers)
{
#if DBG
    const static char Function[] = __FUNCTION__;
    ULONG ExceptionCode;

    ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;

    if (ExceptionCode != STATUS_IN_PAGE_ERROR)
    {
        VtfdDebugPrint(
            "%s: .exr %p\n%s: .cxr %p\n",
            Function,
            ExceptionPointers->ExceptionRecord,
            Function,
            ExceptionPointers->ContextRecord
            );

        ASSERTDD(ExceptionCode == STATUS_IN_PAGE_ERROR,
                    "vtfdLoadFontFile, strange exception code\n");
    }
#endif
    return EXCEPTION_EXECUTE_HANDLER;
}

HFF vtfdLoadFontFileTE(
    ULONG cFiles,
    ULONG_PTR *piFile,
    PVOID *ppvView,
    ULONG *pcjView,
    DESIGNVECTOR *pdv,
    ULONG ulLangId,
    ULONG ulFastCheckSum
    )
{
    HFF  hff = (HFF)NULL;
    ULONG_PTR iFile;
    PVOID pvView;
    ULONG cjView;
    BOOL bRet;

    if ((cFiles != 1) || pdv)
        return hff;

    iFile  = *piFile;
    pvView = *ppvView;
    cjView = *pcjView;

    EngAcquireSemaphore(ghsemVTFD);

#ifndef VTFD_NO_TRY_EXCEPT
    try
    {
#endif

        bRet = vtfdLoadFontFile(iFile, pvView, cjView, &hff);

        if (!bRet)
        {
            ASSERTDD(hff == (HFF)NULL, "vtfdLoadFontFile, hff != NULL\n");
        }
#ifndef VTFD_NO_TRY_EXCEPT
    }
    except (ExceptionFilter_VtfdLoadFontFile(GetExceptionInformation()))
    {
        WARNING("exception in vtfdLoadFontFile \n");

    // if the file disappeared after mem was allocated, free the mem

        if (hff)
        {
            vFree(hff);
            hff = (HFF) NULL;
        }
    }
#endif

    EngReleaseSemaphore(ghsemVTFD);
    
    return hff;
}

/******************************Public*Routine******************************\
*
* BOOL vtfdUnloadFontFileTE , try/except wrapper
*
*
* History:
*  05-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL vtfdUnloadFontFileTE (HFF hff)
{
    BOOL bRet;

    EngAcquireSemaphore(ghsemVTFD);

#ifndef VTFD_NO_TRY_EXCEPT
    try
    {
#endif
        bRet = vtfdUnloadFontFile(hff);
#ifndef VTFD_NO_TRY_EXCEPT
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("exception in vtfdUnloadFontFile\n");
        bRet = FALSE;
    }
#endif
    
    EngReleaseSemaphore(ghsemVTFD);

    return bRet;
}

/******************************Public*Routine******************************\
*
* LONG vtfdQueryFontFileTE, try/except wrapper
*
* History:
*  05-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


LONG vtfdQueryFontFileTE (
    HFF     hff,        // handle to font file
    ULONG   ulMode,     // type of query
    ULONG   cjBuf,      // size of buffer (in BYTEs)
    PULONG  pulBuf      // return buffer (NULL if requesting size of data)
    )
{
    LONG lRet = FD_ERROR;
    
    if ((ulMode != QFF_DESCRIPTION) ||
        bvtfdMapFontFileFD(PFF(hff)))
    {
        EngAcquireSemaphore(ghsemVTFD);
    
#ifndef VTFD_NO_TRY_EXCEPT
        try
        {
#endif
            lRet = vtfdQueryFontFile (hff,ulMode, cjBuf,pulBuf);
#ifndef VTFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("exception in  vtfdQueryFontFile\n");
            vVtfdMarkFontGone((FONTFILE *)hff, GetExceptionCode());
        }
#endif
    
        EngReleaseSemaphore(ghsemVTFD);

        if (ulMode == QFF_DESCRIPTION)
        {
            EngUnmapFontFileFD(PFF(hff)->iFile);            
        }
    }

    return lRet;
}


/******************************Public*Routine******************************\
*
* BOOL vtfdQueryAdvanceWidthsTE, try/except wrapper
*
* History:
*  05-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL vtfdQueryAdvanceWidthsTE
(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    BOOL     bRet = FD_ERROR;

    if ((iMode <= QAW_GETEASYWIDTHS) &&
        bvtfdMapFontFileFD((PFONTFILE)pfo->iFile))
    {
        EngAcquireSemaphore(ghsemVTFD);
    
#ifndef VTFD_NO_TRY_EXCEPT
        try
        {
#endif
            bRet = vtfdQueryAdvanceWidths (pfo,iMode, phg, plWidths, cGlyphs);
#ifndef VTFD_NO_TRY_EXCEPT
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("exception in vtfdQueryAdvanceWidths \n");
            vVtfdMarkFontGone((FONTFILE *)pfo->iFile, GetExceptionCode());
        }
#endif
    
        EngReleaseSemaphore(ghsemVTFD);
    
        EngUnmapFontFileFD(PFF(pfo->iFile)->iFile);        
    }
    return bRet;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI
*
\**************************************************************************/

DHPDEV
vtfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver)
{

    PVOID*   ppdev;

    //
    // Allocate a four byte PDEV for now
    // We can grow it if we ever need to put information in it.
    //

    ppdev = (PVOID*) EngAllocMem(0, sizeof(PVOID), 'dftV');

    return ((DHPDEV) ppdev);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID
vtfdDisablePDEV(
    DHPDEV  dhpdev)
{
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID
vtfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev)
{
    return;
}






// The driver function table with all function index/address pairs

DRVFN gadrvfnVTFD[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) vtfdEnablePDEV,          },
    {   INDEX_DrvDisablePDEV,           (PFN) vtfdDisablePDEV,         },
    {   INDEX_DrvCompletePDEV,          (PFN) vtfdCompletePDEV,        },
    {   INDEX_DrvQueryFont,             (PFN) vtfdQueryFont,           },
    {   INDEX_DrvQueryFontTree,         (PFN) vtfdQueryFontTree,       },
    {   INDEX_DrvQueryFontData,         (PFN) vtfdQueryFontDataTE,     },
    {   INDEX_DrvDestroyFont,           (PFN) vtfdDestroyFont,         },
    {   INDEX_DrvQueryFontCaps,         (PFN) vtfdQueryFontCaps,       },
    {   INDEX_DrvLoadFontFile,          (PFN) vtfdLoadFontFileTE,      },
    {   INDEX_DrvUnloadFontFile,        (PFN) vtfdUnloadFontFileTE,    },
    {   INDEX_DrvQueryFontFile,         (PFN) vtfdQueryFontFileTE,     },
    {   INDEX_DrvQueryAdvanceWidths ,   (PFN) vtfdQueryAdvanceWidthsTE }
};

/******************************Public*Routine******************************\
* vtfdEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
*  Sun 25-Apr-1993 -by- Patrick Haluptzok [patrickh]
* Change to be same as DDI Enable.
*
* History:
*  12-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL vtfdEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

    if ((ghsemVTFD = EngCreateSemaphore()) == (HSEMAPHORE) 0)
    {
        return(FALSE);
    }

    pded->pdrvfn = gadrvfnVTFD;
    pded->c = sizeof(gadrvfnVTFD) / sizeof(DRVFN);
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;
    return(TRUE);
}


#if DBG

VOID
VtfdDebugPrint(
    PCHAR DebugMessage,
    ...
    )
{

    va_list ap;

    va_start(ap, DebugMessage);

    EngDebugPrint("VTFD: ", DebugMessage, ap);

    va_end(ap);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\vtfd\fontfile.h ===
/******************************Module*Header*******************************\
* Module Name: fontfile.h
*
* (Brief description)
*
* Created: 25-Oct-1990 09:20:11
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

// allowed values for FONTFILE.iType field:

// ORIGINAL FILE IS AN *.FNT FILE which contains a single
// size of the single font

#define TYPE_FNT          1L

// ORIGINAL FILE IS A win 3.0 16 bit *.DLL (*.fon FILE),
// This file is compiled out of many *.fnt files
// that correspond to different sizes of the same face, (e.g. tmsr or helv)
// This is provided to ensure binary compatibility with win 3.0 *.fon files

#define TYPE_DLL16        2L

// ORIGINAL FILE IS A win 3.0 32 bit *.DLL
// This file is compiled out of many *.fnt files using NT tools
// (coff linker and nt resource compiler)

#define TYPE_DLL32        3L

// an fnt file that is embeded in an exe and loaded using FdLoadResData

#define TYPE_EXE          4L

typedef struct _FACEDATA
{
    RES_ELEM     re;         // -> top of the resource within the file
    ULONG        iDefFace;
    CP_GLYPHSET *pcp;
    IFIMETRICS  *pifi;
}FACEDATA, *PFACEDATA;

// file is gone

#define FF_EXCEPTION_IN_PAGE_ERROR 1


typedef struct _VT_FONTFILE    // ff
{
    ULONG       iType;      // original file is *.fnt, 16 bit dll or 32 bit dll
    ULONG_PTR   iFile;      // file handle for EngMapFontFile,EngUnmapFontFile
    PVOID       pvView;     // pointer to the base of the mapped view
    ULONG       cjView;     // size of the mapped view
    FLONG       fl;         // general flags
    ULONG       cRef;       // # no of times this font file is selected
                            // into a font context
    ULONG       cFace;      // # of resources in the file
    FACEDATA    afd[1];     // cFace of them followed by cFace IFIMETRICS

} FONTFILE, *PFONTFILE;


#define PFF(hff)   ((FONTFILE*)(hff))

typedef struct _VT_FONTCONTEXT // fc
{
    PFONTFILE   pff;                // the font file selected into this context
    PIFIMETRICS pifi;

    EFLOAT      efM11;              // Transform matrix.
    EFLOAT      efM12;
    EFLOAT      efM21;
    EFLOAT      efM22;

    FIX         fxInkTop;           // Transformed Ascender.
    FIX         fxInkBottom;        // -Transformed Descender.
    EFLOAT      efBase;
    POINTE      pteUnitBase;
    VECTORFL    vtflBase;

    POINTQF     ptqUnitBase;   // pteUnitBase in POINTQF format,
                               // has to be added to all ptqD's if emboldening
    POINTFIX    pfxBaseOffset; // offset strokes this much for emboldened font
    FIX         fxEmbolden;    // length of the above vector
    FIX         fxItalic;      // add to fxD to get fxAB

    EFLOAT      efSide;
    POINTE      pteUnitSide;

    RES_ELEM    *pre;               // -> beginning of the mapped font file
    FLONG       flags;              // simulation and transform flag
    ULONG       dpFirstChar;        // -> control points of the first char

}FONTCONTEXT, *PFONTCONTEXT;

#define PFC(hfc)   ((FONTCONTEXT*)(hfc))


// Allowed values for flags

#define FC_SIM_EMBOLDEN     1
#define FC_SIM_ITALICIZE    2
#define FC_SCALE_ONLY       4
#define FC_X_INVERT         8
#define FC_ORIENT_1         16
#define FC_ORIENT_2         32
#define FC_ORIENT_3         64
#define FC_ORIENT_4         128
#define FC_ORIENT_5         256
#define FC_ORIENT_6         512
#define FC_ORIENT_7         1024
#define FC_ORIENT_8         2048


#define ORIENT_MASK (FC_ORIENT_1|FC_ORIENT_2|FC_ORIENT_3|FC_ORIENT_4| \
                     FC_ORIENT_5|FC_ORIENT_6|FC_ORIENT_7|FC_ORIENT_8)


// Font file/context allocation/free macros.

#define pffAlloc(cj) ((PFONTFILE)EngAllocMem(0, cj, 'dftV'))
#define pfcAlloc()   ((PFONTCONTEXT)EngAllocMem(0, sizeof(FONTCONTEXT), 'dftV'))
#define vFree(pv)    EngFreeMem((PVOID) pv)

BOOL bXformUnitVector
(
POINTL       *pptl,           // IN,  incoming unit vector
XFORML       *pxf,            // IN,  xform to use
PVECTORFL     pvtflXformed,   // OUT, xform of the incoming unit vector
POINTE       *ppteUnit,       // OUT, *pptqXormed/|*pptqXormed|, POINTE
POINTQF      *pptqUnit,       // out optional
EFLOAT       *pefNorm         // OUT, |*pptqXormed|
);

// default face in the font.

#define FF_FACE_NORMAL          0L
#define FF_FACE_BOLD            1L
#define FF_FACE_ITALIC          2L
#define FF_FACE_BOLDITALIC      3L


extern FD_GLYPHSET *gpgsetVTFD;


#define PEN_UP          (CHAR)0x80
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gdiext\gdxlocal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   gdxlocal.h

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/




extern PGDI_SHARED_MEMORY pGdiSharedMemory;
extern PDEVCAPS           pGdiDevCaps;
extern PENTRY             pGdiSharedHandleTable;
extern W32PID             gW32PID;





#define HANDLE_TO_INDEX(h) (ULONG)h & 0x0000ffff
HANDLE GdiFixUpHandle(HANDLE h);

/******************************Public*Macro********************************\
*
*  PSHARED_GET_VALIDATE
*
*  Validate all handle information, return user pointer if the handle
*  is valid or NULL otherwise.
*
* Arguments:
*
*   p       - pointer to assign to pUser is successful
*   h       - handle to object
*   iType   - handle type
*
\**************************************************************************/

#define PSHARED_GET_VALIDATE(p,h,iType)                                 \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    p = NULL;                                                           \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             (pentry->FullUnique == ((ULONG)h >> 16)) &&                \
             (pentry->ObjectOwner.Share.Pid == gW32PID)                 \
           )                                                            \
        {                                                               \
            p = pentry->pUser;                                          \
        }                                                               \
    }                                                                   \
}


#define VALIDATE_HANDLE(bRet, h,iType)                                  \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    bRet = FALSE;                                                       \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             (pentry->FullUnique == ((ULONG)h >> 16)) &&                \
             ((pentry->ObjectOwner.Share.Pid == gW32PID) ||             \
             (pentry->ObjectOwner.Share.Pid == 0))                      \
              )                                                         \
        {                                                               \
           bRet = TRUE;                                                 \
        }                                                               \
    }                                                                   \
}

/******************************Public*Macros******************************\
* FIXUP_HANDLE(h) and FIXUP_HANDLEZ(h)
*
* check to see if the handle has been truncated.
* FIXUP_HANDLEZ() adds an extra check to allow NULL.
*
* Arguments:
*   h - handle to be checked and fix
*
* Return Value:
*
* History:
*
*    25-Jan-1996 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/



#define HANDLE_FIXUP 0

#if DBG
extern INT gbCheckHandleLevel;
#endif

#define NEEDS_FIXING(h)    (!((ULONG)h & 0xffff0000))

#if DBG
#define HANDLE_WARNING()                                                 \
{                                                                        \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
}
#else
#define HANDLE_WARNING()
#endif

#if DBG
#define CHECK_HANDLE_WARNING(h, bZ)                                      \
{                                                                        \
    BOOL bFIX = NEEDS_FIXING(h);                                         \
                                                                         \
    if (bZ) bFIX = h && bFIX;                                            \
                                                                         \
    if (bFIX)                                                            \
    {                                                                    \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
    }                                                                    \
}
#else
#define CHECK_HANDLE_WARNING(h,bZ)
#endif


#if HANDLE_FIXUP
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    CHECK_HANDLE_WARNING(h,FALSE);                      \
}
#endif

#if HANDLE_FIXUP
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    if (h && NEEDS_FIXING(h))                           \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    CHECK_HANDLE_WARNING(h,TRUE);                       \
}
#endif

#define FIXUP_HANDLE_NOW(h)                             \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\fondrv\vtfd\service.h ===
/******************************Module*Header*******************************\
* Module Name: service.h
*
* routines in service.c
*
* Created: 15-Nov-1990 13:00:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#if defined(_AMD64_) || defined(_IA64_)

typedef FLOAT EFLOAT;

#else // i386

typedef struct  _FLOATINTERN
{
    LONG    lMant;
    LONG    lExp;
} FLOATINTERN;

typedef FLOATINTERN  EFLOAT;

#endif

typedef EFLOAT *PEFLOAT;

typedef struct _VECTORFL
{
    EFLOAT x;
    EFLOAT y;
} VECTORFL, *PVECTORFL;


VOID vLTimesVtfl(LONG l, VECTORFL *pvtfl, POINTQF *pptq);

#if defined(_AMD64_) || defined(_IA64_)
#define vEToEF(e, pef)	    ( *pef = e)
#define bIsZero(ef)         ( ef == 0 )
#define bPositive(ef)       ( ef >= 0 )
#define	fxLTimesEf(pef, l)  ( (FIX)(*pef * l) )

#else
VOID    ftoef_c(FLOATL, PEFLOAT);

#define vEToEF(e, pef)      ftoef_c(e, pef)
#define bIsZero(ef)         ((ef.lMant == 0) && (ef.lExp == 0))
#define bPositive(ef)       (ef.lMant >= 0)
FIX  fxLTimesEf(EFLOAT *pef, LONG l);

#endif	// _AMD64_ || _IA64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gdiext\gdiext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   gdiext.h

Abstract:

    GDI exensions for transparent blt, blending, gradient fill

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


typedef LONG  PTFX8;
typedef USHORT COLOR16;

typedef struct _VERTEX
{
    PTFX8   x;
    PTFX8   y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}VERTEX,*PVERTEX;

BOOL
GdxTransparentBlt(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy,
    COLORREF TranColor
    );


BOOL
GdxAlphaBlt(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy,
    ULONG    fAlpha
    );


BOOL
TriangleMesh(
    HDC       hdc,
    PVERTEX   pVertex,
    ULONG     nVertex,
    PULONG    pMesh,
    ULONG     nCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gdiext\tran.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   dllinit.cxx

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

extern "C" {
BOOL
NtGdiTransparentBlt(
    HDC     hdcDst,
    LONG    DstX,
    LONG    DstY,
    LONG    DstCx,
    LONG    DstCy,
    HDC     hdcSrc,
    LONG    SrcX,
    LONG    SrcY,
    LONG    SrcCx,
    LONG    SrcCy,
    COLORREF TranColor
    );
}

BOOL
GdxTransparentBlt(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy,
    COLORREF TranColor
    )
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdcDest);
    FIXUP_HANDLE(hSrc);

    //
    // metafile
    //


    //
    // emultation
    //

    //
    // Direct Drawing
    //

    #if 1

        bRet = NtGdiTransparentBlt(hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      (HDC)hSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      TranColor );
    #endif

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gdiext\trimesh.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop

extern "C" {
BOOL
NtGdiTriangleMesh(
    HDC       hdc,
    PVERTEX   pVertex,
    ULONG     nVertex,
    PULONG    pMesh,
    ULONG     nCount
    );
}


BOOL
TriangleMesh(
    HDC       hdc,
    PVERTEX   pVertex,
    ULONG     nVertex,
    PULONG    pMesh,
    ULONG     nCount
    )
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    //
    // metafile
    //


    //
    // emultation
    //

    //
    // Direct Drawing
    //

    #if 1

        bRet = NtGdiTriangleMesh(hdc,
                                 pVertex,
                                 nVertex,
                                 pMesh,
                                 nCount);
    #endif

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\alphablt.cxx ===
/******************************Module*Header*******************************\
* Module Name: alphablt.cxx
*
* Alpha Blending
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "stretch.hxx"  // For mirroring code.

/******************************Public*Routine******************************\
* bIsSourceBGRA 
*
*   determine whether a surface is in BGR format
*
* Arguments:
*
*   pSurf          - pointer to the surface
*
* Return Value:
*
*   TRUE if the surface is in BGR format, otherwise FALSE
*
* History:
*
*    12-Aug-1997 -by- Ori Gershony [orig]
*
\**************************************************************************/
BOOL
bIsSourceBGRA(
    PSURFACE pSurf
    )
{
    XEPALOBJ pal(pSurf->ppal());

    //
    // A surface is in BGR format if it's a valid 32BPP surface that's either
    // PAL_BGR or PAL_BITFIELDS with the correct bitfields set.
    //

    return ((pSurf->iFormat() == BMF_32BPP) &&
            (pal.bValid()) &&
            ((pal.bIsBGR()) ||
             ((pal.bIsBitfields()) &&
              (pal.flRed() == 0xff0000) && 
              (pal.flGre() == 0xff00) && 
              (pal.flBlu() == 0xff))));
}


/******************************Public*Routine******************************\
*  psSetupTransparentSrcSurface
*
*   make a temp copy of source surface if needed
*
* Arguments:
*
*   pSurfSrc       - original source surface
*   pSurfDst       - original dset surfaca
*   prclDst        - destination rect
*   pxloSrcTo32    - used only for alpha blend, tran src to 32 BGRA
*   prclSrc        - source rect, change to temp src rect if allocated
*   &surfTmpSrc    - use this surfmem to alloc
*   *bAllocSrcSurf - force temp allocation
*   ulSourceType   - alpha or transparent surface
*   ulTranColor    - transparent color
*
* Return Value:
*
*   drawable surface or NULL
*
* History:
*
*    25-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PSURFACE
psSetupTransparentSrcSurface(
    PSURFACE  pSurfSrc,
    PSURFACE  pSurfDst,
    PRECTL    prclDst,
    XLATEOBJ *pxloSrcTo32,
    PRECTL    prclSrc,
    SURFMEM  &surfTmpSrc,
    ULONG     ulSourceType,
    ULONG     ulTranColor
    )
{
    BOOL bStatus;

    PSURFACE psurfRet = pSurfSrc;

    LONG DstCx = prclDst->right  - prclDst->left;
    LONG DstCy = prclDst->bottom - prclDst->top;

    LONG SrcCx = prclSrc->right  - prclSrc->left;
    LONG SrcCy = prclSrc->bottom - prclSrc->top;

    BOOL bStretch = ((DstCx != SrcCx) || (DstCy != SrcCy));

    BOOL bSourceIsBGRA = FALSE;
    BOOL bSrcRectExceedsBounds = FALSE;
 
    //
    // if the surface is a bitmap, identity translate and
    // no stretching, then a temp copy of the surface is not
    // needed.
    //

    if (bStretch)
    {
        DEVBITMAPINFO   dbmi;
        PDEVOBJ         pdoSrc( pSurfSrc->hdev());
        XEPALOBJ        palSurf(pSurfSrc->ppal());

        //
        // calculate clipped extents of destinatoin rect
        //

        RECTL rclDstClip = {0,0,pSurfDst->sizl().cx,pSurfDst->sizl().cy};

        //
        // trimmed destination rect is trimmed surface boundary
        // Perf Note: clipping on destination is not taken into account,
        // this could reduce the size of the source copy surface at
        // times.
        //

        if (rclDstClip.left < prclDst->left)
        {
            rclDstClip.left = prclDst->left;
        }

        if (rclDstClip.top < prclDst->top)
        {
            rclDstClip.top = prclDst->top;
        }

        if (rclDstClip.right > prclDst->right)
        {
            rclDstClip.right = prclDst->right;
        }

        if (rclDstClip.bottom > prclDst->bottom)
        {
            rclDstClip.bottom = prclDst->bottom;
        }

        if ((rclDstClip.left < rclDstClip.right) &&
            (rclDstClip.top  < rclDstClip.bottom))
        {
            //
            // does source rect exceed source bounds? (bad)
            //

            if ((prclSrc->left < 0)                    ||
                (prclSrc->right > pSurfSrc->sizl().cx) ||
                (prclSrc->top < 0)                     ||
                (prclSrc->bottom > pSurfSrc->sizl().cy)
               )
            {
                bSrcRectExceedsBounds = TRUE;
            }

            //
            // allocate surface as same size as dst
            //

            if (ulSourceType == SOURCE_ALPHA)
            {
                //
                // does original source contain alpha channel
                //

                bSourceIsBGRA = bIsSourceBGRA (pSurfSrc);

                //
                // allocate 32bpp BGRA surface for source, must be zero init
                //

                dbmi.cxBitmap = rclDstClip.right  - rclDstClip.left;
                dbmi.cyBitmap = rclDstClip.bottom - rclDstClip.top;
                dbmi.iFormat  = BMF_32BPP;
                dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
                XEPALOBJ      palRGB(gppalRGB);
                dbmi.hpal     = (HPALETTE)palRGB.hpal();

                bStatus = surfTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                //
                // since DIB is zero-init, no other initialization is needed to
                // make it transparent (so that portions of dst rect not covered
                // by source rect are not drawn)
                //
                // UNLESS source DIB does not have it's own alpha. In that case, if
                // the source extents do not completely cover dst extents, source
                // must be initialized to 0xffxxxxxx. StretchBlt will write 0x00xxxxxx.
                // After StretchBlt, must make all 0xffxxxxxx to 0x00xxxxxx and all
                // 0x00xxxxxx to 0xffxxxxxx
                //

                if (bStatus && bSrcRectExceedsBounds && !bSourceIsBGRA)
                {
                    RtlFillMemoryUlong(surfTmpSrc.ps->pvBits(),surfTmpSrc.ps->cjBits(),0xFF000000);
                }
            }
            else
            {
                //
                // allocate compatible surface for TransparentBlt
                //

                dbmi.cxBitmap = DstCx;
                dbmi.cyBitmap = DstCy;
                dbmi.iFormat  = pSurfSrc->iFormat();
                dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
                dbmi.hpal     = (HPALETTE)NULL;

                if (palSurf.bValid())
                {
                    dbmi.hpal     = palSurf.hpal();
                }

                bStatus = surfTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                //
                // init DIB to transparent
                // (so that portions of dst rect not covered by source rect are not drawn)
                //

                if (bStatus && bSrcRectExceedsBounds)
                {
                    ULONG i;
                    ULONG cjBits = surfTmpSrc.ps->cjBits();
                    ULONG ulColor4BPP;
                                        
                    switch (pSurfSrc->iFormat())
                    {
                    case BMF_1BPP:
                        if (ulTranColor)
                        {
                            memset(surfTmpSrc.ps->pvBits(),0xff,cjBits);
                        }
                        else
                        {
                            memset(surfTmpSrc.ps->pvBits(),0,cjBits);
                        }
                        break;
                                            
                    case BMF_4BPP:
                        ulColor4BPP = ulTranColor | (ulTranColor << 4);
                        memset(surfTmpSrc.ps->pvBits(),ulColor4BPP,cjBits);
                        break;
                                            
                    case BMF_8BPP:
                        memset(surfTmpSrc.ps->pvBits(),ulTranColor,cjBits);
                        break;
                                            
                    case BMF_16BPP:
                        {
                            PUSHORT pvBits = (PUSHORT) surfTmpSrc.ps->pvBits();
                                                
                            for (i=0; i<(cjBits/sizeof(USHORT)); i++)
                            {
                                *pvBits++ = (USHORT) ulTranColor;
                                                    
                            }
                        }
                        break;
                                       
                    case BMF_24BPP:
                        {
                            BYTE bC1 = ((PBYTE)&ulTranColor)[0];
                            BYTE bC2 = ((PBYTE)&ulTranColor)[1];
                            BYTE bC3 = ((PBYTE)&ulTranColor)[2];
                                                

                            PULONG pulDstY     = (PULONG)surfTmpSrc.ps->pvScan0();
                            PULONG pulDstLastY = (PULONG)((PBYTE)pulDstY + 
                                                          (surfTmpSrc.ps->lDelta() * surfTmpSrc.ps->sizl().cy));
                            while (pulDstY != pulDstLastY)
                            {
                                PBYTE pulDstX     = (PBYTE) pulDstY;
                                PBYTE pulDstLastX = pulDstX + 3 * surfTmpSrc.ps->sizl().cx;
                                                    
                                while (pulDstX < pulDstLastX-2)
                                {
                                    *pulDstX++ = bC1;
                                    *pulDstX++ = bC2;
                                    *pulDstX++ = bC3;
                                }
                                pulDstY = (PULONG)((PBYTE)pulDstY + surfTmpSrc.ps->lDelta());
                            }                                                    
                        }        
                        break;
                                                                                                
                    case BMF_32BPP:
                        {
                            PULONG pvBits = (PULONG) surfTmpSrc.ps->pvBits();
                                                
                            for (i=0; i<(cjBits/sizeof(ULONG)); i++)
                            {
                                *pvBits++ = ulTranColor;
                            }
                        }
                        break;
                    }
                }
            }


            if (bStatus)
            {
                //
                // zero DIB to make non-drawing areas transparent for alphablend
                //

                POINTL   ptlBrushOrg = {0,0};
                RECTL    rclDstCopy  = *prclDst;
                ECLIPOBJ eco;
                ECLIPOBJ *pco = NULL;
                RGNMEMOBJTMP rmo((BOOL)FALSE);

                if (rmo.bValid())
                {

                    //
                    // offset dst rect
                    //

                    rclDstCopy.left   -= rclDstClip.left;
                    rclDstCopy.right  -= rclDstClip.left;
                    rclDstCopy.top    -= rclDstClip.top;
                    rclDstCopy.bottom -= rclDstClip.top;

                    //
                    // will need rect clipping if rclDstCopy exceeds tmp bitmap
                    //

                    if (
                            (rclDstCopy.left   < 0) ||
                            (rclDstCopy.right  > surfTmpSrc.ps->sizl().cx) ||
                            (rclDstCopy.top    < 0) ||
                            (rclDstCopy.bottom > surfTmpSrc.ps->sizl().cy))
                    {
                        ERECTL rclSurface(0,0,surfTmpSrc.ps->sizl().cx,surfTmpSrc.ps->sizl().cy);
                        rmo.vSet((RECTL *) &rclSurface);
                        pco = (ECLIPOBJ *)&eco;
                        ((XCLIPOBJ *)pco)->vSetup(rmo.prgnGet(),(ERECTL)rclDstCopy);
                    }

                    surfTmpSrc.ps->hdev(pSurfSrc->hdev());

                    //
                    //  init with stretch
                    //

                    bStatus = EngStretchBlt (
                                      surfTmpSrc.ps->pSurfobj(),
                                      pSurfSrc->pSurfobj(),
                                      NULL,
                                      (CLIPOBJ *)pco,
                                      pxloSrcTo32,
                                      NULL,
                                      &ptlBrushOrg,
                                      &rclDstCopy,
                                      prclSrc,
                                      NULL,
                                      COLORONCOLOR
                                      );

                    if (bStatus)
                    {
                        //
                        // adjust prclSrc and prclDst to be non-stretch rects
                        //

                        prclSrc->left   = 0;
                        prclSrc->right  = dbmi.cxBitmap;
                        prclSrc->top    = 0;
                        prclSrc->bottom = dbmi.cyBitmap;

                        *prclDst = rclDstClip;

                        //
                        // for alpha bitmaps that did not originally contain an alpha channel,
                        // init alpha to ff.
                        //
                        // PERF: 2 other options to XOR whole bitmap are
                        //      1: use compatible bitmap for source where rclSrc does not exceed src bounds
                        //          This saves memory maybee, saves xor, but require conversion of each scan to 32BRGA
                        //      2: use flag to ignore alpha channel later where rclSrc does not exceed src bounds
                        //

                        if ((ulSourceType == SOURCE_ALPHA) && (!bSourceIsBGRA))
                        {
                            //
                            // ULONGs that are 0xffxxxxxx must be made 0x00xxxxxx
                            // ULONGs that are 0x00xxxxxx must be made 0xffxxxxxx
                            // bitmaps that started out as 0x00BBGGRR (PAL_RGB) are still broken
                            //

                            PULONG pulDstY     = (PULONG)surfTmpSrc.ps->pvScan0();
                            PULONG pulDstLastY = (PULONG)((PBYTE)pulDstY + surfTmpSrc.ps->lDelta() * surfTmpSrc.ps->sizl().cy);

                            while (pulDstY != pulDstLastY)
                            {
                                PULONG pulDstX     = pulDstY;
                                PULONG pulDstLastX = pulDstX + surfTmpSrc.ps->sizl().cx;

                                while (pulDstX != pulDstLastX)
                                {
                                    *pulDstX = *pulDstX ^ 0xff000000;
                                    pulDstX++;
                                }
                                pulDstY = (PULONG)((PBYTE)pulDstY + surfTmpSrc.ps->lDelta());
                            }
                        }

                        //
                        // mark surface to keep, set return status
                        //

                        psurfRet = surfTmpSrc.ps;
                    }
                    else
                    {
                        psurfRet = NULL;
                    }
                }
                else
                {
                    psurfRet = NULL;
                }
            }
            else
            {
                psurfRet = NULL;
            }
        }
        else
        {
            psurfRet = NULL;
        }
    }
    else
    {
        //
        // trim src rect to src surface bounds and reduce
        // dst rect accordingly
        //

        if (prclSrc->left < 0)
        {
            prclDst->left = prclDst->left - prclSrc->left;
            prclSrc->left = 0;
        }

        if (prclSrc->right > pSurfSrc->sizl().cx)
        {
            prclDst->right = prclDst->right - (prclSrc->right - pSurfSrc->sizl().cx);
            prclSrc->right = pSurfSrc->sizl().cx;
        }

        if (prclSrc->top < 0)
        {
            prclDst->top = prclDst->top - prclSrc->top;
            prclSrc->top = 0;
        }

        if (prclSrc->bottom > pSurfSrc->sizl().cy)
        {
            prclDst->bottom = prclDst->bottom - (prclSrc->bottom - pSurfSrc->sizl().cy);
            prclSrc->bottom = pSurfSrc->sizl().cy;
        }

        //
        // check dst rect exceeds dst surface, reduce src and rect accordingly
        // WINBUG #82938 2-8-2000 bhouse Fix assumption of surface position
        // Old Comment:
        //     This code assumes that the surface starts at 0,0 and ends at sizl().cx, sizl().cy
        //     which is not true for multimon code.
        // This is not a problem anymore. As this is called only from
        // EngAlphaBlend. According to Nagasae-San all Eng* Apis can assume
        // this surface start of 0,0 requirment.

        if (prclDst->left < 0)
        {
            prclSrc->left += (-prclDst->left);
            prclDst->left  = 0;
        }

        if (prclDst->right > pSurfDst->sizl().cx)
        {
            prclSrc->right += (pSurfDst->sizl().cx - prclDst->right);
            prclDst->right = pSurfDst->sizl().cx;
        }

        if (prclDst->top < 0)
        {
            prclSrc->top += (-prclDst->top);
            prclDst->top  = 0;
        }

        if (prclDst->bottom > pSurfDst->sizl().cy)
        {
            prclSrc->bottom += (pSurfDst->sizl().cy - prclDst->bottom);
            prclDst->bottom = pSurfDst->sizl().cy;
        }

        //
        // check for empty rect
        //

        if (
             (prclDst->left >= prclDst->right) ||
             (prclDst->top  >= prclDst->bottom))
        {
            //
            // indicate empty rect
            //

            prclDst->left = prclDst->right;

        }
        else
        {
            if (pSurfSrc->iType() != STYPE_BITMAP)
            {
                DEVBITMAPINFO   dbmi;
                PDEVOBJ         pdoSrc( pSurfSrc->hdev());
                XEPALOBJ        palSurf(pSurfSrc->ppal());
                LONG DstCx = prclDst->right  - prclDst->left;
                LONG DstCy = prclDst->bottom - prclDst->top;

                //
                // allocate surface as same size as dst
                //

                dbmi.cxBitmap = DstCx;
                dbmi.cyBitmap = DstCy;
                dbmi.iFormat  = pSurfSrc->iFormat();
                dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
                dbmi.hpal     = (HPALETTE)NULL;

                if (palSurf.bValid())
                {
                    dbmi.hpal     = palSurf.hpal();
                }

                bStatus = surfTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                if (bStatus)
                {

                    RECTL  rclCopy;

                    rclCopy.left   = 0;
                    rclCopy.right  = DstCx;
                    rclCopy.top    = 0;
                    rclCopy.bottom = DstCy;

                    surfTmpSrc.ps->hdev(pSurfSrc->hdev());

                    //
                    // if src is same size as dest, init with CopyBits
                    //

                    POINTL ptlCopy;

                    ptlCopy.x = prclSrc->left;
                    ptlCopy.y = prclSrc->top;

                    (*PPFNGET(pdoSrc,CopyBits,pSurfSrc->flags()))(
                              surfTmpSrc.ps->pSurfobj(),
                              pSurfSrc->pSurfobj(),
                              (CLIPOBJ *) NULL,
                              (XLATEOBJ *)NULL,
                              &rclCopy,
                              &ptlCopy);

                    //
                    // adjust prclSrc to be the new rect
                    //

                    *prclSrc = rclCopy;

                    //
                    // mark surface to keep, set return status
                    //

                    psurfRet = surfTmpSrc.ps;
                }
                else
                {
                    psurfRet = NULL;
                }
            }
        }
    }

    return(psurfRet);
}

/******************************Public*Routine******************************\
* psSetupDstSurface
*
*   Create temporary destination surface for alpha and gradient fill,
*   if necessary, and optionally copy bits from the 
*   actual destination surface.
*
* Arguments:
*
*   pSurfDst        -  actual destination surface
*   prclDst         -  rectangle on dest surface
*   surfTmpDst      -  reference to surfmem
*   bForceDstAlloc  -  force allocation of temp dest
*   bCopyFromDst    -  copy bits from actual destination surface
*
* Return Value:
*
*   surface to use, either original or new
*
* History:
*
*    25-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PSURFACE
psSetupDstSurface(
    PSURFACE pSurfDst,
    PRECTL   prclDst,
    SURFMEM  &surfTmpDst,
    BOOL     bForceDstAlloc,
    BOOL     bCopyFromDst
    )
{
    PSURFACE psurfRet = pSurfDst;

    LONG DstCx = prclDst->right  - prclDst->left;
    LONG DstCy = prclDst->bottom - prclDst->top;

    BOOL bStatus = FALSE;

    if (bForceDstAlloc || (pSurfDst->iType() != STYPE_BITMAP))
    {
        DEVBITMAPINFO   dbmi;
        PDEVOBJ         pdoDst( pSurfDst->hdev());
        XEPALOBJ        palSurf(pSurfDst->ppal());

        //
        // allocate surface
        //

        dbmi.cxBitmap = DstCx;
        dbmi.cyBitmap = DstCy;
        dbmi.iFormat  = pSurfDst->iFormat();
        dbmi.fl       = pSurfDst->bUMPD() ? UMPD_SURFACE : 0;

        dbmi.hpal     = (HPALETTE) 0;

        if (palSurf.bValid())
        {
            dbmi.hpal     = palSurf.hpal();
        }

        bStatus = surfTmpDst.bCreateDIB(&dbmi, (VOID *) NULL);

        if (bStatus)
        {
            RECTL  rclCopy;
            POINTL ptlCopy;

            surfTmpDst.ps->hdev(pSurfDst->hdev());

            rclCopy.left   = 0;
            rclCopy.right  = DstCx;
            rclCopy.top    = 0;
            rclCopy.bottom = DstCy;

            if (bCopyFromDst)
            {
                ptlCopy.x = prclDst->left;
                ptlCopy.y = prclDst->top;
 
                bStatus = (*PPFNGET(pdoDst,CopyBits,pSurfDst->flags()))(
                          surfTmpDst.pSurfobj(),
                          pSurfDst->pSurfobj(),
                          (CLIPOBJ *) NULL,
                          &xloIdent,
                          &rclCopy,
                          &ptlCopy);
            }

            if (bStatus)
            {
                //
                // adjust dst rect
                //
                
                *prclDst = rclCopy;
                psurfRet = surfTmpDst.ps;
            }
            else
            {
                psurfRet = NULL;
            }
        }
        else
        {
            psurfRet = NULL;
        }
    }

    return(psurfRet);
}

#if defined(_X86_)

/**************************************************************************\
* IsMMXProcessor
*
*   determine if the processor supports MMX
*
* Arguments:
*
*   none
*
* Return Value:
*
*   TRUE if MMX
*
* History:
*
*    4/10/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bIsMMXProcessor(VOID)
{
    BOOL  retval = FALSE;

    #if 0

        PVOID pFloatingPointState = (PVOID)PALLOCMEM(sizeof(KFLOATING_SAVE) + sizeof(BOOL),'pftG');

        if (pFloatingPointState != NULL)
        {
            BOOL bRet = EngSaveFloatingPointState(pFloatingPointState,sizeof(KFLOATING_SAVE) + sizeof(BOOL));

            if (bRet)
            {

                __try
                {
                    _asm emms
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    retval = FALSE;
                }

                EngRestoreFloatingPointState(pFloatingPointState);
            }
            else
            {
                WARNING1("bIsMMXProcessor: Failed to save fp state\n");
                retval = FALSE;
            }

            VFREEMEM(pFloatingPointState);
        }
        else
        {
            WARNING1("bIsMMXProcessor: Failed to allocate fpstate\n");
            retval = FALSE;
        }

    #else

   if (ExIsProcessorFeaturePresent(3)) // PF_MMX_INSTRUCTION_AVAILABLE
    {
        retval = TRUE;
    }

    #endif


    return retval;
}

#endif

/**************************************************************************\
*  bDetermineAlphaBlendFunction
*
*   determine alpha blending routine based on src and dst formats
*   and alpha BlendFunction
*
* Arguments:
*
*   pSurfDst       - dest surface
*   pSurfSrc       - src surface
*   ppalDst        - dest palette
*   ppalSrc        - src palette
*   cxDst          - width of alpha blt
*   pAlphaDispatch - blend function and routines
*
* Return Value:
*
*   status
*
* History:
*
*    1/21/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bDetermineAlphaBlendFunction(
    PSURFACE                  pSurfDst,
    PSURFACE                  pSurfSrc,
    XEPALOBJ                 *ppalDst,
    XEPALOBJ                 *ppalSrc,
    XLATE                    *pxlateSrcTo32,
    LONG                      cxDst,
    PALPHA_DISPATCH_FORMAT    pAlphaDispatch
    )
{
    BOOL bRet               = TRUE;
    BOOL bSrcHasAlpha       = FALSE;
    pAlphaDispatch->bUseMMX = FALSE;

    //
    // does src bitmap have alpha
    //

    bSrcHasAlpha = (pAlphaDispatch->BlendFunction.AlphaFormat & AC_SRC_ALPHA);

    //
    // assume default blend, check for special cases
    //

    pAlphaDispatch->pfnGeneralBlend = vAlphaPerPixelOnly;

    //
    // use "over" optimized blend fucntion
    //

    if (bSrcHasAlpha && (pAlphaDispatch->BlendFunction.SourceConstantAlpha == 255))
    {
        pAlphaDispatch->pfnGeneralBlend = vAlphaPerPixelOnly;

        #if defined(_X86_)

            //
            // source and dest alignment must be 8 byte aligned to use mmx
            //

            if (gbMMXProcessor && (cxDst >= 8))
            {
                pAlphaDispatch->pfnGeneralBlend = mmxAlphaPerPixelOnly;
                pAlphaDispatch->bUseMMX         = TRUE;
            }

        #endif
    }
    else
    {
        //
        // if source format doesn't support alpha then use
        // constant alpha routine
        //

        if (bSrcHasAlpha)
        {
            //
            // blend source and dest using SourceAlpha and
            // source bitmaps integral alpha
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaPerPixelAndConst;

            #if defined(_X86_)

                //
                // source and dest alignment must be 8 byte aligned to use mmx
                //

                if (gbMMXProcessor && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxAlphaPerPixelAndConst;
                    pAlphaDispatch->bUseMMX         = TRUE;
                }

            #endif
        }
        else
        {
            //
            // blend src and dest using SourceConstantAlpha.
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaConstOnly;
        }
    }

    //
    // determine output conversion and storage routines
    //

    switch (pSurfDst->iFormat())
    {
    case BMF_1BPP:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert1ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo1;
        pAlphaDispatch->ulDstBitsPerPixel    = 1;
        break;

    case BMF_4BPP:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert4ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo4;
        pAlphaDispatch->ulDstBitsPerPixel    = 4;
        break;

    case BMF_8BPP:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert8ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo8;
        pAlphaDispatch->ulDstBitsPerPixel    = 8;
        break;

    case BMF_16BPP:

        ASSERTGDI((ppalDst->bIsBitfields()),"AlphaBlt: RGB16 palette must be bitfields");

        if (
             (ppalDst->flRed() == 0xf800) &&
             (ppalDst->flGre() == 0x07e0) &&
             (ppalDst->flBlu() == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB16_565ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16_565;
        }
        else if (
             (ppalDst->flRed() == 0x7c00) &&
             (ppalDst->flGre() == 0x03e0) &&
             (ppalDst->flBlu() == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB16_555ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16_555;
        }
        else
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert16BitfieldsToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16Bitfields;
        }

        pAlphaDispatch->ulDstBitsPerPixel    = 16;

        break;

    case BMF_24BPP:


        // WINBUG #101656 bhouse 5-4-2000 AlphaBlend reversing R and B channels
        // when rendering to 24BPP

        if (
             (ppalDst->bIsBGR()) ||
             (
               (ppalDst->bIsBitfields()) &&
               (
                 (
                   (ppalDst->flRed() == 0xff0000) &&
                   (ppalDst->flGre() == 0x00ff00) &&
                   (ppalDst->flBlu() == 0x0000ff)
                 ) ||
                 (
                   (ppalDst->flRed() == 0x000000) &&
                   (ppalDst->flGre() == 0x000000) &&
                   (ppalDst->flBlu() == 0x000000)
                 )
               )
             )
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertBGR24ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToBGR24;
            pAlphaDispatch->ulDstBitsPerPixel    = 24;
        }
        else
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB24ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB24;
            pAlphaDispatch->ulDstBitsPerPixel    = 24;
        }
        break;

    case BMF_32BPP:

        if (
             (ppalDst->bIsBGR()) ||
             (
               (ppalDst->bIsBitfields()) &&
               (
                 (
                   (ppalDst->flRed() == 0xff0000) &&
                   (ppalDst->flGre() == 0x00ff00) &&
                   (ppalDst->flBlu() == 0x0000ff)
                 ) ||
                 (
                   (ppalDst->flRed() == 0x000000) &&
                   (ppalDst->flGre() == 0x000000) &&
                   (ppalDst->flBlu() == 0x000000)
                 )
               )
             )
           )
        {
            //
            // assigned to null indicates no conversion needed
            //

            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;
        }
        else if (ppalDst->flPal() & PAL_RGB)
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB32ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB32;
        }
        else
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert32BitfieldsToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo32Bitfields;
        }

        pAlphaDispatch->ulDstBitsPerPixel    = 32;

        break;
    default:
        WARNING("bDetermineAlphaBlendFunction: Illegal bitmap format\n");
        bRet = FALSE;
    }

    //
    // determine input load and conversion routine
    //

    switch (pSurfSrc->iFormat())
    {
    case BMF_1BPP:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert1ToBGRA;
        pAlphaDispatch->ulSrcBitsPerPixel    = 1;
        break;

    case BMF_4BPP:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert4ToBGRA;
        pAlphaDispatch->ulSrcBitsPerPixel    = 4;
        break;

    case BMF_8BPP:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert8ToBGRA;
        pAlphaDispatch->ulSrcBitsPerPixel    = 8;
        break;

    case BMF_16BPP:

        ASSERTGDI((ppalSrc->bIsBitfields()),"AlphaBlt: RGB16 palette must be bitfields");

        if ((ppalSrc->flRed() == 0xf800) &&
            (ppalSrc->flGre() == 0x07e0) &&
            (ppalSrc->flBlu() == 0x001f))
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB16_565ToBGRA;
        }
        else if ((ppalSrc->flRed() == 0x7c00) &&
                 (ppalSrc->flGre() == 0x03e0) &&
                 (ppalSrc->flBlu() == 0x001f))
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB16_555ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert16BitfieldsToBGRA;
        }

        pAlphaDispatch->ulSrcBitsPerPixel    = 16;

        break;

    case BMF_24BPP:

        // WINBUG #101656 bhouse 5-4-2000 AlphaBlend reversing R and B channels
        // when rendering to 24BPP

        if ((ppalSrc->bIsBGR()) ||
             (
               (ppalSrc->bIsBitfields()) &&
               (
                 (
                   (ppalSrc->flRed() == 0xff0000) &&
                   (ppalSrc->flGre() == 0x00ff00) &&
                   (ppalSrc->flBlu() == 0x0000ff)
                 ) ||
                 (
                   (ppalSrc->flRed() == 0x000000) &&
                   (ppalSrc->flGre() == 0x000000) &&
                   (ppalSrc->flBlu() == 0x000000)
                 )
               )
             )
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertBGR24ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB24ToBGRA;
        }
        
        pAlphaDispatch->ulSrcBitsPerPixel    = 24;

        break;

    case BMF_32BPP:

        if ( 
             (pxlateSrcTo32 == NULL) ||
             (ppalSrc->bIsBGR()) ||
             (
               (ppalSrc->bIsBitfields()) &&
               (
                 (
                   (ppalSrc->flRed() == 0xff0000) &&
                   (ppalSrc->flGre() == 0x00ff00) &&
                   (ppalSrc->flBlu() == 0x0000ff)
                 ) ||
                 (
                   (ppalSrc->flRed() == 0x000000) &&
                   (ppalSrc->flGre() == 0x000000) &&
                   (ppalSrc->flBlu() == 0x000000)
                 )
               )
             )
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
        }
        else if (ppalSrc->flPal() & PAL_RGB)
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB32ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert32BitfieldsToBGRA;
        }
        pAlphaDispatch->ulSrcBitsPerPixel = 32;

        break;
    default:
        WARNING("bDetermineAlphaBlendFunction: Illegal bitmap format\n");
        bRet = FALSE;
    }

    //
    // 16/24 bit per pixel blend optimization
    //

    if (pAlphaDispatch->pfnGeneralBlend == vAlphaConstOnly)
    {
        if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB16_555ToBGRA) &&
            (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB16_555ToBGRA))
        {
            //
            // use direct 16 bpp blend
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaConstOnly16_555;

            #if defined(_X86_)

                if (gbMMXProcessor && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxAlphaConstOnly16_555;
                    pAlphaDispatch->bUseMMX         = TRUE;
                }

            #endif

            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;

            //
            // convert blend function from x/255 to y/31
            //

            int ia = pAlphaDispatch->BlendFunction.SourceConstantAlpha;

            ia = (ia * 31 + 128)/255;
            pAlphaDispatch->BlendFunction.SourceConstantAlpha = (BYTE)ia;
        }
        else if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB16_565ToBGRA) &&
                 (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB16_565ToBGRA))
        {
            //
            // use direct 16 bpp blend
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaConstOnly16_565;

            #if defined(_X86_)

                if (gbMMXProcessor && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxAlphaConstOnly16_565;
                    pAlphaDispatch->bUseMMX         = TRUE;
                }

            #endif


            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;

            //
            // convert blend function from x/255 to y/31
            //

            int ia = pAlphaDispatch->BlendFunction.SourceConstantAlpha;

            ia = (ia * 31 + 128)/255;
            pAlphaDispatch->BlendFunction.SourceConstantAlpha = (BYTE)ia;
        }
        else if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB24ToBGRA) &&
                 (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB24ToBGRA))
        {
            //
            // use direct 24 bpp blend
            //

            pAlphaDispatch->pfnGeneralBlend = vAlphaConstOnly24;

            #if defined(_X86_)

                if (gbMMXProcessor && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxAlphaConstOnly24;
                    pAlphaDispatch->bUseMMX         = TRUE;
                }

            #endif

            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* EngAlphaBlend
*
*   Implement alpha blending
*
* Arguments:
*
*   psoDst        - destination surface
*   psoSrc        - source surface
*   pco           - clip object
*   pxloSrcTo32   - translate src to 32 bgr
*   pxloDstTo32   - translate dst to 32 bgr
*   pxlo32ToDst   - translate 32bgr to dst
*   prclDst       - dest rect
*   prclSrc       - src rect
*   BlendFunction - blend function
*
* Return Value:
*
*   status
*
* History:
*
*    21-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/
BOOL
EngAlphaBlend(
    SURFOBJ       *psoDst,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDst,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj
    )
{
    BOOL bRet = TRUE;

    ASSERTGDI((prclSrc->left < prclSrc->right) &&
              (prclSrc->top < prclSrc->bottom) &&
              (prclDst->left < prclDst->right) &&
              (prclDst->top < prclDst->bottom),
        "Invalid rectangles");

    EBLENDOBJ *peBlendObj = (EBLENDOBJ*)pBlendObj;
    PSURFACE pSurfDst  = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfSrcTmp;
    PSURFACE pSurfDstTmp;
    BOOL     bAllocDstSurf = FALSE;
    XLATE   *pxlateSrcTo32 = (XLATE *)peBlendObj->pxloSrcTo32;
    XLATE   *pxlateDstTo32 = (XLATE *)peBlendObj->pxloDstTo32;
    XLATE   *pxlate32ToDst = (XLATE *)peBlendObj->pxlo32ToDst;
    RECTL    rclDstWk = *prclDst;
    RECTL    rclSrcWk = *prclSrc;
    POINTL   ptlSrc;
    CLIPOBJ *pcoDstWk = pco;

    ALPHA_DISPATCH_FORMAT AlphaDispatch;

    //
    // check blend
    //

    AlphaDispatch.BlendFunction = peBlendObj->BlendFunction;

    ASSERTGDI(peBlendObj->BlendFunction.BlendOp == AC_SRC_OVER,
        "Invalid blend");

    //
    // must be alpha to pull palette information from xlates
    //

    SURFMEM  surfTmpDst;
    SURFMEM  surfTmpSrc;

    //
    // For profiling purposes, set a flag in the PDEV to indicate that the
    // driver punted this call.
    //

    {
        PDEVOBJ po(pSurfDst->hdev());
        if (po.bValid())
        {
            po.vDriverPuntedCall(TRUE);
        }
    }

    if(peBlendObj->BlendFunction.BlendFlags & AC_USE_HIGHQUALITYFILTER)
    {
        BOOL bStretch = FALSE;
        
        bStretch = ((rclDstWk.right - rclDstWk.left) != (rclSrcWk.right - rclSrcWk.left)) ||
                   ((rclDstWk.bottom - rclDstWk.top) != (rclSrcWk.bottom - rclSrcWk.top));

        // Call EngHTBlt only when we have to stretch. When we dont have to
        // stretch we fall through to the old 1:1 EngAlphaBlend code.
        if(bStretch)
            return EngHTBlt(psoDst,
                            psoSrc,
                            NULL,
                            pco,
                            pxlo,
                            NULL,
                            &gptlZero,
                            prclDst,
                            prclSrc,
                            NULL,
                            BBPF_DO_ALPHA_BLEND,
                            pBlendObj) == HTBLT_SUCCESS ? TRUE : FALSE ;
    }

    //
    // Synchronize with the device driver before touching the device surface.
    //

    {
        PDEVOBJ poDst(psoDst->hdev);
        poDst.vSync(psoDst, NULL, 0);
            
        PDEVOBJ poSrc(psoSrc->hdev);
        poSrc.vSync(psoSrc, NULL, 0);
    }

    //
    // Get a readable source surface that is stretched to the destination size.
    //

    pSurfSrcTmp = psSetupTransparentSrcSurface(
                        pSurfSrc,
                        pSurfDst,
                        &rclDstWk,
                        (XLATEOBJ *)pxlateSrcTo32,
                        &rclSrcWk,
                        surfTmpSrc,
                        SOURCE_ALPHA,
                        0);

    if ((pSurfSrcTmp != NULL) && (rclDstWk.left != rclDstWk.right))
    {
        //
        // save final reduced dst rect. psSetupDstSurface may change rclDstWk to
        // to a temp dib rect.
        //

        RECTL rclDstSurface = rclDstWk;

        //
        // temp surface rect is now same size as dst rect, just need point offset
        //

        ptlSrc.x = rclSrcWk.left;
        ptlSrc.y = rclSrcWk.top;

        //
        // get a dst surface that can be written to, remember since it may have to
        // be written back
        //

        pSurfDstTmp = psSetupDstSurface(
                            pSurfDst,
                            &rclDstWk,
                            surfTmpDst,
                            FALSE,
                            TRUE);

        if (pSurfDstTmp)
        {
            if (pSurfDstTmp != pSurfDst)
            {
                bAllocDstSurf = TRUE;
            }

            XEPALOBJ palSrc(pSurfSrcTmp->ppal());
            XEPALOBJ palDst(pSurfDstTmp->ppal());

            //
            // must have one valid surface palette. Must pass drawing routines
            // two good palettes so duplicate good pointer
            //

            if (!palSrc.bValid())
            {
                //
                // get source surface palette
                //
                // first try the palette translate, because the sprite code
                // doesn't want to stick the palette in the surface
                //

                XLATE* pxlate = (XLATE*) pxlo;
                if ((pxlate != NULL) && (pxlate->ppalSrc != NULL))
                {
                    palSrc.ppalSet(pxlate->ppalSrc);
                }
                else
                {
                    PDEVOBJ pdo(pSurfSrcTmp->hdev());
                    palSrc.ppalSet(pdo.ppalSurf());
                }

                ASSERTGDI(palSrc.bValid(),"EngAlphaBlend:can't get source palette");
            }

            if (!palDst.bValid())
            {
                //
                // get destination surface palette
                //

                PDEVOBJ pdo(pSurfDstTmp->hdev());

                ASSERTGDI(pdo.bValid(),"EngAlphaBlend:can't get destination palette");

                palDst.ppalSet(pdo.ppalSurf());
            }

            //
            // validate palettes
            //

            if (palSrc.bValid() && palDst.bValid())
            {
                LONG cxDst = rclDstWk.right - rclDstWk.left;

                //
                // if using a temp dst, no need to clip except to bounding rect
                //

                if (bAllocDstSurf)
                {
                    pcoDstWk = NULL;
                }

                //
                // determine blend function
                //

                bRet = bDetermineAlphaBlendFunction(pSurfDstTmp,
                                                    pSurfSrcTmp,
                                                    &palDst,
                                                    &palSrc,
                                                    pxlateSrcTo32,
                                                    cxDst,
                                                    &AlphaDispatch);

                //
                // NOTE:
                // May be able to move setup of expensive EXLATE to and from 32 to
                // here only for case where non-direct blending is needed
                //

                if (bRet)
                {
                    KFLOATING_SAVE fsFpState;

                    //
                    // if alpha routines use MMX, must save and restore floating
                    // point state
                    //
    
                    if (bRet && AlphaDispatch.bUseMMX)
                    {
                        NTSTATUS status = KeSaveFloatingPointState(&fsFpState);
    
                        ASSERTGDI(NT_SUCCESS(status), 
                            "Unexpected KeSaveFloatingPointState failure");
                    }

                    //
                    // Determine the clipping region complexity.
                    //

                    CLIPENUMRECT    clenr;
                    BOOL            bMore;
                    ULONG           ircl;

                    //
                    // default (pcoDstWk = NULL) is use Dst rect as single clip rect,
                    // same as DC_TRIVIAL
                    //

                    bMore = FALSE;
                    clenr.c = 1;
                    clenr.arcl[0] = rclDstWk;

                    if (pcoDstWk != (CLIPOBJ *) NULL)
                    {
                        switch(pcoDstWk->iDComplexity)
                        {
                        case DC_TRIVIAL:
                            break;
                        case DC_RECT:
                            bMore = FALSE;
                            clenr.c = 1;
                            clenr.arcl[0] = pcoDstWk->rclBounds;
                            break;

                        case DC_COMPLEX:
                            bMore = TRUE;
                            ((ECLIPOBJ *) pcoDstWk)->cEnumStart(FALSE,
                                                           CT_RECTANGLES,
                                                           CD_LEFTDOWN,
                                                           CLIPOBJ_ENUM_LIMIT);
                            break;

                        default:
                            RIP("ERROR EngCopyBits bad clipping type");

                        }
                    }

                    //
                    // run through clipping enum
                    //

                    do
                    {
                        if (bMore)
                        {
                            bMore = ((ECLIPOBJ *) pcoDstWk)->bEnum(sizeof(clenr),
                                                              (PVOID) &clenr);
                        }

                        for (ircl = 0; ircl < clenr.c; ircl++)
                        {
                            PRECTL prcl = &clenr.arcl[ircl];

                            //
                            // Insersect the clip rectangle with the target rectangle to
                            // determine visible recangle
                            //

                            if (prcl->left < rclDstWk.left)
                            {
                                prcl->left = rclDstWk.left;
                            }

                            if (prcl->right > rclDstWk.right)
                            {
                                prcl->right = rclDstWk.right;
                            }

                            if (prcl->top < rclDstWk.top)
                            {
                                prcl->top = rclDstWk.top;
                            }

                            if (prcl->bottom > rclDstWk.bottom)
                            {
                                prcl->bottom = rclDstWk.bottom;
                            }

                            //
                            // Process the result if it's a valid rectangle.
                            //

                            if ((prcl->top < prcl->bottom) && (prcl->left < prcl->right))
                            {
                                POINTL pptlSrcOffset;

                                //
                                // Figure out the upper-left coordinates of rects to blt.
                                // NOTE: does not do right->left or bottom->top
                                //

                                pptlSrcOffset.x = ptlSrc.x + prcl->left - rclDstWk.left;
                                pptlSrcOffset.y = ptlSrc.y + prcl->top  - rclDstWk.top;

                                bRet = AlphaScanLineBlend(
                                            (PBYTE)pSurfDstTmp->pvScan0(),
                                            prcl,
                                            pSurfDstTmp->lDelta(),
                                            (PBYTE)pSurfSrcTmp->pvScan0(),
                                            pSurfSrcTmp->lDelta(),
                                            &pptlSrcOffset,
                                            pxlateSrcTo32,
                                            pxlateDstTo32,
                                            pxlate32ToDst,
                                            palDst,
                                            palSrc,
                                            &AlphaDispatch
                                            );
                            }
                        }

                    } while (bMore);

                    //
                    // if there is a dst temp surface, need to blt it to
                    // dst, then free
                    //

                    if (bAllocDstSurf)
                    {
                        PDEVOBJ pdoDst(pSurfDst->hdev());
                        POINTL  ptlCopy = {0,0};

                        (*PPFNGET(pdoDst,CopyBits,pSurfDst->flags()))(
                                  pSurfDst->pSurfobj(),
                                  pSurfDstTmp->pSurfobj(),
                                  pco,
                                  &xloIdent,
                                  &rclDstSurface,
                                  &ptlCopy);
                    }

                    //
                    // restore fp state if MMX used
                    //

                    if (AlphaDispatch.bUseMMX)
                    {
                        KeRestoreFloatingPointState(&fsFpState);
                    }
                }
            }
            else
            {
                bRet = FALSE;
            }
        }
        else
        {
            WARNING1("EngAlphaBlend: failed to allocate and copy surface\n");
            bRet = FALSE;
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiAlphaBlend
*
*   Kernel stub for alpha blending
*
* Arguments:
*
*   hdcDst        - dst dc
*   DstX          - dst x origin
*   DstY          - dst y origin
*   DstCx         - dst width
*   DstCy         - dst height
*   hdcSrc        - src dc
*   SrcX          - src x origin
*   SrcY          - src y origin
*   SrcCx         - src width
*   SrcCy         - src height
*   BlendFunction - blend function
*
* Return Value:
*
*   status
*
* History:
*
*    27-Jun-1997 Added rotation support -by- Ori Gershony [orig]
*
*    21-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
NtGdiAlphaBlend(
    HDC                hdcDst,
    LONG               DstX,
    LONG               DstY,
    LONG               DstCx,
    LONG               DstCy,
    HDC                hdcSrc,
    LONG               SrcX,
    LONG               SrcY,
    LONG               SrcCx,
    LONG               SrcCy,
    BLENDFUNCTION      BlendFunction,
    HANDLE             hcmXform
    )
{
    BOOL bStatus = TRUE;
    BOOL bQuickStretch = FALSE;

    //
    // check blend, only support AC_SRC_OVER now
    //

    if ((BlendFunction.BlendOp      != AC_SRC_OVER) ||
        ((BlendFunction.AlphaFormat & (~ AC_SRC_ALPHA)) != 0))
    {
        WARNING1("NtGdiAlphaBlend: invalid blend function\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if ((SrcCx == 0) || (SrcCy == 0))
    {
        //
        // Src rectangle is empty--nothing to do.
        //
        return TRUE;
    }
    
    //
    // no mirroring
    //
    
    if ((DstCx < 0) || (DstCy < 0) || (SrcCx < 0) || (SrcCy < 0)) 
    {
        WARNING1("NtGdiAlphaBlend: mirroring not allowed\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    
    BOOL bMirrorBitmap = (BlendFunction.BlendFlags & AC_MIRRORBITMAP);
    BlendFunction.BlendFlags &= ~AC_MIRRORBITMAP;

    //
    // validate dst DC
    //

    DCOBJ  dcoDst(hdcDst);

    if (!(dcoDst.bValid()) || dcoDst.bStockBitmap())
    {
        WARNING1("NtGdiAlphaBlend failed:  invalid dst DC");
        EngSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    DCOBJ  dcoSrc(hdcSrc);

    if (dcoSrc.bValid())
    {
        EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);
        EXFORMOBJ xoSrc(dcoSrc, WORLD_TO_DEVICE);

        //
        // no source rotation
        //

        if (!xoSrc.bRotationOrMirroring())
        {
            //
            // Return null operations.  Don't need to check source for
            // empty because the xforms are the same except translation.
            //

            ERECTL erclSrc(SrcX,SrcY,SrcX+SrcCx,SrcY+SrcCy);
            xoSrc.bXform(erclSrc);
            erclSrc.vOrder();

             
            //
            // If destination has a rotation, compute a bounding box for the
            // resulting parallelogram
            //
            POINTFIX pptfxDst[4];
            ERECTL erclDst;
            BOOL bRotationDst;

            if ((bRotationDst = xoDst.bRotationOrMirroring()))
            {
                //
                // Compute the resulting parallelogram.  In order to make sure we don't lose
                // precision in the rotation, we will store the output of the transformation
                // in fixed point numbers (this is how PlgBlt does it and we want our output
                // to match).
                // 
                POINTL pptlDst[3];

                pptlDst[0].x = DstX;
                pptlDst[0].y = DstY;

                pptlDst[1].x = DstX+DstCx;
                pptlDst[1].y = DstY;

                pptlDst[2].x = DstX;
                pptlDst[2].y = DstY+DstCy;

                xoDst.bXform(pptlDst, pptfxDst, 3);

                if (!xoDst.bRotation()) 
                {
                    //
                    // Mirroring transforms hack:  back in windows 3.1, they used to shift
                    // by one for mirroring transforms.  We need to support this here to
                    // be compatible with NT's BitBlt/StretchBlt that also use this hack, and
                    // also to be compatible with AlphaBlend that calls BitBlt/StretchBlt
                    // code when constant alpha=255 and there's no per-pixel alpha.  Ick!
                    // See BLTRECORD::vOrderStupid for details.  Also see bug 319917.
                    //

                    if (pptfxDst[0].x > pptfxDst[1].x) 
                    {
                        //
                        // Mirroring in x
                        //
                        pptfxDst[0].x += LTOFX(1);
                        pptfxDst[1].x += LTOFX(1);
                        pptfxDst[2].x += LTOFX(1);
                    }

                    if (pptfxDst[0].y > pptfxDst[2].y) 
                    {
                        //
                        // Mirroring in y
                        //
                        pptfxDst[0].y += LTOFX(1);
                        pptfxDst[1].y += LTOFX(1);
                        pptfxDst[2].y += LTOFX(1);
                    }
                }

                //
                // Compute the fourth point using the first three points.
                //
                pptfxDst[3].x = pptfxDst[1].x + pptfxDst[2].x - pptfxDst[0].x;
                pptfxDst[3].y = pptfxDst[1].y + pptfxDst[2].y - pptfxDst[0].y;

                //
                // Compute the bounding box.  Algorithm borrowed from Donald Sidoroff's code
                // in EngPlgBlt.  Basically the first two statements decide whether the indices of
                // the extremas are odd or even, and the last two statements determine exactly what
                // they are.
                //
                int iLeft = (pptfxDst[1].x > pptfxDst[0].x) == (pptfxDst[1].x > pptfxDst[3].x);
                int iTop  = (pptfxDst[1].y > pptfxDst[0].y) == (pptfxDst[1].y > pptfxDst[3].y);
                 
                if (pptfxDst[iLeft].x > pptfxDst[iLeft ^ 3].x)
                {
                    iLeft ^= 3;
                }
                 
                if (pptfxDst[iTop].y > pptfxDst[iTop ^ 3].y)
                {
                    iTop ^= 3;
                }

                erclDst = ERECTL(LONG_CEIL_OF_FIX(pptfxDst[iLeft  ].x),
                                 LONG_CEIL_OF_FIX(pptfxDst[iTop   ].y),
                                 LONG_CEIL_OF_FIX(pptfxDst[iLeft^3].x),
                                 LONG_CEIL_OF_FIX(pptfxDst[iTop^3 ].y));

                //
                // The vertices should now be in vOrder, but it doesn't hurt to verify this...
                //
                ASSERTGDI((erclDst.right  >= erclDst.left), "NtGdiAlphaBlend:  erclDst not in vOrder");
                ASSERTGDI((erclDst.bottom >= erclDst.top),  "NtGdiAlphaBlend:  erclDst not in vOrder");
            }
            else
            {
                //
                // No rotation--just apply the transformation to the rectangle
                //
               
                erclDst = ERECTL(DstX,DstY,DstX+DstCx,DstY+DstCy);
                xoDst.bXform(erclDst);
                erclDst.vOrder();
            }


            if (!erclDst.bEmpty())
            {
                //
                // Accumulate bounds.  We can do this outside the DEVLOCK
                //

                if (dcoDst.fjAccum())
                {
                    dcoDst.vAccumulate(erclDst);
                }

                //
                // Lock the Rao region and the surface if we are drawing on a
                // display surface.  Bail out if we are in full screen mode.
                //

                DEVLOCKBLTOBJ dlo;
                BOOL bLocked;

                bLocked = dlo.bLock(dcoDst, dcoSrc);

                if (bLocked)
                {
                    //
                    // Check pSurfDst, this may be an info DC or a memory DC with default bitmap.
                    //

                    SURFACE *pSurfDst;

                    if ((pSurfDst = dcoDst.pSurface()) != NULL)
                    {
                        XEPALOBJ   palDst(pSurfDst->ppal());
                        XEPALOBJ   palDstDC(dcoDst.ppal());

                        SURFACE *pSurfSrc = dcoSrc.pSurface();

                        //
                        // Basically we check that pSurfSrc is not NULL which
                        // happens for memory bitmaps with the default bitmap
                        // and for info DC's.  Otherwise we continue if
                        // the source is readable or if it isn't we continue
                        // if we are blting display to display or if User says
                        // we have ScreenAccess on this display DC.  Note
                        // that if pSurfSrc is not readable the only way we
                        // can continue the blt is if the src is a display.
                        //

                        if (pSurfSrc != NULL)
                        {
                            if ((pSurfSrc->bReadable()) ||
                                ( (dcoSrc.bDisplay())  &&
                                  ((dcoDst.bDisplay()) || UserScreenAccessCheck() )))
                            {

                                // Make sure that if the user claims that the source contains an 
                                // Alpha channel, it's a 32BPP source.  This is important, because
                                // the driver has no way of checking whether the source is 32BPP.

                                if ((BlendFunction.AlphaFormat & AC_SRC_ALPHA) &&
                                    (!(bIsSourceBGRA(pSurfSrc))))
                                {
                                    WARNING("NtGdiAlphaBlend:  AlphaFormat claims that there is an Alpha channel in a surface that's not 32BPP");
                                    EngSetLastError(ERROR_INVALID_PARAMETER);
                                    return FALSE;
                                }

                                
                                //
                                // With a fixed DC origin we can change the destination to SCREEN coordinates.
                                //

                                //
                                // This is useful later for rotations
                                //
                                ERECTL erclDstOrig = erclDst;                                 

                                erclDst += dcoDst.eptlOrigin();
                                erclSrc += dcoSrc.eptlOrigin();

                                //
                                // Make sure the source rectangle lies completely within the source
                                // surface.
                                //

                                BOOL bBadRects; 

                                // If the source is a Meta device, we must check bounds taking its 
                                // origin into account. 

                                PDEVOBJ pdoSrc( pSurfSrc->hdev() ); 

                                if( pSurfSrc->iType() == STYPE_DEVICE && 
                                    pdoSrc.bValid() && pdoSrc.bMetaDriver())
                                {
                                    bBadRects = ((erclSrc.left < pdoSrc.pptlOrigin()->x) ||
                                                    (erclSrc.top  < pdoSrc.pptlOrigin()->y) ||
                                                    (erclSrc.right  > pdoSrc.pptlOrigin()->x + 
                                                     pSurfSrc->sizl().cx) ||
                                                    (erclSrc.bottom > pdoSrc.pptlOrigin()->y + 
                                                     pSurfSrc->sizl().cy));
                                }
                                else
                                {
                                    bBadRects = ((erclSrc.left < 0) ||
                                                    (erclSrc.top  < 0) ||
                                                    (erclSrc.right  > pSurfSrc->sizl().cx) ||
                                                    (erclSrc.bottom > pSurfSrc->sizl().cy));
                                }

                                if (bBadRects)
                                {
                                    WARNING("NtGdiAlphaBlend -- source rectangle out of surface bounds");
                                }
                                
                                //
                                // Make sure that source and destination rectangles don't overlap if the
                                // source surface is the same as the destination surface.                                
                                //

                                if (pSurfSrc == pSurfDst)
                                {
                                    ERECTL erclIntersection = erclSrc;
                                    erclIntersection *= erclDst;
                                    if (!erclIntersection.bEmpty())
                                    {
                                        bBadRects = TRUE;
                                        WARNING ("NtGdiAlphaBlend -- source and destination rectangles are on the same surface and overlap");
                                    }
                                }
                                    
                                if (!bBadRects)
                                {

                                    //
                                    // check for quick out
                                    //

                                    if ((BlendFunction.SourceConstantAlpha == 255) &&
                                        (!(BlendFunction.AlphaFormat & AC_SRC_ALPHA)) &&
                                        (!(BlendFunction.BlendFlags & AC_USE_HIGHQUALITYFILTER)))
                                    {
                                        // BUGFIX #331222 2-2-2001
                                        // Set stretch mode to COLORONCOLOR for duration of GreStretchBlt call
                                        // AlphaBlend always point samples when stretching

                                        BYTE jStretchBltMode = dcoDst.pdc->jStretchBltMode();

                                        dcoDst.pdc->jStretchBltMode(COLORONCOLOR);

                                        bStatus = GreStretchBlt(
                                            hdcDst,
                                            DstX,
                                            DstY,
                                            DstCx,
                                            DstCy,
                                            hdcSrc,
                                            SrcX,
                                            SrcY,
                                            SrcCx,
                                            SrcCy,
                                            SRCCOPY,
                                            0xffffffff);

                                         bQuickStretch = TRUE;

                                         dcoDst.pdc->jStretchBltMode(jStretchBltMode);

                                    }

                                    //
                                    // no quick out
                                    //

                                    if (bStatus & !bQuickStretch)
                                    {

                                        XEPALOBJ palSrc(pSurfSrc->ppal());
                                        XEPALOBJ palSrcDC(dcoSrc.ppal());
                                        EXLATEOBJ xlo,xlo1,xloSrcDCto32,xloDstDCto32,xlo32toDstDC;
                                        XLATEOBJ *pxlo,*pxloSrcDCto32,*pxloDstDCto32,*pxlo32toDstDC;
    
                                        XEPALOBJ  palRGB(gppalRGB);
    
                                        //
                                        // Get a translate object from source dc to BGRA
                                        //
    
                                        COLORREF crBackColor = dcoSrc.pdc->ulBackClr();
    
                                        //
                                        // src to dst
                                        //

                                        bStatus = xlo.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palSrc,
                                            palDst,
                                            palSrcDC,
                                            palDstDC,
                                            dcoSrc.pdc->crTextClr(),
                                            dcoSrc.pdc->crBackClr(),
                                            crBackColor
                                            );
    
                                        pxlo = xlo.pxlo();

                                        //
                                        // src to 32
                                        //

                                        bStatus &= xloSrcDCto32.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palSrc,
                                            palRGB,
                                            palSrcDC,
                                            palSrcDC,
                                            dcoSrc.pdc->crTextClr(),
                                            dcoSrc.pdc->crBackClr(),
                                            crBackColor
                                            );
    
                                        pxloSrcDCto32 = xloSrcDCto32.pxlo();
    
                                        //
                                        // translate from dst dc to BGRA
                                        //
    
                                        bStatus &= xloDstDCto32.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palDst,
                                            palRGB,
                                            palDstDC,
                                            palDstDC,
                                            dcoSrc.pdc->crTextClr(),
                                            dcoSrc.pdc->crBackClr(),
                                            crBackColor
                                            );
    
                                        pxloDstDCto32 = xloDstDCto32.pxlo();
    
                                        //
                                        // create xlate from 32 to dst dc
                                        //
    
                                        bStatus &= xlo32toDstDC.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            palRGB,
                                            palDst,
                                            palDstDC,
                                            palDstDC,
                                            dcoSrc.pdc->crTextClr(),
                                            dcoSrc.pdc->crBackClr(),
                                            crBackColor
                                            );
        
                                        pxlo32toDstDC = xlo32toDstDC.pxlo();

                                        // Compute destination clipping

                                        ECLIPOBJ eco(dcoDst.prgnEffRao(), erclDst);

                                        // Check the destination which is reduced by clipping.

                                        if (eco.erclExclude().bEmpty())
                                        {
                                            // NTBUG #456213 2-4-2000 bhouse Clean up use of multiple return
                                            // perf and size: don't return here
                                            return(TRUE);
                                        }

                                        // Compute the exclusion rectangle.

                                        ERECTL erclExclude = eco.erclExclude();

                                        // If we are going to the same source, prevent bad overlap situations
                                        // Expand exclusion rectangle to cover source rectangle

                                        if (dcoSrc.pSurface() == dcoDst.pSurface())
                                        {
                                            if (erclSrc.left   < erclExclude.left)
                                                erclExclude.left   = erclSrc.left;

                                            if (erclSrc.top    < erclExclude.top)
                                                erclExclude.top    = erclSrc.top;

                                            if (erclSrc.right  > erclExclude.right)
                                                erclExclude.right  = erclSrc.right;

                                            if (erclSrc.bottom > erclExclude.bottom)
                                                erclExclude.bottom = erclSrc.bottom;
                                        }

                                        // We might have to exclude the source or the target, get ready to do either.

                                        DEVEXCLUDEOBJ dxo;

                                        // Lock the source and target LDEVs

                                        PDEVOBJ pdoDst(pSurfDst->hdev());

                                        // They can't both be display

                                        if (dcoSrc.bDisplay())
                                        {
                                            ERECTL ercl(0,0,pSurfSrc->sizl().cx,pSurfSrc->sizl().cy);

                                            if (dcoSrc.pSurface() == dcoDst.pSurface())
                                                ercl *= erclExclude;
                                            else
                                                ercl *= erclSrc;

                                            dxo.vExclude(dcoSrc.hdev(),&ercl,NULL);
                                        }
                                        else if (dcoDst.bDisplay())
                                        {
                                            dxo.vExclude(dcoDst.hdev(),&erclExclude,&eco);
                                        }

                                        //
                                        // Note Win2k App compat: We do
                                        // mirroring only when the caller has
                                        // asked for it. This it to make sure
                                        // apps that worked on win2k are not 
                                        // suddenly mirrored causing problems. 
                                        //
                                        // If we need to do RTL layout then
                                        // we create a temporary surface and
                                        // mirror the source into it. Then
                                        // we use it as the source surface.
                                        //

                                        SURFMEM surfMirrorSrc;

                                        if (bMirrorBitmap &&
                                            (MIRRORED_DC(dcoDst.pdc)) &&
                                            (!MIRRORED_DC_NO_BITMAP_FLIP(dcoDst.pdc)))
                                        {

                                            // Create temporary surface

                                            DEVBITMAPINFO dbmi;

                                            dbmi.cxBitmap = pSurfSrc->sizl().cx;
                                            dbmi.cyBitmap = pSurfSrc->sizl().cy; 
                                            dbmi.iFormat = pSurfSrc->iFormat();
                                            dbmi.fl = 0;
                                            XEPALOBJ palMirrorSrc(pSurfSrc->ppal());
                                            dbmi.hpal = (HPALETTE)palMirrorSrc.hpal();

                                            surfMirrorSrc.bCreateDIB(&dbmi,(VOID*)NULL);

                                            if(!surfMirrorSrc.bValid())
                                            {
                                                WARNING("NtGdiAlphaBlend: Could not create surface to mirror the source");
                                                return FALSE;
                                            }

                                            ERECTL erclMirrorSrc(0,0,pSurfSrc->sizl().cx,pSurfSrc->sizl().cy);
                                            EPOINTL eptlMirrorSrcTopLeft(0,0);

                                            // Copy source surface into the
                                            // temporary

                                            if(!(*PPFNGET(pdoSrc,CopyBits,pSurfSrc->flags()))(
                                                            surfMirrorSrc.ps->pSurfobj(),
                                                            pSurfSrc->pSurfobj(),
                                                            NULL,
                                                            NULL,
                                                            &erclMirrorSrc,
                                                            &eptlMirrorSrcTopLeft))
                                            {
                                                WARNING("NtGdiAlphaBlend: Could not mirror the source");
                                                return FALSE;
                                            }

                                            // Mirror the temporary surface.
                                            (*apfnMirror[surfMirrorSrc.ps->iFormat()])(surfMirrorSrc.ps);

                                            // Use temporary surface as source.
                                            pSurfSrc = surfMirrorSrc.ps;

                                        }


                                        //
                                        // If the destination requires rotation, we allocate a surface and rotate the
                                        // source surface into it.
                                        //

                                        SURFMEM surfMemTmpSrc;

                                        //
                                        // If the source is 32bits and has no per pixel Alpha, we need to first copy it
                                        // and then add per pixel Alpha information (all this before the rotation).
                                        //
                                        
                                        SURFMEM surfMemTmpSrcPreRotate;
                                        
                                        if (bRotationDst)
                                        {
                                            //
                                            // allocate 32bpp BGRA surface for source, must be zero init
                                            //
                                            
                                            DEVBITMAPINFO   dbmi;
                                            
                                            dbmi.cxBitmap = erclDst.right  - erclDst.left;
                                            dbmi.cyBitmap = erclDst.bottom - erclDst.top;
                                            dbmi.iFormat  = BMF_32BPP;
                                            dbmi.fl       = 0;
                                            XEPALOBJ      palRGB(gppalRGB);
                                            dbmi.hpal     = (HPALETTE)palRGB.hpal();

                                            bStatus &= surfMemTmpSrc.bCreateDIB(&dbmi, (VOID *) NULL);

                                            //
                                            // init DIB to transparent
                                            // (so that portions of dst rect not covered by source rect are not drawn)
                                            //
                                            if (bStatus)
                                            {
                                                if (!(BlendFunction.AlphaFormat & AC_SRC_ALPHA))
                                                {
                                                    //
                                                    // Source has no per pixel Alpha.  Need to first
                                                    // copy source to a new bitmap, then set the per pixel Alpha,
                                                    // and only then rotate.
                                                    //
                                                    DEVBITMAPINFO   dbmiPreRotate;

                                                    dbmiPreRotate.cxBitmap = erclSrc.right  - erclSrc.left;
                                                    dbmiPreRotate.cyBitmap = erclSrc.bottom - erclSrc.top;
                                                    dbmiPreRotate.iFormat  = BMF_32BPP;
                                                    dbmiPreRotate.fl       = 0;
                                                    XEPALOBJ      palRGB(gppalRGB);
                                                    dbmiPreRotate.hpal     = (HPALETTE)palRGB.hpal();
                                                    
                                                    bStatus = surfMemTmpSrcPreRotate.bCreateDIB(&dbmiPreRotate, (VOID *) NULL);

                                                    if (bStatus)
                                                    {

                                                        //
                                                        // Make sure the bitmap starts at (0,0), but remember the original
                                                        // starting point in eptlSrcTopLeft
                                                        //
                                                        EPOINTL eptlSrcTopLeft (erclSrc.left, erclSrc.top);
                                                    
                                                        // Make sure the subtraction doesn't overflow
                                                        if (((erclSrc.left < 0) && 
                                                             (-erclSrc.left > MAXLONG/2) && 
                                                             (erclSrc.right > MAXLONG/2)) ||
                                                            ((erclSrc.top < 0) && 
                                                             (-erclSrc.top > MAXLONG/2) && 
                                                             (erclSrc.top > MAXLONG/2)))
                                                        {
                                                            //
                                                            // Fail the call
                                                            //
                                                            WARNING("NtGdiAlphaBlend:  source rectangle too large\n");
                                                            EngSetLastError(ERROR_INVALID_PARAMETER);
                                                            return FALSE;
                                                        }

                                                        erclSrc -= eptlSrcTopLeft;
                                                    
                                                        //
                                                        // Only call EngCopyBits for non-empty rectangles
                                                        //
                                                        if ((erclSrc.right  > erclSrc.left) && 
                                                            (erclSrc.bottom > erclSrc.top) &&
                                                            (eptlSrcTopLeft.x <= pSurfSrc->sizl().cx) &&
                                                            (eptlSrcTopLeft.y <= pSurfSrc->sizl().cy))
                                                        {
                                                            EngCopyBits(
                                                                surfMemTmpSrcPreRotate.ps->pSurfobj(),
                                                                pSurfSrc->pSurfobj(),
                                                                NULL,
                                                                pxloSrcDCto32,
                                                                &erclSrc,
                                                                &eptlSrcTopLeft
                                                                );
                                                        }
                                                        
                                                        
                                                        //
                                                        // Now set the Alpha channel to 255 (opaque)
                                                        //
                                                        
                                                        PULONG pulDstY     = (PULONG)surfMemTmpSrcPreRotate.ps->pvScan0();
                                                        PULONG pulDstLastY = (PULONG)((PBYTE)pulDstY + 
                                                                                      (surfMemTmpSrcPreRotate.ps->lDelta() * 
                                                                                       surfMemTmpSrcPreRotate.ps->sizl().cy));
                                                        LONG DstYCount = 0;
                                                        while (pulDstY != pulDstLastY)
                                                        {
                                                            if ((DstYCount >= erclSrc.top) &&
                                                                (DstYCount < erclSrc.bottom))
                                                            {
                                                                PULONG pulDstX     = pulDstY;
                                                                PULONG pulDstLastX = pulDstX + surfMemTmpSrcPreRotate.ps->sizl().cx;
                                                                LONG DstXCount = 0;
                                                                while (pulDstX != pulDstLastX)
                                                                {
                                                                    if ((DstXCount >= erclSrc.left) &&
                                                                        (DstXCount < erclSrc.right))
                                                                    {
                                                                        *pulDstX = *pulDstX | 0xff000000;
                                                                    }
                                                                    DstXCount++;
                                                                    pulDstX++;
                                                                }
                                                            }
                                                            
                                                            DstYCount++;
                                                            pulDstY = (PULONG)((PBYTE)pulDstY + surfMemTmpSrcPreRotate.ps->lDelta());
                                                        }                                                    
                                                    

                                                        // 
                                                        // Set source surface to pre rotated bitmap, and set color
                                                        // translation to trivial
                                                        //
                                                        pSurfSrc = surfMemTmpSrcPreRotate.ps;

                                                        pxloSrcDCto32 = &xloIdent;

                                                        //
                                                        // Now we have an Alpha channel
                                                        //
                                                        BlendFunction.AlphaFormat |= AC_SRC_ALPHA;
                                                        
                                                    }
                                                }
                                                //
                                                // Source is 32bit with per pixel Alpha.  Make sure everything
                                                // is transparent before the EngPlgBlt call.
                                                //
                                                RtlFillMemoryUlong(surfMemTmpSrc.ps->pvBits(),
                                                                   surfMemTmpSrc.ps->cjBits(),
                                                                   0x00000000);
                                            }
                                            if (!bStatus)
                                            {
                                                //
                                                // Fail the call
                                                //
                                                WARNING("NtGdiAlphaBlend:  failed to create temporary DIB\n");
                                                EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                                                return FALSE;
                                            }
                                  
    
                                            //
                                            // Now define the parallelogram the source bitmap is mapped to in surfMemTmpSrc
                                            //
      
                                            EPOINTFIX eptlNewSrc[3];
    
                                            eptlNewSrc[0] = EPOINTFIX(
                                                pptfxDst[0].x - LTOFX(erclDstOrig.left), 
                                                pptfxDst[0].y - LTOFX(erclDstOrig.top)
                                                );

                                            eptlNewSrc[1] = EPOINTFIX(
                                                pptfxDst[1].x - LTOFX(erclDstOrig.left), 
                                                pptfxDst[1].y - LTOFX(erclDstOrig.top)
                                                );
    
                                            eptlNewSrc[2] = EPOINTFIX(
                                                pptfxDst[2].x - LTOFX(erclDstOrig.left), 
                                                pptfxDst[2].y - LTOFX(erclDstOrig.top)
                                                );

                                            EngPlgBlt(
                                                surfMemTmpSrc.ps->pSurfobj(),
                                                pSurfSrc->pSurfobj(),
                                                NULL,   // No mask
                                                NULL,   // No clipping object
                                                pxloSrcDCto32,
                                                NULL,   // No color adjustment
                                                NULL,   
                                                eptlNewSrc,
                                                &erclSrc,
                                                NULL,
                                                COLORONCOLOR 
                                                );


                                            //
                                            // Now adjust the local variables.  First fix color translation.         
                                            //

                                            //
                                            // src to dst
                                            //

                                            bStatus = xlo1.bInitXlateObj(
                                                NULL,
                                                DC_ICM_OFF,
                                                palRGB,
                                                palDst,
                                                NULL,
                                                palDstDC,
                                                dcoSrc.pdc->crTextClr(),
                                                dcoSrc.pdc->crBackClr(),
                                                crBackColor
                                                );
    
                                            pxlo = xlo1.pxlo();

                                            //
                                            // src to 32
                                            //

                                            pxloSrcDCto32 = &xloIdent;


                                            pSurfSrc = surfMemTmpSrc.ps;
                                            erclSrc.left = 0;
                                            erclSrc.top = 0;
                                            erclSrc.right = erclDst.right - erclDst.left;
                                            erclSrc.bottom = erclDst.bottom - erclDst.top;
                                        }

                                        if (bStatus)
                                        {
                                            //
                                            // Inc the target surface uniqueness
                                            //

                                            INC_SURF_UNIQ(pSurfDst);

                                            //
                                            // Dispatch the call.  Give it no mask.
                                            //

                                            //
                                            // Check were on the same PDEV, we can't blt between
                                            // different PDEV's.  We could make blting between different
                                            // PDEV's work easily.  All we need to do force EngBitBlt to
                                            // be called if the PDEV's aren't equal in the dispatch.
                                            // EngBitBlt does the right thing.
                                            //

                                            if (dcoDst.hdev() == dcoSrc.hdev())
                                            {
                                                EBLENDOBJ eBlendObj;

                                                eBlendObj.BlendFunction = BlendFunction;
                                                eBlendObj.pxloSrcTo32   = pxloSrcDCto32;
                                                eBlendObj.pxloDstTo32   = pxloDstDCto32;
                                                eBlendObj.pxlo32ToDst   = pxlo32toDstDC;

                                                //
                                                // dispatch to driver or engine
                                                //

                                                if ( (erclDst.right - erclDst.left) == (erclSrc.right - erclSrc.left) &&
                                                     (erclDst.bottom - erclDst.top) == (erclSrc.bottom - erclSrc.top) )
                                                {
                                                    eBlendObj.BlendFunction.BlendFlags &= ~AC_USE_HIGHQUALITYFILTER;
                                                }

                                                bStatus = (*PPFNGET(pdoDst,AlphaBlend, pSurfDst->flags())) (
                                                    pSurfDst->pSurfobj(),
                                                    pSurfSrc->pSurfobj(),
                                                    &eco,
                                                    pxlo,
                                                    &erclDst,
                                                    &erclSrc,
                                                    (BLENDOBJ *)&eBlendObj
                                                    );
                                            }
                                            else
                                            {
                                                WARNING1("NtGdiAlphaBlend failed: source and destination surfaces not on same PDEV");
                                                EngSetLastError(ERROR_INVALID_PARAMETER);
                                                bStatus = FALSE;
                                            }
                                        
                                        }
                                        else
                                        {
                                            WARNING1("bInitXlateObj failed in NtGdiAlphaBlend\n");
                                            EngSetLastError(ERROR_INVALID_HANDLE);
                                            bStatus = FALSE;
                                        }
                                    }
                                    else
                                    {
                                        //
                                        // Nothing to do--the call to GreStretchBlt succeeded.
                                        //
                                        NULL;
                                    }
                                }
                                else
                                {
                                    EngSetLastError(ERROR_INVALID_PARAMETER);
                                    bStatus = FALSE;
                                }
                            }
                            else
                            {
                                WARNING1("NtGdiAlphaBlend failed - trying to read from unreadable surface\n");
                                EngSetLastError(ERROR_INVALID_HANDLE);
                                bStatus = FALSE;
                            }
                        }
                        else
                        {
                            bStatus = TRUE; // pSurfSrc is NULL
                        }
                    }
                    else
                    {
                        bStatus = TRUE; // pSurfDst is NULL
                    }
                }
                else
                {
                    //
                    // Return True if we are in full screen mode.
                    //

                    bStatus = dcoDst.bFullScreen() | dcoSrc.bFullScreen();
                }
            }
            else
            {
                bStatus = TRUE; // erclDst is empty
            }
        }
        else
        {
            bStatus = FALSE;
            EngSetLastError(ERROR_INVALID_PARAMETER);
            WARNING1("Error in NtGdiAlphaBlend:  source rotation is not allowed");
        }        
    } 
    else
    {
        bStatus = FALSE;
        EngSetLastError(ERROR_INVALID_PARAMETER);
        WARNING1("NtGdiAlphaBlend failed:  invalid src DC");
    }
    
    return(bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\alphatran.cxx ===
/******************************Module*Header*******************************\
* Module Name: tranblt.cxx
*
* Transparent BLT
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/
#include "precomp.hxx"


/**************************************************************************\
*
* XLATE_TO_BGRA  - match palette indexed color to BGRA
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/9/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define XLATE_TO_BGRA(pxlo,cIndex,ulDst)                \
        if (cIndex > pxlo->cEntries)                    \
        {                                               \
            cIndex = cIndex % pxlo->cEntries;           \
        }                                               \
                                                        \
        ulDst = ((XLATE *) pxlo)->ai[cIndex]

/******************************Public*Routine******************************\
* Routines to load a pixel and convert it to BGRA representaion for
* blending operations
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert1ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    XLATEOBJ *pxlo
    )
{
    BYTE SrcByte;

    ASSERTGDI((pxlo->flXlate & XO_TABLE),"vLoadAndConvert1ToBGRA: xlate must be XO_TABLE");

    if (pxlo->flXlate & XO_TABLE)
    {

        pSrcAddr = pSrcAddr + (SrcX >> 3);

        LONG cxUnalignedStart = 7 & (8 - (SrcX & 7));

        cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

        //
        // unaligned start
        //

        if (cxUnalignedStart)
        {
            LONG iDst = 7 - (SrcX & 0x07);
            SrcByte = *pSrcAddr;
            pSrcAddr++;

            while (cxUnalignedStart--)
            {
                ULONG ulDst = ((SrcByte & (1 << iDst)) >> iDst);

                XLATE_TO_BGRA(pxlo,ulDst,ulDst);

                ulDst = ulDst | 0xFF000000;

                *pulDstAddr = ulDst;

                pulDstAddr++;
                SrcCx--;
                iDst--;
            }
        }

        //
        // aligned whole bytes
        //

        while (SrcCx >= 8)
        {
            ULONG ulDst;
            ULONG ulIndex;

            SrcCx -= 8;

            SrcByte = *pSrcAddr;

            ulIndex = (ULONG)((SrcByte & 0x80) >> 7);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 0) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x40) >> 6);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 1) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x20) >> 5);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 2) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x10) >> 4);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 3) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x08) >> 3);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 4) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x04) >> 2);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 5) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x02) >> 1);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 6) = ulDst | 0xff000000;

            ulIndex = ((SrcByte & 0x01) >> 0);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 7) = ulDst | 0xff000000;

            pSrcAddr++;
            pulDstAddr+=8;
        }

        //
        // unaligned end
        //

        if (SrcCx)
        {
            BYTE SrcByte = *pSrcAddr;
            LONG iDst    = 7;

            while (SrcCx)
            {
                ULONG ulDst = ((SrcByte & (1 << iDst)) >> iDst);

                XLATE_TO_BGRA(pxlo,ulDst,ulDst);

                *pulDstAddr = ulDst | 0xff000000;

                pulDstAddr++;
                SrcCx--;
                iDst--;
            }
        }
    }
}

/**************************************************************************\
* vLoadAndConvert4ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert4ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    ASSERTGDI((pxlo->flXlate & XO_TABLE),"vLoadAndConvert1ToBGRA: xlate must be XO_TABLE");

    if (pxlo->flXlate & XO_TABLE)
    {
        ULONG ulIndex;
        ULONG ulDst;
        BYTE  SrcByte;
        LONG  cxUnalignedStart;

        pSrcAddr         = pSrcAddr + (SrcX >> 1);
        cxUnalignedStart = 1 & (2 - (SrcX & 1));
        cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

        //
        // unaligned start
        //

        if (cxUnalignedStart)
        {
            SrcByte = *pSrcAddr;

            ulIndex = (SrcByte & 0x0f);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);

            *pulDstAddr = ulDst | 0xff000000;
            pSrcAddr++;
            pulDstAddr++;
            SrcCx--;
        }

        //
        // aligned whole bytes
        //

        while (SrcCx >= 2)
        {
            SrcCx -= 2;

            SrcByte = *pSrcAddr;

            ulIndex = (SrcByte >> 4);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 0) = ulDst | 0xff000000;

            ulIndex = (SrcByte & 0x0f);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *(pulDstAddr + 1) = ulDst | 0xff000000;

            pSrcAddr++;
            pulDstAddr+=2;
        }

        //
        // unaligned end
        //

        if (SrcCx)
        {
            SrcByte = *pSrcAddr;
            ulIndex = (SrcByte >> 4);
            XLATE_TO_BGRA(pxlo,ulIndex,ulDst);
            *pulDstAddr = ulDst | 0xff000000;
        }
    }
}

/**************************************************************************\
* vLoadAndConvert8ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert8ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    ASSERTGDI((pxlo->flXlate & XO_TABLE),"vLoadAndConvert1ToBGRA: xlate must be XO_TABLE");

    if (pxlo->flXlate & XO_TABLE)
    {
        PBYTE pjSrc = pSrcAddr + SrcX;
        PBYTE pjEnd = pjSrc + SrcCx;

        while (pjSrc != pjEnd)
        {
            ALPHAPIX apix;
            BYTE     jTemp;
            ULONG    ulDst;

            ulDst = (ULONG)*pjSrc;
            XLATE_TO_BGRA(pxlo,ulDst,ulDst);

            apix.ul = ulDst | 0xff000000;

            *pulDstAddr = apix.ul;

            pulDstAddr++;
            pjSrc++;
        }
    }

}

/**************************************************************************\
* vLoadAndConvertRGB16_565ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_565ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    ULONG    ul;

    //
    // unaligned single at start
    //

    if ((ULONG_PTR)pusSrc & 0x02)
    {
        ul = *pusSrc;

        *pulDstAddr =    (((ul << 8) & 0xf80000)
                        | ((ul << 3) & 0x070000)
                        | ((ul << 5) & 0x00fc00)
                        | ((ul >> 1) & 0x000300)
                        | ((ul << 3) & 0x0000f8)
                        | ((ul >> 2) & 0x000007)
                        | 0xff000000);

        pusSrc++;
        pulDstAddr++;
        SrcCx--;
    }

    //
    // aligned
    //

    PUSHORT pusEnd = pusSrc + (SrcCx & ~1);

    while (pusSrc != pusEnd)
    {
        ul = *(PULONG)pusSrc;

        *pulDstAddr =    (((ul << 8) & 0xf80000)
                        | ((ul << 3) & 0x070000)
                        | ((ul << 5) & 0x00fc00)
                        | ((ul >> 1) & 0x000300)
                        | ((ul << 3) & 0x0000f8)
                        | ((ul >> 2) & 0x000007)
                        | 0xff000000);


        *(pulDstAddr+1) = (((ul >> 8) & 0xf80000)
                        | ((ul >> 13) & 0x070000)
                        | ((ul >> 11) & 0x00fc00)
                        | ((ul >> 17) & 0x000300)
                        | ((ul >> 13) & 0x0000f8)
                        | ((ul >> 18) & 0x000007)
                        | 0xff000000);

        pusSrc+= 2;
        pulDstAddr+=2;
    }

    //
    // end unaligned
    //

    if (SrcCx & 1)
    {
        ul = *pusSrc;

        *pulDstAddr =    (((ul << 8) & 0xf80000)
                        | ((ul << 3) & 0x070000)
                        | ((ul << 5) & 0x00fc00)
                        | ((ul >> 1) & 0x000300)
                        | ((ul << 3) & 0x0000f8)
                        | ((ul >> 2) & 0x000007)
                        | 0xff000000);

    }
}

/**************************************************************************\
* vLoadAndConvertRGB16_555ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_555ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    ULONG   ul;

    //
    // unaligned single at start
    //

    if ((ULONG_PTR)pusSrc & 0x02)
    {
        ul = *pusSrc;

        *pulDstAddr = (((ul << 9) & 0xf80000)
                    | ((ul << 4) & 0x070000)
                    | ((ul << 6) & 0x00f800)
                    | ((ul << 1) & 0x000700)
                    | ((ul << 3) & 0x0000f8)
                    | ((ul >> 2) & 0x000007)
                    | 0xff000000);

        pusSrc++;
        pulDstAddr++;
        SrcCx--;
    }

    //
    // aligned
    //

    PUSHORT pusEnd = pusSrc + (SrcCx & ~1);

    while (pusSrc != pusEnd)
    {
        ULONG ul = *(PULONG)pusSrc;

        *pulDstAddr = (((ul << 9) & 0xf80000)
                    | ((ul << 4) & 0x070000)
                    | ((ul << 6) & 0x00f800)
                    | ((ul << 1) & 0x000700)
                    | ((ul << 3) & 0x0000f8)
                    | ((ul >> 2) & 0x000007)
                    | 0xff000000);

        *(pulDstAddr+1) = (((ul >> 7) & 0xf80000)
                        | ((ul >> 12) & 0x070000)
                        | ((ul >> 10) & 0x00f800)
                        | ((ul >> 15) & 0x000700)
                        | ((ul >> 13) & 0x0000f8)
                        | ((ul >> 18) & 0x000007)
                        | 0xff000000);

        pusSrc+= 2;
        pulDstAddr+=2;
    }

    //
    // end unaligned
    //

    if (SrcCx & 1)
    {
        ul = *pusSrc;

        *pulDstAddr = (((ul << 9) & 0xf80000)
                    | ((ul << 4) & 0x070000)
                    | ((ul << 6) & 0x00f800)
                    | ((ul << 1) & 0x000700)
                    | ((ul << 3) & 0x0000f8)
                    | ((ul >> 2) & 0x000007)
                    | 0xff000000);
    }
}

/**************************************************************************\
* vLoadAndConvert16BitfieldsToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert16BitfieldsToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;
    while (pusSrc != pusEnd)
    {
        ULONG ulTmp;

        ulTmp = *pusSrc;

        ulTmp = (((XLATE *)pxlo)->ulTranslate(ulTmp));

        *pulDstAddr = ulTmp | 0xff000000;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB24ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB24ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PBYTE pjSrc = pSrcAddr + 3 * SrcX;
    PBYTE pjEnd = pjSrc    + 3 * SrcCx;

    while (pjSrc != pjEnd)
    {
        ALPHAPIX pixRet;

        pixRet.pix.r = *(((PBYTE)pjSrc));
        pixRet.pix.g = *(((PBYTE)pjSrc)+1);
        pixRet.pix.b = *(((PBYTE)pjSrc)+2);
        pixRet.pix.a = 0xff;

        *pulDstAddr = pixRet.ul;

        pjSrc += 3;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertBGR24ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    5/4/2000 bhouse
*
\**************************************************************************/

VOID
vLoadAndConvertBGR24ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PBYTE pjSrc = pSrcAddr + 3 * SrcX;
    PBYTE pjEnd = pjSrc    + 3 * SrcCx;

    while (pjSrc != pjEnd)
    {
        ALPHAPIX pixRet;

        pixRet.pix.b = *(((PBYTE)pjSrc));
        pixRet.pix.g = *(((PBYTE)pjSrc)+1);
        pixRet.pix.r = *(((PBYTE)pjSrc)+2);
        pixRet.pix.a = 0xff;

        *pulDstAddr = pixRet.ul;

        pjSrc += 3;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB32ToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB32ToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pulSrc;

        pixOut.pix.r = pixIn.pix.b;
        pixOut.pix.g = pixIn.pix.g;
        pixOut.pix.b = pixIn.pix.r;
        pixOut.pix.a = 0xff;

        *pulDstAddr = pixOut.ul;

        pulSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvert32BitfieldsToBGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert32BitfieldsToBGRA(
    PULONG    pulDstAddr,
    PBYTE     pSrcAddr,
    LONG      SrcX,
    LONG      SrcCx,
    XLATEOBJ *pxlo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ULONG ulTmp;

        ulTmp = *pulSrc;

        ulTmp = (((XLATE *)pxlo)->ulTranslate(ulTmp));
        ulTmp |= 0xff000000;

        *pulDstAddr = ulTmp;

        pulSrc++;
        pulDstAddr++;
    }
}

//
//
// STORE ROUTINES
//
//

#define PALETTE_MATCH(pixIn,ppalDst,ppalDstDC)                \
{                                                             \
    BYTE jSwap;                                               \
                                                              \
    pixIn.pix.a  = 0x02;                                      \
    jSwap        = pixIn.pix.r;                               \
    pixIn.pix.r  = pixIn.pix.b;                               \
    pixIn.pix.b  = jSwap;                                     \
                                                              \
    pixIn.ul = ulGetNearestIndexFromColorref(                 \
                            ppalDst,                          \
                            ppalDstDC,                        \
                            pixIn.ul,                         \
                            ppalDst.cEntries() ?              \
                                SE_DO_SEARCH_EXACT_FIRST  :   \
                                SE_DONT_SEARCH_EXACT_FIRST    \
                                                              \
                            );                                \
}                                                             \

/**************************************************************************\
* vConvertAndSaveBGRATo1
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo1(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pjDst = pDst + (DstX >> 3);
    LONG  iDst  = DstX & 7;

    //
    // unaligned byte
    //

    if (iDst)
    {
        BYTE DstByte     = *pjDst;
        LONG iShift      = 7 - iDst;
        LONG cxUnaligned = iShift + 1;

        cxUnaligned = MIN(cxUnaligned,cx);
        cx -= cxUnaligned;

        while (cxUnaligned--)
        {
            ALPHAPIX  pixIn;

            pixIn.ul = *pulSrc;

            PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);

            pixIn.ul = pixIn.ul << iShift;

            DstByte = DstByte & (~(1 << iShift));
            DstByte |= (BYTE)pixIn.ul;
            pulSrc++;
            iShift--;
        }

        *pjDst = DstByte;
        pjDst++;
    }

    //
    // aligned whole bytes
    //

    while (cx >= 8)
    {
        ALPHAPIX  pixIn;
        BYTE DstByte;

        pixIn.ul = *pulSrc;
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte      = (BYTE)(pixIn.ul << 7);

        pixIn.ul = *(pulSrc+1);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 6);

        pixIn.ul = *(pulSrc+2);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 5);

        pixIn.ul = *(pulSrc+3);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 4);

        pixIn.ul = *(pulSrc+4);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 3);

        pixIn.ul = *(pulSrc+5);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 2);

        pixIn.ul = *(pulSrc+6);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 1);

        pixIn.ul = *(pulSrc+7);
        PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);
        DstByte     |= (BYTE)(pixIn.ul << 0);

        *pjDst = DstByte;

        pjDst++;
        pulSrc += 8;
        cx -= 8;
    }

    //
    // unaligned end
    //

    if (cx)
    {
        BYTE iShift = 7;
        BYTE DstByte = *pjDst;

        while (cx--)
        {
            ALPHAPIX  pixIn;

            pixIn.ul = *pulSrc;

            PALETTE_MATCH(pixIn,ppalDst,ppalDstDC);

            pixIn.ul = pixIn.ul << iShift;
            DstByte = DstByte & (~(1 << iShift));
            DstByte |= (BYTE)pixIn.ul;
            pulSrc++;
            iShift--;
        }

        *pjDst = DstByte;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo4
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo4(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pjDst = pDst + (DstX >> 1);
    LONG  iDst  = DstX & 1;

    PBYTE pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("vConvertAndSaveBGRA: To4Failed to generate rgb333 xlate table\n");
        return;
    }

    //
    // make sure params are valid
    //

    if (cx == 0)
    {
        return;
    }

    //
    // unaligned byte
    //

    if (iDst)
    {
        BYTE DstByte     = *pjDst;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);

        DstByte = (DstByte & 0xf0) | (BYTE)pixIn.ul;

        *pjDst = DstByte;
        pjDst++;
        pulSrc++;
        cx--;
    }

    //
    // aligned whole bytes
    //

    while (cx >= 2)
    {
        BYTE DstByte;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;
        pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);
        DstByte = (BYTE)(pixIn.ul << 4);

        pixIn.ul = *(pulSrc+1);
        pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);
        DstByte |= (BYTE)(pixIn.ul);

        *pjDst = DstByte;

        pjDst++;
        pulSrc += 2;
        cx -= 2;
    }

    //
    // unaligned end
    //

    if (cx)
    {
        BYTE DstByte = *pjDst;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);

        DstByte = (DstByte & 0x0f) | (BYTE)(pixIn.ul << 4);

        *pjDst = DstByte;
    }
}


/**************************************************************************\
* vConvertAndSaveBGRATo8
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo8(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("vConvertAndSaveBGRATo8: Failed to generate rgb333 xlate table\n");
        return;
    }

    PBYTE pjDst = (PBYTE)pDst + DstX;
    PBYTE pjEnd = pjDst + cx;

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

    pixIn.ul = *pulSrc;
    
    pixIn.ul = XLATEOBJ_BGR32ToPalSurf(pxlo,pxlate,pixIn.ul);

    *pjDst = (BYTE)pixIn.ul;

        pulSrc++;
        pjDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_565
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_565(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;
    
    pixOut.ul =    ((pixIn.pix.r & 0xf8) << 8) |
               ((pixIn.pix.g & 0xfc) << 3) |
                       ((pixIn.pix.b & 0xf8) >> 3);


    *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_555
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_555(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;

    pixOut.ul =    ((pixIn.pix.r & 0xf8) << 7) |
                       ((pixIn.pix.g & 0xf8) << 2) |
                       ((pixIn.pix.b & 0xf8) >> 3);

    *pusDst = (USHORT)pixOut.ul;
        
    pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo16Bitfields
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16Bitfields(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;

    pixOut.ul = (((XLATE *)pxlo)->ulTranslate(pixIn.ul));

    *pusDst = (USHORT)pixOut.ul;
        
    pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB24
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB24(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pjDst = (PBYTE)pDst + (3 * DstX);
    PBYTE pjEnd = pjDst + (3 * cx);

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

    pixIn.ul = *pulSrc;

    *pjDst     = pixIn.pix.r;
    *(pjDst+1) = pixIn.pix.g;
    *(pjDst+2) = pixIn.pix.b;
        
    pulSrc++;
        pjDst+=3;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToBGR24
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    5/4/2000 bhouse
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToBGR24(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PBYTE pjDst = (PBYTE)pDst + (3 * DstX);
    PBYTE pjEnd = pjDst + (3 * cx);

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

    pixIn.ul = *pulSrc;

    *pjDst     = pixIn.pix.b;
    *(pjDst+1) = pixIn.pix.g;
    *(pjDst+2) = pixIn.pix.r;
        
    pulSrc++;
        pjDst+=3;
    }
}


/**************************************************************************\
* vConvertAndSaveBGRATo32Bitfields
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo32Bitfields(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PULONG pulDst = (PULONG)pjDst + DstX;
    PULONG pulEnd = pulDst + cx;
    while (pulDst != pulEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;

    pixOut.ul = (((XLATE *)pxlo)->ulTranslate(pixIn.ul));

    *pulDst = pixOut.ul;
        
    pulSrc++;
        pulDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB32
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB32(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    XLATEOBJ    *pxlo,
    XEPALOBJ    ppalDst,
    XEPALOBJ    ppalDstDC
    )
{
    PULONG pulDst = (PULONG)pjDst + DstX;
    PULONG pulEnd = pulDst + cx;
    while (pulDst != pulEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

    pixIn.ul = *pulSrc;

    pixOut.pix.r = pixIn.pix.b;
    pixOut.pix.g = pixIn.pix.g;
    pixOut.pix.b = pixIn.pix.r;
    pixOut.pix.a = 0;

    *pulDst = pixOut.ul;

        pulSrc++;
        pulDst++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\aatext.cxx ===
/******************************Module*Header*******************************\
* Module Name: aatext.cxx                                                  *
*                                                                          *
* Routines for rendering anti aliased text to dib surfaces                 *
*                                                                          *
* Created: 13-Mar-1995 10:44:05                                            *
* Author: Kirk Olynyk [kirko]                                              *
*                                                                          *
* Copyright (c) 1995-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.hxx"

// Function prototypes

typedef VOID (FNCOPYALPHABUFFER)(PBYTE, PBYTE, PBYTE, LONG, PUSHORT *);
typedef VOID (FNSRCTRANCOPY)(PBYTE, LONG, LONG, PBYTE, LONG, LONG, LONG, LONG, 
                              ULONG, ULONG, SURFACE*, FNCOPYALPHABUFFER*);
extern HSEMAPHORE ghsemEUDC2;

extern "C" {
    VOID vSrcTranCopyS4D16(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcTranCopyS4D24(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcTranCopyS4D32(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS4D32(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS4D16(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS4D24(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

    VOID vSrcOpaqCopyS8D16(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS8D24(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcOpaqCopyS8D32(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

    VOID vSrcTranCopyS8D16(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcTranCopyS8D24(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);
    VOID vSrcTranCopyS8D32(
        BYTE*,LONG,LONG,BYTE*,LONG,LONG,LONG,LONG,ULONG,ULONG,SURFACE*);

}

// blend macros for cleartype

#define DIVIDE(A,B) ( ((A)+(B)/2) / (B) )

// blend macros for cleartype
// this is k/6, k = 0,1,...,6 in 12.20 format
// Why 12.20 ? well, we are tring to store 6*256 = 1536 = 600h.
// (the largest possible result of multiplying k*dB),
// this fits in eleven bits, so just to be safe we allow 12 bits for
// integer part and 20 bits for the fractional part.
// By using this we avoid doing divides by 6 in trasparent cases and
// in computation of ct lookup table



LONG alAlpha[7] =
{
0,
DIVIDE(1L << 20, 6),
DIVIDE(2L << 20, 6),
DIVIDE(3L << 20, 6),
DIVIDE(4L << 20, 6),
DIVIDE(5L << 20, 6),
DIVIDE(6L << 20, 6),
};



#define HALF20 (1L << 19)
#define ROUND20(X) (((X) + HALF20) >> 20)
//#define ROUND20(X) ((X) >> 20)
#define BLEND(k,B,dB) ((B) + ROUND20(alAlpha[k] * (dB)))
#define BLENDCT(k,F,B,dB) (ULONG)(BLEND(k,B,dB))

// my test program has determined that regardless of whether we do
// proper rounding in ROUND20 or not, we never arrive at a color that is
// diffent by more than 1 from the value computed the old way
// that is using the old formula:
//
// #define BLEND(k,F,B) (ULONG)DIVIDE((k) * (F) + (6 - (k)) * (B), 6)
//
// the only difference is that if we do rounding, we are wrong in only 2%
// of the cases, and if we do not do rounding we are wrong in 38% of the cases.
// But in either case error is very small.
// Because this is done on a per pixel basis in transparent case, we opt for speed
// and do not do rounding. This saves us 3 additions per pixel.


// John Platt has determined that there are 115 distinct filtered states
// when one starts with (2+2+2)x X 1y scaling for cleartype

#define CT_LOOKUP 115

// filtered counts of RGB

typedef struct _F_RGB
{
    BYTE kR;
    BYTE kG;
    BYTE kB;
    BYTE kPadding;
} F_RGB;

// the max number of foreground virt pixels in a subpixel,  2x X 1y , no filtering

#define CT_SAMPLE_NF  2

// the number of distinct nonfiltered states in a whole pixel = 3 x 3 x 3 = 27
// The indices coming from the rasterizer are in [0,26] range

#define CT_MAX_NF ((CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1))

// the max number of foreground virt pixels in a subpixel AFTER filtering, 6

#define CT_SAMPLE_F   6


// size of the storage table, basically 3^5 = 243.
// The table does filtering and index computation (vector quantization) in one step.


#define CT_STORAGE ((CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1) * (CT_SAMPLE_NF+1))

// The codebook: 115 entries stored as sequential triples of unsigned char
static const F_RGB gaOutTableRGB[CT_LOOKUP] = {
0,0,0,0,
0,0,1,0,
0,0,2,0,
0,1,1,0,
0,1,2,0,
0,1,3,0,
0,2,2,0,
0,2,3,0,
0,2,4,0,
1,0,0,0,
1,0,1,0,
1,0,2,0,
1,1,0,0,
1,1,1,0,
1,1,2,0,
1,1,3,0,
1,2,1,0,
1,2,2,0,
1,2,3,0,
1,2,4,0,
1,3,2,0,
1,3,3,0,
1,3,4,0,
1,3,5,0,
2,0,0,0,
2,0,1,0,
2,0,2,0,
2,1,0,0,
2,1,1,0,
2,1,2,0,
2,1,3,0,
2,2,0,0,
2,2,1,0,
2,2,2,0,
2,2,3,0,
2,2,4,0,
2,3,1,0,
2,3,2,0,
2,3,3,0,
2,3,4,0,
2,3,5,0,
2,4,2,0,
2,4,3,0,
2,4,4,0,
2,4,5,0,
2,4,6,0,
3,1,0,0,
3,1,1,0,
3,1,2,0,
3,1,3,0,
3,2,0,0,
3,2,1,0,
3,2,2,0,
3,2,3,0,
3,2,4,0,
3,3,1,0,
3,3,2,0,
3,3,3,0,
3,3,4,0,
3,3,5,0,
3,4,2,0,
3,4,3,0,
3,4,4,0,
3,4,5,0,
3,4,6,0,
3,5,3,0,
3,5,4,0,
3,5,5,0,
3,5,6,0,
4,2,0,0,
4,2,1,0,
4,2,2,0,
4,2,3,0,
4,2,4,0,
4,3,1,0,
4,3,2,0,
4,3,3,0,
4,3,4,0,
4,3,5,0,
4,4,2,0,
4,4,3,0,
4,4,4,0,
4,4,5,0,
4,4,6,0,
4,5,3,0,
4,5,4,0,
4,5,5,0,
4,5,6,0,
4,6,4,0,
4,6,5,0,
4,6,6,0,
5,3,1,0,
5,3,2,0,
5,3,3,0,
5,3,4,0,
5,4,2,0,
5,4,3,0,
5,4,4,0,
5,4,5,0,
5,5,3,0,
5,5,4,0,
5,5,5,0,
5,5,6,0,
5,6,4,0,
5,6,5,0,
5,6,6,0,
6,4,2,0,
6,4,3,0,
6,4,4,0,
6,5,3,0,
6,5,4,0,
6,5,5,0,
6,6,4,0,
6,6,5,0,
6,6,6,0
};

static const F_RGB gaOutTableBGR[CT_LOOKUP] = {
0,0,0,0,
1,0,0,0,
2,0,0,0,
1,1,0,0,
2,1,0,0,
3,1,0,0,
2,2,0,0,
3,2,0,0,
4,2,0,0,
0,0,1,0,
1,0,1,0,
2,0,1,0,
0,1,1,0,
1,1,1,0,
2,1,1,0,
3,1,1,0,
1,2,1,0,
2,2,1,0,
3,2,1,0,
4,2,1,0,
2,3,1,0,
3,3,1,0,
4,3,1,0,
5,3,1,0,
0,0,2,0,
1,0,2,0,
2,0,2,0,
0,1,2,0,
1,1,2,0,
2,1,2,0,
3,1,2,0,
0,2,2,0,
1,2,2,0,
2,2,2,0,
3,2,2,0,
4,2,2,0,
1,3,2,0,
2,3,2,0,
3,3,2,0,
4,3,2,0,
5,3,2,0,
2,4,2,0,
3,4,2,0,
4,4,2,0,
5,4,2,0,
6,4,2,0,
0,1,3,0,
1,1,3,0,
2,1,3,0,
3,1,3,0,
0,2,3,0,
1,2,3,0,
2,2,3,0,
3,2,3,0,
4,2,3,0,
1,3,3,0,
2,3,3,0,
3,3,3,0,
4,3,3,0,
5,3,3,0,
2,4,3,0,
3,4,3,0,
4,4,3,0,
5,4,3,0,
6,4,3,0,
3,5,3,0,
4,5,3,0,
5,5,3,0,
6,5,3,0,
0,2,4,0,
1,2,4,0,
2,2,4,0,
3,2,4,0,
4,2,4,0,
1,3,4,0,
2,3,4,0,
3,3,4,0,
4,3,4,0,
5,3,4,0,
2,4,4,0,
3,4,4,0,
4,4,4,0,
5,4,4,0,
6,4,4,0,
3,5,4,0,
4,5,4,0,
5,5,4,0,
6,5,4,0,
4,6,4,0,
5,6,4,0,
6,6,4,0,
1,3,5,0,
2,3,5,0,
3,3,5,0,
4,3,5,0,
2,4,5,0,
3,4,5,0,
4,4,5,0,
5,4,5,0,
3,5,5,0,
4,5,5,0,
5,5,5,0,
6,5,5,0,
4,6,5,0,
5,6,5,0,
6,6,5,0,
2,4,6,0,
3,4,6,0,
4,4,6,0,
3,5,6,0,
4,5,6,0,
5,5,6,0,
4,6,6,0,
5,6,6,0,
6,6,6,0
};


// The encoding lookup table. There are 3^5 possible entries corresponding to
// 5 emmiters: BP, RT, GT, BT, RN

BYTE gajStorageTable[CT_STORAGE] = {
  0,  1,  2,  3,  4,  5,  6,  7,  8,
 13, 14, 15, 17, 18, 19, 21, 22, 23,
 33, 34, 35, 38, 39, 40, 43, 44, 45,
 12, 13, 14, 16, 17, 18, 20, 21, 22,
 32, 33, 34, 37, 38, 39, 42, 43, 44,
 56, 57, 58, 61, 62, 63, 66, 67, 68,
 31, 32, 33, 36, 37, 38, 41, 42, 43,
 55, 56, 57, 60, 61, 62, 65, 66, 67,
 79, 80, 81, 84, 85, 86, 88, 89, 90,
  9, 10, 11, 13, 14, 15, 17, 18, 19,
 28, 29, 30, 33, 34, 35, 38, 39, 40,
 52, 53, 54, 57, 58, 59, 62, 63, 64,
 27, 28, 29, 32, 33, 34, 37, 38, 39,
 51, 52, 53, 56, 57, 58, 61, 62, 63,
 75, 76, 77, 80, 81, 82, 85, 86, 87,
 50, 51, 52, 55, 56, 57, 60, 61, 62,
 74, 75, 76, 79, 80, 81, 84, 85, 86,
 95, 96, 97, 99,100,101,103,104,105,
 24, 25, 26, 28, 29, 30, 33, 34, 35,
 47, 48, 49, 52, 53, 54, 57, 58, 59,
 71, 72, 73, 76, 77, 78, 81, 82, 83,
 46, 47, 48, 51, 52, 53, 56, 57, 58,
 70, 71, 72, 75, 76, 77, 80, 81, 82,
 92, 93, 94, 96, 97, 98,100,101,102,
 69, 70, 71, 74, 75, 76, 79, 80, 81,
 91, 92, 93, 95, 96, 97, 99,100,101,
106,107,108,109,110,111,112,113,114
};

BYTE gajStorageTableBloated[CT_STORAGE] = {
  0,  2,  5,  6,  8,  8, 22, 23, 23,
 33, 35, 40, 43, 45, 45, 44, 45, 45,
 61, 63, 63, 66, 68, 68, 67, 68, 68,
 31, 33, 38, 41, 43, 43, 66, 67, 67,
 79, 81, 86, 88, 90, 90, 89, 90, 90,
 84, 86, 86, 88, 90, 90, 89, 90, 90,
 74, 76, 81, 84, 86, 86, 85, 86, 86,
 95, 97,101,103,105,105,104,105,105,
 99,101,101,103,105,105,104,105,105,
 24, 26, 30, 33, 35, 35, 58, 59, 59,
 71, 73, 78, 81, 83, 83, 82, 83, 83,
 96, 98, 98,100,102,102,101,102,102,
 69, 71, 76, 79, 81, 81,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 91, 93, 97, 99,101,101,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 46, 48, 53, 56, 58, 58, 81, 82, 82,
 92, 94, 98,100,102,102,101,102,102,
 96, 98, 98,100,102,102,101,102,102,
 69, 71, 76, 79, 81, 81,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114,
 91, 93, 97, 99,101,101,100,101,101,
106,108,111,112,114,114,113,114,114,
109,111,111,112,114,114,113,114,114
};

static const F_RGB * gaOutTable = gaOutTableRGB;

/* illegal index in gajStorage1[] has been set to the closest legal index,  NT bug #435222 */
BYTE gajStorage1[7*7*7] =
{
0x00,0x01,0x02,0x02,0x05,0x05,0x08,0x00,0x03,0x04,0x05,0x05,0x08,0x08,0x03,0x03,
0x06,0x07,0x08,0x08,0x17,0x10,0x06,0x06,0x07,0x08,0x17,0x17,0x10,0x14,0x14,0x15,
0x16,0x17,0x17,0x14,0x14,0x14,0x15,0x16,0x17,0x2d,0x29,0x29,0x29,0x2a,0x2b,0x2c,
0x2d,0x09,0x0a,0x0b,0x0b,0x0f,0x0f,0x13,0x0c,0x0d,0x0e,0x0f,0x0f,0x13,0x13,0x0c,
0x10,0x11,0x12,0x13,0x13,0x17,0x10,0x10,0x14,0x15,0x16,0x17,0x17,0x24,0x14,0x14,
0x15,0x16,0x17,0x2d,0x24,0x29,0x29,0x2a,0x2b,0x2c,0x2d,0x29,0x29,0x29,0x2a,0x2b,
0x2c,0x2d,0x18,0x19,0x1a,0x1a,0x1e,0x1e,0x23,0x1b,0x1c,0x1d,0x1e,0x1e,0x23,0x23,
0x1f,0x20,0x21,0x22,0x23,0x23,0x28,0x1f,0x24,0x25,0x26,0x27,0x28,0x28,0x24,0x24,
0x29,0x2a,0x2b,0x2c,0x2d,0x24,0x29,0x29,0x2a,0x2b,0x2c,0x2d,0x29,0x29,0x41,0x41,
0x42,0x43,0x44,0x18,0x19,0x1a,0x31,0x31,0x31,0x36,0x2e,0x2f,0x30,0x31,0x31,0x36,
0x36,0x32,0x33,0x34,0x35,0x36,0x36,0x3b,0x32,0x37,0x38,0x39,0x3a,0x3b,0x3b,0x37,
0x37,0x3c,0x3d,0x3e,0x3f,0x40,0x37,0x3c,0x3c,0x41,0x42,0x43,0x44,0x3c,0x3c,0x41,
0x41,0x42,0x43,0x44,0x2e,0x2f,0x30,0x31,0x31,0x49,0x49,0x2e,0x2f,0x30,0x31,0x49,
0x49,0x49,0x45,0x46,0x47,0x48,0x49,0x49,0x4e,0x45,0x4a,0x4b,0x4c,0x4d,0x4e,0x4e,
0x4a,0x4a,0x4f,0x50,0x51,0x52,0x53,0x4a,0x4f,0x4f,0x54,0x55,0x56,0x57,0x4f,0x4f,
0x54,0x54,0x58,0x59,0x5a,0x2e,0x2f,0x30,0x31,0x49,0x49,0x49,0x45,0x46,0x47,0x48,
0x49,0x49,0x49,0x45,0x46,0x47,0x48,0x49,0x49,0x4e,0x5b,0x5b,0x5c,0x5d,0x5e,0x4e,
0x4e,0x5b,0x5b,0x5f,0x60,0x61,0x62,0x53,0x5b,0x5f,0x5f,0x63,0x64,0x65,0x66,0x5f,
0x5f,0x63,0x63,0x67,0x68,0x69,0x45,0x46,0x47,0x48,0x49,0x49,0x49,0x45,0x46,0x47,
0x48,0x49,0x49,0x49,0x5b,0x5b,0x5c,0x5d,0x5e,0x5e,0x4e,0x5b,0x5b,0x5c,0x5d,0x5e,
0x5e,0x62,0x5b,0x6a,0x6a,0x6b,0x6c,0x62,0x62,0x6a,0x6a,0x6a,0x6d,0x6e,0x6f,0x66,
0x6a,0x6a,0x6d,0x6d,0x70,0x71,0x72};

// gamma tables

ULONG gulGamma = DEFAULT_CT_CONTRAST;


// all the info needed to perform blends of fore and background pixels

typedef struct _BLENDINFO
{
    int  iRedL; int  iRedR;  // shift numbers
    int  iGreL; int  iGreR;  // shift numbers
    int  iBluL; int  iBluR;  // shift numbers

    ULONG  flRed;            // mask bits
    ULONG  flGre;            // mask bits
    ULONG  flBlu;            // mask bits

    LONG lRedF;              // foreground components
    LONG lGreF;
    LONG lBluF;

    PBYTE pjGamma;           // pointers to gamma tables
    PBYTE pjGammaInv;

} BLENDINFO;




/********************************************************************
*                                                                   *
*    16.16 fix point numbers representing                           *
*                                                                   *
*        aulB[16] = floor(65536 * (a[k]/16)^(1/gamma) + 1/2)        *
*        aulIB[k] = floor(65536 * (1 - a[k]/16)^(1/gamma) + 1/2)    *
*                                                                   *
*    where               a[k] = k == 0 ? 0 : k+1                    *
*                        gamma = 2.33                               *
********************************************************************/
static const ULONG aulB[16] =
{
    0     , 26846 , 31949 , 36148 , 39781 , 43019 , 45961 , 48672 ,
    51196 , 53564 , 55800 , 57923 , 59948 , 61885 , 63745 , 65536
};

static const ULONG aulIB[16] =
{   0     ,  3650 ,  5587 ,  7612 ,  9735 , 11971 , 14339 , 16863 ,
    19574 , 22516 , 25754 , 29387 , 33586 , 38689 , 45597 , 65536
};

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   pvFillOpaqTable                                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   The case of opaqe text is special because the destiantion pixels       *
*   must be chosen from a set of 16 colors. This routine calculates        *
*   those 16 colors and puts them in an array. This array is addressed     *
*   by the value of the 4-bpp antialiased glyph.                           *
*                                                                          *
*   Let k be the value contained in a 4-bpp antialiased glyph value.       *
*   Thus the allowed range for k is                                        *
*                                                                          *
*                        k = 0,1..15                                       *
*                                                                          *
*   This is interpreted as a blending fraction alpha_k given by            *
*                                                                          *
*                    alpha_k = a_k / 16                                    *
*    where                                                                 *
*                                                                          *
*           a_k = (0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)                 *
*                                                                          *
*    The color values are normalized by the maximum color value            *
*    that a color channel can have, i_max                                  *
*                                                                          *
*    For a single color channel, the normalized foreground and             *
*    background colors are given by                                        *
*                                                                          *
*                      c0 = i0 / i_max ,                                   *
*                                                                          *
*                      c1 = i1 / i_max .                                   *
*                                                                          *
*    The blended and gamma corrected color value is                        *
*                                                                          *
*       c_k = (1 - alpha_k) * c0^gam +  alpha_k * c1^gam)^(1/gam)          *
*                                                                          *
*    The unnormalized blended and gamma corrected color values             *
*    are:                                                                  *
*                                                                          *
*            i_k = floor( i_max * c_k + 1/2)                               *
*                                                                          *
*    wbere 'gam'  is the gamma correction value which I have chosen        *
*    to be equal to 2.33.                                                  *
*                                                                          *
*    In order to speed up the caluclation we cut corners by                *
*    making some approximations. The basic idea is to replace              *
*    the slow process of calculating various powers of real                *
*    numbers by table look up's.                                           *
*                                                                          *
*    The first table G[i] is defined as follows:                           *
*                                                                          *
*        G[i] = floor(g_max * (i/i_max)^gam + 1/2) ,                       *
*                                                                          *
*    where                                                                 *
*                                                                          *
*                    0 <= i <= i_max ,                                     *
*    and                                                                   *
*                    0 <= G[i] <= g_max .                                  *
*                                                                          *
*    The second table is essentially the inverse to G[i], which            *
*    I shall call I[j].                                                    *
*                                                                          *
*        I[j] = floor(i_max * (j / j_max)^(1/gam) + 1/2) ,                 *
*                                                                          *
*                      0 <= j <= j_max .                                   *
*                                                                          *
*                i_max = 31      (255)                                     *
*                g_max = 65536                                             *
*                j_max = 256                                               *
*                                                                          *
*    The complete process of calculating the blended and gamma             *
*    corrected color is given by                                           *
*                                                                          *
*                 g   = 16*G[i0];                                          *
*                 dg  = G[i1] - G[i0];                                     *
*                 c   = 16 * g_max / j_max; // 2^12                        *
*                 for (k = 0; k < 16; k++) {                               *
*                    i[k] = I[ (g + c/2)/c];                               *
*                    g += dg;                                              *
*                 }                                                        *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   cj  ............................... size of each array element in      *
*                                       BYTE's.                            *
*                                                                          *
*   uF  ............................... a 32-bit value whose lowest        *
*                                       16 bits contain the foreground     *
*                                       color                              *
*                                                                          *
*   uB  ............................... a 32-bit value whose lowest 16     *
*                                       bits contain the background        *
*                                       color                              *
*                                                                          *
*   pS  ............................... pointer to destination surface     *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   pointer to color table                                                 *
*                                                                          *
\**************************************************************************/

VOID *pvFillOpaqTable(ULONG size, ULONG uF, ULONG uB, SURFACE *pS)
{
    int  iRedL, iRedR;          // shift numbers
    int  iGreL, iGreR;          // shift numbers
    int  iBluL, iBluR;          // shift numbers
    ULONG uRed, dRed, flRed;
    ULONG uGre, dGre, flGre;
    ULONG uBlu, dBlu, flBlu;
    ULONG ul;

    static ULONG aulCache[16];      // set to zero prior to first call
    static HANDLE hCache;           // set to zero prior to first call
    static ULONG  uFCache;
    static ULONG  uBCache;
    static ULONG  sizeCache;
    static VOID *pv = (VOID*) aulCache;

    // I have been assured of two things....
    // 1) Since this routine is a child of EngTextOut then there
    //    will be only one thread in this routine at any one time.
    //    This means that I do not need to protect the color
    //    table, aulCache[] with a critical section
    // 2) I have been assured that the format of a surface
    //    is unique. Thus if the handle of the surface matches
    //    the handle of the cached color table, then the
    //    formats of the surface are the same.

    if (pS->hGet() == hCache && uB == uBCache && uF == uFCache)
    {
        ASSERTGDI(size == sizeCache, "size != sizeCache");
    }
    else
    {
    sizeCache = size;
    uFCache   = uF;
    uBCache   = uB;
    hCache    = pS->hGet();

#if NEVER
    if (size == sizeof(USHORT))
    {
        ASSERTGDI(uF <= USHRT_MAX, "bad uF");
        ASSERTGDI(uB <= USHRT_MAX, "bad uB");
    }
    else if (size == sizeof(ULONG))
    {
        ASSERTGDI(uF < 0x1000000, "bad uF");
        ASSERTGDI(uB < 0x1000000, "bad uB");
    }
    else
    {
        RIP("bad size");
    }
#endif

    XEPALOBJ xpo;

    if(pS->pPal == NULL)
    {
        PDEVOBJ pdo(pS->hdev());
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }
    
    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );


    if (xpo.bIsBitfields())
    {
        flRed = xpo.flRed();
        flGre = xpo.flGre();
        flBlu = xpo.flBlu();

        iRedR = (int) (xpo.cRedRight() + xpo.cRedMiddle() - 8);
        iGreR = (int) (xpo.cGreRight() + xpo.cGreMiddle() - 8);
        iBluR = (int) (xpo.cBluRight() + xpo.cBluMiddle() - 8);
    }
    else
    {
        int cBits;
        ULONG flBits;

        if (size == sizeof(USHORT))
        {
            // assumes standard RGB is 5+5+5 for 16-bit color
            cBits = 5;
            flBits = 0x1f;
        }
        else
        {
            cBits = 8;
            flBits = 0xff;
        }
        if (xpo.bIsRGB())
        {
            flRed = flBits;
            flGre = flRed << cBits;
            flBlu = flGre << cBits;

            iRedR = cBits - 8;
            iGreR = iRedR + cBits;
            iBluR = iGreR + cBits;
        }
        else if (xpo.bIsBGR())
        {
            flBlu = flBits;
            flGre = flBlu << cBits;
            flRed = flGre << cBits;

            iBluR = cBits - 8;
            iGreR = iBluR + cBits;
            iRedR = iGreR + cBits;
        }
        else
        {
            RIP("Palette format not supported\n");
        }
    }

#define GAMMA (ULONG) RFONTOBJ::gTables[0]
/***************************************************************
*                                                              *
*    Now I shall calculate the shift numbers.                  *
*                                                              *
*    I shall explain the shift numbers for the red channel.    *
*    The green and blue channels are treated in the same way.  *
*                                                              *
*    I want to shift the red bits of the red channel colors    *
*    so that the most significant bit of the red channel       *
*    bits corresponds to a value of 2^7. This means that       *
*    if I mask off all of the other color bits, then I         *
*    will end up with a number between zero and 255. This      *
*    process of going to the 0 .. 255 range looks like         *
*                                                              *
*        ((color & flRed) << iRedL) >> iRedR                   *
*                                                              *
*    Only one of iRedL or iRedR is non zero.                   *
*                                                              *
*    I then use this number to index into a 256 element        *
*    gamma correction table. The gamma correction table        *
*    elements are BYTE values that are in the range 0 .. 255.  *
*                                                              *
***************************************************************/
    iRedL = 0;
    if (iRedR < 0)
    {
        iRedL = - iRedR;
        iRedR = 0;
    }
    uRed  = GAMMA[(((uB & flRed) << iRedL) >> iRedR) & 255];
    dRed  = GAMMA[(((uF & flRed) << iRedL) >> iRedR) & 255];
    dRed -= uRed;
    uRed *= 16;

    iGreL = 0;
    if (iGreR < 0)
    {
        iGreL = - iGreR;
        iGreR = 0;
    }
    uGre  = GAMMA[(((uB & flGre) << iGreL) >> iGreR) & 255];
    dGre  = GAMMA[(((uF & flGre) << iGreL) >> iGreR) & 255];
    dGre -= uGre;
    uGre *= 16;

    iBluL = 0;
    if (iBluR < 0)
    {
        iBluL = - iBluR;
        iBluR = 0;
    }
    uBlu  = GAMMA[(((uB & flBlu) << iBluL) >> iBluR) & 255];
    dBlu  = GAMMA[(((uF & flBlu) << iBluL) >> iBluR) & 255];
    dBlu -= uBlu;
    uBlu *= 16;
#undef GAMMA

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "flRed = %-#x\n"
            "iRedL = %d\n"
            "iRedR = %d\n"
            "uRed  = %-#x\n"
            "dRed  = %-#x\n"
            , flRed, iRedL, iRedR, uRed, dRed
        );
        DbgPrint(
            "flGre = %-#x\n"
            "iGreL = %d\n"
            "iGreR = %d\n"
            "uGre  = %-#x\n"
            "dGre  = %-#x\n"
            , flGre, iGreL, iGreR, uGre, dGre
        );
        DbgPrint(
            "flBlu = %-#x\n"
            "iBluL = %d\n"
            "iBluR = %d\n"
            "uBlu  = %-#x\n"
            "dBlu  = %-#x\n"
            , flBlu, iBluL, iBluR, uBlu, dBlu
        );
    }
#endif

#define IGAMMA (ULONG) RFONTOBJ::gTables[1]

    uRed += dRed;
    uGre += dGre;
    uBlu += dBlu;

    if (size == sizeof(USHORT))
    {
        USHORT *aus = (USHORT*) pv;
        USHORT *pus = aus;

        *pus++  = (USHORT) uB;
#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "Table of 16-bit colors ...\n"
                "------------------------------------\n"
                "    %0-#4x %0-#4x %0-#4x = %0-#6x\n"
            ,   (uB & flRed) >> xpo.cRedRight()
            ,   (uB & flGre) >> xpo.cGreRight()
            ,   (uB & flBlu) >> xpo.cBluRight()
            ,   uB
            );
        }
#endif
        while (pus < aus + 15)
        {
    ul  = (((IGAMMA[(uRed += dRed)/16 & 255] << iRedR) >> iRedL) & flRed);
    ul |= (((IGAMMA[(uGre += dGre)/16 & 255] << iGreR) >> iGreL) & flGre);
    ul |= (((IGAMMA[(uBlu += dBlu)/16 & 255] << iBluR) >> iBluL) & flBlu);
            *pus++  = (USHORT) ul;
#if DBG
            if (gflFontDebug & DEBUG_AA)
            {
                DbgPrint(
                    "    %0-#4x %0-#4x %0-#4x = %0-#6x\n"
                ,   IGAMMA[uRed/16 & 255]
                ,   IGAMMA[uGre/16 & 255]
                ,   IGAMMA[uBlu/16 & 255]
                ,   ul
                );
            }
#endif
        }
        *pus = (USHORT) uF;
#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "    %0-#4x %0-#4x %0-#4x = %0-#6x\n"
            ,   (uF & flRed) >> xpo.cRedRight()
            ,   (uF & flGre) >> xpo.cGreRight()
            ,   (uF & flBlu) >> xpo.cBluRight()
            ,   uF
            );
        }
#endif
    }
    else
    {
        ASSERTGDI(size == sizeof(ULONG), "bad size");
        ULONG *aul = (ULONG*) pv;
        ULONG *pul = aul;

        *pul++  = uB;
#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "Table of 32-bit colors .....\n"
                "------------------------------------\n"
                "    %0-#4x %0-#4x %0-#4x = %0-#8x\n"
            ,   (uB & flRed) >> xpo.cRedRight()
            ,   (uB & flGre) >> xpo.cGreRight()
            ,   (uB & flBlu) >> xpo.cBluRight()
            ,   uB
            );
        }
#endif
        while (pul < aul + 15)
        {
    ul  = (((IGAMMA[(uRed += dRed)/16 & 255] << iRedR) >> iRedL) & flRed);
    ul |= (((IGAMMA[(uGre += dGre)/16 & 255] << iGreR) >> iGreL) & flGre);
    ul |= (((IGAMMA[(uBlu += dBlu)/16 & 255] << iBluR) >> iBluL) & flBlu);
            *pul++  =  ul;
#if DBG
            if (gflFontDebug & DEBUG_AA)
            {
                DbgPrint(
                    "%0-#4x %0-#4x %0-#4x = %0-#8x\n"
                ,   IGAMMA[uRed/16 & 255]
                ,   IGAMMA[uGre/16 & 255]
                ,   IGAMMA[uBlu/16 & 255]
                ,   ul
                );
            }
#endif
        }
        *pul    =  uF;
#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "    %0-#4x %0-#4x %0-#4x = %0-#8x\n"
            ,   (uF & flRed) >> xpo.cRedRight()
            ,   (uF & flGre) >> xpo.cGreRight()
            ,   (uF & flBlu) >> xpo.cBluRight()
            ,   uF
            );
        }
#endif
    }
#undef IGAMMA
    }
    return(pv);
}




// Indices into the default palette

#define I_BLACK      0
#define I_DKGRAY   248
#define I_GRAY       7
#define I_WHITE    255

static const BYTE ajWhiteOnBlack[16] = {
    I_BLACK  , I_BLACK  , I_DKGRAY  , I_DKGRAY
  , I_DKGRAY , I_GRAY   , I_GRAY    , I_GRAY
  , I_GRAY   , I_GRAY   , I_GRAY    , I_WHITE
  , I_WHITE  , I_WHITE  , I_WHITE   , I_WHITE
};

static const BYTE ajBlackOnWhite[16] = {
    I_WHITE  , I_WHITE  , I_WHITE   , I_WHITE
  , I_GRAY   , I_GRAY   , I_GRAY    , I_GRAY
  , I_GRAY   , I_DKGRAY , I_DKGRAY  , I_DKGRAY
  , I_DKGRAY , I_DKGRAY , I_BLACK   , I_BLACK
};

static const BYTE ajBlackOnBlack[16] = {
    I_BLACK, I_BLACK, I_BLACK, I_BLACK,
    I_BLACK, I_BLACK, I_BLACK, I_BLACK,
    I_BLACK, I_BLACK, I_BLACK, I_BLACK,
    I_BLACK, I_BLACK, I_BLACK, I_BLACK
};

static const BYTE ajWhiteOnWhite[16] = {
    I_WHITE, I_WHITE, I_WHITE, I_WHITE,
    I_WHITE, I_WHITE, I_WHITE, I_WHITE,
    I_WHITE, I_WHITE, I_WHITE, I_WHITE,
    I_WHITE, I_WHITE, I_WHITE, I_WHITE
};

#if 0
/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS4D8                                                       *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Copies a 4bpp gray bitmap onto an 8bpp palettized surface. The         *
*   only case that this routine handles is white text on a black           *
*   background or black text on a white background.                        *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*                 This points to a 4-bit per pixel anti-aliased bitmap     *
*                 whose scans start and end on 32-bit boundaries.          *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*                 That is, this is the number of pixels in from the edge   *
*                 of the start of each scan line that the actual pixels    *
*                 of the image begins. All pixels before and after the     *
*                 image pixels of the scan are to be ignored. This offset  *
*                 has been put in to guarantee that 32-bit boundaries      *
*                 in the 4bpp source correspond to 32-bit boundaries       *
*                 in the destination.                                      *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - exclusive right dst pixel                                *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* If the destination suface is 8-bits per pixels then the only form        *
* of antialiased text allowed is opaque textout with foreground and        *
* background are either black or white.                                    *
*                                                                          *
* On palette devices (8-bit devices) we are guaranteed to have 4 shades    *
* of gray to work with. These gray come from 4 of the 20 reserved          *
* entries in the palette and are given by:                                 *
*                                                                          *
*                    name           rgb           index                    *
*                                                                          *
*                    BLACK   (0x00, 0x00, 0x00)     0                      *
*                   DKGRAY   (0x80, 0x80, 0x80)    12                      *
*                     GRAY   (0xc0, 0xc0, 0xc0)     7                      *
*                    WHITE   (0xff, 0xff, 0xff)    19                      *
*                                                                          *
* There are, two cases of interest: 1) white text on black; and 2)         *
* black text on white. The various levels of gray seen on the screen       *
* is controled by the 16 values of blending as defined by each of the      *
* 4-bit gray levels in the glyphs images. The allowed value of blending    *
* are:                                                                     *
*                                                                          *
*                   alpha[i] = (i == 0) ? 0 : (i+1)/16                     *
*                                                                          *
*   where i = <value of 4-bit pixel>                                       *
*                                                                          *
* For case 1) (white text on a black background) the gamma corrected       *
* color channel values are given by:                                       *
*                                                                          *
*           c[i] = floor(255*(alpha[i]^(1/gamma)) + 1/2)                   *
*                                                                          *
* which is equivalent to the following table                               *
*                                                                          *
*                 c[16] = {   0, 104, 124, 141,                            *
*                           155, 167, 179, 189,                            *
*                           199, 208, 217, 225,                            *
*                           233, 241, 248, 255   };                        *
*                                                                          *
* This result applies to each of the three color channels.                 *
*                                                                          *
* The problem is that there are only four colors available: BLACK, DKGRAY, *
* GRAY, WHITE with the color values of 0, 128, 192, and 255 respectively.  *
* This means that the color table that is used is an                       *
* approximation to the correct color table given by:                       *
*                                                                          *
*           c' = { BLACK, BLACK,                                           *
*                  DKGRAY, DKGRAY, DKGRAY,                                 *
*                  GRAY, GRAY, GRAY, GRAY, GRAY, GRAY,                     *
*                  WHITE, WHITE, WHITE, WHITE, WHITE };                    *
*                                                                          *
* For case 2) (black text on white) the gamma corrected color channel      *
* values are given by:                                                     *
*                                                                          *
* d[i] = floor(255*((1-alpha[i])^(1/gamma) + 1/2) = c[15 - i]              *
*    =                                                                     *
*    {                                                                     *
*       255, 248, 241, 233,                                                *
*       225, 217, 208, 199,                                                *
*       189, 179, 167, 155,                                                *
*       141, 124, 104,   0                                                 *
*    };                                                                    *
*                                                                          *
* which is approximated by                                                 *
*                                                                          *
*                 d' = {                                                   *
*                   WHITE, WHITE, WHITE, WHITE,                            *
*                   GRAY, GRAY, GRAY, GRAY, GRAY,                          *
*                   DKGRAY, DKGRAY, DKGRAY, DKGRAY, DKGRAY,                *
*                   BLACK, BLACK                                           *
*                   }                                                      *
*                                                                          *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS4D8(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    int cPreamble, cMiddle, cPostamble, A, B;
    const BYTE *ajIndex;
    BYTE jSrc, *pjSrc, *pjDst;

    static const BYTE *apjIndex[4] = {
        ajBlackOnBlack  // uB = 0    uF = 0
    ,   ajBlackOnWhite  // uB = 0xff uF = 0
    ,   ajWhiteOnBlack  // uB = 0    uF = 0xff
    ,   ajWhiteOnWhite  // uB = 0xff uF = 0xff
    };

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
         "vSrcOpaqCopyS4D8(\n"
         "    PBYTE   pjSrcIn    = %-#x\n"
         "    LONG    SrcLeft    = %d\n"
         "    LONG    DeltaSrcIn = %d\n"
         "    PBYTE   pjDstIn    = %-#x\n"
         "    LONG    DstLeft    = %d\n"
         "    LONG    DstRight   = %d\n"
         "    LONG    DeltaDstIn = %d\n"
         "    LONG    cy         = %d\n"
         "    ULONG   uF         = %-#x\n"
         "    ULONG   uB         = %-#x\n"
         "    SURFACE *pS        = %-#x\n"
         ");\n\n"
        , pjSrcIn
        , SrcLeft
        , DeltaSrcIn
        , pjDstIn
        , DstLeft
        , DstRight
        , DeltaDstIn
        , cy
        , uF
        , uB
        , pS
        );
        DbgBreakPoint();
    }
#endif

    ASSERTGDI((uF == 0xff) || (uF == 0), "Bad Foreground Color\n");
    ASSERTGDI((uB == 0xff) || (uB == 0), "Bad Background Color\n");
    ASSERTGDI((unsigned) pjSrcIn % 4 == 0,
        "Source buffer not 32-bit aligned\n");
    ASSERTGDI((unsigned) DeltaSrcIn % 4 == 0,
        "Source scans are not 32-bit aligned\n");
    /******************************************************************
    * Select the appropriate byte table                               *
    *                                                                 *
    * I take advantage of the restricted values of the foreground and *
    * background colors to form an index into a table. This requires  *
    * that the foreground and bacground colors be either 0 or -1.     *
    ******************************************************************/
    ajIndex = apjIndex[(uB & 1) + (uF & 2)];
    /******************************************************************
    *    Each nyble  of the source maps to a byte in the              *
    *    destination. I want to separate the pixels into three        *
    *    groups: preamble, middle, and postamble. The middle          *
    *    pixels of the destination start and end on 32-bit            *
    *    boundaries. The preamble and postamble are the               *
    *    other pixels on the left and right respectively.             *
    *    The preamble ends on a 32-bit address and the postamble      *
    *    begins on a 32-bit address.                                  *
    *                                                                 *
    *    It is possible for small images (1 or 2 wide) to be          *
    *    contained completely within a DWORD of the destination such  *
    *    that the destination image does not start on, contain, or    *
    *    end on a 32-bit boundary. I treat this situation as          *
    *    special cases.                                               *
    ******************************************************************/
    pjSrcIn += SrcLeft / 2;                // 2 pixels per source byte
    pjDstIn += DstLeft;                    // one byte per dest pixel
    A       = (DstLeft + 3) & ~3;          // A = 4 * ceil(DstLeft/4)
    B       = (DstRight   ) & ~3;          // B = 4 * floor(DstRight/4)
    if (B < A)
    {
        /*****************************************************
        *    There are only three ways that you can get here *
        *                                                    *
        *    1) DstLeft & 3 == 1 && DstRight == DstLeft + 1  *
        *    2) DstLeft & 3 == 1 && DstRight == DstLeft + 2  *
        *    3) DstLeft & 3 == 2 && DstRight == DstLeft + 1  *
        *****************************************************/
        if ((DstLeft & 3) == 1)
        {
            *pjDstIn++ = ajIndex[*pjSrcIn++ & 15];
        }
        if ((DstRight & 3) == 3)
        {
            *pjDstIn = ajIndex[*pjSrcIn >> 4];
        }
    }
    else
    {
        cPreamble  = A - DstLeft;           // # pixels in preamble
        cMiddle    = (B - A)/4;
        cPostamble = DstRight - B;          // # pixels in postamble
        for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
        {
            int cLast;
            int i;

            pjSrc = pjSrcIn;
            pjDst = pjDstIn;
            switch (cPreamble)
            {
            case 3:
                jSrc = *pjSrc++;
                *pjDst++ = ajIndex[jSrc & 15];
                // fall through
            case 2:
                jSrc = *pjSrc;
                *pjDst++ = ajIndex[jSrc >> 4];
                // fall through
            case 1:
                jSrc = *pjSrc++;
                *pjDst++ = ajIndex[jSrc & 15];
                // fall through
            }
            for (i = 0 ; i < cMiddle ; i++)
            {
                jSrc  = *pjSrc++;
                *pjDst++ = ajIndex[jSrc >> 4];
                *pjDst++ = ajIndex[jSrc & 15];

                jSrc  = *pjSrc++;
                *pjDst++ = ajIndex[jSrc >> 4];
                *pjDst++ = ajIndex[jSrc & 15];
            }
            if (cLast = cPostamble)
            {
                cLast -= 1;
                jSrc = *pjSrc++;
                *pjDst++ = ajIndex[jSrc >> 4];
                if (cLast)
                {
                    cLast -= 1;
                    *pjDst++ = ajIndex[jSrc & 15];
                    if (cLast)
                    {
                        jSrc = *pjSrc;
                        *pjDst++ = ajIndex[jSrc >> 4];
                        *pjDst++ = ajIndex[jSrc & 15];
                    }
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcTranCopyS4D8                                                       *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Despite what the title implies this routine is not a `transparent'     *
*   copy of a 4bpp gray scale bitmap onto an arbitrary 8bpp surface.       *
*   What it really does is do an opaque copy of a 4bpp gray scale          *
*   bitmap onto an 8bpp surface EXCEPT for the case where the value        *
*   of the 4bpp gray scale pixel is zero. In that special case, the        *
*   destination pixel is untouched. This routine nearly identical to       *
*   the routine named `vSrcOpaqCopyS4D8' except that this routine tests    *
*   each 4bpp pixel to see if it is zero.                                  *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*                 This points to a 4-bit per pixel anti-aliased bitmap     *
*                 whose scans start and end on 32-bit boundaries.          *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*                 That is, this is the number of pixels in from the edge   *
*                 of the start of each scan line that the actual pixels    *
*                 of the image begins. All pixels before and after the     *
*                 image pixels of the scan are to be ignored. This offset  *
*                 has been put in to guarantee that 32-bit boundaries      *
*                 in the 4bpp source correspond to 32-bit boundaries       *
*                 in the destination.                                      *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - exclusive right dst pixel                                *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color (0x00 or 0xff)                          *
*    uB         - Background color (not used)                              *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcTranCopyS4D8(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    int cPreamble, cMiddle, cPostamble, A, B;
    const BYTE *ajIndex;
    BYTE jSrc, *pjSrc, *pjDst;

    static const BYTE *apjIndex[2] = {
        ajBlackOnWhite  // uF = 0       // black text
    ,   ajWhiteOnBlack  // uF = 0xFF    // white text
    };

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
         "vSrcTranCopyS4D8(\n"
         "    PBYTE   pjSrcIn    = %-#x\n"
         "    LONG    SrcLeft    = %d\n"
         "    LONG    DeltaSrcIn = %d\n"
         "    PBYTE   pjDstIn    = %-#x\n"
         "    LONG    DstLeft    = %d\n"
         "    LONG    DstRight   = %d\n"
         "    LONG    DeltaDstIn = %d\n"
         "    LONG    cy         = %d\n"
         "    ULONG   uF         = %-#x\n"
         "    ULONG   uB         = %-#x\n"
         "    SURFACE *pS        = %-#x\n"
         ");\n\n"
        , pjSrcIn
        , SrcLeft
        , DeltaSrcIn
        , pjDstIn
        , DstLeft
        , DstRight
        , DeltaDstIn
        , cy
        , uF
        , uB
        , pS
        );
        DbgBreakPoint();
    }
#endif
    ASSERTGDI((uF == 0xff) || (uF == 0), "Bad Foreground Color\n");
    ASSERTGDI((unsigned) pjSrcIn % 4 == 0,
        "Source buffer not 32-bit aligned\n");
    ASSERTGDI((unsigned) DeltaSrcIn % 4 == 0,
        "Source scans are not 32-bit aligned\n");

static const BYTE ajTranWhiteOnBlack[16] = {
    I_BLACK  , I_BLACK  , I_DKGRAY  , I_DKGRAY
  , I_DKGRAY , I_GRAY   , I_GRAY    , I_GRAY
  , I_GRAY   , I_GRAY   , I_GRAY    , I_WHITE
  , I_WHITE  , I_WHITE  , I_WHITE   , I_WHITE
};

static const BYTE ajBlackOnWhite[16] = {
    I_WHITE  , I_WHITE  , I_WHITE   , I_WHITE
  , I_GRAY   , I_GRAY   , I_GRAY    , I_GRAY
  , I_GRAY   , I_DKGRAY , I_DKGRAY  , I_DKGRAY
  , I_DKGRAY , I_DKGRAY , I_BLACK   , I_BLACK
};
    ajIndex = apjIndex[uF & 1];
    pjSrcIn += SrcLeft / 2;                // 2 pixels per source byte
    pjDstIn += DstLeft;                    // one byte per dest pixel
    A       = (DstLeft + 3) & ~3;          // A = 4 * ceil(DstLeft/4)
    B       = (DstRight   ) & ~3;          // B = 4 * floor(DstRight/4)
    if (B < A)
    {
        if ((DstLeft & 3) == 1)
        {
            jSrc = *pjSrc++;
            if (jSrc & 15)                      // is gray pixel zero?
            {
                *pjDstIn = ajIndex[jSrc & 15];  // no, modify dest
            }
            pjDstIn++;
        }
        if ((DstRight & 3) == 3)
        {
            if (jSrc = *pjSrcIn >> 4)
            {
                *pjDstIn = ajIndex[jSrc];
            }
        }
    }
    else
    {
        cPreamble  = A - DstLeft;
        cMiddle = (B - A)/4;
        cPostamble = DstRight - B;
        for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
        {
            int cLast;
            int i;

            pjSrc = pjSrcIn;
            pjDst = pjDstIn;
            switch (cPreamble)
            {
            case 3:
                jSrc = *pjSrc++;
                if (jSrc & 15)
                {
                    *pjDst = ajIndex[jSrc & 15];
                }
                pjDst++;
                // fall through
            case 2:
                jSrc = *pjSrc;
                if (jSrc >> 4)
                {
                    *pjDst = ajIndex[jSrc >> 4];
                }
                pjDst++;
                // fall through
            case 1:
                jSrc = *pjSrc++;
                if (jSrc & 15)
                {
                    *pjDst = ajIndex[jSrc & 15];
                }
                pjDst++;
                // fall through
            }
            for (i = 0; i < cMiddle ; i++)
            {
                jSrc  = *pjSrc++;
                if (jSrc >> 4)
                {
                    *pjDst = ajIndex[jSrc >> 4];
                }
                pjDst++;
                if (jSrc & 15)
                {
                    *pjDst = ajIndex[jSrc & 15];
                }
                pjDst++;

                jSrc  = *pjSrc++;
                if (jSrc >> 4)
                {
                    *pjDst = ajIndex[jSrc >> 4];
                }
                pjDst++;
                if (jSrc & 15)
                {
                    *pjDst = ajIndex[jSrc & 15];
                }
                pjDst++;
            }
            if (cLast = cPostamble)
            {
                cLast -= 1;
                jSrc = *pjSrc++;
                if (jSrc >> 4)
                {
                    *pjDst = ajIndex[jSrc >> 4];
                }
                pjDst++;
                if (cLast)
                {
                    cLast -= 1;
                    if (jSrc & 15)
                    {
                        *pjDst = ajIndex[jSrc & 15];
                    }
                    pjDst++;
                    if (cLast)
                    {
                        jSrc = *pjSrc;
                        if (jSrc >> 4)
                        {
                            *pjDst = ajIndex[jSrc >> 4];
                        }
                        pjDst++;
                        if (jSrc & 15)
                        {
                            *pjDst = ajIndex[jSrc & 15];
                        }
                        pjDst++;
                    }
                }
            }
        }
    }
}
#endif

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS4D16                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS4D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )

{
    int cPreamble, cMiddle, cPostamble, A, B;
    USHORT *aus;                  // array of 16 possible colors
    USHORT *pus;                  // convenient pointer into the color array
//
//  If filling the color table in aus
//  turns out to be time consuming we could cache the table
//  off of the FONTOBJ and check to see if the foreground and
//  background colors have not changed since the last time.
//
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcOpaqCopyS4D16(\n"
            "   pjSrcIn    = %-#x\n"
            "   SrcLeft    = %-#x\n"
            "   pjDstIn    = %-#x\n"
            "   DstLeft    = %-#x\n"
            "   DstRight   = %-#x\n"
            "   DeltaDstIn = %-#x\n"
            "   cy         = %-#x\n"
            "   uF         = %-#x\n"
            "   uB         = %-#x\n"
            "   pS         = %-#x\n"
            ,   pjSrcIn
            ,   SrcLeft
            ,   pjDstIn
            ,   DstLeft
            ,   DstRight
            ,   DeltaDstIn
            ,   cy
            ,   uF
            ,   uB
            ,   pS
        );
        DbgBreakPoint();
    }
#endif

    aus = (USHORT*) pvFillOpaqTable(sizeof(*aus), uF, uB, pS);
    A          = (DstLeft + 1) & ~1;
    B          = (DstRight   ) & ~1;
    pjSrcIn   += SrcLeft/2;
    pjDstIn   += DstLeft * sizeof(USHORT);
    cPreamble  = A - DstLeft;
    cMiddle    = (B - A) / 2;
    cPostamble = DstRight - B;
    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        int i;
        BYTE jSrc;
        BYTE *pjSrc = pjSrcIn;
        USHORT *pusDst = (USHORT*) pjDstIn;

        if (cPreamble)
        {
            jSrc = *pjSrc++;
            *pusDst++ = aus[jSrc & 15];
        }
        for (i = 0; i < cMiddle; i++)
        {
            jSrc  = *pjSrc++;
            *pusDst++ = aus[jSrc >> 4];
            *pusDst++ = aus[jSrc & 15];
        }
        if (cPostamble)
        {
            jSrc = *pjSrc;
            *pusDst = aus[jSrc >> 4];
        }
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcTranCopyS4D16                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to the FINAL destination SURFACE                 *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/
VOID
vSrcTranCopyS4D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    ULONG flRed, cRedRight, uRedF, flRedRight;
    ULONG flGre, cGreRight, uGreF, flGreRight;
    ULONG flBlu, cBluRight, uBluF, flBluRight;
    ULONG uT, dT, u;
    CONST ULONG *aul;
    int cPreamble, cMiddle, cPostamble, A, B;
    BYTE j;
    XEPALOBJ xpo;

    if(pS->pPal == NULL)
    {
        PDEVOBJ pdo(pS->hdev());
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }
    
    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );

    if (xpo.bIsBitfields())
    {
        flRed      = xpo.flRed();               // masks red bits
        cRedRight  = xpo.cRedRight();

        flGre      = xpo.flGre();               // masks green bits
        cGreRight  = xpo.cGreRight();

        flBlu      = xpo.flBlu();               // masks blu bits
        cBluRight  = xpo.cBluRight();
    }
    else if (xpo.bIsRGB())
    {
        WARNING("16 bit-RGB -- assuming 5+5+5\n");
        flRed     = 0x001f;
        cRedRight = 0;
        flGre     = 0x03e0;
        cGreRight = 5;
        flBlu     = 0x7c00;
        cBluRight = 10;
    }
    else if (xpo.bIsBGR())
    {
        WARNING("16 bit-BGR -- assuming 5+5+5\n");
        flRed     = 0x7c00;
        cRedRight = 10;
        flGre     = 0x03e0;
        cGreRight = 5;
        flBlu     = 0x001f;
        cBluRight = 0;
    }
    else
    {
        RIP("unsuported palette format\n");
    }
    uRedF      = (uF & flRed) >> cRedRight;
    flRedRight = flRed >> cRedRight;

    uGreF      = (uF & flGre) >> cGreRight;
    flGreRight = flGre >> cGreRight;

    uBluF      = (uF & flBlu) >> cBluRight;
    flBluRight = flBlu >> cBluRight;

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcTranCopyS4D16(\n"
            "   pjSrcIn    = %-#x\n"
            "   SrcLeft    = %d\n"
            "   DeltaSrcIn = %d\n"
            "   pjDstIn    = %-#x\n"
            "   DstLeft    = %d\n"
            "   DstRight   = %d\n"
            "   DeltaDstIn = %d\n"
            "   cy         = %d\n"
            "   uF         = %-#x\n"
            "   uB         = %-#x\n"
            "   pS         = %-#x\n"
           ,    pjSrcIn
           ,    SrcLeft
           ,    DeltaSrcIn
           ,    pjDstIn
           ,    DstLeft
           ,    DstRight
           ,    DeltaDstIn
           ,    cy
           ,    uF
           ,    uB
           ,    pS
        );
        DbgPrint(
            "   flRed      = %-#x\n"
            "   cRedRight  = %d\n"
            "   uRedF      = %-#x\n"
            "   flRedRight = %-#x\n"
            , flRed, cRedRight, uRedF, flRedRight
        );
        DbgPrint(
            "   flGre      = %-#x\n"
            "   cGreRight  = %d\n"
            "   uGreF      = %-#x\n"
            "   flGreRight = %-#x\n"
            , flGre, cGreRight, uGreF, flGreRight
        );
        DbgPrint(
            "   flBlu      = %-#x\n"
            "   cBluRight  = %d\n"
            "   uBluF      = %-#x\n"
            "   flBluRight = %-#x\n"
            , flBlu, cBluRight, uBluF, flBluRight
        );
            DbgBreakPoint();
    }
#endif

/*****************************************************************************
*                                                                            *
*    The CCC macro blends forground and background colors of a single color  *
*    channel. Gamma correction is taken into account using an approximate    *
*    correction scheme. uB contains all three background colors. We first    *
*    mask off the bits of interest and then shift them down until the        *
*    least significant color bit resides at the lowest bit of the dword.     *
*    The answer is placed in uT ("temporary ULONG"). This must be done for   *
*    each pixel in the destination. The same thing has been done for the     *
*    each of the forground color channels and placed in uRedF, uGreF,        *
*    and uBluF. These values do not change from pixel to pixel and so the    *
*    calculation of these down shifted forground color channel values is     *
*    done up front before the loop. Then for each color channel we           *
*    calculate the difference between the down-shifted forground- and        *
*    background color channels and place the answer in dT ("temporary        *
*    difference"). The approximate gamma correction is done in the           *
*    following manner: If the background color value is smaller than         *
*    the foreground color value then the approximate correction is:          *
*                                                                            *
*        (c_f >= c_b):                                                       *
*                                                                            *
*              c = c_b + alpha_k ^ (1/gamma) * (c_f - c_b)                   *
*                                                                            *
*        (c_f <= c_b):                                                       *
*                                                                            *
*              c = c_b + (1 - (1 - alpha_k)^(1/gamma)) * (c_f - c_b)         *
*                                                                            *
*    where                                                                   *
*                                                                            *
*            c   := blended color                                            *
*            c_b := background color                                         *
*            c_f := foreground color                                         *
*            alpha_k := k'th blending fraction = k == 0 ? 0 : (k+1)/16;      *
*            gamma := 2.33                                                   *
*                                                                            *
*    I have storred all sixteen values of alpha_k ^ (1/gamma) in 16.16       *
*    representation in an array ULONG aulB[16] and I have storred the        *
*    values of 1 - (1 - alpha_k)^(1/gamma) in aulIB[k]                       *
*                                                                            *
*    Thus the blended color value is                                         *
*                                                                            *
*        (c_f >= c_b):                                                       *
*                                                                            *
*            c = (2^16 * c_b + aulB[k] * (c_f - c_b)) / 2^16                 *
*                                                                            *
*                                                                            *
*        (c_f <= c_b):                                                       *
*                                                                            *
*            c = (2^16 * c_b + aulB[15-k] * (c_f - c_b)) / 2^16              *
*    Instead of accessing aulB[15-k], I access aulIB which has               *
*    aulIB[k] = aulB[15-k]                                                   *
*    In the macro below, I actually blend the down-shifted color             *
*    channel values and then shift the answer up and mask it (the            *
*    mask shouldn't be necessary, but this is a precaution).                 *
*                                                                            *
*****************************************************************************/

#define CCC(Color,jj)                                                 \
    uT = (uB & fl##Color) >> c##Color##Right;                         \
    dT = u##Color##F - uT;                                            \
    aul = ((LONG) dT < 0) ? aulIB : aulB;                             \
    u |= (((dT * aul[jj] + (uT << 16)) >> 16) << c##Color##Right) & fl##Color

/******************************************************************************
*                                                                             *
*    The SETCOLOR macro looks at the blending value. If it is zero then       *
*    the destination pixel does not change and we do nothing. If the blending *
*    value is 15 then the destination pixel should take the forground color   *
*    , no blending is necessary. If the blending value is one of 1..14 then   *
*    all three color channels are blended and added together.                 *
*                                                                             *
******************************************************************************/

                #define SETCOLOR(jj)           \
                if (j = (jj))                  \
                {                              \
                    if (j == 15)               \
                    {                          \
                        u = uF;                \
                    }                          \
                    else                       \
                    {                          \
                        u = 0;                 \
                        uB = (ULONG) *pusDst;  \
                        CCC(Red,j);            \
                        CCC(Gre,j);            \
                        CCC(Blu,j);            \
                    }                          \
                    *pusDst = (USHORT) u;      \
                }                              \
                pusDst++

/*********************************************************************
*                                                                    *
*    Each pixel takes 16-bits, half of a DWORD. I will separate      *
*    each scan into three sections: the "preamble", the              *
*    "middle", and the "postamble". The preamble are the set of      *
*    pixels that occur before the first 32-bit boundary in the       *
*    destination. Either a pixel starts on a DWORD or it doesn't.    *
*    Therefore there can be at most one pixel in the preamble.       *
*    The middle section starts and ends on a 32-bit boundary.        *
*    The postamble starts on a 32-bit boundary but ends on an        *
*    address that is not 32-bit aligned. There can be at most        *
*    one pixel in the postamble.                                     *
*                                                                    *
*        A = x-coord of pixel starting on the lowest                 *
*            32-bit aligned address in the scan                      *
*                                                                    *
*          = 2 (pixels/dword)                                        *
*              * ceiling (16 (bits/pixel) * left / 32 (bits/dword))  *
*                                                                    *
*          = 2 * ceiling( left / 2 )                                 *
*                                                                    *
*          = 2 * floor((left + 1) / 2)                               *
*                                                                    *
*          = (left + 1) & ~1;                                        *
*                                                                    *
*                                                                    *
*        B =  x-coord of pixel starting at the highest               *
*             32-bit aligned address in the scan                     *
*                                                                    *
*          = 2 * floor( right / 2)                                   *
*                                                                    *
*          = right & ~1                                              *
*                                                                    *
*                                                                    *
*        cPreamble  = # pixels in preamble                           *
*        cPostamble = # pixels in postamble                          *
*                                                                    *
*    Each nyble  of the gray 4-bpp source bitmap corresponds to a    *
*    pixel in the destination. The pixels of the scan do not         *
*    start on the left edge of the gray 4-bpp bitmap, they are       *
*    indented by SrcLeft pixels. The reason is that the gray         *
*    bitmap was aligned so that the initial starting address         *
*    of the gray bitmap started at a position corresponding to       *
*    a 32-bit aligned address in the destination. Thus there         *
*    is a relationship between cPreamble and SrcLeft. In any         *
*    case we have to move the pointer to the first source pixel      *
*    of interest inward away from the left edge of the gray          *
*    source bitmap. Since we move pointers in BYTE increments        *
*    we must convert the number of pixels (SrcLeft), each            *
*    of which corresponds to an nyble  to a count of bytes. The      *
*    conversion is easy                                              *
*                                                                    *
*        source shift in bytes = floor(SrcLeft/2)                    *
*                                                                    *
*    Similarly, the pointer to the destination must be indented      *
*    by the offset of the x-coordinate of the destination            *
*    rectangle and thus pjDstIn is shifted                           *
*                                                                    *
*********************************************************************/

    A          = (DstLeft + 1) & ~1;
    B          = (DstRight   ) & ~1;
    cPreamble  = A - DstLeft;
    cMiddle    = (B - A)/2;
    cPostamble = DstRight - B;
    pjSrcIn   += SrcLeft / 2;
    pjDstIn   += DstLeft * sizeof(USHORT);
    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        int i;
        BYTE jSrc;
        BYTE *pjSrc = pjSrcIn;
        USHORT *pusDst = (USHORT*) pjDstIn;

        if (cPreamble)
        {
            jSrc = *pjSrc;
            SETCOLOR(jSrc & 15);
            pjSrc++;
        }
        for (i = 0; i < cMiddle; i++)
        {
            jSrc  = *pjSrc;
            SETCOLOR(jSrc >> 4);
            SETCOLOR(jSrc & 15);
            pjSrc++;
        }
        if (cPostamble)
        {
            SETCOLOR(*pjSrc >> 4);
        }
    }
#undef SETCOLOR
#undef CCC
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS4D24                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS4D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    int A;                  // position of first 32-bit aligned pixel
    int B;                  // position of last 32-bit aligned pixel
    int cPreamble;          // The preamble is the set of pixeles
                            // that you need to go through to get
    // nearest 32-bit boundary in the destination

    int cMiddle;            // This is the number of interations
                            // that are done in the middle section
    // in which we are guaranteed 32-bit alignment. Each time through
    // the loop, we use 2 source bytes which corresponds to 4 pixels.
    // In this case of 24-bits per destination pixel, this means that
    // each itteration of the loop affects 3 DWORD's of the destination.
    // This means that cMiddle = (#destination DWORD's)/3 in the
    // middle (32-bit aligned) section.

    int cPostamble;         // The postamble is the set of pixels
                            // that remain after the last 32-bit
    // boundary in the destination. Thus number is can be 0, 1, or 2.

    ULONG  *aul;            // a cache of the 16 possible 24-bit
                            // colors that can be seen on the
                            // destination surface.
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcOpaqCopyS4D24(\n"
            "   PBYTE   pjSrcIn     = %-#x\n"
            "   LONG    SrcLeft     = %d\n"
            "   LONG    DeltaSrcIn  = %d\n"
            "   PBYTE   pjDstIn     = %-#x\n"
            "   LONG    DstLeft     = %d\n"
            "   LONG    DstRight    = %d\n"
            "   LONG    DeltaDstIn  = %d\n"
            "   LONG    cy          = %d\n"
            "   ULONG   uF          = %-#x\n"
            "   ULONG   uB          = %-#x\n"
            "   SURFACE *pS         = %-#x\n"
            ,   pjSrcIn
            ,   SrcLeft
            ,   DeltaSrcIn
            ,   pjDstIn
            ,   DstLeft
            ,   DstRight
            ,   DeltaDstIn
            ,   cy
            ,   uF
            ,   uB
            ,   pS
        );
         DbgBreakPoint();
    }
#endif

    aul = (ULONG*) pvFillOpaqTable(sizeof(*aul), uF, uB, pS);
    pjSrcIn   += SrcLeft / 2;         // 2 pixels per src byte
    pjDstIn   += DstLeft * 3;         // 3 bytes per dest pixel
    A          = (DstLeft + 3) & ~3;  // round up to nearest multiple of 4
    B          = (DstRight   ) & ~3;  // round down to nearest multiple of 4

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "\n"
            "   pjSrcIn     = %-#x\n"
            "   pjDstIn     = %-#x\n"
            "   A           = %d\n"
            "   B           = %d\n"
        ,   pjSrcIn
        ,   pjDstIn
        ,   A
        ,   B
        );
        DbgBreakPoint();
    }
#endif

    if (A <= B)
    {
        cPreamble  = A - DstLeft;       // # pixels in preamble
        cMiddle    = (B - A) / 4;       // each loop does 4 pixels
        cPostamble = DstRight - B;      // # pixels in postample

#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "   cPreamble   = %d\n"
                "   cMiddle     = %d\n"
                "   cPostamble  = %d\n"
                , cPreamble, cMiddle, cPostamble
            );
            DbgBreakPoint();
        }
#endif

        for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
        {
            int i;
            BYTE  *ajSrc; // points directly into the gamma correction table
            ULONG *pul;
            BYTE  *pjSrc = pjSrcIn;
            BYTE  *pjDst = pjDstIn;

            switch (cPreamble)
            {
            case 3:
                ajSrc = (BYTE*) & (aul[*pjSrc & 15]);
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
                pjSrc++;
                // fall through
            case 2:
                ajSrc = (BYTE*) & (aul[*pjSrc >> 4]);
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
                // fall through
            case 1:
                ajSrc = (BYTE*) & (aul[*pjSrc & 15]);
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
                pjSrc++;
            case 0:
                ;
            }
            for (pul = (ULONG*) pjDst, i = 0; i < cMiddle; i++)
            {
                /*****************************************************
                *    Each time through the loop four pixels are      *
                *    processed (3 DWORD's in the destination, 2      *
                *    bytes in the source glyph.)                     *
                *****************************************************/
                ULONG c0, c1, c2, c3;
                BYTE j0,j1;
                ASSERTGDI(!((ULONG_PTR) pjDst & 3),"bad alignment\n");
                j0 = *pjSrc++;
                j1 = *pjSrc++;
                c0 = aul[j0 >> 4];
                c1 = aul[j0 & 15];
                c2 = aul[j1 >> 4];
                c3 = aul[j1 & 15];
                *pul++ = (c0      ) + (c1 << 24);
                *pul++ = (c1 >>  8) + (c2 << 16);
                *pul++ = (c2 >> 16) + (c3 <<  8);
            }
            pjDst = (BYTE*) pul;
            if (i = cPostamble)
            {
                /*****************************************************
                *   I do the postamble a byte at a time so that I    *
                *   don't overwrite pixels beyond the scan. If I     *
                *   wrote a DWORD at a time, then I would have to    *
                *   do some tricky masking.                          *
                *****************************************************/
                i--;
                ajSrc = (BYTE*) & (aul[*pjSrc >> 4]);
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
                if (i)
                {
                    i--;
                    ajSrc = (BYTE*) & (aul[*pjSrc & 15]);
                    *pjDst++ = *ajSrc++;
                    *pjDst++ = *ajSrc++;
                    *pjDst++ = *ajSrc;
                    pjSrc++;
                    if (i) {
                        ajSrc = (BYTE*) & (aul[*pjSrc >> 4]);
                        *pjDst++ = *ajSrc++;
                        *pjDst++ = *ajSrc++;
                        *pjDst++ = *ajSrc;
                    }
                }
            }
        }
    }
    else
    {
        /***************************************************************
        *    If the text bitmap is narrow (3 wide or less) then        *
        *    it is possible to have B < A. There are three such cases: *
        *                                                              *
        *     1) DstLeft & 3 == 2 AND DstLeft + 1 == DstRight          *
        *     1) DstLeft & 3 == 1 AND DstLeft + 1 == DstRight          *
        *     2) DstLeft & 3 == 1 AND DstLeft + 2 == DstRight          *
        *                                                              *
        *    I shall treat each of these as a special case             *
        ***************************************************************/
        ASSERTGDI(B < A, "A <= B");
        BYTE *ajSrc; // points directly into the gamma correction table
        BYTE *pjDst = pjDstIn;
        BYTE *pjSrc = pjSrcIn;

#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "   SPECIAL CASE: A < B\n"
                "       DstLeft & 3 = %d\n"
                , DstLeft & 3
            );
            DbgBreakPoint();
        }
#endif

        switch (DstLeft & 3)
        {
        case 0:

            RIP("DstLeft & 3 == 0");
            break;

        case 1:

            /********************************************************
            *                                                       *
            *      H   H   H   L   L   L   H   H   H   L   L   L    *
            *    +---------------+---------------+---------------+  *
            *    | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |  *
            *    +---------------+---------------+---------------+  *
            *                  X   X   X                            *
            *                  ^                                    *
            *                  |                                    *
            *                  pjDst                                *
            *                                                       *
            ********************************************************/
            // copy three bytes from the opaque color table
            ajSrc = (BYTE*) & (aul[*pjSrc & 15]);
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc;
            if (DstLeft + 1 == DstRight)
                break;
            pjSrc++;                        // done with this source byte
            // fall through
        case 2:

            /*********************************************************
            *                                                        *
            *      H   H   H   L   L   L   H   H   H   L   L   L     *
            *    +---------------+---------------+---------------+   *
            *    | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |   *
            *    +---------------+---------------+---------------+   *
            *                              X   X   X                 *
            *                              ^                         *
            *                              |                         *
            *                              pjDst                     *
            *                                                        *
            *********************************************************/
            // copy three bytes from the opaque color table
            ajSrc = (BYTE*) & (aul[*pjSrc >> 4]);
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc++;
            *pjDst   = *ajSrc;
            break;
        }
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcTranCopyS4D24                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcTranCopyS4D24(
    PBYTE    pjSrcIn,
    LONG     SrcLeft,
    LONG     DeltaSrcIn,
    PBYTE    pjDstIn,
    LONG     DstLeft,
    LONG     DstRight,
    LONG     DeltaDstIn,
    LONG     cy,
    ULONG    uF,
    ULONG    uB,
    SURFACE *pS
    )
{
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcTranCopyS4D24(\n"
            "   PBYTE    pjSrcIn     = %-#x\n"
            "   LONG     SrcLeft     = %d\n"
            "   LONG     DeltaSrcIn  = %d\n"
            "   PBYTE    pjDstIn     = %-#x\n"
            "   LONG     DstLeft     = %d\n"
            "   LONG     DstRight    = %d\n"
            "   LONG     DeltaDstIn  = %d\n"
            "   LONG     cy          = %d\n"
            "   ULONG    uF          = %-#x\n"
            "   ULONG    uB          = %-#x\n"
            "   SURFACE *pS          = %-#x\n"
            "   )\n"
            ,   pjSrcIn
            ,   SrcLeft
            ,   DeltaSrcIn
            ,   pjDstIn
            ,   DstLeft
            ,   DstRight
            ,   DeltaDstIn
            ,   cy
            ,   uF
            ,   uB
            ,   pS
        );
        DbgBreakPoint();
    }
#endif
    ULONG flRed, cRedRight, uRedF, flRedRight;
    ULONG flGre, cGreRight, uGreF, flGreRight;
    ULONG flBlu, cBluRight, uBluF, flBluRight;
    ULONG uT, dT, u;
    CONST ULONG *aul;
    int cPreamble, cMiddle, cPostamble, A, B;
    BYTE j;
    XEPALOBJ xpo;

    if(pS->pPal == NULL)
    {
        PDEVOBJ pdo(pS->hdev());
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }

    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );

    if (xpo.bIsBitfields())
    {
        flRed      = xpo.flRed();               // masks red bits
        cRedRight  = xpo.cRedRight();

        flGre      = xpo.flGre();               // masks green bits
        cGreRight  = xpo.cGreRight();

        flBlu      = xpo.flBlu();               // masks blu bits
        cBluRight  = xpo.cBluRight();
    }
    else if (xpo.bIsRGB())
    {
        // assuming 8+8+8
        flRed     = 0x0000ff;
        cRedRight = 0;
        flGre     = 0x00ff00;
        cGreRight = 8;
        flBlu     = 0xff0000;
        cBluRight = 16;
    }
    else if (xpo.bIsBGR())
    {
        // assuming 8+8+8
        flRed     = 0xff0000;
        cRedRight = 16;
        flGre     = 0x00ff00;
        cGreRight = 8;
        flBlu     = 0x0000ff;
        cBluRight = 0;
    }
    else
    {
        RIP("unsuported palette format\n");
    }
    uRedF      = (uF & flRed) >> cRedRight;
    flRedRight = flRed >> cRedRight;

    uGreF      = (uF & flGre) >> cGreRight;
    flGreRight = flGre >> cGreRight;

    uBluF      = (uF & flBlu) >> cBluRight;
    flBluRight = flBlu >> cBluRight;
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "   flRed      = %-#x\n"
            "   cRedRight  = %d\n"
            "   uRedF      = %-#x\n"
            "   flRedRight = %-#x\n"
            , flRed, cRedRight, uRedF, flRedRight
        );
        DbgPrint(
            "   flGre      = %-#x\n"
            "   cGreRight  = %d\n"
            "   uGreF      = %-#x\n"
            "   flGreRight = %-#x\n"
            , flGre, cGreRight, uGreF, flGreRight
        );
        DbgPrint(
            "   flBlu      = %-#x\n"
            "   cBluRight  = %d\n"
            "   uBluF      = %-#x\n"
            "   flBluRight = %-#x\n"
            , flBlu, cBluRight, uBluF, flBluRight
        );
        DbgBreakPoint();
    }
#endif

/******************************************************************************
*                                                                             *
*    See the discussion of the CCC macro in vSrcTranCopyS4D16()               *
*                                                                             *
*                                                                             *
                                                                             */
#define CCC(Color,jj)                                                 \
    uT = (uB & fl##Color) >> c##Color##Right;                         \
    dT = u##Color##F - uT;                                            \
    aul = ((LONG) dT < 0) ? aulIB : aulB;                             \
    u |= (((dT * aul[jj] + (uT << 16)) >> 16)                         \
                                << c##Color##Right) & fl##Color
/*                                                                            *
*                                                                             *
*                                                                             *
/******************************************************************************/


/******************************************************************************
*                                                                             *
*    The SETCOLOR macro looks at the blending value. If it is zero then       *
*    the destination pixel does not change and we do nothing. If the blending *
*    value is 15 then the destination pixel should take the forground color   *
*    , no blending is necessary. If the blending value is one of 1..14 then   *
*    all three color channels are blended and added together.                 *
*                                                                             *
*                                                                             */

                    #define SETCOLOR(jj)                          \
                        if (j = (jj))                             \
                        {                                         \
                            if (j == 15)                          \
                            {                                     \
                                u = uF;                           \
                            }                                     \
                            else                                  \
                            {                                     \
                                u = 0;                            \
                                *(((BYTE*) & uB)+0) = *(pjDst+0); \
                                *(((BYTE*) & uB)+1) = *(pjDst+1); \
                                *(((BYTE*) & uB)+2) = *(pjDst+2); \
                                CCC(Red,j);                       \
                                CCC(Gre,j);                       \
                                CCC(Blu,j);                       \
                            }                                     \
                            *(pjDst+0) = *(((BYTE*) & u)+0);      \
                            *(pjDst+1) = *(((BYTE*) & u)+1);      \
                            *(pjDst+2) = *(((BYTE*) & u)+2);      \
                        }                                         \
                        pjDst += 3
/*                                                                            *
*                                                                             *
*                                                                             *
/******************************************************************************/

    A          = (DstLeft + 3) & ~3;
    B          = (DstRight   ) & ~3;
    pjSrcIn   += SrcLeft / 2;           // 4-bits  per source pixel
    pjDstIn   += DstLeft * 3;           // 24-bits per destination pixel
    if (A <= B)
    {
        cPreamble  = A - DstLeft;
        cMiddle    = (B - A) / 4;
        cPostamble = DstRight - B;
        for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
        {
            int i;
            BYTE *pjSrc = pjSrcIn;
            BYTE *pjDst = pjDstIn;

            switch (cPreamble)
            {
            case 3:
                SETCOLOR(*pjSrc & 15);
                pjSrc++;
            case 2:
                SETCOLOR(*pjSrc >> 4);
            case 1:
                SETCOLOR(*pjSrc & 15);
                pjSrc++;
            case 0:
                ;
            }
            ASSERTGDI(!((ULONG_PTR) pjDst & 3),"bad alignment\n");
            for (i = 0; i < cMiddle; i++)
            {
                SETCOLOR(*pjSrc >> 4);
                SETCOLOR(*pjSrc & 15);
                pjSrc++;
                SETCOLOR(*pjSrc >> 4);
                SETCOLOR(*pjSrc & 15);
                pjSrc++;
            }
            if (i = cPostamble)
            {
                SETCOLOR(*pjSrc >> 4);
                i--;
                if (i)
                {
                    SETCOLOR(*pjSrc & 15);
                    i--;
                    if (i)
                    {
                        pjSrc++;
                        SETCOLOR(*pjSrc >> 4);
                    }
                }
            }
        }
    }
    else
    {
        /***************************************************************
        *    If the text bitmap is narrow (3 wide or less) then        *
        *    it is possible to have B < A. There are three such cases: *
        *                                                              *
        *     1) DstLeft & 3 == 2 AND DstLeft + 1 == DstRight          *
        *     1) DstLeft & 3 == 1 AND DstLeft + 1 == DstRight          *
        *     2) DstLeft & 3 == 1 AND DstLeft + 2 == DstRight          *
        *                                                              *
        *    I shall treat each of these as a special case             *
        ***************************************************************/
        ASSERTGDI(B < A, "A <= B");
        BYTE *ajSrc; // points directly into the gamma correction table
        BYTE *pjDst = pjDstIn;
        BYTE *pjSrc = pjSrcIn;

#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
                "   SPECIAL CASE: A < B\n"
                "       DstLeft & 3 = %d\n"
                , DstLeft & 3
            );
            DbgBreakPoint();
        }
#endif

        switch (DstLeft & 3)
        {
        case 0:

            RIP("DstLeft & 3 == 0");
            break;

        case 1:

            /********************************************************
            *                                                       *
            *      H   H   H   L   L   L   H   H   H   L   L   L    *
            *    +---------------+---------------+---------------+  *
            *    | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |  *
            *    +---------------+---------------+---------------+  *
            *                  X   X   X                            *
            *                  ^                                    *
            *                  |                                    *
            *                  pjDst                                *
            *                                                       *
            ********************************************************/
            SETCOLOR(*pjSrc & 15);
            if (DstLeft + 1 == DstRight)
                break;
            pjSrc++;                        // done with this byte
                                            // fall through
        case 2:

            /*********************************************************
            *                                                        *
            *      H   H   H   L   L   L   H   H   H   L   L   L     *
            *    +---------------+---------------+---------------+   *
            *    | 0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |   *
            *    +---------------+---------------+---------------+   *
            *                              X   X   X                 *
            *                              ^                         *
            *                              |                         *
            *                              pjDst                     *
            *                                                        *
            *********************************************************/
            SETCOLOR(*pjSrc >> 4);
            break;
        }
    }
#undef SETCOLOR
#undef CCC
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS4D32                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS4D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )

{
    int A, B, cPreamble, cMiddle, cPostamble;
    ULONG  *aul;                            // array of 16 possible colors
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcOpaqCopyS4D32(\n"
            "   pjSrcIn    = %-#x\n"
            "   SrcLeft    = %-#x\n"
            "   pjDstIn    = %-#x\n"
            "   DstLeft    = %-#x\n"
            "   DstRight   = %-#x\n"
            "   DeltaDstIn = %-#x\n"
            "   cy         = %-#x\n"
            "   uF         = %-#x\n"
            "   uB         = %-#x\n"
            "   pS         = %-#x\n"
           ,    pjSrcIn
           ,    SrcLeft
           ,    DeltaSrcIn
           ,    pjDstIn
           ,    DstLeft
           ,    DstRight
           ,    DeltaDstIn
           ,    cy
           ,    uF
           ,    uB
           ,    pS
        );
        DbgBreakPoint();
    }
#endif
    aul = (ULONG*) pvFillOpaqTable(sizeof(*aul), uF, uB, pS);
    A          = (DstLeft + 1) & ~1;
    B          = (DstRight   ) & ~1;
    cPreamble  = A - DstLeft;        // # pixels in preamble
    cMiddle    = (B - A)/2;
    cPostamble = DstRight - B;       // # pixels in postamble
    pjSrcIn   += SrcLeft / 2;
    pjDstIn   += DstLeft * sizeof(ULONG);
    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        int i;
        BYTE *pjSrc = pjSrcIn;
        ULONG *pul  = (ULONG*) pjDstIn;

        if (cPreamble)
        {
            *pul++ = aul[*pjSrc++ & 15];
        }
        for (i = 0; i < cMiddle; i++)
        {
            BYTE j = *pjSrc++;
            *pul++ = aul[j >> 4];
            *pul++ = aul[j & 15];
        }
        if (cPostamble)
        {
            *pul = aul[*pjSrc >> 4];
        }
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcTranCopyS4D32                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcTranCopyS4D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{

    ULONG flRed, cRedRight, uRedF, flRedRight;
    ULONG flGre, cGreRight, uGreF, flGreRight;
    ULONG flBlu, cBluRight, uBluF, flBluRight;
    ULONG uT, dT, u;
    CONST ULONG *aul;
    int cPreamble, cMiddle, cPostamble, A, B;
    BYTE j;
    XEPALOBJ xpo;

    if(pS->pPal == NULL)
    {
        PDEVOBJ pdo(pS->hdev());
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }
    
    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );

    if (xpo.bIsBitfields())
    {
        flRed      = xpo.flRed();               // masks red bits
        cRedRight  = xpo.cRedRight();

        flGre      = xpo.flGre();               // masks green bits
        cGreRight  = xpo.cGreRight();

        flBlu      = xpo.flBlu();               // masks blu bits
        cBluRight  = xpo.cBluRight();
    }
    else if (xpo.bIsRGB())
    {
        // assuming 8+8+8
        flRed     = 0x0000ff;
        cRedRight = 0;
        flGre     = 0x00ff00;
        cGreRight = 8;
        flBlu     = 0xff0000;
        cBluRight = 16;
    }
    else if (xpo.bIsBGR())
    {
        // assuming 8+8+8
        flRed     = 0xff0000;
        cRedRight = 16;
        flGre     = 0x00ff00;
        cGreRight = 8;
        flBlu     = 0x0000ff;
        cBluRight = 0;
    }
    else
    {
        RIP("unsuported palette format\n");
    }
    uRedF      = (uF & flRed) >> cRedRight;
    flRedRight = flRed >> cRedRight;

    uGreF      = (uF & flGre) >> cGreRight;
    flGreRight = flGre >> cGreRight;

    uBluF      = (uF & flBlu) >> cBluRight;
    flBluRight = flBlu >> cBluRight;

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "vSrcTranCopyS4D32(\n"
            "   PBYTE   pjSrcIn     = %-#x\n"
            "   LONG    SrcLeft     = %d\n"
            "   LONG    DeltaSrcIn  = %d\n"
            "   PBYTE   pjDstIn     = %-#x\n"
            "   LONG    DstLeft     = %d\n"
            "   LONG    DstRight    = %d\n"
            "   LONG    DeltaDstIn  = %d\n"
            "   LONG    cy          = %d\n"
            "   ULONG   uF          = %-#x\n"
            "   ULONG   uB          = %-#x\n"
            "   SURFACE *pS         = %-#x\n"
        ,   pjSrcIn
        ,   SrcLeft
        ,   DeltaSrcIn
        ,   pjDstIn
        ,   DstLeft
        ,   DstRight
        ,   DeltaDstIn
        ,   cy
        ,   uF
        ,   uB
        ,   pS
        );
        DbgPrint(
            "   flRed      = %-#x\n"
            "   cRedRight  = %d\n"
            "   uRedF      = %-#x\n"
            "   flRedRight = %-#x\n"
            , flRed, cRedRight, uRedF, flRedRight
        );
        DbgPrint(
            "   flGre      = %-#x\n"
            "   cGreRight  = %d\n"
            "   uGreF      = %-#x\n"
            "   flGreRight = %-#x\n"
            , flGre, cGreRight, uGreF, flGreRight
        );
        DbgPrint(
            "   flBlu      = %-#x\n"
            "   cBluRight  = %d\n"
            "   uBluF      = %-#x\n"
            "   flBluRight = %-#x\n"
            , flBlu, cBluRight, uBluF, flBluRight
        );
        DbgBreakPoint();
    }
#endif

/*****************************************************************************
*                                                                            *
*    The CCC macro blends forground and background colors of a single color  *
*    channel. Gamma correction is taken into account using an approximate    *
*    correction scheme. uB contains all three background colors. We first    *
*    mask off the bits of interest and then shift them down until the        *
*    least significant color bit resides at the lowest bit of the dword.     *
*    The answer is placed in uT ("temporary ULONG"). This must be done for   *
*    each pixel in the destination. The same thing has been done for the     *
*    each of the forground color channels and placed in uRedF, uGreF,        *
*    and uBluF. These values do not change from pixel to pixel and so the    *
*    calculation of these down shifted forground color channel values is     *
*    done up front before the loop. Then for each color channel we           *
*    calculate the difference between the down-shifted forground- and        *
*    background color channels and place the answer in dT ("temporary        *
*    difference"). The approximate gamma correction is done in the           *
*    following manner: If the background color value is smaller than         *
*    the foreground color value then the approximate correction is:          *
*                                                                            *
*        (c_f >= c_b):                                                       *
*                                                                            *
*              c = c_b + alpha_k ^ (1/gamma) * (c_f - c_b)                   *
*                                                                            *
*        (c_f <= c_b):                                                       *
*                                                                            *
*              c = c_b + (1 - (1 - alpha_k)^(1/gamma)) * (c_f - c_b)         *
*                                                                            *
*    where                                                                   *
*                                                                            *
*            c   := blended color                                            *
*            c_b := background color                                         *
*            c_f := foreground color                                         *
*            alpha_k := k'th blending fraction = k == 0 ? 0 : (k+1)/16;      *
*            gamma := 2.33                                                   *
*                                                                            *
*    I have storred all sixteen values of alpha_k ^ (1/gamma) in 16.16       *
*    representation in an array ULONG aulB[16] and I have storred the        *
*    values of 1 - (1 - alpha_k)^(1/gamma) in aulIB[k]                       *
*                                                                            *
*    Thus the blended color value is                                         *
*                                                                            *
*        (c_f >= c_b):                                                       *
*                                                                            *
*            c = (2^16 * c_b + aulB[k] * (c_f - c_b)) / 2^16                 *
*                                                                            *
*                                                                            *
*        (c_f <= c_b):                                                       *
*                                                                            *
*            c = (2^16 * c_b + aulB[15-k] * (c_f - c_b)) / 2^16              *
*    Instead of accessing aulB[15-k], I access aulIB which has               *
*    aulIB[k] = aulB[15-k]                                                   *
*    In the macro below, I actually blend the down-shifted color             *
*    channel values and then shift the answer up and mask it (the            *
*    mask shouldn't be necessary, but this is a precaution).                 *
*                                                                            *
*****************************************************************************/
#define CCC(Color,jj)                                                 \
    uT = (uB & fl##Color) >> c##Color##Right;                         \
    dT = u##Color##F - uT;                                            \
    aul = ((LONG) dT < 0) ? aulIB : aulB;                             \
    u |= (((dT * aul[jj] + (uT << 16)) >> 16) << c##Color##Right) & fl##Color

/******************************************************************************
*                                                                             *
*    The SETCOLOR macro looks at the blending value. If it is zero then       *
*    the destination pixel does not change and we do nothing. If the blending *
*    value is 15 then the destination pixel should take the forground color   *
*    , no blending is necessary. If the blending value is one of 1..14 then   *
*    all three color channels are blended and added together.                 *
*                                                                             *
******************************************************************************/

                    #define SETCOLOR(jj)    \
                    if (j = (jj))           \
                    {                       \
                        if (j == 15)        \
                        {                   \
                            u = uF;         \
                        }                   \
                        else                \
                        {                   \
                            u = 0;          \
                            uB = *pulDst;   \
                            CCC(Red,j);     \
                            CCC(Gre,j);     \
                            CCC(Blu,j);     \
                        }                   \
                        *pulDst = u;        \
                    }                       \
                    pulDst++

/************************************************************************
*                                                                       *
*    Each nyble of the source bitmap corresponds to 32 bits             *
*    in the destination bitmap. I have decided to arrange things        *
*    so that the inner most loop sets two pixels at a time. The         *
*    first of these two pixels starts on an even address in             *
*    the destination. After separating these 'aligned' pairs            *
*    in the middle of the scan there may be some left over              *
*    at the left (preamble) and the right (postamble). The              *
*    preamble can have at most one pixel in it. If there is             *
*    a pixel in the postamble then it correxponds to the                *
*    low nyble  of the source byte. If there is a pixel in              *
*    the postamble then it corresponds to the high nyble  of            *
*    the source byte. Each time, we have dealt with an odd              *
*    x-coordinate in the destination (corresponding to the              *
*    low nyble  in the source byte) we advance the source pointer       *
*    to the next byte.                                                  *
*                                                                       *
************************************************************************/

    A          = (DstLeft + 1) & ~1; // nearest multiple of 2 left of left edge
    B          = (DstRight   ) & ~1; // nearest multiple of 2 right of right edge
    cPreamble  = A - DstLeft;        // # pixels in preamble
    cMiddle    = (B - A)/2;          // # pixels in middle
    cPostamble = DstRight - B;       // # pixels in postamble
    pjSrcIn   += SrcLeft / 2;        // points to first source byte
    pjDstIn   += DstLeft * sizeof(ULONG);   // points to first dst DWORD
    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        int i;
        BYTE jSrc;
        BYTE *pjSrc = pjSrcIn;
        ULONG *pulDst  = (ULONG*) pjDstIn;

        if (cPreamble)
        {
            SETCOLOR(*pjSrc & 15);
            pjSrc++;
        }
        for (i = 0; i < cMiddle; i++)
        {
            jSrc = *pjSrc;
            SETCOLOR(jSrc >> 4);
            SETCOLOR(jSrc & 15);
            pjSrc++;
        }
        if (cPostamble)
        {
            SETCOLOR(*pjSrc >> 4);
        }
    }
#undef SETCOLOR
#undef CCC
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vOrNonAlignedGrayGlyphEven                                             *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Writes the a single gray glyph to a 4bpp buffer. This is for the       *
*   special case where the destination starts on a non byte (nyble )       *
*   boundary and the glyph images is an even number of pixels wide.        *
*                                                                          *
*   The source gray pixel image is guaranteed to have its initial scan     *
*   start on a 32-bit boundary, all subsequent scans start on byte         *
*   boundaries.                                                            *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgb         - address of gray GLYPHBITS structure                      *
*   dpSrcScan   - number of bytes between address of start of glyph scans  *
*   pjDstScan   - starting address of glyph image in destination buffer    *
*   dpDstScan   - increment between scan addresses in destination buffer   *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

void
vOrNonAlignedGrayGlyphEven(
    GLYPHBITS*  pgb      ,
    unsigned    dpSrcScan,
    BYTE*       pjDstScan,
    unsigned    dpDstScan
    )
{
/*
       0     1     2     3     4  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |n  n |n  n |n  n |n  n |n  n |     |     |     |
    | 1  0| 3  2| 5  4| 7  6| 9  8|     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                        ^  ^
    pjSrc                   Hi  Lo


       0     1     2     3     4     5  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |   n |n  n |n  n |n  n |n  n |n    |     |     |
    |    1| 0  3| 2  5| 4  7| 6  9| 8   |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                             ^
    pjDst                         pjDstLast

*/
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "void\n"
            "vOrNonAlignedGrayGlyphEven(\n"
            "    GLYPHBITS*  pgb       = %-#x\n"
            "    unsigned    dpSrcScan = %-#x\n"
            "    BYTE*       pjDstScan = %-#x\n"
            "    unsigned    dpDstScan = %-#x\n"
            "    )\n"
          , pgb
          , dpSrcScan
          , pjDstScan
          , dpDstScan
        );
        DbgBreakPoint();
    }
#endif
    BYTE jLo, jHi, *pjSrc, *pjDst, *pjSrcOut, *pjDstScanOut;

    dpSrcScan    = (pgb->sizlBitmap.cx + 1)/2;
    pjSrcOut     = pgb->aj;
    pjDstScanOut = pjDstScan + ((unsigned) pgb->sizlBitmap.cy) * dpDstScan;
    for ( ; pjDstScan < pjDstScanOut ; pjDstScan += dpDstScan)
    {
        pjSrc      = pjSrcOut;
        pjSrcOut  += dpSrcScan;
        for (jLo = 0, pjDst = pjDstScan; pjSrc < pjSrcOut; )
        {
            jHi = *pjSrc++;
            *pjDst++ |= (jLo << 4) + (jHi >> 4);
            jLo = jHi;
        }
        *pjDst |= (jLo << 4);
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vOrNonAlignedGrayGlyphOdd                                              *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Writes the a single gray glyph to a 4bpp buffer. This is for the       *
*   special case where the destination starts on a non byte (nyble )       *
*   boundary and the glyph images is an odd number of pixels wide.         *
*                                                                          *
*   The source gray pixel image is guaranteed to have its initial scan     *
*   start on a 32-bit boundary, all subsequent scans start on byte         *
*   boundaries.                                                            *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgb         - address of gray GLYPHBITS structure                      *
*   dpSrcScan   - number of bytes between address of start of glyph scans  *
*   pjDstScan   - starting address of glyph image in destination buffer    *
*   dpDstScan   - increment between scan addresses in destination buffer   *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

void
vOrNonAlignedGrayGlyphOdd(
    GLYPHBITS*  pgb      ,
    unsigned    dpSrcScan,
    BYTE*       pjDstScan,
    unsigned    dpDstScan
    )
{
/*
       0     1     2     3     4  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |n  n |n  n |n  n |n  n |n    |     |     |     |
    | 1  0| 3  2| 5  4| 7  6| 9   |     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                        ^  ^
    pjSrc                   Hi  Lo


       0     1     2     3     4     5  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |   n |n  n |n  n |n  n |n  n |     |     |     |
    |    1| 0  3| 2  5| 4  7| 6  9|     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                             ^
    pjDst                         pjDstLast

*/

    BYTE j1, j0, *pjDst, *pjSrc, *pjDstLast, *pjDstScanOut;
    unsigned cy        = (unsigned) pgb->sizlBitmap.cy;
    unsigned cx        = (unsigned) pgb->sizlBitmap.cx / 2;
    BYTE    *pjSrcScan = &(pgb->aj[0]);
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "void\n"
            "vOrNonAlignedGrayGlyphOdd(\n"
            "    GLYPHBITS*  pgb       = %-#x\n"
            "    unsigned    dpSrcScan = %-#x\n"
            "    BYTE*       pjDstScan = %-#x\n"
            "    unsigned    dpDstScan = %-#x\n"
            "    )\n"
          , pgb
          , dpSrcScan
          , pjDstScan
          , dpDstScan
        );
        DbgBreakPoint();
    }
#endif
    for (
        pjDstScanOut = pjDstScan + cy * dpDstScan
      ; pjDstScan < pjDstScanOut
      ; pjDstScan += dpDstScan, pjSrcScan += dpSrcScan
      )
    {
        //
        // set the source and destination pointers to point to the
        // start of the scans
        //

        pjSrc = pjSrcScan;
        pjDst = pjDstScan;

        //
        // do the first pixel in the scan
        //

        j1 = *pjSrc;
        *pjDst |= (j1 >> 4) & 0x0f;

        //
        // advance the pointers to the next pixel in the scans
        //

        pjSrc++;
        pjDst++;

        //
        // do the rest of the pixels in the scan
        //

        for (
            pjDstLast = pjDst + cx
          ; pjDst < pjDstLast
          ; pjDst++, pjSrc++
          )
        {
            j0 = j1;
            j1 = *pjSrc;
            *pjDst |= ((j1 >> 4) & 0x0f) | ((j0 << 4) & 0xf0);
        }

        //
        // last pixel in the scan has already been done
        //
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vOrAlignedGrayGlyphEven                                                *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Writes the a single gray glyph to a 4bpp buffer. This is for the       *
*   special case where the destination starts on a byte aligned boundary   *
*   and the glyph is an even number of pixels wide.                        *
*                                                                          *
*   This routine can be used for glyphs with odd widths.                   *
*                                                                          *
*   The source gray pixel image is guaranteed to have its initial scan     *
*   start on a 32-bit boundary, all subsequent scans start on byte         *
*   boundaries.                                                            *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgb         - address of gray GLYPHBITS structure                      *
*   dpSrcScan   - number of bytes between address of start of glyph scans  *
*   pjDstScan   - starting address of glyph image in destination buffer    *
*   dpDstScan   - increment between scan addresses in destination buffer   *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

void
vOrAlignedGrayGlyphEven(
    GLYPHBITS*  pgb      ,
    unsigned    dpSrcScan,
    BYTE*       pjDstScan,
    unsigned    dpDstScan
    )
{
/*
       0     1     2     3     4  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |n  n |n  n |n  n |n  n |n  n |     |     |     |
    | 1  0| 3  2| 5  4| 7  6| 9  8|     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                        ^  ^
    pjSrc                   Hi  Lo

       0     1     2     3     4  <-- byte number
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    |n  n |n  n |n  n |n  n |n  n |     |     |     |
    | 1  0| 3  2| 5  4| 7  6| 9  8|     |     |     |
    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    ^                             ^
    pjDst                         pjDstOut

    Note that this routine will also work for source
    glyphs with an odd number of pixels because
    the source glyph is padded with zeros. This means
    that for the case of odd length scans the last
    byte is or'ed into the destination but the
    extra nyble  of the source is guaranteed to have
    the value zero and thus has no effect.

*/

    BYTE *pjDst, *pjSrc, *pjDstOut, *pjDstScanOut;
    unsigned cy        = (unsigned) pgb->sizlBitmap.cy;

    // I round cx up to the nearest byte. This makes no
    // difference for glyphs of even width but it will
    // get that last column for glyphs with odd width.

    unsigned cx        = (unsigned) (pgb->sizlBitmap.cx+1) / 2;
    BYTE    *pjSrcScan = &(pgb->aj[0]);

#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
            "void\n"
            "vOrAlignedGrayGlyphEven(\n"
            "    GLYPHBITS*  pgb       = %-#x\n"
            "    unsigned    dpSrcScan = %-#x\n"
            "    BYTE*       pjDstScan = %-#x\n"
            "    unsigned    dpDstScan = %-#x\n"
            "    )\n"
          , pgb
          , dpSrcScan
          , pjDstScan
          , dpDstScan
        );
        DbgBreakPoint();
    }
#endif
    for (
        pjDstScanOut = pjDstScan + cy * dpDstScan
      ; pjDstScan < pjDstScanOut
      ; pjDstScan += dpDstScan, pjSrcScan += dpSrcScan
      )
    {
        pjSrc = pjSrcScan;
        pjDst = pjDstScan;
        for (pjDstOut = pjDst + cx ; pjDst < pjDstOut; pjDst++, pjSrc++)
        {
            *pjDst |= *pjSrc;
        }
    }
}

void (*(apfnGray[4]))(GLYPHBITS*, unsigned, BYTE*, unsigned) =
{
    vOrAlignedGrayGlyphEven
  , vOrAlignedGrayGlyphEven         // can handle odd width glyphs
  , vOrNonAlignedGrayGlyphEven
  , vOrNonAlignedGrayGlyphOdd
};

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   draw_gray_nf_ntb_o_to_temp_start                                       *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Assembles a gray glyph string into a temporary 4bpp right and left     *
*   DWORD aligned buffer. This routine assumes a variable pitch font.      *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pGlyphPos  - pointer to an array of cGlyph gray GLYPHPOS structures    *
*   cGlyphs    - count of gray glyphs in array starting at pGlyphPos       *
*   pjDst      - pointer to a 4bpp buffer where string is to be assembled  *
*                This buffer is DWORD aligned at the left and right        *
*                edges of each scan.                                       *
*   ulLeftEdge - screen coordinate corresponding to the left edge of       *
*                the temporary buffer                                      *
*   dpDst      - count of bytes in each scan of the destination buffer     *
*                (this must be a multiple of 4 because the buffer is       *
*                 DWORD aligned on each scan).                             *
*   ulCharInc  - This must be zero.                                        *
*   ulTempTop  - screen coordinate corresponding to the top of the         *
*                destination buffer. This is used to convert the           *
*                glyph positions on the screen to addresses in the         *
*                destination bitmap.                                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

extern "C" VOID draw_gray_nf_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDst,
    ULONG           ulLeftEdge,
    ULONG           dpDst,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS     *pgb;        // pointer to current GLYPHBITS

    int            x;          // pixel offset of the
                               // left edge of the glyph bitmap
                               // from the left edge of the
                               // output (4-bpp) bitmap

    int            y;          // the pixel offset of the top edge
                               // of the glyph bitmap from the top
                               // edge of the output bitmap.

    unsigned       bOddPos;    // (x-coordinate is odd) ? 1 : 0

    unsigned       cx;         // number of pixels per glyph scan
                               // If non zero then the destination
                               // bitmap is out of alignment with
                               // the source glyph by a one nyble
                               // shift and a single byte of the
                               // source will affect two consecutive
                               // bytes of the destination.

    unsigned       dpSrc;      // number of bytes per source scan. Each
                               // scan is BYTE aligned.
                               // = ceil(4*cx/8) = floor((cx+1)/2)

    GLYPHPOS      *pgpOut;     // sentinel for loop

    BYTE          *pj;         // pointer into Buffer corresponding
                               // to the upper left pixel of the
                               // current gray glyph
    pj = pjDst;
    for (pgpOut = pGlyphPos + cGlyphs; pGlyphPos < pgpOut; pGlyphPos++)
    {
        pgb         = pGlyphPos->pgdf->pgb;
        x           = pGlyphPos->ptl.x + pgb->ptlOrigin.x - ulLeftEdge;
        y           = pGlyphPos->ptl.y + pgb->ptlOrigin.y - ulTempTop ;
        bOddPos     = (unsigned) x & 1;
        cx          = (unsigned) pgb->sizlBitmap.cx;
        dpSrc       = (cx + 1)/2;
        pj          = pjDst + (y * dpDst) + (x/2);
        (*(apfnGray[(cx & 1) + 2*bOddPos]))(pgb, dpSrc, pj, dpDst);
    }
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   draw_gray_f_ntb_o_to_temp_start                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Assembles a gray glyph string into a temporary 4bpp right and left     *
*   DWORD aligned buffer. This routine assumes a fixed pitch font with     *
*   character increment equal to ulCharInc                                 *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pGlyphPos  - pointer to an array of cGlyph gray GLYPHPOS structures    *
*   cGlyphs    - count of gray glyphs in array starting at pGlyphPos       *
*   pjDst      - pointer to a 4bpp buffer where string is to be assembled  *
*                This buffer is DWORD aligned at the left and right        *
*                edges of each scan.                                       *
*   ulLeftEdge - screen coordinate corresponding to the left edge of       *
*                the temporary buffer                                      *
*   dpDst      - count of bytes in each scan of the destination buffer     *
*                (this must be a multiple of 4 because the buffer is       *
*                 DWORD aligned on each scan).                             *
*   ulCharInc  - This must be zero.                                        *
*   ulTempTop  - screen coordinate corresponding to the top of the         *
*                destination buffer. This is used to convert the           *
*                glyph positions on the screen to addresses in the         *
*                destination bitmap.                                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

extern "C" VOID draw_gray_f_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDst,
    ULONG           ulLeftEdge,
    ULONG           dpDst,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS     *pgb;        // pointer to current GLYPHBITS

    int            x;          // x-coordinate of the current
                               // character origin with respect
                               // to the upper left pixel of the
                               // output (4-bpp) bitmap

    int            y;          // y-coordinate of the current
                               // character origin with respect
                               // to the upper left pixel of the
                               // output (4-bpp) bitmap

    unsigned       bOddPos;    // (x-coordinate is odd) ? 1 : 0

    unsigned       cx;         // number of pixels per glyph scan
                               // If non zero then the destination
                               // bitmap is out of alignment with
                               // the source glyph by a one nyble
                               // shift and a single byte of the
                               // source will affect two consecutive
                               // bytes of the destination.

    unsigned       dpSrc;      // number of bytes per source scan. Each
                               // scan is BYTE aligned.
                               // = ceil(4*cx/8) = floor((cx+1)/2)

    GLYPHPOS      *pgpOut;     // sentinel for loop

    BYTE          *pj;         // pointer into Buffer corresponding
                               // to the upper left pixel of the
                               // current gray glyph
#if DBG
    if (gflFontDebug & DEBUG_AA)
    {
        DbgPrint(
        "draw_gray_f_ntb_o_to_temp_start(\n"
        "   PGLYPHPOS       pGlyphPos     = %-#x\n"
        "   ULONG           cGlyphs       = %u\n"
        "   PUCHAR          pjDst         = %-#x\n"
        "   ULONG           ulLeftEdge    = %u\n"
        "   ULONG           dpDst         = %u\n"
        "   ULONG           ulCharInc     = %u\n"
        "   ULONG           ulTempTop     = %u\n"
        "   )\n"
        , pGlyphPos
        , cGlyphs
        , pjDst
        , ulLeftEdge
        , dpDst
        , ulCharInc
        , ulTempTop
        );
        DbgBreakPoint();
    }
#endif

    // (x,y) = position of first CHARACTER ORIGIN with respect to
    //         the upper left pixel of the destination 4bpp bitmap

    x  = pGlyphPos->ptl.x - ulLeftEdge;
    y  = pGlyphPos->ptl.y - ulTempTop;

    for (pgpOut = pGlyphPos + cGlyphs; pGlyphPos < pgpOut; x += ulCharInc, pGlyphPos++)
    {
        int xT, yT; // position of UPPER LEFT pixel of glyph
                    // with respect to the upper left pixel
                    // of the bitmap.

        pgb         = pGlyphPos->pgdf->pgb;
        xT          = x + pgb->ptlOrigin.x;
        yT          = y + pgb->ptlOrigin.y;
        bOddPos     = (unsigned) xT & 1;
        cx          = (unsigned) pgb->sizlBitmap.cx;
        dpSrc       = (cx + 1)/2;
        pj          = pjDst + (yT * dpDst) + (xT/2);

#if DBG
        if (gflFontDebug & DEBUG_AA)
        {
            DbgPrint(
            "\n"
            "   pgb     = %-#x\n"
            "       ptlOrigin = (%d,%d)\n"
            "   xT      = %d\n"
            "   yT      = %d\n"
            "   bOddPos = %d\n"
            , pgb
            , pgb->ptlOrigin.x
            , pgb->ptlOrigin.y
            , xT
            , yT
            , bOddPos
            );
            DbgPrint(
            "   cx      = %u\n"
            "   dpSrc   = %u\n"
            "   pj      = %-#x\n"
            "   (cx & 1) + 2*bOddPos = %d\n"
            , cx
            , dpSrc
            , pj
            , (cx & 1) + 2*bOddPos
            );
            DbgBreakPoint();
        }
#endif
        (*(apfnGray[(cx & 1) + 2*bOddPos]))(pgb, dpSrc, pj, dpDst);
    }
}


#if DBG
/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vDumpGrayBuffer                                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Debug routine for dumping the temporary 4bpp gray string buffer        *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pjBuffer - pointer to gray 4bpp image                                  *
*   dpjScan  - count of bytes per scan                                     *
*   prcl     - rectangle surrounding 4bpp gray image                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

void vDumpGrayBuffer(BYTE *pjBuffer, ULONG dpjScan, RECTL *prcl)
{
    BYTE *pj, *pjNext, *pjOut;
    static char achNyble[16] = {
        ' ','1','2','3','4','5','6','7'
       ,'8','9','a','b','c','d','e','f'
    };
    DbgPrint(
        "vDumpGrayBuffer(\n"
        "    pjBuffer = %-#x\n"
        "    dpjScan  = %u\n"
        "    prcl     = %-#x ==> %d %d %d %d\n"
        ")\n"
    ,   pjBuffer
    ,   dpjScan
    ,   prcl
    ,   prcl->left, prcl->top, prcl->right, prcl->bottom
    );
    DbgPrint("+");
    for (ULONG i = 0; i < dpjScan; i++)
        DbgPrint("--");
    DbgPrint("+\n");
    pjOut = pjBuffer + dpjScan * (prcl->bottom - prcl->top);
    for (pj = pjBuffer; pj < pjOut;) {
        DbgPrint("|");
        for (pjNext = pj + dpjScan; pj < pjNext; pj++)
            DbgPrint("%c%c", achNyble[*pj >> 4], achNyble[*pj & 15]);
        DbgPrint("|\n");
    }
    DbgPrint("+");
    for (i = 0; i < dpjScan; i++)
        DbgPrint("--");
    DbgPrint("+\n");
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vPrintGrayGLYPHBITS                                                    *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps Gray GLYPHBITS to the debug screen                               *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgb - pointer to a gray GLYPHBITS structure                            *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vPrintGrayGLYPHBITS(GLYPHBITS *pgb)
{
    BYTE *pj, *pjNext, *pjEnd;
    ptrdiff_t cjScan, i;
    static char achNyble[16] =
    {' ','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};

    DbgPrint(
        "Gray GLYPHBITS at   = %-#x\n"
        "    ptlOrigin  = %d %d\n"
        "    sizlBitmap = %u %u\n"
    ,   pgb
    ,   pgb->ptlOrigin.x
    ,   pgb->ptlOrigin.y
    ,   pgb->sizlBitmap.cx
    ,   pgb->sizlBitmap.cy
    );
    pj     = pgb->aj;
    cjScan = ((ptrdiff_t) pgb->sizlBitmap.cx + 1)/2;
    pjNext = pj + cjScan;
    pjEnd  = pj + cjScan * (ptrdiff_t) pgb->sizlBitmap.cy;
    DbgPrint("+");
    for (i = 0; i < cjScan; i++)
        DbgPrint("--");
    DbgPrint("+\n");
    while (pj < pjEnd) {
        DbgPrint("|");
        while (pj < pjNext) {
            DbgPrint("%c%c" , achNyble[*pj >> 4], achNyble[*pj & 0xf]);
            pj += 1;
        }
        pj = pjNext;
        pjNext += cjScan;
        DbgPrint("|\n");
    }
    DbgPrint("+");
    for (i = 0; i < cjScan; i++)
        DbgPrint("--");
    DbgPrint("+\n\n");
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vPrintGrayGLYPHPOS                                                     *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps the contents of a Gray GLYPHPOS structure to the                 *
*   debugger.                                                              *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pgpos - a pointer to a gray GLYPHPOS structure                         *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vPrintGrayGLYPHPOS(GLYPHPOS *pgpos)
{
    DbgPrint("Gray GLYPHPOS at %-#x\n",   pgpos);
    DbgPrint("    hg   = %-#x\n",    pgpos->hg);
    DbgPrint("    pgdf = %-#x\n",    pgpos->pgdf);
    DbgPrint("    ptl  = (%d,%d)\n", pgpos->ptl.x, pgpos->ptl.y);
    // vPrintGrayGLYPHBITS(pgpos->pgdf->pgb);
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   vDump8bppDIB                                                           *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Dumps an 8bpp DIB to the screen. This routine only recognizes the      *
*   four canonical shades of gray, all other colors are marked with        *
*   a question mark                                                        *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   SURFMEM reference.                                                     *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   none                                                                   *
*                                                                          *
\**************************************************************************/

void vDump8bppDIB(SURFMEM& surfmem)
{
    char ch;
    int j;
    BYTE *pjScan, *pj, *pjOut;
    ULONG dpjScan;
    SURFOBJ *pso = surfmem.pSurfobj();

    DbgPrint("Dumping the contents of the 8bpp DIB\n");
    pso = surfmem.pSurfobj();
    pjScan  = (BYTE*) pso->pvBits;
    dpjScan = 4 * ((pso->sizlBitmap.cx + 3) / 4);
    DbgPrint("+");
    for (j = 0; j < pso->sizlBitmap.cx; j++)
    {
        DbgPrint("-");
    }
    DbgPrint("+\n");
    for (j = pso->sizlBitmap.cy; j; j--)
    {
        pj     = pjScan;
        pjOut  = pjScan + pso->sizlBitmap.cx;
        pjScan += dpjScan;
        DbgPrint("|");
        while (pj < pjOut)
        {
            switch (*pj++)
            {
            case   0:   ch = ' '; break;
            case 248:   ch = '+'; break;
            case   7:   ch = '*'; break;
            case 255:   ch = '#'; break;
            default:    ch = '?'; break;
            }
            DbgPrint("%c",ch);
        }
        DbgPrint("|\n");
    }
    DbgPrint("+");
    for (j = 0; j < pso->sizlBitmap.cx; j++)
    {
        DbgPrint("-");
    }
    DbgPrint("+\n");
}
#endif


// make them global for now, easier to debug

ULONG  aulCacheCT[CT_LOOKUP];
HANDLE hCacheCT;
ULONG  uFCacheCT;
ULONG  uBCacheCT;
ULONG  sizeCacheCT;
ULONG  uGammaCacheCT;


VOID vGetBlendInfo (
    ULONG size, SURFACE *pS,            // input
    ULONG uF,                           // foreground color
    BLENDINFO  *pbi                     // output
);



VOID *pvFillOpaqTableCT(
    ULONG      size,
    ULONG      uF,
    ULONG      uB,
    SURFACE   *pS,
    BLENDINFO *pbi,         // must NOT be NULL
    BOOL       bTransparent // in transparent case we must compute bi info,
    );                      // in opaque case do not need to
                            // if the table is up to date


VOID vClearTypeLookupTableLoop(
    ULONG       size,
    SURFACE    *pS,
    BLENDINFO  *pbi,
    ULONG       uF,
    ULONG       uB
)
{
// this can not fail, store the new info

    sizeCacheCT = size;
    uFCacheCT   = uF;
    uBCacheCT   = uB;
    uGammaCacheCT = gulGamma;
    hCacheCT    = pS->hGet();

    ULONG  *pul =           aulCacheCT;
    USHORT *pus = (USHORT*) aulCacheCT;
    ULONG   ul;

    LONG dRedB, dGreB, dBluB; // precompute the diffs outside of the loop
    LONG lRedB, lGreB, lBluB; // precompute outside of the loop

    lRedB  = pbi->pjGamma[((((uB & pbi->flRed) << pbi->iRedL) >> pbi->iRedR) & 255)];
    lGreB  = pbi->pjGamma[((((uB & pbi->flGre) << pbi->iGreL) >> pbi->iGreR) & 255)];
    lBluB  = pbi->pjGamma[((((uB & pbi->flBlu) << pbi->iBluL) >> pbi->iBluR) & 255)];

    dRedB = pbi->lRedF - lRedB;
    dGreB = pbi->lGreF - lGreB;
    dBluB = pbi->lBluF - lBluB;

// the first and last entries are set outside the loop, for perf reasons

    ULONG iTable;
    const F_RGB *pfrgb;

    for
    (
         iTable = 1, pfrgb = &gaOutTable[1];
         iTable < (CT_LOOKUP-1);
         iTable++, pfrgb++
    )
    {
      ULONG ulRT, ulGT, ulBT;

      ulRT = BLENDCT(pfrgb->kR, pbi->lRedF, lRedB, dRedB);
      ulGT = BLENDCT(pfrgb->kG, pbi->lGreF, lGreB, dGreB);
      ulBT = BLENDCT(pfrgb->kB, pbi->lBluF, lBluB, dBluB);

      ASSERTGDI(((ulRT | ulGT | ulBT) & 0xffffff00) == 0,
          "lookup table computation!!!\n");

      ulRT = pbi->pjGammaInv[ulRT];
      ulGT = pbi->pjGammaInv[ulGT];
      ulBT = pbi->pjGammaInv[ulBT];

      ul  = (((ulRT << pbi->iRedR) >> pbi->iRedL) & pbi->flRed);
      ul |= (((ulGT << pbi->iGreR) >> pbi->iGreL) & pbi->flGre);
      ul |= (((ulBT << pbi->iBluR) >> pbi->iBluL) & pbi->flBlu);

      if (size == sizeof(USHORT))
          pus[iTable] = (USHORT)ul;
      else
          pul[iTable] = ul;
    }

    // make sure that blending and gamma correcting did not mess up
    // backgroung and foreground pixels. (not sure that the round trip
    // is guarranteed)

    if (size == sizeof(USHORT))
    {
        pus[0]           = (USHORT)uB; // set the first value to background:
        pus[CT_LOOKUP-1] = (USHORT)uF; // set the last value to foreground
    }
    else
    {
        pul[0]           = uB; // set the first value to background:
        pul[CT_LOOKUP-1] = uF; // set the last value to foreground
    }
}




/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS8D16                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS8D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{

    USHORT *aus;
    ULONG   cusDst = DstRight - DstLeft;
    BLENDINFO bi;
    SEMOBJ so(ghsemEUDC2);

    aus = (USHORT*) pvFillOpaqTableCT(sizeof(*aus), uF, uB, pS, &bi, FALSE);
    pjSrcIn   += SrcLeft;
    pjDstIn   += DstLeft * sizeof(USHORT);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE   *pjSrc = pjSrcIn;
        USHORT *pusDst = (USHORT*) pjDstIn;
        USHORT *pusDstEnd = pusDst + cusDst;

        for ( ; pusDst < pusDstEnd; pusDst++, pjSrc++)
        {
            *pusDst = aus[*pjSrc];
        }
    }
}


static
ULONG FASTCALL ulBlendPixelCT(BLENDINFO *pbi, ULONG uB, const F_RGB *pfrgb)
{
    ULONG ulRet, ulT;
    LONG  lB, dB;

// shift as ULONG's, store as LONG's.

    lB = pbi->pjGamma[((((uB & pbi->flRed) << pbi->iRedL) >> pbi->iRedR) & 255)];
    dB = pbi->lRedF - lB;
    ulT = BLENDCT(pfrgb->kR, pbi->lRedF, lB, dB);
    ulT = pbi->pjGammaInv[ulT];
    ulRet  = (((ulT << pbi->iRedR) >> pbi->iRedL) & pbi->flRed);

    lB = pbi->pjGamma[((((uB & pbi->flGre) << pbi->iGreL) >> pbi->iGreR) & 255)];
    dB = pbi->lGreF - lB;
    ulT = BLENDCT(pfrgb->kG, pbi->lGreF, lB, dB);
    ulT = pbi->pjGammaInv[ulT];
    ulRet |= (((ulT << pbi->iGreR) >> pbi->iGreL) & pbi->flGre);

    lB = pbi->pjGamma[((((uB & pbi->flBlu) << pbi->iBluL) >> pbi->iBluR) & 255)];
    dB = pbi->lBluF - lB;
    ulT = BLENDCT(pfrgb->kB, pbi->lBluF, lB, dB);
    ulT = pbi->pjGammaInv[ulT];
    ulRet |= (((ulT << pbi->iBluR) >> pbi->iBluL) & pbi->flBlu);

    return ulRet;
}


VOID
vSrcTranCopyS8D16New(
    PBYTE               pjSrcIn,
    LONG                SrcLeft,
    LONG                DeltaSrcIn,
    PBYTE               pjDstIn,
    LONG                DstLeft,
    LONG                DstRight,
    LONG                DeltaDstIn,
    LONG                cy,
    ULONG               uF,
    ULONG               uB,
    SURFACE             *pS,
    FNCOPYALPHABUFFER   *pfnCopyAlphaBuffer,
    PBYTE               pjCopyBuffer
    )
{
    USHORT *aus = NULL;  // points to lookup table
    LONG   cusDst = (LONG)(DstRight - DstLeft);
    BLENDINFO bi;
    ULONG   uB0;  // background pixel in the upper left corner
    SEMOBJ so(ghsemEUDC2);

    pjSrcIn   += SrcLeft;
    pjDstIn   += DstLeft * sizeof(USHORT);

// take the hit, hoping the background will not be variable

    uB0 = uB = *((USHORT *)pjDstIn);
    aus = (USHORT *)pvFillOpaqTableCT(sizeof(USHORT), uF, uB, pS, &bi, TRUE);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE   *pjSrc = pjSrcIn;
        USHORT *pusDst = (USHORT*) pjDstIn;
        LONG    cx = cusDst;
        USHORT *pusDstNew;

    // copy dst to the temp buffer according to alpha information

        (*pfnCopyAlphaBuffer)(pjSrc, pjDstIn, pjCopyBuffer, cusDst, &pusDstNew);

        for ( ; cx; cx--, pusDst++, pjSrc++, pusDstNew++)
        {
        // if *pjSrc == 0, we do not touch the destination, therefore
        // we do not need to READ the destination and do not need to blend.
        // This is about 68% of the pixels in winstone scenario.
        // Likewise, if *pjSrc == max_index (ie pure foreground), READ
        // operation is not necessary, the only thing we do is WRITE of the
        // foreground to the destination,

            ULONG kSrc = *pjSrc;

            if (kSrc)
            {
                uB = *pusDstNew; // no hit any more on the read

                if (uB == uB0)   // 25% of the pixels in winstone
                {
                    *pusDst = aus[kSrc]; // background did not change, lucky
                }
                else if (kSrc == (CT_LOOKUP-1)) // 5% of the pixels in winstone
                {
                    *pusDst = (USHORT)uF;
                }
                else // auch, must blend, fortunately only 2% on winstone
                {
                    *pusDst = (USHORT)ulBlendPixelCT(&bi, uB, &gaOutTable[kSrc]);
                }
            }
        }
    }
}



/******************************Public*Routine******************************\
*                                                                          
* Routine Name                                                             
*                                                                          
*   vCopyAlphaBuffer16bpp                                                  
*                                                                          
* Routine Description:                                                     
*
*   This routine copies from 'pjSrc' to 'pjDst' the portions needed for
*   doing blended, as specified by the 'pjAlpha' alpha buffer.  
*
*   The motivation for this routine is that reads from video memory are
*   performance killers, and we want to do reads only where we absolutely
*   need to.  
*
*   I have observed that consecutive word reads from video memory are
*   typically about 4 MB/s on AGP systems; consecutive dword reads are
*   typically about 8 MB/s.
*
*   This is done as the first pass in the blend operation, in order to
*   get all the reads done first for all the read-modify-write operations
*   implicit in a blend.  We very carefully pay attention to the blend
*   buffer we'll be using later to read only those pixels that we'll
*   need.
*
*   We get 2 benefits:
*
*   1. It's easy to combine reads into dword reads.  If we need both
*      pixels in a dword, it's twice as fast to do a single dword read
*      as it is to do 2 consecutive word reads.
*   2. We enable the write portion to be all write-combined, which wouldn't
*      be true if we were doing read-modify-write on a pixel by pixel basis.
*
*                                                                          
* Arguments:                                                               
*                                                                          
*    pjAlpha    - alpha buffer that is actually the source in the blend
*                 operation; this tells us what pixels we'll need to read
*                 from the destination of the blend operation
*    pjSrc      - actually points to the destination of the blend operation
*    pjDst      - points to where we'll store our temporary copy of the
*                 destination of the blend operation
*    cx         - number of pixels to read
*                                                                          
* Return Value:                                                            
*                                                                          
*   None                                                                   
*                                                                          
\**************************************************************************/

// This macro returns TRUE if the specified alpha value is either 
// completely transparent or completely opaque.  In either case, we
// don't actually need to read the destination.
//
// NOTE: For reasons that escape me, the compiler required casts to
//       'unsigned' even though all the parameters were unsigned.

#define TRANSLUCENT(a) ((UCHAR) ((a) - 1) < (CT_LOOKUP - 2))

VOID
vCopyAlphaBuffer16bpp(
    PBYTE   pjAlpha,
    PBYTE   pjSrc,
    PBYTE   pjDst,
    LONG    cx,
    PUSHORT *ppusDstNew
    )
{
    ULONG cj = (ULONG)(((ULONG_PTR) pjSrc) & 3);
    pjDst += cj;
    *ppusDstNew = (USHORT*)pjDst;

    if (((ULONG_PTR) pjSrc) & 2) 
    {
        if (TRANSLUCENT(pjAlpha[0]))
        {
            *((USHORT*) pjDst) = *((USHORT*) pjSrc);
        }
        pjSrc += 2;
        pjDst += 2;
        pjAlpha++;
        cx--;
    }

    while (TRUE)
    {
        cx -= 2;
        if (cx < 0)
            break;

        if (TRANSLUCENT(pjAlpha[0]) || TRANSLUCENT(pjAlpha[1]))
        {
            *((ULONG*) pjDst) = *((ULONG*) pjSrc);
        }
        pjSrc += 4;
        pjDst += 4;
        pjAlpha += 2;
    }
    if (cx & 1)
    {
        if (TRANSLUCENT(pjAlpha[0]))
        {
            *((USHORT*) pjDst) = *((USHORT*) pjSrc);
        }
    }
}


/******************************Public*Routine******************************\
*                                                                          
* Routine Name                                                             
*                                                                          
*   vCopyAlphaBuffer16bppMMX                                                  
*                                                                          
* Routine Description:                                                     
*
*   This routine works the same as 'vCopyAlphaBuffer16bpp', except that
*   it will take advantage of MMX 64-bit operations to improve the read
*   speed even more.  
*
*   I have observed that consecutive dword reads from video memory are
*   typically about 8 MB/s on AGP systems; consecutive qword reads are
*   typically about 11 MB/s.  
*
*   IMPORTANT NOTE: The floating point state is expected to have already
*                   been saved!  
*                                                                          
* Arguments:                                                               
*                                                                          
*    pjAlpha    - alpha buffer that is actually the source in the blend
*                 operation; this tells us what pixels we'll need to read
*                 from the destination of the blend operation
*    pjSrc      - actually points to the destination of the blend operation
*    pjDst      - points to where we'll store our temporary copy of the
*                 destination of the blend operation
*    cx         - number of pixels to read
*                                                                          
* Return Value:                                                            
*                                                                          
*   None                                                                   
*                                                                          
\**************************************************************************/

// Disable the "missing emms" warning.  We don't really need to do it in 
// this routine; instead, we do the emms instruction just before we restore 
// the floating point state.

#pragma warning( disable: 4799 )

VOID
vCopyAlphaBuffer16bppMMX(
    PBYTE   pjAlpha,
    PBYTE   pjSrc,
    PBYTE   pjDst,
    LONG    cx,
    PUSHORT *ppusDstNew
    )
{
    ULONG cj = (ULONG)(((ULONG_PTR) pjSrc) & 7);
    pjDst += cj;
    *ppusDstNew = (USHORT*)pjDst;

    if (((ULONG_PTR) pjSrc) & 2) 
    {
        if (TRANSLUCENT(pjAlpha[0]))
        {
            *((USHORT*) pjDst) = *((USHORT*) pjSrc);
        }
        pjSrc += 2;
        pjDst += 2;
        pjAlpha++;
        cx--;
    }

    if (((ULONG_PTR) pjSrc) & 4)
    {
        if (cx >= 2)
        {
            cx -= 2;
            if (TRANSLUCENT(pjAlpha[0]) || TRANSLUCENT(pjAlpha[1]))
            {
                *((ULONG*) pjDst) = *((ULONG*) pjSrc);
            }
            pjSrc += 4;
            pjDst += 4;
            pjAlpha += 2;
        }
    }

    while (TRUE)
    {
        cx -= 4;
        if (cx < 0)
            break;

        if (TRANSLUCENT(pjAlpha[0]) || TRANSLUCENT(pjAlpha[1]))
        {
            if (TRANSLUCENT(pjAlpha[2]) || TRANSLUCENT(pjAlpha[3]))
            {
                // Do a 64-bit copy using the MMX registers:

            #if defined(_X86_)
            
                _asm
                {
                    mov     esi, pjSrc
                    movq    mm0, [esi]
                    mov     esi, pjDst
                    movq    [esi], mm0
                }

            #endif

            }
            else
            {
                *((ULONG*) pjDst) = *((ULONG*) pjSrc);
            }
        }
        else if (TRANSLUCENT(pjAlpha[2]) || TRANSLUCENT(pjAlpha[3]))
        {
            *((ULONG*) (pjDst + 4)) = *((ULONG*) (pjSrc + 4));
        }
        pjSrc += 8;
        pjDst += 8;
        pjAlpha += 4;
    }
    if (cx & 2)
    {
        if (TRANSLUCENT(pjAlpha[0]) || TRANSLUCENT(pjAlpha[1]))
        {
            *((ULONG*) pjDst) = *((ULONG*) pjSrc);
        }
        pjSrc += 4;
        pjDst += 4;
        pjAlpha += 2;
    }
    if (cx & 1)
    {
        if (TRANSLUCENT(pjAlpha[0]))
        {
            *((USHORT*) pjDst) = *((USHORT*) pjSrc);
        }
    }
}

#define COPY_BUFFER_ENTRIES   1000
#define COPY_BUFFER_SIZE (sizeof(double) * COPY_BUFFER_ENTRIES)
double  gajCopyBuffer[COPY_BUFFER_ENTRIES];

/******************************Public*Routine******************************\
*                                                                          
* Routine Name                                                             
*                                                                          
*   vSrcTranCopyS8D16
*                                                                          
* Routine Description:                                                     
*
*   This routine chooses the optimal SrcTranCopy routine for the display,
*   be it 5-5-5 or 5-6-5 or arbitrary.  It also chooses the appropriate 
*   destination 'copy' routine based on the hardware's capabilities.
*
*   NOTE: I expect this function to disappear, and this logic moved up
*         higher at some point.
*                                                                          
* Arguments:                                                               
*                                                                          
* Return Value:                                                            
*                                                                          
*   None                                                                   
*                                                                          
\**************************************************************************/

VOID
vSrcTranCopyS8D16(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
// !!! Note that this isn't thread safe or anything

    BYTE* pjCopyBuffer = (BYTE *)gajCopyBuffer;
    BOOL bAlloc = FALSE;
    ULONG cjNeeded = (DstRight - DstLeft) * sizeof(USHORT) + sizeof(double);

    if (cjNeeded > COPY_BUFFER_SIZE)
    {
        pjCopyBuffer = (PBYTE)PALLOCNOZ(cjNeeded, 'oteG');
        if (!pjCopyBuffer)
            return;
        bAlloc = TRUE;
    }

    #if defined(_X86_)
    if (gbMMXProcessor)
    {


        KFLOATING_SAVE fsFpState;

    // This save operation is quite expensive.  We would want to amortize
    // its cost across all the rectangles if there is complex clipping.

        NTSTATUS status = KeSaveFloatingPointState(&fsFpState);

        ASSERTGDI(NT_SUCCESS(status),
            "Unexpected KeSaveFloatingPointState failure");

        vSrcTranCopyS8D16New(pjSrcIn, SrcLeft, DeltaSrcIn, pjDstIn, DstLeft,
                             DstRight, DeltaDstIn, cy, uF, uB, pS,
                             vCopyAlphaBuffer16bppMMX, pjCopyBuffer);

    // Do the 'emms' instruction now that we're done with all of our
    // MMX operations.  I'm not actually sure if we really need to do
    // this because KeRestoreFloatingPointState might handle it anyway,
    // but we're better safe than sorry.
    //
    // NOTE: 'emms' is a very expensive operation.

        _asm emms

        KeRestoreFloatingPointState(&fsFpState);


    }
    else
    #endif
    {
        // We don't have to worry about floating point state in this
        // code path.

        vSrcTranCopyS8D16New(pjSrcIn, SrcLeft, DeltaSrcIn, pjDstIn, DstLeft,
                             DstRight, DeltaDstIn, cy, uF, uB, pS,
                             vCopyAlphaBuffer16bpp, pjCopyBuffer);
    }

    if (bAlloc)
        VFREEMEM(pjCopyBuffer);
}


/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS8D24                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS8D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{

    ULONG  *aul;            // a cache of the 252 possible 24-bit
                            // colors that can be seen on the
                            // destination surface.

    ULONG  cjDst = 3 * (DstRight - DstLeft);
    BLENDINFO bi;
    SEMOBJ so(ghsemEUDC2);

    aul = (ULONG*) pvFillOpaqTableCT(sizeof(*aul), uF, uB, pS, &bi, FALSE);

    pjSrcIn += SrcLeft ;            // 1 pixels per src byte
    pjDstIn += DstLeft * 3;         // 3 bytes per dest pixel

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE  *ajSrc; // points directly into OpaqTable
        BYTE  *pjSrc = pjSrcIn;
        BYTE  *pjDst = pjDstIn;
        BYTE  *pjDstEnd = pjDstIn + cjDst;

        for ( ;pjDst < pjDstEnd; pjSrc++)
        {
            ajSrc = (BYTE*) &aul[*pjSrc];
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc++;
            *pjDst++ = *ajSrc;
        }
    }
}



VOID
vSrcTranCopyS8D24(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{

    BLENDINFO bi;

    ULONG  *aul;
    ULONG   ulFore = uF & 0xffffff; // 24 bits
    ULONG   ulNewFore;
    ULONG   uB0;
    SEMOBJ so(ghsemEUDC2);

    ULONG  cjDst = 3 * (DstRight - DstLeft);

    pjSrcIn += SrcLeft ;            // 1 pixels per src byte
    pjDstIn += DstLeft * 3;         // 3 bytes per dest pixel

// this is real slow, there 3 reads, must optimize

    uB0 = ((ULONG)pjDstIn[0] <<  0) |
          ((ULONG)pjDstIn[1] <<  8) |
          ((ULONG)pjDstIn[2] << 16) ;

// precompute the table in case we need it:

    aul = (ULONG*) pvFillOpaqTableCT(sizeof(*aul), uF, uB0, pS, &bi, TRUE);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE  *ajSrc; // points directly into OpaqTable
        BYTE  *pjSrc = pjSrcIn;
        BYTE  *pjDst = pjDstIn;
        BYTE  *pjDstEnd = pjDstIn + cjDst;

        for ( ;pjDst < pjDstEnd; pjSrc++)
        {
            if (*pjSrc)
            {
                if (*pjSrc == (CT_LOOKUP-1)) // pure foreground
                {
                    ajSrc = (BYTE*)&ulFore;
                }
                else
                {
                    uB = ((ULONG)pjDst[0] <<  0) |
                         ((ULONG)pjDst[1] <<  8) |
                         ((ULONG)pjDst[2] << 16) ;

                    if (uB == uB0)
                    {
                        ajSrc = (BYTE*) &aul[*pjSrc];
                    }
                    else // must blend
                    {
                        ulNewFore = ulBlendPixelCT(&bi, uB, &gaOutTable[*pjSrc]);
                        ajSrc = (BYTE*)&ulNewFore;
                    }
                }

                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc++;
                *pjDst++ = *ajSrc;
            }
            else
            {
                pjDst += 3; // do not touch the background, just inc position
            }
        }
    }
}



/******************************Public*Routine******************************\
*                                                                          *
* Routine Name                                                             *
*                                                                          *
*   vSrcOpaqCopyS8D32                                                      *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*    pjSrcIn    - pointer to beginning of current scan line of src buffer  *
*    SrcLeft    - left (starting) pixel in src rectangle                   *
*    DeltaSrcIn - bytes from one src scan line to next                     *
*    pjDstIn    - pointer to beginning of current scan line of Dst buffer  *
*    DstLeft    - left(first) dst pixel                                    *
*    DstRight   - right(last) dst pixel                                    *
*    DeltaDstIn - bytes from one Dst scan line to next                     *
*    cy         - number of scan lines                                     *
*    uF         - Foreground color                                         *
*    uB         - Background color                                         *
*    pS         - pointer to destination SURFACE                           *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

VOID
vSrcOpaqCopyS8D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    ULONG  *aul;      // array of 252 possible colors
    ULONG   culDst = (DstRight - DstLeft); // * sizeof(ULONG)
    BLENDINFO bi;
    SEMOBJ so(ghsemEUDC2);

    aul = (ULONG*) pvFillOpaqTableCT(sizeof(*aul), uF, uB, pS, &bi, FALSE);

    pjSrcIn   += SrcLeft;
    pjDstIn   += DstLeft * sizeof(ULONG);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE *pjSrc = pjSrcIn;
        ULONG *pul  = (ULONG*) pjDstIn;
        ULONG *pulEnd  = pul + culDst;

        for ( ; pul < pulEnd; pul++, pjSrc++)
        {
            *pul = aul[*pjSrc];
        }
    }
}


VOID
vSrcTranCopyS8D32(
    PBYTE   pjSrcIn,
    LONG    SrcLeft,
    LONG    DeltaSrcIn,
    PBYTE   pjDstIn,
    LONG    DstLeft,
    LONG    DstRight,
    LONG    DeltaDstIn,
    LONG    cy,
    ULONG   uF,
    ULONG   uB,
    SURFACE *pS
    )
{
    BLENDINFO bi;

    ULONG  *aul;
    ULONG   culDst = (DstRight - DstLeft); // * sizeof(ULONG)
    ULONG   uB0; // dst pixel at the upper left corner
    SEMOBJ so(ghsemEUDC2);

    pjSrcIn   += SrcLeft;
    pjDstIn   += DstLeft * sizeof(ULONG);

// take the hit, hoping the background will not be variable

    uB0 = uB = *((ULONG *)pjDstIn);

// compute the table, get blending info

    aul = (ULONG*) pvFillOpaqTableCT(sizeof(*aul), uF, uB, pS, &bi, TRUE);

    for (; cy; cy--, pjSrcIn += DeltaSrcIn, pjDstIn += DeltaDstIn)
    {
        BYTE *pjSrc = pjSrcIn;
        ULONG *pul  = (ULONG*) pjDstIn;
        ULONG *pulEnd  = pul + culDst;

        for ( ; pul < pulEnd; pul++, pjSrc++)
        {
            ULONG kSrc = *pjSrc;

            if (kSrc)
            {
                if (kSrc == (CT_LOOKUP-1)) // pure foreground
                {
                    *pul = uF; // just write, no read, no recompute
                }
                else
                {
                // now comes the slow read/modify/write operation on a per pixel basis

                    uB = *pul; // read

                    if (uB == uB0)  // lucky, background did not change
                    {
                        *pul = aul[kSrc]; // write
                    }
                    else // blend on the spot
                    {
                        *pul = ulBlendPixelCT(&bi, uB, &gaOutTable[kSrc]);
                    }
                }
            }
        }
    }
}

void
vOrClearTypeGlyph(
    GLYPHBITS*  pgb      ,
    unsigned    dpSrcScan,
    BYTE*       pjDstScan,
    unsigned    dpDstScan
    )
{
    BYTE *pjDst, *pjSrc, *pjDstOut, *pjDstScanOut;
    unsigned cy        = (unsigned) pgb->sizlBitmap.cy;
    unsigned cx        = (unsigned) pgb->sizlBitmap.cx;
    BYTE    *pjSrcScan = &(pgb->aj[0]);

    for
    (
      pjDstScanOut = pjDstScan + cy * dpDstScan;
      pjDstScan < pjDstScanOut;
      pjDstScan += dpDstScan, pjSrcScan += dpSrcScan
    )
    {
        pjSrc = pjSrcScan;
        pjDst = pjDstScan;
        for (pjDstOut = pjDst + cx ; pjDst < pjDstOut; pjDst++, pjSrc++)
        {
            if (*pjDst == 0)
            {
                *pjDst = *pjSrc;
            }
            else if (*pjSrc != 0)
            {
                ULONG kR, kG, kB;

                kR = (ULONG)gaOutTable[*pjDst].kR + (ULONG)gaOutTable[*pjSrc].kR;
                kG = (ULONG)gaOutTable[*pjDst].kG + (ULONG)gaOutTable[*pjSrc].kG;
                kB = (ULONG)gaOutTable[*pjDst].kB + (ULONG)gaOutTable[*pjSrc].kB;

                if (kR > CT_SAMPLE_F) {kR = CT_SAMPLE_F;}
                if (kG > CT_SAMPLE_F) {kG = CT_SAMPLE_F;}
                if (kB > CT_SAMPLE_F) {kB = CT_SAMPLE_F;}

                *pjDst = gajStorage1[kB + 7 * kG + 49 * kR];
            }
        }
    }
}


// rasterizer returns unfiltered data in 2,2,2 format for r,g,b

#define GETRED(j)  (((j) >> 4) & 3)
#define GETGRE(j)  (((j) >> 2) & 3)
#define GETBLU(j)  (((j) >> 0) & 3)

#define R_SET(j)   ((j) & 0X30)
#define B_SET(j)   ((j) & 0X03)

#define FL_LEFT_LEAK   1
#define FL_RIGHT_LEAK  2

// because of the color filtering we may need to expand the original bitmap
// by one column of zero pixels on the left and on the right.
// After we perform the color filtering the column of left edge will pick up
// a non-trivial Blue component (color "leak" from the leftmost pixel in the
// original bitmap) while the column on the right edge will pick up the
// nontrivial Red component from the "leakage" of the rightmost pixel in the
// original bitmap. [BodinD]


ULONG ulClearTypeFilter(GLYPHBITS *pgb, GLYPHDATA *pgd, PRFONT prfnt)
{
    ULONG cx = pgb->sizlBitmap.cx;
    ULONG cy = pgb->sizlBitmap.cy;
    BYTE * pCurrentStorageTable = gajStorageTable;

    if ((cx == 1) && (cy == 1) && (pgb->aj[0] == 0))
    {
    // this is a space glyph

        pgb->sizlBitmap.cx = 0;
        pgb->sizlBitmap.cy = 0;
        return CJ_CTGD(0,0);
    }
#if DBG
    {
        ULONG cx1 = (ULONG)(pgd->rclInk.right  - pgd->rclInk.left);
        ULONG cy1 = (ULONG)(pgd->rclInk.bottom - pgd->rclInk.top);

        ASSERTGDI(cx1 == cx, "cx problem\n");
        ASSERTGDI(cy1 == cy, "cy problem\n");
    }
#endif // DBG

    if (prfnt->ppfe->pifi->flInfo & (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH) /* the font is fixed pitch */
        && prfnt->cache.bSmallMetrics /* only for horizontal transform */
        && (prfnt->ppfe->pifi->usWinWeight <= FW_NORMAL) /* normal or thin weight */
        && 
          (   !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Courier New") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Rod") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Rod Transparent") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Fixed Miriam Transparent") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Miriam Fixed") 
           || !_wcsicmp((PWSTR)((BYTE*)prfnt->ppfe->pifi + prfnt->ppfe->pifi->dpwszFamilyName),L"Simplified Arabic Fixed") 
          )
        )
    {
        /* Courier New look too thin with ClearType standard filter, let's use a bloated filter : */
        pCurrentStorageTable = gajStorageTableBloated;
    }


    FLONG flCTBits = 0;
    ULONG cyT = cy;

    for (BYTE *pjScan = pgb->aj; cyT; cyT--, pjScan += cx)
    {
        if (R_SET(pjScan[0]))
            flCTBits |= FL_LEFT_LEAK;

        if (B_SET(pjScan[cx - 1]))
            flCTBits |= FL_RIGHT_LEAK;

        if ((flCTBits & (FL_LEFT_LEAK | FL_RIGHT_LEAK)) == (FL_LEFT_LEAK | FL_RIGHT_LEAK))
            break;
    }

// we need to copy and filter in the same pass for performance reasons,
// we traverse the source backwards, so that we do not overwrite it

    ULONG cxD = cx;

    if (flCTBits & FL_LEFT_LEAK)
        cxD += 1;

    if (flCTBits & FL_RIGHT_LEAK)
        cxD += 1;

    BYTE jP, jT, jN;

    ULONG kBP;          // unfiltered blue count from the previous pixel
    ULONG kRN;          // unfiltered red count from the next pixel
    ULONG kRT, kGT, kBT;   // unfiltered counts from this pixel
    ULONG iStorage;

    BYTE *pjSrcScanEnd;
    BYTE *pjDstScanEnd;

    pjSrcScanEnd = pgb->aj + (cx * cy) - 1;
    pjDstScanEnd = pgb->aj + (cxD * cy) - 1;

    for ( ; pjDstScanEnd > pgb->aj; pjDstScanEnd -= cxD, pjSrcScanEnd -= cx)
    {
        BYTE *pjD1, *pjS1, *pjS0;

        pjD1 = pjDstScanEnd;
        pjS1 = pjSrcScanEnd;
        pjS0 = pjS1 - cx;

    // for the right border pixel jN = 0; jT = 0; jP = *pjS1;
    // therefore:
    //
    // kBP = GETBLU(*pjS1);  // GETBLU(jP);
    // kRN = 0; // GETRED(jN);
    // kRT = 0; // GETRED(jT);
    // kGT = 0; // GETGRE(jT);
    // kBT = 0; // GETBLU(jT);
    //
    // now convert this to a filtered index in the lookup table range
    // this is the trick, filtering and storing is done in one step
    // iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));

        if (flCTBits & FL_RIGHT_LEAK)
        {
            *pjD1-- = pCurrentStorageTable[3 * 3 * 3 * 3 * GETBLU(*pjS1)];
        }

    // initialize the loop in the middle

        for (jN = 0, jT = *pjS1; pjS1 > pjS0; pjS1--, pjD1--, jN = jT, jT = jP)
        {
            jP = (pjS1 == &pjS0[1]) ? 0 : pjS1[-1];

            kBP = GETBLU(jP);
            kRN = GETRED(jN);

            if (kBP || jT || kRN) // must compute, else optimize
            {
                kRT = GETRED(jT);
                kGT = GETGRE(jT);
                kBT = GETBLU(jT);

            // now convert this to a filtered index in the lookup table range
            // this is the trick, filtering and storing is done in one step

                iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));
                *pjD1 = pCurrentStorageTable[iStorage];
            }
            else
            {
                *pjD1 = 0;
            }
        }

    // for the left border pixel jP = 0; jT = 0; jN = pjS0[1];
    // therefore:
    //
    // kBP = 0; // GETBLU(jP);
    // kRN = GETRED(pjS0[1]); // GETRED(jN);
    // kRT = 0; // GETRED(jT);
    // kGT = 0; // GETGRE(jT);
    // kBT = 0; // GETBLU(jT);
    //
    // now convert this to a filtered index in the lookup table range
    // this is the trick, filtering and storing is done in one step
    // iStorage = kRN + 3 * (kBT + 3 * (kGT + 3 * (kRT + 3 * kBP)));
    // i.e. iStorage = kRN, which implies:

        if (flCTBits & FL_LEFT_LEAK)
        {
            *pjD1 = pCurrentStorageTable[ GETRED(pjS0[1]) ];
        }
    }

// fix the size and the origin

    pgb->sizlBitmap.cx = cxD;
    if (flCTBits & FL_LEFT_LEAK)
        pgb->ptlOrigin.x -= 1;

    return CJ_CTGD(cxD, cy);
}




/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   draw_clrt_nf_ntb_o_to_temp_start                                       *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Assembles a cleartype glyph string into a temporary 8bpp right and left*
*   DWORD aligned buffer. This routine assumes a variable pitch font.      *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pGlyphPos  - pointer to an array of cGlyph gray GLYPHPOS structures    *
*   cGlyphs    - count of gray glyphs in array starting at pGlyphPos       *
*   pjDstStart - pointer to a 8bpp buffer where string is to be assembled  *
*                This buffer is DWORD aligned at the left and right        *
*                edges of each scan.                                       *
*   ulLeftEdge - screen coordinate corresponding to the left edge of       *
*                the temporary buffer                                      *
*   lDstDelta  - count of bytes in each scan of the destination buffer     *
*                (this must be a multiple of 4 because the buffer is       *
*                 DWORD aligned on each scan).                             *
*   ulCharInc  - This must be zero.                                        *
*   ulTempTop  - screen coordinate corresponding to the top of the         *
*                destination buffer. This is used to convert the           *
*                glyph positions on the screen to addresses in the         *
*                destination bitmap.                                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

extern "C" VOID draw_clrt_nf_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDstStart,
    ULONG           ulLeftEdge,
    ULONG           lDstDelta,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS     *pgb;        // pointer to current GLYPHBITS
    LONG           x;          // pixel offset of the
                               // left edge of the glyph bitmap
                               // from the left edge of the
                               // output (8-bpp) bitmap
    LONG           y;          // the pixel offset of the top edge
                               // of the glyph bitmap from the top
                               // edge of the output bitmap.
    LONG           cx;         // number of pixels per glyph scan
                               // If non zero then the destination
                               // bitmap is out of alignment with
                               // the source glyph by a one nyble
                               // shift and a single byte of the
                               // source will affect two consecutive
                               // bytes of the destination.
    LONG           cy;
    BYTE          *pjSrc;
    LONG           lDstSkip;
    ULONG          kR;
    ULONG          kG;
    ULONG          kB;
    LONG           i;

    do {
        pgb = pGlyphPos->pgdf->pgb;
        x   = pGlyphPos->ptl.x + pgb->ptlOrigin.x - ulLeftEdge;
        y   = pGlyphPos->ptl.y + pgb->ptlOrigin.y - ulTempTop;

		ASSERTGDI(x >=0,"draw_clrt_nf_ntb_o_to_temp_start x < 0" );
		ASSERTGDI(y >=0,"draw_clrt_nf_ntb_o_to_temp_start y < 0" );


        cy = pgb->sizlBitmap.cy;
        if (cy)
        {
            BYTE *pjDst = pjDstStart + (y * lDstDelta) + x;
            cx = pgb->sizlBitmap.cx;
            lDstSkip = lDstDelta - cx;
            pjSrc = &pgb->aj[0];

            do {
                i = cx;
                do {
                    if (*pjDst == 0)
                    {
                        *pjDst = *pjSrc;
                    }
                    else if (*pjSrc != 0)
                    {
                        kR = (ULONG)gaOutTable[*pjDst].kR + (ULONG)gaOutTable[*pjSrc].kR;
                        kG = (ULONG)gaOutTable[*pjDst].kG + (ULONG)gaOutTable[*pjSrc].kG;
                        kB = (ULONG)gaOutTable[*pjDst].kB + (ULONG)gaOutTable[*pjSrc].kB;

                        if (kR > CT_SAMPLE_F) {kR = CT_SAMPLE_F;}
                        if (kG > CT_SAMPLE_F) {kG = CT_SAMPLE_F;}
                        if (kB > CT_SAMPLE_F) {kB = CT_SAMPLE_F;}

                        *pjDst = gajStorage1[kB + 7 * kG + 49 * kR];
                    }

                    pjDst++;
                    pjSrc++;

                } while (--i != 0);

                pjDst += lDstSkip;

            } while (--cy != 0);
        }

        pGlyphPos++;

    } while (--cGlyphs != 0);
}

/******************************Public*Routine******************************\
*                                                                          *
* Routine Name:                                                            *
*                                                                          *
*   draw_clrt_f_ntb_o_to_temp_start                                        *
*                                                                          *
* Routine Description:                                                     *
*                                                                          *
*   Assembles a cleartype glyph string into a temporary 4bpp right and left*
*   DWORD aligned buffer. This routine assumes a fixed pitch font with     *
*   character increment equal to ulCharInc                                 *
*                                                                          *
* Arguments:                                                               *
*                                                                          *
*   pGlyphPos  - pointer to an array of cGlyph gray GLYPHPOS structures    *
*   cGlyphs    - count of gray glyphs in array starting at pGlyphPos       *
*   pjDst      - pointer to a 8bpp buffer where string is to be assembled  *
*                This buffer is DWORD aligned at the left and right        *
*                edges of each scan.                                       *
*   ulLeftEdge - screen coordinate corresponding to the left edge of       *
*                the temporary buffer                                      *
*   dpDst      - count of bytes in each scan of the destination buffer     *
*                (this must be a multiple of 4 because the buffer is       *
*                 DWORD aligned on each scan).                             *
*   ulCharInc  - must NOT be zero in this case                             *
*   ulTempTop  - screen coordinate corresponding to the top of the         *
*                destination buffer. This is used to convert the           *
*                glyph positions on the screen to addresses in the         *
*                destination bitmap.                                       *
*                                                                          *
* Return Value:                                                            *
*                                                                          *
*   None                                                                   *
*                                                                          *
\**************************************************************************/

extern "C" VOID draw_clrt_f_ntb_o_to_temp_start(
    PGLYPHPOS       pGlyphPos,
    ULONG           cGlyphs,
    PUCHAR          pjDst,
    ULONG           ulLeftEdge,
    ULONG           dpDst,
    ULONG           ulCharInc,
    ULONG           ulTempTop
    )
{
    GLYPHBITS     *pgb;        // pointer to current GLYPHBITS

    int            x;          // x-coordinate of the current
                               // character origin with respect
                               // to the upper left pixel of the
                               // output (4-bpp) bitmap

    int            y;          // y-coordinate of the current
                               // character origin with respect
                               // to the upper left pixel of the
                               // output (4-bpp) bitmap

    unsigned       cx;         // number of pixels per glyph scan
                               // If non zero then the destination
                               // bitmap is out of alignment with
                               // the source glyph by a one nyble
                               // shift and a single byte of the
                               // source will affect two consecutive
                               // bytes of the destination.

    GLYPHPOS      *pgpOut;     // sentinel for loop

    BYTE          *pj;         // pointer into Buffer corresponding
                               // to the upper left pixel of the
                               // current gray glyph

    // (x,y) = position of first CHARACTER ORIGIN with respect to
    //         the upper left pixel of the destination 4bpp bitmap

    x  = pGlyphPos->ptl.x - ulLeftEdge;
    y  = pGlyphPos->ptl.y - ulTempTop;

    for (pgpOut = pGlyphPos + cGlyphs; pGlyphPos < pgpOut; x += ulCharInc, pGlyphPos++)
    {
        int xT, yT; // position of UPPER LEFT pixel of glyph
                    // with respect to the upper left pixel
                    // of the bitmap.

        pgb         = pGlyphPos->pgdf->pgb;
        xT          = x + pgb->ptlOrigin.x;
        yT          = y + pgb->ptlOrigin.y;
        cx          = (unsigned) pgb->sizlBitmap.cx;
        pj          = pjDst + (yT * dpDst) + xT;

        vOrClearTypeGlyph(pgb, cx, pj, dpDst);
    }
}

BYTE ajGammaCT_10[256] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 
0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 
0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 
0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 
0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 
0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 
0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 
0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

BYTE ajGammaCT_11[256] = {
0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 
0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 
0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x10, 0x11, 0x12, 
0x13, 0x14, 0x15, 0x16, 0x16, 0x17, 0x18, 0x19, 
0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x1F, 0x20, 
0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 
0x29, 0x2A, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3E, 
0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 
0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 
0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 
0x77, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x95, 0x96, 0x97, 0x98, 
0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 
0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA9, 
0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 
0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xBA, 
0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 
0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 
0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
0xD4, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 
0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE3, 0xE4, 0xE5, 
0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 
0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 
0xF7, 0xF8, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

BYTE ajGammaInvCT_11[256] = {
0x00, 0x02, 0x03, 0x04, 0x06, 0x07, 0x08, 0x0A, 
0x0B, 0x0C, 0x0D, 0x0F, 0x10, 0x11, 0x12, 0x13, 
0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1D, 
0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x26, 
0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 
0x2F, 0x30, 0x31, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x47, 0x48, 
0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 
0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 
0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 
0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 
0x81, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C, 0x9D, 0x9E, 
0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 
0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 
0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 
0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 
0xBE, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 
0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 
0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 
0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 
0xE3, 0xE4, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 
0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xEF, 0xF0, 
0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 
0xF9, 0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

BYTE ajGammaCT_12[256] = {
 0x00,   0x00,   0x01,   0x01,   0x02,   0x02,   0x03,   0x03,
 0x04,   0x05,   0x05,   0x06,   0x07,   0x07,   0x08,   0x09,
 0x09,   0x0A,   0x0B,   0x0B,   0x0C,   0x0D,   0x0D,   0x0E,
 0x0F,   0x10,   0x10,   0x11,   0x12,   0x13,   0x14,   0x14,
 0x15,   0x16,   0x17,   0x18,   0x18,   0x19,   0x1A,   0x1B,
 0x1C,   0x1C,   0x1D,   0x1E,   0x1F,   0x20,   0x21,   0x22,
 0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x28,
 0x29,   0x2A,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,
 0x31,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,
 0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3E,
 0x3F,   0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,
 0x47,   0x48,   0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,
 0x4F,   0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,
 0x57,   0x58,   0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,
 0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,
 0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,
 0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,
 0x80,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,   0x88,
 0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x90,   0x91,
 0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,
 0x9B,   0x9C,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA5,   0xA6,   0xA7,   0xA8,   0xA9,   0xAA,   0xAB,
 0xAC,   0xAD,   0xAF,   0xB0,   0xB1,   0xB2,   0xB3,   0xB4,
 0xB5,   0xB7,   0xB8,   0xB9,   0xBA,   0xBB,   0xBC,   0xBD,
 0xBF,   0xC0,   0xC1,   0xC2,   0xC3,   0xC4,   0xC5,   0xC7,
 0xC8,   0xC9,   0xCA,   0xCB,   0xCC,   0xCD,   0xCF,   0xD0,
 0xD1,   0xD2,   0xD3,   0xD4,   0xD6,   0xD7,   0xD8,   0xD9,
 0xDA,   0xDB,   0xDD,   0xDE,   0xDF,   0xE0,   0xE1,   0xE2,
 0xE4,   0xE5,   0xE6,   0xE7,   0xE8,   0xEA,   0xEB,   0xEC,
 0xED,   0xEE,   0xEF,   0xF1,   0xF2,   0xF3,   0xF4,   0xF5,
 0xF7,   0xF8,   0xF9,   0xFA,   0xFB,   0xFD,   0xFE,   0xFF
};

BYTE ajGammaInvCT_12[256] = {
 0x00,   0x03,   0x04,   0x06,   0x08,   0x0A,   0x0B,   0x0D,
 0x0E,   0x10,   0x11,   0x13,   0x14,   0x15,   0x17,   0x18,
 0x19,   0x1B,   0x1C,   0x1D,   0x1F,   0x20,   0x21,   0x22,
 0x24,   0x25,   0x26,   0x27,   0x28,   0x2A,   0x2B,   0x2C,
 0x2D,   0x2E,   0x30,   0x31,   0x32,   0x33,   0x34,   0x35,
 0x36,   0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,
 0x3F,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
 0x48,   0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x50,
 0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,
 0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,
 0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,
 0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,   0x6F,   0x70,
 0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,
 0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,   0x80,
 0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,
 0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x8F,
 0x90,   0x91,   0x91,   0x92,   0x93,   0x94,   0x95,   0x96,
 0x97,   0x98,   0x99,   0x9A,   0x9B,   0x9C,   0x9D,   0x9D,
 0x9E,   0x9F,   0xA0,   0xA1,   0xA2,   0xA3,   0xA4,   0xA5,
 0xA6,   0xA7,   0xA8,   0xA8,   0xA9,   0xAA,   0xAB,   0xAC,
 0xAD,   0xAE,   0xAF,   0xB0,   0xB1,   0xB1,   0xB2,   0xB3,
 0xB4,   0xB5,   0xB6,   0xB7,   0xB8,   0xB9,   0xB9,   0xBA,
 0xBB,   0xBC,   0xBD,   0xBE,   0xBF,   0xC0,   0xC1,   0xC1,
 0xC2,   0xC3,   0xC4,   0xC5,   0xC6,   0xC7,   0xC8,   0xC8,
 0xC9,   0xCA,   0xCB,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD2,   0xD3,   0xD4,   0xD5,   0xD5,   0xD6,
 0xD7,   0xD8,   0xD9,   0xDA,   0xDB,   0xDB,   0xDC,   0xDD,
 0xDE,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE3,   0xE4,
 0xE5,   0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xEA,   0xEB,
 0xEC,   0xED,   0xED,   0xEE,   0xEF,   0xF0,   0xF1,   0xF2,
 0xF2,   0xF3,   0xF4,   0xF5,   0xF6,   0xF7,   0xF7,   0xF8,
 0xF9,   0xFA,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFF
};

BYTE ajGammaCT_13[256] = {
0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 
0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 
0x07, 0x08, 0x08, 0x09, 0x09, 0x0A, 0x0B, 0x0B, 
0x0C, 0x0C, 0x0D, 0x0E, 0x0E, 0x0F, 0x10, 0x10, 
0x11, 0x12, 0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 
0x17, 0x18, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1C, 
0x1D, 0x1E, 0x1F, 0x1F, 0x20, 0x21, 0x22, 0x23, 
0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x29, 
0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x2F, 0x30, 
0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 
0x39, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
0x79, 0x7A, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 
0x82, 0x83, 0x84, 0x85, 0x87, 0x88, 0x89, 0x8A, 
0x8B, 0x8C, 0x8D, 0x8F, 0x90, 0x91, 0x92, 0x93, 
0x94, 0x95, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 
0x9D, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA6, 
0xA7, 0xA8, 0xA9, 0xAA, 0xAC, 0xAD, 0xAE, 0xAF, 
0xB0, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB8, 0xB9, 
0xBA, 0xBB, 0xBC, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 
0xC4, 0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 0xCC, 
0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD4, 0xD5, 0xD6, 
0xD7, 0xD9, 0xDA, 0xDB, 0xDC, 0xDE, 0xDF, 0xE0, 
0xE2, 0xE3, 0xE4, 0xE5, 0xE7, 0xE8, 0xE9, 0xEA, 
0xEC, 0xED, 0xEE, 0xF0, 0xF1, 0xF2, 0xF3, 0xF5, 
0xF6, 0xF7, 0xF9, 0xFA, 0xFB, 0xFC, 0xFE, 0xFF
};

BYTE ajGammaInvCT_13[256] = {
0x00, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 
0x12, 0x13, 0x15, 0x17, 0x18, 0x1A, 0x1B, 0x1D, 
0x1E, 0x20, 0x21, 0x23, 0x24, 0x25, 0x27, 0x28, 
0x29, 0x2B, 0x2C, 0x2D, 0x2F, 0x30, 0x31, 0x32, 
0x34, 0x35, 0x36, 0x37, 0x39, 0x3A, 0x3B, 0x3C, 
0x3D, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x60, 0x61, 0x62, 0x63, 0x64, 0x66, 0x67, 0x68, 
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x86, 
0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 
0x8F, 0x90, 0x91, 0x92, 0x92, 0x93, 0x94, 0x95, 
0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9B, 0x9C, 
0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA3, 
0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAA, 
0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB0, 0xB1, 
0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB6, 0xB7, 0xB8, 
0xB9, 0xBA, 0xBB, 0xBC, 0xBC, 0xBD, 0xBE, 0xBF, 
0xC0, 0xC1, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 
0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCB, 0xCC, 
0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 
0xD4, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD8, 0xD9, 
0xDA, 0xDB, 0xDC, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE4, 0xE5, 0xE6, 
0xE7, 0xE8, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xEC, 
0xED, 0xEE, 0xEF, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 
0xF3, 0xF4, 0xF5, 0xF6, 0xF6, 0xF7, 0xF8, 0xF9, 
0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFF 
};

BYTE ajGammaCT_14[256] = {
 0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,   0x02,
 0x02,   0x02,   0x03,   0x03,   0x04,   0x04,   0x04,   0x05,
 0x05,   0x06,   0x06,   0x07,   0x07,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0B,   0x0C,   0x0C,   0x0D,   0x0D,
 0x0E,   0x0F,   0x0F,   0x10,   0x10,   0x11,   0x12,   0x12,
 0x13,   0x14,   0x14,   0x15,   0x16,   0x16,   0x17,   0x18,
 0x19,   0x19,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,
 0x1F,   0x1F,   0x20,   0x21,   0x22,   0x22,   0x23,   0x24,
 0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,   0x2B,
 0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,   0x31,   0x31,
 0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,
 0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,
 0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,
 0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,
 0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,
 0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,
 0x61,   0x62,   0x63,   0x64,   0x65,   0x67,   0x68,   0x69,
 0x6A,   0x6B,   0x6C,   0x6D,   0x6E,   0x6F,   0x70,   0x71,
 0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7A,
 0x7C,   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,   0x84,
 0x85,   0x86,   0x87,   0x88,   0x89,   0x8B,   0x8C,   0x8D,
 0x8E,   0x8F,   0x91,   0x92,   0x93,   0x94,   0x95,   0x97,
 0x98,   0x99,   0x9A,   0x9B,   0x9D,   0x9E,   0x9F,   0xA0,
 0xA1,   0xA3,   0xA4,   0xA5,   0xA6,   0xA8,   0xA9,   0xAA,
 0xAB,   0xAD,   0xAE,   0xAF,   0xB0,   0xB2,   0xB3,   0xB4,
 0xB5,   0xB7,   0xB8,   0xB9,   0xBB,   0xBC,   0xBD,   0xBE,
 0xC0,   0xC1,   0xC2,   0xC4,   0xC5,   0xC6,   0xC8,   0xC9,
 0xCA,   0xCB,   0xCD,   0xCE,   0xCF,   0xD1,   0xD2,   0xD3,
 0xD5,   0xD6,   0xD7,   0xD9,   0xDA,   0xDB,   0xDD,   0xDE,
 0xDF,   0xE1,   0xE2,   0xE3,   0xE5,   0xE6,   0xE8,   0xE9,
 0xEA,   0xEC,   0xED,   0xEE,   0xF0,   0xF1,   0xF2,   0xF4,
 0xF5,   0xF7,   0xF8,   0xF9,   0xFB,   0xFC,   0xFE,   0xFF
};

BYTE ajGammaInvCT_14[256] = {
 0x00,   0x05,   0x08,   0x0B,   0x0D,   0x0F,   0x12,   0x14,
 0x16,   0x17,   0x19,   0x1B,   0x1D,   0x1E,   0x20,   0x22,
 0x23,   0x25,   0x26,   0x28,   0x29,   0x2B,   0x2C,   0x2E,
 0x2F,   0x31,   0x32,   0x33,   0x35,   0x36,   0x37,   0x39,
 0x3A,   0x3B,   0x3C,   0x3E,   0x3F,   0x40,   0x41,   0x43,
 0x44,   0x45,   0x46,   0x48,   0x49,   0x4A,   0x4B,   0x4C,
 0x4D,   0x4E,   0x50,   0x51,   0x52,   0x53,   0x54,   0x55,
 0x56,   0x57,   0x59,   0x5A,   0x5B,   0x5C,   0x5D,   0x5E,
 0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,
 0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,
 0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,
 0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x85,
 0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,
 0x8E,   0x8F,   0x8F,   0x90,   0x91,   0x92,   0x93,   0x94,
 0x95,   0x96,   0x97,   0x97,   0x98,   0x99,   0x9A,   0x9B,
 0x9C,   0x9D,   0x9E,   0x9E,   0x9F,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,   0xA8,   0xA9,
 0xAA,   0xAA,   0xAB,   0xAC,   0xAD,   0xAE,   0xAF,   0xAF,
 0xB0,   0xB1,   0xB2,   0xB3,   0xB4,   0xB4,   0xB5,   0xB6,
 0xB7,   0xB8,   0xB8,   0xB9,   0xBA,   0xBB,   0xBC,   0xBC,
 0xBD,   0xBE,   0xBF,   0xC0,   0xC0,   0xC1,   0xC2,   0xC3,
 0xC4,   0xC4,   0xC5,   0xC6,   0xC7,   0xC8,   0xC8,   0xC9,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,   0xD5,   0xD6,
 0xD6,   0xD7,   0xD8,   0xD9,   0xD9,   0xDA,   0xDB,   0xDC,
 0xDC,   0xDD,   0xDE,   0xDF,   0xDF,   0xE0,   0xE1,   0xE2,
 0xE2,   0xE3,   0xE4,   0xE5,   0xE5,   0xE6,   0xE7,   0xE8,
 0xE8,   0xE9,   0xEA,   0xEB,   0xEB,   0xEC,   0xED,   0xEE,
 0xEE,   0xEF,   0xF0,   0xF1,   0xF1,   0xF2,   0xF3,   0xF3,
 0xF4,   0xF5,   0xF6,   0xF6,   0xF7,   0xF8,   0xF9,   0xF9,
 0xFA,   0xFB,   0xFB,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
};


BYTE ajGammaCT_15[256] = {
   0x00,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,
   0x01,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x04,
   0x04,   0x04,   0x05,   0x05,   0x06,   0x06,   0x06,   0x07,
   0x07,   0x08,   0x08,   0x09,   0x09,   0x0A,   0x0A,   0x0B,
   0x0B,   0x0C,   0x0C,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,
   0x10,   0x10,   0x11,   0x12,   0x12,   0x13,   0x14,   0x14,
   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x19,   0x1A,
   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1F,   0x1F,
   0x20,   0x21,   0x22,   0x22,   0x23,   0x24,   0x25,   0x25,
   0x26,   0x27,   0x28,   0x29,   0x29,   0x2A,   0x2B,   0x2C,
   0x2D,   0x2E,   0x2E,   0x2F,   0x30,   0x31,   0x32,   0x33,
   0x34,   0x35,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3A,
   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41,   0x41,
   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,
   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,
   0x52,   0x53,   0x54,   0x55,   0x56,   0x58,   0x59,   0x5A,
   0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x60,   0x61,   0x62,
   0x63,   0x64,   0x66,   0x67,   0x68,   0x69,   0x6A,   0x6B,
   0x6C,   0x6D,   0x6E,   0x70,   0x71,   0x72,   0x73,   0x74,
   0x75,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7E,
   0x7F,   0x80,   0x81,   0x82,   0x84,   0x85,   0x86,   0x87,
   0x88,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x90,   0x91,
   0x92,   0x93,   0x95,   0x96,   0x97,   0x98,   0x9A,   0x9B,
   0x9C,   0x9E,   0x9F,   0xA0,   0xA1,   0xA3,   0xA4,   0xA5,
   0xA7,   0xA8,   0xA9,   0xAB,   0xAC,   0xAD,   0xAE,   0xB0,
   0xB1,   0xB2,   0xB4,   0xB5,   0xB6,   0xB8,   0xB9,   0xBB,
   0xBC,   0xBD,   0xBF,   0xC0,   0xC1,   0xC3,   0xC4,   0xC5,
   0xC7,   0xC8,   0xCA,   0xCB,   0xCC,   0xCE,   0xCF,   0xD1,
   0xD2,   0xD3,   0xD5,   0xD6,   0xD8,   0xD9,   0xDA,   0xDC,
   0xDD,   0xDF,   0xE0,   0xE2,   0xE3,   0xE4,   0xE6,   0xE7,
   0xE9,   0xEA,   0xEC,   0xED,   0xEF,   0xF0,   0xF2,   0xF3,
   0xF5,   0xF6,   0xF8,   0xF9,   0xFB,   0xFC,   0xFE,   0xFF
};


BYTE ajGammaInvCT_15[256] = {
   0x00,   0x06,   0x0A,   0x0D,   0x10,   0x13,   0x15,   0x17,
   0x19,   0x1B,   0x1D,   0x1F,   0x21,   0x23,   0x25,   0x27,
   0x28,   0x2A,   0x2C,   0x2D,   0x2F,   0x30,   0x32,   0x33,
   0x35,   0x36,   0x38,   0x39,   0x3A,   0x3C,   0x3D,   0x3F,
   0x40,   0x41,   0x43,   0x44,   0x45,   0x46,   0x48,   0x49,
   0x4A,   0x4B,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,
   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5B,   0x5C,
   0x5D,   0x5E,   0x5F,   0x60,   0x61,   0x62,   0x63,   0x64,
   0x65,   0x67,   0x68,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,
   0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,
   0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,
   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,
   0x85,   0x86,   0x87,   0x88,   0x89,   0x8A,   0x8A,   0x8B,
   0x8C,   0x8D,   0x8E,   0x8F,   0x90,   0x91,   0x92,   0x92,
   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,   0x99,
   0x9A,   0x9B,   0x9C,   0x9D,   0x9E,   0x9F,   0x9F,   0xA0,
   0xA1,   0xA2,   0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,
   0xA8,   0xA9,   0xA9,   0xAA,   0xAB,   0xAC,   0xAD,   0xAD,
   0xAE,   0xAF,   0xB0,   0xB1,   0xB1,   0xB2,   0xB3,   0xB4,
   0xB5,   0xB5,   0xB6,   0xB7,   0xB8,   0xB9,   0xB9,   0xBA,
   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBF,   0xC0,   0xC0,
   0xC1,   0xC2,   0xC3,   0xC3,   0xC4,   0xC5,   0xC6,   0xC6,
   0xC7,   0xC8,   0xC9,   0xC9,   0xCA,   0xCB,   0xCC,   0xCC,
   0xCD,   0xCE,   0xCF,   0xCF,   0xD0,   0xD1,   0xD2,   0xD2,
   0xD3,   0xD4,   0xD5,   0xD5,   0xD6,   0xD7,   0xD7,   0xD8,
   0xD9,   0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,   0xDE,
   0xDF,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE3,   0xE4,
   0xE4,   0xE5,   0xE6,   0xE6,   0xE7,   0xE8,   0xE8,   0xE9,
   0xEA,   0xEB,   0xEB,   0xEC,   0xED,   0xED,   0xEE,   0xEF,
   0xEF,   0xF0,   0xF1,   0xF1,   0xF2,   0xF3,   0xF4,   0xF4,
   0xF5,   0xF6,   0xF6,   0xF7,   0xF8,   0xF8,   0xF9,   0xFA,
   0xFA,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
};

BYTE ajGammaCT_16[256] = {
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x01,   0x01,
 0x01,   0x01,   0x01,   0x02,   0x02,   0x02,   0x02,   0x03,
 0x03,   0x03,   0x04,   0x04,   0x04,   0x05,   0x05,   0x05,
 0x06,   0x06,   0x07,   0x07,   0x07,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0B,   0x0B,   0x0C,   0x0C,   0x0D,
 0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10,   0x11,
 0x12,   0x12,   0x13,   0x13,   0x14,   0x15,   0x15,   0x16,
 0x17,   0x17,   0x18,   0x19,   0x19,   0x1A,   0x1B,   0x1B,
 0x1C,   0x1D,   0x1D,   0x1E,   0x1F,   0x1F,   0x20,   0x21,
 0x22,   0x22,   0x23,   0x24,   0x25,   0x26,   0x26,   0x27,
 0x28,   0x29,   0x2A,   0x2A,   0x2B,   0x2C,   0x2D,   0x2E,
 0x2E,   0x2F,   0x30,   0x31,   0x32,   0x33,   0x34,   0x35,
 0x35,   0x36,   0x37,   0x38,   0x39,   0x3A,   0x3B,   0x3C,
 0x3D,   0x3E,   0x3F,   0x40,   0x40,   0x41,   0x42,   0x43,
 0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4A,   0x4B,
 0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,   0x54,
 0x55,   0x56,   0x57,   0x58,   0x59,   0x5A,   0x5B,   0x5C,
 0x5D,   0x5E,   0x5F,   0x61,   0x62,   0x63,   0x64,   0x65,
 0x66,   0x67,   0x68,   0x6A,   0x6B,   0x6C,   0x6D,   0x6E,
 0x6F,   0x71,   0x72,   0x73,   0x74,   0x75,   0x77,   0x78,
 0x79,   0x7A,   0x7B,   0x7D,   0x7E,   0x7F,   0x80,   0x82,
 0x83,   0x84,   0x85,   0x87,   0x88,   0x89,   0x8A,   0x8C,
 0x8D,   0x8E,   0x8F,   0x91,   0x92,   0x93,   0x95,   0x96,
 0x97,   0x99,   0x9A,   0x9B,   0x9D,   0x9E,   0x9F,   0xA1,
 0xA2,   0xA3,   0xA5,   0xA6,   0xA7,   0xA9,   0xAA,   0xAB,
 0xAD,   0xAE,   0xB0,   0xB1,   0xB2,   0xB4,   0xB5,   0xB7,
 0xB8,   0xB9,   0xBB,   0xBC,   0xBE,   0xBF,   0xC1,   0xC2,
 0xC4,   0xC5,   0xC6,   0xC8,   0xC9,   0xCB,   0xCC,   0xCE,
 0xCF,   0xD1,   0xD2,   0xD4,   0xD5,   0xD7,   0xD8,   0xDA,
 0xDB,   0xDD,   0xDE,   0xE0,   0xE1,   0xE3,   0xE4,   0xE6,
 0xE7,   0xE9,   0xEB,   0xEC,   0xEE,   0xEF,   0xF1,   0xF2,
 0xF4,   0xF5,   0xF7,   0xF9,   0xFA,   0xFC,   0xFD,   0xFF
};

BYTE ajGammaInvCT_16[256] = {
 0x00,   0x08,   0x0C,   0x10,   0x13,   0x16,   0x18,   0x1B,
 0x1D,   0x20,   0x22,   0x24,   0x26,   0x28,   0x2A,   0x2B,
 0x2D,   0x2F,   0x31,   0x32,   0x34,   0x36,   0x37,   0x39,
 0x3A,   0x3C,   0x3D,   0x3F,   0x40,   0x42,   0x43,   0x44,
 0x46,   0x47,   0x48,   0x4A,   0x4B,   0x4C,   0x4E,   0x4F,
 0x50,   0x51,   0x53,   0x54,   0x55,   0x56,   0x57,   0x59,
 0x5A,   0x5B,   0x5C,   0x5D,   0x5E,   0x60,   0x61,   0x62,
 0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6A,
 0x6B,   0x6D,   0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,
 0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,
 0x7C,   0x7D,   0x7D,   0x7E,   0x7F,   0x80,   0x81,   0x82,
 0x83,   0x84,   0x85,   0x86,   0x87,   0x88,   0x89,   0x8A,
 0x8A,   0x8B,   0x8C,   0x8D,   0x8E,   0x8F,   0x90,   0x91,
 0x92,   0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,
 0x98,   0x99,   0x9A,   0x9B,   0x9C,   0x9D,   0x9E,   0x9E,
 0x9F,   0xA0,   0xA1,   0xA2,   0xA2,   0xA3,   0xA4,   0xA5,
 0xA6,   0xA7,   0xA7,   0xA8,   0xA9,   0xAA,   0xAB,   0xAB,
 0xAC,   0xAD,   0xAE,   0xAF,   0xAF,   0xB0,   0xB1,   0xB2,
 0xB2,   0xB3,   0xB4,   0xB5,   0xB5,   0xB6,   0xB7,   0xB8,
 0xB9,   0xB9,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,
 0xBF,   0xBF,   0xC0,   0xC1,   0xC2,   0xC2,   0xC3,   0xC4,
 0xC4,   0xC5,   0xC6,   0xC7,   0xC7,   0xC8,   0xC9,   0xCA,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCF,   0xCF,
 0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,   0xD5,
 0xD6,   0xD6,   0xD7,   0xD8,   0xD8,   0xD9,   0xDA,   0xDA,
 0xDB,   0xDC,   0xDC,   0xDD,   0xDE,   0xDE,   0xDF,   0xE0,
 0xE1,   0xE1,   0xE2,   0xE3,   0xE3,   0xE4,   0xE5,   0xE5,
 0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xE9,   0xEA,   0xEB,
 0xEB,   0xEC,   0xEC,   0xED,   0xEE,   0xEE,   0xEF,   0xF0,
 0xF0,   0xF1,   0xF2,   0xF2,   0xF3,   0xF4,   0xF4,   0xF5,
 0xF6,   0xF6,   0xF7,   0xF7,   0xF8,   0xF9,   0xF9,   0xFA,
 0xFB,   0xFB,   0xFC,   0xFC,   0xFD,   0xFE,   0xFE,   0xFF
};

BYTE ajGammaCT_17[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 
0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 
0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 
0x07, 0x08, 0x08, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 0x0E, 
0x0F, 0x0F, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 
0x13, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x18, 
0x18, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 0x1C, 0x1D, 
0x1E, 0x1E, 0x1F, 0x20, 0x21, 0x21, 0x22, 0x23, 
0x24, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 
0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 
0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 
0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 
0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 
0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 
0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x69, 
0x6A, 0x6B, 0x6C, 0x6D, 0x6F, 0x70, 0x71, 0x72, 
0x73, 0x75, 0x76, 0x77, 0x78, 0x7A, 0x7B, 0x7C, 
0x7D, 0x7F, 0x80, 0x81, 0x83, 0x84, 0x85, 0x86, 
0x88, 0x89, 0x8A, 0x8C, 0x8D, 0x8E, 0x90, 0x91, 
0x92, 0x94, 0x95, 0x97, 0x98, 0x99, 0x9B, 0x9C, 
0x9D, 0x9F, 0xA0, 0xA2, 0xA3, 0xA4, 0xA6, 0xA7, 
0xA9, 0xAA, 0xAC, 0xAD, 0xAE, 0xB0, 0xB1, 0xB3, 
0xB4, 0xB6, 0xB7, 0xB9, 0xBA, 0xBC, 0xBD, 0xBF, 
0xC0, 0xC2, 0xC3, 0xC5, 0xC6, 0xC8, 0xC9, 0xCB, 
0xCD, 0xCE, 0xD0, 0xD1, 0xD3, 0xD4, 0xD6, 0xD8, 
0xD9, 0xDB, 0xDC, 0xDE, 0xE0, 0xE1, 0xE3, 0xE4, 
0xE6, 0xE8, 0xE9, 0xEB, 0xED, 0xEE, 0xF0, 0xF2, 
0xF3, 0xF5, 0xF7, 0xF8, 0xFA, 0xFC, 0xFD, 0xFF
};

BYTE ajGammaInvCT_17[256] = {
0x00, 0x0A, 0x0F, 0x13, 0x16, 0x19, 0x1C, 0x1F, 
0x21, 0x24, 0x26, 0x28, 0x2A, 0x2C, 0x2E, 0x30, 
0x32, 0x34, 0x36, 0x37, 0x39, 0x3B, 0x3C, 0x3E, 
0x40, 0x41, 0x43, 0x44, 0x46, 0x47, 0x48, 0x4A, 
0x4B, 0x4D, 0x4E, 0x4F, 0x51, 0x52, 0x53, 0x54, 
0x56, 0x57, 0x58, 0x59, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 
0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 
0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 
0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C, 
0x9D, 0x9E, 0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3, 
0xA4, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA8, 0xA9, 
0xAA, 0xAB, 0xAC, 0xAC, 0xAD, 0xAE, 0xAF, 0xAF, 
0xB0, 0xB1, 0xB2, 0xB2, 0xB3, 0xB4, 0xB5, 0xB5, 
0xB6, 0xB7, 0xB8, 0xB8, 0xB9, 0xBA, 0xBB, 0xBB, 
0xBC, 0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 
0xC2, 0xC3, 0xC3, 0xC4, 0xC5, 0xC5, 0xC6, 0xC7, 
0xC7, 0xC8, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC, 0xCC, 
0xCD, 0xCE, 0xCE, 0xCF, 0xD0, 0xD0, 0xD1, 0xD2, 
0xD2, 0xD3, 0xD4, 0xD4, 0xD5, 0xD6, 0xD6, 0xD7, 
0xD8, 0xD8, 0xD9, 0xDA, 0xDA, 0xDB, 0xDC, 0xDC, 
0xDD, 0xDE, 0xDE, 0xDF, 0xE0, 0xE0, 0xE1, 0xE2, 
0xE2, 0xE3, 0xE3, 0xE4, 0xE5, 0xE5, 0xE6, 0xE7, 
0xE7, 0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 0xEC, 
0xEC, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 0xF0, 0xF1, 
0xF1, 0xF2, 0xF2, 0xF3, 0xF4, 0xF4, 0xF5, 0xF5, 
0xF6, 0xF7, 0xF7, 0xF8, 0xF8, 0xF9, 0xFA, 0xFA, 
0xFB, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF 
};

// 1.8 gamma tables, we use these as default for now

BYTE ajGammaCT_18[256] = {
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,
 0x01,   0x01,   0x01,   0x01,   0x01,   0x01,   0x01,   0x02,
 0x02,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x03,
 0x04,   0x04,   0x04,   0x04,   0x05,   0x05,   0x05,   0x06,
 0x06,   0x06,   0x07,   0x07,   0x08,   0x08,   0x08,   0x09,
 0x09,   0x0A,   0x0A,   0x0A,   0x0B,   0x0B,   0x0C,   0x0C,
 0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10,
 0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,   0x15,
 0x15,   0x16,   0x16,   0x17,   0x18,   0x18,   0x19,   0x1A,
 0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1E,   0x1F,
 0x20,   0x20,   0x21,   0x22,   0x23,   0x23,   0x24,   0x25,
 0x26,   0x26,   0x27,   0x28,   0x29,   0x29,   0x2A,   0x2B,
 0x2C,   0x2D,   0x2E,   0x2E,   0x2F,   0x30,   0x31,   0x32,
 0x33,   0x34,   0x35,   0x35,   0x36,   0x37,   0x38,   0x39,
 0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41,
 0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,
 0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,   0x51,
 0x52,   0x53,   0x54,   0x56,   0x57,   0x58,   0x59,   0x5A,
 0x5B,   0x5C,   0x5D,   0x5F,   0x60,   0x61,   0x62,   0x63,
 0x64,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6E,   0x6F,   0x71,   0x72,   0x73,   0x74,   0x76,   0x77,
 0x78,   0x7A,   0x7B,   0x7C,   0x7E,   0x7F,   0x80,   0x81,
 0x83,   0x84,   0x86,   0x87,   0x88,   0x8A,   0x8B,   0x8C,
 0x8E,   0x8F,   0x91,   0x92,   0x93,   0x95,   0x96,   0x98,
 0x99,   0x9A,   0x9C,   0x9D,   0x9F,   0xA0,   0xA2,   0xA3,
 0xA5,   0xA6,   0xA8,   0xA9,   0xAB,   0xAC,   0xAE,   0xAF,
 0xB1,   0xB2,   0xB4,   0xB5,   0xB7,   0xB8,   0xBA,   0xBC,
 0xBD,   0xBF,   0xC0,   0xC2,   0xC3,   0xC5,   0xC7,   0xC8,
 0xCA,   0xCC,   0xCD,   0xCF,   0xD0,   0xD2,   0xD4,   0xD5,
 0xD7,   0xD9,   0xDA,   0xDC,   0xDE,   0xE0,   0xE1,   0xE3,
 0xE5,   0xE6,   0xE8,   0xEA,   0xEC,   0xED,   0xEF,   0xF1,
 0xF3,   0xF4,   0xF6,   0xF8,   0xFA,   0xFB,   0xFD,   0xFF
};

BYTE ajGammaInvCT_18[256] = {
 0x00,   0x0C,   0x11,   0x16,   0x19,   0x1D,   0x20,   0x23,
 0x25,   0x28,   0x2A,   0x2C,   0x2F,   0x31,   0x33,   0x35,
 0x37,   0x39,   0x3A,   0x3C,   0x3E,   0x40,   0x41,   0x43,
 0x45,   0x46,   0x48,   0x49,   0x4B,   0x4C,   0x4E,   0x4F,
 0x50,   0x52,   0x53,   0x55,   0x56,   0x57,   0x59,   0x5A,
 0x5B,   0x5C,   0x5E,   0x5F,   0x60,   0x61,   0x62,   0x64,
 0x65,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6E,   0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,
 0x76,   0x77,   0x78,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,
 0x7E,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85,
 0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8B,   0x8C,
 0x8D,   0x8E,   0x8F,   0x90,   0x91,   0x92,   0x92,   0x93,
 0x94,   0x95,   0x96,   0x97,   0x98,   0x98,   0x99,   0x9A,
 0x9B,   0x9C,   0x9D,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,
 0xA1,   0xA2,   0xA3,   0xA4,   0xA5,   0xA5,   0xA6,   0xA7,
 0xA8,   0xA9,   0xA9,   0xAA,   0xAB,   0xAC,   0xAC,   0xAD,
 0xAE,   0xAF,   0xAF,   0xB0,   0xB1,   0xB2,   0xB2,   0xB3,
 0xB4,   0xB5,   0xB5,   0xB6,   0xB7,   0xB7,   0xB8,   0xB9,
 0xBA,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBF,
 0xBF,   0xC0,   0xC1,   0xC1,   0xC2,   0xC3,   0xC3,   0xC4,
 0xC5,   0xC6,   0xC6,   0xC7,   0xC8,   0xC8,   0xC9,   0xCA,
 0xCA,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCE,   0xCF,
 0xD0,   0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,   0xD4,
 0xD5,   0xD5,   0xD6,   0xD7,   0xD7,   0xD8,   0xD9,   0xD9,
 0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,   0xDE,   0xDE,
 0xDF,   0xDF,   0xE0,   0xE1,   0xE1,   0xE2,   0xE2,   0xE3,
 0xE4,   0xE4,   0xE5,   0xE6,   0xE6,   0xE7,   0xE7,   0xE8,
 0xE9,   0xE9,   0xEA,   0xEA,   0xEB,   0xEC,   0xEC,   0xED,
 0xED,   0xEE,   0xEE,   0xEF,   0xF0,   0xF0,   0xF1,   0xF1,
 0xF2,   0xF3,   0xF3,   0xF4,   0xF4,   0xF5,   0xF5,   0xF6,
 0xF7,   0xF7,   0xF8,   0xF8,   0xF9,   0xF9,   0xFA,   0xFB,
 0xFB,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF
};

BYTE ajGammaCT_19[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 
0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 
0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 
0x0E, 0x0F, 0x0F, 0x10, 0x10, 0x11, 0x11, 0x12, 
0x12, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 
0x17, 0x18, 0x18, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 
0x1C, 0x1D, 0x1E, 0x1E, 0x1F, 0x20, 0x20, 0x21, 
0x22, 0x23, 0x23, 0x24, 0x25, 0x26, 0x26, 0x27, 
0x28, 0x29, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 
0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 
0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 
0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 
0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 
0x4D, 0x4E, 0x4F, 0x51, 0x52, 0x53, 0x54, 0x55, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 
0x5F, 0x61, 0x62, 0x63, 0x64, 0x65, 0x67, 0x68, 
0x69, 0x6A, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72, 
0x73, 0x75, 0x76, 0x77, 0x79, 0x7A, 0x7B, 0x7D, 
0x7E, 0x7F, 0x81, 0x82, 0x84, 0x85, 0x86, 0x88, 
0x89, 0x8B, 0x8C, 0x8D, 0x8F, 0x90, 0x92, 0x93, 
0x95, 0x96, 0x98, 0x99, 0x9B, 0x9C, 0x9E, 0x9F, 
0xA1, 0xA2, 0xA4, 0xA5, 0xA7, 0xA8, 0xAA, 0xAC, 
0xAD, 0xAF, 0xB0, 0xB2, 0xB4, 0xB5, 0xB7, 0xB8, 
0xBA, 0xBC, 0xBD, 0xBF, 0xC1, 0xC2, 0xC4, 0xC6, 
0xC7, 0xC9, 0xCB, 0xCC, 0xCE, 0xD0, 0xD2, 0xD3, 
0xD5, 0xD7, 0xD9, 0xDA, 0xDC, 0xDE, 0xE0, 0xE1, 
0xE3, 0xE5, 0xE7, 0xE9, 0xEB, 0xEC, 0xEE, 0xF0, 
0xF2, 0xF4, 0xF6, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF
};

BYTE ajGammaInvCT_19[256] = {
0x00, 0x0E, 0x14, 0x19, 0x1D, 0x20, 0x23, 0x26, 
0x29, 0x2C, 0x2E, 0x31, 0x33, 0x35, 0x37, 0x39, 
0x3B, 0x3D, 0x3F, 0x41, 0x43, 0x45, 0x46, 0x48, 
0x4A, 0x4B, 0x4D, 0x4E, 0x50, 0x51, 0x53, 0x54, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5E, 0x5F, 
0x60, 0x61, 0x63, 0x64, 0x65, 0x66, 0x68, 0x69, 
0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72, 
0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 
0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 
0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 
0x8B, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 
0x92, 0x93, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 
0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9D, 0x9E, 
0x9F, 0xA0, 0xA1, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 
0xA5, 0xA6, 0xA7, 0xA8, 0xA8, 0xA9, 0xAA, 0xAB, 
0xAB, 0xAC, 0xAD, 0xAE, 0xAE, 0xAF, 0xB0, 0xB1, 
0xB1, 0xB2, 0xB3, 0xB4, 0xB4, 0xB5, 0xB6, 0xB6, 
0xB7, 0xB8, 0xB9, 0xB9, 0xBA, 0xBB, 0xBB, 0xBC, 
0xBD, 0xBD, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 0xC2, 
0xC2, 0xC3, 0xC4, 0xC4, 0xC5, 0xC6, 0xC6, 0xC7, 
0xC8, 0xC8, 0xC9, 0xC9, 0xCA, 0xCB, 0xCB, 0xCC, 
0xCD, 0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD1, 
0xD2, 0xD2, 0xD3, 0xD4, 0xD4, 0xD5, 0xD6, 0xD6, 
0xD7, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 0xDA, 0xDB, 
0xDC, 0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xDF, 0xE0, 
0xE0, 0xE1, 0xE2, 0xE2, 0xE3, 0xE3, 0xE4, 0xE4, 
0xE5, 0xE6, 0xE6, 0xE7, 0xE7, 0xE8, 0xE9, 0xE9, 
0xEA, 0xEA, 0xEB, 0xEB, 0xEC, 0xEC, 0xED, 0xEE, 
0xEE, 0xEF, 0xEF, 0xF0, 0xF0, 0xF1, 0xF2, 0xF2, 
0xF3, 0xF3, 0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 
0xF7, 0xF8, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 
0xFB, 0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF
};

BYTE ajGammaCT_20[256] = {
 0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,
 0x00,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,
 0x01,   0x01,   0x01,   0x01,   0x02,   0x02,   0x02,   0x02,
 0x02,   0x02,   0x03,   0x03,   0x03,   0x03,   0x04,   0x04,
 0x04,   0x04,   0x05,   0x05,   0x05,   0x05,   0x06,   0x06,
 0x06,   0x07,   0x07,   0x07,   0x08,   0x08,   0x08,   0x09,
 0x09,   0x09,   0x0A,   0x0A,   0x0B,   0x0B,   0x0B,   0x0C,
 0x0C,   0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,
 0x10,   0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,
 0x14,   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x18,
 0x19,   0x1A,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,
 0x1E,   0x1F,   0x20,   0x20,   0x21,   0x22,   0x23,   0x23,
 0x24,   0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,
 0x2A,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x2F,   0x30,
 0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,
 0x38,   0x39,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,
 0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,
 0x49,   0x4A,   0x4B,   0x4C,   0x4D,   0x4E,   0x4F,   0x50,
 0x51,   0x52,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,
 0x5B,   0x5C,   0x5D,   0x5E,   0x5F,   0x61,   0x62,   0x63,
 0x64,   0x66,   0x67,   0x68,   0x69,   0x6B,   0x6C,   0x6D,
 0x6F,   0x70,   0x71,   0x73,   0x74,   0x75,   0x77,   0x78,
 0x79,   0x7B,   0x7C,   0x7E,   0x7F,   0x80,   0x82,   0x83,
 0x85,   0x86,   0x88,   0x89,   0x8B,   0x8C,   0x8E,   0x8F,
 0x91,   0x92,   0x94,   0x95,   0x97,   0x98,   0x9A,   0x9B,
 0x9D,   0x9E,   0xA0,   0xA2,   0xA3,   0xA5,   0xA6,   0xA8,
 0xAA,   0xAB,   0xAD,   0xAF,   0xB0,   0xB2,   0xB4,   0xB5,
 0xB7,   0xB9,   0xBA,   0xBC,   0xBE,   0xC0,   0xC1,   0xC3,
 0xC5,   0xC7,   0xC8,   0xCA,   0xCC,   0xCE,   0xCF,   0xD1,
 0xD3,   0xD5,   0xD7,   0xD9,   0xDA,   0xDC,   0xDE,   0xE0,
 0xE2,   0xE4,   0xE6,   0xE8,   0xE9,   0xEB,   0xED,   0xEF,
 0xF1,   0xF3,   0xF5,   0xF7,   0xF9,   0xFB,   0xFD,   0xFF
};



BYTE ajGammaInvCT_20[256] = {
 0x00,   0x10,   0x17,   0x1C,   0x20,   0x24,   0x27,   0x2A,
 0x2D,   0x30,   0x32,   0x35,   0x37,   0x3A,   0x3C,   0x3E,
 0x40,   0x42,   0x44,   0x46,   0x47,   0x49,   0x4B,   0x4D,
 0x4E,   0x50,   0x51,   0x53,   0x54,   0x56,   0x57,   0x59,
 0x5A,   0x5C,   0x5D,   0x5E,   0x60,   0x61,   0x62,   0x64,
 0x65,   0x66,   0x67,   0x69,   0x6A,   0x6B,   0x6C,   0x6D,
 0x6F,   0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,
 0x77,   0x79,   0x7A,   0x7B,   0x7C,   0x7D,   0x7E,   0x7F,
 0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,
 0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8D,   0x8E,
 0x8F,   0x90,   0x91,   0x91,   0x92,   0x93,   0x94,   0x95,
 0x96,   0x97,   0x97,   0x98,   0x99,   0x9A,   0x9B,   0x9C,
 0x9C,   0x9D,   0x9E,   0x9F,   0xA0,   0xA0,   0xA1,   0xA2,
 0xA3,   0xA4,   0xA4,   0xA5,   0xA6,   0xA7,   0xA7,   0xA8,
 0xA9,   0xAA,   0xAA,   0xAB,   0xAC,   0xAD,   0xAD,   0xAE,
 0xAF,   0xB0,   0xB0,   0xB1,   0xB2,   0xB3,   0xB3,   0xB4,
 0xB5,   0xB5,   0xB6,   0xB7,   0xB7,   0xB8,   0xB9,   0xBA,
 0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBE,   0xBE,   0xBF,
 0xC0,   0xC0,   0xC1,   0xC2,   0xC2,   0xC3,   0xC4,   0xC4,
 0xC5,   0xC6,   0xC6,   0xC7,   0xC7,   0xC8,   0xC9,   0xC9,
 0xCA,   0xCB,   0xCB,   0xCC,   0xCC,   0xCD,   0xCE,   0xCE,
 0xCF,   0xD0,   0xD0,   0xD1,   0xD1,   0xD2,   0xD3,   0xD3,
 0xD4,   0xD4,   0xD5,   0xD6,   0xD6,   0xD7,   0xD7,   0xD8,
 0xD9,   0xD9,   0xDA,   0xDA,   0xDB,   0xDC,   0xDC,   0xDD,
 0xDD,   0xDE,   0xDE,   0xDF,   0xE0,   0xE0,   0xE1,   0xE1,
 0xE2,   0xE2,   0xE3,   0xE4,   0xE4,   0xE5,   0xE5,   0xE6,
 0xE6,   0xE7,   0xE7,   0xE8,   0xE9,   0xE9,   0xEA,   0xEA,
 0xEB,   0xEB,   0xEC,   0xEC,   0xED,   0xED,   0xEE,   0xEE,
 0xEF,   0xF0,   0xF0,   0xF1,   0xF1,   0xF2,   0xF2,   0xF3,
 0xF3,   0xF4,   0xF4,   0xF5,   0xF5,   0xF6,   0xF6,   0xF7,
 0xF7,   0xF8,   0xF8,   0xF9,   0xF9,   0xFA,   0xFA,   0xFB,
 0xFB,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF
};

BYTE ajGammaCT_21[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 
0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 
0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 
0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 
0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0A, 0x0A, 
0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0D, 0x0D, 0x0E, 
0x0E, 0x0E, 0x0F, 0x0F, 0x10, 0x10, 0x11, 0x11, 
0x12, 0x12, 0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 
0x16, 0x17, 0x18, 0x18, 0x19, 0x19, 0x1A, 0x1B, 
0x1B, 0x1C, 0x1D, 0x1D, 0x1E, 0x1F, 0x1F, 0x20, 
0x21, 0x21, 0x22, 0x23, 0x24, 0x24, 0x25, 0x26, 
0x27, 0x28, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2C, 
0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x33, 
0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 
0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 
0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4B, 0x4C, 
0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x53, 0x54, 0x55, 
0x56, 0x57, 0x58, 0x5A, 0x5B, 0x5C, 0x5D, 0x5F, 
0x60, 0x61, 0x62, 0x64, 0x65, 0x66, 0x68, 0x69, 
0x6A, 0x6B, 0x6D, 0x6E, 0x70, 0x71, 0x72, 0x74, 
0x75, 0x76, 0x78, 0x79, 0x7B, 0x7C, 0x7E, 0x7F, 
0x81, 0x82, 0x83, 0x85, 0x86, 0x88, 0x89, 0x8B, 
0x8D, 0x8E, 0x90, 0x91, 0x93, 0x94, 0x96, 0x97, 
0x99, 0x9B, 0x9C, 0x9E, 0xA0, 0xA1, 0xA3, 0xA5, 
0xA6, 0xA8, 0xAA, 0xAB, 0xAD, 0xAF, 0xB0, 0xB2, 
0xB4, 0xB6, 0xB7, 0xB9, 0xBB, 0xBD, 0xBF, 0xC0, 
0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCB, 0xCD, 0xCF, 
0xD1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDB, 0xDD, 0xDF, 
0xE1, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 
0xF1, 0xF3, 0xF5, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF
};

BYTE ajGammaInvCT_21[256] = {
0x00, 0x12, 0x19, 0x1F, 0x23, 0x27, 0x2B, 0x2E, 
0x31, 0x34, 0x37, 0x39, 0x3B, 0x3E, 0x40, 0x42, 
0x44, 0x46, 0x48, 0x4A, 0x4C, 0x4E, 0x4F, 0x51, 
0x53, 0x54, 0x56, 0x58, 0x59, 0x5B, 0x5C, 0x5D, 
0x5F, 0x60, 0x62, 0x63, 0x64, 0x66, 0x67, 0x68, 
0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x70, 0x71, 0x72, 
0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7A, 0x7B, 
0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 
0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 
0x8C, 0x8D, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 
0x93, 0x94, 0x95, 0x95, 0x96, 0x97, 0x98, 0x99, 
0x9A, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0x9F, 
0xA0, 0xA1, 0xA2, 0xA3, 0xA3, 0xA4, 0xA5, 0xA6, 
0xA6, 0xA7, 0xA8, 0xA9, 0xA9, 0xAA, 0xAB, 0xAC, 
0xAC, 0xAD, 0xAE, 0xAF, 0xAF, 0xB0, 0xB1, 0xB1, 
0xB2, 0xB3, 0xB4, 0xB4, 0xB5, 0xB6, 0xB6, 0xB7, 
0xB8, 0xB8, 0xB9, 0xBA, 0xBA, 0xBB, 0xBC, 0xBC, 
0xBD, 0xBE, 0xBE, 0xBF, 0xC0, 0xC0, 0xC1, 0xC2, 
0xC2, 0xC3, 0xC4, 0xC4, 0xC5, 0xC5, 0xC6, 0xC7, 
0xC7, 0xC8, 0xC9, 0xC9, 0xCA, 0xCA, 0xCB, 0xCC, 
0xCC, 0xCD, 0xCD, 0xCE, 0xCF, 0xCF, 0xD0, 0xD0, 
0xD1, 0xD2, 0xD2, 0xD3, 0xD3, 0xD4, 0xD5, 0xD5, 
0xD6, 0xD6, 0xD7, 0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 
0xDA, 0xDB, 0xDB, 0xDC, 0xDD, 0xDD, 0xDE, 0xDE, 
0xDF, 0xDF, 0xE0, 0xE0, 0xE1, 0xE2, 0xE2, 0xE3, 
0xE3, 0xE4, 0xE4, 0xE5, 0xE5, 0xE6, 0xE6, 0xE7, 
0xE7, 0xE8, 0xE8, 0xE9, 0xEA, 0xEA, 0xEB, 0xEB, 
0xEC, 0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 
0xF0, 0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 0xF3, 
0xF4, 0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xF7, 0xF7, 
0xF8, 0xF8, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB, 
0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF
};

BYTE ajGammaCT_22[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 
0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 
0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 
0x09, 0x09, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0C, 
0x0C, 0x0D, 0x0D, 0x0D, 0x0E, 0x0E, 0x0F, 0x0F, 
0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 
0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17, 0x18, 
0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1C, 0x1C, 0x1D, 
0x1E, 0x1E, 0x1F, 0x20, 0x21, 0x21, 0x22, 0x23, 
0x23, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 
0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 
0x31, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x51, 
0x52, 0x53, 0x54, 0x55, 0x57, 0x58, 0x59, 0x5A, 
0x5B, 0x5D, 0x5E, 0x5F, 0x61, 0x62, 0x63, 0x64, 
0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6D, 0x6E, 0x6F, 
0x71, 0x72, 0x74, 0x75, 0x77, 0x78, 0x79, 0x7B, 
0x7C, 0x7E, 0x7F, 0x81, 0x82, 0x84, 0x85, 0x87, 
0x89, 0x8A, 0x8C, 0x8D, 0x8F, 0x91, 0x92, 0x94, 
0x95, 0x97, 0x99, 0x9A, 0x9C, 0x9E, 0x9F, 0xA1, 
0xA3, 0xA5, 0xA6, 0xA8, 0xAA, 0xAC, 0xAD, 0xAF, 
0xB1, 0xB3, 0xB5, 0xB6, 0xB8, 0xBA, 0xBC, 0xBE, 
0xC0, 0xC2, 0xC4, 0xC5, 0xC7, 0xC9, 0xCB, 0xCD, 
0xCF, 0xD1, 0xD3, 0xD5, 0xD7, 0xD9, 0xDB, 0xDD, 
0xDF, 0xE1, 0xE3, 0xE5, 0xE7, 0xEA, 0xEC, 0xEE, 
0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFB, 0xFD, 0xFF 
};

BYTE ajGammaInvCT_22[256] = {
0x00, 0x15, 0x1C, 0x22, 0x27, 0x2B, 0x2E, 0x32, 
0x35, 0x38, 0x3B, 0x3D, 0x40, 0x42, 0x44, 0x46, 
0x48, 0x4A, 0x4C, 0x4E, 0x50, 0x52, 0x54, 0x55, 
0x57, 0x59, 0x5A, 0x5C, 0x5D, 0x5F, 0x60, 0x62, 
0x63, 0x65, 0x66, 0x67, 0x69, 0x6A, 0x6B, 0x6D, 
0x6E, 0x6F, 0x70, 0x72, 0x73, 0x74, 0x75, 0x76, 
0x77, 0x78, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 
0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 
0x90, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 
0x97, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9C, 
0x9D, 0x9E, 0x9F, 0xA0, 0xA0, 0xA1, 0xA2, 0xA3, 
0xA4, 0xA4, 0xA5, 0xA6, 0xA7, 0xA7, 0xA8, 0xA9, 
0xAA, 0xAA, 0xAB, 0xAC, 0xAD, 0xAD, 0xAE, 0xAF, 
0xAF, 0xB0, 0xB1, 0xB2, 0xB2, 0xB3, 0xB4, 0xB4, 
0xB5, 0xB6, 0xB6, 0xB7, 0xB8, 0xB8, 0xB9, 0xBA, 
0xBA, 0xBB, 0xBC, 0xBC, 0xBD, 0xBE, 0xBE, 0xBF, 
0xC0, 0xC0, 0xC1, 0xC2, 0xC2, 0xC3, 0xC3, 0xC4, 
0xC5, 0xC5, 0xC6, 0xC7, 0xC7, 0xC8, 0xC8, 0xC9, 
0xCA, 0xCA, 0xCB, 0xCB, 0xCC, 0xCD, 0xCD, 0xCE, 
0xCE, 0xCF, 0xCF, 0xD0, 0xD1, 0xD1, 0xD2, 0xD2, 
0xD3, 0xD4, 0xD4, 0xD5, 0xD5, 0xD6, 0xD6, 0xD7, 
0xD7, 0xD8, 0xD9, 0xD9, 0xDA, 0xDA, 0xDB, 0xDB, 
0xDC, 0xDC, 0xDD, 0xDD, 0xDE, 0xDF, 0xDF, 0xE0, 
0xE0, 0xE1, 0xE1, 0xE2, 0xE2, 0xE3, 0xE3, 0xE4, 
0xE4, 0xE5, 0xE5, 0xE6, 0xE6, 0xE7, 0xE7, 0xE8, 
0xE8, 0xE9, 0xE9, 0xEA, 0xEA, 0xEB, 0xEB, 0xEC, 
0xEC, 0xED, 0xED, 0xEE, 0xEE, 0xEF, 0xEF, 0xF0, 
0xF0, 0xF1, 0xF1, 0xF2, 0xF2, 0xF3, 0xF3, 0xF4, 
0xF4, 0xF5, 0xF5, 0xF6, 0xF6, 0xF7, 0xF7, 0xF8, 
0xF8, 0xF9, 0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB, 
0xFC, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 0xFF, 0xFF
};

VOID vGetBlendInfo (
    ULONG size, SURFACE *pS,            // input
    ULONG uF,                           // foreground color
    BLENDINFO  *pbi                     // output
)
{
    BLENDINFO  bi; // local for faster reference

    XEPALOBJ xpo;

    PDEVOBJ pdo(pS->hdev());

    if(pS->pPal == NULL)
    {
        xpo.ppalSet(pdo.ppalSurf());
    }
    else
    {
        xpo.ppalSet(pS->pPal);
    }

    ASSERTGDI(xpo.bValid(),      "Invalid XEPALOBJ" );

    if (xpo.bIsBitfields())
    {
        bi.flRed = xpo.flRed();
        bi.flGre = xpo.flGre();
        bi.flBlu = xpo.flBlu();

        bi.iRedR = (int) (xpo.cRedRight() + xpo.cRedMiddle() - 8);
        bi.iGreR = (int) (xpo.cGreRight() + xpo.cGreMiddle() - 8);
        bi.iBluR = (int) (xpo.cBluRight() + xpo.cBluMiddle() - 8);
    }
    else
    {
        int cBits;
        ULONG flBits;

        if (size == sizeof(USHORT))
        {
            // assumes standard RGB is 5+5+5 for 16-bit color
            cBits = 5;
            flBits = 0x1f;
        }
        else
        {
            cBits = 8;
            flBits = 0xff;
        }
        if (xpo.bIsRGB())
        {
            bi.flRed = flBits;
            bi.flGre = bi.flRed << cBits;
            bi.flBlu = bi.flGre << cBits;

            bi.iRedR = cBits - 8;
            bi.iGreR = bi.iRedR + cBits;
            bi.iBluR = bi.iGreR + cBits;
        }
        else if (xpo.bIsBGR())
        {
            bi.flBlu = flBits;
            bi.flGre = bi.flBlu << cBits;
            bi.flRed = bi.flGre << cBits;

            bi.iBluR = cBits - 8;
            bi.iGreR = bi.iBluR + cBits;
            bi.iRedR = bi.iGreR + cBits;
        }
        else
        {
            RIP("Palette format not supported\n");
        }
    }

/***************************************************************
*                                                              *
*    Now I shall calculate the shift numbers.                  *
*                                                              *
*    I shall explain the shift numbers for the red channel.    *
*    The green and blue channels are treated in the same way.  *
*                                                              *
*    I want to shift the red bits of the red channel colors    *
*    so that the most significant bit of the red channel       *
*    bits corresponds to a value of 2^7. This means that       *
*    if I mask off all of the other color bits, then I         *
*    will end up with a number between zero and 255. This      *
*    process of going to the 0 .. 255 range looks like         *
*                                                              *
*        ((color & flRed) << iRedL) >> iRedR                   *
*                                                              *
*    Only one of iRedL or iRedR is non zero.                   *
*                                                              *
*    I then use this number to index into a 256 element        *
*    gamma correction table. The gamma correction table        *
*    elements are BYTE values that are in the range 0 .. 255.  *
*                                                              *
***************************************************************/

    bi.iRedL = 0;
    if (bi.iRedR < 0)
    {
        bi.iRedL = - bi.iRedR;
        bi.iRedR = 0;
    }

    bi.iGreL = 0;
    if (bi.iGreR < 0)
    {
        bi.iGreL = - bi.iGreR;
        bi.iGreR = 0;
    }

    bi.iBluL = 0;
    if (bi.iBluR < 0)
    {
        bi.iBluL = - bi.iBluR;
        bi.iBluR = 0;
    }

// set gamma, default value is 1.5, a bit low to ensure contrast for thin fonts
// from the color point of view 1.8 might be better

    ULONG ulGamma;

    if (gulGamma != DEFAULT_CT_CONTRAST)
    {
        ulGamma = gulGamma; // overridden via registry or debugger
    }
    else
    {
        ulGamma = pdo.ulGamma();
        if (ulGamma == 0)         // the driver did not set it, we set it to our default
            ulGamma = DEFAULT_CT_CONTRAST;

    }

    if (ulGamma < 1100)
    {
        bi.pjGamma    = ajGammaCT_10;
        bi.pjGammaInv = ajGammaCT_10;
    }
    else if (ulGamma < 1200)
    {
        bi.pjGamma    = ajGammaCT_11;
        bi.pjGammaInv = ajGammaInvCT_11;
    }
    else if (ulGamma < 1300)
    {
        bi.pjGamma    = ajGammaCT_12;
        bi.pjGammaInv = ajGammaInvCT_12;
    }
    else if (ulGamma < 1400)
    {
        bi.pjGamma    = ajGammaCT_13;
        bi.pjGammaInv = ajGammaInvCT_13;
    }
    else if (ulGamma < 1500)
    {
        bi.pjGamma    = ajGammaCT_14;
        bi.pjGammaInv = ajGammaInvCT_14;
    }
    else if (ulGamma < 1600)
    {
        bi.pjGamma    = ajGammaCT_15;
        bi.pjGammaInv = ajGammaInvCT_15;
    }
    else if (ulGamma < 1700)
    {
        bi.pjGamma    = ajGammaCT_16;
        bi.pjGammaInv = ajGammaInvCT_16;
    }
    else if (ulGamma < 1800)
    {
        bi.pjGamma    = ajGammaCT_17;
        bi.pjGammaInv = ajGammaInvCT_17;
    }
    else if (ulGamma < 1900)
    {
        bi.pjGamma    = ajGammaCT_18;
        bi.pjGammaInv = ajGammaInvCT_18;
    }
    else if (ulGamma < 2000)
    {
        bi.pjGamma    = ajGammaCT_19;
        bi.pjGammaInv = ajGammaInvCT_19;
    }
    else if (ulGamma < 2100)
    {
        bi.pjGamma    = ajGammaCT_20;
        bi.pjGammaInv = ajGammaInvCT_20;
    }
    else if (ulGamma < 2200)
    {
        bi.pjGamma    = ajGammaCT_21;
        bi.pjGammaInv = ajGammaInvCT_21;
    }
    else
    {
        bi.pjGamma    = ajGammaCT_22;
        bi.pjGammaInv = ajGammaInvCT_22;
    }

// important; shift as ULONG's, store back as LONG's
// gamma correct at the same step

    bi.lRedF  = bi.pjGamma[((((uF & bi.flRed) << bi.iRedL) >> bi.iRedR) & 255)];
    bi.lGreF  = bi.pjGamma[((((uF & bi.flGre) << bi.iGreL) >> bi.iGreR) & 255)];
    bi.lBluF  = bi.pjGamma[((((uF & bi.flBlu) << bi.iBluL) >> bi.iBluR) & 255)];

// done, copy out, this is faster than doing pbi->xxx all the time...

    *pbi = bi;
}





// default value for few sgi monitors that we have seen
// Actually, it closer to 2.0, but if the monitor is viewed from
// a non 90 degree angle, than effective gamma goes as low as 1.2,
// so we decided to undercompensate and set it to 1.8, slightly below ideal


VOID *pvFillOpaqTableCT(
    ULONG size,
    ULONG uF,
    ULONG uB,
    SURFACE *pS,
    BLENDINFO *pbi,
    BOOL bTransparent
)
{
    // I have been assured of two things....
    // 1) Since this routine is a child of EngTextOut then there
    //    will be only one thread in this routine at any one time.
    //    This means that I do not need to protect the color
    //    table, aulCacheCT[] with a critical section
    // 2) I have been assured that the format of a surface
    //    is unique. Thus if the handle of the surface matches
    //    the handle of the cached color table, then the
    //    formats of the surface are the same.

    BOOL bLookupTableOk = (pS->hGet() == hCacheCT) &&
                          (uB == uBCacheCT)        &&
                          (uF == uFCacheCT)        &&
                          (gulGamma == uGammaCacheCT) ;

    if (bLookupTableOk && !bTransparent) // do not need to do anything, done
    {
        ASSERTGDI(size == sizeCacheCT, "size != sizeCacheCT\n");
    }
    else
    {
        vGetBlendInfo(size, pS, uF, pbi);

        if (!bLookupTableOk) // need to recompute the lookup table
        {
            vClearTypeLookupTableLoop(size, pS, pbi, uF, uB);
        }
    }
    return (PVOID)aulCacheCT;
}

VOID GreSetLCDOrientation(DWORD dwOrientation)
{
    gaOutTable = (dwOrientation & FE_FONTSMOOTHINGORIENTATIONRGB) ? gaOutTableRGB : gaOutTableBGR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\atmstub.h ===
/******************************Module*Header*******************************\
* Module Name: atmstub.h
*
* Created: 23-Apr-1990
* Author: Xudong Wu [tessiew]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

DHPDEV APIENTRY atmfdEnablePDEV(
    DEVMODEW *pdm,
    LPWSTR    pwszLogAddress,
    ULONG     cPat,
    HSURF    *phsurfPatterns,
    ULONG     cjCaps,
    ULONG    *pdevcaps,
    ULONG     cjDevInfo,
    DEVINFO  *pdi,
    HDEV      hdev,
    LPWSTR    pwszDeviceName,
    HANDLE    hDriver
    );

VOID APIENTRY atmfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV hdev
    );

VOID APIENTRY atmfdDisablePDEV(
    DHPDEV dhpdev
    );


ULONG_PTR APIENTRY atmfdLoadFontFile(
    ULONG     cFiles,
    ULONG_PTR  *piFile,
    PVOID     *ppvView,
    ULONG     *pcjView,
    DESIGNVECTOR *pdv,
    ULONG     ulLangID,
    ULONG     ulFastCheckSum
    );

LONG APIENTRY atmfdQueryFontFile(
    ULONG_PTR   iFile,
    ULONG      ulMode,
    ULONG      cjBuf,
    ULONG      *pulBuf
    );

BOOL APIENTRY atmfdUnloadFontFile(
    ULONG_PTR   iFile
    );

PIFIMETRICS APIENTRY atmfdQueryFont(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG_PTR *pid
    );

LONG APIENTRY atmfdQueryFontCaps(
    ULONG   culCaps,
    ULONG  *pulCaps
    );

PVOID APIENTRY atmfdQueryFontTree(
    DHPDEV    dhpdev,
    ULONG_PTR  iFile,
    ULONG     iFace,
    ULONG     iMode,
    ULONG_PTR *pid
    );

LONG APIENTRY atmfdQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

BOOL APIENTRY atmfdQueryAdvanceWidths(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    PVOID    pvWidths,
    ULONG    cGlyphs
    );

LONG APIENTRY atmfdQueryTrueTypeOutline(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    HGLYPH      hglyph,
    BOOL        bMetricsOnly,
    GLYPHDATA  *pgldt,
    ULONG       cjBuf,
    TTPOLYGONHEADER *ppoly
    );

LONG APIENTRY atmfdQueryTrueTypeTable(
    ULONG_PTR   iFile,
    ULONG      ulFont,
    ULONG      ulTag,
    PTRDIFF    dpStart,
    ULONG      cjBuf,
    BYTE       *pjBuf,
    PBYTE      *ppjTable,
    ULONG      *pcjTable
    );

PFD_GLYPHATTR atmfdQueryGlyphAttrs (
    FONTOBJ *pfo,
    ULONG   iMode
    );

PVOID APIENTRY atmfdGetTrueTypeFile (
    ULONG_PTR   iFile,
    ULONG      *pcj
    );

ULONG APIENTRY atmfdFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iMode,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    );

VOID APIENTRY atmfdDestroyFont(
    FONTOBJ *pfo
    );

VOID APIENTRY atmfdFree(
    PVOID   pv,
    ULONG_PTR id
    );

ULONG APIENTRY atmfdEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\atmstub.c ===
/******************************Module*Header*******************************\
* Module Name: atmstub.c
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#include "engine.h"
#include "atmstub.h"

#define ARRAYSIZE(a)                (sizeof(a) / sizeof(*(a)))
#define ESC_NOT_SUPPORTED           0
#define ESC_IS_SUPPORTED            1
#define BEG_OF_ATM_ESCAPE_LIST      0x2500
#define END_OF_ATM_ESCAPE_LIST      0x2600  //Allocated 256 escapes to ATM.


DRVFN atmfdCallBlock[] =
{
    {INDEX_DrvEnablePDEV,               (PFN)atmfdEnablePDEV},
    {INDEX_DrvDisablePDEV,              (PFN)atmfdDisablePDEV},
    {INDEX_DrvCompletePDEV,             (PFN)atmfdCompletePDEV},
    {INDEX_DrvLoadFontFile,             (PFN)atmfdLoadFontFile},
    {INDEX_DrvQueryFontCaps,            (PFN)atmfdQueryFontCaps},
    {INDEX_DrvUnloadFontFile,           (PFN)atmfdUnloadFontFile},
    {INDEX_DrvQueryFontFile,            (PFN)atmfdQueryFontFile},
    {INDEX_DrvQueryFont,                (PFN)atmfdQueryFont},
    {INDEX_DrvFree,                     (PFN)atmfdFree},
    {INDEX_DrvQueryFontTree,            (PFN)atmfdQueryFontTree},
    {INDEX_DrvQueryFontData,            (PFN)atmfdQueryFontData},
    {INDEX_DrvDestroyFont,              (PFN)atmfdDestroyFont},
    {INDEX_DrvQueryAdvanceWidths,       (PFN)atmfdQueryAdvanceWidths},
    {INDEX_DrvQueryTrueTypeOutline,     (PFN)atmfdQueryTrueTypeOutline},
    {INDEX_DrvQueryTrueTypeTable,       (PFN)atmfdQueryTrueTypeTable},
    {INDEX_DrvEscape,                   (PFN)atmfdEscape},
    {INDEX_DrvFontManagement,           (PFN)atmfdFontManagement},
    {INDEX_DrvGetTrueTypeFile,          (PFN)atmfdGetTrueTypeFile},
    {INDEX_DrvQueryGlyphAttrs,          (PFN)atmfdQueryGlyphAttrs},
};
UINT ARRAYSIZE_atmfdCallBlock = ARRAYSIZE(atmfdCallBlock);

//Typedefs for functions pointers...
typedef BOOL (APIENTRY *DRV_ENABLE_DRIVER)(ULONG, ULONG, PDRVENABLEDATA);
typedef LONG (APIENTRY *DRV_QUERY_FONT_CAPS)(ULONG, PULONG);
typedef BOOL (APIENTRY *DRV_UNLOAD_FONT_FILE)(ULONG_PTR);
typedef LONG (APIENTRY *DRV_QUERY_FONT_FILE)(ULONG_PTR, ULONG, ULONG, PULONG);
typedef PIFIMETRICS (APIENTRY *DRV_QUERY_FONT)(DHPDEV, ULONG_PTR, ULONG, ULONG_PTR*);
typedef VOID (APIENTRY *DRV_FREE)(PVOID, ULONG_PTR);
typedef PVOID (APIENTRY *DRV_QUERY_FONT_TREE)(DHPDEV, ULONG_PTR, ULONG, ULONG, ULONG_PTR*);
typedef LONG (APIENTRY *DRV_QUERY_FONT_DATA)(DHPDEV, FONTOBJ*, ULONG, HGLYPH, GLYPHDATA*, PVOID, ULONG);
typedef VOID (APIENTRY *DRV_DESTROY_FONT)(FONTOBJ*);
typedef BOOL (APIENTRY *DRV_QUERY_ADVANCE_WIDTHS)(DHPDEV, FONTOBJ*, ULONG, PHGLYPH, PVOID, ULONG);
typedef LONG (APIENTRY *DRV_QUERY_TRUE_TYPE_OUTLINE)(DHPDEV, FONTOBJ*, HGLYPH, BOOL, GLYPHDATA*, ULONG, TTPOLYGONHEADER*);
typedef ULONG (APIENTRY *DRV_ESCAPE)(SURFOBJ*, ULONG, ULONG, PVOID, ULONG, PVOID);
typedef ULONG (APIENTRY *DRV_FONT_MANAGEMENT)(SURFOBJ*, FONTOBJ*, ULONG, ULONG, PVOID, ULONG, PVOID);
typedef PVOID (APIENTRY *DRV_GET_TRUE_TYPE_FILE)(ULONG_PTR, PULONG);
typedef ULONG_PTR (APIENTRY *DRV_LOAD_FONT_FILE)(ULONG, PULONG_PTR, PVOID*, PULONG, PDESIGNVECTOR, ULONG, ULONG);
typedef LONG (APIENTRY *DRV_QUERY_TRUE_TYPE_TABLE)(ULONG_PTR, ULONG, ULONG, PTRDIFF, ULONG, PBYTE, PBYTE*, PULONG);
typedef PFD_GLYPHATTR (APIENTRY *DRV_QUERY_GLYPH_ATTRS)(FONTOBJ*, ULONG);

//Globals...
//Function pointers....
DRV_ENABLE_DRIVER               pAtmfdEnableDriver = NULL;
DRV_LOAD_FONT_FILE              pAtmfdLoadFontFile = NULL;
DRV_UNLOAD_FONT_FILE            pAtmfdUnloadFontFile = NULL;
DRV_QUERY_FONT_FILE             pAtmfdQueryFontFile = NULL;
DRV_QUERY_FONT                  pAtmfdQueryFont = NULL;
DRV_FREE                        pAtmfdFree = NULL;
DRV_QUERY_FONT_TREE             pAtmfdQueryFontTree = NULL;
DRV_QUERY_FONT_DATA             pAtmfdQueryFontData = NULL;
DRV_DESTROY_FONT                pAtmfdDestroyFont = NULL;
DRV_QUERY_ADVANCE_WIDTHS        pAtmfdQueryAdvanceWidths = NULL;
DRV_QUERY_TRUE_TYPE_OUTLINE     pAtmfdQueryTrueTypeOutline = NULL;
DRV_QUERY_TRUE_TYPE_TABLE       pAtmfdQueryTrueTypeTable = NULL;
DRV_ESCAPE                      pAtmfdEscape = NULL;
DRV_FONT_MANAGEMENT             pAtmfdFontManagement = NULL;
DRV_GET_TRUE_TYPE_FILE          pAtmfdGetTrueTypeFile = NULL;
DRV_QUERY_GLYPH_ATTRS           pAtmfdQueryGlyphAttrs = NULL;

HANDLE                          atmfdHandle = NULL;
BOOL                            driverFailedLoad = FALSE;
ULONG                           engineVersion = 0;
DRVENABLEDATA                   atmfdFuncData = {0};


//------------------------------------------------------------------------------
static PVOID FindFunc(
    ULONG     funcIndex)
{
    PVOID   result = NULL;
    UINT    i;

    for (i = 0; i < ARRAYSIZE_atmfdCallBlock; i++)
    {
        if (atmfdFuncData.pdrvfn[i].iFunc == funcIndex)
        {
            result = (PVOID)atmfdFuncData.pdrvfn[i].pfn;
            break;
        }
    }
    
    return result;
}


//------------------------------------------------------------------------------
static BOOL InitializeDriver(void)
{
    BOOL    result = FALSE;

    GreAcquireSemaphore(ghsemAtmfdInit);

    //Has the driver already been loaded?
    if (atmfdHandle != NULL)
    {
        result = TRUE;
        goto ExitPoint;
    }

    //Have we attempted to load the driver previously but failed?
    if (driverFailedLoad == TRUE)
        goto ExitPoint;

    //Load an image of the ATM font driver...
    if ((atmfdHandle = EngLoadImage(L"ATMFD.DLL")) == NULL)
        goto ExitPoint;

    //Get a pointer to the DrvEnableDriver function...
    if ((pAtmfdEnableDriver = EngFindImageProcAddress(atmfdHandle, "DrvEnableDriver")) == NULL)
        goto ExitPoint;

    //Initialize the ATMFD driver...
    if ((*pAtmfdEnableDriver)(engineVersion, sizeof(atmfdFuncData), &atmfdFuncData) == FALSE)
        goto ExitPoint;

    //Check driver version number...
    if (atmfdFuncData.iDriverVersion != DDI_DRIVER_VERSION_NT5)
        goto ExitPoint;

    //Now get the rest of the function pointers...
    if ((pAtmfdLoadFontFile = FindFunc(INDEX_DrvLoadFontFile)) == NULL)
        goto ExitPoint;
    if ((pAtmfdUnloadFontFile = FindFunc(INDEX_DrvUnloadFontFile)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryFontFile = FindFunc(INDEX_DrvQueryFontFile)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryFont = FindFunc(INDEX_DrvQueryFont)) == NULL)
        goto ExitPoint;
    if ((pAtmfdFree = FindFunc(INDEX_DrvFree)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryFontTree = FindFunc(INDEX_DrvQueryFontTree)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryFontData = FindFunc(INDEX_DrvQueryFontData)) == NULL)
        goto ExitPoint;
    if ((pAtmfdDestroyFont = FindFunc(INDEX_DrvDestroyFont)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryAdvanceWidths = FindFunc(INDEX_DrvQueryAdvanceWidths)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryTrueTypeOutline = FindFunc(INDEX_DrvQueryTrueTypeOutline)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryTrueTypeTable = FindFunc(INDEX_DrvQueryTrueTypeTable)) == NULL)
        goto ExitPoint;
    if ((pAtmfdEscape = FindFunc(INDEX_DrvEscape)) == NULL)
        goto ExitPoint;
    if ((pAtmfdFontManagement = FindFunc(INDEX_DrvFontManagement)) == NULL)
        goto ExitPoint;
    if ((pAtmfdGetTrueTypeFile = FindFunc(INDEX_DrvGetTrueTypeFile)) == NULL)
        goto ExitPoint;
    if ((pAtmfdQueryGlyphAttrs = FindFunc(INDEX_DrvQueryGlyphAttrs)) == NULL)
        goto ExitPoint;

    result = TRUE;
ExitPoint:
    if (result == FALSE)
    {
        driverFailedLoad = TRUE;
        if (atmfdHandle != NULL)
        {
            EngUnloadImage(atmfdHandle);
            atmfdHandle = NULL;
        }
    }

    GreReleaseSemaphore(ghsemAtmfdInit);

    return result;
}


//------------------------------------------------------------------------------
BOOL APIENTRY atmfdEnableDriver(
    ULONG           iEngineVersion,
    ULONG           cj,
    PDRVENABLEDATA  pded) 
// Requests that the driver fill a structure with pointers to supported                 
// functions and other control information. The function returns TRUE if                 
// the driver is enabled FALSE otherwise.                                                                               
{
    engineVersion = iEngineVersion;
    if (cj >= sizeof(DRVENABLEDATA))
    {
        pded->pdrvfn = atmfdCallBlock;
        pded->c = ARRAYSIZE_atmfdCallBlock;
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;
        return TRUE;
    }
    return FALSE;
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdDisableDriver(void) 
{
    if (atmfdHandle)
    {
        EngUnloadImage(atmfdHandle);
        atmfdHandle = NULL;
    }
}


//------------------------------------------------------------------------------
DHPDEV APIENTRY atmfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver)
{
    return ((DHPDEV) EngAllocMem(FL_ZERO_MEMORY, 4, 'AerG'));
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdDisablePDEV(
    DHPDEV  dhpdev)
{
    EngFreeMem(dhpdev);
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev)
{
    return;
}


//------------------------------------------------------------------------------
ULONG_PTR APIENTRY atmfdLoadFontFile(      //Returns IFILE value
    ULONG           cFiles,  // number of font files associated with this font
    PULONG_PTR      piFile,  // handles for individual files, cFiles of them
    PVOID           *ppvView, // array of cFiles views
    PULONG          pcjView, // array of their sizes
    PDESIGNVECTOR   pdv,
    ULONG           ulLangID,
    ULONG           ulFastCheckSum)
{
    if (InitializeDriver())
        return (*pAtmfdLoadFontFile)(cFiles, piFile, ppvView, pcjView, pdv, ulLangID, ulFastCheckSum);
    else
        return 0;
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryFontCaps(
    ULONG   culCaps,
    PULONG  pulCaps)
{
    if (culCaps >= 2)
    {
        pulCaps[0] = 2L;
        pulCaps[1] = QC_OUTLINES | QC_1BIT | QC_4BIT;
        return 2;
    }
    else
        return FD_ERROR;
}


//------------------------------------------------------------------------------
BOOL APIENTRY atmfdUnloadFontFile(
    ULONG_PTR iFile)
{
    return (*pAtmfdUnloadFontFile)(iFile);
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryFontFile(
    ULONG_PTR   iFile,  
    ULONG       ulMode,  
    ULONG       cjBuf,  
    PULONG      pulBuf) 
{
    return (*pAtmfdQueryFontFile)(iFile, ulMode, cjBuf, pulBuf);
}


//------------------------------------------------------------------------------
PIFIMETRICS APIENTRY atmfdQueryFont(
    DHPDEV      dhpdev, 
    ULONG_PTR   iFile, 
    ULONG       iFace, 
    ULONG_PTR  *pid)
{
    return (*pAtmfdQueryFont)(dhpdev, iFile, iFace, pid);
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdFree(
    PVOID pv,
    ULONG_PTR id)
{
    (*pAtmfdFree)(pv, id);
}


//------------------------------------------------------------------------------
PVOID APIENTRY atmfdQueryFontTree(
    DHPDEV      dhpdev, 
    ULONG_PTR   iFile, 
    ULONG       iFace, 
    ULONG       iMode, 
    ULONG_PTR  *pid) 
{
    return (*pAtmfdQueryFontTree)(dhpdev, iFile, iFace, iMode, pid);
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryFontData(
    DHPDEV      dhpdev, 
    FONTOBJ     *pfo, 
    ULONG       iMode, 
    HGLYPH      hg, 
    GLYPHDATA   *pgd, 
    PVOID       pv, 
    ULONG       cjSize) 
{
    return (*pAtmfdQueryFontData)(dhpdev, pfo, iMode, hg, pgd, pv, cjSize);
}


//------------------------------------------------------------------------------
VOID APIENTRY atmfdDestroyFont(
    FONTOBJ *pfo) 
{
    (*pAtmfdDestroyFont)(pfo);
}


//------------------------------------------------------------------------------
BOOL APIENTRY atmfdQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ     *pfo,
    ULONG       iMode,
    PHGLYPH     pGlyphHandle,
    PVOID       widths,
    ULONG       numOfGlyphs)
{
    return (*pAtmfdQueryAdvanceWidths)(dhpdev, pfo, iMode, pGlyphHandle, widths, numOfGlyphs);
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryTrueTypeOutline(
    DHPDEV              dhpdev, 
    FONTOBJ             *pfo, 
    HGLYPH              hg, 
    BOOL                metricsOnly,
    GLYPHDATA           *pgd, 
    ULONG               cjSize,
    TTPOLYGONHEADER     *pgHead)
{
    return (*pAtmfdQueryTrueTypeOutline)(dhpdev, pfo, hg, metricsOnly, pgd, cjSize, pgHead);
}


//------------------------------------------------------------------------------
LONG APIENTRY atmfdQueryTrueTypeTable(
    ULONG_PTR   iFile,
    ULONG       ulFont,
    ULONG       ulTag,
    PTRDIFF     dpStart,
    ULONG       cjBuf,
    PBYTE       pjBuf,
    PBYTE       *ppjTable,
    PULONG      pcjTable)
{
    return (*pAtmfdQueryTrueTypeTable)(iFile, ulFont, ulTag, dpStart, cjBuf, pjBuf, ppjTable, pcjTable);
}


//------------------------------------------------------------------------------
PFD_GLYPHATTR APIENTRY atmfdQueryGlyphAttrs(
    FONTOBJ       *pfo,
    ULONG          iMode)
{
    return (*pAtmfdQueryGlyphAttrs)(pfo, iMode);
}


//------------------------------------------------------------------------------
ULONG APIENTRY atmfdEscape(
    SURFOBJ *pso,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut)
{
    return atmfdFontManagement(pso, NULL, iEsc, cjIn, pvIn, cjOut, pvOut);
}


//------------------------------------------------------------------------------
ULONG APIENTRY atmfdFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut)
{
    ULONG   result = ESC_NOT_SUPPORTED;
    BOOL    callDriver = FALSE;

    switch(iEsc)
    {
        case QUERYESCSUPPORT:
        {
            switch (*((PULONG)pvIn))
            {
                case QUERYESCSUPPORT:
                case GETEXTENDEDTEXTMETRICS:
                    result = ESC_IS_SUPPORTED;
                    break;
                default:
                    if ((*((PULONG)pvIn) > BEG_OF_ATM_ESCAPE_LIST) && (*((PULONG)pvIn) < END_OF_ATM_ESCAPE_LIST))
                        result = ESC_IS_SUPPORTED;
            }
            break;
        }
        case GETEXTENDEDTEXTMETRICS:
        {
            callDriver = TRUE;
            break;
        }
        default:
        {
            if ((iEsc <= BEG_OF_ATM_ESCAPE_LIST) || (iEsc >= END_OF_ATM_ESCAPE_LIST))
                break;

            callDriver = TRUE;
            break;
        }
    }
    if (callDriver)
    {
        if (InitializeDriver() == TRUE)
        {
            return (*pAtmfdFontManagement)(pso, pfo, iEsc, cjIn, pvIn, cjOut, pvOut);
        }
    }
    return result;
}


//------------------------------------------------------------------------------
PVOID APIENTRY atmfdGetTrueTypeFile(
    ULONG_PTR   iFile,
    PULONG      pcj)
{
    return (*pAtmfdGetTrueTypeFile)(iFile, pcj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\alphaimg.cxx ===
/******************************Module*Header*******************************\
* Module Name: alphaimg.cxx
*
* Low level alpha blending routines
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/
#include "precomp.hxx"

                
/**************************************************************************\
* Explanation of algorithm for AlphaPerPixelOnly routines
* -------------------------------------------------------
*
* The inner loop of each routine computes:
* 
*   Dst = Alpha * Src + (1-Alpha) * Dst
*
*
* The source pixel is assumed to have been premultiplied
* with the alpha value, which leaves this:
*
*   Dst = Src + (1-Alpha) * Dst
*
*
* Because the alpha is stored as a byte, we must actually compute
*
*   Dst = Src + (255-SrcAlpha) * Dst / 255
*
*
* A close approximation to 1/255 is 257/65536; we use this to replace
* the divide with shifts and adds. That is, X/255 becomes:
*
*   ((X<<8) + X) >> 16
*
* or:
*
*   (X + (X>>8)) >> 8
*
*
* We improve the accuracy of this approximation by adding a rounding
* step after the multiply. 
*
* In particular, this gives exact results
* where SrcAlpha is 0 or 255, important for versions of the routine
* which do not special case those values (such as mmxAlphaPerPixelOnly).
*
* The resulting algorithm is:
*
*   T1  = Dst * (255 - SrcAlpha) + 128
*   T2  = T1 >> 8
*   T3  = (T1 + T2) >> 8;
*   Dst = Src + T2
*
* Finally, the above must be done to each of the 4 components of the pixel.
* Most versions of the routine do 2 components in a single
* DWORD. The algorithm is therefore done twice per pixel, 
* once for each set of 2 components, and the two iterations are interleaved.
*
\**************************************************************************/

/**************************************************************************\
* vAlphaPerPixelOnly
*   
*   Used when the source has per-pixel alpha values and the
*   SourceConstantAlpha is 255.
*
*       Dst = Src + (1-SrcAlpha) * Dst
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*
*   none
*
* History:
*
*    1/23/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#if !defined(_X86_)

VOID
vAlphaPerPixelOnly(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;
    BYTE     alpha;

    while (cx--)
    {
        pixSrc = *ppixSrc;
	alpha = pixSrc.pix.a;

        if (alpha != 0)
        {
            pixDst = *ppixDst;

            if (alpha == 255)
            {
                pixDst = pixSrc;
            }
            else
            {
                //
                // Dst = Src + (1-Alpha) * Dst
                //

                ULONG Multa = 255 - alpha;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);
                
                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;
                
                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;
                
                
                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;
                
                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }

        ppixSrc++;
        ppixDst++;
    }
}

#endif

/**************************************************************************\
* vAlphaPerPixelAndConst
*   
*   Used when the source has per-pixel alpha values and the
*   SourceConstantAlpha is not 255.
*
*       if SrcAlpha == 255 then
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*
*       else
*
*           Src = Src * ConstAlpha
*           Dst = Src + (1 - SrcAlpha) Dst       
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*
*   None
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vAlphaPerPixelAndConst(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;
    BYTE     alpha; 

    while (cx--)
    {
        pixSrc = *ppixSrc;
	alpha = pixSrc.pix.a;

        if (alpha != 0)
        {
            pixDst = *ppixDst;

            if (alpha == 255)
            {
                //
                // Blend: D = sA * S + (1-sA) * D
                //
                // red and blue
                //
        
                ULONG uB00rr00bb = pixDst.ul & 0x00ff00ff;
                ULONG uF00rr00bb = pixSrc.ul & 0x00ff00ff;
        
                ULONG uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                                   (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;
        
                ULONG uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;
        
                ULONG uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;
        
                //
                // alpha and green
                //
        
                ULONG uB00aa00gg = (pixDst.ul >> 8) & 0xff00ff;
                ULONG uF00aa00gg = (pixSrc.ul >> 8) & 0xff00ff;
        
                ULONG uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                                   (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;
        
                ULONG uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;
        
                ULONG uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;
        
                pixDst.ul  = uD00rr00bb + uDaa00gg00;
            }
            else
            {
                //
                // disolve
                //

                ULONG ul_B_00AA00GG = (pixSrc.ul & 0xff00ff00) >> 8;
                ULONG ul_B_00RR00BB = (pixSrc.ul & 0x00ff00ff);
        
                ULONG ul_T_AAAAGGGG = ul_B_00AA00GG * ConstAlpha + 0x00800080;
                ULONG ul_T_RRRRBBBB = ul_B_00RR00BB * ConstAlpha + 0x00800080;
        
                ULONG ul_T_00AA00GG = (ul_T_AAAAGGGG & 0xFF00FF00) >> 8;
                ULONG ul_T_00RR00BB = (ul_T_RRRRBBBB & 0xFF00FF00) >> 8;
        
                ULONG ul_C_AA00GG00 = ((ul_T_AAAAGGGG + ul_T_00AA00GG) & 0xFF00FF00);
                ULONG ul_C_00RR00BB = ((ul_T_RRRRBBBB + ul_T_00RR00BB) & 0xFF00FF00) >> 8;
        
                pixSrc.ul = (ul_C_AA00GG00 | ul_C_00RR00BB);

                //
                // over
                //


                ULONG Multa = 255 - pixSrc.pix.a;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);

                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;


                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }
        
	ppixSrc++;
        ppixDst++;
    }
}

/******************************Public*Routine******************************\
* vAlphaConstOnly
*   
*   Used when the source does not have per-pixel alpha values,
*   and SourceConstantAlpha is not 255.
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*   
*   None
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/
#if !defined (_X86_)

VOID
vAlphaConstOnly(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    PULONG   pulSrc = (PULONG)ppixSrc;
    PULONG   pulDst = (PULONG)ppixDst;
    PULONG   pulSrcEnd = pulSrc + cx;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    //
    // Blend: D = sA * S + (1-sA) * D
    //

    while (pulSrc != pulSrcEnd)
    {
        ULONG ulDst = *pulDst;
        ULONG ulSrc = *pulSrc;
        ULONG uB00rr00bb = ulDst & 0x00ff00ff;
        ULONG uF00rr00bb = ulSrc & 0x00ff00ff;

        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uD00rr00bb; 
        ULONG uB00aa00gg;
        ULONG uF00aa00gg;
        ULONG uMaaaagggg;
        ULONG uM00aa00gg;
        ULONG uDaa00gg00;

        //
        // red and blue
        //

        uB00rr00bb = ulDst & 0x00ff00ff;
        uF00rr00bb = ulSrc & 0x00ff00ff;

        uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;

        uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;

        uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;

        //
        // alpha and green
        //

        uB00aa00gg = (ulDst >> 8) & 0xff00ff;
        uF00aa00gg = (ulSrc >> 8) & 0xff00ff;

        uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                     (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;

        uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;

        uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;

        *pulDst = uD00rr00bb + uDaa00gg00;

        pulSrc++;
        pulDst++;
    }
}

/**************************************************************************\
* vAlphaConstOnly16_555
*
*   Optimized version of vAlphaConstOnly used when source and destination
*   are both 16_555.
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*   
*   None
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vAlphaConstOnly16_555(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    PUSHORT  pusSrc = (PUSHORT)ppixSrc;
    PUSHORT  pusDst = (PUSHORT)ppixDst;
    PUSHORT  pusSrcEnd = pusSrc + cx;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    //
    // Blend: D = sA * S + (1-sA) * D
    //

    while (pusSrc != pusSrcEnd)
    {
        USHORT usDst = *pusDst;
        USHORT usSrc = *pusSrc;

        ULONG uB00rr00bb;
        ULONG uF00rr00bb;
        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uDrrxxbbxx; 
        ULONG uB000000gg;
        ULONG uF000000gg;
        ULONG uM0000gggg;
        ULONG uM000000gg;
        ULONG uD0000ggxx;

        //
        // red and blue
        //

        uB00rr00bb = (usDst & 0x7c1f); // uB 0rrr rr00 000b bbbb
        uF00rr00bb = (usSrc & 0x7c1f); // uS 0rrr rr00 000b bbbb

        uMrrrrbbbb = ((uB00rr00bb<<5)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00004010;

        uM00rr00bb = (uMrrrrbbbb & 0x000F83E0) >> 5;

        uDrrxxbbxx = ((uMrrrrbbbb+uM00rr00bb) >> 5) &  0x7c1f;

        //
        // green
        //

        uB000000gg = (usDst & 0x3e0) >> 5;
        uF000000gg = (usSrc & 0x3e0) >> 5;

        uM0000gggg = ((uB000000gg <<5)-uB000000gg) +
                     (ConstAlpha * (uF000000gg-uB000000gg)) + 0x00000010;

        uM000000gg = (uM0000gggg & 0x000003E0)>>5;

        uD0000ggxx = (uM0000gggg + uM000000gg) & 0x03E0;

        *pusDst = (USHORT)(uDrrxxbbxx  |  uD0000ggxx);

        pusSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vAlphaConstOnly16_565
*
*   Optimized version of vAlphaConstOnly used when source and destination
*   are both 16_565.
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*   
*   None
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vAlphaConstOnly16_565(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction
    )
{
    PUSHORT  pusSrc = (PUSHORT)ppixSrc;
    PUSHORT  pusDst = (PUSHORT)ppixDst;
    PUSHORT  pusSrcEnd = pusSrc + cx;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    //
    // Blend: D = sA * S + (1-sA) * D
    //

    while (pusSrc != pusSrcEnd)
    {
        USHORT usDst = *pusDst;
        USHORT usSrc = *pusSrc;

        ULONG uB00rr00bb;
        ULONG uF00rr00bb;
        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uDrrxxbbxx; 
        ULONG uB000000gg;
        ULONG uF000000gg;
        ULONG uM0000gggg;
        ULONG uM000000gg;
        ULONG uD0000ggxx;

        //
        // red and blue
        //

        uB00rr00bb = (usDst & 0xf81f); // uB 0rrr rr00 000b bbbb
        uF00rr00bb = (usSrc & 0xf81f); // uS 0rrr rr00 000b bbbb

        uMrrrrbbbb = ((uB00rr00bb<<5)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00008010;

        uM00rr00bb = (uMrrrrbbbb & 0x001F03E0) >> 5;

        uDrrxxbbxx = ((uMrrrrbbbb+uM00rr00bb) >> 5) &  0xf81f;

        //
        // green
        //

        uB000000gg = (usDst & 0x7e0) >> 5;
        uF000000gg = (usSrc & 0x7e0) >> 5;

        uM0000gggg = ((uB000000gg <<6)-uB000000gg) +
                     (2 * ConstAlpha * (uF000000gg-uB000000gg)) + 0x00000020;

        uM000000gg = (uM0000gggg & 0x00000fc0)>>6;

        uD0000ggxx = ((uM0000gggg + uM000000gg) & 0x0fc0) >> 1;

        *pusDst = (USHORT)(uDrrxxbbxx  |  uD0000ggxx);

        pusSrc++;
        pusDst++;
    }
}

#endif

/******************************Public*Routine******************************\
* vAlphaConstOnly24
*   
*   Optimized version of vAlphaConstOnly used when source and destination
*   are both 24bpp.
*
* Arguments:
*   
*   pixDst,      
*   pixSrc,      
*   cx,          
*   BlendFunction
*
* Return Value:
*
*
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vAlphaConstOnly24(
    ALPHAPIX     *ppixDst,
    ALPHAPIX     *ppixSrc,
    LONG          cx,
    BLENDFUNCTION BlendFunction
    )
{
    BYTE    ConstAlpha = BlendFunction.SourceConstantAlpha;
    PBYTE   pjSrc      = (PBYTE)ppixSrc;
    PBYTE   pjDst      = (PBYTE)ppixDst;
    PBYTE   pjSrcEnd   = pjSrc + 3*cx;

    while (pjSrc != pjSrcEnd)
    {
        ULONG ulDst = (*pjDst) << 16;
        ULONG ulSrc = (*pjSrc) << 16;

        ULONG uB00rr00bb;
        ULONG uF00rr00bb;
        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uD00rr00bb; 
        ULONG uB000000gg;
        ULONG uF000000gg;
        ULONG uM0000gggg;
        ULONG uM000000gg;
        ULONG uD000000gg;

        //
        // red and blue
        //

        uB00rr00bb = uB00rr00bb = ulDst | (*(pjDst+1)); 
        uF00rr00bb = uF00rr00bb = ulSrc | (*(pjSrc+1)); 

        uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;

        uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;

        uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;

        //
        // green
        //

        uB000000gg = *(pjDst+2);
        uF000000gg = *(pjSrc+2);

        uM0000gggg = ((uB000000gg <<8)-uB000000gg) +
                     (ConstAlpha * (uF000000gg-uB000000gg)) + 0x00000080;

        uM000000gg = (uM0000gggg & 0x0000ff00)>>8;

        uD000000gg = ((uM0000gggg + uM000000gg) & 0x0000ff00) >> 8;

        *pjDst     = (BYTE)(uD00rr00bb >> 16);
        *(pjDst+1) = (BYTE)(uD00rr00bb);
        *(pjDst+2) = (BYTE)(uD000000gg);

        pjSrc+=3;
        pjDst+=3;
    }
}



/******************************Public*Routine******************************\
* AlphaScanLineBlend
*
*   Blends source and destionation surfaces one scan line at a time. 
*
*   Allocate a scan line buffer for xlate of src to 32BGRA if needed.
*   Allocate a scan line buffer for xlate of dst to 32BGRA if needed.
*   Blend scan line using blend function from pAlphaDispatch
*   Write scan line back to dst (if needed)
*      
* Arguments:
*   
*   pDst           - pointer to dst surface       
*   pDstRect       - Dst output rect
*   DeltaDst       - dst scan line delat
*   pSrc           - pointer to src surface
*   DeltaSrc       - src scan line delta      
*   pptlSrc        - src offset
*   pxloSrcTo32    - xlateobj from src to 32BGR
*   pxlo32ToDst    - xlateobj from 32BGR to dst
*   palDst         - destination palette
*   palSrc         - source palette
*   pAlphaDispatch - blend data and function pointers
*
* Return Value:
*
*   Status
*
* History:
*
*    10/14/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
AlphaScanLineBlend(
    PBYTE                    pDst,                   
    PRECTL                   pDstRect,               
    LONG                     DeltaDst,               
    PBYTE                    pSrc,                   
    LONG                     DeltaSrc,               
    PPOINTL                  pptlSrc,                
    XLATEOBJ                *pxloSrcTo32,                   
    XLATEOBJ                *pxloDstTo32,                   
    XLATEOBJ                *pxlo32ToDst,
    XEPALOBJ                 palDst,                 
    XEPALOBJ                 palSrc,                 
    PALPHA_DISPATCH_FORMAT   pAlphaDispatch
    )
{
    //
    // get two scanlines of RGBA data, blend pixels, store
    //

    LONG     cx = pDstRect->right - pDstRect->left;
    LONG     cy = pDstRect->bottom - pDstRect->top;
    LONG     ScanBufferWidth = cx * 4;
    LONG     AllocationSize = 0;
    LONG     lSrcBytesPerPixel = pAlphaDispatch->ulSrcBitsPerPixel/8;
    LONG     lDstBytesPerPixel = pAlphaDispatch->ulDstBitsPerPixel/8;
    PBYTE    pjSrcTempScanBuffer = NULL;
    PBYTE    pjDstTempScanBuffer = NULL;
    PBYTE    pjAlloc = NULL;
    PBYTE    pjDstTmp;
    PBYTE    pjSrcTmp;
    XEPALOBJ palDstDC = (XEPALOBJ)((XLATE *) pxlo32ToDst)->ppalDstDC;

    // Arithemtic overflow check
    if (ScanBufferWidth < cx)
        return(FALSE);
    //
    // calculate destination starting address
    //
        
    if (lDstBytesPerPixel)
    {
        pjDstTmp = pDst + lDstBytesPerPixel * pDstRect->left + DeltaDst * pDstRect->top;
    }
    else if (pAlphaDispatch->ulDstBitsPerPixel == 1)
    {
        pjDstTmp = pDst + pDstRect->left/8 + DeltaDst * pDstRect->top;
    }
    else
    {
        pjDstTmp = pDst + pDstRect->left/2 + DeltaDst * pDstRect->top;
    }

    //
    // calculate source starting address
    //

    if (lSrcBytesPerPixel)
    {
        pjSrcTmp = pSrc + lSrcBytesPerPixel * pptlSrc->x + DeltaSrc * pptlSrc->y;
    }
    else if (pAlphaDispatch->ulSrcBitsPerPixel == 1)
    {
        pjSrcTmp = pSrc + pptlSrc->x/8 + DeltaSrc * pptlSrc->y;
    }
    else
    {
        pjSrcTmp = pSrc + pptlSrc->x/2 + DeltaSrc * pptlSrc->y;
    }

    //
    // calculate size of needed scan line buffer
    //

    if (pAlphaDispatch->pfnLoadDstAndConvert != NULL)
    {
        AllocationSize += ScanBufferWidth;
    }

    if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
    {
        AllocationSize += ScanBufferWidth;
        // Arithemtic overflow check
        if (AllocationSize < ScanBufferWidth)
            return(FALSE);
    }

    //
    // allocate scan line buffer memory
    //

    if (AllocationSize) {
       pjAlloc = (PBYTE)PALLOCMEM(AllocationSize,'plaG');

       if (pjAlloc == NULL)
       {
	  return(FALSE);
       }
    }

    PBYTE pjTemp = pjAlloc;

    if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
    {
        pjSrcTempScanBuffer = pjTemp;
        pjTemp += ScanBufferWidth;
    }

    if (pAlphaDispatch->pfnLoadDstAndConvert != NULL)
    {
        pjDstTempScanBuffer = pjTemp;
        pjTemp += ScanBufferWidth;
    }

    //
    // Blend scan lines
    //

    while (cy--)
    {
        PBYTE pjSource = pjSrcTmp;
        PBYTE pjDest   = pjDstTmp;

        //
        // get src scan line if needed
        //

        if (pjSrcTempScanBuffer)
        {
            (*pAlphaDispatch->pfnLoadSrcAndConvert)(
                                (PULONG)pjSrcTempScanBuffer,
                                pjSrcTmp,
                                0,
                                cx,
                                pxloSrcTo32
                                );


            pjSource = pjSrcTempScanBuffer;
        }

        //
        // get dst scan line if needed
        //

        if (pjDstTempScanBuffer)
        {
            (*pAlphaDispatch->pfnLoadDstAndConvert)(
                                (PULONG)pjDstTempScanBuffer,
                                pjDstTmp,
                                0,
                                cx,
                                pxloDstTo32
                                );

            pjDest = pjDstTempScanBuffer;
        }

        //
        // blend
        //

        (*pAlphaDispatch->pfnGeneralBlend)(
                               (PALPHAPIX)pjDest,
                               (PALPHAPIX)pjSource,
                               cx,
                               pAlphaDispatch->BlendFunction);

        //
        // write buffer back if needed
        //

        if (pjDstTempScanBuffer)
        {
            (*pAlphaDispatch->pfnConvertAndStore)(
                                pjDstTmp,
                                (PULONG)pjDstTempScanBuffer,
                                cx,
                                0,
                                pxlo32ToDst,
                                palDst,
                                palDstDC);
        }

        pjDstTmp += DeltaDst;
        pjSrcTmp += DeltaSrc;
    }

    //
    // free scan line buffer memory
    //

    if (AllocationSize) VFREEMEM(pjAlloc);

    return(TRUE);
}

#if defined(_X86_)

//
// MMX assembly code from intel
//

typedef unsigned __int64 QWORD;

/**************************************************************************\
* mmxAlphaPerPixelOnly
*   
*   Used when the source has per-pixel alpha values and the
*   SourceConstantAlpha is 255.
*
*       Dst = Src + (1-SrcAlpha) * Dst
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*
* Return Value:
*
*   none
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

/**************************************************************************
  THIS FUNCTION DOE