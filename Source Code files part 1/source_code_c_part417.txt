Key)
{
    DWORD dwSts = ERROR_SUCCESS;
    PKEY_CONTEXT pKeyCtx = NULL;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    BOOL fSuccess = FALSE;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    LOCAL_CALL_INFO LocalCallInfo;

    *phKey = 0;

    InitializeLocalCallInfo(&LocalCallInfo);

    pKeyCtx = (PKEY_CONTEXT) CspAllocH(sizeof(KEY_CONTEXT));

    LOG_CHECK_ALLOC(pKeyCtx);

    pKeyCtx->pUserContext = pUserCtx;
    pKeyCtx->Algid = Algid;
    pKeyCtx->cKeyBits = dwFlags >> 16;
    pKeyCtx->dwFlags = dwFlags & 0x0000ffff;

    if (pLocalCspInfo->pfnLocalDeriveKey)
    {
        dwSts = pLocalCspInfo->pfnLocalDeriveKey(
            pKeyCtx,
            pHashCtx,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptDeriveKey(
        pUserCtx->hSupportProv,
        Algid,
        pHashCtx->hSupportHash,
        dwFlags,
        &pKeyCtx->hSupportKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    *phKey = (HCRYPTKEY) pKeyCtx;
    pKeyCtx = NULL;

    fSuccess = TRUE;
Ret:
    if (pKeyCtx)
    {
        DeleteKeyContext(pKeyCtx);
        CspFreeH(pKeyCtx);
    }

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}


/*
 -  CPDestroyKey
 -
 *  Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *  Parameters:
 *               IN      hProv  -  Handle to a CSP
 *               IN      hKey   -  Handle to a key
 *
 *  Returns:
 */

BOOL WINAPI
CPDestroyKey(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey)
{
    DWORD dwSts = ERROR_SUCCESS;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = (PKEY_CONTEXT) hKey;

    dwSts = DeleteKeyContext(pKeyCtx);

    CspFreeH(pKeyCtx);

    if (ERROR_SUCCESS != dwSts)
        SetLastError(dwSts);

    return (ERROR_SUCCESS == dwSts);
}

/*
 -  CPSetKeyParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPSetKeyParam(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  DWORD dwParam,
    IN  CONST BYTE *pbData,
    IN  DWORD dwFlags)
{
    DWORD dwSts = ERROR_SUCCESS;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = (PKEY_CONTEXT) hKey;
    LOCAL_CALL_INFO LocalCallInfo;
    BOOL fSuccess = FALSE;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalSetKeyParam)
    {
        dwSts = pLocalCspInfo->pfnLocalSetKeyParam(
            pKeyCtx,
            dwParam,
            (PBYTE) pbData,
            dwFlags,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptSetKeyParam(
        pKeyCtx->hSupportKey,
        dwParam,
        pbData,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPGetKeyParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *  Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPGetKeyParam(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  DWORD dwParam,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD dwFlags)
{
    DWORD dwSts = ERROR_SUCCESS;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = (PKEY_CONTEXT) hKey;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    BOOL fSuccess = FALSE;

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalGetKeyParam)
    {
        dwSts = pLocalCspInfo->pfnLocalGetKeyParam(
            pKeyCtx,
            dwParam,
            pbData,
            pcbDataLen,
            dwFlags,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptGetKeyParam(
        pKeyCtx->hSupportKey,
        dwParam,
        pbData,
        pcbDataLen,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

Ret:
    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}


/*
 -  CPSetProvParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *  Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPSetProvParam(
    IN  HCRYPTPROV hProv,
    IN  DWORD dwParam,
    IN  CONST BYTE *pbData,
    IN  DWORD dwFlags)
{
    DWORD dwSts = ERROR_SUCCESS;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    BOOL fSuccess = FALSE;

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalSetProvParam)
    {
        dwSts = pLocalCspInfo->pfnLocalSetProvParam(
            pUserCtx,
            dwParam,
            (PBYTE) pbData,
            dwFlags,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptSetProvParam(
        pUserCtx->hSupportProv,
        dwParam,
        pbData,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (FALSE == fSuccess)
        SetLastError(dwSts);
    
    return fSuccess;
}


/*
 -  CPGetProvParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *  Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN OUT  pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPGetProvParam(
    IN  HCRYPTPROV hProv,
    IN  DWORD dwParam,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD dwFlags)
{
    DWORD dwSts = ERROR_SUCCESS;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    BOOL fSuccess = FALSE;
    DWORD cbData = 0;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    BOOL fFreeAnsiString = FALSE;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    BOOL fContinue = TRUE;

    memset(&AnsiString, 0, sizeof(AnsiString));
    memset(&UnicodeString, 0, sizeof(UnicodeString));

    InitializeLocalCallInfo(&LocalCallInfo);

    //
    // First, see if the local CSP wants to service this call
    //
    if (pLocalCspInfo->pfnLocalGetProvParam)
    {
        dwSts = pLocalCspInfo->pfnLocalGetProvParam(
            pUserCtx,
            dwParam,
            pbData,
            pcbDataLen,
            dwFlags,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    // 
    // Some prov params are general enough to be serviced "globally"
    // by this lib.
    // Try those before calling the support CSP.
    //
    switch (dwParam)
    {
    case PP_CONTAINER:
        fContinue = FALSE;

        RtlInitUnicodeString(
            &UnicodeString, 
            pUserCtx->wszBaseContainerName);

        dwSts = RtlUnicodeStringToAnsiString(
            &AnsiString,
            &UnicodeString,
            TRUE);

        if (STATUS_SUCCESS != dwSts)
        {
            dwSts = RtlNtStatusToDosError(dwSts);
            goto Ret;
        }

        fFreeAnsiString = TRUE;

        cbData = strlen(AnsiString.Buffer) + 1;

        if (*pcbDataLen < cbData || NULL == pbData)
        {
            *pcbDataLen = cbData;

            if (NULL != pbData)
                dwSts = ERROR_MORE_DATA;
            else
                fSuccess = TRUE;

            break;
        }

        *pcbDataLen = cbData;

        strcpy((LPSTR) pbData, AnsiString.Buffer);

        fSuccess = TRUE;
        break;

    case PP_UNIQUE_CONTAINER:
        fContinue = FALSE;

        RtlInitUnicodeString(
            &UnicodeString, 
            pUserCtx->wszUniqueContainerName);

        dwSts = RtlUnicodeStringToAnsiString(
            &AnsiString,
            &UnicodeString,
            TRUE);

        if (STATUS_SUCCESS != dwSts)
        {
            dwSts = RtlNtStatusToDosError(dwSts);
            goto Ret;
        }

        fFreeAnsiString = TRUE;

        cbData = strlen(AnsiString.Buffer) + 1;

        if (*pcbDataLen < cbData || NULL == pbData)
        {
            *pcbDataLen = cbData;

            if (NULL != pbData)
                dwSts = ERROR_MORE_DATA;
            else
                fSuccess = TRUE;

            break;
        }

        *pcbDataLen = cbData;

        strcpy((LPSTR) pbData, AnsiString.Buffer);

        fSuccess = TRUE;
        break;

    case PP_NAME:
        fContinue = FALSE;

        RtlInitUnicodeString(
            &UnicodeString, 
            pLocalCspInfo->wszProviderName);

        dwSts = RtlUnicodeStringToAnsiString(
            &AnsiString,
            &UnicodeString,
            TRUE);

        if (STATUS_SUCCESS != dwSts)
        {
            dwSts = RtlNtStatusToDosError(dwSts);
            goto Ret;
        }

        fFreeAnsiString = TRUE;

        cbData = strlen(AnsiString.Buffer) + 1;

        if (*pcbDataLen < cbData || NULL == pbData)
        {
            *pcbDataLen = cbData;

            if (NULL != pbData)
                dwSts = ERROR_MORE_DATA;
            else
                fSuccess = TRUE;

            break;
        }

        *pcbDataLen = cbData;

        strcpy((LPSTR) pbData, AnsiString.Buffer);

        fSuccess = TRUE;
        break;

    case PP_PROVTYPE:
        fContinue = FALSE;

        if (*pcbDataLen < sizeof(DWORD) || NULL == pbData)
        {
            *pcbDataLen = sizeof(DWORD);

            if (NULL != pbData)
                dwSts = ERROR_MORE_DATA;
            else
                fSuccess = TRUE;

            break;
        }

        *pcbDataLen = sizeof(DWORD);

        memcpy(
            pbData,
            (PBYTE) &pLocalCspInfo->dwProviderType,
            sizeof(DWORD));

        fSuccess = TRUE;
        break;

    case PP_IMPTYPE:
        fContinue = FALSE;
 
        if (*pcbDataLen < sizeof(DWORD) || NULL == pbData)
        {
            *pcbDataLen = sizeof(DWORD);

            if (NULL != pbData)
                dwSts = ERROR_MORE_DATA;
            else
                fSuccess = TRUE;

            break;
        }

        *pcbDataLen = sizeof(DWORD);

        memcpy(
            pbData,
            (PBYTE) &pLocalCspInfo->dwImplementationType,
             sizeof(DWORD));

        fSuccess = TRUE;
        break;
    }

    if (FALSE == fContinue)
        goto Ret;
    
    //
    // Try sending any request that hasn't been filtered by the above checks
    // to the support CSP.
    //
    if (! CryptGetProvParam(
        pUserCtx->hSupportProv,
        dwParam,
        pbData,
        pcbDataLen,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (fFreeAnsiString)
        RtlFreeAnsiString(&AnsiString);
    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}


/*
 -  CPSetHashParam
 -
 *  Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *  Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPSetHashParam(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  DWORD dwParam,
    IN  CONST BYTE *pbData,
    IN  DWORD dwFlags)
{
    BOOL fSuccess = FALSE;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    DWORD dwSts = ERROR_SUCCESS;

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalSetHashParam)
    {
        dwSts = pLocalCspInfo->pfnLocalSetHashParam(
            pHashCtx,
            dwParam,
            (PBYTE) pbData,
            dwFlags,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptSetHashParam(
        pHashCtx->hSupportHash,
        dwParam,
        pbData,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:
    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPGetHashParam
 -
 *  Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a hash
 *
 *  Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPGetHashParam(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  DWORD dwParam,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD dwFlags)
{
    BOOL fSuccess = FALSE;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    DWORD dwSts = ERROR_SUCCESS;

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalGetHashParam)
    {
        dwSts = pLocalCspInfo->pfnLocalGetHashParam(
            pHashCtx,
            dwParam,
            pbData,
            pcbDataLen,
            dwFlags,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptGetHashParam(
        pHashCtx->hSupportHash,
        dwParam,
        pbData,
        pcbDataLen,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:  

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}


/*
 -  CPExportKey
 -
 *  Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *  Parameters:
 *               IN  hProv         - Handle to the CSP user
 *               IN  hKey          - Handle to the key to export
 *               IN  hPubKey       - Handle to exchange public key value of
 *                                   the destination user
 *               IN  dwBlobType    - Type of key blob to be exported
 *               IN  dwFlags       - Flags values
 *               OUT pbData        -     Key blob data
 *               IN OUT pdwDataLen - Length of key blob in bytes
 *
 *  Returns:
 */

BOOL WINAPI
CPExportKey(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  HCRYPTKEY hPubKey,
    IN  DWORD dwBlobType,
    IN  DWORD dwFlags,
    OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen)
{
    BOOL fSuccess = FALSE;
    DWORD dwSts = ERROR_SUCCESS;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = (PKEY_CONTEXT) hKey;
    PKEY_CONTEXT pPubKeyCtx = (PKEY_CONTEXT) hPubKey;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalExportKey)
    {
        dwSts = pLocalCspInfo->pfnLocalExportKey(
            pKeyCtx,
            pPubKeyCtx,
            dwBlobType,
            dwFlags,
            pbData,
            pcbDataLen,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptExportKey(
        pKeyCtx->hSupportKey,
        pPubKeyCtx ? pPubKeyCtx->hSupportKey : 0,
        dwBlobType,
        dwFlags,
        pbData,
        pcbDataLen))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPImportKey
 -
 *  Purpose:
 *                Import cryptographic keys
 *
 *
 *  Parameters:
 *               IN  hProv     -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *  Returns:
 */

BOOL WINAPI
CPImportKey(
    IN  HCRYPTPROV hProv,
    IN  CONST BYTE *pbData,
    IN  DWORD cbDataLen,
    IN  HCRYPTKEY hPubKey,
    IN  DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    BOOL fSuccess = FALSE;
    DWORD dwSts = ERROR_SUCCESS;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = NULL;
    PKEY_CONTEXT pPubKeyCtx = (PKEY_CONTEXT) hPubKey;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    *phKey = 0;

    InitializeLocalCallInfo(&LocalCallInfo);

    pKeyCtx = (PKEY_CONTEXT) CspAllocH(sizeof(KEY_CONTEXT));

    LOG_CHECK_ALLOC(pKeyCtx);

    pKeyCtx->dwFlags = dwFlags & 0x0000ffff;
    pKeyCtx->pUserContext = pUserCtx;

    if (pLocalCspInfo->pfnLocalImportKey)
    {
        dwSts = pLocalCspInfo->pfnLocalImportKey(
            pKeyCtx,
            (PBYTE) pbData,
            cbDataLen,
            pPubKeyCtx,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptImportKey(
        pUserCtx->hSupportProv,
        pbData,
        cbDataLen,
        pPubKeyCtx ? pPubKeyCtx->hSupportKey : 0,
        dwFlags,
        &pKeyCtx->hSupportKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:

    if (TRUE == fSuccess)
    {
        *phKey = (HCRYPTKEY) pKeyCtx;
        pKeyCtx = NULL;
    }

    if (pKeyCtx)
    {
        DeleteKeyContext(pKeyCtx);
        CspFreeH(pKeyCtx);
    }

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPEncrypt
 -
 *  Purpose:
 *                Encrypt data
 *
 *
 *  Parameters:
 *               IN  hProv         -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *  Returns:
 */

BOOL WINAPI
CPEncrypt(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  HCRYPTHASH hHash,
    IN  BOOL fFinal,
    IN  DWORD dwFlags,
    IN OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen,
    IN  DWORD cbBufLen)
{
    BOOL fSuccess = FALSE;
    DWORD dwSts = ERROR_SUCCESS;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = (PKEY_CONTEXT) hKey;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    *pcbDataLen = 0;

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalEncrypt)
    {
        dwSts = pLocalCspInfo->pfnLocalEncrypt(
            pKeyCtx,
            pHashCtx,
            fFinal,
            dwFlags,
            pbData,
            pcbDataLen,
            cbBufLen,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptEncrypt(
        pKeyCtx->hSupportKey,
        pHashCtx ? pHashCtx->hSupportHash : 0,
        fFinal,
        dwFlags,
        pbData,
        pcbDataLen,
        cbBufLen))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;
Ret:

    if (FALSE == fSuccess)
        SetLastError(dwSts);
    
    return fSuccess;
}


/*
 -  CPDecrypt
 -
 *  Purpose:
 *                Decrypt data
 *
 *
 *  Parameters:
 *               IN  hProv         -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *  Returns:
 */

BOOL WINAPI
CPDecrypt(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  HCRYPTHASH hHash,
    IN  BOOL fFinal,
    IN  DWORD dwFlags,
    IN OUT LPBYTE pbData,
    IN OUT LPDWORD pcbDataLen)
{
    BOOL fSuccess = FALSE;
    DWORD dwSts = ERROR_SUCCESS;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = (PKEY_CONTEXT) hKey;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalDecrypt)
    {
        dwSts = pLocalCspInfo->pfnLocalDecrypt(
            pKeyCtx,
            pHashCtx,
            fFinal,
            dwFlags,
            pbData,
            pcbDataLen,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptDecrypt(
        pKeyCtx->hSupportKey,
        pHashCtx ? pHashCtx->hSupportHash : 0,
        fFinal,
        dwFlags,
        pbData,
        pcbDataLen))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;
Ret:

    if (FALSE == fSuccess)
        SetLastError(dwSts);
    
    return fSuccess;
}

/*
 -  CPCreateHash
 -
 *  Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *  Parameters:
 *               IN  hUID    -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey   -   Optional handle to a key
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *  Returns:
 */

BOOL WINAPI
CPCreateHash(
    IN  HCRYPTPROV hProv,
    IN  ALG_ID Algid,
    IN  HCRYPTKEY hKey,
    IN  DWORD dwFlags,
    OUT HCRYPTHASH *phHash)
{
    BOOL fSuccess = FALSE;
    PHASH_CONTEXT pHashCtx = NULL;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = (PKEY_CONTEXT) hKey;
    DWORD dwSts = ERROR_SUCCESS;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    *phHash = 0;

    InitializeLocalCallInfo(&LocalCallInfo);

    pHashCtx = (PHASH_CONTEXT) CspAllocH(sizeof(HASH_CONTEXT));

    LOG_CHECK_ALLOC(pHashCtx);

    pHashCtx->Algid = Algid;
    pHashCtx->dwFlags = dwFlags;
    pHashCtx->pUserContext = pUserCtx;

    if (pLocalCspInfo->pfnLocalCreateHash)
    {
        dwSts = pLocalCspInfo->pfnLocalCreateHash(
            pHashCtx,
            pKeyCtx,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptCreateHash(
        pUserCtx->hSupportProv,
        Algid,  
        pKeyCtx ? pKeyCtx->hSupportKey : 0,
        dwFlags,
        &pHashCtx->hSupportHash))
    {
        dwSts = GetLastError();
        goto Ret;
    }
    
    *phHash = (HCRYPTHASH) pHashCtx;
    pHashCtx = NULL;

    fSuccess = TRUE;

Ret:
    if (pHashCtx)
    {
        DeleteHashContext(pHashCtx);
        CspFreeH(pHashCtx);
    }

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}


/*
 -  CPHashData
 -
 *  Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *  Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPHashData(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  CONST BYTE *pbData,
    IN  DWORD cbDataLen,
    IN  DWORD dwFlags)
{
    BOOL fSuccess = FALSE;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    DWORD dwSts = ERROR_SUCCESS;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalHashData)
    {
        dwSts = pLocalCspInfo->pfnLocalHashData(
            pHashCtx,
            pbData,
            cbDataLen,
            dwFlags,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptHashData(
        pHashCtx->hSupportHash,
        pbData,
        cbDataLen,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPHashSessionKey
 -
 *  Purpose:
 *                Compute the cryptograghic hash on a key object.
 *
 *
 *  Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *  Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */

BOOL WINAPI
CPHashSessionKey(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  HCRYPTKEY hKey,
    IN  DWORD dwFlags)
{
    BOOL fSuccess = FALSE;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = (PKEY_CONTEXT) hKey;
    DWORD dwSts = ERROR_SUCCESS;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalHashSessionKey)
    {
        dwSts = pLocalCspInfo->pfnLocalHashSessionKey(
            pHashCtx,
            pKeyCtx,
            dwFlags,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptHashSessionKey(
        pHashCtx->hSupportHash,
        pKeyCtx ? pKeyCtx->hSupportKey : 0,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPSignHash
 -
 *  Purpose:
 *                Create a digital signature from a hash
 *
 *
 *  Parameters:
 *               IN  hProv        -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair to that is used to sign with
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignature  -  Pointer to signature data
 *               IN OUT dwHashLen -  Pointer to the len of the signature data
 *
 *  Returns:
 */

BOOL WINAPI
CPSignHash(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  DWORD dwKeySpec,
    IN  LPCWSTR szDescription,
    IN  DWORD dwFlags,
    OUT LPBYTE pbSignature,
    IN OUT LPDWORD pcbSigLen)
{
    BOOL fSuccess = FALSE;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    DWORD dwSts = ERROR_SUCCESS;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalSignHash)
    {
        dwSts = pLocalCspInfo->pfnLocalSignHash(
            pHashCtx,
            dwKeySpec,
            dwFlags,
            pbSignature,
            pcbSigLen,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptSignHash(
        pHashCtx->hSupportHash,
        dwKeySpec,
        NULL,
        dwFlags,
        pbSignature,
        pcbSigLen))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPDestroyHash
 -
 *  Purpose:
 *                Destroy the hash object
 *
 *
 *  Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *
 *  Returns:
 */

BOOL WINAPI
CPDestroyHash(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash)
{
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    DWORD dwSts = ERROR_SUCCESS;

    dwSts = DeleteHashContext(pHashCtx);

    CspFreeH(pHashCtx);

    if (ERROR_SUCCESS != dwSts)
        SetLastError(dwSts);

    return (ERROR_SUCCESS == dwSts);
}

/*
 -  CPVerifySignature
 -
 *  Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *  Parameters:
 *               IN  hProv        -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *  Returns:
 */

BOOL WINAPI
CPVerifySignature(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  CONST BYTE *pbSignature,
    IN  DWORD cbSigLen,
    IN  HCRYPTKEY hPubKey,
    IN  LPCWSTR szDescription,
    IN  DWORD dwFlags)
{
    BOOL fSuccess = FALSE;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pPubKeyCtx = (PKEY_CONTEXT) hPubKey;
    DWORD dwSts = ERROR_SUCCESS;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalVerifySignature)
    {
        dwSts = pLocalCspInfo->pfnLocalVerifySignature(
            pHashCtx,
            pbSignature,
            cbSigLen,
            pPubKeyCtx,
            dwFlags,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptVerifySignature(
        pHashCtx->hSupportHash,
        pbSignature,
        cbSigLen,
        pPubKeyCtx->hSupportKey,
        NULL,
        dwFlags))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPGenRandom
 -
 *  Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *  Parameters:
 *               IN  hProv         -  Handle to the user identifcation
 *               IN  dwLen         -  Number of bytes of random data requested
 *               IN OUT pbBuffer   -  Pointer to the buffer where the random
 *                                    bytes are to be placed
 *
 *  Returns:
 */

BOOL WINAPI
CPGenRandom(
    IN  HCRYPTPROV hProv,
    IN  DWORD cbLen,
    OUT LPBYTE pbBuffer)
{
    BOOL fSuccess = FALSE;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    DWORD dwSts = ERROR_SUCCESS;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    InitializeLocalCallInfo(&LocalCallInfo);

    if (pLocalCspInfo->pfnLocalGenRandom)
    {
        dwSts = pLocalCspInfo->pfnLocalGenRandom(
            pUserCtx,
            cbLen,
            pbBuffer,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptGenRandom(
        pUserCtx->hSupportProv,
        cbLen,
        pbBuffer))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPGetUserKey
 -
 *  Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *  Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwKeySpec  -  Specification of the key to retrieve
 *               OUT phUserKey  -  Pointer to key handle of retrieved key
 *
 *  Returns:
 */

BOOL WINAPI
CPGetUserKey(
    IN  HCRYPTPROV hProv,
    IN  DWORD dwKeySpec,
    OUT HCRYPTKEY *phUserKey)
{
    BOOL fSuccess = FALSE;
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = NULL;
    DWORD dwSts = ERROR_SUCCESS;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    *phUserKey = 0;

    InitializeLocalCallInfo(&LocalCallInfo);

    pKeyCtx = (PKEY_CONTEXT) CspAllocH(sizeof(KEY_CONTEXT));

    LOG_CHECK_ALLOC(pKeyCtx);

    pKeyCtx->Algid = dwKeySpec;
    pKeyCtx->pUserContext = pUserCtx;

    if (pLocalCspInfo->pfnLocalGetUserKey)
    {
        dwSts = pLocalCspInfo->pfnLocalGetUserKey(
            pKeyCtx,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptGetUserKey(
        pUserCtx->hSupportProv,
        dwKeySpec,
        &pKeyCtx->hSupportKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    fSuccess = TRUE;

Ret:
    if (fSuccess)
    {
        *phUserKey = (HCRYPTKEY) pKeyCtx;
        pKeyCtx = NULL;
    }

    if (pKeyCtx)
    {
        DeleteKeyContext(pKeyCtx);
        CspFreeH(pKeyCtx);
    }

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

/*
 -  CPDuplicateHash
 -
 *  Purpose:
 *                Duplicates the state of a hash and returns a handle to it.
 *                This is an optional entry.  Typically it only occurs in
 *                SChannel related CSPs.
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hHash          -  Handle to a hash
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phHash         -  Handle to the new hash
 *
 *  Returns:
 */

BOOL WINAPI
CPDuplicateHash(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTHASH hHash,
    IN  LPDWORD pdwReserved,
    IN  DWORD dwFlags,
    OUT HCRYPTHASH *phHash)
{
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PHASH_CONTEXT pHashCtx = (PHASH_CONTEXT) hHash;
    PHASH_CONTEXT pNewHashCtx = NULL;
    DWORD dwSts = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();
    LOCAL_CALL_INFO LocalCallInfo;

    *phHash = 0;

    InitializeLocalCallInfo(&LocalCallInfo);

    pNewHashCtx = (PHASH_CONTEXT) CspAllocH(sizeof(HASH_CONTEXT));

    LOG_CHECK_ALLOC(pNewHashCtx);

    pNewHashCtx->pUserContext = pUserCtx;
    pNewHashCtx->dwFlags = dwFlags;

    if (pLocalCspInfo->pfnLocalDuplicateHash)
    {
        dwSts = pLocalCspInfo->pfnLocalDuplicateHash(
            pHashCtx,
            pdwReserved,
            pNewHashCtx,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptDuplicateHash(
        pHashCtx->hSupportHash,
        pdwReserved,
        dwFlags,
        &pNewHashCtx->hSupportHash))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    *phHash = (HCRYPTHASH) pNewHashCtx;
    pNewHashCtx = NULL;

    fSuccess = TRUE;

Ret:
    if (pNewHashCtx)
    {
        DeleteHashContext(pNewHashCtx);
        CspFreeH(pNewHashCtx);
    }

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}


/*
 -  CPDuplicateKey
 -
 *  Purpose:
 *                Duplicates the state of a key and returns a handle to it.
 *                This is an optional entry.  Typically it only occurs in
 *                SChannel related CSPs.
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hKey           -  Handle to a key
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phKey          -  Handle to the new key
 *
 *  Returns:
 */

BOOL WINAPI
CPDuplicateKey(
    IN  HCRYPTPROV hProv,
    IN  HCRYPTKEY hKey,
    IN  LPDWORD pdwReserved,
    IN  DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    PUSER_CONTEXT pUserCtx = (PUSER_CONTEXT) hProv;
    PKEY_CONTEXT pKeyCtx = (PKEY_CONTEXT) hKey;
    PKEY_CONTEXT pNewKeyCtx = NULL;
    BOOL fSuccess = FALSE;
    DWORD dwSts = ERROR_SUCCESS;
    LOCAL_CALL_INFO LocalCallInfo;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    *phKey = 0;

    InitializeLocalCallInfo(&LocalCallInfo);

    pNewKeyCtx = (PKEY_CONTEXT) CspAllocH(sizeof(KEY_CONTEXT));

    LOG_CHECK_ALLOC(pNewKeyCtx);
    
    pNewKeyCtx->pUserContext = pUserCtx;
    pNewKeyCtx->dwFlags = dwFlags;

    if (pLocalCspInfo->pfnLocalDuplicateKey)
    {
        dwSts = pLocalCspInfo->pfnLocalDuplicateKey(
            pKeyCtx,
            pdwReserved,
            pNewKeyCtx,
            &LocalCallInfo);

        if (! CheckLocalCallInfo(&LocalCallInfo, dwSts, &fSuccess))
            goto Ret;
    }

    if (! CryptDuplicateKey(
        pKeyCtx->hSupportKey,
        pdwReserved,
        dwFlags,
        &pNewKeyCtx->hSupportKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    *phKey = (HCRYPTKEY) pNewKeyCtx;
    pNewKeyCtx = NULL;

    fSuccess = TRUE;

Ret:
    if (pNewKeyCtx)
    {
        DeleteKeyContext(pNewKeyCtx);
        CspFreeH(pNewKeyCtx);
    }

    if (FALSE == fSuccess)
        SetLastError(dwSts);

    return fSuccess;
}

//
// Function: DllInitialize
//
BOOL WINAPI
DllInitialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context)    // Unused parameter
{
    DWORD dwLen = 0;
    static BOOL fLoadedStrings = FALSE;
    static BOOL fInitializedCspState = FALSE;
    BOOL fSuccess = FALSE;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:

        // Get our image name.
        dwLen = GetModuleBaseName(
            GetCurrentProcess(),
            hmod,
            l_szImagePath, 
            sizeof(l_szImagePath) / sizeof(l_szImagePath[0]));

        if (0 == dwLen)
             return FALSE;

        DisableThreadLibraryCalls(hmod);

        fSuccess = TRUE;

        break;

    case DLL_PROCESS_DETACH:
        fSuccess = TRUE;

        break;
    }   

    if (pLocalCspInfo->pfnLocalDllInitialize)
    {
        fSuccess = pLocalCspInfo->pfnLocalDllInitialize(
            hmod, Reason, Context);
    }

    return fSuccess;
}

//
// Function: DllRegisterServer
//
STDAPI
DllRegisterServer(
    void)
{         
    HKEY    hKey = 0;
    DWORD   dwVal = 0;
    DWORD   dwProvType = PROV_RSA_FULL;
    DWORD   dwSts = ERROR_SUCCESS;
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    dwSts = RegOpenProviderKey(&hKey, KEY_ALL_ACCESS);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Set Image path
    //
    dwSts = RegSetValueExA(hKey, "Image Path", 0L, REG_SZ,
                          (LPBYTE) l_szImagePath, 
                          strlen(l_szImagePath) + 1);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Set Type
    //
    dwSts = RegSetValueExA(hKey, "Type", 0L, REG_DWORD,
                          (LPBYTE) &pLocalCspInfo->dwProviderType,
                          sizeof(DWORD));

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Place signature in file value
    //
    dwSts = RegSetValueExA(hKey, "SigInFile", 0L,
                          REG_DWORD, (LPBYTE)&dwVal,
                          sizeof(DWORD));

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Add CSP default configuration
    //
    if (pLocalCspInfo->pfnLocalDllRegisterServer)
        dwSts = pLocalCspInfo->pfnLocalDllRegisterServer();

Ret:
    if (hKey)
        RegCloseKey(hKey);
    
    return dwSts;
}

//
// Function: DllUnregisterServer
//
STDAPI
DllUnregisterServer(
    void)
{
    PLOCAL_CSP_INFO pLocalCspInfo = GetLocalCspInfo();

    if (pLocalCspInfo->pfnLocalDllUnregisterServer)
        return pLocalCspInfo->pfnLocalDllUnregisterServer();
    else
        return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\cardmod.h ===
#ifndef __CARDMOD__H__
#define __CARDMOD__H__

#include <windows.h>
#include <wincrypt.h>
#include <winscard.h>
#include "pincache.h"

typedef struct _CARD_DATA CARD_DATA, *PCARD_DATA;

//
// This define can be used as a return value for queries involving
// card data that may be impossible to determine on a given card
// OS, such as the number of available card storage bytes.
//
#define CARD_DATA_VALUE_UNKNOWN                     ((DWORD) -1)

//
// Well Known Logical Names
//

//
// Logical Directory Names
//

// Second-level logical directories 
#define wszCSP_DATA_DIR                             L"CSP"
#define wszCSP_DATA_DIR_FULL_PATH                   L"/Microsoft/CSP"

#define wszROOT_CERTS_DIR                           L"RootCerts"
#define wszROOT_CERTS_DIR_FULL_PATH                 L"/Microsoft/RootCerts"

#define wszINTERMEDIATE_CERTS_DIR                   L"IntermediateCerts"
#define wszINTERMEDIATE_CERTS_DIR_FULL_PATH         L"/Microsoft/IntermediateCerts"

//
// Logical File Names
//
// When requesting (or otherwise referring to) any logical file, the full path
// must be used, including when referring to well known files.  For example,
// to request the wszCONTAINER_MAP_FILE, the provided name will be
// "/Microsoft/CSP/ContainerMapFile".
//

// Well known logical files under Microsoft
#define wszCACHE_FILE                               L"CacheFile"
#define wszCACHE_FILE_FULL_PATH                     L"/Microsoft/CacheFile"

#define wszCARD_IDENTIFIER_FILE                     L"CardIdentifierFile"
#define wszCARD_IDENTIFIER_FILE_FULL_PATH           L"/Microsoft/CardIdentifierFile"

#define wszPERSONAL_DATA_FILE                       L"CardPersonalDataFile"
#define wszPERSONAL_DATA_FILE_FULL_PATH             L"/Microsoft/CardPersonalDataFile"

// Well known logical files under CSP 
#define wszCONTAINER_MAP_FILE                       L"ContainerMapFile"
#define wszCONTAINER_MAP_FILE_FULL_PATH             L"/Microsoft/CSP/ContainerMapFile"

//
// Well known logical files under User Certs
//
// The following prefixes are appended with the container index of the 
// associated key.  For example, the certificate associated with the
// Key Exchange key in container index 2 will have the logical name:
//  "/Microsoft/CSP/UserCerts/K2"
//
#define wszUSER_SIGNATURE_CERT_PREFIX               L"/Microsoft/CSP/UserCerts/S"
#define wszUSER_KEYEXCHANGE_CERT_PREFIX             L"/Microsoft/CSP/UserCerts/K"

//
// Logical Card User Names
//
#define wszCARD_USER_EVERYONE                       L"Everyone"
#define wszCARD_USER_USER                           L"User"
#define wszCARD_USER_ADMIN                          L"Administrator"

//
// Converts a card filename string from unicode to ansi
//
DWORD WINAPI I_CardConvertFileNameToAnsi(
    IN PCARD_DATA pCardData,
    IN LPWSTR wszUnicodeName,
    OUT LPSTR *ppszAnsiName);

// Logical File Access Conditions
typedef enum 
{
    InvalidAc = 0,

    // Everyone Read
    // User Write
    //
    // Example:  A user certificate file.
    EveryoneReadUserWriteAc,

    // User Read, Write
    //
    // Example:  A private key file.
    UserWriteExecuteAc,        

    // Everyone Read
    // Admin Write
    //
    // Example:  The Card Identifier file.
    EveryoneReadAdminWriteAc       
    
} CARD_FILE_ACCESS_CONDITION;

//
// Function: CardAcquireContext
//
// Purpose: Initialize the CARD_DATA structure which will be used by 
//          the CSP to interact with a specific card.
//  
typedef DWORD (WINAPI *PFN_CARD_ACQUIRE_CONTEXT)(
    IN OUT  PCARD_DATA  pCardData,
    IN      DWORD       dwFlags);

DWORD 
WINAPI
CardAcquireContext(
    IN OUT  PCARD_DATA  pCardData,
    IN      DWORD       dwFlags);

//
// Function: CardDeleteContext
//
// Purpose: Free resources consumed by the CARD_DATA structure.
//
typedef DWORD (WINAPI *PFN_CARD_DELETE_CONTEXT)(
    OUT     PCARD_DATA  pCardData);

DWORD
WINAPI
CardDeleteContext(
    OUT     PCARD_DATA  pCardData);

// 
// Function: CardQueryCapabilities
//
// Purpose: Query the card module for specific functionality
//          provided by this card.
//
#define CARD_CAPABILITIES_CURRENT_VERSION 1

typedef struct _CARD_CAPABILITIES
{
    DWORD   dwVersion;
    BOOL    fCertificateCompression;
    BOOL    fKeyGen;

} CARD_CAPABILITIES, *PCARD_CAPABILITIES;

typedef DWORD (WINAPI *PFN_CARD_QUERY_CAPABILITIES)(
    IN      PCARD_DATA          pCardData,
    IN OUT  PCARD_CAPABILITIES  pCardCapabilities);

DWORD
WINAPI
CardQueryCapabilities(
    IN      PCARD_DATA          pCardData,
    IN OUT  PCARD_CAPABILITIES  pCardCapabilities);

//
// Function: CardDeleteContainer
//
// Purpose: Delete the specified key container.
// 
typedef DWORD (WINAPI *PFN_CARD_DELETE_CONTAINER)(
    IN      PCARD_DATA  pCardData,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwReserved);

DWORD
WINAPI
CardDeleteContainer(
    IN      PCARD_DATA  pCardData,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwReserved);

//
// Function: CardCreateContainer
//

#define CARD_CREATE_CONTAINER_KEY_GEN           1
#define CARD_CREATE_CONTAINER_KEY_IMPORT        2

typedef DWORD (WINAPI *PFN_CARD_CREATE_CONTAINER)(
    IN      PCARD_DATA  pCardData,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwKeySize,
    IN      PBYTE       pbKeyData);

DWORD
WINAPI
CardCreateContainer(
    IN      PCARD_DATA  pCardData,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwKeySize,
    IN      PBYTE       pbKeyData);

//
// Function: CardGetContainerInfo
//
// Purpose: Query for all public information available about
//          the named key container.  This includes the Signature
//          and Key Exchange type public keys, if they exist.
//
//          The pbSigPublicKey and pbKeyExPublicKey buffers contain the 
//          Signature and Key Exchange public keys, respectively, if they 
//          exist.  The format of these buffers is a Crypto 
//          API PUBLICKEYBLOB -
//
//              BLOBHEADER
//              RSAPUBKEY
//              modulus
//
#define CONTAINER_INFO_CURRENT_VERSION 1

typedef struct _CONTAINER_INFO
{
    DWORD dwVersion;
    DWORD dwContainerInfo;

    DWORD cbSigPublicKey;
    PBYTE pbSigPublicKey;

    DWORD cbKeyExPublicKey;
    PBYTE pbKeyExPublicKey;

} CONTAINER_INFO, *PCONTAINER_INFO;

typedef DWORD (WINAPI *PFN_CARD_GET_CONTAINER_INFO)(
    IN      PCARD_DATA  pCardData,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN OUT  PCONTAINER_INFO pContainerInfo);

DWORD
WINAPI
CardGetContainerInfo(
    IN      PCARD_DATA  pCardData,
    IN      BYTE        bContainerIndex,
    IN      DWORD       dwFlags,
    IN OUT  PCONTAINER_INFO pContainerInfo);

// 
// Function: CardSubmitPin
//
typedef DWORD (WINAPI *PFN_CARD_SUBMIT_PIN)(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,
    IN      PBYTE       pbPin,
    IN      DWORD       cbPin,
    OUT OPTIONAL PDWORD pcAttemptsRemaining);
    

DWORD
WINAPI
CardSubmitPin(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,
    IN      PBYTE       pbPin,
    IN      DWORD       cbPin,
    OUT OPTIONAL PDWORD pcAttemptsRemaining);

//
// Function: CardGetChallenge
//
typedef DWORD (WINAPI *PFN_CARD_GET_CHALLENGE)(
    IN      PCARD_DATA  pCardData,
    OUT     PBYTE       *ppbChallengeData,
    OUT     PDWORD      pcbChallengeData);

DWORD 
WINAPI 
CardGetChallenge(
    IN      PCARD_DATA  pCardData,
    OUT     PBYTE       *ppbChallengeData,
    OUT     PDWORD      pcbChallengeData);

//
// Function: CardAuthenticateChallenge
//
typedef DWORD (WINAPI *PFN_CARD_AUTHENTICATE_CHALLENGE)(
    IN      PCARD_DATA  pCardData,
    IN      PBYTE       pbResponseData,
    IN      DWORD       cbResponseData,
    OUT OPTIONAL PDWORD pcAttemptsRemaining);

DWORD 
WINAPI 
CardAuthenticateChallenge(
    IN      PCARD_DATA  pCardData,
    IN      PBYTE       pbResponseData,
    IN      DWORD       cbResponseData,
    OUT OPTIONAL PDWORD pcAttemptsRemaining);

//
// Function: CardUnblockPin
//
#define CARD_UNBLOCK_PIN_CHALLENGE_RESPONSE                 1
#define CARD_UNBLOCK_PIN_PIN                                2

typedef DWORD (WINAPI *PFN_CARD_UNBLOCK_PIN)(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,         
    IN      PBYTE       pbAuthenticationData,
    IN      DWORD       cbAuthenticationData,
    IN      PBYTE       pbNewPinData,
    IN      DWORD       cbNewPinData,
    IN      DWORD       cRetryCount,
    IN      DWORD       dwFlags);

DWORD 
WINAPI 
CardUnblockPin(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,         
    IN      PBYTE       pbAuthenticationData,
    IN      DWORD       cbAuthenticationData,
    IN      PBYTE       pbNewPinData,
    IN      DWORD       cbNewPinData,
    IN      DWORD       cRetryCount,
    IN      DWORD       dwFlags);

//
// Function: CardChangeAuthenticator
//
typedef DWORD (WINAPI *PFN_CARD_CHANGE_AUTHENTICATOR)(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,         
    IN      PBYTE       pbCurrentAuthenticator,
    IN      DWORD       cbCurrentAuthenticator,
    IN      PBYTE       pbNewAuthenticator,
    IN      DWORD       cbNewAuthenticator,
    IN      DWORD       cRetryCount,
    OUT OPTIONAL PDWORD pcAttemptsRemaining);

DWORD 
WINAPI 
CardChangeAuthenticator(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,         
    IN      PBYTE       pbCurrentAuthenticator,
    IN      DWORD       cbCurrentAuthenticator,
    IN      PBYTE       pbNewAuthenticator,
    IN      DWORD       cbNewAuthenticator,
    IN      DWORD       cRetryCount,
    OUT OPTIONAL PDWORD pcAttemptsRemaining);

//
// Function: CardDeauthenticate
//
// Purpose: De-authenticate the specified logical user name on the card.
//
// This is an optional API.  If implemented, this API is used instead
// of SCARD_RESET_CARD by the Base CSP.  An example scenario is leaving
// a transaction in which the card has been authenticated (a Pin has been
// successfully presented).
//
// The pwszUserId parameter will point to a valid well-known User Name (see
// above).
//
// The dwFlags parameter is currently unused and will always be zero.
//
// Card modules that choose to not implement this API must set the CARD_DATA
// pfnCardDeauthenticate pointer to NULL.
//
typedef DWORD (WINAPI *PFN_CARD_DEAUTHENTICATE)(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,
    IN      DWORD       dwFlags);

DWORD
WINAPI
CardDeauthenticate(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszUserId,
    IN      DWORD       dwFlags);

//
// Function: CardCreateFile
//
typedef DWORD (WINAPI *PFN_CARD_CREATE_FILE)(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    IN      CARD_FILE_ACCESS_CONDITION AccessCondition);

DWORD
WINAPI
CardCreateFile(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    IN      CARD_FILE_ACCESS_CONDITION AccessCondition);

//
// Function: CardReadFile
//
// Purpose: Read the specified file from the card.
//
//          The pbData parameter should be allocated 
//          by the card module and freed by the CSP.  The card module 
//          must set the cbData parameter to the size of the returned buffer.
//
typedef DWORD (WINAPI *PFN_CARD_READ_FILE)(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    OUT     PBYTE       *ppbData,
    OUT     PDWORD      pcbData);

DWORD 
WINAPI
CardReadFile(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    OUT     PBYTE       *ppbData,
    OUT     PDWORD      pcbData);

//
// Function: CardWriteFile
//
typedef DWORD (WINAPI *PFN_CARD_WRITE_FILE)(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData);

DWORD
WINAPI
CardWriteFile(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData);

//
// Function: CardDeleteFile
//
typedef DWORD (WINAPI *PFN_CARD_DELETE_FILE)(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwReserved,
    IN      LPWSTR      pwszFileName);

DWORD
WINAPI
CardDeleteFile(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwReserved,
    IN      LPWSTR      pwszFileName);

//
// Function: CardEnumFiles
//
// Purpose: Return a multi-string list of the general files
//          present on this card.  The multi-string is allocated
//          by the card module and must be freed by the CSP.
//
//  The caller must provide a logical file directory name in the 
//  pmwszFileNames parameter (see Logical Directory Names, above).
//  The logical directory name indicates which group of files will be
//  enumerated.  
//
//  The logical directory name is expected to be a static string, so the
//  the card module will not free it.  The card module
//  will allocate a new buffer in *pmwszFileNames to store the multi-string 
//  list of enumerated files using pCardData->pfnCspAlloc.
//
//  If the function fails for any reason, *pmwszFileNames is set to NULL.
//
typedef DWORD (WINAPI *PFN_CARD_ENUM_FILES)(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwFlags,
    IN OUT  LPWSTR      *pmwszFileNames);

DWORD
WINAPI
CardEnumFiles(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwFlags,
    IN OUT  LPWSTR      *pmwszFileNames);

//
// Function: CardGetFileInfo
//
#define CARD_FILE_INFO_CURRENT_VERSION 1

typedef struct _CARD_FILE_INFO
{
    DWORD dwVersion;
    DWORD cbFileSize;
    CARD_FILE_ACCESS_CONDITION AccessCondition;
} CARD_FILE_INFO, *PCARD_FILE_INFO;

typedef DWORD (WINAPI *PFN_CARD_GET_FILE_INFO)(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    OUT     PCARD_FILE_INFO pCardFileInfo);

DWORD
WINAPI
CardGetFileInfo(
    IN      PCARD_DATA  pCardData,
    IN      LPWSTR      pwszFileName,
    OUT     PCARD_FILE_INFO pCardFileInfo);

//
// Function: CardQueryFreeSpace
//                                         
#define CARD_FREE_SPACE_INFO_CURRENT_VERSION 1

typedef struct _CARD_FREE_SPACE_INFO
{
    DWORD dwVersion;
    DWORD dwBytesAvailable;
    DWORD dwKeyContainersAvailable;
    DWORD dwMaxKeyContainers;

} CARD_FREE_SPACE_INFO, *PCARD_FREE_SPACE_INFO;

typedef DWORD (WINAPI *PFN_CARD_QUERY_FREE_SPACE)(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwFlags,
    OUT     PCARD_FREE_SPACE_INFO pCardFreeSpaceInfo);

DWORD
WINAPI
CardQueryFreeSpace(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwFlags,
    OUT     PCARD_FREE_SPACE_INFO pCardFreeSpaceInfo);

//
// Function: CardPrivateKeyDecrypt
//
// Purpose: Perform a private key decryption on the supplied data.  The
//          card module should assume that pbData is the length of the
//          key modulus.
//
#define CARD_PRIVATE_KEY_DECRYPT_INFO_CURRENT_VERSION 1

typedef struct _CARD_PRIVATE_KEY_DECRYPT_INFO
{
    DWORD dwVersion;            // IN
    
    BYTE bContainerIndex;       // IN
    
    // For RSA operations, this should be AT_SIGNATURE or AT_KEYEXCHANGE.
    DWORD dwKeySpec;            // IN

    // This is the buffer and length that the caller expects to be decrypted.
    // For RSA operations, cbData is redundant since the length of the buffer
    // should always be equal to the length of the key modulus.
    PBYTE pbData;               // IN | OUT
    DWORD cbData;               // IN | OUT

} CARD_PRIVATE_KEY_DECRYPT_INFO, *PCARD_PRIVATE_KEY_DECRYPT_INFO;

typedef DWORD (WINAPI *PFN_CARD_PRIVATE_KEY_DECRYPT)(
    IN      PCARD_DATA                      pCardData,
    IN OUT  PCARD_PRIVATE_KEY_DECRYPT_INFO  pInfo);

DWORD
WINAPI
CardPrivateKeyDecrypt(
    IN      PCARD_DATA                      pCardData,
    IN OUT  PCARD_PRIVATE_KEY_DECRYPT_INFO  pInfo);

//
// Function: CardQueryKeySizes
//
#define CARD_KEY_SIZES_CURRENT_VERSION 1

typedef struct _CARD_KEY_SIZES
{
    DWORD dwVersion;

    DWORD dwMinimumBitlen;
    DWORD dwDefaultBitlen;
    DWORD dwMaximumBitlen;
    DWORD dwIncrementalBitlen;

} CARD_KEY_SIZES, *PCARD_KEY_SIZES;

typedef DWORD (WINAPI *PFN_CARD_QUERY_KEY_SIZES)(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwReserved,
    OUT     PCARD_KEY_SIZES pKeySizes);

DWORD
WINAPI
CardQueryKeySizes(
    IN      PCARD_DATA  pCardData,
    IN      DWORD       dwKeySpec,
    IN      DWORD       dwReserved,
    OUT     PCARD_KEY_SIZES pKeySizes);

//
// Memory Management Routines
//
// These routines are supplied to the card module
// by the calling CSP.
//

//
// Function: PFN_CSP_ALLOC
//
typedef LPVOID (WINAPI *PFN_CSP_ALLOC)(
    IN      SIZE_T      Size);

//
// Function: PFN_CSP_REALLOC
//
typedef LPVOID (WINAPI *PFN_CSP_REALLOC)(
    IN      LPVOID      Address,
    IN      SIZE_T      Size);

//
// Function: PFN_CSP_FREE
//
// Note: Data allocated for the CSP by the card module must
//       be freed by the CSP.  
//
typedef void (WINAPI *PFN_CSP_FREE)(
    IN      LPVOID      Address);

//
// Function: PFN_CSP_CACHE_ADD_FILE
//
// A copy of the pbData parameter is added to the cache.
//
typedef DWORD (WINAPI *PFN_CSP_CACHE_ADD_FILE)(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData);

//
// Function: PFN_CSP_CACHE_LOOKUP_FILE
//
// If the cache lookup is successful,
// the caller must free the *ppbData pointer with pfnCspFree.
//
typedef DWORD (WINAPI *PFN_CSP_CACHE_LOOKUP_FILE)(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       *ppbData,
    IN      PDWORD      pcbData);

//
// Function: PFN_CSP_CACHE_DELETE_FILE
//
// Deletes the specified item from the cache.
//
typedef DWORD (WINAPI *PFN_CSP_CACHE_DELETE_FILE)(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags);

//
// Type: CARD_DATA
//

#define CARD_DATA_CURRENT_VERSION 1

typedef struct _CARD_DATA
{
    // These members must be initialized by the CSP before
    // calling CardAcquireContext.

    DWORD                           dwVersion;

    PBYTE                           pbAtr;
    DWORD                           cbAtr;
    LPWSTR                          pwszCardName;

    PFN_CSP_ALLOC                   pfnCspAlloc;
    PFN_CSP_REALLOC                 pfnCspReAlloc;
    PFN_CSP_FREE                    pfnCspFree;

    PFN_CSP_CACHE_ADD_FILE          pfnCspCacheAddFile;
    PFN_CSP_CACHE_LOOKUP_FILE       pfnCspCacheLookupFile;
    PFN_CSP_CACHE_DELETE_FILE       pfnCspCacheDeleteFile;
    PVOID                           pvCacheContext;

    SCARDCONTEXT                    hSCardCtx;
    SCARDHANDLE                     hScard;

    // These members are initialized by the card module

    PFN_CARD_DELETE_CONTEXT         pfnCardDeleteContext;
    PFN_CARD_QUERY_CAPABILITIES     pfnCardQueryCapabilities;
    PFN_CARD_DELETE_CONTAINER       pfnCardDeleteContainer;
    PFN_CARD_CREATE_CONTAINER       pfnCardCreateContainer;
    PFN_CARD_GET_CONTAINER_INFO     pfnCardGetContainerInfo;
    PFN_CARD_SUBMIT_PIN             pfnCardSubmitPin;
    PFN_CARD_GET_CHALLENGE          pfnCardGetChallenge;
    PFN_CARD_AUTHENTICATE_CHALLENGE pfnCardAuthenticateChallenge;
    PFN_CARD_UNBLOCK_PIN            pfnCardUnblockPin;
    PFN_CARD_CHANGE_AUTHENTICATOR   pfnCardChangeAuthenticator;
    PFN_CARD_DEAUTHENTICATE         pfnCardDeauthenticate;
    PFN_CARD_CREATE_FILE            pfnCardCreateFile;
    PFN_CARD_READ_FILE              pfnCardReadFile;
    PFN_CARD_WRITE_FILE             pfnCardWriteFile;
    PFN_CARD_DELETE_FILE            pfnCardDeleteFile;
    PFN_CARD_ENUM_FILES             pfnCardEnumFiles;
    PFN_CARD_GET_FILE_INFO          pfnCardGetFileInfo;
    PFN_CARD_QUERY_FREE_SPACE       pfnCardQueryFreeSpace;
    PFN_CARD_PRIVATE_KEY_DECRYPT    pfnCardPrivateKeyDecrypt;
    PFN_CARD_QUERY_KEY_SIZES        pfnCardQueryKeySizes;

    PVOID                           pvVendorSpecific;

} CARD_DATA, *PCARD_DATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\debug.h ===
#ifndef __BASECSP__DEBUG__H
#define __BASECSP__DEBUG__H

#include <windows.h>
#include <dsysdbg.h>

// 
// Debug Support
//
// This uses the debug routines from dsysdbg.h
// Debug output will only be available in chk
// bits.
//

DECLARE_DEBUG2(Basecsp)

#define DEB_TRACE_CSP           0x00000001
#define DEB_TRACE_FINDCARD      0x00000002
#define DEB_TRACE_CACHE         0x00000004
#define DEB_TRACE_MEM           0x00000008
#define DEB_TRACE_CRYPTOAPI     0x00000010

#if DBG
#define DebugLog(x)     BasecspDebugPrint x
#else
#define DebugLog(x)
#endif

#define LOG_CHECK_ALLOC(x)                                              \
    { if (NULL == x) {                                                  \
        dwSts = ERROR_NOT_ENOUGH_MEMORY;                                \
        DebugLog((DEB_TRACE_MEM, "%s: Allocation failed\n", #x));       \
        goto Ret;                                                       \
    } }
    
void CspInitializeDebug(void);

void CspUnloadDebug(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\datacach.h ===
#ifndef __CSP_DATA_CACHE__
#define __CSP_DATA_CACHE__

#include <windows.h>
#include <wincrypt.h>

typedef ULONG_PTR CACHEHANDLE;

DWORD CacheFreeEnumItems(
    IN PDATA_BLOB pdbItems);

DWORD CacheEnumItems(
    IN CACHEHANDLE hCache,
    OUT PDATA_BLOB *ppdbItems,
    OUT PDWORD pcItems);

DWORD CacheGetItem(
	IN CACHEHANDLE hCache,
	IN PDATA_BLOB mpdbKeys,
	IN DWORD cKeys,
	OUT PDATA_BLOB pdbItem);

DWORD CacheAddItem(
	IN CACHEHANDLE hCache,
	IN PDATA_BLOB mpdbKeys,
	IN DWORD cKeys,
	IN PDATA_BLOB pdbItem);

DWORD CacheDeleteItem(
	IN CACHEHANDLE hCache,
	IN PDATA_BLOB mpdbKeys,
	IN DWORD cKeys);

#define CACHE_TYPE_IN_PROC						1
#define CACHE_TYPE_SERVICE  					2

typedef struct _CACHE_INITIALIZE_INFO
{
	DWORD dwFlags;
	DWORD dwType;
	PVOID pvInfo;
} CACHE_INITIALIZE_INFO, *PCACHE_INITIALIZE_INFO;

DWORD CacheInitializeCache(
	IN CACHEHANDLE *phCache,
	IN PCACHE_INITIALIZE_INFO pCacheInitializeInfo);

DWORD CacheDeleteCache(
	IN CACHEHANDLE hCache);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\pinlib.h ===
#ifndef __BASECSP__PINLIB__H
#define __BASECSP__PINLIB__H

#include <windows.h>
#include <basecsp.h>

//
// Function: PinStringToBytesA
//
DWORD
WINAPI
PinStringToBytesA(
    IN      LPSTR       szPin,
    OUT     PDWORD      pcbPin,
    OUT     PBYTE       *ppbPin);

//
// Function: PinStringToBytesW
//
DWORD 
WINAPI
PinStringToBytesW(
    IN      LPWSTR      wszPin,
    OUT     PDWORD      pcbPin,
    OUT     PBYTE       *ppbPin);

//
// Function: PinShowGetPinUI
//
typedef struct _PIN_SHOW_GET_PIN_UI_INFO
{
    IN      PCSP_STRING pStrings;
    IN      LPWSTR      wszPrincipal;
    IN      LPWSTR      wszCardName;
    IN      HWND        hClientWindow;

    // The Pin Dialog code will pass the PPIN_SHOW_GET_PIN_UI_INFO pointer as
    // the second parameter to the VerifyPinCallback (not the pvCallbackContext
    // member).
    IN      PFN_VERIFYPIN_CALLBACK pfnVerify;
    IN      PVOID       pvCallbackContext;
    IN      HMODULE     hDlgResourceModule;

    // If the VerifyPinCallback fails with SCARD_E_INVALID_CHV, this member 
    // will be set to the number of pin attempts remaining before the card
    // will be blocked.  If the value is set to ((DWORD) -1), the number of
    // attempts remaining is Unknown.
    DWORD   cAttemptsRemaining;

    // Caller of PinShowGetPinUI must free pbPin if
    // it's non-NULL.
    OUT     PBYTE       pbPin;
    OUT     DWORD       cbPin;
    OUT     DWORD       dwError;

} PIN_SHOW_GET_PIN_UI_INFO, *PPIN_SHOW_GET_PIN_UI_INFO;

DWORD
WINAPI
PinShowGetPinUI(
    IN OUT  PPIN_SHOW_GET_PIN_UI_INFO pInfo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\resource.h ===
#ifndef __BASECSP__RESOURCE__H
#define __BASECSP__RESOURCE__H

#define IDS_BASECSP                     3

#define IDS_CSP_STRING1                 4
#define IDS_CSP_STRING2                 5
#define IDS_PINDIALOG_NEWPIN_MISMATCH   6
#define IDS_PINDIALOG_MSGBOX_TITLE      7
#define IDS_PINDIALOG_WRONG_PIN         8
#define IDS_PINDIALOG_PIN_RETRIES       9

#define IDC_MYICON                      10
#define IDC_BUTTONOPTIONS               12
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_TESTPINDLG                  107
#define IDI_SMALL                       108
#define IDC_TESTPINDLG                  109
#define IDR_MAINFRAME                   128
#define IDD_PINDIALOG                   129
#define IDB_BITMAP1                     134
#define IDC_EDITPIN                     1000
#define IDC_EDITNEWPIN                  1005
#define IDC_EDITNEWPIN2                 1006
#define IDM_USERAUTH                    32771
#define IDC_STATIC                      -1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\physfile.h ===
#ifndef __CARDMOD_PHYSICAL_FILE_LAYOUT__
#define __CARDMOD_PHYSICAL_FILE_LAYOUT__

#include <windows.h>

// 
// Physical ACL Files
//

static const WCHAR wszAdminWritePhysicalAcl []      = L"/s/a/aw";
static const WCHAR wszUserWritePhysicalAcl  []      = L"/s/a/uw";
static const WCHAR wszUserExecutePhysicalAcl  []    = L"/s/a/ux";

//
// Physical File Layout
//

// Card Identifier File
// "/cardid"
static CHAR szPHYSICAL_CARD_IDENTIFIER [] =                 "/\0cardid\0";
#define cbPHYSICAL_CARD_IDENTIFIER \
    sizeof(szPHYSICAL_CARD_IDENTIFIER)

// Cache File 
// "/cardcf"
static CHAR szPHYSICAL_CACHE_FILE [] =                      "/\0cardcf\0";
#define cbPHYSICAL_CACHE_FILE \
    sizeof(szPHYSICAL_CACHE_FILE)

// Personal Data File 
// "/msitg"
static CHAR szPHYSICAL_PERSONAL_DATA_FILE [] =              "/\0msitgf\0";
#define cbPHYSICAL_PERSONAL_DATA_FILE \
    sizeof(szPHYSICAL_PERSONAL_DATA_FILE)

// Application Directory File
// "/cardapps"
static CHAR szPHYSICAL_APPLICATION_DIRECTORY_FILE [] =      "/\0cardapps\0";
#define cbPHYSICAL_APPLICATION_DIRECTORY_FILE \
    sizeof(szPHYSICAL_APPLICATION_DIRECTORY_FILE)

// CSP Application Directory
// "/mscp"
//
// Not NULL-terminated
static CHAR szPHYSICAL_CSP_DIR [] = {
    '/', '\0', 
    'm', 's', 'c', 'p'
};
#define cbPHYSICAL_CSP_DIR \
    sizeof(szPHYSICAL_CSP_DIR)

// Container Map File
// "/mscp/cmapfile"
static CHAR szPHYSICAL_CONTAINER_MAP_FILE [] =              "/\0mscp/\0cmapfile\0";
#define cbPHYSICAL_CONTAINER_MAP_FILE \
    sizeof(szPHYSICAL_CONTAINER_MAP_FILE)

// Signature Private Key Prefix
// "/mscp/kss"
//
// Not NULL-terminated
static CHAR szPHYSICAL_SIGNATURE_PRIVATE_KEY_PREFIX [] = {
    '/', '\0', 
    'm', 's', 'c', 'p',
    '/', '\0', 
    'k', 's', 's'
};
#define cbPHYSICAL_SIGNATURE_PRIVATE_KEY_PREFIX \
    sizeof(szPHYSICAL_SIGNATURE_PRIVATE_KEY_PREFIX)

// Signature Public Key Prefix
// "/mscp/ksp"
//
// Not NULL-terminated
static CHAR szPHYSICAL_SIGNATURE_PUBLIC_KEY_PREFIX [] = {
    '/', '\0', 
    'm', 's', 'c', 'p',
    '/', '\0', 
    'k', 's', 'p'
};
#define cbPHYSICAL_SIGNATURE_PUBLIC_KEY_PREFIX \
    sizeof(szPHYSICAL_SIGNATURE_PUBLIC_KEY_PREFIX)

// Key Exchange Private Key Prefix
// "/mscp/kxs"
//
// Not NULL-terminated
static CHAR szPHYSICAL_KEYEXCHANGE_PRIVATE_KEY_PREFIX [] = {
    '/', '\0', 
    'm', 's', 'c', 'p',
    '/', '\0', 
    'k', 'x', 's'
};
#define cbPHYSICAL_KEYEXCHANGE_PRIVATE_KEY_PREFIX \
    sizeof(szPHYSICAL_KEYEXCHANGE_PRIVATE_KEY_PREFIX)

// Key Exchange Public Key Prefix
// "/mscp/kxp"
//
// Not NULL-terminated
static CHAR szPHYSICAL_KEYEXCHANGE_PUBLIC_KEY_PREFIX [] = {
    '/', '\0', 
    'm', 's', 'c', 'p',
    '/', '\0', 
    'k', 'x', 'p'
};
#define cbPHYSICAL_KEYEXCHANGE_PUBLIC_KEY_PREFIX \
    sizeof(szPHYSICAL_KEYEXCHANGE_PUBLIC_KEY_PREFIX)

// User Signature Certificate Prefix
// "/mscp/ksc"
//
// Not NULL-terminated
static CHAR szPHYSICAL_USER_SIGNATURE_CERT_PREFIX [] = {
    '/', '\0', 
    'm', 's', 'c', 'p',
    '/', '\0', 
    'k', 's', 'c'
};
#define cbPHYSICAL_USER_SIGNATURE_CERT_PREFIX \
    sizeof(szPHYSICAL_USER_SIGNATURE_CERT_PREFIX)

// User Key Exchange Certificate Prefix
// "/mscp/kxc"
//
// Not NULL-terminated
static CHAR szPHYSICAL_USER_KEYEXCHANGE_CERT_PREFIX [] = {
    '/', '\0', 
    'm', 's', 'c', 'p',
    '/', '\0', 
    'k', 'x', 'c'
};
#define cbPHYSICAL_USER_KEYEXCHANGE_CERT_PREFIX \
    sizeof(szPHYSICAL_USER_KEYEXCHANGE_CERT_PREFIX)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\sccache.h ===
#ifndef __SCARD__GLOBAL__CACHE
#define __SCARD__GLOBAL__CACHE

#include <windows.h>

//
// This header defines a general data cache to be used for Smart Card
// data.
//

//
// Function: SCardCacheLookupItem
//
// Purpose: Query the data cache for a specific item, identified by the 
//  rgdbCacheKey array in the SCARD_CACHE_LOOKUP_ITEM_INFO structure, below.
//
//  If the item is found cached, a copy is made using the caller's 
//  PFN_CACHE_ITEM_ALLOC type allocator and ERROR_SUCCESS is returned.
//  The caller is responsible for freeing the dbItem.pbData member.
//
//  If the item is not found cached, ERROR_NOT_FOUND is returned.
//

typedef LPVOID (WINAPI *PFN_CACHE_ITEM_ALLOC)(
    IN SIZE_T Size);

#define SCARD_CACHE_LOOKUP_ITEM_INFO_CURRENT_VERSION 1

typedef struct _SCARD_CACHE_LOOKUP_ITEM_INFO
{
    IN DWORD dwVersion;

    IN PFN_CACHE_ITEM_ALLOC pfnAlloc;   
    IN DATA_BLOB *mpdbCacheKey;
    IN DWORD cCacheKey;
    OUT DATA_BLOB dbItem;

} SCARD_CACHE_LOOKUP_ITEM_INFO, *PSCARD_CACHE_LOOKUP_ITEM_INFO;

typedef DWORD (WINAPI *PFN_SCARD_CACHE_LOOKUP_ITEM) (
    IN PSCARD_CACHE_LOOKUP_ITEM_INFO pInfo);

DWORD SCardCacheLookupItem(
    IN PSCARD_CACHE_LOOKUP_ITEM_INFO pInfo);

//
// Function: SCardCacheAddItem
// 
// Purpose: Add data to the cache.  The item to be added is identified
//  by the rgdbCacheKey parameter.  A flat copy of the pdbItem->pbData
//  parameter will be made for storage in the cache.
//

typedef DWORD (WINAPI *PFN_SCARD_CACHE_ADD_ITEM) (
    IN DATA_BLOB *rgdbCacheKey,
    IN DWORD cCacheKey,
    IN DATA_BLOB *pdbItem);

DWORD SCardCacheAddItem(
    IN DATA_BLOB *rgdbCacheKey,
    IN DWORD cCacheKey,
    IN DATA_BLOB *pdbItem);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pinlib\pindlg.c ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    pindlg.c

Abstract:

    Window procedure for the PIN dialog

Notes:

    <Implementation Details>

--*/

#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include "resource.h"
#include "basecsp.h"
#include "pinlib.h"
#include "pindlg.h"

    // Offset added to the bottom of the reference control to determine
    // the bottom of the dialog
#define BORDER_OFFSET                   7

/*++

PinDlgProc:

    Message handler for PIN dialog box.

Arguments:

    HWND hDlg        handle to window
    UINT message     message identifier
    WPARAM wParam    first message parameter
    LPARAM lParam    second message parameter

Return Value:

    TRUE if the message was processed or FALSE if it wasn't

Remarks:

    <usageDetails>

--*/
INT_PTR CALLBACK PinDlgProc(
    HWND hDlg, 
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PPIN_SHOW_GET_PIN_UI_INFO pInfo = (PPIN_SHOW_GET_PIN_UI_INFO)
        GetWindowLongPtr(hDlg, GWLP_USERDATA);
    int wmId, wmEvent;
    DWORD cchPin = cchMAX_PIN_LENGTH;
    WCHAR wszPin [cchMAX_PIN_LENGTH + 1];
    DWORD cchNewPin = cchMAX_PIN_LENGTH;
    WCHAR wszNewPin [cchMAX_PIN_LENGTH];
    DWORD cchNewPinConfirm = cchMAX_PIN_LENGTH;
    WCHAR wszNewPinConfirm [cchMAX_PIN_LENGTH];
    DWORD dwSts = ERROR_SUCCESS;
    PINCACHE_PINS Pins;
    LPWSTR wszWrongPin = NULL;
    DWORD cchWrongPin = 0;

    switch (message)
    {
    case WM_INITDIALOG:

        // Store the caller's data - this is the buffer by which we'll return
        // the user's pin.
        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) lParam);
        
        // The dialog shall be initially "small"
        {
            RECT xRefRect, xRect;
            GetWindowRect(hDlg, &xRect);
            GetWindowRect(GetDlgItem(hDlg, IDOK), &xRefRect);
            xRect.bottom = xRefRect.bottom + BORDER_OFFSET;
            MoveWindow(hDlg,
                xRect.left, xRect.top,
                xRect.right - xRect.left, xRect.bottom - xRect.top,
                FALSE);
        }

        //
        // Set the max input length for the various pin input fields
        //

        SendDlgItemMessage(
            hDlg,
            IDC_EDITPIN,
            EM_LIMITTEXT,
            cchMAX_PIN_LENGTH,
            0);

        SendDlgItemMessage(
            hDlg,
            IDC_EDITNEWPIN,
            EM_LIMITTEXT,
            cchMAX_PIN_LENGTH,
            0);

        SendDlgItemMessage(
            hDlg,
            IDC_EDITNEWPIN2,
            EM_LIMITTEXT,
            cchMAX_PIN_LENGTH,
            0);

        return TRUE;

    case WM_COMMAND:
        wmId    = LOWORD(wParam); 
        wmEvent = HIWORD(wParam); 
        // Parse the menu selections:
        switch (wmId)
        {
        case IDOK:

            pInfo->dwError = ERROR_SUCCESS;

            memset(&Pins, 0, sizeof(Pins));

            //
            // Find out what the user typed in
            //

            cchPin = GetDlgItemText(
                hDlg,
                IDC_EDITPIN,
                wszPin,
                cchMAX_PIN_LENGTH);

            if (cchPin == 0)
                goto InvalidPin;

            // User entered something.  See if it's a valid pin.

            dwSts = PinStringToBytesW(
                wszPin,
                &Pins.cbCurrentPin,
                &Pins.pbCurrentPin);

            switch (dwSts)
            {
            case ERROR_SUCCESS:
                // Just continue
                break;
            case ERROR_NOT_ENOUGH_MEMORY:
                goto OutOfMemoryRet;
            default:
                goto InvalidPin;
            }

            // See if the user is requesting a pinchange

            cchNewPin = GetDlgItemText(
                hDlg,
                IDC_EDITNEWPIN,
                wszNewPin,
                cchMAX_PIN_LENGTH);

            if (0 != cchNewPin)
            {
                // See if the "confirmed" new pin matches the first new pin

                cchNewPinConfirm = GetDlgItemText(
                    hDlg,
                    IDC_EDITNEWPIN2,
                    wszNewPinConfirm,
                    cchMAX_PIN_LENGTH);

                if (0 != wcscmp(wszNewPin, wszNewPinConfirm))
                {
                    // Display a warning message and let the user try again
                    MessageBoxEx(
                        hDlg,
                        pInfo->pStrings[StringNewPinMismatch].wszString,
                        pInfo->pStrings[StringPinMessageBoxTitle].wszString,
                        MB_OK | MB_ICONWARNING | MB_APPLMODAL,
                        0);

                    return TRUE;
                }

                // See if the new pin is valid
                dwSts = PinStringToBytesW(
                    wszNewPin,
                    &Pins.cbNewPin,
                    &Pins.pbNewPin);

                switch (dwSts)
                {
                case ERROR_SUCCESS:
                    // Just continue
                    break;
                case ERROR_NOT_ENOUGH_MEMORY:
                    goto OutOfMemoryRet;
                default:
                    goto InvalidPin;
                }
            }
            
            dwSts = pInfo->pfnVerify(
                &Pins,
                (PVOID) pInfo);

            if (ERROR_SUCCESS != dwSts)
                goto InvalidPin;

            // Pin appears to be good.  We're done.

            // Return the appropriate validated pin to the caller
            if (NULL != Pins.pbNewPin)
            {
                pInfo->pbPin = Pins.pbNewPin;
                pInfo->cbPin = Pins.cbNewPin;
                Pins.pbNewPin = NULL;
            }
            else
            {
                pInfo->pbPin = Pins.pbCurrentPin;
                pInfo->cbPin = Pins.cbCurrentPin;
                Pins.pbCurrentPin = NULL;
            }

            EndDialog(hDlg, wmId);
            goto CommonRet;

        case IDCANCEL:
            pInfo->dwError = SCARD_W_CANCELLED_BY_USER;

            EndDialog(hDlg, wmId);
            return TRUE;

        case IDC_BUTTONOPTIONS:
            {
                RECT xRefRect, xRect;
                LPCTSTR lpszNewText;
                HWND hWnd;
                
                GetWindowRect(hDlg, &xRect);
                GetWindowRect(GetDlgItem(hDlg, IDOK), &xRefRect);

                if (xRect.bottom == xRefRect.bottom + BORDER_OFFSET)
                {       // if dialog is small, make it big
                    GetWindowRect(GetDlgItem(hDlg, IDC_EDITNEWPIN2), &xRefRect);
                        // Change the button label accordingly
                    lpszNewText = _T("&Options <<");
                }
                else    // otherwise shrink it
                {
                        // Change the button label accordingly
                    lpszNewText = _T("&Options >>");
                }

                xRect.bottom = xRefRect.bottom + BORDER_OFFSET;
                MoveWindow(hDlg,
                    xRect.left, xRect.top,
                    xRect.right - xRect.left, xRect.bottom - xRect.top,
                    TRUE);
                SetDlgItemText(hDlg, IDC_BUTTONOPTIONS, lpszNewText);
            }

            return TRUE;
        }
        break;
    }

    return FALSE;

InvalidPin:

    // See if valid "Attempts Remaining" info was supplied.  If so, display 
    // it to the user.
    if (((DWORD) -1) != pInfo->cAttemptsRemaining)
    {
        cchWrongPin = 
            wcslen(pInfo->pStrings[StringWrongPin].wszString) + 3 +
            wcslen(pInfo->pStrings[StringPinRetries].wszString) + 3 + 2 + 1;

        wszWrongPin = (LPWSTR) CspAllocH(cchWrongPin * sizeof(WCHAR));

        if (NULL == wszWrongPin)
            goto OutOfMemoryRet;

        wsprintf(
            wszWrongPin,
            L"%s.  %s:  %02d",
            pInfo->pStrings[StringWrongPin].wszString,
            pInfo->pStrings[StringPinRetries].wszString,
            pInfo->cAttemptsRemaining & 0x0F);
    }
    else
    {
        cchWrongPin = 
            wcslen(pInfo->pStrings[StringWrongPin].wszString) + 2;

        wszWrongPin = (LPWSTR) CspAllocH(cchWrongPin * sizeof(WCHAR));

        if (NULL == wszWrongPin)
            goto OutOfMemoryRet;

        wsprintf(
            wszWrongPin,
            L"%s.",
            pInfo->pStrings[StringWrongPin].wszString);
    }

    // Display a warning message and let the user try again, if they'd like.
    MessageBoxEx(
        hDlg,
        wszWrongPin,
        pInfo->pStrings[StringPinMessageBoxTitle].wszString,
        MB_OK | MB_ICONWARNING | MB_APPLMODAL,
        0);

    //
    // Clear the pin edit boxes since the current pin is wrong
    //

    SetDlgItemText(hDlg, IDC_EDITPIN, L"");
    SetDlgItemText(hDlg, IDC_EDITNEWPIN, L"");
    SetDlgItemText(hDlg, IDC_EDITNEWPIN2, L"");

CommonRet:

    if (NULL != wszWrongPin)
        CspFreeH(wszWrongPin);

    if (NULL != Pins.pbCurrentPin)
    {
        RtlSecureZeroMemory(Pins.pbCurrentPin, Pins.cbCurrentPin);
        CspFreeH(Pins.pbCurrentPin);
    }

    if (NULL != Pins.pbNewPin)
    {
        RtlSecureZeroMemory(Pins.pbNewPin, Pins.cbNewPin);
        CspFreeH(Pins.pbNewPin);
    }

    if (ERROR_SUCCESS != pInfo->dwError)
        EndDialog(hDlg, wmId);

    return TRUE;

OutOfMemoryRet:

    pInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
    goto CommonRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\inc\csplib.h ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    csplib.h

    General Cryptographic Service Provider Library

Abstract:


Author:

    Dan Griffin

Notes:

--*/

#ifndef __CSP__LIB__H__
#define __CSP__LIB__H__

#include <windows.h>
#include <wincrypt.h>
#include <cspdk.h>

//
// Hash OID Encodings for PKCS #1 Signing 
//
// Reverse ASN.1 Encodings of possible hash identifiers.  The leading byte is
// the length of the remaining byte string.  The lists of possible identifiers
// is terminated with a '\x00' entry.
//
static const BYTE
    *md2Encodings[]
//                        1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x02\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },

    *md4Encodings[]
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x04\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x04\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",
        (CONST BYTE *)"\x00" },

    *md5Encodings[]
    = { (CONST BYTE *)"\x12\x10\x04\x00\x05\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0c\x30\x20\x30",
        (CONST BYTE *)"\x10\x10\x04\x05\x02\x0d\xf7\x86\x48\x86\x2a\x08\x06\x0a\x30\x1e\x30",

        // The following encoding which excludes the digest algorithm was added
        // for: Nortel V1 Cert Signatures
        //
        // It can be removed when these type of certificates no longer exist.
        //
        // Since we only allow the digest OID to be omitted for MD5 there
        // isn't a compromise where another algorithm could be substituted.
        (CONST BYTE *)"\x02\x10\x04",

        (CONST BYTE *)"\x00" },
    
    *shaEncodings[]
    = { (CONST BYTE *)"\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
        (CONST BYTE *)"\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
        (CONST BYTE *)"\x00"},

    *sha256Encodings[]
    = { (CONST BYTE *)"\x13\x20\x04\x00\x05\x01\x02\x04\x03\x65\x01\x48\x86\x60\x09\x06\x0d\x30\x31\x30",
        (CONST BYTE *)"\x11\x20\x04\x01\x02\x04\x03\x65\x01\x48\x86\x60\x09\x06\x0b\x30\x2f\x30",
        (CONST BYTE *)"\x00"},
    
    *sha384Encodings[]
    = { (CONST BYTE *)"\x13\x30\x04\x00\x05\x02\x02\x04\x03\x65\x01\x48\x86\x60\x09\x06\x0d\x30\x41\x30",
        (CONST BYTE *)"\x11\x30\x04\x02\x02\x04\x03\x65\x01\x48\x86\x60\x09\x06\x0b\x30\x3f\x30",
        (CONST BYTE *)"\x00"},
    
    *sha512Encodings[]
    = { (CONST BYTE *)"\x13\x40\x04\x00\x05\x03\x02\x04\x03\x65\x01\x48\x86\x60\x09\x06\x0d\x30\x51\x30",
        (CONST BYTE *)"\x11\x40\x04\x03\x02\x04\x03\x65\x01\x48\x86\x60\x09\x06\x0b\x30\x4f\x30",
        (CONST BYTE *)"\x00"},

    *endEncodings[]
    = { (CONST BYTE *)"\x00" };

//
// Type: USER_CONTEXT
//
typedef struct _USER_CONTEXT
{
    HCRYPTPROV hSupportProv;
    
    //
    // The csplib will set this to the string value passed by the 
    // caller to CryptAcquireContext.  For a smartcard CSP, it might
    // include a reader name.
    //
    LPWSTR wszContainerNameFromCaller;

    //
    // The CSP allocates this string (using CspAllocH) and sets it to
    // the name of the key container being used for this context.
    //
    // The csplib will free this value on CryptReleaseContext.
    //
    LPWSTR wszBaseContainerName;
    BOOL fBaseContainerNameIsRpcUuid;

    //
    // The CSP allocates this string (using CspAllocH) and sets it to
    // the expanded representation of the container name.  This may be the
    // same as the wszBaseContainerName value.
    //
    // The csplib will free this value on CryptReleaseContext.
    //
    LPWSTR wszUniqueContainerName;

    DWORD dwFlags;
    PVTableProvStrucW pVTableW;
    PVOID pvLocalUserContext;

} USER_CONTEXT, *PUSER_CONTEXT;

//
// Type: KEY_CONTEXT
//
typedef struct _KEY_CONTEXT
{
    PUSER_CONTEXT pUserContext;
    HCRYPTKEY hSupportKey;
    DWORD dwFlags;
    DWORD cKeyBits;
    ALG_ID Algid;
    PVOID pvLocalKeyContext;
} KEY_CONTEXT, *PKEY_CONTEXT;

//
// Type: HASH_CONTEXT
//
typedef struct _HASH_CONTEXT
{
    PUSER_CONTEXT pUserContext;
    HCRYPTHASH hSupportHash;
    DWORD dwFlags;
    ALG_ID Algid;
    PVOID pvLocalHashContext;
} HASH_CONTEXT, *PHASH_CONTEXT;

//
// Type: LOCAL_CALL_INFO
//
typedef BOOL LOCAL_CALL_INFO, *PLOCAL_CALL_INFO;

//
// Function: LocalAcquireContext
//
typedef DWORD (WINAPI *PFN_LOCAL_ACQUIRE_CONTEXT)(
    IN OUT  PUSER_CONTEXT       pUserContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalReleaseContext
//
typedef DWORD (WINAPI *PFN_LOCAL_RELEASE_CONTEXT)(
    IN OUT  PUSER_CONTEXT       pUserContext,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalGenKey
//
typedef DWORD (WINAPI *PFN_LOCAL_GEN_KEY)(
    IN OUT  PKEY_CONTEXT        pKeyContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalDeriveKey
//
typedef DWORD (WINAPI *PFN_LOCAL_DERIVE_KEY)(
    IN OUT  PKEY_CONTEXT        pKeyContext,
    IN      PHASH_CONTEXT       pHashContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalDestroyKey
//
typedef DWORD (WINAPI *PFN_LOCAL_DESTROY_KEY)(
    IN OUT  PKEY_CONTEXT        pKeyContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalSetKeyParam
//
typedef DWORD (WINAPI *PFN_LOCAL_SET_KEY_PARAM)(
    IN      PKEY_CONTEXT        pKeyContext,
    IN      DWORD               dwParam,
    IN      PBYTE               pbData,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalGetKeyParam
//
typedef DWORD (WINAPI *PFN_LOCAL_GET_KEY_PARAM)(
    IN      PKEY_CONTEXT        pKeyContext,
    IN      DWORD               dwParam,
    OUT     PBYTE               pbData,
    IN OUT  PDWORD              pcbDataLen,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalSetProvParam
//
typedef DWORD (WINAPI *PFN_LOCAL_SET_PROV_PARAM)(
    IN      PUSER_CONTEXT       pUserContext,
    IN      DWORD               dwParam,
    IN      PBYTE               pbData,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalGetProvParam
//
typedef DWORD (WINAPI *PFN_LOCAL_GET_PROV_PARAM)(
    IN      PUSER_CONTEXT       pUserContext,
    IN      DWORD               dwParam,
    OUT     PBYTE               pbData,
    IN OUT  PDWORD              pcbDataLen,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalSetHashParam
//
typedef DWORD (WINAPI *PFN_LOCAL_SET_HASH_PARAM)(
    IN      PHASH_CONTEXT       pHashContext,
    IN      DWORD               dwParam,
    IN      PBYTE               pbData,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalGetHashParam
//
typedef DWORD (WINAPI *PFN_LOCAL_GET_HASH_PARAM)(
    IN      PHASH_CONTEXT       pHashContext,
    IN      DWORD               dwParam,
    OUT     PBYTE               pbData,
    IN OUT  PDWORD              pcbDataLen,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalExportKey
//
typedef DWORD (WINAPI *PFN_LOCAL_EXPORT_KEY)(
    IN      PKEY_CONTEXT        pKeyContext,
    IN      PKEY_CONTEXT        pPubKey,
    IN      DWORD               dwBlobType,
    IN      DWORD               dwFlags,
    OUT     PBYTE               pbData,
    IN OUT  PDWORD              pcbDataLen,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalImportKey
//
typedef DWORD (WINAPI *PFN_LOCAL_IMPORT_KEY)(
    IN      PKEY_CONTEXT        pKeyContext,
    IN      PBYTE               pbData,
    IN      DWORD               cbDataLen,
    IN      PKEY_CONTEXT        pPubKey,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalEncrypt
//
typedef DWORD (WINAPI *PFN_LOCAL_ENCRYPT)(
    IN      PKEY_CONTEXT        pKeyContext,
    IN      PHASH_CONTEXT       pHashContext,
    IN      BOOL                fFinal,
    IN      DWORD               dwFlags,
    IN OUT  LPBYTE              pbData,
    IN OUT  LPDWORD             pcbDataLen,
    IN      DWORD               cbBufLen,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalDecrypt
//
typedef DWORD (WINAPI *PFN_LOCAL_DECRYPT)(
    IN      PKEY_CONTEXT        pKeyContext,
    IN      PHASH_CONTEXT       pHashContext,
    IN      BOOL                fFinal,
    IN      DWORD               dwFlags,
    IN OUT  LPBYTE              pbData,
    IN OUT  LPDWORD             pcbDataLen,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalCreateHash
//
typedef DWORD (WINAPI *PFN_LOCAL_CREATE_HASH)(
    IN      PHASH_CONTEXT       pHashContext,
    IN      PKEY_CONTEXT        pKeyContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalHashData
//
typedef DWORD (WINAPI *PFN_LOCAL_HASH_DATA)(
    IN      PHASH_CONTEXT       pHashContext,
    IN      CONST BYTE          *pbData,
    IN      DWORD               cbDataLen,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo); 

//
// Function: LocalHashSessionKey
//
typedef DWORD (WINAPI *PFN_LOCAL_HASH_SESSION_KEY)(
    IN      PHASH_CONTEXT       pHashContext,
    IN      PKEY_CONTEXT        pKeyContext,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalSignHash
//
typedef DWORD (WINAPI *PFN_LOCAL_SIGN_HASH)(
    IN      PHASH_CONTEXT       pHashContext,
    IN      DWORD               dwKeySpec,
    IN      DWORD               dwFlags,
    OUT     LPBYTE              pbSignature,
    IN OUT  LPDWORD             pcbSigLen,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalDestroyHash
//
typedef DWORD (WINAPI *PFN_LOCAL_DESTROY_HASH)(
    IN      PHASH_CONTEXT       pHashContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalVerifySignature
//
typedef DWORD (WINAPI *PFN_LOCAL_VERIFY_SIGNATURE)(
    IN      PHASH_CONTEXT       pHashContext,
    IN      CONST BYTE          *pbSignature,
    IN      DWORD               cbSigLen,
    IN      PKEY_CONTEXT        pPubKey,
    IN      DWORD               dwFlags,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalGenRandom
//
typedef DWORD (WINAPI *PFN_LOCAL_GEN_RANDOM)(
    IN      PUSER_CONTEXT       pUserContext,
    IN      DWORD               cbLen,
    OUT     LPBYTE              pbBuffer,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalGetUserKey
//
typedef DWORD (WINAPI *PFN_LOCAL_GET_USER_KEY)(
    IN      PKEY_CONTEXT        pKeyContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalDuplicateHash
//
typedef DWORD (WINAPI *PFN_LOCAL_DUPLICATE_HASH)(
    IN      PHASH_CONTEXT       pHashContext,
    IN      LPDWORD             pdwReserved,
    IN      PHASH_CONTEXT       pNewHashContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalDuplicateKey
//
typedef DWORD (WINAPI *PFN_LOCAL_DUPLICATE_KEY)(
    IN      PKEY_CONTEXT        pKeyContext,
    IN      LPDWORD             pdwReserved,
    IN      PKEY_CONTEXT        pNewKeyContext,
    OUT     PLOCAL_CALL_INFO    pLocalCallInfo);

//
// Function: LocalDllInitialize
//
typedef BOOL (WINAPI *PFN_LOCAL_DLL_INITIALIZE)(
    IN      PVOID               hmod,
    IN      ULONG               Reason,
    IN      PCONTEXT            Context);

//
// Function: LocalDllRegisterServer
//
typedef DWORD (WINAPI *PFN_LOCAL_DLL_REGISTER_SERVER)(void);

//
// Function: LocalDllUnregisterServer
//
typedef DWORD (WINAPI *PFN_LOCAL_DLL_UNREGISTER_SERVER)(void);

//
// Type: LOCAL_CSP_INFO
//
typedef struct _LOCAL_CSP_INFO
{
    //
    // Function pointers for the "local" CSP implementation to fill
    // in, and be called by the CSP library.
    //
    PFN_LOCAL_ACQUIRE_CONTEXT       pfnLocalAcquireContext; // Required
    PFN_LOCAL_RELEASE_CONTEXT       pfnLocalReleaseContext; // Required
    PFN_LOCAL_GEN_KEY               pfnLocalGenKey;
    PFN_LOCAL_DERIVE_KEY            pfnLocalDeriveKey;
    PFN_LOCAL_DESTROY_KEY           pfnLocalDestroyKey;
    PFN_LOCAL_SET_KEY_PARAM         pfnLocalSetKeyParam;
    PFN_LOCAL_GET_KEY_PARAM         pfnLocalGetKeyParam;
    PFN_LOCAL_SET_PROV_PARAM        pfnLocalSetProvParam;
    PFN_LOCAL_GET_PROV_PARAM        pfnLocalGetProvParam;
    PFN_LOCAL_SET_HASH_PARAM        pfnLocalSetHashParam;
    PFN_LOCAL_GET_HASH_PARAM        pfnLocalGetHashParam;
    PFN_LOCAL_EXPORT_KEY            pfnLocalExportKey;
    PFN_LOCAL_IMPORT_KEY            pfnLocalImportKey;
    PFN_LOCAL_ENCRYPT               pfnLocalEncrypt;
    PFN_LOCAL_DECRYPT               pfnLocalDecrypt;
    PFN_LOCAL_CREATE_HASH           pfnLocalCreateHash;
    PFN_LOCAL_HASH_DATA             pfnLocalHashData;
    PFN_LOCAL_HASH_SESSION_KEY      pfnLocalHashSessionKey;
    PFN_LOCAL_SIGN_HASH             pfnLocalSignHash;
    PFN_LOCAL_DESTROY_HASH          pfnLocalDestroyHash;
    PFN_LOCAL_VERIFY_SIGNATURE      pfnLocalVerifySignature;
    PFN_LOCAL_GEN_RANDOM            pfnLocalGenRandom;
    PFN_LOCAL_GET_USER_KEY          pfnLocalGetUserKey;
    PFN_LOCAL_DUPLICATE_HASH        pfnLocalDuplicateHash;
    PFN_LOCAL_DUPLICATE_KEY         pfnLocalDuplicateKey;

    PFN_LOCAL_DLL_INITIALIZE        pfnLocalDllInitialize;
    PFN_LOCAL_DLL_REGISTER_SERVER   pfnLocalDllRegisterServer;
    PFN_LOCAL_DLL_UNREGISTER_SERVER pfnLocalDllUnregisterServer;

    //
    // Static data describing the local CSP.
    //
    LPWSTR wszProviderName;
    DWORD dwProviderType;
    DWORD dwImplementationType;

    //
    // Description of the support CSP to be used.
    //
    LPWSTR wszSupportProviderName;
    DWORD dwSupportProviderType;
} LOCAL_CSP_INFO, *PLOCAL_CSP_INFO;

//
// General Wrappers
//

LPVOID WINAPI CspAllocH(
    IN SIZE_T cBytes);

LPVOID WINAPI CspReAllocH(
    IN LPVOID pMem, 
    IN SIZE_T cBytes);

void WINAPI CspFreeH(
    IN LPVOID pMem);

DWORD CspInitializeCriticalSection(
    IN CRITICAL_SECTION *pcs);

DWORD CspEnterCriticalSection(
    IN CRITICAL_SECTION *pcs);

void CspLeaveCriticalSection(
    IN CRITICAL_SECTION *pcs);

void CspDeleteCriticalSection(
    IN CRITICAL_SECTION *pcs);

DWORD WINAPI RegOpenProviderKey(
    IN OUT  HKEY *phProviderKey,
    IN      REGSAM samDesired);

void SetLocalCallInfo(
    IN OUT  PLOCAL_CALL_INFO    pLocalCallInfo,
    IN      BOOL                fContinue);

DWORD WINAPI CreateUuidContainerName(
    IN PUSER_CONTEXT pUserCtx);

DWORD WINAPI ApplyPKCS1SigningFormat(
    IN  ALG_ID HashAlgid,
    IN  BYTE *pbHash,
    IN  DWORD cbHash,
    IN  DWORD dwFlags,
    IN  DWORD cbModulus,
    OUT PBYTE *ppbPKCS1Format);

#ifndef PKCS_BLOCKTYPE_2        
#define PKCS_BLOCKTYPE_2        2
#endif

DWORD WINAPI VerifyPKCS2Padding(
    IN  PBYTE pbPaddedData,
    IN  DWORD cbModulus,
    OUT PBYTE *ppbData,
    OUT PDWORD pcbData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pinlib\pindlg.h ===
#ifndef __BASECSP__PINGDLG__H
#define __BASECSP__PINGDLG__H 

#include <windows.h>

//
// Function: PinDlgProc
//
// Purpose: Display Pin-Entry UI for the Base CSP.  
//
//          The lParam parameter should be a pointer to a
//          PIN_SHOW_GET_PIN_UI_INFO structure.
//
INT_PTR CALLBACK PinDlgProc(
    HWND hDlg, 
    UINT message,   
    WPARAM wParam, 
    LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\helpers.cpp ===
#include <windows.h>
#include <winscard.h>
#include <string.h>
#include <stdlib.h>
#include "basecsp.h"//
// Function: CspAllocH
//
LPVOID WINAPI CspAllocH(
    IN SIZE_T cBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cBytes);
}

//
// Function: CspFreeH
//
void WINAPI CspFreeH(
    IN LPVOID pMem)
{
    HeapFree(GetProcessHeap(), 0, pMem);
}

// 
// Function: CspReAllocH
//
LPVOID WINAPI CspReAllocH(
    IN LPVOID pMem, 
    IN SIZE_T cBytes)
{
    return HeapReAlloc(
        GetProcessHeap(), HEAP_ZERO_MEMORY, pMem, cBytes);
}

DWORD WINAPI CspCacheAddFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData)
{
    return ERROR_SUCCESS;
}

DWORD WINAPI CspCacheLookupFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       *ppbData,
    IN      PDWORD      pcbData)
{
    return ERROR_NOT_FOUND;
}

DWORD WINAPI CspCacheDeleteFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags)
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pinlib\pinlib.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <basecsp.h>
#include <pinlib.h>
#include "pindlg.h"
#include "resource.h"

//
// Function: PinStringToBytesA
//
DWORD
WINAPI
PinStringToBytesA(
    IN      LPSTR       szPin,
    OUT     PDWORD      pcbPin,
    OUT     PBYTE       *ppbPin)
{
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbPin = 0;
    PBYTE pbPin = NULL;
    DWORD iChar = 0;

    *pcbPin = 0;
    *ppbPin = NULL;

    cbPin = strlen(szPin);

    pbPin = CspAllocH(cbPin);

    if (NULL == pbPin)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    // Copy the pin bytes directly - no further conversion needed
    memcpy(pbPin, szPin, cbPin);

    *ppbPin = pbPin;
    pbPin = NULL;
    *pcbPin = cbPin;

Ret:
    if (pbPin)
        CspFreeH(pbPin);

    return dwSts;
}

//
// Function: PinStringToBytesW
//
DWORD 
WINAPI
PinStringToBytesW(
    IN      LPWSTR      wszPin,
    OUT     PDWORD      pcbPin,
    OUT     PBYTE       *ppbPin)
{ 
    DWORD dwSts = ERROR_SUCCESS;
    UNICODE_STRING UnicodePin;
    ANSI_STRING AnsiPin;

    *pcbPin = 0;
    *ppbPin = NULL;

    memset(&AnsiPin, 0, sizeof(AnsiPin));

    RtlInitUnicodeString(&UnicodePin, wszPin);
    
    dwSts = RtlUnicodeStringToAnsiString(
        &AnsiPin,
        &UnicodePin,
        TRUE);

    if (STATUS_SUCCESS != dwSts)
    {
        dwSts = RtlNtStatusToDosError(dwSts);
        goto Ret;
    }

    dwSts = PinStringToBytesA(
        AnsiPin.Buffer,
        pcbPin,
        ppbPin);

Ret:
    if (AnsiPin.Buffer)
        RtlFreeAnsiString(&AnsiPin);

    if (ERROR_SUCCESS != dwSts && NULL != *ppbPin)
    {
        CspFreeH(*ppbPin);
        *ppbPin = NULL;
    }

    return dwSts;
}

//
// Function: PinShowGetPinUI
//
DWORD
WINAPI
PinShowGetPinUI(
    IN OUT  PPIN_SHOW_GET_PIN_UI_INFO pInfo)
{
    DWORD dwSts = ERROR_SUCCESS;
    HWND hWnd = pInfo->hClientWindow;
    DWORD cchPin = 0;
    INT_PTR dlgResult = 0;

    if (0 == hWnd)
    {
        hWnd = GetDesktopWindow();
    
        if (0 == hWnd || INVALID_HANDLE_VALUE == hWnd)
        {
            dwSts = GetLastError();
            goto Ret;
        }
    }

    //
    // Display a dialog to ask the user to enter a pin
    //
    dlgResult = DialogBoxParamW(
        pInfo->hDlgResourceModule,
        (LPWSTR) IDD_PINDIALOG,
        hWnd,
        PinDlgProc,
        (LPARAM) pInfo);

    if (-1 == dlgResult)
    {
        dwSts = GetLastError();
        goto Ret;
    }

    dwSts = pInfo->dwError;

Ret:

    return dwSts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDC_CRED           350
#define IDD_PAGE1          332
#define IDD_PAGE2          333
#define IDS_APP_NAME       334
#define IDS_APP_DESCRIPTION 335
#define IDS_UNBLOCK1 336
#define IDS_UNBLOCK2 337
#define IDC_OLDPIN                 300
#define IDC_OLDPINLABEL            301
#define IDBUTTON1 303
#define IDBUTTON2 304
#define IDC_NEWPIN1                 305
#define IDC_NEWPIN1LABEL            306
#define IDC_NEWPIN2                 307
#define IDC_NEWPIN2LABEL            308
#define IDC_SCARDIDLABEL 309
#define IDC_SCARDID 310
#define IDC_CHALLENGELABEL 311
#define IDC_CHALLENGE      312
#define IDC_RESPONSELABEL 313
#define IDC_RESPONSE 314
#define IDC_TOPTEXT 315

#define IDS_ITGTITLE 400
#define IDS_SCERROR 401
#define IDS_NEEDPIN 402
#define IDS_NOTSAME 403
#define IDS_UNBLOCKOK 404
#define IDS_UNBLOCKFAIL 405
#define IDS_BADRESPONSE 406
#define IDS_NEEDRESPONSE 407
#define IDS_WRONGPIN 408
#define IDS_BADPIN 409
#define IDS_PINCHANGEOK 410
#define IDS_PINCHANGEFAIL 411
#define IDS_NOCARD 412
#define IDS_INTERROR 413
#define IDS_CANCELLED 414
#define IDS_NOSERVICE 415
#define IDS_TOOMANY 416
#define IDS_INVALIDCHV 417
#define IDS_STOPPED 418
#define IDS_UNSUPPORTED 419
#define IDS_NOTFOUND 420
#define IDS_WRONGCHV 421
#define IDS_BLOCKEDCHV 422
#define IDS_UNRESP 423
#define IDS_REMOVED 424
#define IDS_BADCHV 425
#define IDS_WRONGBUTTON 426
#define IDS_BADMODULE 427
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\dialog.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    Dialog

File Name:

    Dialog.cpp

Abstract:

	Simple property sheet application skeleton.  All page resource are in a common 
	resource file, but each page implementation is in a separate source file.
	
Author:


Environment:

    Win32, C++

Revision History:

	none

Notes:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commdlg.h>
#include <commctrl.h>
#include <ole2.h>
#include <stdio.h>
#include "support.h"
#include "utils.h"

#include "res.h"

// Page currently active - set on the page activate notification.  used to prevent 
//  processing of the apply message except for the page currently shown when the 
//  user hits OK.
INT iCurrent = 0;

// The unblock challenge has been acquired from the card, and the user has entered
//  a response to it.  This mode should be left by cancel or finishing the unblock.
BOOL fUnblockActive = FALSE;

#define MODALPROPSHEET 0
#define numpages 2

HINSTANCE ghInstance = NULL;
HWND hwndContainer = NULL;

INT_PTR CALLBACK PageProc1(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam);
    
INT_PTR CALLBACK PageProc2(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam);


/* ---------------------------------------------------------------------

HelpHandler

    Part of the implementation for context sensitive help.  This function is called with
    the control ID, which needs to be mapped to a string and displayed in a popup.

--------------------------------------------------------------------- */

void HelpHandler(LPARAM lp)
{
    HELPINFO *pH = (HELPINFO *) lp;
    UINT ControlID;
    WCHAR szTemp[200];

    ControlID = pH->iCtrlId;
    swprintf(szTemp,L"Help request for control %d\n",ControlID);
    OutputDebugString(szTemp);
}

/* ---------------------------------------------------------------------

CreateFontY

    Create the font used on the property page UI.

--------------------------------------------------------------------- */

HFONT CreateFontY(LPCTSTR pszFontName,LONG lWeight,LONG lHeight) 
{
    NONCLIENTMETRICS ncm = {0};
    
    if (NULL == pszFontName)
    {
        return NULL;
    }
    if (0 == lHeight)
    {
        return NULL;
    }
    ncm.cbSize = sizeof(ncm);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS,0,&ncm,0))
    {
        return NULL;
    }
    LOGFONT TitleLogFont = ncm.lfMessageFont;
    TitleLogFont.lfWeight = lWeight;
    lstrcpyn(TitleLogFont.lfFaceName,pszFontName,LF_FACESIZE);

    HDC hdc = GetDC(NULL);
    if (NULL == hdc)
    {
        return NULL;
    }
    INT FontSize = lHeight;
    TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72;
    HFONT h = CreateFontIndirect(&TitleLogFont);
    ReleaseDC(NULL,hdc);
    return h;
}

/* ---------------------------------------------------------------------

InitPropertyPage

    More of a macro, really... Performs some routine structure initalization functions to
    set up a page in an array of pages to be passed when starting up the property 
    sheet.

--------------------------------------------------------------------- */

void InitPropertyPage( PROPSHEETPAGE* psp,
                       INT idDlg,
                       DLGPROC pfnDlgProc,
                       DWORD dwFlags,
                       LPARAM lParam)
{
    memset((LPVOID)psp,0,sizeof(PROPSHEETPAGE));
    psp->dwFlags = dwFlags;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pfnDlgProc = pfnDlgProc;
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->hInstance = ghInstance;
}

/* ---------------------------------------------------------------------

ShowPropertySheet

    Initializes the property sheet header, sets up the pages, and displays the 
    property sheet.

--------------------------------------------------------------------- */

void APIENTRY ShowPropertySheet(HWND hwndOwner)
{
    PROPSHEETPAGE psp[numpages];
    HPROPSHEETPAGE hpsp[numpages];
    PROPSHEETHEADER psh;
    HFONT hTitleFont = NULL;
    INT_PTR iRet;

#if MODALPROPSHEET
    if (NULL == hwndOwner) 
    {
        hwndOwner = GetForegroundWindow();
    }
#endif

    hTitleFont = CreateFontY(L"MS Shell Dlg",FW_BOLD,12);

    InitPropertyPage( &psp[0], IDD_PAGE1, PageProc1, PSP_DEFAULT, 0);
    InitPropertyPage( &psp[1], IDD_PAGE2, PageProc2, PSP_DEFAULT, 0);
    
    for (INT j=0;j<numpages;j++)
    {
         hpsp[j] = CreatePropertySheetPage((LPCPROPSHEETPAGE) &psp[j]);
    }
    
    psh.dwSize         = sizeof(PROPSHEETHEADER);
    psh.dwFlags        =  PSH_HEADER | PSH_NOAPPLYNOW;
    psh.hwndParent     = hwndOwner;
    psh.pszCaption     = (LPCTSTR)IDS_APP_NAME;
    psh.nPages         = numpages;
    psh.nStartPage     = 0;
    psh.phpage           = (HPROPSHEETPAGE *) hpsp;
    psh.pszbmWatermark = NULL;
    psh.pszbmHeader    = NULL;
    psh.hInstance      = ghInstance;

    // modal property sheet
    SetErrorMode(0);
    iRet = PropertySheet(&psh);
    if (hTitleFont) 
    {
        DeleteObject (hTitleFont);
    }
     return;
}


/* ---------------------------------------------------------------------

WinMain

    Entry point for the application.
    It is here that the smart card context is entered and left.

--------------------------------------------------------------------- */

int WINAPI WinMain (
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR lpszCmdParam,
	int nCmdShow)
{
        ghInstance = hInstance;
            
        INITCOMMONCONTROLSEX stICC;
        BOOL fICC;
        stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
        stICC.dwICC = ICC_WIN95_CLASSES | ICC_STANDARD_CLASSES;
        fICC = InitCommonControlsEx(&stICC);

        DWORD dwRet = DoAcquireCardContext();
        if (0 == dwRet)
        {
            ShowPropertySheet(NULL);
            DoLeaveCardContext();
        }
        else if (ERROR_REVISION_MISMATCH == dwRet)
        {
            PresentMessageBox(IDS_BADMODULE, MB_ICONHAND);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\helpers.h ===
LPVOID WINAPI CspAllocH(
    IN SIZE_T cBytes);

//
// Function: CspFreeH
//
void WINAPI CspFreeH(
    IN LPVOID pMem);

// 
// Function: CspReAllocH
//
LPVOID WINAPI CspReAllocH(
    IN LPVOID pMem, 
    IN SIZE_T cBytes);

DWORD WINAPI CspCacheAddFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData);

DWORD WINAPI CspCacheLookupFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       *ppbData,
    IN      PDWORD      pcbData);

DWORD WINAPI CspCacheDeleteFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\sheet1.cpp ===
/*

  SHEET1.CPP

  Implements the property sheet page's behaviors.

 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commdlg.h>
#include <commctrl.h>
#include <ole2.h>
#include <stdio.h>

#include "support.h"
#include "helpers.h"
#include "res.h"
#include "utils.h"

extern BOOL fUnblockActive;
extern INT iCurrent;

extern HINSTANCE ghInstance;
extern HWND hwndContainer;
void HelpHandler(LPARAM lp);

/* ---------------------------------------------------------------------

PageProc1

    Page procedure for the first page, the PIN change page.

--------------------------------------------------------------------- */

INT_PTR CALLBACK PageProc1(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam)
{
    
    INT_PTR ret;
    HWND hwndCred = NULL;
    BOOL gfSuccess = FALSE;
    
    switch (msg)
    {
        case WM_HELP:
            {
                HelpHandler(lparam);
                break;
            };
        case WM_NOTIFY:
            {
                NMHDR *pHdr = (NMHDR *)lparam;
                switch (pHdr->code)
                {
                    case PSN_SETACTIVE:
                        // A good place to capture the hwnd of the enclosing property sheet
                        iCurrent = 1;
                        if (NULL == hwndContainer)
                        {
                            hwndContainer = pHdr->hwndFrom;
                            ASSERT(hwndContainer);
                        }
                        if (fUnblockActive)
                        {
                            // If sheet 2 still active force the UI back there.
                            SetWindowLongPtr(hwnd,DWLP_MSGRESULT,IDD_PAGE2);
                            return TRUE;
                        }
                        
                        // return 0 to permit activation to proceed on this page.
                        return 0;
                        break;
                        
                    case PSN_KILLACTIVE:
                        //User hit OK, or switched to another page
                        //do validation, return FALSE if ok to lose focus, else TRUE
                        return FALSE;
                        break;
                        
                    case PSN_QUERYCANCEL:
                        // Return TRUE to prevent cancel, FALSE to allow it.
                        return FALSE;
                        
                    case PSN_APPLY:
                        // Only process an apply for this page if it is the active page
                        // Only process an apply for this page if sheet 2 is active
                        // This will entail getting the two copies of the PIN, making sure they are 
                        //  identical, and 
                        if (iCurrent != 1)
                        {
                            // If the user was looking at the other sheet when he hit OK, do 
                            //  nothing with the page.
                            SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_NOERROR);
                            return TRUE;
                        }
                        // buffers for old pin and 2 copies of new pin
                        WCHAR szOld[100];
                        WCHAR sz[100];
                        WCHAR sz2[100];
                        // SetWindowLong(DWL_MSGRESULT = PSNRET_INVALID if unable
                        //       PSN_INVALID_NOCHANGEPAGE looks the same
                        //       PSNRET_NOERROR - OK, page can be destroyed if OK
                        SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_NOERROR);
                        GetWindowText(GetDlgItem(hwnd,IDC_OLDPIN),szOld,100);
                        GetWindowText(GetDlgItem(hwnd,IDC_NEWPIN1),sz,100);
                        GetWindowText(GetDlgItem(hwnd,IDC_NEWPIN2),sz2,100);


                        // Do not process pin change unless the two copies entered by the user were the same
                        if (0 != wcscmp(sz,sz2))
                        {
                            PresentModalMessageBox(hwnd, IDS_NOTSAME,MB_ICONHAND);
                            SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_INVALID);
                            return TRUE;
                        }
                        else 
                        {
                            // Do not process an attempt to change the pin to a blank pin
                            if (wcslen(sz) == 0)
                            {
                                PresentModalMessageBox(hwnd, IDS_BADPIN,MB_ICONHAND);
                                SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_INVALID);
                                return TRUE;
                            }
                            
                            DWORD dwRet = DoChangePin(szOld,sz);
                            if (0 == dwRet)
                            {
                                PresentModalMessageBox(hwnd,IDS_PINCHANGEOK,MB_OK);
                            }
                            else
                            {
                            switch(dwRet)
                                {
                                    case SCARD_F_INTERNAL_ERROR:
                                        PresentModalMessageBox(hwnd, IDS_INTERROR ,MB_ICONHAND);
                                        break;
                                    case SCARD_E_CANCELLED:
                                        PresentModalMessageBox(hwnd, IDS_CANCELLED,MB_ICONHAND);
                                        break;
                                    case SCARD_E_NO_SERVICE:
                                        PresentModalMessageBox(hwnd, IDS_NOSERVICE,MB_ICONHAND);
                                        break;
                                    case SCARD_E_SERVICE_STOPPED:
                                        PresentModalMessageBox(hwnd, IDS_STOPPED,MB_ICONHAND);
                                        break;
                                    case SCARD_E_UNSUPPORTED_FEATURE:
                                        PresentModalMessageBox(hwnd, IDS_UNSUPPORTED,MB_ICONHAND);
                                        break;
                                    case SCARD_E_FILE_NOT_FOUND:
                                        PresentModalMessageBox(hwnd, IDS_NOTFOUND,MB_ICONHAND);
                                        break;
                                    case SCARD_E_WRITE_TOO_MANY:
                                        PresentModalMessageBox(hwnd, IDS_TOOMANY,MB_ICONHAND);
                                        break;
                                    case SCARD_E_INVALID_CHV:
                                        // !!! Note the mapping of invalid to wrong.
                                        //  consult public\sdk\inc\scarderr.h @ 562
                                        PresentModalMessageBox(hwnd, IDS_WRONGCHV,MB_ICONHAND);
                                        break;
                                    case SCARD_W_UNSUPPORTED_CARD:
                                        PresentModalMessageBox(hwnd, IDS_UNSUPPORTED,MB_ICONHAND);
                                        break;
                                    case SCARD_W_UNRESPONSIVE_CARD:
                                        PresentModalMessageBox(hwnd, IDS_UNRESP ,MB_ICONHAND);
                                        break;
                                    case SCARD_W_REMOVED_CARD:
                                        PresentModalMessageBox(hwnd, IDS_REMOVED ,MB_ICONHAND);
                                        break;
                                    case SCARD_W_WRONG_CHV:
                                        PresentModalMessageBox(hwnd, IDS_WRONGCHV,MB_ICONHAND);
                                        break;
                                    case SCARD_W_CHV_BLOCKED:
                                        PresentModalMessageBox(hwnd, IDS_BLOCKEDCHV,MB_ICONHAND);
                                        break;
                                    default:
                                         PresentModalMessageBox(hwnd, IDS_PINCHANGEFAIL,MB_ICONHAND);
                                        break;
                                }
                                SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_INVALID);
                                return TRUE;
                            }
                        }
                    }
                    return TRUE;
            }
            break;
        case WM_COMMAND:
        	// Button clicks.
        	switch(LOWORD(wparam))
                {
                    case IDBUTTON1:
                        if (HIWORD(wparam) == BN_CLICKED)
                        {
                            SendMessage(hwndContainer,PSM_CHANGED,(WPARAM)hwnd,(LPARAM)0);
                        }
                        break;
                        
                    default:
                        break;
                }
        	break;

        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\sheet2.cpp ===
/*

  SHEET2.CPP

  Implements the property sheet page's behaviors.

  On initialization of this sheet, an authentication challenge is fetched from
  the card by a call to CardGetChallenge().  Both the challenge and the
  response from the user are in binary form when used, so helper functions
  exist to convert to and from string form.  

  This sheet is implemented as two dialogs, the opening one in which the
  challenge is presented and the user returns the response, and a second
  one in which ther user enters the new PIN for the card.

  The user switches between the two dialogs by pressing the "Unblock" 
  button on the dialog.  When this happens, the response entered by the user 
  is cached, and the UI changes to present a panel in which the user enters the 
  desired new PIN in duplicate.  There is no  second button on this panel, so 
  the user presses OK when data entry  is completed.

  At that point, the card module CardUnblockPin function is called, passing
  in the response and the new pin.

  The user is prevented from leaving this dialog once the "unblock" button is 
  pressed, except by means of the OK or Cancel buttons (Cannot switch pages).

*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commdlg.h>
#include <commctrl.h>
#include <ole2.h>
#include <stdio.h>
#include <scarderr.h>
#include "helpers.h"
#include "support.h"
#include "res.h"
#include "utils.h"
#include "helpers.h"

extern HINSTANCE ghInstance;
extern HWND hwndContainer;
extern BOOL fUnblockActive;         // showing PIN entry phase of unblock
extern INT iCurrent;
BOOL fTransacted = FALSE;

// Help handler for the sheet
void HelpHandler(LPARAM lp);

// stash of UI handles, because we use them more than normal
HWND hwndTopText = NULL;
HWND hwndCardIDLabel = NULL;
HWND hwndCardID = NULL;
HWND hwndPIN1Label = NULL;
HWND hwndPIN2Label = NULL;
HWND hwndChallengeLabel = NULL;
HWND hwndResponseLabel = NULL;
HWND hwndChallenge = NULL;
HWND hwndResponse = NULL;
HWND hwndButton1 = NULL;

// buffer to hold the response from the UI which has to persist through changes in window
// mode.
WCHAR wszResponse[100];
BYTE *pBin = NULL;
DWORD dwBin = 0;

/* ---------------------------------------------------------------------

SetWindowTextFromResource

    Accept hwnd of window and resource ID.  Fetch string from resources and write to 
    the window Text.

--------------------------------------------------------------------- */

BOOL SetWindowTextFromResource(HWND hwnd,UINT uiResid)
{
    WCHAR szTmp[1024];
    if (NULL == hwnd) return FALSE;
    if (0 != LoadString(ghInstance,uiResid,szTmp,1024))
    {
        SendMessage(hwnd,WM_SETTEXT,0,(LPARAM) szTmp);
        return TRUE;
    }
    return FALSE;
}

/* ---------------------------------------------------------------------

Page2InitUIHandles

--------------------------------------------------------------------- */

DWORD Page2InitUIHandles(HWND hwnd)
{
    hwndTopText = GetDlgItem(hwnd,IDC_TOPTEXT);
    ASSERT(hwndTopText);
    hwndPIN1Label = GetDlgItem(hwnd,IDC_NEWPIN1LABEL);
    ASSERT(hwndPIN1Label);
    hwndPIN2Label = GetDlgItem(hwnd,IDC_NEWPIN2LABEL);
    ASSERT(hwndPIN2Label);
    hwndCardIDLabel = GetDlgItem(hwnd,IDC_SCARDIDLABEL);
    ASSERT(hwndCardIDLabel);
    hwndCardID = GetDlgItem(hwnd,IDC_SCARDID);
    ASSERT(hwndCardID);
    hwndChallengeLabel = GetDlgItem(hwnd,IDC_CHALLENGELABEL);
    ASSERT(hwndChallengeLabel);
    hwndChallenge = GetDlgItem(hwnd,IDC_CHALLENGE);
    ASSERT(hwndChallenge);
    hwndResponseLabel = GetDlgItem(hwnd,IDC_RESPONSELABEL);
    ASSERT(hwndResponseLabel);
    hwndResponse = GetDlgItem(hwnd,IDC_RESPONSE);
    ASSERT(hwndResponse);
    hwndButton1 = GetDlgItem(hwnd,IDBUTTON1);
    ASSERT(hwndButton1);
    return 0;
}

/* ---------------------------------------------------------------------

Page2SetUIToChallenge
    
--------------------------------------------------------------------- */

DWORD Page2SetUIToChallenge(void)
{
    
    // Set user instructions
    SetWindowTextFromResource(hwndTopText,IDS_UNBLOCK1);

    // Hide the pin UI labels
    ShowWindow(hwndPIN1Label,SW_HIDE);
    ShowWindow(hwndPIN2Label,SW_HIDE);
    
    // Show the card id information and the challenge/response labels 
    ShowWindow(hwndCardIDLabel,SW_NORMAL);
    ShowWindow(hwndCardID,SW_NORMAL);
    ShowWindow(hwndChallengeLabel,SW_NORMAL);
    ShowWindow(hwndResponseLabel,SW_NORMAL);
    ShowWindow(hwndButton1,SW_NORMAL);

    // Show the CardID 
    WCHAR *psId = NULL;
    DWORD dwRet = DoGetCardId(&psId);
    if (psId != NULL)
        SetWindowText(hwndCardID,psId);
    
    //  Turn off password style
    SendMessage(hwndChallenge,EM_SETPASSWORDCHAR,0,0);
    SendMessage(hwndChallenge,EM_SETREADONLY,TRUE,0);
    SendMessage(hwndResponse,EM_SETPASSWORDCHAR,0,0);

    SetFocus(hwndResponse);
    return 0;
}

/* ---------------------------------------------------------------------

Page2SetUIToPin
    
--------------------------------------------------------------------- */

DWORD Page2SetUIToPin(void)
{
    // clean both text boxes
    SetWindowText(hwndChallenge,L"");
    SetWindowText(hwndResponse,L"");

    // Set user instructions
    SetWindowTextFromResource(hwndTopText,IDS_UNBLOCK2);

    // Hide challenge/response labels and the card id information
    ShowWindow(hwndChallengeLabel,SW_HIDE);
    ShowWindow(hwndResponseLabel,SW_HIDE);
    ShowWindow(hwndCardIDLabel,SW_HIDE);
    ShowWindow(hwndCardID,SW_HIDE);
    ShowWindow(hwndButton1,SW_HIDE);

    // Show the PIN labels
    ShowWindow(hwndPIN1Label,SW_NORMAL);
    ShowWindow(hwndPIN2Label,SW_NORMAL);

    //  Hide the PIN
    SendMessage(hwndChallenge,EM_SETPASSWORDCHAR,L'*',0);
    SendMessage(hwndChallenge,EM_SETREADONLY,0,0);
    SendMessage(hwndResponse,EM_SETPASSWORDCHAR,L'*',0);
    
    SetFocus(hwndChallenge);
    return 0;
}

/* ---------------------------------------------------------------------

PageProc2

    Page procedure for page 2, the Card unblock page. 

    Once the user begins the unblock operation, he is not allowed to leave this page
    except via attempting completion of the operation or cancelling.  Simply selecting
    the other UI tab is disabled once he hits the "Unblock" button.
    
--------------------------------------------------------------------- */

INT_PTR CALLBACK PageProc2(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam)
{
    
    INT_PTR ret;
    HWND hwndCred = NULL;
    BOOL gfSuccess = FALSE;
    
    switch (msg)
    {
        case WM_HELP:
            {
                // context sensitive help - call the sheet help handler
                HelpHandler(lparam);
                break;
            };
        case WM_NOTIFY:
            {
                NMHDR *pHdr = (NMHDR *)lparam;
                switch (pHdr->code)
                {
                    case PSN_SETACTIVE:
                        iCurrent = 2;
                        if (NULL == hwndContainer)
                        {
                            hwndContainer = pHdr->hwndFrom;
                            ASSERT(hwndContainer);
                        }

                       // Cache control handles the first time this page is seen
			  if (!hwndChallenge) Page2InitUIHandles(hwnd);
			  ASSERT(hwndChallenge);

                       // We are activating or returning to this page.  If we have not presented
                       //  the PIN UI yet, init the challenge/response UI.
                       if (!fUnblockActive)
                        {
                            WCHAR rgwc[100];
                            
                            Page2SetUIToChallenge();
                            
				// Fetch up to 100 characters of challenge information from the control to 
				//  see if it is empty.  If so, call CardGetChallenge.
                            if (GetWindowText(hwndChallenge,rgwc,100) == 0)
                        	{
                        	    BYTE *pChal = NULL;
                        	    DWORD dwChal = 0;
                        	    WCHAR *pUI = NULL;
                        	    DWORD dwUI = 0;
                                if (!FAILED(DoGetChallenge(&pChal,&dwChal)))
                                {
                                    if (!FAILED(DoConvertBinaryToBuffer(pChal,dwChal,(BYTE **)&pUI,&dwUI)))
                                    {
                                        SetWindowText(hwndChallenge,pUI);
                                        CspFreeH(pUI);
                                        SendMessage(hwndResponse, EM_SETSEL,0,-1);
                                        SetFocus(hwndResponse);
                                    }
                                    else ASSERT(0);     // should be impossible to get conversion error here
                                    CspFreeH(pChal);
                                }
                                else 
                                {
                                    ASSERT(0);
                                    // fetch challenge failed - present msg box and restart the page
                                    PresentModalMessageBox(hwnd, IDS_SCERROR,MB_ICONHAND);
                                    SetWindowLongPtr(hwnd,DWLP_MSGRESULT,IDD_PAGE2);
                                    return TRUE;
                                }
                        	}

                            // Put the keyboard focus on the response control.
                            SetFocus(hwndResponse);
                       }
                        return 0;
                        break;

                    case PSN_RESET:
                        // User cancelled the property sheet or hit the close button on the top right corner
                        if (fTransacted) SCardEndTransaction(pCardData->hScard,SCARD_RESET_CARD);
                        fTransacted = FALSE;
                        if (pBin)
                        {
                            CspFreeH(pBin);
                            pBin = NULL;
                            dwBin = 0;
                        }
                        return FALSE;
                        break;

                    case PSN_KILLACTIVE:
                        //User hit OK, or switched to another page
                        // Watch out!  When you are on page 2, this notification is received
                        //  before the PSN_APPLY notification
                        //do validation, return FALSE if ok to lose focus, else TRUE
                        return FALSE;
                        break;
                        
                    case PSN_QUERYCANCEL:
                        // Return TRUE to prevent cancel, FALSE to allow it.
                        // clear the edit control, and return the sheet to the initial state
                        if (fTransacted) SCardEndTransaction(pCardData->hScard,SCARD_RESET_CARD);
                        fTransacted = FALSE;
                        if (pBin)
                        {
                            CspFreeH(pBin);
                            pBin = NULL;
                            dwBin = 0;
                        }
                        if (fUnblockActive)
                        {
                            fUnblockActive = FALSE;
                            Page2SetUIToChallenge();
                            SendMessage(hwndResponse,WM_SETTEXT,0,0);
                            return FALSE;
                        }
                        return TRUE;
                        
                    case PSN_APPLY:
                        // Only process an apply for this page if sheet 2 is active
                        // This will entail getting the two copies of the PIN, making sure they are 
                        //  identical, and 
                        if (iCurrent != 2)
                        {
                            // If the user was looking at the other sheet when he hit OK, do 
                            //  nothing with the page.
                            SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_NOERROR);
                            return TRUE;
                        }
                        if (fUnblockActive)
                        {
                           WCHAR sz[100];       // buffer for PIN from the UI
                           WCHAR sz2[100];
                           
                            // SetWindowLong(DWL_MSGRESULT = PSNRET_INVALID if unable
                            //       PSN_INVALID_NOCHANGEPAGE looks the same
                            //       PSNRET_NOERROR - OK, page can be destroyed if OK
                            SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_NOERROR);
                            GetWindowText(hwndResponse,sz,100);
                            GetWindowText(hwndChallenge,sz2,100);

                            // Make sure that the two copies match
                            if (0 != wcscmp(sz,sz2))
                            {
                                PresentModalMessageBox(hwnd, IDS_NOTSAME,MB_ICONHAND);
                                SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_INVALID);
                                return TRUE;
                            }

                            // make sure we have a pin at all
                            if (wcslen(sz) == 0)
                            {
                                PresentModalMessageBox(hwnd, IDS_NEEDPIN,MB_ICONHAND);
                                SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_INVALID);
                                return TRUE;
                            }

                            {
                                // Attempt the unblock
                                char AnsiPin[64];
                                DWORD dwRet = 0;
                                
                                // change WCHAR PINs to ANSI
                                WideCharToMultiByte(GetConsoleOutputCP(),
                                    0,
                                    (WCHAR *) sz,
                                    -1,
                                    AnsiPin,
                                    64,
                                    NULL,
                                    NULL);
                                
                                dwRet = DoCardUnblock(pBin,dwBin,(BYTE *)AnsiPin,strlen(AnsiPin));

                                // done with the response binary - release it
                                if (pBin)
                                {
                                    CspFreeH(pBin);
                                    pBin = NULL;
                                    dwBin = 0;
                                }

                                // End the transaction
                                SCardEndTransaction(pCardData->hScard,SCARD_LEAVE_CARD);
                                fTransacted = FALSE;

                                // Process success or failure
                                if (!FAILED(dwRet ))
                                {
                                    PresentModalMessageBox(hwnd, IDS_UNBLOCKOK,MB_OK);
                                    return TRUE;
                                }
                                else
                                {
                                    switch(dwRet)
                                        {
                                        case SCARD_F_INTERNAL_ERROR:
                                            PresentModalMessageBox(hwnd, IDS_INTERROR ,MB_ICONHAND);
                                            break;
                                        case SCARD_E_CANCELLED:
                                            PresentModalMessageBox(hwnd, IDS_CANCELLED,MB_ICONHAND);
                                            break;
                                        case SCARD_E_NO_SERVICE:
                                            PresentModalMessageBox(hwnd, IDS_NOSERVICE,MB_ICONHAND);
                                            break;
                                        case SCARD_E_SERVICE_STOPPED:
                                            PresentModalMessageBox(hwnd, IDS_STOPPED,MB_ICONHAND);
                                            break;
                                        case SCARD_E_UNSUPPORTED_FEATURE:
                                            PresentModalMessageBox(hwnd, IDS_UNSUPPORTED,MB_ICONHAND);
                                            break;
                                        case SCARD_E_FILE_NOT_FOUND:
                                            PresentModalMessageBox(hwnd, IDS_NOTFOUND,MB_ICONHAND);
                                            break;
                                        case SCARD_E_WRITE_TOO_MANY:
                                            PresentModalMessageBox(hwnd, IDS_TOOMANY,MB_ICONHAND);
                                            break;
                                        case SCARD_E_INVALID_CHV:
                                            // !!! Note the mapping of invalid to wrong.
                                            //  consult public\sdk\inc\scarderr.h @ 562
                                            PresentModalMessageBox(hwnd, IDS_BADCHV,MB_ICONHAND);
                                            break;
                                        case SCARD_W_UNSUPPORTED_CARD:
                                            PresentModalMessageBox(hwnd, IDS_UNSUPPORTED,MB_ICONHAND);
                                            break;
                                        case SCARD_W_UNRESPONSIVE_CARD:
                                            PresentModalMessageBox(hwnd, IDS_UNRESP ,MB_ICONHAND);
                                            break;
                                        case SCARD_W_REMOVED_CARD:
                                            PresentModalMessageBox(hwnd, IDS_REMOVED ,MB_ICONHAND);
                                            break;
                                        case SCARD_W_WRONG_CHV:
                                            PresentModalMessageBox(hwnd, IDS_WRONGCHV,MB_ICONHAND);
                                            break;
                                        case SCARD_W_CHV_BLOCKED:
                                            PresentModalMessageBox(hwnd, IDS_BLOCKEDCHV,MB_ICONHAND);
                                            break;
                                        default:
                                            PresentModalMessageBox(hwnd, IDS_UNBLOCKFAIL,MB_ICONHAND);
                                            break;
                                    }
                                    
                                    SetWindowText(hwndResponse,L"");
                                    SetWindowText(hwndChallenge,L"");

                                    Page2SetUIToChallenge();
                                    fUnblockActive = FALSE;
                                    SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_INVALID);
                                    return TRUE;
                                }
                            }  // end block of code that used to be in an IF
                        }

                        // Don't close the prop sheet if OK was pressed from the unblock page, 
                        //  and we have not completed PIN entry.  Else OK to close.
                        if (!fUnblockActive) 
                        {
                            PresentModalMessageBox(hwnd, IDS_WRONGBUTTON,MB_ICONHAND);
                            SetWindowLongPtr(hwnd,DWLP_MSGRESULT,PSNRET_INVALID);
                        }
                        break;
                    }
                    return TRUE;
                }
            break;
        case WM_COMMAND:
        	// Button clicks.
        	switch(LOWORD(wparam))
                {
                    case IDBUTTON1:
                        if (HIWORD(wparam) == BN_CLICKED)
                        {
                            // On button, fetch the response text, hide the chal/response controls, hide the 
                            //  launch button, and expose the gather PIN controls.
                            //
                            //Notify the 'apply' button that something is appliable. - but we don't have an apply button
                            //SendMessage(hwndContainer,PSM_CHANGED,(WPARAM)hwnd,(LPARAM)0);
                            
                            // Get challenge value back and store it for later use by the apply code
                            INT iCount = GetWindowText(hwndResponse,wszResponse,100);
                            if (0 != iCount) 
                            {
                               if (!FAILED(DoConvertBufferToBinary((BYTE *)wszResponse,100,&pBin,&dwBin)))
                                {
                                    Page2SetUIToPin();
                                    fUnblockActive = TRUE;
                                }
                               else
                                {
                                    SetWindowText(hwndResponse,L"");
                                    PresentModalMessageBox(hwnd, IDS_BADRESPONSE,MB_ICONHAND);
                                    if (pBin) CspFreeH(pBin);
                                }
                            }
                            else 
                                PresentModalMessageBox(hwnd, IDS_NEEDRESPONSE,MB_ICONHAND);
                        }
                        break;
                        
                    default:
                        break;
                }
        	break;

        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\utils.h ===
BOOL PresentMessageBox(UINT uiMessageID,UINT uiType);
BOOL PresentModalMessageBox(HWND hw, UINT uiMessageID, UINT uiType);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\support.h ===
#include "cardmod.h"

extern PCARD_DATA pCardData;

void DoConvertWideStringToLowerCase(WCHAR *pwsz);
DWORD DoConvertBufferToBinary(BYTE *pIn, DWORD dwc,BYTE **pOut, DWORD *pdwcbOut);
DWORD DoConvertBinaryToBuffer(BYTE *pIn, DWORD dwcbIn, BYTE **pOut, DWORD *dwcbOut);
// Acquire a context for the target smart card

DWORD DoAcquireCardContext(void);

DWORD DoGetCardId(WCHAR **psz);

void DoLeaveCardContext(void);

DWORD DoChangePin(WCHAR *pOldPin, WCHAR *pNewPin);


// Get a challenge buffer from the card.  Render it as upper case BASE 64, and return it as a 
// string to the caller

DWORD DoGetChallenge(BYTE **pChallenge, DWORD *dwcbChallenge);

// Perform the PIN unblock, calling down to the card module, and assuming challenge-response
// administrative authentication.
//
// The admin auth data is coming in as a case-unknown string from the user.  Convert to binary,
// and pass the converted blob to pfnCardUnblockPin

DWORD DoCardUnblock(BYTE *pAuthData, DWORD dwcbAuthData,
	                                     BYTE *pPinData, DWORD dwcbPinData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\utils.cpp ===
#include <windows.h>
#include "helpers.h"
#include "res.h"

extern HINSTANCE ghInstance;
#define TITLESIZE 50
WCHAR szTitle[TITLESIZE] = {0};
WCHAR *pszMessage = NULL;
#define MSGBUFFERSIZE 500

BOOL PresentMessageBox(UINT uiMessageID,UINT uiType)
{
    if (NULL == ghInstance) return FALSE;
    
    if (szTitle[0] == 0)
    {
        LoadString(ghInstance, IDS_ITGTITLE,szTitle,TITLESIZE);
    }

    pszMessage = (WCHAR *) CspAllocH(MSGBUFFERSIZE * sizeof(WCHAR));
    if (NULL == pszMessage) return FALSE;
    INT iRet = LoadString(ghInstance,uiMessageID,pszMessage,MSGBUFFERSIZE);
    if (iRet == 0) return FALSE;
    MessageBox(NULL,pszMessage,szTitle,uiType);
    CspFreeH((void *) pszMessage);
    return TRUE;
}

BOOL PresentModalMessageBox(HWND hw, UINT uiMessageID,UINT uiType)
{
    if (NULL == ghInstance) return FALSE;
    
    if (szTitle[0] == 0)
    {
        LoadString(ghInstance, IDS_ITGTITLE,szTitle,TITLESIZE);
    }

    pszMessage = (WCHAR *) CspAllocH(MSGBUFFERSIZE * sizeof(WCHAR));
    if (NULL == pszMessage) return FALSE;
    INT iRet = LoadString(ghInstance,uiMessageID,pszMessage,MSGBUFFERSIZE);
    if (iRet == 0) return FALSE;
    MessageBox(hw,pszMessage,szTitle,uiType);
    CspFreeH((void *) pszMessage);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\test\cardmod\crdmdtst.c ===
#include <windows.h>
#include <wincrypt.h>
#include <winscard.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "basecsp.h"
#include <des.h>
#include <tripldes.h>
#include <modes.h>

#define TEST_CASE(X) { if (ERROR_SUCCESS != (dwSts = X)) { printf("%s", #X); goto Ret; } }

#ifndef cbCHALLENGE_RESPONSE_DATA
#define cbCHALLENGE_RESPONSE_DATA       8
#endif

//
// Defines for Admin challenge-response key
//
BYTE rgbAdminKey [] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

BYTE rgbNewAdminKey [] = {
    0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 
    0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 
    0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC 
};

#define USE_DEFAULT_ADMIN_KEY           1
#define USE_NEW_ADMIN_KEY               2

BYTE rgbUserPin [] = {
    0x30, 0x30, 0x30, 0x30
};

BYTE rgbNewUserPin [] = {
    0x41, 0x62, 0x63, 0x64
};

//
// Function: CspAllocH
//
LPVOID WINAPI CspAllocH(
    IN SIZE_T cBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cBytes);
}

//
// Function: CspFreeH
//
void WINAPI CspFreeH(
    IN LPVOID pMem)
{
    HeapFree(GetProcessHeap(), 0, pMem);
}

// 
// Function: CspReAllocH
//
LPVOID WINAPI CspReAllocH(
    IN LPVOID pMem, 
    IN SIZE_T cBytes)
{
    return HeapReAlloc(
        GetProcessHeap(), HEAP_ZERO_MEMORY, pMem, cBytes);
}

DWORD WINAPI CspCacheAddFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData)
{
    return ERROR_SUCCESS;
}

DWORD WINAPI CspCacheLookupFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       *ppbData,
    IN      PDWORD      pcbData)
{
    return ERROR_NOT_FOUND;
}

DWORD WINAPI CspCacheDeleteFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags)
{
    return ERROR_SUCCESS;
}

//
// Function: TestCreateCertificates
//
DWORD
WINAPI 
TestCreateCertificates(
    IN PCARD_DATA pCardData)
{
    DWORD dwSts = ERROR_SUCCESS;
    LPWSTR rgwszCertFiles [] = { 
        L"1",
        L"2",
        L"3"
    };
#define cCERT_FILES (sizeof(rgwszCertFiles) / sizeof(rgwszCertFiles[0]))

    WCHAR rgrgFiles [cCERT_FILES][200];
    DWORD iFile = 0;
    LPWSTR mwszFiles = NULL;
    CARD_FILE_ACCESS_CONDITION Acl = EveryoneReadUserWriteAc;
    DWORD iCurrent = 0;

    printf("Creating and deleting %d test certificate files ...\n", cCERT_FILES);

    for (   iFile = 0; 
            iFile < cCERT_FILES;
            iFile++)
    {
        wsprintf(
            rgrgFiles[iFile],
            L"%s%s",
            wszUSER_KEYEXCHANGE_CERT_PREFIX,
            rgwszCertFiles[iFile]);

        TEST_CASE(pCardData->pfnCardCreateFile(
            pCardData,
            rgrgFiles[iFile],
            Acl));            
    }

    /*
    TODO - when CardEnumFiles has been implemented, re-enable this test
    
    mwszFiles = (LPWSTR) CspAllocH(
        sizeof(WCHAR) * (1 + wcslen(wszUSER_CERTS_DIR_FULL_PATH)));

    if (NULL == mwszFiles)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    wcscpy(mwszFiles, wszUSER_CERTS_DIR_FULL_PATH);

    TEST_CASE(pCardData->pfnCardEnumFiles(
        pCardData,
        0,
        &mwszFiles));

    while (L'\0' != mwszFiles[iCurrent])
    {
        wprintf(L" %s\n", mwszFiles + iCurrent);

        iCurrent += wcslen(mwszFiles + iCurrent) + 1;
    }
    */

Ret:
    for (   iFile = 0; 
            iFile < cCERT_FILES;
            iFile++)
    {
        pCardData->pfnCardDeleteFile(
            pCardData,
            0,
            rgrgFiles[iFile]);
    }

    if (mwszFiles)
        CspFreeH(mwszFiles);

    return dwSts;
}

//
// Function: TestCreateContainers
//
// Notes: The pbKey parameter must be an AT_KEYEXCHANGE private key blob.
//
DWORD 
WINAPI
TestCreateContainers(
    IN PCARD_DATA pCardData,
    IN PBYTE pbKey,
    IN DWORD cbKey)
{
    DWORD dwSts = ERROR_SUCCESS;
    BYTE iContainer = 0;

    printf("Creating and deleting 3 key containers ...\n");

    for (iContainer = 0; iContainer < 3; iContainer++)
    {
        TEST_CASE(pCardData->pfnCardCreateContainer(
            pCardData,
            iContainer,
            CARD_CREATE_CONTAINER_KEY_IMPORT,
            AT_KEYEXCHANGE,
            cbKey,
            pbKey));
    }

Ret:
    for (iContainer = 0; iContainer < 3; iContainer++)
    {
        pCardData->pfnCardDeleteContainer(
            pCardData,
            iContainer,
            0);
    }

    return dwSts;
}

DWORD GetAdminAuthResponse(
    IN PCARD_DATA pCardData,
    IN OUT PBYTE pbResponse,
    IN DWORD cbResponse,
    IN DWORD dwWhichKey)
{
    DES3TABLE des3Table;
    PBYTE pbKey = NULL;
    PBYTE pbChallenge = NULL;
    DWORD cbChallenge = 0;
    DWORD dwSts = ERROR_SUCCESS;

    memset(&des3Table, 0, sizeof(des3Table));

    if (cbCHALLENGE_RESPONSE_DATA != cbResponse)
    {
        dwSts = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    switch (dwWhichKey)
    {
    case USE_DEFAULT_ADMIN_KEY:
        pbKey = rgbAdminKey;
        break;

    case USE_NEW_ADMIN_KEY:
        pbKey = rgbNewAdminKey;
        break;

    default:
        return (DWORD) NTE_BAD_DATA;
    }

    // Get the challenge
    TEST_CASE(pCardData->pfnCardGetChallenge(
        pCardData,
        &pbChallenge,
        &cbChallenge));

    // Build a des key using the admin auth key
    tripledes3key(&des3Table, pbKey);

    // Encrypt the challenge to compute the response
    tripledes(pbResponse, pbChallenge, (PVOID) &des3Table, ENCRYPT);

Ret:
    
    if (pbChallenge)
        pCardData->pfnCspFree(pbChallenge);

    return dwSts;
}

//
// Tests authenticating to the card as admin
//
DWORD
WINAPI
TestCardAuthenticateChallenge(
    IN PCARD_DATA pCardData)
{    
    DWORD dwSts = ERROR_SUCCESS;
    BYTE rgbResponse [cbCHALLENGE_RESPONSE_DATA];

    printf("Testing CardAuthenticateChallenge ...\n");

    // Get a challenge-response
    dwSts = GetAdminAuthResponse(
        pCardData,
        rgbResponse,
        sizeof(rgbResponse),
        USE_DEFAULT_ADMIN_KEY);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    TEST_CASE(pCardData->pfnCardAuthenticateChallenge(
        pCardData,
        rgbResponse,
        sizeof(rgbResponse),
        NULL));

    TEST_CASE(pCardData->pfnCardDeauthenticate(
        pCardData,
        wszCARD_USER_ADMIN,
        0));
Ret:

    return dwSts;
}

//
// Tests changing the admin challenge-response key
//
DWORD
WINAPI
TestCardChangeAuthenticator(
    IN PCARD_DATA pCardData)
{
    DWORD dwSts = ERROR_SUCCESS;
    BYTE rgbResponse [cbCHALLENGE_RESPONSE_DATA];

    printf("Testing CardChangeAuthenticator ...\n");

    // Get a challenge-response
    dwSts = GetAdminAuthResponse(
        pCardData,
        rgbResponse,
        sizeof(rgbResponse),
        USE_DEFAULT_ADMIN_KEY);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // Change the admin key
    TEST_CASE(pCardData->pfnCardChangeAuthenticator(
        pCardData,
        wszCARD_USER_ADMIN,
        rgbResponse,
        sizeof(rgbResponse),
        rgbNewAdminKey,
        sizeof(rgbNewAdminKey),
        0,
        NULL));

    // Get a challenge-response
    dwSts = GetAdminAuthResponse(
        pCardData,
        rgbResponse,
        sizeof(rgbResponse),
        USE_NEW_ADMIN_KEY);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // Change the admin key back
    TEST_CASE(pCardData->pfnCardChangeAuthenticator(
        pCardData,
        wszCARD_USER_ADMIN,
        rgbResponse,
        sizeof(rgbResponse),
        rgbAdminKey,
        sizeof(rgbAdminKey),
        0,
        NULL));

    TEST_CASE(pCardData->pfnCardDeauthenticate(
        pCardData,
        wszCARD_USER_ADMIN,
        0));

Ret:

    return dwSts;
}

//
// Tests unblocking the user account
//
DWORD
WINAPI
TestCardUnblockPin(
    IN PCARD_DATA pCardData)
{
    DWORD dwSts = ERROR_SUCCESS;
    BYTE rgbResponse [cbCHALLENGE_RESPONSE_DATA]; 

    printf("Testing CardUnblockPin ...\n");

    dwSts = GetAdminAuthResponse(
        pCardData,
        rgbResponse,
        sizeof(rgbResponse),
        USE_DEFAULT_ADMIN_KEY);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    // Unblock the user account
    TEST_CASE(pCardData->pfnCardUnblockPin(
        pCardData,
        wszCARD_USER_USER,
        rgbResponse,
        sizeof(rgbResponse),
        rgbNewUserPin,
        sizeof(rgbNewUserPin),
        0,
        CARD_UNBLOCK_PIN_CHALLENGE_RESPONSE));

    // Change the user account back to the default pin
    TEST_CASE(pCardData->pfnCardChangeAuthenticator(
        pCardData,
        wszCARD_USER_USER,
        rgbNewUserPin,
        sizeof(rgbNewUserPin),
        rgbUserPin,
        sizeof(rgbUserPin),
        0,
        NULL));

    TEST_CASE(pCardData->pfnCardDeauthenticate(
        pCardData,
        wszCARD_USER_USER,
        0));

Ret:

    return dwSts;
}

int _cdecl main(int argc, char * argv[])
{
    PCARD_DATA pCardData = NULL;
    DWORD dwSts = ERROR_SUCCESS;
    PFN_CARD_ACQUIRE_CONTEXT pfnCardAcquireContext = NULL;
    SCARDCONTEXT hSCardContext = 0;
    SCARDHANDLE hSCardHandle = 0;
    LPWSTR mszReaders = NULL;
    DWORD cchReaders = SCARD_AUTOALLOCATE; 
    LPWSTR mszCards = NULL;
    DWORD cchCards = SCARD_AUTOALLOCATE;
    DWORD dwActiveProtocol = 0;
    DWORD dwState = 0;
    BYTE rgbAtr [32];
    DWORD cbAtr = sizeof(rgbAtr);
    LPWSTR pszProvider = NULL;
    DWORD cchProvider = SCARD_AUTOALLOCATE;
    HMODULE hMod = INVALID_HANDLE_VALUE;
    DATA_BLOB FileContents;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    PBYTE pbKey = NULL;
    DWORD cbKey = 0;
    BYTE rgbData[2000];
    DWORD cbData = 0;
    DATA_BLOB Pin;
    CONTAINER_INFO ContainerInfo;
    BLOBHEADER *pBlobHeader = NULL;
    BYTE bContainerIndex = 0;
    CARD_PRIVATE_KEY_DECRYPT_INFO CardPrivateKeyDecryptInfo;

    memset(&ContainerInfo, 0, sizeof(ContainerInfo));
    memset(&Pin, 0, sizeof(Pin));
    memset(rgbData, 0, sizeof(rgbData));
    memset(rgbAtr, 0, sizeof(rgbAtr));
    memset(&FileContents, 0, sizeof(FileContents));
    memset(&CardPrivateKeyDecryptInfo, 0, sizeof(CardPrivateKeyDecryptInfo));

    Pin.cbData = sizeof(rgbUserPin);
    Pin.pbData = rgbUserPin;

    // 
    // Initialization
    //

    dwSts = SCardEstablishContext(
        SCARD_SCOPE_USER, NULL, NULL, &hSCardContext);
    
    if (FAILED(dwSts))
        goto Ret;
    
    dwSts = SCardListReadersW(
        hSCardContext, NULL, (LPWSTR) (&mszReaders), &cchReaders);
    
    if (FAILED(dwSts) || NULL == mszReaders)
        goto Ret;
    
    dwSts = SCardConnect(
        hSCardContext, 
        mszReaders, 
        SCARD_SHARE_SHARED, 
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
        &hSCardHandle,
        &dwActiveProtocol);
    
    if (FAILED(dwSts))
        goto Ret;    

    dwSts = SCardFreeMemory(hSCardContext, mszReaders);

    if (FAILED(dwSts))
        goto Ret;

    mszReaders = NULL;
    cchReaders = SCARD_AUTOALLOCATE;

    dwSts = SCardStatusW(
        hSCardHandle,
        (LPWSTR) (&mszReaders),
        &cchReaders,
        &dwState,
        &dwActiveProtocol,
        rgbAtr,
        &cbAtr);

    if (FAILED(dwSts))
        goto Ret;

    dwSts = SCardListCardsW(
        hSCardContext,
        rgbAtr,
        NULL,
        0,
        (LPWSTR) (&mszCards),
        &cchCards);

    if (FAILED(dwSts))
        goto Ret;
    
    dwSts = SCardGetCardTypeProviderNameW(
        hSCardContext,
        mszCards,
        SCARD_PROVIDER_CARD_MODULE,
        (LPWSTR) (&pszProvider),
        &cchProvider);

    if (FAILED(dwSts))
        goto Ret;

    hMod = LoadLibraryW(pszProvider);

    if (INVALID_HANDLE_VALUE == hMod)
    {
        wprintf(L"LoadLibrary %s", pszProvider);
        dwSts = GetLastError();
        goto Ret;
    }

    pfnCardAcquireContext = 
        (PFN_CARD_ACQUIRE_CONTEXT) GetProcAddress(
        hMod,
        "CardAcquireContext");

    if (NULL == pfnCardAcquireContext)
    {
        printf("GetProcAddress");
        dwSts = GetLastError();
        goto Ret;
    }

    pCardData = (PCARD_DATA) CspAllocH(sizeof(CARD_DATA));

    if (NULL == pCardData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    pCardData->pbAtr = rgbAtr;
    pCardData->cbAtr = cbAtr;
    pCardData->pwszCardName = mszCards;
    pCardData->dwVersion = CARD_DATA_CURRENT_VERSION;
    pCardData->pfnCspAlloc = CspAllocH;
    pCardData->pfnCspReAlloc = CspReAllocH;
    pCardData->pfnCspFree = CspFreeH;
    pCardData->pfnCspCacheAddFile = CspCacheAddFile;
    pCardData->pfnCspCacheDeleteFile = CspCacheDeleteFile;
    pCardData->pfnCspCacheLookupFile = CspCacheLookupFile;
    pCardData->hScard = hSCardHandle;
    hSCardHandle = 0;


    //
    // Now start tests
    //

    // First, connect to the card
    TEST_CASE(pfnCardAcquireContext(pCardData, 0));

    //
    // Try to read a file from the card
    //
    TEST_CASE(pCardData->pfnCardReadFile(
        pCardData,
        wszCARD_IDENTIFIER_FILE_FULL_PATH,
        0,
        &FileContents.pbData,
        &FileContents.cbData));

    //
    // Create a private key blob to import to the card
    //
    if (! CryptAcquireContext(
        &hProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    //
    // For now, make this key really small so we're sure to not run out of 
    // space on wimpy test cards.
    //
    if (! CryptGenKey(
        hProv, AT_KEYEXCHANGE, (1024 << 16) | CRYPT_EXPORTABLE, &hKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    if (! CryptExportKey(
        hKey, 0, PRIVATEKEYBLOB, 0, NULL, &cbKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    pbKey = (PBYTE) CspAllocH(cbKey);

    if (NULL == pbKey)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (! CryptExportKey(
        hKey, 0, PRIVATEKEYBLOB, 0, pbKey, &cbKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    CryptDestroyKey(hKey);
    hKey = 0;

    //
    // Test challenge-response pin change and unblock
    //
    TEST_CASE(TestCardAuthenticateChallenge(pCardData));
    TEST_CASE(TestCardChangeAuthenticator(pCardData));
    TEST_CASE(TestCardUnblockPin(pCardData));

    //
    // Authenticate User
    //
    TEST_CASE(pCardData->pfnCardSubmitPin(
        pCardData,
        wszCARD_USER_USER,
        Pin.pbData,
        Pin.cbData,
        NULL));

    //
    // Now create a new container on the card via Key Import
    //
    TEST_CASE(pCardData->pfnCardCreateContainer(
        pCardData,
        bContainerIndex,
        CARD_CREATE_CONTAINER_KEY_IMPORT,
        AT_KEYEXCHANGE,
        cbKey,
        pbKey));

    //
    // Now create a signature key in the same container
    //
    pBlobHeader = (BLOBHEADER *) pbKey;
    pBlobHeader->aiKeyAlg = CALG_RSA_SIGN;

    TEST_CASE(pCardData->pfnCardCreateContainer(
        pCardData,
        bContainerIndex,
        CARD_CREATE_CONTAINER_KEY_IMPORT,
        AT_SIGNATURE,
        cbKey,
        pbKey));

    //
    // Get the Container Info for the new container
    //
    ContainerInfo.dwVersion = CONTAINER_INFO_CURRENT_VERSION;

    TEST_CASE(pCardData->pfnCardGetContainerInfo(
        pCardData,
        bContainerIndex,
        0, 
        &ContainerInfo));

    // 
    // Use the public key blob that we got from the card and import it
    // into the software CSP.
    //
    if (! CryptImportKey(
        hProv, 
        ContainerInfo.pbKeyExPublicKey, 
        ContainerInfo.cbKeyExPublicKey, 
        0, 0, &hKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    //
    // RSA Encrypt some data using the public key in the software
    // CSP.
    //
    cbData = 20; 

    while (cbData--)
        rgbData[cbData] = (BYTE) cbData;

    cbData = 20;
    if (! CryptEncrypt(
        hKey, 0, TRUE, 0, rgbData, &cbData, sizeof(rgbData)))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    CardPrivateKeyDecryptInfo.bContainerIndex = bContainerIndex;
    CardPrivateKeyDecryptInfo.dwKeySpec = AT_KEYEXCHANGE;
    CardPrivateKeyDecryptInfo.dwVersion = 
        CARD_PRIVATE_KEY_DECRYPT_INFO_CURRENT_VERSION;
    CardPrivateKeyDecryptInfo.pbData = rgbData;
    CardPrivateKeyDecryptInfo.cbData = 1024 / 8;

    TEST_CASE(pCardData->pfnCardPrivateKeyDecrypt(
        pCardData,
        &CardPrivateKeyDecryptInfo));

    // CryptEncrypt byte-reversed the input portion of the plaintext, per
    // PKCS2.
    cbData = 20;
    while (cbData--)
    {
        if (cbData != rgbData[20 - (cbData + 1)])
        {
            printf("RSA decrypted blob doesn't match\n");
            dwSts = -1;
            goto Ret;
        }
    }

    //
    // Now delete the container
    //
    TEST_CASE(pCardData->pfnCardDeleteContainer(
        pCardData,
        bContainerIndex,
        0));

    //
    // Create a few containers, enumerate them, then delete them.
    //
    TEST_CASE(TestCreateContainers(
        pCardData,
        pbKey,
        cbKey));

    //
    // Create a few "certificate" files, enumerate them, then delete them.
    //
    TEST_CASE(TestCreateCertificates(
        pCardData));

    //
    // Cleanup the card context
    //
    TEST_CASE(pCardData->pfnCardDeleteContext(pCardData));    
    
Ret:
    
    if (ContainerInfo.pbKeyExPublicKey)
        CspFreeH(ContainerInfo.pbKeyExPublicKey);
    if (ContainerInfo.pbSigPublicKey)
        CspFreeH(ContainerInfo.pbSigPublicKey);
    if (pbKey)
        CspFreeH(pbKey);
    if (hKey)
        CryptDestroyKey(hKey);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (mszCards)
        SCardFreeMemory(hSCardContext, mszCards);
    if (mszReaders)
        SCardFreeMemory(hSCardContext, mszReaders);
    if (pszProvider)
        SCardFreeMemory(hSCardContext, pszProvider);
    if (hSCardHandle)
        SCardDisconnect(hSCardHandle, SCARD_RESET_CARD);
    if (FileContents.pbData)
        CspFreeH(FileContents.pbData);
    
    if (pCardData)
    {
        if (pCardData->hScard)
            SCardDisconnect(pCardData->hScard, SCARD_RESET_CARD);

        CspFreeH(pCardData);
        pCardData = NULL;
    }

    if (hSCardContext)
        SCardReleaseContext(hSCardContext);
    
    if (ERROR_SUCCESS != dwSts)
        printf(" failed, 0x%x\n", dwSts);
    else 
        printf("Success.\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\pintool\support.cpp ===
#include <windows.h>
#include <winscard.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <guiddef.h>
#include "basecsp.h"
#include "pincache.h"
#include "helpers.h"

extern HINSTANCE ghInstance;
PCARD_DATA pCardData = NULL;
SCARDCONTEXT hSCardContext = 0;

// global array to hold the provider name
WCHAR gszProvider[MAX_PATH];

#ifdef DBG
#define ERROUT(x) ShowError(x)
#else
#define ERROUT(x)
#endif

void ShowError(DWORD dwErr)
{
    WCHAR sz[200];
    swprintf(sz,L"Returned status %x\n",dwErr);
    OutputDebugString(sz);
}

void DoConvertWideStringToLowerCase(WCHAR *pwsz)
{
    WCHAR c;
    if (NULL == pwsz) return;
    while (NULL != (c = *pwsz)) 
    {
        *pwsz++= towlower(c);
    }
}

// Accept an input buffer containing text, and convert it to binary
// The binary buffer is allocated new and must be freed by the caller
//
// The incoming data consists of hex digits and spaces.  Hex digits are 
//  assembled into bytes as pairs, with the first digit becoming the 
//  most significant nybble.  Spaces in input are discarded with no effect 
//  so that "12 34 5" becomes 0x12 0x34 0x5, as soes "1 2 3 4 5."

DWORD DoConvertBufferToBinary(BYTE *pIn, DWORD dwcbIn, 
							BYTE **pOut, DWORD *dwcbOut)
{
    WCHAR szTemp[10];
    WCHAR *pInput = (WCHAR *) pIn;
    BYTE *pAlloc   = NULL;
    BYTE *pOutput = NULL;
    DWORD dwOut = 0;
    DWORD dwRet = -1;
    BOOL fInabyte = FALSE;
    BOOL fErr = FALSE;
    BYTE b;
    BYTE b2;
    WCHAR c;
    
    // Bag it if no data or output ptrs obviously invalid
    if ((NULL == pIn) || (dwcbIn == 0)) goto Ret;
    if ((NULL == pOut) || (NULL == dwcbOut)) goto Ret;

    // count input characters
    int iLen = wcslen(pInput);
    
    if (iLen == 0) goto Ret;

    // guaranteed to contain the output
    pAlloc = (BYTE *)CspAllocH((iLen / 2) + 2);
    pOutput = pAlloc;

    for (int i = 0;i<iLen;i++) 
    {

        c = pInput[i];
        if (c == 0) break;
        
        // skip over whitespace in the input
        c =  towupper(c);
        if (c <= L' ') 
        {
            fInabyte = FALSE;
            continue;
        }
        
        if (!fInabyte) 
        {
            b = 0;
        }
        b2 = 0;

        // error on not legal hex character
        if ( ((c < L'0') || (c > L'F')) ||
            ((c > L'9') && (c < L'A')) )
        {
            dwRet = -1;
            *pOut = 0;
            *dwcbOut = 0;
            if (pAlloc) CspFreeH(pAlloc);
            goto Ret;
        }
        else if (c <= L'9')
            b2 = c - L'0';
        else
            b2 = c - L'A' + 10;
        
        if (fInabyte)
        {
            b = (b << 4) + b2;
            fInabyte = FALSE;
            dwOut += 1;
            *pOutput++ = b;
        }
        else
        {
            b = b2;
            fInabyte = TRUE;
        }
    }

    // Permit writing an unpaired terminating hex character to the tail of the binary as a 0x byte.
    if (fInabyte)
    {
            fInabyte = FALSE;
            dwOut += 1;
            *pOutput++ = b;
    }
    
    dwRet = 0;
    *pOut = pAlloc;
    *dwcbOut = dwOut;
    
    Ret:
    ERROUT(dwRet);
    return dwRet;
}

DWORD DoConvertBinaryToBuffer(BYTE *pIn, DWORD dwcbIn, 
                							BYTE **pOut, DWORD *dwcbOut)
{
    WCHAR *pAlloc = NULL;
    WCHAR *pOutput = NULL;
    DWORD dwOut = 0;
    DWORD dwRet = -1;
    BOOL fErr = FALSE;
    BYTE b;
    
    // Bag it if no data or output ptrs obviously invalid
    if ((NULL == pIn)   || (dwcbIn == 0))       goto Ret;
    if ((NULL == pOut) || (NULL == dwcbOut))  goto Ret;

    pAlloc = (WCHAR *)CspAllocH(((dwcbIn * 3) + 1) * sizeof(WCHAR));
    if (NULL == pAlloc)  goto Ret;
    pOutput = pAlloc;

    for (DWORD i = 0 ; i<dwcbIn ; i++) 
    {   
        b = pIn[i];
        b &= 0xf0;
        b = b>> 4;
        b += L'0';
        if (b > L'9') b += 7;
        *pOutput++ = b;
        
        b = pIn[i];
        b &= 0x0f;
        b += L'0';
        if (b > L'9') b += 7;
        *pOutput++ = b;
        dwOut += 2;

        // a space every 4 characters
        if ((i > 0) && (((i+1) % 2) == 0)) *pOutput++ = L' ';
    }
    *pOutput = 0;
    
    dwRet = 0;
    *pOut = (BYTE *) pAlloc;
    *dwcbOut = (pOutput - pAlloc -1) * sizeof(WCHAR);
    
    Ret:
    ERROUT(dwRet);
    return dwRet;
}

//
// Find any card present in an attached reader using "minimal" scarddlg UI
//
DWORD GetCardHandleViaUI(
    IN  SCARDCONTEXT hSCardContext,
    OUT SCARDHANDLE *phSCardHandle,
    IN  DWORD cchMatchedCard,
    OUT LPWSTR wszMatchedCard,
    IN  DWORD cchMatchedReader,
    OUT LPWSTR wszMatchedReader)
{
    OPENCARDNAME_EXW ocnx;
    DWORD dwSts = ERROR_SUCCESS;

    memset(&ocnx, 0, sizeof(ocnx));
 
    ocnx.dwStructSize = sizeof(ocnx);
    ocnx.hSCardContext = hSCardContext;
    ocnx.lpstrCard = wszMatchedCard;
    ocnx.nMaxCard = cchMatchedCard;
    ocnx.lpstrRdr = wszMatchedReader;
    ocnx.nMaxRdr = cchMatchedReader;
    ocnx.dwShareMode = SCARD_SHARE_SHARED;
    ocnx.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
    ocnx.dwFlags = SC_DLG_MINIMAL_UI;

    dwSts = SCardUIDlgSelectCardW(&ocnx);

    *phSCardHandle = ocnx.hCardHandle;

    return dwSts;
}

// Acquire a context for the target smart card

DWORD DoAcquireCardContext(void)
{
    DWORD dwSts = ERROR_SUCCESS;
    PFN_CARD_ACQUIRE_CONTEXT pfnCardAcquireContext = NULL;
    SCARDHANDLE hSCardHandle = 0;
    LPWSTR mszReaders = NULL;
    DWORD cchReaders = SCARD_AUTOALLOCATE; 
    LPWSTR mszCards = NULL;
    DWORD cchCards = SCARD_AUTOALLOCATE;
    DWORD dwActiveProtocol = 0;
    DWORD dwState = 0;
    BYTE rgbAtr [32];
    DWORD cbAtr = sizeof(rgbAtr);
    LPWSTR pszProvider = NULL;
    DWORD cchProvider = SCARD_AUTOALLOCATE;
    HMODULE hMod = 0;
    WCHAR wszMatchedCard[MAX_PATH];
    WCHAR wszMatchedReader[MAX_PATH];
    HMODULE hThis = (HMODULE) ghInstance;	// this executable

    memset(rgbAtr, 0, sizeof(rgbAtr));

    // 
    // Initialization
    //

    dwSts = SCardEstablishContext(
        SCARD_SCOPE_USER, NULL, NULL, &hSCardContext);
    
    if (FAILED(dwSts))
        goto Ret;
    
    dwSts = GetCardHandleViaUI(
        hSCardContext,
        &hSCardHandle,
        MAX_PATH,
        wszMatchedCard,
        MAX_PATH,
        wszMatchedReader);
  
    if (FAILED(dwSts))
        goto Ret;    

    mszReaders = NULL;
    cchReaders = SCARD_AUTOALLOCATE;

    dwSts = SCardStatusW(
        hSCardHandle,
        (LPWSTR) (&mszReaders),
        &cchReaders,
        &dwState,
        &dwActiveProtocol,
        rgbAtr,
        &cbAtr);

    if (FAILED(dwSts))
        goto Ret;

    dwSts = SCardListCardsW(
        hSCardContext,
        rgbAtr,
        NULL,
        0,
        (LPWSTR) (&mszCards),
        &cchCards);

    if (FAILED(dwSts))
        goto Ret;
    
    dwSts = SCardGetCardTypeProviderNameW(
        hSCardContext,
        mszCards,
        SCARD_PROVIDER_CARD_MODULE,
        (LPWSTR) (&pszProvider),
        &cchProvider);

    if (FAILED(dwSts))
        goto Ret;

    // Load the card module for the selected card
    //  acquire context and trade initializations

    hMod = LoadLibraryW(pszProvider);

    if (INVALID_HANDLE_VALUE == hMod)
    {
        dwSts = GetLastError();
        goto Ret;
    }

    // This fails for an unsupported card type (no card module)

    pfnCardAcquireContext = 
        (PFN_CARD_ACQUIRE_CONTEXT) GetProcAddress(
        hMod,
        "CardAcquireContext");

    if (NULL == pfnCardAcquireContext)
    {
        dwSts = GetLastError();
        goto Ret;
    }

    pCardData = (PCARD_DATA) CspAllocH(sizeof(CARD_DATA));

    if (NULL == pCardData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    memset(pCardData,0,sizeof(CARD_DATA));
    pCardData->pbAtr = rgbAtr;
    pCardData->cbAtr = cbAtr;
    pCardData->pwszCardName = mszCards;
    pCardData->dwVersion = CARD_DATA_CURRENT_VERSION;
    pCardData->pfnCspAlloc = CspAllocH;
    pCardData->pfnCspReAlloc = CspReAllocH;
    pCardData->pfnCspFree = CspFreeH;
    pCardData->pfnCspCacheAddFile = CspCacheAddFile;
    pCardData->pfnCspCacheDeleteFile = CspCacheDeleteFile;
    pCardData->pfnCspCacheLookupFile = CspCacheLookupFile;
    pCardData->hScard = hSCardHandle;
    hSCardHandle = 0;

    // First, connect to the card
    dwSts = pfnCardAcquireContext(pCardData, 0);

Ret:
	if (FAILED(dwSts))
	{
		CspFreeH(pCardData);
	}
	ERROUT(dwSts);
	return dwSts;
}


void DoLeaveCardContext(void)
{
	if (pCardData)
	{
		if (pCardData->hScard) 
			SCardDisconnect(pCardData->hScard,SCARD_RESET_CARD);
		CspFreeH(pCardData);
	}
	if (hSCardContext)
		SCardReleaseContext(hSCardContext);
}

// Get the CardID, returned in a new allocation as an SZ string.  It must be freed by the 
//  user.  Is returned NULL on error.

DWORD DoGetCardId(
    WCHAR **pSz)
{
        DWORD dwSts = ERROR_SUCCESS;
        WCHAR *pString = NULL;
        GUID *pGuid;
        DWORD ccGuid = 0;

        dwSts = pCardData->pfnCardReadFile(pCardData,
            wszCARD_IDENTIFIER_FILE_FULL_PATH,
            0, 
            (PBYTE *) &pGuid,
            &ccGuid);
    
        if (ERROR_SUCCESS != dwSts)
            goto Ret;

        pString = (WCHAR *) CspAllocH(40 * sizeof(WCHAR));

        if (pString == NULL)
        {
            *pSz = NULL;
            dwSts = -1;
            goto Ret;
        }
        
        DWORD ccSz = 40;
    
        _snwprintf(pString, ccSz,L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
		    // first copy...
		    pGuid->Data1, pGuid->Data2, pGuid->Data3,
		    pGuid->Data4[0], pGuid->Data4[1], pGuid->Data4[2], pGuid->Data4[3],
		    pGuid->Data4[4], pGuid->Data4[5], pGuid->Data4[6], pGuid->Data4[7]);

       *pSz = pString;
Ret:
       return dwSts;

}


// Get a challenge buffer from the card.  Render it as upper case BASE 64, and return it as a 
// string to the caller
/*
DWORD WINAPI CardChangePin(
	IN CARD_DATA *pCardData,
	IN LPWSTR pwszUserId,			
IN BYTE   *pbCurrentAuthenticator,
IN DWORD dwcbCurrentAuthenticator,
IN BYTE   *pbNewAuthenticator,
IN DWORD dwcbNewAuthenticator,
IN DWORD dwcRetryCount,
IN DWORD dwFlags,
OUT OPTIONAL DWORD *pdwcAttemptsRemaining
);

*/

DWORD DoInvalidatePinCache(
    void)
{
    DWORD dwSts = ERROR_SUCCESS;
    DATA_BLOB dbCacheFile;
    CARD_CACHE_FILE_FORMAT *pCache = NULL;

        memset(&dbCacheFile, 0, sizeof(dbCacheFile));
    
        dwSts = pCardData->pfnCardReadFile(
            pCardData,
            wszCACHE_FILE_FULL_PATH,
            0, 
            &dbCacheFile.pbData,
            &dbCacheFile.cbData);
    
        if (ERROR_SUCCESS != dwSts)
            goto Ret;
    
        if (sizeof(CARD_CACHE_FILE_FORMAT) != dbCacheFile.cbData)
        {
            dwSts = ERROR_BAD_LENGTH;
            goto Ret;
        }

        // We have the cache file contents at dbCacheFile.pbData
        //  Update the PinsFreshness value, and write it back

        pCache = (CARD_CACHE_FILE_FORMAT *) dbCacheFile.pbData;
        BYTE bPinFreshness = pCache->bPinsFreshness;
        pCache->bPinsFreshness = bPinFreshness + 1;
        
        dwSts = pCardData->pfnCardWriteFile(
            pCardData,
            wszCACHE_FILE_FULL_PATH,
            0, 
            dbCacheFile.pbData,
            dbCacheFile.cbData);

        if (ERROR_SUCCESS != dwSts)
            goto Ret;

Ret:

    if (dbCacheFile.pbData)
        CspFreeH(dbCacheFile.pbData);
    return dwSts;
}


DWORD DoChangePin(WCHAR *pOldPin,  WCHAR *pNewPin)
{
    char AnsiOldPin[64];
    char AnsiNewPin[64];
    
    WCHAR szName[] = wszCARD_USER_USER;
    //DoConvertWideStringToLowerCase(szName);
    
    // change WCHAR PINs to ANSI
    WideCharToMultiByte(GetConsoleOutputCP(),
        0,
        (WCHAR *) pOldPin,
        -1,
        AnsiOldPin,
        64,
        NULL,
        NULL);
    
    WideCharToMultiByte(GetConsoleOutputCP(),
        0,
        (WCHAR *) pNewPin,
        -1,
        AnsiNewPin,
        64,
        NULL,
        NULL);
    
    DWORD dwcbOldPin = strlen(AnsiOldPin);
    DWORD dwcbNewPin = strlen( AnsiNewPin);

    if (dwcbOldPin == 0) return -1;
    
    DWORD dwSts = pCardData->pfnCardChangeAuthenticator(pCardData, szName,
                                                                                        (BYTE *)AnsiOldPin, dwcbOldPin,
                                                                                        (BYTE *)AnsiNewPin, dwcbNewPin,
                                                                                        0,
                                                                                        NULL);
    ERROUT(dwSts);
    if (0 == dwSts) DoInvalidatePinCache();
    return dwSts;
}

// Get a challenge buffer from the card.  Render it as upper case BASE 64, and return it as a 
// string to the caller
DWORD DoGetChallenge(BYTE **pChallenge, DWORD *dwcbChallenge)
{
	DWORD dwSts = pCardData->pfnCardGetChallenge(pCardData, pChallenge,dwcbChallenge);
	if (FAILED(dwSts))
	{
		dwcbChallenge = 0;
		return dwSts;
	}
	ERROUT(dwSts);
	return dwSts;
}

// Perform the PIN unblock, calling down to the card module, and assuming challenge-response
// administrative authentication.
//
// The admin auth data is coming in as a case-unknown string from the user.  Convert to binary,
// and pass the converted blob to pfnCardUnblockPin

DWORD DoCardUnblock(BYTE *pAuthData, DWORD dwcbAuthData,
	                                     BYTE *pPinData, DWORD dwcbPinData)
{

    WCHAR szName[] = wszCARD_USER_USER;
    //DoConvertWideStringToLowerCase(szName);
    
    // Convert the incoming buffer

    DWORD dwRet = pCardData->pfnCardUnblockPin(
        pCardData,
        szName,
        pAuthData,
        dwcbAuthData,
        pPinData,
        dwcbPinData,
        0,
        CARD_UNBLOCK_PIN_CHALLENGE_RESPONSE);

    // this call should be unnecessary, as the unblock should deauth the admin
    //  I can't reset the card from the card module interface, so I'll ask the user to remove
    //  his card from the reader if deauth fails.  In the real thing, I'll reset the card.

    pCardData->pfnCardDeauthenticate(
				        pCardData,
				        wszCARD_USER_USER,0);

    // Deallocate the buffer for the converted response
    ERROUT(dwRet);
    if (0 == dwRet) DoInvalidatePinCache();
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\test\compress\compress.c ===
#include <windows.h>
#include <wincrypt.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <zlib.h>
#include "compress.h"

BYTE rgbTestCer [] = {
0x30, 0x82, 0x05, 0x8f, 0x30, 0x82, 0x04, 0xf8, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0a, 0x1e,
0x39, 0xa7, 0x1c, 0x00, 0x01, 0x00, 0x0f, 0xc9, 0x64, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x4b, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a,
0x13, 0x09, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x0e, 0x30, 0x0c, 0x06,
0x03, 0x55, 0x04, 0x0b, 0x13, 0x05, 0x4e, 0x74, 0x64, 0x65, 0x76, 0x31, 0x18, 0x30, 0x16, 0x06,
0x03, 0x55, 0x04, 0x03, 0x13, 0x0f, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x20, 0x49, 0x53, 0x53, 0x55,
0x45, 0x33, 0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d, 0x30, 0x31, 0x31, 0x31, 0x31, 0x39, 0x32,
0x31, 0x32, 0x39, 0x31, 0x34, 0x5a, 0x17, 0x0d, 0x30, 0x32, 0x30, 0x39, 0x32, 0x30, 0x32, 0x31,
0x33, 0x33, 0x32, 0x38, 0x5a, 0x30, 0x7b, 0x31, 0x13, 0x30, 0x11, 0x06, 0x0a, 0x09, 0x92, 0x26,
0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x03, 0x63, 0x6f, 0x6d, 0x31, 0x19, 0x30, 0x17,
0x06, 0x0a, 0x09, 0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x09, 0x6d, 0x69,
0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x15, 0x30, 0x13, 0x06, 0x0a, 0x09, 0x92, 0x26,
0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x05, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x31, 0x0c,
0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x03, 0x49, 0x54, 0x47, 0x31, 0x0e, 0x30, 0x0c,
0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x05, 0x55, 0x73, 0x65, 0x72, 0x73, 0x31, 0x14, 0x30, 0x12,
0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0b, 0x44, 0x61, 0x6e, 0x20, 0x47, 0x72, 0x69, 0x66, 0x66,
0x69, 0x6e, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0x89,
0x9f, 0x70, 0xb2, 0x5e, 0xfd, 0x99, 0x31, 0xb8, 0xcd, 0x17, 0xba, 0x2f, 0x7c, 0xb9, 0xed, 0xde,
0x56, 0xff, 0xb3, 0x37, 0x78, 0xd0, 0x51, 0xae, 0x14, 0x7c, 0xae, 0x91, 0x1f, 0xb0, 0x26, 0x87,
0xaf, 0x43, 0x3e, 0xde, 0x59, 0xbb, 0xc8, 0xcf, 0xbe, 0x25, 0x03, 0x0a, 0x1c, 0xd8, 0x18, 0x4d,
0x1a, 0xbd, 0xe3, 0xb0, 0x73, 0xc9, 0x2b, 0x29, 0x0b, 0x0a, 0x12, 0xdd, 0x55, 0x37, 0xcb, 0x2b,
0x8f, 0xf2, 0xe6, 0x2c, 0x2e, 0x7f, 0x8d, 0x71, 0x9a, 0x77, 0xf6, 0x4e, 0x4e, 0x3e, 0x94, 0x2e,
0xdb, 0x3c, 0xd4, 0xde, 0x32, 0x1f, 0xc7, 0xb9, 0x96, 0x72, 0xbb, 0x0d, 0x80, 0xc9, 0xc0, 0x3e,
0x84, 0xee, 0x33, 0x3c, 0x62, 0x46, 0x17, 0x7d, 0x27, 0x83, 0x15, 0xdd, 0x2f, 0x2f, 0x0a, 0xb3,
0xcf, 0x76, 0xf6, 0x9b, 0x0d, 0x70, 0x6d, 0x99, 0x5b, 0xca, 0xba, 0x07, 0x8a, 0x44, 0xd3, 0x02,
0x03, 0x01, 0x00, 0x01, 0xa3, 0x82, 0x03, 0x48, 0x30, 0x82, 0x03, 0x44, 0x30, 0x0b, 0x06, 0x03,
0x55, 0x1d, 0x0f, 0x04, 0x04, 0x03, 0x02, 0x05, 0xa0, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e,
0x04, 0x16, 0x04, 0x14, 0x38, 0xef, 0x1a, 0xde, 0x6f, 0x3e, 0xa8, 0x73, 0x86, 0x74, 0xb8, 0x27,
0x4b, 0x9e, 0x8a, 0x98, 0xf7, 0x67, 0x70, 0x47, 0x30, 0x2b, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04,
0x01, 0x82, 0x37, 0x14, 0x02, 0x04, 0x1e, 0x1e, 0x1c, 0x00, 0x53, 0x00, 0x6d, 0x00, 0x61, 0x00,
0x72, 0x00, 0x74, 0x00, 0x63, 0x00, 0x61, 0x00, 0x72, 0x00, 0x64, 0x00, 0x4c, 0x00, 0x6f, 0x00,
0x67, 0x00, 0x6f, 0x00, 0x6e, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16,
0x80, 0x14, 0xc9, 0x44, 0x56, 0x4a, 0x90, 0x13, 0x7c, 0xa9, 0xf3, 0x33, 0x06, 0x6b, 0xde, 0xd0,
0x99, 0xbb, 0xe7, 0xc8, 0xce, 0xe9, 0x30, 0x82, 0x01, 0x26, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04,
0x82, 0x01, 0x1d, 0x30, 0x82, 0x01, 0x19, 0x30, 0x82, 0x01, 0x15, 0xa0, 0x82, 0x01, 0x11, 0xa0,
0x82, 0x01, 0x0d, 0x86, 0x81, 0xc4, 0x6c, 0x64, 0x61, 0x70, 0x3a, 0x2f, 0x2f, 0x2f, 0x43, 0x4e,
0x3d, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25,
0x32, 0x30, 0x43, 0x41, 0x2c, 0x43, 0x4e, 0x3d, 0x57, 0x48, 0x49, 0x43, 0x41, 0x33, 0x2c, 0x43,
0x4e, 0x3d, 0x43, 0x44, 0x50, 0x2c, 0x43, 0x4e, 0x3d, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x25,
0x32, 0x30, 0x4b, 0x65, 0x79, 0x25, 0x32, 0x30, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73,
0x2c, 0x43, 0x4e, 0x3d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d,
0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x44, 0x43,
0x3d, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2c, 0x44, 0x43, 0x3d, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73,
0x6f, 0x66, 0x74, 0x2c, 0x44, 0x43, 0x3d, 0x63, 0x6f, 0x6d, 0x3f, 0x63, 0x65, 0x72, 0x74, 0x69,
0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
0x4c, 0x69, 0x73, 0x74, 0x3f, 0x62, 0x61, 0x73, 0x65, 0x3f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
0x43, 0x6c, 0x61, 0x73, 0x73, 0x3d, 0x63, 0x52, 0x4c, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62,
0x75, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x86, 0x44, 0x68, 0x74, 0x74, 0x70,
0x3a, 0x2f, 0x2f, 0x77, 0x68, 0x69, 0x63, 0x61, 0x33, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e,
0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x65,
0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f, 0x6c, 0x6c, 0x2f, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32,
0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25, 0x32, 0x30, 0x43, 0x41, 0x2e, 0x63, 0x72, 0x6c,
0x30, 0x82, 0x01, 0x42, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x82,
0x01, 0x34, 0x30, 0x82, 0x01, 0x30, 0x30, 0x81, 0xbd, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05,
0x07, 0x30, 0x02, 0x86, 0x81, 0xb0, 0x6c, 0x64, 0x61, 0x70, 0x3a, 0x2f, 0x2f, 0x2f, 0x43, 0x4e,
0x3d, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25,
0x32, 0x30, 0x43, 0x41, 0x2c, 0x43, 0x4e, 0x3d, 0x41, 0x49, 0x41, 0x2c, 0x43, 0x4e, 0x3d, 0x50,
0x75, 0x62, 0x6c, 0x69, 0x63, 0x25, 0x32, 0x30, 0x4b, 0x65, 0x79, 0x25, 0x32, 0x30, 0x53, 0x65,
0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74,
0x69, 0x6f, 0x6e, 0x2c, 0x44, 0x43, 0x3d, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2c, 0x44, 0x43, 0x3d,
0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2c, 0x44, 0x43, 0x3d, 0x63, 0x6f, 0x6d,
0x3f, 0x63, 0x41, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x3f, 0x62,
0x61, 0x73, 0x65, 0x3f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x3d,
0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x75, 0x74,
0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30, 0x6e, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
0x30, 0x02, 0x86, 0x62, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x68, 0x69, 0x63, 0x61,
0x33, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66,
0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x65, 0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f, 0x6c, 0x6c,
0x2f, 0x57, 0x48, 0x49, 0x43, 0x41, 0x33, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69,
0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x5f, 0x4e, 0x54, 0x44, 0x45,
0x56, 0x25, 0x32, 0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25, 0x32, 0x30, 0x43, 0x41, 0x28,
0x31, 0x29, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x18, 0x30,
0x16, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x02, 0x06, 0x08, 0x2b,
0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x30, 0x37, 0x06, 0x03, 0x55, 0x1d, 0x11, 0x04, 0x30,
0x30, 0x2e, 0xa0, 0x2c, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x03,
0xa0, 0x1e, 0x0c, 0x1c, 0x64, 0x61, 0x6e, 0x67, 0x72, 0x69, 0x66, 0x66, 0x40, 0x6e, 0x74, 0x64,
0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d,
0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03,
0x81, 0x81, 0x00, 0x92, 0xe6, 0x34, 0x6a, 0x1b, 0x71, 0xe6, 0x91, 0x4a, 0x92, 0x35, 0x00, 0x2d,
0xe3, 0x20, 0x50, 0x68, 0x01, 0x7d, 0x92, 0xe7, 0xc1, 0x5c, 0xfd, 0x13, 0xb5, 0x49, 0x31, 0xc5,
0xc5, 0x0d, 0x5f, 0xa5, 0xf3, 0xa6, 0xd1, 0xb4, 0x28, 0x7b, 0x70, 0xfd, 0x16, 0xd2, 0x60, 0x3a,
0xa9, 0xa5, 0x39, 0x08, 0xed, 0x36, 0x76, 0xa5, 0x44, 0xf3, 0x45, 0x8e, 0x56, 0x63, 0xd6, 0xfe,
0x0e, 0xbd, 0x41, 0xf0, 0xdf, 0x2c, 0xa7, 0xdf, 0x03, 0xda, 0xf0, 0x35, 0x2f, 0x51, 0xab, 0xa3,
0x0d, 0x94, 0xb2, 0x89, 0x12, 0xe0, 0x30, 0x6f, 0xee, 0x1f, 0x09, 0x21, 0xe4, 0x3e, 0x51, 0x4f,
0xf0, 0x4a, 0xb3, 0x30, 0x87, 0xef, 0x7a, 0x49, 0x2f, 0x0e, 0x30, 0x4d, 0xd0, 0xd5, 0x4b, 0xfc,
0x77, 0xac, 0x81, 0xb8, 0xf1, 0x36, 0xfa, 0x9e, 0xbb, 0x35, 0x5b, 0xf7, 0x4a, 0x5f, 0x81, 0x16,
0x98, 0x27, 0xd7
};

#define cbTestCer sizeof(rgbTestCer)

int _cdecl main(int argc, char * argv[])
{
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbIn = 0;
    DWORD cbOut = 0;
    DWORD cbOut2 = 0;
    PBYTE pbOut = NULL;
    PBYTE pbOut2 = NULL;

    dwSts = CompressData(
        cbTestCer,
        rgbTestCer,
        &cbOut,
        NULL);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    pbOut = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbOut);

    if (NULL == pbOut)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    dwSts = CompressData(
        cbTestCer,
        rgbTestCer,
        &cbOut,
        pbOut);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    printf("Compression ratio = %f\n", 
        (float) cbTestCer / (float) cbOut);

    dwSts = UncompressData(
        cbOut,
        pbOut,
        &cbOut2,
        NULL);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    pbOut2 = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbOut2);

    if (NULL == pbOut2)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    dwSts = UncompressData(
        cbOut,
        pbOut,
        &cbOut2,
        pbOut2);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    if (cbOut2 != cbTestCer)
    {
        printf("ERROR: data lengths don't match\n");
        dwSts = ERROR_INTERNAL_ERROR;
        goto Ret;
    }

    if (0 != memcmp(pbOut2, rgbTestCer, cbOut2))
    {
        printf("ERROR: data doesn't match\n");
        dwSts = ERROR_INTERNAL_ERROR;
        goto Ret;
    }

Ret:
    
    if (ERROR_SUCCESS != dwSts)
        printf(" failed, 0x%x\n", dwSts);
    else
        printf("Success.\n");

    if (pbOut)
        HeapFree(GetProcessHeap(), 0, pbOut);
    if (pbOut2)
        HeapFree(GetProcessHeap(), 0, pbOut2);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\test\perso\perso.c ===
#include <windows.h>
#include <wincrypt.h>
#include <winscard.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "basecsp.h"
#include <des.h>
#include <tripldes.h>
#include <modes.h>
#include "wpscproxy.h"
#include "physfile.h"
#include "carddbg.h"

#define wszCARDMOD_VERSION_ERROR \
L"The version of the smart card module installed on the system is incorrect for use with this program."

//
// Debug Logging
//
// This uses the debug routines from dsysdbg.h
// Debug output will only be available in chk
// bits.
//
DEFINE_DEBUG2(Cardmod)

#define LOG_BEGIN_FUNCTION(x)                                           \
    { DebugLog((DEB_TRACE_FUNC, "%s: Entering\n", #x)); }
    
#define LOG_END_FUNCTION(x, y)                                          \
    { DebugLog((DEB_TRACE_FUNC, "%s: Leaving, status: 0x%x\n", #x, y)); }
    
#define LOG_CHECK_ALLOC(x)                                              \
    { if (NULL == x) {                                                  \
        dwError = ERROR_NOT_ENOUGH_MEMORY;                              \
        DebugLog((DEB_TRACE_MEM, "%s: Allocation failed\n", #x));       \
        goto Ret;                                                       \
    } }
    
#define LOG_CHECK_SCW_CALL(x)                                           \
    { if (ERROR_SUCCESS != (dwError = I_CardMapErrorCode(x))) {         \
        DebugLog((DEB_TRACE_FUNC, "%s: failed, status: 0x%x\n",         \
            #x, dwError));                                              \
        goto Ret;                                                       \
    } }

#define TEST_CASE(X) { if (ERROR_SUCCESS != (dwSts = X)) { printf("%s", #X); goto Ret; } }

DEBUG_KEY  MyDebugKeys[] = 
{   
    {DEB_ERROR,                 "Error"},
    {DEB_WARN,                  "Warning"},
    {DEB_TRACE,                 "Trace"},
    {DEB_TRACE_FUNC,            "TraceFuncs"},
    {DEB_TRACE_MEM,             "TraceMem"},
    {DEB_TRACE_TRANSMIT,        "TraceTransmit"},
    {DEB_TRACE_PROXY,           "TraceProxy"},
    {0, NULL}
};

#if DBG
#include <stdio.h>
#define CROW 16
void I_DebugPrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;
    CHAR rgsz[1024];
    ULONG cbOffset = 0;
    BOOL fTruncated = FALSE;

    if (NULL == pb || 0 == cbSize)
        return;

    memset(rgsz, 0, sizeof(rgsz));

    DebugLog((
        DEB_TRACE_TRANSMIT, 
        "%S, %d bytes ::\n", 
        pwszHdr, 
        cbSize));

    // Don't overflow the debug library output buffer.
    if (cbSize > 50)
    {
        cbSize = 50;
        fTruncated = TRUE;
    }

    while (cbSize > 0)
    {
        // Start every row with extra space
        strcat(rgsz, "   ");
        cbOffset = strlen(rgsz);

        cb = min(CROW, cbSize);
        cbSize -= cb;

        for (i = 0; i < cb; i++)
        {
            sprintf(
                rgsz + cbOffset,
                " %02x",
                pb[i]);
            cbOffset += 3;
        } 
        for (i = cb; i < CROW; i++)
        {
            strcat(rgsz, "   "); 
        }

        strcat(rgsz, "    '");
        cbOffset = strlen(rgsz);

        for (i = 0; i < cb; i++)
        {
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                sprintf(
                    rgsz + cbOffset,
                    "%c",
                    pb[i]);
            else
                sprintf(
                    rgsz + cbOffset,
                    ".",
                    pb[i]);

            cbOffset++;
        }

        strcat(rgsz, "\n");
        pb += cb;
    }

    if (fTruncated)
        DebugLog((
            DEB_TRACE_TRANSMIT, 
            "(truncated)\n%s",
            rgsz));
    else
        DebugLog((
            DEB_TRACE_TRANSMIT, 
            "\n%s",
            rgsz));
}
#endif

#ifndef cbCHALLENGE_RESPONSE_DATA
#define cbCHALLENGE_RESPONSE_DATA       8
#endif

//
// Defines for Admin challenge-response key
//
BYTE rgbAdminKey [] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//
// Default User Pin
//
CHAR szUserPin [] = "0000";

//
// Function: CspAllocH
//
LPVOID WINAPI CspAllocH(
    IN SIZE_T cBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cBytes);
}

//
// Function: CspFreeH
//
void WINAPI CspFreeH(
    IN LPVOID pMem)
{
    HeapFree(GetProcessHeap(), 0, pMem);
}

// 
// Function: CspReAllocH
//
LPVOID WINAPI CspReAllocH(
    IN LPVOID pMem, 
    IN SIZE_T cBytes)
{
    return HeapReAlloc(
        GetProcessHeap(), HEAP_ZERO_MEMORY, pMem, cBytes);
}

DWORD WINAPI CspCacheAddFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       pbData,
    IN      DWORD       cbData)
{
    return ERROR_SUCCESS;
}

DWORD WINAPI CspCacheLookupFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags,
    IN      PBYTE       *ppbData,
    IN      PDWORD      pcbData)
{
    return ERROR_NOT_FOUND;
}

DWORD WINAPI CspCacheDeleteFile(
    IN      PVOID       pvCacheContext,
    IN      LPWSTR      wszTag,
    IN      DWORD       dwFlags)
{
    return ERROR_SUCCESS;
}

// 
// Gets the challenge bytes for an admin challenge-response 
// authentication.
//
DWORD GetAdminAuthResponse(
    IN PCARD_DATA pCardData,
    IN OUT PBYTE pbResponse,
    IN DWORD cbResponse)
{
    DES3TABLE des3Table;
    PBYTE pbChallenge = NULL;
    DWORD cbChallenge = 0;
    DWORD dwSts = ERROR_SUCCESS;

    memset(&des3Table, 0, sizeof(des3Table));

    if (cbCHALLENGE_RESPONSE_DATA != cbResponse)
    {
        dwSts = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // Get the challenge
    TEST_CASE(pCardData->pfnCardGetChallenge(
        pCardData,
        &pbChallenge,
        &cbChallenge));

    // Build a des key using the admin auth key
    tripledes3key(&des3Table, rgbAdminKey);

    // Encrypt the challenge to compute the response
    tripledes(pbResponse, pbChallenge, (PVOID) &des3Table, ENCRYPT);

Ret:
    
    if (pbChallenge)
        pCardData->pfnCspFree(pbChallenge);

    return dwSts;
}

//
// Authenticates the user principal on the target card.
//
DWORD AuthenticateCardUser(
    IN PCARD_DATA pCardData)
{
    return pCardData->pfnCardSubmitPin(
        pCardData,
        wszCARD_USER_USER,
        szUserPin,
        strlen(szUserPin),
        NULL);
}

//
// Authenticates the admin principal on the target card.
//
DWORD AuthenticateCardAdmin(
    IN PCARD_DATA pCardData)
{
    DWORD dwSts = ERROR_SUCCESS;
    BYTE rgbResponse [cbCHALLENGE_RESPONSE_DATA];

    // Get a challenge-response
    dwSts = GetAdminAuthResponse(
        pCardData,
        rgbResponse,
        sizeof(rgbResponse));

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    TEST_CASE(pCardData->pfnCardAuthenticateChallenge(
        pCardData,
        rgbResponse,
        sizeof(rgbResponse),
        NULL));

Ret:

    return dwSts;
}

//
// Create and initialize the Card Cache File
//
DWORD InitializeCardCacheFile(
    IN PCARD_DATA pCardData)
{
    DWORD dwSts = ERROR_SUCCESS;
    BYTE rgbContents [sizeof(CARD_CACHE_FILE_FORMAT)];

    printf("Installing the Card Cache File ...\n");

    memset(rgbContents, 0, sizeof(rgbContents));

    TEST_CASE(AuthenticateCardUser(pCardData));

    TEST_CASE(pCardData->pfnCardCreateFile(
        pCardData,
        wszCACHE_FILE_FULL_PATH,
        EveryoneReadUserWriteAc));

    TEST_CASE(pCardData->pfnCardWriteFile(
        pCardData,
        wszCACHE_FILE_FULL_PATH,
        0,
        rgbContents,
        sizeof(rgbContents)));

Ret:

    return dwSts;
}

//
// Create and initialize the Personal Data File
//
DWORD InitializePersonalDataFile(
    IN PCARD_DATA pCardData)
{
    DWORD dwSts = ERROR_SUCCESS;

    printf("Installing the Card Personal Data File ...\n");

    TEST_CASE(AuthenticateCardUser(pCardData));

    TEST_CASE(pCardData->pfnCardCreateFile(
        pCardData,
        wszPERSONAL_DATA_FILE_FULL_PATH,
        EveryoneReadUserWriteAc));

Ret:

    return dwSts;
}

//
// Create and initialize the Card Identifier File
//
DWORD InitializeCardIDFile(
    IN PCARD_DATA pCardData)
{
    DWORD dwSts = ERROR_SUCCESS;
    BYTE rgbContents [16];
    HCRYPTPROV hProv = 0;

    printf("Installing the Card Identifier File ...\n");

    if (! CryptAcquireContext(
        &hProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    if (! CryptGenRandom(
        hProv, sizeof(rgbContents), rgbContents))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    TEST_CASE(AuthenticateCardAdmin(pCardData));

    TEST_CASE(pCardData->pfnCardCreateFile(
        pCardData,
        wszCARD_IDENTIFIER_FILE_FULL_PATH,
        EveryoneReadAdminWriteAc));

    TEST_CASE(pCardData->pfnCardWriteFile(
        pCardData,
        wszCARD_IDENTIFIER_FILE_FULL_PATH,
        0,
        rgbContents,
        sizeof(rgbContents)));

Ret:

    if (hProv)
        CryptReleaseContext(hProv, 0);

    return dwSts;
}

//
// Create and initialize the CSP directory and Container Map File
//
DWORD InitializeCardCSPApplication(
    IN PCARD_DATA pCardData)
{
    DWORD dwSts = ERROR_SUCCESS;
    BYTE rgbContents [16];
    SCODE scode = SCW_S_OK;
    WCHAR wszDirectory [MAX_PATH];

    printf("Installing the CSP Application ...\n");

    memset(wszDirectory, 0, sizeof(wszDirectory));

    memcpy(
        wszDirectory, 
        szPHYSICAL_CSP_DIR, 
        cbPHYSICAL_CSP_DIR);

    TEST_CASE(AuthenticateCardUser(pCardData));

    // Create the CSP application directory
    scode = hScwCreateDirectory(
        *((SCARDHANDLE *) pCardData->pvVendorSpecific),
        wszDirectory,
        wszUserWritePhysicalAcl);

    if (SCW_E_ALREADYEXISTS == scode)
        printf("CSP Application directory already exists.\n");
    else if (SCW_S_OK != scode)
    {
        dwSts = (DWORD) scode;
        goto Ret;
    }

    TEST_CASE(pCardData->pfnCardCreateFile(
        pCardData,
        wszCONTAINER_MAP_FILE_FULL_PATH,
        EveryoneReadUserWriteAc));

    TEST_CASE(pCardData->pfnCardWriteFile(
        pCardData,
        wszCARD_IDENTIFIER_FILE_FULL_PATH,
        0,
        rgbContents,
        sizeof(rgbContents)));

Ret:

    return dwSts;
}

//
// Find any card present in an attached reader using "minimal" scarddlg UI
//
DWORD GetCardHandleViaUI(
    IN  SCARDCONTEXT hSCardContext,
    OUT SCARDHANDLE *phSCardHandle,
    IN  DWORD cchMatchedCard,
    OUT LPWSTR wszMatchedCard,
    IN  DWORD cchMatchedReader,
    OUT LPWSTR wszMatchedReader)
{
    OPENCARDNAME_EXW ocnx;
    DWORD dwSts = ERROR_SUCCESS;

    memset(&ocnx, 0, sizeof(ocnx));
 
    ocnx.dwStructSize = sizeof(ocnx);
    ocnx.hSCardContext = hSCardContext;
    ocnx.lpstrCard = wszMatchedCard;
    ocnx.nMaxCard = cchMatchedCard;
    ocnx.lpstrRdr = wszMatchedReader;
    ocnx.nMaxRdr = cchMatchedReader;
    ocnx.dwShareMode = SCARD_SHARE_SHARED;
    ocnx.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
    ocnx.dwFlags = SC_DLG_MINIMAL_UI;

    TEST_CASE(SCardUIDlgSelectCardW(&ocnx));

    *phSCardHandle = ocnx.hCardHandle;

Ret:

    return dwSts;
}

int _cdecl main(int argc, char * argv[])
{
    PCARD_DATA pCardData = NULL;
    DWORD dwSts = ERROR_SUCCESS;
    PFN_CARD_ACQUIRE_CONTEXT pfnCardAcquireContext = NULL;
    SCARDCONTEXT hSCardContext = 0;
    SCARDHANDLE hSCardHandle = 0;
    LPWSTR mszReaders = NULL;
    DWORD cchReaders = SCARD_AUTOALLOCATE; 
    LPWSTR mszCards = NULL;
    DWORD cchCards = SCARD_AUTOALLOCATE;
    DWORD dwActiveProtocol = 0;
    DWORD dwState = 0;
    BYTE rgbAtr [32];
    DWORD cbAtr = sizeof(rgbAtr);
    LPWSTR pszProvider = NULL;
    DWORD cchProvider = SCARD_AUTOALLOCATE;
    HMODULE hMod = INVALID_HANDLE_VALUE;
    WCHAR wszMatchedCard [MAX_PATH];
    WCHAR wszMatchedReader [MAX_PATH];
    BOOL fTransaction = FALSE;

    memset(rgbAtr, 0, sizeof(rgbAtr));

    // 
    // Initialization
    //

    TEST_CASE(SCardEstablishContext(
        SCARD_SCOPE_USER, NULL, NULL, &hSCardContext));
    
    dwSts = GetCardHandleViaUI(
        hSCardContext,
        &hSCardHandle,
        MAX_PATH,
        wszMatchedCard,
        MAX_PATH,
        wszMatchedReader);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    mszReaders = NULL;
    cchReaders = SCARD_AUTOALLOCATE;

    TEST_CASE(SCardStatusW(
        hSCardHandle,
        (LPWSTR) (&mszReaders),
        &cchReaders,
        &dwState,
        &dwActiveProtocol,
        rgbAtr,
        &cbAtr));

    TEST_CASE(SCardListCardsW(
        hSCardContext,
        rgbAtr,
        NULL,
        0,
        (LPWSTR) (&mszCards),
        &cchCards));

    TEST_CASE(SCardGetCardTypeProviderNameW(
        hSCardContext,
        mszCards,
        SCARD_PROVIDER_CARD_MODULE,
        (LPWSTR) (&pszProvider),
        &cchProvider));

    hMod = LoadLibraryW(pszProvider);

    if (INVALID_HANDLE_VALUE == hMod)
    {
        wprintf(L"LoadLibrary %s", pszProvider);
        dwSts = GetLastError();
        goto Ret;
    }

    pfnCardAcquireContext = 
        (PFN_CARD_ACQUIRE_CONTEXT) GetProcAddress(
        hMod,
        "CardAcquireContext");

    if (NULL == pfnCardAcquireContext)
    {
        printf("GetProcAddress");
        dwSts = GetLastError();
        goto Ret;
    }

    pCardData = (PCARD_DATA) CspAllocH(sizeof(CARD_DATA));

    if (NULL == pCardData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    pCardData->pbAtr = rgbAtr;
    pCardData->cbAtr = cbAtr;
    pCardData->pwszCardName = mszCards;
    pCardData->dwVersion = CARD_DATA_CURRENT_VERSION;
    pCardData->pfnCspAlloc = CspAllocH;
    pCardData->pfnCspReAlloc = CspReAllocH;
    pCardData->pfnCspFree = CspFreeH;
    pCardData->pfnCspCacheAddFile = CspCacheAddFile;
    pCardData->pfnCspCacheDeleteFile = CspCacheDeleteFile;
    pCardData->pfnCspCacheLookupFile = CspCacheLookupFile;
    pCardData->hScard = hSCardHandle;
    hSCardHandle = 0;

    // First, connect to the card
    dwSts = pfnCardAcquireContext(pCardData, 0);

    switch (dwSts)
    {
    case ERROR_SUCCESS:
        // Keep going
        break;

    case ERROR_REVISION_MISMATCH:
        MessageBoxEx(
            GetDesktopWindow(),
            wszCARDMOD_VERSION_ERROR,
            NULL,
            MB_ICONWARNING | MB_OK | MB_TASKMODAL,
            0);

        // fall through

    default:

        goto Ret;
    }

    TEST_CASE(SCardBeginTransaction(pCardData->hScard));

    fTransaction = TRUE;

    TEST_CASE(InitializeCardCacheFile(pCardData));

    TEST_CASE(InitializeCardIDFile(pCardData));

    TEST_CASE(InitializePersonalDataFile(pCardData));

    TEST_CASE(InitializeCardCSPApplication(pCardData));

    // Deauthenticate 
    pCardData->pfnCardDeauthenticate(
        pCardData,
        wszCARD_USER_ADMIN,
        0);

    pCardData->pfnCardDeauthenticate(
        pCardData,
        wszCARD_USER_USER,
        0);

    // Cleanup the card context
    TEST_CASE(pCardData->pfnCardDeleteContext(pCardData));    
    
Ret:
    
    if (fTransaction)
        SCardEndTransaction(pCardData->hScard, SCARD_RESET_CARD);
    if (mszCards)
        SCardFreeMemory(hSCardContext, mszCards);
    if (mszReaders)
        SCardFreeMemory(hSCardContext, mszReaders);
    if (pszProvider)
        SCardFreeMemory(hSCardContext, pszProvider);
    if (hSCardHandle)
        SCardDisconnect(hSCardHandle, SCARD_RESET_CARD);
    
    if (pCardData)
    {
        if (pCardData->hScard)
            SCardDisconnect(pCardData->hScard, SCARD_RESET_CARD);

        CspFreeH(pCardData);
        pCardData = NULL;
    }

    if (hSCardContext)
        SCardReleaseContext(hSCardContext);
    
    if (ERROR_SUCCESS != dwSts)
    {
        printf(" failed, 0x%x\n", dwSts);
        exit(1);
    }
    else 
    {
        printf("Success.\n");
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\test\pindlg\pindlg.c ===
#include <windows.h>
#include <wincrypt.h>
#include <winscard.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "pinlib.h"

#define TEST_CASE(X) { if (ERROR_SUCCESS != (dwSts = X)) { printf("%s", #X); goto Ret; } }

#define CAPI_TEST_CASE(X) { if (! X) { dwSts = GetLastError(); printf("%s", #X); goto Ret; } }

//
// Function: CspAllocH
//
LPVOID WINAPI CspAllocH(
    IN SIZE_T cBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cBytes);
}

//
// Function: CspFreeH
//
void WINAPI CspFreeH(
    IN LPVOID pMem)
{
    HeapFree(GetProcessHeap(), 0, pMem);
}

//
// Function: PrintBytes
//
#define CROW 8
void PrintBytes(LPSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;
    CHAR rgsz[1024];

    printf("\n  %s, %d bytes ::\n", pszHdr, cbSize);

    while (cbSize > 0)
    {
        // Start every row with an extra space
        printf(" ");

        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i < cb; i++)
            printf(" %02x", pb[i]);
        for (i = cb; i < CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i < cb; i++)
        {
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        }
        printf("\n");
        pb += cb;
    }
}

DWORD WINAPI MyVerifyPin(
    IN PPINCACHE_PINS pPins, 
    IN PVOID pvCallbackCtx)
{
    return ERROR_SUCCESS;
}

int _cdecl main(int argc, char * argv[])
{
    DWORD dwSts = ERROR_SUCCESS;
    PIN_SHOW_GET_PIN_UI_INFO PinUIInfo;
    HMODULE hCspMod = 0;
    
    hCspMod = LoadLibrary(L"basecsp.dll");

    if (0 == hCspMod || INVALID_HANDLE_VALUE == hCspMod)
    {
        dwSts = GetLastError();
        goto Ret;
    }

    memset(&PinUIInfo, 0, sizeof(PinUIInfo));

    PinUIInfo.wszCardName = L"My Card";
    PinUIInfo.wszPrincipal = L"User";
    PinUIInfo.pfnVerify = MyVerifyPin;
    PinUIInfo.pvCallbackContext = (PVOID) 0xdaad;
    PinUIInfo.hDlgResourceModule = hCspMod;

    dwSts = PinShowGetPinUI(
        &PinUIInfo);

Ret:

    if (ERROR_SUCCESS != dwSts)
        printf(" failed, 0x%x\n", dwSts);
    else 
        printf("Success.\n");

    if (hCspMod)
        FreeLibrary(hCspMod);
    if (PinUIInfo.pbPin)
        CspFreeH(PinUIInfo.pbPin);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\test\profile\profile.c ===
#include <windows.h>
#include <wincrypt.h>
#include <winscard.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#define CAPI_TEST_CASE(X) { if (! X) { dwSts = GetLastError(); printf("%s", #X); goto Ret; } }

#define TEST_ITERATIONS     1000

/*
void DisplayHelp(void)
{
    printf("Usage: scnarios [option]\n");
    printf(" -1 : Test simulated enrollment\n");
    printf(" -2 : Test simulated certificate propagation\n");
    printf(" -3 : Test simulated logon\n");
    printf(" -c : Cleanup (delete default container)\n");
}
*/

DWORD DoCryptAcquireContext(void)
{
    HCRYPTPROV hProv = 0;
    DWORD dwSts = ERROR_SUCCESS;
 
    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv,
        NULL,
        MS_SCARD_PROV_W,
        PROV_RSA_FULL,
        0));

    CAPI_TEST_CASE(CryptReleaseContext(hProv, 0));

Ret:

    return dwSts;
}

int _cdecl main(int argc, char * argv[])
{
    DWORD dwSts = ERROR_SUCCESS;
    DWORD iteration = 0;

    dwSts = DoCryptAcquireContext();

    if (ERROR_SUCCESS != dwSts)
        goto Ret;
    
    for (iteration = 0; iteration < TEST_ITERATIONS; iteration++)
    {
        dwSts = DoCryptAcquireContext();

        if (ERROR_SUCCESS != dwSts)
            goto Ret;
    }
    
Ret:
    
    if (ERROR_SUCCESS != dwSts)
        printf(" failed, 0x%x\n", dwSts);
    else 
        printf("Success.\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\test\wfscproto\wfscproto.c ===
// wfscproto - Prototyping code for the Windows for Smart Card Card Module
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <crypt.h>

#include <windows.h>
#include "cardmod.h"
#include "wpscproxy.h"
#include <malloc.h>
#include <stdio.h>
#include <rsa.h>
#include <stdlib.h>
#include "carddbg.h"

//
// Need to define the dsys debug symbols since we're linking directly to the
// proxy lib which requires them.
//
DEFINE_DEBUG2(Cardmod)

#define SC_FAILED(X)                    (0 != (X))

#define SCW_CALL(X) {                       \
    if ((status = X) != SCW_S_OK) {         \
        dwError = (DWORD) status;           \
        goto Ret;                           \
    }}

//
// Using Crypto API, the RSA public exponent is always 0x10001, which can
// be represented in three bytes.
//
#define cbCAPI_PUBLIC_EXPONENT          3

#define wszTEST_CARD_NAME               L"SCWUnnamed"
#define wszDEFAULT_ACL_FILE             L"/s/a/uw"
#define wszKEY_ACL_FILE                 L"/s/a/ux"
#define wszNEW_FILE                     L"/dan"
#define wszRSA_KEY_FILE                 L"/CK0"

//
// Card module applet instruction codes
//
#define PIN_CHANGE_CLA                  0x00
#define PIN_CHANGE_INS                  0x52
#define PIN_CHANGE_P1                   0x00
#define PIN_CHANGE_P2                   0x00

#define PIN_UNBLOCK_CLA                 0x00
#define PIN_UNBLOCK_INS                 0x52
#define PIN_UNBLOCK_P1                  0x01
#define PIN_UNBLOCK_P2                  0x00

#define PIN_RETRY_COUNTER_CLA           0x00
#define PIN_RETRY_COUNTER_INS           0x50
#define PIN_RETRY_COUNTER_P1            0x00
#define PIN_RETRY_COUNTER_P2            0x00

SCARDHANDLE g_hWfscHandle = 0;

#define ScwAuthenticateName(X, Y, Z)        (hScwAuthenticateName(g_hWfscHandle, X, Y, Z))
#define ScwDeauthenticateName(X)            (hScwDeauthenticateName(g_hWfscHandle, X))
#define ScwCreateFile(X, Y, Z)              (hScwCreateFile(g_hWfscHandle, X, Y, Z))
#define ScwCloseFile(X)                     (hScwCloseFile(g_hWfscHandle, X))
#define ScwWriteFile(X, Y, Z, A)            (hScwWriteFile(g_hWfscHandle, X, Y, Z, A))
#define ScwWriteFile32(X, Y, Z, A)          (hScwWriteFile32(g_hWfscHandle, X, Y, Z, A))
#define ScwEnumFile(X, Y, Z, A)             (hScwEnumFile(g_hWfscHandle, X, Y, Z, A))
#define ScwGetFileLength(X, Y)              (hScwGetFileLength(g_hWfscHandle, X, Y))
#define ScwReadFile32(X, Y, Z, A)           (hScwReadFile32(g_hWfscHandle, X, Y, Z, A))
#define ScwAttachToCard(X, Y)               (hScwAttachToCard(X, Y, &g_hWfscHandle))
#define ScwCryptoInitialize(X, Y)           (hScwCryptoInitialize(g_hWfscHandle, X, Y))
#define ScwCryptoAction(X, Y, Z, A)         (hScwCryptoAction(g_hWfscHandle, X, Y, Z, A))
#define ScwDetachFromCard()                 (hScwDetachFromCard(g_hWfscHandle))
#define ScwDeleteFile(X)                    (hScwDeleteFile(g_hWfscHandle, X))
#define ScwExecute(A, B, C, D, E, F)        (hScwExecute(g_hWfscHandle, A, B, C, D, E, F))
#define ScwSetFilePointer(A, B, C)          (hScwSetFilePointer(g_hWfscHandle, A, B, C))
//
// Required for linking to rsa32 
//
unsigned int
RSA32API
NewGenRandom(
    IN  OUT unsigned char **ppbRandSeed /*unused*/,
    IN      unsigned long *pcbRandSeed /*unused*/,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength
    )
{
    return (unsigned int)RtlGenRandom( pbBuffer, dwLength );
}

void MyRngFunc(
    IN      PVOID pvInfo,
    IN  OUT unsigned char **ppbRandSeed /*unused*/,
    IN      unsigned long *pcbRandSeed /*unused*/,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength)
{
    NewGenRandom(ppbRandSeed, pcbRandSeed, pbBuffer, dwLength);
}

typedef struct _Principal
{
    BYTE rgbPin[4];
    LPWSTR pwszUser;
} Principal;

Principal Principals [] = {
    { { 0x00, 0x00, 0x00, 0x00 }, L"Everyone"   },
    { { 0x00, 0x00, 0x00, 0x00 }, L"user"       },
    { { 0x01, 0x02, 0x03, 0x04 }, L"admin"      }
};

#define PRINCIPAL_USER                  1
#define PRINCIPAL_ADMIN                 2

BYTE rgbUserNewPin [] = {
    0x01, 0x01, 0x01, 0x01
};

DWORD Authenticate(
    DWORD dwId)
{
    return (DWORD) ScwAuthenticateName(
        Principals[dwId].pwszUser,
        Principals[dwId].rgbPin,
        sizeof(Principals[dwId].rgbPin));
}

DWORD Deauthenticate(
    DWORD dwId)
{
    return (DWORD) ScwDeauthenticateName(Principals[dwId].pwszUser);
}

#define CROW 16
void PrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    if (cbSize == 0) {
        wprintf(L"%s NO Value Bytes\n", pwszHdr);
        return;
    }

    if (NULL != pwszHdr)
        wprintf(L"%s\n", pwszHdr);

    while (cbSize > 0)
    {
        wprintf(L"     ");
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            wprintf(L" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            wprintf(L"   ");
        wprintf(L"    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                wprintf(L"%c", pb[i]);
            else
                wprintf(L".");
        pb += cb;
        wprintf(L"'\n");
    }
}

void I_DebugPrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize)
{
    PrintBytes(pwszHdr, pb, cbSize);
}

DWORD WriteKeyToCard(
    IN LPWSTR pwszKeyFile,
    IN LPWSTR pwszAclFile,
    IN PBYTE pbKey,
    IN DWORD cbKey)
{
    HFILE hFile = 0;
    DWORD cbCheck = 0;
    SCODE status = 0;
    DWORD dwError = 0;
 
    PrintBytes(L"Key file to write to card", pbKey, cbKey);

    //
    // Write the private key to the card
    //

    status = Authenticate(PRINCIPAL_USER);

    if (SCW_S_OK != status)
    {
        dwError = (DWORD) status;
        goto Ret;
    }

    // Delete the key if it already exists
    status = ScwCreateFile(pwszKeyFile, NULL, &hFile);

    if (SCW_S_OK == status)
    {
        SCW_CALL(ScwCloseFile(hFile));
        hFile = 0;

        SCW_CALL(ScwDeleteFile(pwszKeyFile));
    }

    SCW_CALL(ScwCreateFile(pwszKeyFile, pwszAclFile, &hFile));
   
    SCW_CALL(ScwWriteFile32(hFile, pbKey, cbKey, &cbCheck));

    if (cbKey != cbCheck)
    {
        printf(
            "ERROR - expected to write %d key bytes, but only wrote %d\n",
            cbKey,
            cbCheck);
        dwError = -1;
        goto Ret;
    }

Ret:
    if (hFile)
        ScwCloseFile(hFile);

    return dwError;
}

//
// Generates a new RSA key using rsa32 (BSafe) primitives, then writes
// the key to the card in the card's key format.
//
DWORD GenKeyOnCardWithRsa32(
    IN LPWSTR pwszKeyFile,
    IN LPWSTR pwszAclFile,
    IN DWORD cKeySizeBits)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbPublic = 0;
    DWORD cbPrivate = 0;
    DWORD cLocalBits = cKeySizeBits;
    BSAFE_PUB_KEY *pPub = NULL;
    BSAFE_PRV_KEY *pPrv = NULL;
    BSAFE_OTHER_INFO    OtherInfo;
    DWORD cbTmpLen = 0;
    DWORD cbHalfTmpLen = 0;
    DWORD cbHalfModLen = 0;
    BYTE rgbCardKey [1000];
    DWORD cbKey = 0;
    PBYTE pbKey = NULL;
    DWORD cBitlenBytes = cKeySizeBits / 8;
    PBYTE pbIn = NULL;

    memset(&OtherInfo, 0, sizeof(OtherInfo));

    OtherInfo.pFuncRNG = MyRngFunc;

    //
    // Figure out how big the key buffers need to be
    //

    if (! BSafeComputeKeySizes(&cbPublic, &cbPrivate, &cLocalBits))
    {
        dwError = ERROR_INTERNAL_ERROR;
        goto Ret;
    }

    // 
    // Alloc the key buffers
    //

    pPub = (BSAFE_PUB_KEY *) malloc(cbPublic);

    if (NULL == pPub)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    pPrv = (BSAFE_PRV_KEY *) malloc(cbPrivate);

    if (NULL == pPrv)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    //
    // Generate the key pair
    //

    if (!BSafeMakeKeyPairEx2(
        &OtherInfo, pPub, pPrv, cKeySizeBits, 0x3))
    {
        dwError = ERROR_INTERNAL_ERROR;
        goto Ret;
    }

    //
    // Copy the private key out of the BSafe format into the card format
    //
    // This code is copied from rsaenh.dll sources
    //

    cbHalfModLen = (pPrv->bitlen + 15) / 16;

    // figure out the number of overflow bytes which are in the private
    // key structure
    cbTmpLen = (sizeof(DWORD) * 2)
               - (((pPrv->bitlen + 7) / 8) % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) != cbTmpLen)
        cbTmpLen += sizeof(DWORD) * 2;
    cbHalfTmpLen = cbTmpLen / 2;

    pbKey = rgbCardKey;

    // Key mode
    pbKey[cbKey] = MODE_RSA_SIGN;
    cbKey++;

    // size of public exponent
    pbKey[cbKey] = 1;
    cbKey++;

    // public exponent
    pbKey[cbKey] = 0x3;
    cbKey++;

    // RSA key length
    pbKey[cbKey] = (BYTE) cBitlenBytes; 
    cbKey++;

    pbIn = (PBYTE) pPrv + sizeof(BSAFE_PRV_KEY);

    // Public modulus
    memcpy(pbKey + cbKey, pbIn, cBitlenBytes);
    pbIn += cBitlenBytes + cbTmpLen;
    cbKey += cBitlenBytes;

    // Fast-forward to the end of the private key structure to grab the 
    // private exponent.
    pbIn += 5 * (cbHalfModLen + cbHalfTmpLen);

    memcpy(pbKey + cbKey, pbIn, cBitlenBytes);
    cbKey += cBitlenBytes;

    dwError = WriteKeyToCard(
        pwszKeyFile, pwszAclFile, rgbCardKey, cbKey);

Ret:

    if (pPub)
        free(pPub);
    if (pPrv)
        free(pPrv);

    return dwError;
}

//
// Generates a new RSA key using Crypto API, then exports the key and
// writes it to the card.  The key is stored in a format that allows
// the use of Chinese Remainder Theorem parameters for faster RSA perf.
//
DWORD GenKeyOnCardCRT(
    IN LPWSTR pwszKeyFile,
    IN LPWSTR pwszAclFile,
    IN DWORD cKeySizeBits)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    BYTE rgbCapiKey [1000];
    BYTE rgbCardKey [1000];
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbCapiKey = 0;
    BLOBHEADER *pBlobHeader = NULL;
    RSAPUBKEY *pPubKey = NULL;
    BYTE *pbKey = NULL;
    DWORD cbKey = 0;
    DWORD cBitlenBytes = 0;

    if (! CryptAcquireContext(
        &hProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        dwError = GetLastError();
        goto Ret;
    }

    if (! CryptGenKey(
        hProv, AT_KEYEXCHANGE, (cKeySizeBits << 16) | CRYPT_EXPORTABLE, &hKey))
    {
        dwError = GetLastError();
        goto Ret;
    }

    cbCapiKey = sizeof(rgbCapiKey);

    if (! CryptExportKey(
        hKey, 0, PRIVATEKEYBLOB, 0, rgbCapiKey, &cbCapiKey))
    {
        dwError = GetLastError();
        goto Ret;
    }

    pBlobHeader = (BLOBHEADER *) rgbCapiKey;
    pPubKey = (RSAPUBKEY *) (rgbCapiKey + sizeof(BLOBHEADER));
    cBitlenBytes = pPubKey->bitlen / 8;
    pbKey = rgbCardKey;

    //
    // Build the private key in the card's format
    //

    // Key mode
    pbKey[cbKey] = MODE_RSA_SIGN;
    cbKey++;

    // size of public exponent
    pbKey[cbKey] = cbCAPI_PUBLIC_EXPONENT;
    cbKey++;

    // public exponent
    memcpy(
        pbKey + cbKey, 
        (PBYTE) &pPubKey->pubexp, 
        cbCAPI_PUBLIC_EXPONENT);
    cbKey += cbCAPI_PUBLIC_EXPONENT;

    // RSA key length
    pbKey[cbKey] = (BYTE) cBitlenBytes; 
    cbKey++;

    // public key
    memcpy(
        pbKey + cbKey, 
        rgbCapiKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY),
        cBitlenBytes);
    cbKey += cBitlenBytes; 

    // prime 1
    memcpy(
        pbKey + cbKey,
        rgbCapiKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            cBitlenBytes,
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // prime 2
    memcpy(
        pbKey + cbKey,
        rgbCapiKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            (3 * cBitlenBytes / 2),
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // Exp1 (D mod (P-1)) (m/2 bytes)
    memcpy(
        pbKey + cbKey,
        rgbCapiKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            2 * cBitlenBytes,
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // Exp2 (D mod (Q-1)) (m/2 bytes)
    memcpy(
        pbKey + cbKey,
        rgbCapiKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            (5 * cBitlenBytes / 2),
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // Coef ((Q^(-1)) mod p) (m/2 bytes)
    memcpy(
        pbKey + cbKey,
        rgbCapiKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +
            3 * cBitlenBytes,
        cBitlenBytes / 2);
    cbKey += cBitlenBytes / 2;

    // private exponent
    memcpy(
        pbKey + cbKey,
        rgbCapiKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) + 
            (7 * cBitlenBytes / 2),
        cBitlenBytes);        
    cbKey += cBitlenBytes;

    dwError = WriteKeyToCard(
        pwszKeyFile, pwszAclFile, rgbCardKey, cbKey);

Ret:
    if (hKey)
        CryptDestroyKey(hKey);
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return dwError;
}

//
// Generates a new RSA key in Crypto API (in software), then exports the 
// key and writes it to the card in a format usable by the card's RSA
// engine.
//
DWORD GenKeyOnCardWithCapi(
    IN LPWSTR pwszKeyFile,
    IN LPWSTR pwszAclFile,
    IN DWORD cKeySizeBits)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    BYTE rgbCapiKey [1000];
    BYTE rgbCardKey [1000];
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbCapiKey = 0;
    BLOBHEADER *pBlobHeader = NULL;
    RSAPUBKEY *pPubKey = NULL;
    BYTE *pbKey = NULL;
    DWORD cbKey = 0;
    DWORD cBitlenBytes = 0;

    if (! CryptAcquireContext(
        &hProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        dwError = GetLastError();
        goto Ret;
    }

    if (! CryptGenKey(
        hProv, AT_KEYEXCHANGE, (cKeySizeBits << 16) | CRYPT_EXPORTABLE, &hKey))
    {
        dwError = GetLastError();
        goto Ret;
    }

    cbCapiKey = sizeof(rgbCapiKey);

    if (! CryptExportKey(
        hKey, 0, PRIVATEKEYBLOB, 0, rgbCapiKey, &cbCapiKey))
    {
        dwError = GetLastError();
        goto Ret;
    }

    pBlobHeader = (BLOBHEADER *) rgbCapiKey;
    pPubKey = (RSAPUBKEY *) (rgbCapiKey + sizeof(BLOBHEADER));
    cBitlenBytes = pPubKey->bitlen / 8;
    pbKey = rgbCardKey;

    //
    // Build the private key in the card's format
    //

    // Key mode
    pbKey[cbKey] = MODE_RSA_SIGN;
    cbKey++;

    // size of public exponent
    pbKey[cbKey] = cbCAPI_PUBLIC_EXPONENT;
    cbKey++;

    // public exponent
    memcpy(
        pbKey + cbKey, 
        (PBYTE) &pPubKey->pubexp, 
        cbCAPI_PUBLIC_EXPONENT);
    cbKey += cbCAPI_PUBLIC_EXPONENT;

    // RSA key length
    pbKey[cbKey] = (BYTE) cBitlenBytes; 
    cbKey++;

    // public key
    memcpy(
        pbKey + cbKey, 
        rgbCapiKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY),
        cBitlenBytes);
    cbKey += cBitlenBytes; 

    // private exponent
    memcpy(
        pbKey + cbKey,
        rgbCapiKey + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) + 
            (7 * cBitlenBytes / 2),
        cBitlenBytes);        
    cbKey += cBitlenBytes;

    dwError = WriteKeyToCard(
        pwszKeyFile, pwszAclFile, rgbCardKey, cbKey);

Ret:
    if (hKey)
        CryptDestroyKey(hKey);
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return dwError;
}

DWORD SetupRsaKeyOnCardSimulator(
    IN LPWSTR pwszKeyFile,
    IN LPWSTR pwszAclFile,
    IN BOOL fUseSimulator)
{
    FILE *fh = NULL;
    UINT16 NLen, D1Len, DLen;
    BYTE buffer[1000];
    DWORD dwError = ERROR_SUCCESS;
    SCODE status = 0;
    HFILE hFile = 0;
    TCOUNT bytecheck = 0;
    BOOL fReAuthenticated = FALSE;
    
    status = ScwCreateFile(pwszKeyFile, NULL, &hFile);

    if (SCW_S_OK == status)
    {
        // Key file already exists, so we're done
        status = ScwCloseFile(hFile);
        return (DWORD) status;
    }

    fh=fopen("SimKeys.RSA", "rb");
        
    if (NULL == fh)
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Ret;
    }

    dwError = Authenticate(PRINCIPAL_USER);
    
    if (ERROR_SUCCESS != dwError)
        goto Ret;
    
    fReAuthenticated = TRUE;
    
    status = ScwCreateFile(pwszKeyFile, pwszAclFile, &hFile);

    if (SC_FAILED(status))
    {
        dwError = (DWORD) status;
        goto Ret;
    }

    buffer[0]=0; //mode=0
    ScwWriteFile(hFile, buffer, 1, &bytecheck);
    NLen = (UINT16) fgetc(fh);
    buffer[0]=(BYTE) NLen;
    NLen += 0x14;
    ScwWriteFile(hFile, buffer, 1, &bytecheck);
    
    DLen = (UINT16) fgetc(fh);
    buffer[0]=(BYTE) DLen;
    ScwWriteFile(hFile, buffer, 1, &bytecheck);
    D1Len = (UINT16) fgetc(fh);
    buffer[0]=(BYTE) D1Len;
    ScwWriteFile(hFile, buffer, 1, &bytecheck);
    DLen=DLen*256+D1Len+0x14;
    
    //write the keys to file
    while(NLen>0) {
        buffer[0] = (BYTE) fgetc(fh);
        buffer[1] = (BYTE) fgetc(fh);
        ScwWriteFile(hFile, buffer, 2, &bytecheck);
        NLen-=2;
    }
    
    while(DLen>0) {
        buffer[0] = (BYTE) fgetc(fh);
        buffer[1] = (BYTE) fgetc(fh);
        ScwWriteFile(hFile, buffer, 2, &bytecheck);
        DLen-=2;
    }
    
Ret:
    if (fh)
        fclose(fh);
    if (hFile)
        ScwCloseFile(hFile);
    if (fReAuthenticated)
        Deauthenticate(PRINCIPAL_USER);

    return dwError;
}

DWORD DisplayFileContents(
    IN LPWSTR pwszFileName)
{
    HFILE hFile = 0;
    SCODE status = 0;
    DWORD dwError = 0;
    PBYTE pbContents = NULL;
    DWORD cbContents = 0;
    DWORD cbActual = 0;

    status = ScwCreateFile(
        pwszFileName, NULL, &hFile);

    if (SC_FAILED(status))
        goto Ret;

    status = ScwGetFileLength(
        hFile, (TOFFSET *) &cbContents);

    if (SC_FAILED(status))
        goto Ret;

    pbContents = (PBYTE) malloc(cbContents);

    if (NULL == pbContents)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    status = ScwReadFile32(
        hFile, pbContents, cbContents, &cbActual);

    if (SC_FAILED(status))
        goto Ret;

    PrintBytes(pwszFileName, pbContents, cbActual);

Ret:
    if (SCW_S_OK != status)
        dwError = (DWORD) status;

    if (hFile)
        ScwCloseFile(hFile);

    if (pbContents)
        free(pbContents);

    return dwError;
}

DWORD EnumFilesInDirectory(
    IN LPWSTR pwszBaseDir,
    IN LPWSTR pwszCurrent)
{
    SCODE status = 0;
    DWORD dwError = 0;
    BOOL fFirst = TRUE;
    UINT16 EnumState = 0;
    WCHAR rgwsz[64];
    WCHAR rgwszDir[64];

    if (    L'/' != pwszCurrent[0] &&
            0 != wcscmp(L"/", pwszBaseDir))
        swprintf(
            rgwszDir, L"%s/%s", pwszBaseDir, pwszCurrent);
    else
        swprintf(
            rgwszDir, L"%s%s", pwszBaseDir, pwszCurrent);

    EnumState = 0;
    status = ScwEnumFile(rgwszDir, &EnumState, rgwsz, sizeof(rgwsz) / sizeof(WCHAR));

    switch (status) 
    {
    case SCW_S_OK:
        
        // pwszDir is indeed a directory.  Keep enumerating.
        
        wprintf(L"%s - DIR\n", rgwszDir);

        do 
        {
            dwError = EnumFilesInDirectory(rgwszDir, rgwsz);
        }
        while (
            SCW_S_OK == dwError &&
            SCW_S_OK == (status = ScwEnumFile(
                rgwszDir, &EnumState, rgwsz, sizeof(rgwsz) / sizeof(WCHAR))));

        break;

    case SCW_E_NOMOREFILES:

        // Empty directory
        wprintf(L"%s - DIR\n", rgwszDir);
        status = SCW_S_OK;
        break;

    case SCW_E_BADDIR:

        // pwszDir is not a directory.  Stop.
        wprintf(L"%s - FILE\n", rgwszDir);
        DisplayFileContents(rgwszDir);
        status = SCW_S_OK;
        break;

    case SCW_E_NOTAUTHORIZED:

        // Not authenticated.  Stop with error.
        wprintf(L"%s - NOT AUTHORIZED\n", rgwszDir);
        break;

    case SCW_E_FILENOTFOUND:

        // What the hell does this mean?

        wprintf(L"%s - FILE NOT FOUND\n", rgwszDir);
        status = SCW_S_OK;
        break;

    default:
        // Other error.  We're done.
        dwError = (DWORD) status;
        break;
    }

    return dwError;
}

//
// Resets the user's pin using the VB applet on the card
//
DWORD TestPinUnblock(
    IN PBYTE pbNewPin,
    IN DWORD cbNewPin)
{
    ISO_HEADER IsoHeader;
    BYTE rgbDataIn [256];
    UINT16 wStatusWord = 0;
    TCOUNT cbDataIn = 0;
    BYTE cbUser = (BYTE) ((wcslen(L"user") + 1) * sizeof(WCHAR));
    SCODE status = 0;

    memset(&IsoHeader, 0, sizeof(IsoHeader));
    memset(rgbDataIn, 0, sizeof(rgbDataIn));

    // Setup User Name TLV
    rgbDataIn[cbDataIn] = 0;
    cbDataIn++;

    rgbDataIn[cbDataIn] = cbUser;
    cbDataIn++;

    memcpy(rgbDataIn + cbDataIn, (PBYTE) L"user", cbUser);
    cbDataIn += cbUser;

    // Setup New Pin TLV
    rgbDataIn[cbDataIn] = 2;
    cbDataIn++;

    rgbDataIn[cbDataIn] = (BYTE) cbNewPin;
    cbDataIn++;

    memcpy(rgbDataIn + cbDataIn, pbNewPin, cbNewPin);
    cbDataIn += (TCOUNT) cbNewPin;

    // Build the command
    IsoHeader.INS = PIN_UNBLOCK_INS;
    IsoHeader.CLA = PIN_UNBLOCK_CLA;
    IsoHeader.P1 = PIN_UNBLOCK_P1;
    IsoHeader.P2 = PIN_UNBLOCK_P2;

    //
    // Send the pin change command to the card
    //

    status = ScwExecute(
        &IsoHeader,
        rgbDataIn,
        cbDataIn,
        NULL,
        NULL,
        &wStatusWord);

    if (SCW_S_OK == status)
    {
        // Reminder: Status words returned by this RTE app are in the form:
        // 9000 -> Success
        // 6Fyy -> An API failed with return code yy
        // 6Ezz -> An exception was raised (zz is the err number)
        switch (wStatusWord >> 8)
        {
        case 0x90:
            printf("Pin unblock was successful\n");
            break;

        case 0x6F:
        case 0x6E:
            // Make it a 32 bits error code so the message can be retrieved from
            // scwapi.dll
            status = 0x80000000L | (BYTE) wStatusWord;
            break;

        default:
            printf(
                "ERROR: unexpected status word received from card, %04X\n", 
                wStatusWord);

            status = (SCODE) SCARD_F_INTERNAL_ERROR;
            break;
        }
    }

    return status;
}

//
// Changes the user's pin using the VB applet on the card
//
DWORD TestPinChange(
    IN PBYTE pbCurrentPin,
    IN DWORD cbCurrentPin,
    IN PBYTE pbNewPin,
    IN DWORD cbNewPin)
{
    ISO_HEADER IsoHeader;
    BYTE rgbDataIn [256];
    UINT16 wStatusWord = 0;
    TCOUNT cbDataIn = 0;
    BYTE cbUser = (BYTE) ((wcslen(L"user") + 1) * sizeof(WCHAR));
    SCODE status = 0;

    memset(&IsoHeader, 0, sizeof(IsoHeader));
    memset(rgbDataIn, 0, sizeof(rgbDataIn));

    // Setup User Name TLV
    rgbDataIn[cbDataIn] = 0;
    cbDataIn++;

    rgbDataIn[cbDataIn] = cbUser;
    cbDataIn++;

    memcpy(rgbDataIn + cbDataIn, (PBYTE) L"user", cbUser);
    cbDataIn += cbUser;

    // Setup Current Pin TLV
    rgbDataIn[cbDataIn] = 1;
    cbDataIn++;

    rgbDataIn[cbDataIn] = (BYTE) cbCurrentPin;
    cbDataIn++;

    memcpy(rgbDataIn + cbDataIn, pbCurrentPin, cbCurrentPin);
    cbDataIn += (TCOUNT) cbCurrentPin;

    // Setup New Pin TLV
    rgbDataIn[cbDataIn] = 2;
    cbDataIn++;

    rgbDataIn[cbDataIn] = (BYTE) cbNewPin;
    cbDataIn++;

    memcpy(rgbDataIn + cbDataIn, pbNewPin, cbNewPin);
    cbDataIn += (TCOUNT) cbNewPin;

    // Build the command
    IsoHeader.INS = PIN_CHANGE_INS;
    IsoHeader.CLA = PIN_CHANGE_CLA;
    IsoHeader.P1 = PIN_CHANGE_P1;
    IsoHeader.P2 = PIN_CHANGE_P2;

    //
    // Send the pin change command to the card
    //

    status = ScwExecute(
        &IsoHeader,
        rgbDataIn,
        cbDataIn,
        NULL,
        NULL,
        &wStatusWord);

    if (SCW_S_OK == status)
    {
        // Reminder: Status words returned by this RTE app are in the form:
        // 9000 -> Success
        // 6Fyy -> An API failed with return code yy
        // 6Ezz -> An exception was raised (zz is the err number)
        switch (wStatusWord >> 8)
        {
        case 0x90:
            printf("Pin was changed successfully\n");
            break;

        case 0x6F:
        case 0x6E:
            // Make it a 32 bits error code so the message can be retrieved from
            // scwapi.dll
            status = 0x80000000L | (BYTE) wStatusWord;
            break;

        default:
            printf(
                "ERROR: unexpected status word received from card, %04X\n", 
                wStatusWord);

            status = (SCODE) SCARD_F_INTERNAL_ERROR;
            break;
        }
    }

    return status;
}

//
// Retrieves the number of attempts remaining on the specified principal's
// pin from the card, via the Pin Retry Counter applet.
//
DWORD TestPinRetryCounter(
    IN LPWSTR wszUserName)
{
    ISO_HEADER IsoHeader;
    BYTE rgbDataIn [256];
    UINT16 wStatusWord = 0;
    TCOUNT cbDataIn = (TCOUNT) ((wcslen(wszUserName) + 1) * sizeof(WCHAR));
    SCODE status = 0;

    memset(&IsoHeader, 0, sizeof(IsoHeader));
    memset(rgbDataIn, 0, sizeof(rgbDataIn));

    // Setup the user name that we'll send to the card
    memcpy(rgbDataIn, (PBYTE) wszUserName, cbDataIn);
     
    // Setup the command
    IsoHeader.CLA = PIN_RETRY_COUNTER_CLA;
    IsoHeader.INS = PIN_RETRY_COUNTER_INS;
    IsoHeader.P1 = PIN_RETRY_COUNTER_P1;
    IsoHeader.P2 = PIN_RETRY_COUNTER_P2;

    //
    // Call the retry counter applet on the card
    //

    status = ScwExecute(
        &IsoHeader,
        rgbDataIn,
        cbDataIn,
        NULL,
        NULL,
        &wStatusWord);

    if (SCW_S_OK == status)
    {
        // Reminder: Status words returned by this RTE app are in the form:
        // 9000 -> Success
        // 6Fyy -> An API failed with return code yy
        // 6Ezz -> An exception was raised (zz is the err number)
        switch (wStatusWord >> 8)
        {
        case 0x90:
            wprintf(
                L"Current pin attempts remaining for %s:  %02X\n",
                wszUserName,
                (BYTE) wStatusWord);
            break;

        case 0x6F:
        case 0x6E:
            // Make it a 32 bits error code so the message can be retrieved from
            // scwapi.dll
            status = 0x80000000L | (BYTE) wStatusWord;
            break;

        default:
            printf(
                "ERROR: unexpected status word received from card, %04X\n", 
                wStatusWord);

            status = (SCODE) SCARD_F_INTERNAL_ERROR;
            break;
        }
    }

    return status;
}

DWORD UpdateT1Atr(void)
{
    SCODE status = 0;
    DWORD cbFile = 0;
    DWORD cbRead = 0;
    BYTE rgbAtr [36];
    HFILE hFile = 0;
    BYTE rgbNewAtr [36];
    /*
    BYTE rgbNewAtr2 [] = {
        0x11, 0x00, 
        0x9C, 0x13, 0x81, 0x31, 0x20, 0x55, 0x42,
        0x61, 0x73, 0x65, 0x43, 0x53, 0x50, 0x2D, 0x54,
        0x31, 0x2D, 0x31, 0x6B
    };
    */

    BYTE rgbNewAtr2 [] = {
        0x11, 0x00, 
        0xDC, 0x13, 0x0A, 0x81, 0x31, 0x20, 0x55, 0x42,
        0x61, 0x73, 0x65, 0x43, 0x53, 0x50, 0x2D, 0x54,
        0x31, 0x2D, 0x31, 0x21
    };

    //
    // Get the current ATR and display it
    //

    status = ScwCreateFile(
        L"/T0",
        NULL,
        &hFile);

    if (SCW_S_OK != status)
        goto Ret;

    status = ScwWriteFile32(
        hFile, rgbNewAtr2, sizeof(rgbNewAtr2), &cbRead);

    if (SCW_S_OK != status)
        goto Ret;

    /*
    status = ScwGetFileLength(
        hFile, (TOFFSET *) &cbFile);

    if (SCW_S_OK != status)
        goto Ret;

    if (cbFile > sizeof(rgbAtr))
    {
        status = (SCODE) SCARD_F_INTERNAL_ERROR;
        goto Ret;
    }

    status = ScwReadFile32(
        hFile, rgbAtr, cbFile, &cbRead);

    if (SCW_S_OK != status)
        goto Ret;

    if (cbFile != cbRead)
    {
        status = (SCODE) SCARD_W_EOF;
        goto Ret;
    }

    PrintBytes(L"Current ATR", rgbAtr + 2, cbFile - 2);

    if (rgbAtr[2] & 0x10)
    {
        printf("Upgrade not necessary\n");
        goto Ret;
    }

    //
    // Build the new high data rate T1 ATR, display it, and write
    // it to the card.
    //

    rgbNewAtr[0] = rgbAtr[0];
    rgbNewAtr[1] = rgbAtr[1];
    rgbNewAtr[2] = rgbAtr[2] | 0x10;
    rgbNewAtr[3] = 0x12;

    memcpy(rgbNewAtr + 4, rgbAtr + 3, cbFile - 3);

    rgbNewAtr[cbFile] ^= 0x02;

    status = ScwSetFilePointer(hFile, 0, FILE_BEGIN);

    if (SCW_S_OK != status)
        goto Ret;

    status = ScwWriteFile32(
        hFile, rgbNewAtr, cbFile + 1, &cbRead);

    if (SCW_S_OK != status)
        goto Ret;

    if (cbRead != cbFile + 1)
    {
        status = (SCODE) SCARD_W_EOF;
        goto Ret;
    }

    PrintBytes(L"New ATR", rgbNewAtr + 2, cbRead - 2);
    */

Ret:

    if (hFile)
        ScwCloseFile(hFile);

    return (DWORD) status;
}

void ShowHelp(void)
{
    printf("wfscproto <options>\n");
    printf(" Options:\n");
    printf(" -a : Update the ATR for a T=1 card\n");
    printf(" -g : Generate a new private key on the card\n");
    printf(" -k [bits] : Key size in bits (default is 512)\n");
    printf(" -c : Use Crypto API to generate key (default is to use rsa32.lib directly)\n");
    printf(" -t : Use Crypto API to generate key with CRT parameters\n");
    printf(" -e : Enumerate all directories and files on card\n");
    printf(" -p : Pin change\n");
    printf(" -u : Pin unblock\n");
    printf(" -r : Query pin retry counter\n");
}

int __cdecl main(int argc, char* argv[])
{
    SCODE status = 0;
    BOOL fSuccess = FALSE;
    HFILE hFile = 0;
    BYTE rgb[65];
    BYTE rgbData[1024];
    BYTE rgbResult[1024];
    DWORD cb = 0;
    DWORD dw = 0;
    UINT16 EnumState = 0;
    WCHAR rgwsz[64];
    PBYTE pb = NULL;
    TCOUNT tcount = 0;
    DWORD dwError = 0;
    SCARDCONTEXT hSCardContext = 0;
    SCARDHANDLE hSCardHandle = 0;
    LPSTR mszReaders = NULL;
    DWORD cchReaders = SCARD_AUTOALLOCATE;
    DWORD dwActiveProtocol = 0;
    BOOL fAuthenticatedUser = FALSE;
    BOOL fAuthenticatedAdmin = FALSE;
    BOOL fUseSimulator = FALSE;
    BOOL fEnumFiles = FALSE;
    BOOL fGenKey = FALSE;
    DWORD dwState = 0;
    BYTE rgbAtr [32];
    DWORD cbAtr = sizeof(rgbAtr);
    DWORD fUseCapi = FALSE;
    DWORD cKeyBits = 512;
    BOOL fShowHelp = FALSE;
    BOOL fPinChange = FALSE;
    BOOL fPinUnblock = FALSE;
    BOOL fGetPinRetryCounter = FALSE;
    BOOL fGenKeyCRT = FALSE;
    BOOL fUpdateT1Atr = FALSE;

    memset(rgbData, 0, sizeof(rgbData));
    memset(rgbResult, 0, sizeof(rgbResult));

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'a':
                fUpdateT1Atr = TRUE;
                break;

            case 'c':
                fUseCapi = TRUE;
                break;

            case 'k':
                --argc;
                ++argv;

                cKeyBits = atoi(*argv);
                break;

            case 'g':
                fGenKey = TRUE;
                break;

            case 'e':
                fEnumFiles = TRUE;
                break;

            case 'p':
                fPinChange = TRUE;
                break;

            case 'u':
                fPinUnblock = TRUE;
                break;

            case 'r':
                fGetPinRetryCounter = TRUE;
                break;

            case 't':
                fGenKeyCRT = TRUE;
                break;

            case '?':
                fShowHelp = TRUE;
                goto Ret;

            default:
                fShowHelp = TRUE;
                goto Ret;
            }
        }
        else
            goto Ret;
    }

    //
    // Attach to the card
    //

    if (fUseSimulator)
    {
        
        // For connecting to the simulator
        status = ScwAttachToCard(NULL_TX, wszTEST_CARD_NAME);
        
        if (SC_FAILED(status))
            goto Ret;
    }
    else
    {
        
        status = SCardEstablishContext(
            SCARD_SCOPE_USER, NULL, NULL, &hSCardContext);
        
        if (SC_FAILED(status))
            goto Ret;
        
        status = SCardListReadersA(
            hSCardContext, NULL, (LPSTR) (&mszReaders), &cchReaders);
        
        if (SC_FAILED(status) || NULL == mszReaders)
            goto Ret;
        
        status = SCardConnectA(
            hSCardContext, 
            mszReaders, 
            SCARD_SHARE_SHARED, 
            SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1 | SCARD_PROTOCOL_DEFAULT,
            &hSCardHandle,
            &dwActiveProtocol);
        
        if (SC_FAILED(status))
            goto Ret;

        if (mszReaders)
        {
            SCardFreeMemory(hSCardContext, mszReaders);
            mszReaders = NULL;
        }

        cchReaders = SCARD_AUTOALLOCATE;
        status = SCardStatusA(
            hSCardHandle,
            (LPSTR) (&mszReaders),
            &cchReaders,
            &dwState,
            &dwActiveProtocol,
            rgbAtr,
            &cbAtr);

        if (SC_FAILED(status))
            goto Ret;
        
        status = ScwAttachToCard(
            hSCardHandle, NULL);
        
        if (SC_FAILED(status))
            goto Ret;
        
    }

    status = Authenticate(PRINCIPAL_USER);

    if (SC_FAILED(status))
        goto Ret;

    fAuthenticatedUser = TRUE;

    if (fUpdateT1Atr)
    {
        dwError = UpdateT1Atr();

        if (ERROR_SUCCESS != dwError)
            goto Ret;
    }
    //
    // Enumerate all files
    //

    if (fEnumFiles)
    {
        status = (DWORD) EnumFilesInDirectory(L"", L"/");
    
        if (SC_FAILED(status))
            goto Ret;
    }

    //
    // RSA Operation
    //

    if (fGenKey)
    {
        if (fUseSimulator)
        {
            dwError = SetupRsaKeyOnCardSimulator(
                wszRSA_KEY_FILE, wszKEY_ACL_FILE, fUseSimulator);
        
            if (ERROR_SUCCESS != dwError)
                goto Ret;
        }
        else
        {
            printf(
                "Using %s to generate %d bit key\n",
                fUseCapi ? "Crypto API" : "rsa32.lib",
                cKeyBits);
    
            if (FALSE == fUseCapi)
                dwError = GenKeyOnCardWithRsa32(
                    wszRSA_KEY_FILE, wszKEY_ACL_FILE, cKeyBits);
            else
                dwError = GenKeyOnCardWithCapi(
                    wszRSA_KEY_FILE, wszKEY_ACL_FILE, cKeyBits);
    
            if (ERROR_SUCCESS != dwError)
                goto Ret;
        }
    
        // Initialize
        pb = rgb;
        *pb++ = 0x00;                           // Tag
        
        cb = (wcslen(wszRSA_KEY_FILE) + 1) * sizeof(WCHAR);
        *pb++ = (BYTE) (1 + cb + 2);        
                                                // Length
                                                //  Number of following bytes: 
                                                //  filename len, filename + NULL, key data offset
        
        *pb++ = (BYTE) cb / sizeof(WCHAR);      // Value
        wcscpy((LPWSTR) pb, wszRSA_KEY_FILE);
        pb += cb;
        *(WORD*)pb = 0x0000;    
    
        status = ScwCryptoInitialize(
            CM_RSA | CM_KEY_INFILE,
            rgb);
    
        if (SC_FAILED(status))
            goto Ret;
    
        // RSA Sign
        memset(rgbData, 0, sizeof(rgbData));
    
        for (dw = 0; dw < 16; dw++)
            rgbData[dw] = (BYTE) dw;

        PrintBytes(L"Plaintext", rgbData, 16);

        tcount = (TCOUNT) (cKeyBits / 8);
        status = ScwCryptoAction(
            rgbData,
            16,
            rgbResult,
            &tcount);
    
        if (SC_FAILED(status))
            goto Ret;

        PrintBytes(L"Ciphertext", rgbResult, tcount);
    }

    if (fGenKeyCRT)
    {
        printf(
            "Using Crypto API to generate %d bit key with CRT params\n",
            cKeyBits);

        dwError = GenKeyOnCardCRT(
            wszRSA_KEY_FILE, wszKEY_ACL_FILE, cKeyBits);

        if (ERROR_SUCCESS != dwError)
            goto Ret;
         
        // Initialize
        pb = rgb;
        *pb++ = 0x00;                           // Tag
        
        cb = (wcslen(wszRSA_KEY_FILE) + 1) * sizeof(WCHAR);
        *pb++ = (BYTE) (1 + cb + 2);        
                                                // Length
                                                //  Number of following bytes: 
                                                //  filename len, filename + NULL, key data offset
        
        *pb++ = (BYTE) cb / sizeof(WCHAR);      // Value
        wcscpy((LPWSTR) pb, wszRSA_KEY_FILE);
        pb += cb;
        *(WORD*)pb = 0x0000;    
    
        status = ScwCryptoInitialize(
            CM_RSA_CRT | CM_KEY_INFILE,
            rgb);
    
        if (SC_FAILED(status))
            goto Ret;
    
        // RSA Sign
        memset(rgbData, 0, sizeof(rgbData));
    
        for (dw = 0; dw < 16; dw++)
            rgbData[dw] = (BYTE) dw;

        PrintBytes(L"Plaintext", rgbData, 16);

        tcount = (TCOUNT) (cKeyBits / 8);
        status = ScwCryptoAction(
            rgbData,
            16,
            rgbResult,
            &tcount);
    
        if (SC_FAILED(status))
            goto Ret;

        PrintBytes(L"Ciphertext", rgbResult, tcount);
    }

    if (fPinChange)
    {
        //
        // Test the on-card pin change applet
        //

        if (fAuthenticatedUser)
        {
            status = (DWORD) Deauthenticate(PRINCIPAL_USER);

            if (SC_FAILED(status))
                goto Ret;

            fAuthenticatedUser = FALSE;
        }

        status = (DWORD) TestPinChange(
            Principals[PRINCIPAL_USER].rgbPin,
            sizeof(Principals[PRINCIPAL_USER].rgbPin),
            rgbUserNewPin,
            sizeof(rgbUserNewPin));

        if (SC_FAILED(status))
            goto Ret;

        // Now change the pin back
        status = (DWORD) TestPinChange(
            rgbUserNewPin,
            sizeof(rgbUserNewPin),
            Principals[PRINCIPAL_USER].rgbPin,
            sizeof(Principals[PRINCIPAL_USER].rgbPin));

        if (SC_FAILED(status))
            goto Ret;
    }

    if (fPinUnblock)
    {
        //
        // Test the on-card pin unblock applet
        //

        // Need to authenticate the Admin first

        if (fAuthenticatedUser)
        {
            status = (DWORD) Deauthenticate(PRINCIPAL_USER);

            if (SC_FAILED(status))
                goto Ret;

            fAuthenticatedUser = FALSE;
        }

        status = (DWORD) Authenticate(PRINCIPAL_ADMIN);

        if (SC_FAILED(status))
            goto Ret;

        fAuthenticatedAdmin = TRUE;

        status = (DWORD) TestPinUnblock(
            rgbUserNewPin,
            sizeof(rgbUserNewPin));

        if (SC_FAILED(status))
            goto Ret;

        // Now change the User pin back to its original value

        status = (DWORD) Deauthenticate(PRINCIPAL_ADMIN);

        if (SC_FAILED(status))
            goto Ret;

        fAuthenticatedAdmin = FALSE;

        status = (DWORD) TestPinChange(
            rgbUserNewPin,
            sizeof(rgbUserNewPin),
            Principals[PRINCIPAL_USER].rgbPin,
            sizeof(Principals[PRINCIPAL_USER].rgbPin));

        if (SC_FAILED(status))
            goto Ret;
    }

    if (fGetPinRetryCounter)
    {
        //
        // Test the on-card pin retry counter applet
        //

        status = (DWORD) TestPinRetryCounter(
            Principals[PRINCIPAL_USER].pwszUser);

        if (SC_FAILED(status))
            goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (! fSuccess)
    {
        if (fShowHelp)
            ShowHelp();
        else
            printf("ERROR: 0x%x\n", status);
    }
    else 
        printf("Success\n");

    if (fAuthenticatedAdmin)
        Deauthenticate(PRINCIPAL_ADMIN);

    if (fAuthenticatedUser)
        Deauthenticate(PRINCIPAL_USER);

    ScwDetachFromCard();

    if (mszReaders)
        status = SCardFreeMemory(hSCardContext, mszReaders);

    if (hSCardHandle)
        status = SCardDisconnect(hSCardHandle, SCARD_RESET_CARD);

    if (hSCardContext)
        status = SCardReleaseContext(hSCardContext);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\test\intftest\intftest.c ===
#include <windows.h>
#include <wincrypt.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "basecsp.h"
#include "cardmod.h"
#include <dsysdbg.h>

#define wszTEST_CARD            L"Wfsc Demo 3\0"
#define cMAX_READERS            20

//
// Need to define the dsys debug symbols since we're linking directly to the
// card interface lib which requires them.
//
DEFINE_DEBUG2(Basecsp)

//
// Functions defined in the card interface lib that we call.
//
extern DWORD InitializeCardState(PCARD_STATE);
extern void DeleteCardState(PCARD_STATE);          

//
// Wrapper for making test calls.
//
#define TEST_CASE(X) { if (ERROR_SUCCESS != (dwSts = X)) { printf("%s", #X); goto Ret; } }

//
// Function: CspAllocH
//
LPVOID WINAPI CspAllocH(
    IN SIZE_T cBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cBytes);
}

//
// Function: CspFreeH
//
void WINAPI CspFreeH(
    IN LPVOID pMem)
{
    HeapFree(GetProcessHeap(), 0, pMem);
}

// 
// Function: CspReAllocH
//
LPVOID WINAPI CspReAllocH(
    IN LPVOID pMem, 
    IN SIZE_T cBytes)
{
    return HeapReAlloc(
        GetProcessHeap(), HEAP_ZERO_MEMORY, pMem, cBytes);
}

//
// Critical Section Management
//

//
// Function: CspInitializeCriticalSection
//
DWORD CspInitializeCriticalSection(
    IN CRITICAL_SECTION *pcs)
{
    __try {
        InitializeCriticalSection(pcs);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return ERROR_SUCCESS;
}

//
// Function: CspEnterCriticalSection
//
DWORD CspEnterCriticalSection(
    IN CRITICAL_SECTION *pcs)
{
    __try {
        EnterCriticalSection(pcs);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return ERROR_SUCCESS;
}   

//
// Function: CspLeaveCriticalSection
//
void CspLeaveCriticalSection(
    IN CRITICAL_SECTION *pcs)
{
    LeaveCriticalSection(pcs);
}

//
// Function: CspDeleteCriticalSection
//
void CspDeleteCriticalSection(
    IN CRITICAL_SECTION *pcs)
{
    DeleteCriticalSection(pcs);
}

int _cdecl main(int argc, char * argv[])
{
    CARD_STATE CardState;
    PCARD_DATA pCardData;
    DWORD dwSts = ERROR_SUCCESS;
    PFN_CARD_ACQUIRE_CONTEXT pfnCardAcquireContext = NULL;
    CARD_FREE_SPACE_INFO CardFreeSpaceInfo;
    CARD_CAPABILITIES CardCapabilities;
    CARD_KEY_SIZES CardKeySizes;
    CONTAINER_INFO ContainerInfo;
    LPWSTR pwsz = NULL;
    DATA_BLOB dbOut;
    BYTE rgb [] = { 0x3, 0x2, 0x1, 0x0 };
    DATA_BLOB dbIn;
    SCARDCONTEXT hContext = 0;
    LPWSTR mszReaders = NULL;
    DWORD cchReaders = SCARD_AUTOALLOCATE;
    LPWSTR mszCards = NULL;
    DWORD cchCards = SCARD_AUTOALLOCATE;
    SCARD_READERSTATE rgReaderState [cMAX_READERS];
    DWORD iReader = 0;
    DWORD cchCurrent = 0;
    DWORD dwProtocol = 0;
    SCARDHANDLE hCard = 0;
    BOOL fConnected = FALSE;
    CARD_FILE_ACCESS_CONDITION Acl = EveryoneReadUserWriteAc;
    BYTE rgbPin [] = { 0x00, 0x00, 0x00, 0x00 };
    DATA_BLOB dbPin;
    PBYTE pbKey = NULL;
    DWORD cbKey = 0;
    HCRYPTKEY hKey = 0;
    HCRYPTPROV hProv = 0;
    WCHAR rgwsz [MAX_PATH];
    BYTE bContainerIndex = 0;

    memset(&CardState, 0, sizeof(CardState));
    memset(&CardFreeSpaceInfo, 0, sizeof(CardFreeSpaceInfo));
    memset(&CardCapabilities, 0, sizeof(CardCapabilities));
    memset(&ContainerInfo, 0, sizeof(ContainerInfo));
    memset(&CardKeySizes, 0, sizeof(CardKeySizes));
    memset(&dbOut, 0, sizeof(dbOut));
    memset(rgReaderState, 0, sizeof(rgReaderState));
    memset(&dbPin, 0, sizeof(dbPin));

    dbPin.cbData = sizeof(rgbPin);
    dbPin.pbData = rgbPin;

    dbIn.cbData = sizeof(rgb);
    dbIn.pbData = rgb;

    // 
    // Initialization
    //

    //
    // Get a list of readers
    //

    dwSts = SCardEstablishContext(
        SCARD_SCOPE_USER, NULL, NULL, &hContext);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    dwSts = SCardListReaders(
        hContext,
        NULL,
        (LPWSTR) &mszReaders,
        &cchReaders);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    //
    // Get a list of cards
    //

    /*
    dwSts = SCardListCards(
        hContext, NULL, NULL, 0, (LPWSTR) &mszCards, &cchCards);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;
        */

    //
    // Build the reader state array
    //

    for (   iReader = 0, cchReaders = 0; 
            iReader < (sizeof(rgReaderState) / sizeof(rgReaderState[0])) 
                &&
            L'\0' != mszReaders[cchReaders]; 
            iReader++)
    {
        rgReaderState[iReader].dwCurrentState = SCARD_STATE_UNAWARE;
        rgReaderState[iReader].szReader = mszReaders + cchReaders;

        cchReaders += 1 + wcslen(mszReaders);
    }

    //
    // Find a card we can talk to
    //

    dwSts = SCardLocateCards(
        hContext, 
        wszTEST_CARD,
        rgReaderState,
        iReader);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;
    
    while (0 != iReader && FALSE == fConnected)
    {
        iReader--;

        if (SCARD_STATE_ATRMATCH & rgReaderState[iReader].dwEventState)
        {
            dwSts = SCardConnect(
                hContext,
                rgReaderState[iReader].szReader,
                SCARD_SHARE_SHARED,
                SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
                &hCard,
                &dwProtocol);

            if (ERROR_SUCCESS != dwSts)
                goto Ret;
            else
                fConnected = TRUE;
        }
    }

    if (FALSE == fConnected)
        goto Ret;

    //
    // Initialize the card data structures
    //

    TEST_CASE(InitializeCardState(&CardState));

    CardState.hCardModule = LoadLibrary(L"cardmod.dll");

    if (INVALID_HANDLE_VALUE == CardState.hCardModule)
    {
        printf("LoadLibrary cardmod.dll");
        dwSts = GetLastError();
        goto Ret;
    }

    pfnCardAcquireContext = 
        (PFN_CARD_ACQUIRE_CONTEXT) GetProcAddress(
        CardState.hCardModule,
        "CardAcquireContext");

    if (NULL == pfnCardAcquireContext)
    {
        printf("GetProcAddress");
        dwSts = GetLastError();
        goto Ret;
    }

    pCardData = (PCARD_DATA) CspAllocH(sizeof(CARD_DATA));

    if (NULL == pCardData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    pCardData->pwszCardName = wszTEST_CARD;
    pCardData->hScard = hCard;
    pCardData->hSCardCtx = hContext;
    pCardData->dwVersion = CARD_DATA_CURRENT_VERSION;
    pCardData->pfnCspAlloc = CspAllocH;
    pCardData->pfnCspReAlloc = CspReAllocH;
    pCardData->pfnCspFree = CspFreeH;
    pCardData->pbAtr = rgReaderState[iReader].rgbAtr;
    pCardData->cbAtr = rgReaderState[iReader].cbAtr;

    TEST_CASE(pfnCardAcquireContext(pCardData, 0));

    CardState.pCardData = pCardData;

    TEST_CASE(InitializeCspCaching(&CardState));

    //
    // Now start tests
    //

    //
    // Test 1: Container data caching
    //

    /*
    TEST_CASE(CspEnumContainers(&CardState, 0, &pwsz));

    CspFreeH(pwsz);
    pwsz = NULL;

    // Check cached call
    TEST_CASE(CspEnumContainers(&CardState, 0, &pwsz));

    CspFreeH(pwsz);
    pwsz = NULL;
    */

    //
    // Create a private key blob to import to the card
    //

    if (! CryptAcquireContext(
        &hProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    //
    // For now, make this key really small so we're sure to not run out of 
    // space on wimpy test cards.
    //
    if (! CryptGenKey(
        hProv, AT_KEYEXCHANGE, (384 << 16) | CRYPT_EXPORTABLE, &hKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    if (! CryptExportKey(
        hKey, 0, PRIVATEKEYBLOB, 0, NULL, &cbKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    pbKey = (PBYTE) CspAllocH(cbKey);

    if (NULL == pbKey)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (! CryptExportKey(
        hKey, 0, PRIVATEKEYBLOB, 0, pbKey, &cbKey))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    //
    // Now we'll be modifying card data, so we need to authenticate.
    //

    TEST_CASE(CspSubmitPin(
        &CardState, 
        wszCARD_USER_USER, 
        dbPin.pbData,
        dbPin.cbData,
        NULL));

    // CreateContainer call will invalidate current container-space cache items
    TEST_CASE(CspCreateContainer(
        &CardState,
        bContainerIndex,
        CARD_CREATE_CONTAINER_KEY_IMPORT,
        AT_KEYEXCHANGE,
        cbKey,
        pbKey));

    // Cached container enum should now be invalid
    /*
    TEST_CASE(CspEnumContainers(&CardState, 0, &pwsz));

    CspFreeH(pwsz);
    pwsz = NULL;
    */

    // 
    // Test 2: File data caching
    //

    /*
    TODO - re-enabled the EnumFiles tests once CardEnumFiles is correctly
    implemented
    
    pwsz = wszCSP_DATA_DIR_FULL_PATH;
    TEST_CASE(CspEnumFiles(&CardState, 0, &pwsz));

    CspFreeH(pwsz);
    pwsz = NULL;

    // Use cached data
    pwsz = wszCSP_DATA_DIR_FULL_PATH;
    TEST_CASE(CspEnumFiles(&CardState, 0, &pwsz));

    CspFreeH(pwsz);
    pwsz = NULL;
    */

    // Create some test files just in case they don't already exist on 
    // this card.
    wsprintf(
        rgwsz, L"%s/File2", wszCSP_DATA_DIR_FULL_PATH);

    dwSts = CspCreateFile(&CardState, rgwsz, Acl);

    wsprintf(
        rgwsz, L"%s/File1", wszCSP_DATA_DIR_FULL_PATH);

    dwSts = CspCreateFile(&CardState, rgwsz, Acl);

    // Write file should invalidate all cached file data
    TEST_CASE(CspWriteFile(&CardState, rgwsz, 0, dbIn.pbData, dbIn.cbData));

    // Invalidate cached file we just created
    TEST_CASE(CspWriteFile(&CardState, rgwsz, 0, dbIn.pbData, dbIn.cbData));

    // Cached file enum should now be invalid
    /*
    pwsz = wszCSP_DATA_DIR_FULL_PATH;
    TEST_CASE(CspEnumFiles(&CardState, 0, &pwsz));

    CspFreeH(pwsz);
    pwsz = NULL;
    */

    //
    // Test 3: Get container info
    //

    ContainerInfo.dwVersion = CONTAINER_INFO_CURRENT_VERSION;

    TEST_CASE(CspGetContainerInfo(&CardState, bContainerIndex, 0, &ContainerInfo));

    // Caller won't free the key data buffers.  Leave them for final cleanup.
    if (ContainerInfo.pbKeyExPublicKey)
        CspFreeH(ContainerInfo.pbKeyExPublicKey);
    ContainerInfo.pbKeyExPublicKey = NULL;

    if (ContainerInfo.pbSigPublicKey)
        CspFreeH(ContainerInfo.pbSigPublicKey);
    ContainerInfo.pbSigPublicKey = NULL;

    // Use cached data
    TEST_CASE(CspGetContainerInfo(&CardState, bContainerIndex, 0, &ContainerInfo));

    if (ContainerInfo.pbKeyExPublicKey)
        CspFreeH(ContainerInfo.pbKeyExPublicKey);
    ContainerInfo.pbKeyExPublicKey = NULL;

    if (ContainerInfo.pbSigPublicKey)
        CspFreeH(ContainerInfo.pbSigPublicKey);
    ContainerInfo.pbSigPublicKey = NULL;

    //
    // Test 4: Get Card Capabilities
    //

    CardCapabilities.dwVersion = CARD_CAPABILITIES_CURRENT_VERSION;

    TEST_CASE(CspQueryCapabilities(&CardState, &CardCapabilities));

    // Read cached
    TEST_CASE(CspQueryCapabilities(&CardState, &CardCapabilities));

    //
    // Test 5: Read file
    //

    wsprintf(
        rgwsz, L"%s/File1", wszCSP_DATA_DIR_FULL_PATH);

    TEST_CASE(CspReadFile(&CardState, rgwsz, 0, &dbOut.pbData, &dbOut.cbData));

    CspFreeH(dbOut.pbData);
    memset(&dbOut, 0, sizeof(dbOut));

    // Use cached data
    TEST_CASE(CspReadFile(&CardState, rgwsz, 0, &dbOut.pbData, &dbOut.cbData));

    CspFreeH(dbOut.pbData);
    memset(&dbOut, 0, sizeof(dbOut));

    wsprintf(
        rgwsz, L"%s/File2", wszCSP_DATA_DIR_FULL_PATH);
    
    // Invalidate all file-related cached data
    TEST_CASE(CspDeleteFile(&CardState, 0, rgwsz));

    wsprintf(
        rgwsz, L"%s/File1", wszCSP_DATA_DIR_FULL_PATH);

    // Re-read file from card
    TEST_CASE(CspReadFile(&CardState, rgwsz, 0, &dbOut.pbData, &dbOut.cbData));

    CspFreeH(dbOut.pbData);
    memset(&dbOut, 0, sizeof(dbOut));

    //
    // Test 6: Query Key Sizes
    //

    CardKeySizes.dwVersion = CARD_KEY_SIZES_CURRENT_VERSION;

    // Signature Keys
    TEST_CASE(CspQueryKeySizes(&CardState, AT_SIGNATURE, 0, &CardKeySizes));

    // Query cached
    TEST_CASE(CspQueryKeySizes(&CardState, AT_SIGNATURE, 0, &CardKeySizes));

    // Key Exchange Keys
    TEST_CASE(CspQueryKeySizes(&CardState, AT_KEYEXCHANGE, 0, &CardKeySizes));

    // Query cached
    TEST_CASE(CspQueryKeySizes(&CardState, AT_KEYEXCHANGE, 0, &CardKeySizes));

Ret:
    
    if (pbKey)
        CspFreeH(pbKey);
    if (hKey)
        CryptDestroyKey(hKey);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (mszCards)
        SCardFreeMemory(hContext, mszCards);
    if (mszReaders)
        SCardFreeMemory(hContext, mszReaders);
    if (dbOut.pbData)
        CspFreeH(dbOut.pbData);
    if (pwsz)
        CspFreeH(pwsz);
    if (ERROR_SUCCESS != dwSts)
        printf(" failed, 0x%x\n", dwSts);

    // Static buffers were used, don't let them be freed
    pCardData->pwszCardName = NULL; 
    pCardData->pbAtr = NULL;

    DeleteCardState(&CardState);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\test\scnarios\scnarios.c ===
#include <windows.h>
#include <wincrypt.h>
#include <winscard.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

/*
    A list of the API calls made by enrollment:
    
    CryptAcquireContext
    CRYPT_VERIFYCONTEXT
    
    CryptGetProvParam
    PP_ENUMALGS_EX
    PP_ENUMALGS
    PP_KEYSPEC
    PP_NAME
    PP_UNIQUE_CONTAINER
    PP_PROVTYPE
    
    CryptReleaseContext
    
    CryptGetUserKey
    AT_KEYEXCHANGE
    
    CryptGenKey
    
    CryptDestroyKey
    
    CryptExportKey
    PUBLICKEYBLOB
    
    CryptCreateHash
    CALG_SHA
    
    CryptHashData
    
    CryptSignHash
    AT_KEYEXCHANGE
    
    CryptDestroyHash
*/

#define TEST_CASE(X) { if (ERROR_SUCCESS != (dwSts = X)) { printf("%s", #X); goto Ret; } }

#define CAPI_TEST_CASE(X) { if (! X) { dwSts = GetLastError(); printf("%s", #X); goto Ret; } }

BYTE rgbTestCer [] = {
0x30, 0x82, 0x05, 0x8f, 0x30, 0x82, 0x04, 0xf8, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0a, 0x1e,
0x39, 0xa7, 0x1c, 0x00, 0x01, 0x00, 0x0f, 0xc9, 0x64, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x4b, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a,
0x13, 0x09, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x0e, 0x30, 0x0c, 0x06,
0x03, 0x55, 0x04, 0x0b, 0x13, 0x05, 0x4e, 0x74, 0x64, 0x65, 0x76, 0x31, 0x18, 0x30, 0x16, 0x06,
0x03, 0x55, 0x04, 0x03, 0x13, 0x0f, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x20, 0x49, 0x53, 0x53, 0x55,
0x45, 0x33, 0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d, 0x30, 0x31, 0x31, 0x31, 0x31, 0x39, 0x32,
0x31, 0x32, 0x39, 0x31, 0x34, 0x5a, 0x17, 0x0d, 0x30, 0x32, 0x30, 0x39, 0x32, 0x30, 0x32, 0x31,
0x33, 0x33, 0x32, 0x38, 0x5a, 0x30, 0x7b, 0x31, 0x13, 0x30, 0x11, 0x06, 0x0a, 0x09, 0x92, 0x26,
0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x03, 0x63, 0x6f, 0x6d, 0x31, 0x19, 0x30, 0x17,
0x06, 0x0a, 0x09, 0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x09, 0x6d, 0x69,
0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x15, 0x30, 0x13, 0x06, 0x0a, 0x09, 0x92, 0x26,
0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x05, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x31, 0x0c,
0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x03, 0x49, 0x54, 0x47, 0x31, 0x0e, 0x30, 0x0c,
0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x05, 0x55, 0x73, 0x65, 0x72, 0x73, 0x31, 0x14, 0x30, 0x12,
0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0b, 0x44, 0x61, 0x6e, 0x20, 0x47, 0x72, 0x69, 0x66, 0x66,
0x69, 0x6e, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0x89,
0x9f, 0x70, 0xb2, 0x5e, 0xfd, 0x99, 0x31, 0xb8, 0xcd, 0x17, 0xba, 0x2f, 0x7c, 0xb9, 0xed, 0xde,
0x56, 0xff, 0xb3, 0x37, 0x78, 0xd0, 0x51, 0xae, 0x14, 0x7c, 0xae, 0x91, 0x1f, 0xb0, 0x26, 0x87,
0xaf, 0x43, 0x3e, 0xde, 0x59, 0xbb, 0xc8, 0xcf, 0xbe, 0x25, 0x03, 0x0a, 0x1c, 0xd8, 0x18, 0x4d,
0x1a, 0xbd, 0xe3, 0xb0, 0x73, 0xc9, 0x2b, 0x29, 0x0b, 0x0a, 0x12, 0xdd, 0x55, 0x37, 0xcb, 0x2b,
0x8f, 0xf2, 0xe6, 0x2c, 0x2e, 0x7f, 0x8d, 0x71, 0x9a, 0x77, 0xf6, 0x4e, 0x4e, 0x3e, 0x94, 0x2e,
0xdb, 0x3c, 0xd4, 0xde, 0x32, 0x1f, 0xc7, 0xb9, 0x96, 0x72, 0xbb, 0x0d, 0x80, 0xc9, 0xc0, 0x3e,
0x84, 0xee, 0x33, 0x3c, 0x62, 0x46, 0x17, 0x7d, 0x27, 0x83, 0x15, 0xdd, 0x2f, 0x2f, 0x0a, 0xb3,
0xcf, 0x76, 0xf6, 0x9b, 0x0d, 0x70, 0x6d, 0x99, 0x5b, 0xca, 0xba, 0x07, 0x8a, 0x44, 0xd3, 0x02,
0x03, 0x01, 0x00, 0x01, 0xa3, 0x82, 0x03, 0x48, 0x30, 0x82, 0x03, 0x44, 0x30, 0x0b, 0x06, 0x03,
0x55, 0x1d, 0x0f, 0x04, 0x04, 0x03, 0x02, 0x05, 0xa0, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e,
0x04, 0x16, 0x04, 0x14, 0x38, 0xef, 0x1a, 0xde, 0x6f, 0x3e, 0xa8, 0x73, 0x86, 0x74, 0xb8, 0x27,
0x4b, 0x9e, 0x8a, 0x98, 0xf7, 0x67, 0x70, 0x47, 0x30, 0x2b, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04,
0x01, 0x82, 0x37, 0x14, 0x02, 0x04, 0x1e, 0x1e, 0x1c, 0x00, 0x53, 0x00, 0x6d, 0x00, 0x61, 0x00,
0x72, 0x00, 0x74, 0x00, 0x63, 0x00, 0x61, 0x00, 0x72, 0x00, 0x64, 0x00, 0x4c, 0x00, 0x6f, 0x00,
0x67, 0x00, 0x6f, 0x00, 0x6e, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16,
0x80, 0x14, 0xc9, 0x44, 0x56, 0x4a, 0x90, 0x13, 0x7c, 0xa9, 0xf3, 0x33, 0x06, 0x6b, 0xde, 0xd0,
0x99, 0xbb, 0xe7, 0xc8, 0xce, 0xe9, 0x30, 0x82, 0x01, 0x26, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04,
0x82, 0x01, 0x1d, 0x30, 0x82, 0x01, 0x19, 0x30, 0x82, 0x01, 0x15, 0xa0, 0x82, 0x01, 0x11, 0xa0,
0x82, 0x01, 0x0d, 0x86, 0x81, 0xc4, 0x6c, 0x64, 0x61, 0x70, 0x3a, 0x2f, 0x2f, 0x2f, 0x43, 0x4e,
0x3d, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25,
0x32, 0x30, 0x43, 0x41, 0x2c, 0x43, 0x4e, 0x3d, 0x57, 0x48, 0x49, 0x43, 0x41, 0x33, 0x2c, 0x43,
0x4e, 0x3d, 0x43, 0x44, 0x50, 0x2c, 0x43, 0x4e, 0x3d, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x25,
0x32, 0x30, 0x4b, 0x65, 0x79, 0x25, 0x32, 0x30, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73,
0x2c, 0x43, 0x4e, 0x3d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d,
0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x44, 0x43,
0x3d, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2c, 0x44, 0x43, 0x3d, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73,
0x6f, 0x66, 0x74, 0x2c, 0x44, 0x43, 0x3d, 0x63, 0x6f, 0x6d, 0x3f, 0x63, 0x65, 0x72, 0x74, 0x69,
0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
0x4c, 0x69, 0x73, 0x74, 0x3f, 0x62, 0x61, 0x73, 0x65, 0x3f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
0x43, 0x6c, 0x61, 0x73, 0x73, 0x3d, 0x63, 0x52, 0x4c, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62,
0x75, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x86, 0x44, 0x68, 0x74, 0x74, 0x70,
0x3a, 0x2f, 0x2f, 0x77, 0x68, 0x69, 0x63, 0x61, 0x33, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e,
0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x65,
0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f, 0x6c, 0x6c, 0x2f, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32,
0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25, 0x32, 0x30, 0x43, 0x41, 0x2e, 0x63, 0x72, 0x6c,
0x30, 0x82, 0x01, 0x42, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x82,
0x01, 0x34, 0x30, 0x82, 0x01, 0x30, 0x30, 0x81, 0xbd, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05,
0x07, 0x30, 0x02, 0x86, 0x81, 0xb0, 0x6c, 0x64, 0x61, 0x70, 0x3a, 0x2f, 0x2f, 0x2f, 0x43, 0x4e,
0x3d, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25,
0x32, 0x30, 0x43, 0x41, 0x2c, 0x43, 0x4e, 0x3d, 0x41, 0x49, 0x41, 0x2c, 0x43, 0x4e, 0x3d, 0x50,
0x75, 0x62, 0x6c, 0x69, 0x63, 0x25, 0x32, 0x30, 0x4b, 0x65, 0x79, 0x25, 0x32, 0x30, 0x53, 0x65,
0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74,
0x69, 0x6f, 0x6e, 0x2c, 0x44, 0x43, 0x3d, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2c, 0x44, 0x43, 0x3d,
0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2c, 0x44, 0x43, 0x3d, 0x63, 0x6f, 0x6d,
0x3f, 0x63, 0x41, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x3f, 0x62,
0x61, 0x73, 0x65, 0x3f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x3d,
0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x75, 0x74,
0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30, 0x6e, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
0x30, 0x02, 0x86, 0x62, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x68, 0x69, 0x63, 0x61,
0x33, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66,
0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x65, 0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f, 0x6c, 0x6c,
0x2f, 0x57, 0x48, 0x49, 0x43, 0x41, 0x33, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69,
0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x5f, 0x4e, 0x54, 0x44, 0x45,
0x56, 0x25, 0x32, 0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25, 0x32, 0x30, 0x43, 0x41, 0x28,
0x31, 0x29, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x18, 0x30,
0x16, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x02, 0x06, 0x08, 0x2b,
0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x30, 0x37, 0x06, 0x03, 0x55, 0x1d, 0x11, 0x04, 0x30,
0x30, 0x2e, 0xa0, 0x2c, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x03,
0xa0, 0x1e, 0x0c, 0x1c, 0x64, 0x61, 0x6e, 0x67, 0x72, 0x69, 0x66, 0x66, 0x40, 0x6e, 0x74, 0x64,
0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d,
0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03,
0x81, 0x81, 0x00, 0x92, 0xe6, 0x34, 0x6a, 0x1b, 0x71, 0xe6, 0x91, 0x4a, 0x92, 0x35, 0x00, 0x2d,
0xe3, 0x20, 0x50, 0x68, 0x01, 0x7d, 0x92, 0xe7, 0xc1, 0x5c, 0xfd, 0x13, 0xb5, 0x49, 0x31, 0xc5,
0xc5, 0x0d, 0x5f, 0xa5, 0xf3, 0xa6, 0xd1, 0xb4, 0x28, 0x7b, 0x70, 0xfd, 0x16, 0xd2, 0x60, 0x3a,
0xa9, 0xa5, 0x39, 0x08, 0xed, 0x36, 0x76, 0xa5, 0x44, 0xf3, 0x45, 0x8e, 0x56, 0x63, 0xd6, 0xfe,
0x0e, 0xbd, 0x41, 0xf0, 0xdf, 0x2c, 0xa7, 0xdf, 0x03, 0xda, 0xf0, 0x35, 0x2f, 0x51, 0xab, 0xa3,
0x0d, 0x94, 0xb2, 0x89, 0x12, 0xe0, 0x30, 0x6f, 0xee, 0x1f, 0x09, 0x21, 0xe4, 0x3e, 0x51, 0x4f,
0xf0, 0x4a, 0xb3, 0x30, 0x87, 0xef, 0x7a, 0x49, 0x2f, 0x0e, 0x30, 0x4d, 0xd0, 0xd5, 0x4b, 0xfc,
0x77, 0xac, 0x81, 0xb8, 0xf1, 0x36, 0xfa, 0x9e, 0xbb, 0x35, 0x5b, 0xf7, 0x4a, 0x5f, 0x81, 0x16,
0x98, 0x27, 0xd7
};

#define cbTestCer sizeof(rgbTestCer)

//
// Function: AllocH
//
LPVOID WINAPI AllocH(
    IN SIZE_T cBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cBytes);
}

//
// Function: FreeH
//
void WINAPI FreeH(
    IN LPVOID pMem)
{
    HeapFree(GetProcessHeap(), 0, pMem);
}

//
// Function: PrintBytes
//
#define CROW 8
void PrintBytes(LPSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;
    CHAR rgsz[1024];

    printf("\n  %s, %d bytes ::\n", pszHdr, cbSize);

    while (cbSize > 0)
    {
        // Start every row with an extra space
        printf(" ");

        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i < cb; i++)
            printf(" %02x", pb[i]);
        for (i = cb; i < CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i < cb; i++)
        {
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        }
        printf("\n");
        pb += cb;
    }
}

DWORD TestLogon(void)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hHelperEncryptKey = 0;
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbCertificate = 0;
    PBYTE pbCertificate = NULL;
    DWORD cbSignature = 0;
    PBYTE pbSignature = NULL;
    HCRYPTPROV hHelperProv = 0;
    HCRYPTKEY hPublicKey = 0;
    DWORD cbPublicKey = 0;
    PBYTE pbPublicKey = NULL;
    HCRYPTHASH hHelperHash = 0;
    DWORD cbEncrypted = 0;
    PBYTE pbEncrypted = NULL;
    DWORD cb = 0;
    DWORD cbEncryptedKey = 0;
    PBYTE pbEncryptedKey = NULL;
    HCRYPTKEY hDecryptKey = 0;

    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, 
        L"\\\\.\\Gemplus GemPC430 0\\" /*NULL*/, 
        MS_SCARD_PROV, 
        PROV_RSA_FULL, 
        CRYPT_SILENT | CRYPT_MACHINE_KEYSET));

    CAPI_TEST_CASE(CryptGetUserKey(
        hProv, AT_KEYEXCHANGE, &hKey));
    
    //
    // Get the user logon certificate
    //
    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, NULL, &cbCertificate, 0));

    pbCertificate = AllocH(cbCertificate);

    if (NULL == pbCertificate)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, pbCertificate, &cbCertificate, 0));

    PrintBytes("KP_CERTIFICATE", pbCertificate, cbCertificate);

    //
    // Hash the certificate
    //
    CAPI_TEST_CASE(CryptCreateHash(
        hProv, CALG_MD5, 0, 0, &hHash));

    CAPI_TEST_CASE(CryptHashData(
        hHash, pbCertificate, cbCertificate, 0));

    CAPI_TEST_CASE(CryptSetProvParam(
        hProv, PP_SIGNATURE_PIN, (PBYTE) "0000", 0));

    //
    // Sign the hash
    //
    CAPI_TEST_CASE(CryptSignHash(
        hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &cbSignature))

    pbSignature = AllocH(cbSignature);

    if (NULL == pbSignature)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptSignHash(
        hHash, AT_KEYEXCHANGE, NULL, 0, pbSignature, &cbSignature));

    //
    // Export the public key
    //
    CAPI_TEST_CASE(CryptExportKey(
        hKey, 0, PUBLICKEYBLOB, 0, NULL, &cbPublicKey));

    pbPublicKey = AllocH(cbPublicKey);

    if (NULL == pbPublicKey)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptExportKey(
        hKey, 0, PUBLICKEYBLOB, 0, pbPublicKey, &cbPublicKey));

    //
    // Import the public key into the helper CSP
    //
    CAPI_TEST_CASE(CryptAcquireContext(
        &hHelperProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT));

    CAPI_TEST_CASE(CryptImportKey(
        hHelperProv, pbPublicKey, cbPublicKey, 0, 0, &hPublicKey));

    //
    // Now hash the cert with the helper CSP
    //
    CAPI_TEST_CASE(CryptCreateHash(
        hHelperProv, CALG_MD5, 0, 0, &hHelperHash));

    CAPI_TEST_CASE(CryptHashData(
        hHelperHash, pbCertificate, cbCertificate, 0));

    //
    // Verify the signature on our cert hash
    //
    CAPI_TEST_CASE(CryptVerifySignature(
        hHelperHash, pbSignature, cbSignature, hPublicKey, NULL, 0));

    //
    // Derive a session key from the hash
    //
    CAPI_TEST_CASE(CryptDeriveKey(
        hHelperProv, 
        CALG_3DES, 
        hHelperHash, 
        CRYPT_EXPORTABLE, 
        &hHelperEncryptKey));

    //
    // Encrypt the cert with the session key
    //
    cbEncrypted = cbCertificate;

    CAPI_TEST_CASE(CryptEncrypt(
        hHelperEncryptKey, 0, TRUE, 0, NULL, &cbEncrypted, 0));

    pbEncrypted = AllocH(cbEncrypted);

    if (NULL == pbEncrypted)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    memcpy(
        pbEncrypted,
        pbCertificate,
        cbCertificate);

    cb = cbCertificate;

    CAPI_TEST_CASE(CryptEncrypt(
        hHelperEncryptKey, 0, TRUE, 0, pbEncrypted, &cb, cbEncrypted));

    // 
    // Export the encryption key, encrypted with the public key
    //
    CAPI_TEST_CASE(CryptExportKey(
        hHelperEncryptKey, hPublicKey, SIMPLEBLOB, 0, NULL, &cbEncryptedKey));

    pbEncryptedKey = AllocH(cbEncryptedKey);

    if (NULL == pbEncryptedKey)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptExportKey(
        hHelperEncryptKey, 
        hPublicKey, 
        SIMPLEBLOB, 
        0, 
        pbEncryptedKey, 
        &cbEncryptedKey));

    //
    // Import the encrypted session key into the smartcard CSP, decrypting it
    // with the private key
    //
    CAPI_TEST_CASE(CryptImportKey(
        hProv, pbEncryptedKey, cbEncryptedKey, hKey, 0, &hDecryptKey));

    //
    // Decrypt the encrypted certificate using the session key
    //
    CAPI_TEST_CASE(CryptDecrypt(
        hDecryptKey, 0, TRUE, 0, pbEncrypted, &cbEncrypted));

    //
    // Compare the decrypted certificate with the original
    //
    if (cbCertificate != cbEncrypted ||
        0 != memcmp(pbEncrypted, pbCertificate, cbCertificate))
    {
        printf("ERROR: Decrypted cert doesn't match\n");
        dwSts = -1;
    }

Ret:

    if (pbEncrypted)
        FreeH(pbEncrypted);
    if (pbCertificate)
        FreeH(pbCertificate);
    if (pbEncryptedKey)
        FreeH(pbEncryptedKey);
    if (pbSignature)
        FreeH(pbSignature);
    if (pbPublicKey)
        FreeH(pbPublicKey);

    if (hDecryptKey)
        CryptDestroyKey(hDecryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    if (hPublicKey)
        CryptDestroyKey(hPublicKey);
    if (hHelperEncryptKey)
        CryptDestroyKey(hHelperEncryptKey);
    if (hHash)
        CryptDestroyHash(hHash);
    if (hHelperHash)
        CryptDestroyHash(hHelperHash);

    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (hHelperProv)
        CryptReleaseContext(hHelperProv, 0);

    return dwSts;
}

DWORD CheckCertUsageForDefaultContainer(
    PBYTE pbEncodedCert,
    DWORD cbEncodedCert,
    BOOL *pfMakeDefault)
{
    DWORD dwSts = 0;
    PCCERT_CONTEXT pCertCtx = NULL;
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbUsage = 0;

    *pfMakeDefault = FALSE;

    pCertCtx = CertCreateCertificateContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pbEncodedCert,
        cbEncodedCert);

    if (NULL == pCertCtx)
    {
        dwSts = GetLastError();
        goto Ret;
    }

    if (! CertGetEnhancedKeyUsage(
        pCertCtx,
        0,
        NULL,
        &cbUsage))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    pUsage = (PCERT_ENHKEY_USAGE) AllocH(cbUsage);

    if (NULL == pUsage)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (! CertGetEnhancedKeyUsage(
        pCertCtx,
        0,
        pUsage,
        &cbUsage))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    while (pUsage->cUsageIdentifier)
    {
        pUsage->cUsageIdentifier -= 1;

        if (0 == strcmp(
                szOID_KP_SMARTCARD_LOGON,
                pUsage->rgpszUsageIdentifier[pUsage->cUsageIdentifier]) ||
            0 == strcmp(
                szOID_ENROLLMENT_AGENT,
                pUsage->rgpszUsageIdentifier[pUsage->cUsageIdentifier]))
        {
            *pfMakeDefault = TRUE;
        }
    }

Ret:

    if (pUsage)
        FreeH(pUsage);
    if (pCertCtx)
        CertFreeCertificateContext(pCertCtx);

    return dwSts;
}


DWORD TestEnrollment(void)
{
    HCRYPTPROV hProv = 0;
    DWORD dwSts = 0;
    DWORD dwData = 0;
    DWORD cbData = 0;
    PROV_ENUMALGS_EX EnumalgsEx;
    DWORD dwFlags = 0;
    HCRYPTKEY hKey = 0;
    PBYTE pbData = NULL;
    LPSTR szContainer = NULL;
    LPSTR szName = NULL;
    HCRYPTHASH hHash = 0;
    BOOL fDefault = FALSE;

    memset(&EnumalgsEx, 0, sizeof(EnumalgsEx));

    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT));

    // Used only for enrollment station - filtering for smartcard CSP's
    cbData = sizeof(DWORD);
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_IMPTYPE, (PBYTE) &dwData, &cbData, 0));

    printf(" ImpType: %d\n", dwData);

    cbData = sizeof(DWORD);
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_KEYSPEC, (PBYTE) &dwData, &cbData, 0));

    printf(" Keyspec: %d\n", dwData);

    cbData = sizeof(DWORD);
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_PROVTYPE, (PBYTE) &dwData, &cbData, 0));

    printf(" Provtype: %d\n", dwData);

    cbData = 0;
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_NAME, NULL, &cbData, 0));

    szName = (LPSTR) AllocH(cbData);

    if (NULL == szName)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_NAME, (PBYTE) szName, &cbData, 0));

    printf(" Prov name: %s\n", szName);

    dwFlags = CRYPT_FIRST;
    cbData = sizeof(EnumalgsEx);

    while (CryptGetProvParam(
        hProv, PP_ENUMALGS_EX, (PBYTE) &EnumalgsEx, &cbData, dwFlags))
    {
        printf(" %s\n", EnumalgsEx.szName);
        dwFlags = 0;
    }

    if (ERROR_NO_MORE_ITEMS != (dwSts = GetLastError()))
    {
        if (ERROR_SUCCESS == dwSts)
            dwSts = -1;

        goto Ret;
    }

    dwSts = ERROR_SUCCESS;

    CAPI_TEST_CASE(CryptReleaseContext(hProv, 0));
    hProv = 0;
    
    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET));

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_CONTAINER, NULL, &cbData, 0));

    szContainer = (LPSTR) AllocH(cbData);

    if (NULL == szContainer)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_CONTAINER, (PBYTE) szContainer, &cbData, 0));

    printf(" Container name: %s\n", szContainer);

    FreeH(szContainer);
    szContainer = NULL;

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_UNIQUE_CONTAINER, NULL, &cbData, 0));

    szContainer = (LPSTR) AllocH(cbData);

    if (NULL == szContainer)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_UNIQUE_CONTAINER, (PBYTE) szContainer, &cbData, 0));

    printf(" Unique container: %s\n", szContainer);

    // Eliminate the SetProv step to force the CSP to show pin UI
    /*
    CAPI_TEST_CASE(CryptSetProvParam(
        hProv, PP_SIGNATURE_PIN, (PBYTE) "0000", 0));
        */

    CAPI_TEST_CASE(CryptGenKey(
        hProv, AT_KEYEXCHANGE, 0, &hKey));

    //
    // Test creating and signing a hash
    //
    CAPI_TEST_CASE(CryptCreateHash(
        hProv, CALG_SHA, 0, 0, &hHash));

    CAPI_TEST_CASE(CryptSignHash(
        hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &cbData));

    pbData = AllocH(cbData);

    if (NULL == pbData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptSignHash(
        hHash, AT_KEYEXCHANGE, NULL, 0, pbData, &cbData));

    PrintBytes("Signature blob", pbData, cbData);

    CAPI_TEST_CASE(CryptVerifySignature(
        hHash, pbData, cbData, hKey, NULL, 0));

    CAPI_TEST_CASE(CryptDestroyHash(hHash));
    hHash = 0;

    FreeH(pbData);
    pbData = NULL;

    //
    // Test writing a reading a user certificate
    //

    dwSts = CheckCertUsageForDefaultContainer(
        rgbTestCer,
        sizeof(rgbTestCer),
        &fDefault);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    CAPI_TEST_CASE(CryptSetKeyParam(
        hKey, KP_CERTIFICATE, rgbTestCer, 0));

    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, NULL, &cbData, 0));

    pbData = AllocH(cbData);

    if (NULL == pbData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, pbData, &cbData, 0));

    PrintBytes("KP_CERTIFICATE", pbData, cbData);

    FreeH(pbData);
    pbData = NULL;

    CAPI_TEST_CASE(CryptDestroyKey(hKey));
    hKey = 0;

    //
    // Test exporting a public key
    //
    CAPI_TEST_CASE(CryptGetUserKey(
        hProv, AT_KEYEXCHANGE, &hKey));

    CAPI_TEST_CASE(CryptExportKey(
        hKey, 0, PUBLICKEYBLOB, 0, NULL, &cbData));

    pbData = AllocH(cbData);

    if (NULL == pbData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptExportKey(
        hKey, 0, PUBLICKEYBLOB, 0, pbData, &cbData));

    PrintBytes("PUBLICKEYBLOB", pbData, cbData);

    FreeH(pbData);
    pbData = NULL;

    CAPI_TEST_CASE(CryptDestroyKey(hKey));
    hKey = 0;

Ret:
    if (hHash)
        CryptDestroyHash(hHash);
    if (hKey)
        CryptDestroyKey(hKey);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (pbData)
        FreeH(pbData);
    if (szName)
        FreeH(szName);

    return dwSts;
}

DWORD TestCertPropagation(void)
{
    DWORD dwSts = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    PBYTE pbCert = NULL;
    DWORD cbCert = 0;

    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, 
        /*L"\\\\.\\GemPlus SCR 500\\My Big - long container"*/ NULL, 
        MS_SCARD_PROV, 
        PROV_RSA_FULL, 
        0));

    CAPI_TEST_CASE(CryptGetUserKey(
        hProv, AT_KEYEXCHANGE, &hKey));

    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, NULL, &cbCert, 0));

    pbCert = AllocH(cbCert);

    if (NULL == pbCert)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, pbCert, &cbCert, 0));

    PrintBytes("User Cert", pbCert, cbCert);

Ret:
    if (pbCert)
        FreeH(pbCert);

    return dwSts;
}

DWORD Cleanup(void)
{
    DWORD dwSts = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    CHAR rgszContainer [MAX_PATH];
    DWORD cbContainer = sizeof(rgszContainer);

    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, 0));

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_CONTAINER, (PBYTE) rgszContainer, &cbContainer, 0));

    CAPI_TEST_CASE(CryptReleaseContext(hProv, 0));

    printf("Deleting default container ...\n");

    CAPI_TEST_CASE(CryptAcquireContextA(
        &hProv, rgszContainer, MS_SCARD_PROV_A, PROV_RSA_FULL, CRYPT_DELETEKEYSET));

Ret:

    return dwSts;
}

void DisplayHelp(void)
{
    printf("Usage: scnarios [option]\n");
    printf(" -1 : Test simulated enrollment\n");
    printf(" -2 : Test simulated certificate propagation\n");
    printf(" -3 : Test simulated logon\n");
    printf(" -c : Cleanup (delete default container)\n");
}

int _cdecl main(int argc, char * argv[])
{
    DWORD dwSts = ERROR_SUCCESS;
    BOOL fDisplayHelp = FALSE;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case '1':

                dwSts = TestEnrollment();

                if (ERROR_SUCCESS != dwSts)
                    goto Ret;

                break;

            case '2':

                dwSts = TestCertPropagation();

                if (ERROR_SUCCESS != dwSts)
                    goto Ret;

                break;

            case '3':

                dwSts = TestLogon();

                if (ERROR_SUCCESS != dwSts)
                    goto Ret;

                break;

            case 'c':

                dwSts = Cleanup();

                if (ERROR_SUCCESS != dwSts)
                    goto Ret;

                break;

            case '?':
                fDisplayHelp = TRUE;
                break;

            default:
                printf("Invalid args\n");
                fDisplayHelp = TRUE;
                goto Ret;
            }
        }
    }

Ret:
    
    if (TRUE == fDisplayHelp)
    {
        DisplayHelp();
    }
    else
    {
        if (ERROR_SUCCESS != dwSts)
            printf(" failed, 0x%x\n", dwSts);
        else 
            printf("Success.\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\wpscprox\apiproxy.c ===
/*
** Proxied Application Program Interface (API) for Windows Card
**
*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "MarshalPC.h"
#include "carddbg.h"

LONG WINAPI SCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut);

    // Buffers for APDU exchange
#define MAX_APDU    255

    // Command header helpers
#define CLA(cla)    UINT82XSCM(&phTmp->xSCM, cla, TYPE_NOTYPE_NOCOUNT)
#define INS(ins)    UINT82XSCM(&phTmp->xSCM, ins, TYPE_NOTYPE_NOCOUNT)
#define P1(p1)      UINT82XSCM(&phTmp->xSCM, p1, TYPE_NOTYPE_NOCOUNT)
#define P2(p2)      UINT82XSCM(&phTmp->xSCM, p2, TYPE_NOTYPE_NOCOUNT)
#define Lc(lc)      (phTmp->pbLc = GetSCMCrtPointer(&phTmp->xSCM), UINT82XSCM(&phTmp->xSCM, 0, TYPE_NOTYPE_NOCOUNT))  // We don't know at this time
#define UPDATE_Lc(lc) *phTmp->pbLc = lc


static SCODE ExtractSCODE(LPMYSCARDHANDLE phTmp, LPCBYTE abRAPDU, DWORD dwOut);

//*****************************************************************************
//      EXPORTED API
//*****************************************************************************

/*
** AnA
*/
SCODE WINAPI hScwGetPrincipalUID(SCARDHANDLE hCard, WCSTR principalName, TUID *principalUID)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwGetPrincipalUID);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(2);
        P2(1);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, principalName, phTmp->dwFlags & FLAG_BIGENDIAN);
        UINT8BYREF2XSCM(&phTmp->xSCM, principalUID);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            *principalUID = XSCM2UINT8(&phTmp->xSCM);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}


SCODE WINAPI hScwAuthenticateName(SCARDHANDLE hCard, WCSTR name , BYTE *supportData, TCOUNT supportDataLength) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwAuthenticateName);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(2);
        P2(2);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, name, phTmp->dwFlags & FLAG_BIGENDIAN);
        ByteArray2XSCM(&phTmp->xSCM, supportData, supportDataLength);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = 255;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwAuthenticateUID(SCARDHANDLE hCard, TUID uid, BYTE *supportData, TCOUNT supportDataLength) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwAuthenticateUID);
    
        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(2);
        P2(3);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        UINT82XSCM(&phTmp->xSCM, uid, TYPE_TYPED);
        ByteArray2XSCM(&phTmp->xSCM, supportData, supportDataLength);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwDeauthenticateName(SCARDHANDLE hCard, WCSTR principalName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwDeauthenticateName);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(2);
        P2(4);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, principalName, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwDeauthenticateUID(SCARDHANDLE hCard, TUID uid) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwDeauthenticateUID);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(2);
        P2(5);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
        UINT82XSCM(&phTmp->xSCM, uid, TYPE_TYPED);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwIsAuthenticatedName(SCARDHANDLE hCard, WCSTR principalName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwIsAuthenticatedName);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(2);
        P2(6);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, principalName, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwIsAuthenticatedUID(SCARDHANDLE hCard, TUID uid) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwIsAuthenticatedUID);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(2);
        P2(7);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
        UINT82XSCM(&phTmp->xSCM, uid, TYPE_TYPED);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwIsAuthorized(SCARDHANDLE hCard, WCSTR resourceName, BYTE operation) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwIsAuthorized);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(2);
        P2(8);
        Lc(0);
//      UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
//      UINT82XSCM(&phTmp->xSCM, resourceType, TYPE_TYPED);
        String2XSCM(&phTmp->xSCM, resourceName, phTmp->dwFlags & FLAG_BIGENDIAN);
        UINT82XSCM(&phTmp->xSCM, operation, TYPE_TYPED);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

/*
** File System
*/

SCODE WINAPI hScwCreateFile(SCARDHANDLE hCard, WCSTR fileName, WCSTR aclFileName, HFILE *phFile) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwCreateFile);
    
        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(1);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
        String2XSCM(&phTmp->xSCM, aclFileName, phTmp->dwFlags & FLAG_BIGENDIAN);
        HFILEBYREF2XSCM(&phTmp->xSCM, phFile);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            if (phFile)
                *phFile = XSCM2HFILE(&phTmp->xSCM);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwDeleteFile(SCARDHANDLE hCard, WCSTR fileName) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwDeleteFile);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(2);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwCloseFile(SCARDHANDLE hCard, HFILE hFile) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwCloseFile);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(4);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
        HFILE2XSCM(&phTmp->xSCM, hFile);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE __hScwReadFile(SCARDHANDLE hCard, HFILE hFile, BYTE *buffer, TCOUNT length, TCOUNT *bytesRead)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwReadFile);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(5);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
        HFILE2XSCM(&phTmp->xSCM, hFile);
        ByteArrayOut2XSCM(&phTmp->xSCM, buffer, length);
        UINT8BYREF2XSCM(&phTmp->xSCM, bytesRead);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            BYTE *_pbBuffer;
            UINT8 len;

            len = XSCM2ByteArray(&phTmp->xSCM, &_pbBuffer);
            *bytesRead = XSCM2UINT8(&phTmp->xSCM);
            memcpy(buffer, _pbBuffer, *bytesRead);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwReadFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes)
{
    SCODE ret;
    TCOUNT nNow, nOpt, nRead;
    DWORD nOverall = 0;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
    __try {

        if ((phTmp == NULL) || (pnActualBytes == NULL))
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

            // v1.0 IN: #param | 8 | HFILE | a | L | 108 | Read / OUT: RC | L | Data | Read | SW (already deducted so max = bResLen-10)
            // v1.1 IN: #param | 8 | HFILE | a | L | 108 | Read / OUT: L | Data | Read | SW (already deducted so max = bResLen-9)
        if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
        {
            if (phTmp->bResLen < 10)
                RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
        }
        else if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_1)
        {
            if (phTmp->bResLen < 9)
                RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
        }
        else
            RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

        nOpt = phTmp->bResLen - 9;      // Biggest possible
        if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
            nOpt--;

        do
        {
            nNow = (TCOUNT)((nRequestedBytes - nOverall > nOpt) ? nOpt : nRequestedBytes - nOverall);

            ret = __hScwReadFile(hCard, hFile, pbBuffer+nOverall, nNow, &nRead);

            if (FAILED(ret))
                break;

            nOverall += nRead;
        } while ((nOverall < nRequestedBytes) && (nRead == nNow));

        if (!(FAILED(ret)))
            *pnActualBytes = nOverall;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwReadFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes)
{
    DWORD cbActual;
    SCODE ret;

    if (IsBadWritePtr(pnActualBytes, 1))
        ret = hScwReadFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, NULL);
    else
    {
        ret = hScwReadFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, &cbActual);
        if (!FAILED(ret))
            *pnActualBytes = (TCOUNT)cbActual;
    }
    return ret;
}

SCODE __hScwWriteFile(SCARDHANDLE hCard, HFILE hFile, BYTE *buffer, TCOUNT length, TCOUNT *bytesWritten)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwWriteFile);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(6);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
        HFILE2XSCM(&phTmp->xSCM, hFile);
        ByteArray2XSCM(&phTmp->xSCM, buffer, length);
        UINT8BYREF2XSCM(&phTmp->xSCM, bytesWritten);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            *bytesWritten = XSCM2UINT8(&phTmp->xSCM);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwWriteFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes)
{
    SCODE ret;
    TCOUNT nNow, nOpt, nWritten;
    DWORD nOverall = 0;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
    __try {

        if ((phTmp == NULL) || (pnActualBytes == NULL))
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

            // v1.0 IN: #param | 8 | HFILE | A | L | Data | 108 | Written / OUT: RC | Written | SW (already deducted so max = bResLen-9)
            // v1.1 IN: #param | 8 | HFILE | A | L | Data | 108 | Written / OUT: Written | SW (already deducted so max = bResLen-8)
        if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
        {
            if (phTmp->bResLen < 9)
                RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
        }
        else if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_1)
        {
            if (phTmp->bResLen < 8)
                RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
        }
        else
            RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

        nOpt = phTmp->bResLen - 8;      // Biggest possible
        if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
            nOpt--;

        do
        {
            nNow = (TCOUNT)((nRequestedBytes - nOverall > (TCOUNT)nOpt) ? nOpt : nRequestedBytes - nOverall);

            ret = __hScwWriteFile(hCard, hFile, pbBuffer+nOverall, nNow, &nWritten);

            if (FAILED(ret))
                break;

            nOverall += nWritten;
        } while ((nOverall < nRequestedBytes) && (nWritten == nNow));

        if (!(FAILED(ret)))
            *pnActualBytes = nOverall;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwWriteFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes)
{
    DWORD cbActual;
    SCODE ret;

    if (IsBadWritePtr(pnActualBytes, 1))
        ret = hScwWriteFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, NULL);
    else
    {
        ret = hScwWriteFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, &cbActual);
        if (!FAILED(ret))
            *pnActualBytes = (TCOUNT)cbActual;
    }
    return ret;
}

SCODE WINAPI hScwGetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET *fileSize)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwGetFileLength);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(7);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        HFILE2XSCM(&phTmp->xSCM, hFile);
        UINT16BYREF2XSCM(&phTmp->xSCM, fileSize, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            *fileSize = XSCM2UINT16(&phTmp->xSCM, phTmp->dwFlags & FLAG_BIGENDIAN);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwSetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET fileSize)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwSetFileLength);
    
        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(8);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        HFILE2XSCM(&phTmp->xSCM, hFile);
        UINT162XSCM(&phTmp->xSCM, fileSize, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwSetFilePointer(SCARDHANDLE hCard, HFILE hFile, INT16 offset, BYTE mode)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwSetFilePointer);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(9);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
        HFILE2XSCM(&phTmp->xSCM, hFile);
        UINT162XSCM(&phTmp->xSCM, (UINT16)offset, phTmp->dwFlags & FLAG_BIGENDIAN);
        UINT82XSCM(&phTmp->xSCM, mode, TYPE_TYPED);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwGetFileAttributes(SCARDHANDLE hCard, WCSTR fileName, UINT16 *attributeValue) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwGetFileAttributes);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(11);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
        UINT16BYREF2XSCM(&phTmp->xSCM, attributeValue, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            *attributeValue = XSCM2UINT16(&phTmp->xSCM, phTmp->dwFlags & FLAG_BIGENDIAN);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwSetFileAttributes(SCARDHANDLE hCard, WCSTR fileName, UINT16 attributeValue) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwSetFileAttributes);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(12);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
        UINT162XSCM(&phTmp->xSCM, attributeValue, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwSetFileACL(SCARDHANDLE hCard, WCSTR fileName, WCSTR aclFileName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwSetFileACL);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(13);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
        String2XSCM(&phTmp->xSCM, aclFileName, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwGetFileAclHandle(SCARDHANDLE hCard, WCSTR fileName, HFILE *phFile)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwGetFileAclHandle);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(14);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
        HFILEBYREF2XSCM(&phTmp->xSCM, phFile);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            if (phFile)
                *phFile = XSCM2HFILE(&phTmp->xSCM);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwEnumFile(SCARDHANDLE hCard, WCSTR directoryName, UINT16 *fileCookie, WSTR fileName, TCOUNT fileNameLength) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwEnumFile);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(15);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, directoryName, phTmp->dwFlags & FLAG_BIGENDIAN);
        UINT16BYREF2XSCM(&phTmp->xSCM, fileCookie, phTmp->dwFlags & FLAG_BIGENDIAN);
        StringOut2XSCM(&phTmp->xSCM, fileName, fileNameLength, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            WCSTR wsz;
            UINT8 len;

            *fileCookie = XSCM2UINT16(&phTmp->xSCM, phTmp->dwFlags & FLAG_BIGENDIAN);
            wsz = XSCM2String(&phTmp->xSCM, &len, phTmp->dwFlags & FLAG_BIGENDIAN);
            if (len > fileNameLength)
                ret = SCW_E_BUFFERTOOSMALL;
            else
                wcscpy(fileName, wsz);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwCreateDirectory(SCARDHANDLE hCard, WCSTR fileName, WCSTR aclFileName) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwCreateDirectory);
    
        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(16);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
        String2XSCM(&phTmp->xSCM, aclFileName, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwSetDispatchTable(SCARDHANDLE hCard, WCSTR wszFileName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwSetDispatchTable);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(3);
        P2(17);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, wszFileName, phTmp->dwFlags & FLAG_BIGENDIAN);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}


/*
** Cryptography
*/

SCODE WINAPI hScwCryptoInitialize(SCARDHANDLE hCard, BYTE mechanism, BYTE *key)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    TCOUNT len = 0;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwCryptoInitialize);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(5);
        P2(1);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        UINT82XSCM(&phTmp->xSCM, mechanism, TYPE_TYPED);

        if (key)
            len = 2 + key[1];   // T+L+V
        ByteArray2XSCM(&phTmp->xSCM, key, len);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            phTmp->byCryptoM = mechanism;       // Store the last mechanism for 1024 hack
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwCryptoAction(SCARDHANDLE hCard, BYTE *dataIn, TCOUNT dataInLength, BYTE *dataOut, TCOUNT *dataOutLength)
{
    BOOL fHack = FALSE;
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwCryptoAction);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        if ((((phTmp->byCryptoM & CM_CRYPTO_NAME) == CM_RSA) || ((phTmp->byCryptoM & CM_CRYPTO_NAME) == CM_RSA_CRT)) &&
            ((phTmp->byCryptoM & CM_DATA_INFILE) != CM_DATA_INFILE))
        {                               // Hack for 1024 RSA
            P1(0xFE);
            P2(0);
            Lc(0);
            ByteArray2XSCM(&phTmp->xSCM, dataIn, dataInLength);
            if (dataOutLength == NULL)
                RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);
            abCAPDU[5] = *dataOutLength;
            fHack = TRUE;
        }
        else
        {
            P1(5);
            P2(2);
            Lc(0);
            UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
            ByteArray2XSCM(&phTmp->xSCM, dataIn, dataInLength);
            ByteArrayOut2XSCM(&phTmp->xSCM, dataOut, (TCOUNT)(dataOutLength == 0 ? 0 : *dataOutLength));
            UINT8BYREF2XSCM(&phTmp->xSCM, dataOutLength);
        }

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            BYTE *pb;
            TCOUNT len;

            len = XSCM2ByteArray(&phTmp->xSCM, &pb);
            if (len > *dataOutLength)
                ret = SCW_E_BUFFERTOOSMALL;
            else
            {
                memcpy(dataOut, pb, len);
                if (fHack)
                    *dataOutLength = len;
                else
                    *dataOutLength = XSCM2UINT8(&phTmp->xSCM);
            }
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwCryptoUpdate(SCARDHANDLE hCard, BYTE *dataIn, TCOUNT dataInLength)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwCryptoUpdate);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(5);
        P2(3);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
        ByteArray2XSCM(&phTmp->xSCM, dataIn, dataInLength);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwCryptoFinalize(SCARDHANDLE hCard, BYTE *dataOut, TCOUNT *dataOutLength)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwCryptoFinalize);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(5);
        P2(4);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        ByteArrayOut2XSCM(&phTmp->xSCM, dataOut, (TCOUNT)(dataOutLength == 0 ? 0 : *dataOutLength));
        UINT8BYREF2XSCM(&phTmp->xSCM, dataOutLength);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            BYTE *pb;
            TCOUNT len;

            len = XSCM2ByteArray(&phTmp->xSCM, &pb);
            if (len > *dataOutLength)
                ret = SCW_E_BUFFERTOOSMALL;
            else
            {
                memcpy(dataOut, pb, len);
                *dataOutLength = XSCM2UINT8(&phTmp->xSCM);
            }
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

SCODE WINAPI hScwGenerateRandom(SCARDHANDLE hCard, BYTE *dataOut, TCOUNT dataOutLength)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwGenerateRandom);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(5);
        P2(5);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
        ByteArrayOut2XSCM(&phTmp->xSCM, dataOut, dataOutLength);
        UINT8BYREF2XSCM(&phTmp->xSCM, &dataOutLength);

            // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
            BYTE *pb;
            TCOUNT len;

            len = XSCM2ByteArray(&phTmp->xSCM, &pb);
            if (len != dataOutLength)
                ret = SCW_E_BUFFERTOOSMALL;
            else
                memcpy(dataOut, pb, len);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

 
/*
** Runtime Environment
*/

SCODE WINAPI hScwRTEExecute(SCARDHANDLE hCard, WCSTR wszCodeFileName, WCSTR wszDataFileName, UINT8 bRestart)
{
    SCODE ret;
    DWORD dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwRTEExecute);

        // Marshaling
    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
            return SCW_E_NOTIMPLEMENTED;

        InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
        CLA(0x00);
        INS(phTmp->byINS);
        P1(1);
        P2(1);
        Lc(0);
        UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
        String2XSCM(&phTmp->xSCM, wszCodeFileName, phTmp->dwFlags & FLAG_BIGENDIAN);
        String2XSCM(&phTmp->xSCM, wszDataFileName, phTmp->dwFlags & FLAG_BIGENDIAN);
        UINT82XSCM(&phTmp->xSCM, bRestart, TYPE_TYPED);

        // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
            ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

            // Parameters UnMarshaling
        if (ret == S_OK)
        {
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}


/*
    ScwExecute:
        I-: lpxHdr (points to 4 bytes (CLA, INS, P1, P2))
        I-: InBuf (Incoming data from card's perspective (NULL -> no data in))
        I-: InBufLen (length of data pointed by InBuf)
        -O: OutBuf (Buffer that will receive the R-APDU (NULL -> no expected data))
        IO: pOutBufLen (I -> Size of OutBuf, O -> Number of bytes written in OutBuf)
        -O: pwSW (Card Status Word)
*/
SCODE WINAPI hScwExecute(SCARDHANDLE hCard, LPISO_HEADER lpxHdr, BYTE *InBuf, TCOUNT InBufLen, BYTE *OutBuf, TCOUNT *pOutBufLen, UINT16 *pwSW)
{
    SCODE ret;
    DWORD dwIn, dwOut, dwRet;
    BYTE abCAPDU[5+MAX_APDU];
    BYTE abRAPDU[MAX_APDU];
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwExecute);

    __try {

        if ((lpxHdr == NULL) || (pwSW == NULL) || ((OutBuf != NULL) && (pOutBufLen == NULL)))
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        abCAPDU[0] = lpxHdr->CLA;
        abCAPDU[1] = lpxHdr->INS;
        abCAPDU[2] = lpxHdr->P1;
        abCAPDU[3] = lpxHdr->P2;
        if ((InBuf != NULL) && (InBufLen != 0))
        {
            abCAPDU[4] = (BYTE)InBufLen;
            memcpy(abCAPDU+5, InBuf, InBufLen);
            dwIn = 5 + InBufLen;

            // We don't care about out data yet
        }
        else
        {   // No in data. How much data out then?

            dwIn = 5;
            if (OutBuf == NULL)     // No data out either
            {
                abCAPDU[4] = 0;
                if (phTmp->dwProtocol == SCARD_PROTOCOL_T0)
                    dwIn = 4;       // To indicate a case 1 command
            }
            else
                abCAPDU[4] = (BYTE)(*pOutBufLen);
        }

        // API transfer
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, dwIn, abRAPDU, &dwOut);

        if (dwRet == 0)
        {
            if (dwOut < 2)
                ret = SCARD_F_INTERNAL_ERROR;
            else
            {
                *pwSW = MAKEWORD(abRAPDU[dwOut-1], abRAPDU[dwOut-2]);
                dwOut -= 2;

                ret = 0;
                if (OutBuf != NULL)
                {
                    if (dwOut <= (DWORD)(*pOutBufLen))
                    {
                        memcpy(OutBuf, abRAPDU, dwOut);
                        *pOutBufLen = (TCOUNT)dwOut;
                    }
                    else
                        ret = SCW_E_BUFFERTOOSMALL;
                }
            }
        }
        else
            ret = (SCODE)dwRet;

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = SCW_E_INVALIDPARAM;
            break;

        case STATUS_INSUFFICIENT_MEM:
            ret = SCW_E_CANTMARSHAL;
            break;

        case STATUS_INTERNAL_ERROR:
            ret = SCARD_F_INTERNAL_ERROR;
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

static SCODE ExtractSCODE(LPMYSCARDHANDLE phTmp, LPCBYTE abRAPDU, DWORD dwOut)
{
    if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
    {
        if ((dwOut < 2) || (abRAPDU[dwOut-2] != 0x90) || (abRAPDU[dwOut-1] != 0x00))
            RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

        InitXSCM(phTmp, abRAPDU, (WORD)(dwOut-2));  // Doesn't take SW into account
        return XSCM2SCODE(&phTmp->xSCM);
    }
    else if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_1)
    {
        if ((dwOut < 2) || (abRAPDU[dwOut-2] != 0x90))
            RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

        InitXSCM(phTmp, abRAPDU, (WORD)(dwOut-2));  // Doesn't take SW into account
        return MAKESCODE(abRAPDU[dwOut-1]);
    }
    else
        RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

    return SCW_S_OK;    // to please the compiler
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\wpscprox\marshalpc.h ===
#ifndef _MARSHAL_H_DEF
#define _MARSHAL_H_DEF

    // Card SCODEs are 8 bits with msb meaning error
    // Win32 SCODEs are 32 bits with msb meaning error
#define MAKESCODE(r) ((SCODE)((((r) & 0x80) != 0) ? (r) | 0xC0000000L : (r)))

#include "wpscproxy.h"

    // Smart Card Marshaling structure
typedef struct {
    WORD wGenLen;       // Size of the generated buffer
    WORD wExpLen;       // Size of the expanded buffer (after unmarshaling in the card)
    WORD wResLen;       // Size of the reserved buffer (as returned by the card)
    BYTE *pbBuffer;     // Pointer where the next argument will be added
} XSCM;

typedef XSCM *LPXSCM;

#define FLAG_REALPCSC   0
#define FLAG_FAKEPCSC   1
#define FLAG_NOT_PCSC   2
#define FLAG_MASKPCSC   1   // To get the PC/SC index in the array below
#define FLAG_TYPEPCSC   3   // To get the PC/SC type

#define FLAG_BIGENDIAN  0x80000000L
#define FLAG_MY_ATTACH  0x40000000L
#define FLAG_ISPROXY    0x20000000L

#define FLAG_MASKVER    0x00FF0000L
#define FLAG2VERSION(dw)    ((dw)&FLAG_MASKVER)
#define VERSION_1_0     0x00100000L
#define VERSION_1_1     0x00110000L

typedef struct {
    SCARDCONTEXT hCtx;      // Associated ResMgr context
    SCARDHANDLE hCard;      // Associated PC/SC card handle 
    DWORD dwFlags;          // 
    DWORD dwProtocol;
    LPFNSCWTRANSMITPROC lpfnTransmit;
    BYTE bResLen;           // Reserved length in TheBuffer in the card
    BYTE *pbLc;             // Stores Crt SCM pointer for future update
    XSCM xSCM;
    BYTE byINS;             // INS to be used for proxy
    BYTE byCryptoM;         // Last Crypto mechanism
} MYSCARDHANDLE;

typedef MYSCARDHANDLE *LPMYSCARDHANDLE;

//
// Copies the current SCARDHANDLE, owned by the caller, into the proxy 
// MYSCARDHANDLE context structure.  This is necessary in case the original
// SCARDHANDLE used to connect has become invalid and subsequently reconnected.
//
static void ProxyUpdateScardHandle(
    IN SCARDHANDLE hProxy,
    IN SCARDHANDLE hScardHandle)
{
    ((LPMYSCARDHANDLE) hProxy)->hCard = hScardHandle;
}


    // Raisable exceptions
#define STATUS_INSUFFICIENT_MEM     0xE0000001
#define STATUS_INVALID_PARAM        0xE0000002
#define STATUS_NO_SERVICE           0xE0000003
#define STATUS_INTERNAL_ERROR       0xE0000004

    // len will set wResLen in the above structure
    // If wExpLen gets bigger than wResLen, an exception will be generated (marshaling)
    // If wResLen indicates that the buffer cannot hold the parameter, an exception
    // will be raised too (unmarshaling)
void InitXSCM(LPMYSCARDHANDLE phTmp, const BYTE *pbBuffer, WORD len);

    // Generated buffer length
WORD GetSCMBufferLength(LPXSCM pxSCM);
BYTE *GetSCMCrtPointer(LPXSCM pxSCM);

    // Extraction of data from the returned buffer (PC unmarshaling)
    // helper functions
SCODE XSCM2SCODE(LPXSCM pxSCM);
UINT8 XSCM2UINT8(LPXSCM pxSCM);
HFILE XSCM2HFILE(LPXSCM pxSCM);
UINT16 XSCM2UINT16(LPXSCM pxSCM, BOOL fBigEndian);
WCSTR XSCM2String(LPXSCM pxSCM, UINT8 *plen, BOOL fBigEndian);
TCOUNT XSCM2ByteArray(LPXSCM pxSCM, UINT8 **ppb);

    // Laying out of data in the buffer to be sent (PC marshaling)
    // helper functions
#define TYPE_NOTYPE_NOCOUNT     0       // Not prefixed with type, not data
#define TYPE_TYPED              1       // Prefixed with type (always counts)
#define TYPE_NOTYPE_COUNT       2       // Not prefixed with type, but is data

void UINT82XSCM(LPXSCM pxSCM, UINT8 val, int type);
void HFILE2XSCM(LPXSCM pxSCM, HFILE val);
void UINT162XSCM(LPXSCM pxSCM, UINT16 val, BOOL fBigEndian);
void ByteArray2XSCM(LPXSCM pxSCM, const BYTE *pbBuffer, TCOUNT len);
void String2XSCM(LPXSCM pxSCM, WCSTR wsz, BOOL fBigEndian);
void SW2XSCM(LPXSCM pxSCM, UINT16 wSW);
void UINT8BYREF2XSCM(LPXSCM pxSCM, UINT8 *val);
void HFILEBYREF2XSCM(LPXSCM pxSCM, HFILE *val);
void UINT16BYREF2XSCM(LPXSCM pxSCM, UINT16 *val, BOOL fBigEndian);
void ByteArrayOut2XSCM(LPXSCM pxSCM, BYTE *pb, TCOUNT len);
void StringOut2XSCM(LPXSCM pxSCM, WSTR wsz, TCOUNT len, BOOL fBigEndian);
void NULL2XSCM(LPXSCM pxSCM);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\wpscprox\transmit.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "MarshalPC.h"
#include <tchar.h>
#include "carddbg.h"

#if (!defined(UNICODE) && !defined(_UNICODE))
#define SCARDSTATUS "SCardStatusA"
#define GETOPENCARDNAME "GetOpenCardNameA"
#else
#define SCARDSTATUS "SCardStatusW"
#define GETOPENCARDNAME "GetOpenCardNameW"
#endif

typedef LONG (WINAPI *LPFNSCARDESTABLISHCONTEXT)(DWORD, LPCVOID, LPCVOID, LPSCARDCONTEXT);
typedef LONG (WINAPI *LPFNSCARDSTATUS)(SCARDHANDLE, LPTSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef LONG (WINAPI *LPFNGETOPENCARDNAME)(LPOPENCARDNAME);
typedef LONG (WINAPI *LPFNSCARDTRANSMIT)(SCARDHANDLE, LPCSCARD_IO_REQUEST, LPCBYTE, DWORD, LPSCARD_IO_REQUEST, LPBYTE, LPDWORD);
typedef LONG (WINAPI *LPFNDISCONNECT)(SCARDHANDLE, DWORD);
typedef LONG (WINAPI *LPFNSCARDRELEASECONTEXT)(SCARDCONTEXT);
typedef LONG (WINAPI *LPFNSCARDBEGINTRANSACTION)(SCARDHANDLE);
typedef LONG (WINAPI *LPFNSCARDENDTRANSACTION)(SCARDHANDLE, DWORD);

typedef struct {
    HINSTANCE hPCSCInst;        // winscard
    HINSTANCE hPCSCInst2;       // scarddlg
    LPFNSCARDESTABLISHCONTEXT lpfnEstablish;
    LPFNGETOPENCARDNAME lpfnOpenCard;
    LPFNSCARDSTATUS lpfnStatus;
    LPFNSCARDTRANSMIT lpfnSCardTransmit;
    LPFNDISCONNECT lpfnDisconnect;
    LPFNSCARDRELEASECONTEXT lpfnRelease;
    LPFNSCARDBEGINTRANSACTION lpfnSCardBeginTransaction;
    LPFNSCARDENDTRANSACTION lpfnSCardEndTransaction;
} PCSC_CTX;

#define REAL_PCSC   0
#define FAKE_PCSC   1

static PCSC_CTX axCtx[2] =  // Array of contexts for each PC/SC
{
    {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
};

static LONG _GetCardHandle(LPCWSTR mszCardNames, LPMYSCARDHANDLE phCard);
static LONG WINAPI _MySCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut);
    // bEnd = 0 -> LITTLE_ENDIAN ; otherwise -> BIG_ENDIAN
static LONG WINAPI hScwSetEndianness(SCARDHANDLE hCard, BOOL bEnd);

#define MAX_NAME 256


SCODE WINAPI hScwAttachToCard(SCARDHANDLE hCard, LPCWSTR mszCardNames, LPSCARDHANDLE phCard)
{
    return hScwAttachToCardEx(hCard, mszCardNames, 0x00, phCard);
}

SCODE WINAPI hScwAttachToCardEx(SCARDHANDLE hCard, LPCWSTR mszCardNames, BYTE byINS, LPSCARDHANDLE phCard)
{
    LPMYSCARDHANDLE phTmp = NULL;
    SCODE ret = SCARD_S_SUCCESS;

    LOG_BEGIN_PROXY(hScwAttachToCardEx);

    __try {

        if (phCard == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        phTmp = (LPMYSCARDHANDLE)HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, sizeof(MYSCARDHANDLE));

        if ((hCard == (SCARDHANDLE)NULL) && (mszCardNames == NULL)) // No PC/SC
        {
            phTmp->dwFlags = FLAG_NOT_PCSC;
            *phCard = (SCARDHANDLE)phTmp;
            return ret;
        }

        if ((hCard == (SCARDHANDLE)NULL) || (mszCardNames == NULL)) // real PC/SC
        {
                // In this case we will be using PC/SC so we init the structure
            if (axCtx[REAL_PCSC].hPCSCInst == NULL)
            {
                axCtx[REAL_PCSC].hPCSCInst = LoadLibrary(_T("winscard.dll"));
                axCtx[REAL_PCSC].hPCSCInst2 = LoadLibrary(_T("scarddlg.dll"));
            }

            if ((axCtx[REAL_PCSC].hPCSCInst == NULL) || (axCtx[REAL_PCSC].hPCSCInst2 == NULL))
                RaiseException(STATUS_NO_SERVICE, 0, 0, 0);

            if (axCtx[REAL_PCSC].lpfnEstablish == NULL)
            {
                // Set all calls to DLL once and for all
                axCtx[REAL_PCSC].lpfnEstablish = (LPFNSCARDESTABLISHCONTEXT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardEstablishContext");
                if (axCtx[REAL_PCSC].lpfnEstablish == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[REAL_PCSC].lpfnOpenCard = (LPFNGETOPENCARDNAME)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst2, GETOPENCARDNAME);
                if (axCtx[REAL_PCSC].lpfnOpenCard == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[REAL_PCSC].lpfnStatus = (LPFNSCARDSTATUS)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, SCARDSTATUS);
                if (axCtx[REAL_PCSC].lpfnStatus == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[REAL_PCSC].lpfnSCardTransmit = (LPFNSCARDTRANSMIT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardTransmit");
                if (axCtx[REAL_PCSC].lpfnSCardTransmit == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[REAL_PCSC].lpfnDisconnect = (LPFNDISCONNECT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardDisconnect");
                if (axCtx[REAL_PCSC].lpfnDisconnect == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[REAL_PCSC].lpfnRelease = (LPFNSCARDRELEASECONTEXT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardReleaseContext");
                if (axCtx[REAL_PCSC].lpfnRelease == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[REAL_PCSC].lpfnSCardBeginTransaction = (LPFNSCARDBEGINTRANSACTION)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardBeginTransaction");
                if (axCtx[REAL_PCSC].lpfnSCardBeginTransaction == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[REAL_PCSC].lpfnSCardEndTransaction = (LPFNSCARDENDTRANSACTION)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardEndTransaction");
                if (axCtx[REAL_PCSC].lpfnSCardEndTransaction == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
            }

            phTmp->dwFlags = FLAG_REALPCSC;

        }
        else if ((hCard == NULL_TX) || (mszCardNames == NULL_TX_NAME)) // PC/SC for simulator
        {
                // In this case we will be using PC/SC so we init the structure
            if (axCtx[FAKE_PCSC].hPCSCInst == NULL)
            {
                axCtx[FAKE_PCSC].hPCSCInst = LoadLibrary(_T("scwwinscard.dll"));
                axCtx[FAKE_PCSC].hPCSCInst2 = axCtx[FAKE_PCSC].hPCSCInst;
            }

            if (axCtx[FAKE_PCSC].hPCSCInst == NULL)
                RaiseException(STATUS_NO_SERVICE, 0, 0, 0);

            if (axCtx[FAKE_PCSC].lpfnEstablish == NULL)
            {
                // Set all calls to DLL once and for all
                axCtx[FAKE_PCSC].lpfnEstablish = (LPFNSCARDESTABLISHCONTEXT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardEstablishContext");
                if (axCtx[FAKE_PCSC].lpfnEstablish == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[FAKE_PCSC].lpfnOpenCard = (LPFNGETOPENCARDNAME)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst2, GETOPENCARDNAME);
                if (axCtx[FAKE_PCSC].lpfnOpenCard == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[FAKE_PCSC].lpfnStatus = (LPFNSCARDSTATUS)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, SCARDSTATUS);
                if (axCtx[FAKE_PCSC].lpfnStatus == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[FAKE_PCSC].lpfnSCardTransmit = (LPFNSCARDTRANSMIT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardTransmit");
                if (axCtx[FAKE_PCSC].lpfnSCardTransmit == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[FAKE_PCSC].lpfnDisconnect = (LPFNDISCONNECT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardDisconnect");
                if (axCtx[FAKE_PCSC].lpfnDisconnect == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[FAKE_PCSC].lpfnRelease = (LPFNSCARDRELEASECONTEXT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardReleaseContext");
                if (axCtx[FAKE_PCSC].lpfnRelease == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[FAKE_PCSC].lpfnSCardBeginTransaction = (LPFNSCARDBEGINTRANSACTION)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardBeginTransaction");
                if (axCtx[FAKE_PCSC].lpfnSCardBeginTransaction == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
                axCtx[FAKE_PCSC].lpfnSCardEndTransaction = (LPFNSCARDENDTRANSACTION)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardEndTransaction");
                if (axCtx[FAKE_PCSC].lpfnSCardEndTransaction == NULL)
                    RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
            }

            phTmp->dwFlags = FLAG_FAKEPCSC;
        }
        else
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if ((hCard == (SCARDHANDLE)NULL) || (hCard == NULL_TX)) // Dialog wanted
        {
            phTmp->dwFlags |= FLAG_MY_ATTACH;
            ret = (SCODE)_GetCardHandle(mszCardNames, phTmp);
        }
        else
            phTmp->hCard = hCard;

            // Get the protocol
        if (ret == SCARD_S_SUCCESS)
        {
            DWORD dwLenReader, dwState, dwATRLength;
            BYTE abyATR[32];
            TCHAR wszReader[MAX_NAME];

            dwLenReader = MAX_NAME;
            dwATRLength = 32;
            ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnStatus)(
                phTmp->hCard,
                wszReader,
                &dwLenReader,
                &dwState,
                &phTmp->dwProtocol,
                abyATR,
                &dwATRLength);

                // Set the default callback because we are in PC/SC config here
            if (ret == SCARD_S_SUCCESS)
            {
                phTmp->byINS = byINS;
                ret = hScwSetTransmitCallback((SCARDHANDLE)phTmp, _MySCWTransmit);
                if (ret == SCARD_S_SUCCESS)
                    *phCard = (SCARDHANDLE)phTmp;
            }
            else
                RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);
        }
        else
            RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        if (phTmp)
            HeapFree(GetProcessHeap(), 0, phTmp);

        if (ret == SCARD_S_SUCCESS)
        {
            switch(GetExceptionCode())
            {
            case STATUS_INVALID_PARAM:
                ret = MAKESCODE(SCW_E_INVALIDPARAM);
                break;

            case STATUS_NO_MEMORY:
            case STATUS_ACCESS_VIOLATION:
                ret = MAKESCODE(SCW_E_BUFFERTOOSMALL);
                break;

            case STATUS_NO_SERVICE:
                ret = SCARD_E_NO_SERVICE;
                break;

            default:
                ret = SCARD_F_UNKNOWN_ERROR;
            }
        }       // Otherwise ret was set already
    }

    return ret;
}

SCODE WINAPI hScwDetachFromCard(SCARDHANDLE hCard)
{
    SCODE ret = SCARD_S_SUCCESS;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwDetachFromCard);

    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if (phTmp->dwFlags & FLAG_MY_ATTACH)
        {
            (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnDisconnect)(phTmp->hCard, SCARD_LEAVE_CARD);
            (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnRelease)(phTmp->hCtx);
        }

        HeapFree(GetProcessHeap(), 0, phTmp);

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = MAKESCODE(SCW_E_INVALIDPARAM);
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

static LONG WINAPI hScwSetEndianness(SCARDHANDLE hCard, BOOL bEnd)
{
    SCODE ret = SCARD_S_SUCCESS;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    LOG_BEGIN_PROXY(hScwSetEndianness);

    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if (bEnd)
            phTmp->dwFlags |= FLAG_BIGENDIAN;
        else
            phTmp->dwFlags &= ~FLAG_BIGENDIAN;

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = MAKESCODE(SCW_E_INVALIDPARAM);
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

    // This is the right time to get proxy information
    // Is proxy supported, what's the endianness and the buffer size
SCODE WINAPI hScwSetTransmitCallback(SCARDHANDLE hCard, LPFNSCWTRANSMITPROC lpfnProc)
{
    SCODE ret = SCARD_S_SUCCESS;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    __try {

        if ((phTmp == NULL) || (lpfnProc == NULL))
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        phTmp->lpfnTransmit = lpfnProc;

                // Get the proxy info
        {
            ISO_HEADER xHdr;
            BYTE rgData[] = {2, 108, 0, 116, 0, 0}; // 2 param, 0 as UINT8 by ref, 0 as UINT16 by ref
            BYTE rgRes[1+1+2];  // RetCode + Endianness + TheBuffer size
            TCOUNT OutLen = sizeof(rgRes);
            UINT16 wSW;

            xHdr.CLA = 0;
            xHdr.INS = phTmp->byINS;
            xHdr.P1 = 0xFF;     // Get proxy config
            xHdr.P2 = 0x00;
            ret = hScwExecute(hCard, &xHdr, rgData, sizeof(rgData), rgRes, &OutLen, &wSW);
            if (SCARD_S_SUCCESS == ret)
            {       // Status OK & expected length & RC=SCW_S_OK
                if ((wSW == 0x9000) && (OutLen == sizeof(rgRes)) && (rgRes[0] == 0))    // Version 1.0
                {
                    hScwSetEndianness(hCard, rgRes[1]);
                    if (rgRes[1] == 0)  // LITTLE_ENDIAN
                        phTmp->bResLen = rgRes[2] - 2;      // SW!!!
                    else
                        phTmp->bResLen = rgRes[3] - 2;      // SW!!!

                    phTmp->dwFlags |= FLAG_ISPROXY;
                    phTmp->dwFlags |= VERSION_1_0;
                }
                else if ((wSW == 0x9011) && (OutLen == sizeof(rgRes) - 1))  // Version 1.1
                {
                    hScwSetEndianness(hCard, rgRes[0]);
                    if (rgRes[0] == 0)  // LITTLE_ENDIAN
                        phTmp->bResLen = rgRes[1] - 2;      // SW!!!
                    else
                        phTmp->bResLen = rgRes[2] - 2;      // SW!!!

                    phTmp->dwFlags |= FLAG_ISPROXY;
                    phTmp->dwFlags |= VERSION_1_1;
                }
                // else there will be no proxy support but you can still use the Dll
            }
            else    // There will be no proxy support though but you can still use the Dll
                ret = SCARD_S_SUCCESS;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = MAKESCODE(SCW_E_INVALIDPARAM);
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

LONG WINAPI SCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut)
{
    SCODE ret = SCARD_S_SUCCESS;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        DebugPrintBytes(L"bytes transmitted", (PBYTE) lpbIn, dwIn);

        ret = (*phTmp->lpfnTransmit)(hCard, lpbIn, dwIn, lpBOut, pdwOut);

        if (NULL != pdwOut)
            DebugPrintBytes(L"bytes received", lpBOut, *pdwOut);

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = MAKESCODE(SCW_E_INVALIDPARAM);
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

const SCARD_IO_REQUEST
    g_xIORT0 = { SCARD_PROTOCOL_T0, sizeof(SCARD_IO_REQUEST) },
    g_xIORT1 = { SCARD_PROTOCOL_T1, sizeof(SCARD_IO_REQUEST) };

static LONG WINAPI _MySCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut)
{
    SCARD_IO_REQUEST xIOR;
    LONG ret = SCARD_S_SUCCESS;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    __try {

        if (phTmp == NULL)
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

        if (phTmp->dwProtocol == SCARD_PROTOCOL_T1)
        {
            memcpy(&xIOR, &g_xIORT1, sizeof(xIOR));
            ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardTransmit)(phTmp->hCard,
                &xIOR, lpbIn, dwIn,
                &xIOR, lpBOut, pdwOut);
        }
        else
        {
            DWORD dwOut = *pdwOut;

            memcpy(&xIOR, &g_xIORT0, sizeof(xIOR));

            __try {

                ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardBeginTransaction)(phTmp->hCard);

                if (ret == SCARD_S_SUCCESS)
                {
                    ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardTransmit)(phTmp->hCard,
                        &xIOR, lpbIn, dwIn,
                        &xIOR, lpBOut, &dwOut);
                }

                if (ret == SCARD_S_SUCCESS)
                {
                    if ((dwOut == 2) && ((lpBOut[0] == 0x61) || (lpBOut[0] == 0x9F)))
                    {
                        BYTE abGR[] = {0x00, 0xC0, 0x00, 0x00, 0x00};

                        abGR[4] = lpBOut[1];
                        ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardTransmit)(phTmp->hCard,
                            &xIOR, abGR, 5,
                            &xIOR, lpBOut, pdwOut);
                    }
                    else
                        *pdwOut = dwOut;
                }
            }
            __finally
            {
                (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardEndTransaction)(phTmp->hCard, SCARD_LEAVE_CARD);
            }
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        switch(GetExceptionCode())
        {
        case STATUS_INVALID_PARAM:
            ret = MAKESCODE(SCW_E_INVALIDPARAM);
            break;

        default:
            ret = SCARD_F_UNKNOWN_ERROR;
        }
    }

    return ret;
}

static TCHAR lpstrGroupNames[] = _TEXT("SCard$DefaultReaders\0");

static LONG _GetCardHandle(LPCWSTR mszCardNames, LPMYSCARDHANDLE phCard)
{
    LONG lRes;
    OPENCARDNAME xOCN;
    TCHAR wszReader[MAX_NAME];
    TCHAR wszCard[MAX_NAME];
    TCHAR wszCN[MAX_NAME];

    DWORD len;
    LPCWSTR lpwstr = mszCardNames;
    LPTSTR lpstrCardNames = wszCN;
    xOCN.nMaxCardNames = 0;

#if (!defined(UNICODE) && !defined(_UNICODE))
    while (*lpwstr)
    {
        wsprintf(lpstrCardNames, "%S", lpwstr); // Conversion
        len = wcslen(lpwstr) + 1;       // Add the trailing 0
        xOCN.nMaxCardNames += len;
        lpwstr += len;
        lpstrCardNames += len;
    }
#else
    while (*lpwstr)
    {
        wcscpy(lpstrCardNames, lpwstr);
        len = wcslen(lpwstr) + 1;       // Add the trailing 0
        xOCN.nMaxCardNames += len;
        lpwstr += len;
        lpstrCardNames += len;
    }
#endif
    xOCN.nMaxCardNames++;       // Add the trailing 0
    *lpstrCardNames = 0;

    lRes = (*axCtx[phCard->dwFlags & FLAG_MASKPCSC].lpfnEstablish)(SCARD_SCOPE_USER, NULL, NULL, &phCard->hCtx);

    if (lRes == SCARD_S_SUCCESS)
    {
        xOCN.dwStructSize = sizeof(xOCN);
        xOCN.hwndOwner = NULL;      // probably called from console anyway
        xOCN.hSCardContext = phCard->hCtx;
        xOCN.lpstrGroupNames = lpstrGroupNames;
        xOCN.nMaxGroupNames = sizeof(lpstrGroupNames)/sizeof(TCHAR);
        xOCN.lpstrCardNames = wszCN;
        xOCN.rgguidInterfaces = NULL;
        xOCN.cguidInterfaces = 0;
        xOCN.lpstrRdr = wszReader;
        xOCN.nMaxRdr = MAX_NAME/sizeof(TCHAR);
        xOCN.lpstrCard = wszCard;
        xOCN.nMaxCard = MAX_NAME/sizeof(TCHAR);
        xOCN.lpstrTitle = _TEXT("Insert Card:");
        xOCN.dwFlags = SC_DLG_MINIMAL_UI;
        xOCN.pvUserData = NULL;
        xOCN.dwShareMode = SCARD_SHARE_SHARED;
        xOCN.dwPreferredProtocols = SCARD_PROTOCOL_T1 | SCARD_PROTOCOL_T0;
        xOCN.lpfnConnect = NULL;
        xOCN.lpfnCheck = NULL;
        xOCN.lpfnDisconnect = NULL;

        lRes = (*axCtx[phCard->dwFlags & FLAG_MASKPCSC].lpfnOpenCard)(&xOCN);
    }

    if (lRes == SCARD_S_SUCCESS)
    {
        phCard->hCard = xOCN.hCardHandle;
    }

    return lRes;
}

SCODE WINAPI hScwSCardBeginTransaction(SCARDHANDLE hCard)
{
    SCODE ret;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    if ((phTmp->dwFlags & FLAG_REALPCSC) == FLAG_REALPCSC)
        ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardBeginTransaction)(phTmp->hCard);
    else
        ret = SCARD_S_SUCCESS;  // No transactions on simulator

    return ret;
}

SCODE WINAPI hScwSCardEndTransaction(SCARDHANDLE hCard, DWORD dwDisposition)
{
    SCODE ret;
    LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

    if ((phTmp->dwFlags & FLAG_REALPCSC) == FLAG_REALPCSC)
        ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardEndTransaction)(phTmp->hCard, dwDisposition);
    else
        ret = SCARD_S_SUCCESS;  // No transactions on simulator

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\wpscprox\marshalpc.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "MarshalPC.h"
#include <string.h>

//*****************************************************************************
//      Un/Marshaling
//*****************************************************************************


void InitXSCM(LPMYSCARDHANDLE phTmp, const BYTE *pbBuffer, WORD len)
{
    phTmp->xSCM.wResLen = len;

    if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
        phTmp->xSCM.wExpLen = 1;            // Prereserves the return code
    else
        phTmp->xSCM.wExpLen = 0;            // Return code in SW2
    phTmp->xSCM.wGenLen = 0;
    phTmp->xSCM.pbBuffer = (LPBYTE)pbBuffer;
}

WORD GetSCMBufferLength(LPXSCM pxSCM)
{
    return pxSCM->wGenLen;
}

BYTE *GetSCMCrtPointer(LPXSCM pxSCM)
{
    return pxSCM->pbBuffer;
}


//*****************************************************************************
// PARAM EXTRACTION (we care only that there is enough data received, i.e.
// we ignore pxSCM->wGenLen & pxSCM->wExpLen

SCODE XSCM2SCODE(LPXSCM pxSCM)
{
    BYTE by;
    if (pxSCM->wResLen == 0)
        RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
    pxSCM->wResLen -= sizeof(UINT8);
    by = *(pxSCM->pbBuffer)++;
    return MAKESCODE(by);
}

UINT8 XSCM2UINT8(LPXSCM pxSCM)
{
    if (pxSCM->wResLen == 0)
        RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
    pxSCM->wResLen -= sizeof(UINT8);
    return *((UINT8 *)pxSCM->pbBuffer)++;
}

HFILE XSCM2HFILE(LPXSCM pxSCM)
{
    return (HFILE)(XSCM2UINT8(pxSCM));
}

UINT16 XSCM2UINT16(LPXSCM pxSCM, BOOL fBigEndian)
{
    if (pxSCM->wResLen < sizeof(UINT16))
        RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
    pxSCM->wResLen -= sizeof(UINT16);
    if (fBigEndian)
    {
        UINT16 w = *((UINT16 *)pxSCM->pbBuffer)++;
        w = (UINT16)(w>>8) | (UINT16)(w<<8);
        return w;
    }
    else
        return *((UNALIGNED UINT16 *)pxSCM->pbBuffer)++;
}

    // Returns length in WCHAR
WCSTR XSCM2String(LPXSCM pxSCM, UINT8 *plen, BOOL fBigEndian)
{
        // Get the length (addr next byte + length -> next object
    WCSTR wsz;
    UINT8 len, i;

    len = XSCM2UINT8(pxSCM);
    if (len == 0)
    {
        wsz = NULL;
    }
    else
    {
        if (pxSCM->wResLen < (WORD)len)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
        pxSCM->wResLen -= (WORD)len;
        wsz = (WCSTR)pxSCM->pbBuffer;
            // In place byte switching
//        if (fBigEndian)
//        {
//            BYTE b;
//            for (i=0 ; i<(len&0xF7)-2 ; i+=2)
//            {
//                b = pxSCM->pbBuffer[i];
//                pxSCM->pbBuffer[i] = pxSCM->pbBuffer[i + 1];
//                pxSCM->pbBuffer[i+1] = b;
//            }
//        }
            // Verify 0 terminated within len/2
        for (i=0 ; i<len/2 ; i++)
        {
            if (wsz[i] == (WCHAR)0)
                break;
        }
        if (i >= len/2) 
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
        else
            len = i+1;

        pxSCM->pbBuffer += len;
    }
    if (plen)
        *plen = len;
    return wsz;
}

TCOUNT XSCM2ByteArray(LPXSCM pxSCM, UINT8 **ppb)
{
    TCOUNT len = XSCM2UINT8(pxSCM);
    if (len)
    {
        if (pxSCM->wResLen < (WORD)len)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
        pxSCM->wResLen -= (WORD)len;
        *ppb = (UINT8 *)pxSCM->pbBuffer;
        pxSCM->pbBuffer += len;
    }
    else
        *ppb = NULL;
    return len;
}

//*****************************************************************************


void UINT82XSCM(LPXSCM pxSCM, UINT8 val, int type)
{
    switch (type)
    {
    case TYPE_NOTYPE_NOCOUNT:   // Goes in the header
        break;                  // There can't be a problem

    case TYPE_NOTYPE_COUNT:     // Probably #param or a param type (1 byte)
        if (pxSCM->wExpLen + sizeof(UINT8) > pxSCM->wResLen)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
        break;

    case TYPE_TYPED:            // 8 bits number passed by value (2 bytes)
        if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
                // Prefix by the type (8)
        *((UINT8 *)pxSCM->pbBuffer)++ = 8;
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
        break;
    }

        // Add the value already !
    *((UINT8 *)pxSCM->pbBuffer)++ = val;
    if (type != TYPE_NOTYPE_NOCOUNT)    // Header doesn't count as expanded
        pxSCM->wExpLen += sizeof(UINT8);
    pxSCM->wGenLen += sizeof(UINT8);
}

    // proxies HFILE as an UINT8
void HFILE2XSCM(LPXSCM pxSCM, HFILE val)
{
    if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
        RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                // Prefix by the type (8 -> UINT8)
    *((UINT8 *)pxSCM->pbBuffer)++ = 8;
    pxSCM->wExpLen += sizeof(UINT8);
    pxSCM->wGenLen += sizeof(UINT8);
    *((UINT8 *)pxSCM->pbBuffer)++ = (UINT8)val;
    pxSCM->wExpLen += sizeof(UINT8);
    pxSCM->wGenLen += sizeof(UINT8);
}

void UINT162XSCM(LPXSCM pxSCM, UINT16 val, BOOL fBigEndian)
{
    if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT16) > pxSCM->wResLen)
        RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                // Prefix by the type (16)
    *((UINT8 *)pxSCM->pbBuffer)++ = 16;
    pxSCM->wExpLen += sizeof(UINT8);
    pxSCM->wGenLen += sizeof(UINT8);
    if (fBigEndian)
    {
        *pxSCM->pbBuffer++ = (BYTE)(val>>8);
        *pxSCM->pbBuffer++ = (BYTE)(val);
    }
    else
        *((UNALIGNED UINT16 *)pxSCM->pbBuffer)++ = val;
    pxSCM->wExpLen += sizeof(UINT16);
    pxSCM->wGenLen += sizeof(UINT16);
}

void ByteArray2XSCM(LPXSCM pxSCM, const BYTE *pbBuffer, TCOUNT len)
{
    if (pbBuffer == NULL)
    {
            // This is equivalent to marshal a NULL & "len as a UINT8"
        NULL2XSCM(pxSCM);
        UINT82XSCM(pxSCM, len, TYPE_TYPED);
    }
    else
    {
        if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + len > pxSCM->wResLen)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                // Prefix by the type ('A')
        *((UINT8 *)pxSCM->pbBuffer)++ = 'A';
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
                // Add the length
        *((UINT8 *)pxSCM->pbBuffer)++ = len;
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
                // Add the data already
        memcpy(pxSCM->pbBuffer, pbBuffer, len);
        pxSCM->pbBuffer += len;
        pxSCM->wExpLen += len;
        pxSCM->wGenLen += len;
    }
}

void String2XSCM(LPXSCM pxSCM, WCSTR wsz, BOOL fBigEndian)
{
    UINT16 len; //, i;

    if (wsz == NULL)
    {
            // This is equivalent to marshal a NULL
        NULL2XSCM(pxSCM);
    }
    else
    {
            // No overflow needs to be checked in the following assignement to len
        if (wcslen(wsz) > 0x7FFE)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

            // compute the length (addr next byte + length -> next object
        len = (wcslen(wsz) + 1) * sizeof(WCHAR);

        if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + len > pxSCM->wResLen)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                // Prefix by the type ('S')
        *((UINT8 *)pxSCM->pbBuffer)++ = 'S';
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
                // Add the length
        *((UINT8 *)pxSCM->pbBuffer)++ = (UINT8)len;     // No chance the length check succeeds
                                                        // if len > 255
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
                // Add the data already
           // Byte switching?
//        if (fBigEndian)
//        {
//            for (i=0 ; i<len ; i+=2)
//            {
//                pxSCM->pbBuffer[i] = (BYTE)(wsz[i>>1]>>8);
//                pxSCM->pbBuffer[i+1] = (BYTE)(wsz[i>>1]);
//            }
//        }
//        else
            memcpy(pxSCM->pbBuffer, (BYTE *)wsz, len);

        pxSCM->pbBuffer += len;
        pxSCM->wExpLen += len;
        pxSCM->wGenLen += len;
    }
}

void UINT8BYREF2XSCM(LPXSCM pxSCM, UINT8 *val)
{
    if (val)
    {
            // In this case the card unmarshaling code will reserve 1 byte in the
            // OutputBuffer and have _param[_iparam++]._pv point to it
        if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                    // Prefix by the type (108)
        *((UINT8 *)pxSCM->pbBuffer)++ = 108;
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
                    // Add the value already
        *((UINT8 *)pxSCM->pbBuffer)++ = *val;
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);

                    // As mentioned above, 1 byte will be reserved in the output buffer
        pxSCM->wExpLen += sizeof(UINT8);
    }
    else
    {
            // This is equivalent to marshal a NULL
        NULL2XSCM(pxSCM);
    }
}

void HFILEBYREF2XSCM(LPXSCM pxSCM, HFILE *val)
{
    if (val)
    {
            // In this case the card unmarshaling code will reserve 1 byte in the
            // OutputBuffer and have _param[_iparam++]._pv point to it
        if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                    // Prefix by the type (108)
        *((UINT8 *)pxSCM->pbBuffer)++ = 108;
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
                    // Add the value already
        *((UINT8 *)pxSCM->pbBuffer)++ = (UINT8)*val;
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);

                    // As mentioned above, 1 byte will be reserved in the output buffer
        pxSCM->wExpLen += sizeof(UINT8);
    }
    else
    {
            // This is equivalent to marshal a NULL
        NULL2XSCM(pxSCM);
    }
}

void UINT16BYREF2XSCM(LPXSCM pxSCM, UINT16 *val, BOOL fBigEndian)
{
    if (val)
    {
            // In this case the card unmarshaling code will reserve 2 bytes in the
            // OutputBuffer and have _param[_iparam++]._pv point to it
        if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT16) + sizeof(UINT16) > pxSCM->wResLen)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                    // Prefix by the type (116)
        *((UINT8 *)pxSCM->pbBuffer)++ = 116;
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
                    // Add the value already
        if (fBigEndian)
        {
            *pxSCM->pbBuffer++ = (BYTE)((*val)>>8);
            *pxSCM->pbBuffer++ = (BYTE)(*val);
        }
        else
            *((UNALIGNED UINT16 *)pxSCM->pbBuffer)++ = *val;
        pxSCM->wExpLen += sizeof(UINT16);
        pxSCM->wGenLen += sizeof(UINT16);

                    // As mentioned above, 2 bytes will be reserved in the output buffer
        pxSCM->wExpLen += sizeof(UINT16);
    }
    else
    {
            // This is equivalent to marshal a NULL
        NULL2XSCM(pxSCM);
    }
}

void ByteArrayOut2XSCM(LPXSCM pxSCM, BYTE *pb, TCOUNT len)
{
    if (pb)
    {
            // In this case the card unmarshaling code will reserve 1+len bytes in the
            // OutputBuffer and have _param[_iparam++]._pv point to the len bytes
            // Note that the current buffer isn't passed in
        if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) + len > pxSCM->wResLen)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                    // Prefix by the type ('a')
        *((UINT8 *)pxSCM->pbBuffer)++ = 'a';
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
                    // Add the length
        *((UINT8 *)pxSCM->pbBuffer)++ = len;
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);

                    // As mentioned above, 1+len bytes will be reserved in the output buffer
        pxSCM->wExpLen += sizeof(UINT8) + len;
    }
    else
    {
            // This is equivalent to marshal a NULL & "len as a UINT8"
        NULL2XSCM(pxSCM);
        UINT82XSCM(pxSCM, len, TYPE_TYPED);
    }
}

void StringOut2XSCM(LPXSCM pxSCM, WSTR wsz, TCOUNT len, BOOL fBigEndian)
{
    if (wsz)
    {
                            // len is a WCHAR count
        if (len > 127)      // This would cause overflows in String marshaling
            RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

            // In this case the card unmarshaling code will reserve 1+len*2 bytes in the
            // OutputBuffer and have _param[_iparam++]._pv point to the len bytes
            // Note that the current buffer isn't passed in
        if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) + len*2 > pxSCM->wResLen)
            RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                    // Prefix by the type ('s')
        *((UINT8 *)pxSCM->pbBuffer)++ = 's';
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);
        *((UINT8 *)pxSCM->pbBuffer)++ = len*2;
        pxSCM->wExpLen += sizeof(UINT8);
        pxSCM->wGenLen += sizeof(UINT8);

                    // As mentioned above, 1+len*2 bytes will be reserved in the output buffer
        pxSCM->wExpLen += sizeof(UINT8) + len*2;
    }
    else
    {
            // This is equivalent to marshal a NULL & "len as a UINT8"
        NULL2XSCM(pxSCM);
        UINT82XSCM(pxSCM, len, TYPE_TYPED);
    }
}

void NULL2XSCM(LPXSCM pxSCM)
{
    if (pxSCM->wExpLen + sizeof(UINT8) > pxSCM->wResLen)
        RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

                // Prefix by the type (0)
     *((UINT8 *)pxSCM->pbBuffer)++ = 0;
    pxSCM->wExpLen += sizeof(UINT8);
    pxSCM->wGenLen += sizeof(UINT8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\csps\wfsccsp\wpscprox\wpscproxy.h ===
#ifndef _WPSCPROXY_H_DEF_
#define _WPSCPROXY_H_DEF_

#include <winscard.h>

// Basic types
typedef signed char    INT8;
typedef signed short   INT16;
typedef unsigned char  UINT8;
typedef unsigned short UINT16;

// Derived types for API
typedef UINT8   TCOUNT;
typedef UINT16  ADDRESS;
typedef UINT16  TOFFSET;
typedef UINT8   TUID;
typedef UINT8   HACL;

typedef WCHAR *WSTR;
typedef const WCHAR *WCSTR;

#include "wpscoserr.h"

#ifdef __cplusplus
extern "C" {
#endif

/* PC/SC */
typedef LONG (WINAPI *LPFNSCWTRANSMITPROC)(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut);

#define NULL_TX		((SCARDHANDLE)(-1))		// To indicate to use scwwinscard.dll vs winscard.dll
#define NULL_TX_NAME ((LPCWSTR)(-1))		// To indicate to use scwwinscard.dll vs winscard.dll

	// Different scenarios:
	// Non PC/SC apps: call hScwAttachToCard(NULL, NULL, &hCard), hScwSetTransmitCallback & hScwSetEndianness
	// PC/SC apps not connecting themselves: call hScwAttachToCard(NULL, mszCardNames, &hCard)
	// PC/SC apps connecting themselves: call hScwAttachToCard(hCard, NULL, &hCard)
	// For simulator use replace NULL by NULL_TX in the 2 above lines
	// PC/SC hScwAttachToCard will call hScwSetTransmitCallback & hScwSetEndianness (the ATR better
	// be compliant (endianness in 1st historical bytes) or call hScwSetEndianness with
	// appropriate value).
SCODE WINAPI hScwAttachToCard(SCARDHANDLE hCard, LPCWSTR mszCardNames, LPSCARDHANDLE phCard);
SCODE WINAPI hScwAttachToCardEx(SCARDHANDLE hCard, LPCWSTR mszCardNames, BYTE byINS, LPSCARDHANDLE phCard);
SCODE WINAPI hScwSetTransmitCallback(SCARDHANDLE hCard, LPFNSCWTRANSMITPROC lpfnProc);
SCODE WINAPI hScwDetachFromCard(SCARDHANDLE hCard);
SCODE WINAPI hScwSCardBeginTransaction(SCARDHANDLE hCard);
SCODE WINAPI hScwSCardEndTransaction(SCARDHANDLE hCard, DWORD dwDisposition);

/*
** Constants
*/

// File attribute Flags. Some are used by the system (defined below.) 
// The rest are available for application use
#define SCW_FILEATTR_DIRF  (UINT16)(0x8000)    // The file defined by this entry is a sub directory
#define SCW_FILEATTR_ACLF  (UINT16)(0x4000)    // The file defined by this entry is an ACL file
#define SCW_FILEATTR_ROMF  (UINT16)(0x2000)    // The file defined by this entry is in ROM
#define SCW_FILEATTR_RSRV2 (UINT16)(0x1000)   
// Bits that cannot be changed by ScwSetFileAttributes
#define SCW_FILEATTR_PBITS (UINT16)(SCW_FILEATTR_DIRF|SCW_FILEATTR_ACLF|SCW_FILEATTR_ROMF|SCW_FILEATTR_RSRV2)

/* File seek */
#define FILE_BEGIN      0
#define FILE_CURRENT    1
#define FILE_END        2

/* Access Control */
#define SCW_ACLTYPE_DISJUNCTIVE 0x00
#define SCW_ACLTYPE_CONJUNCTIVE 0x01

/*
** Maximum Known principals and Groups
*/
#define SCW_MAX_NUM_PRINCIPALS     40

/*
** Authentication Protocols
*/
#define SCW_AUTHPROTOCOL_AOK    0x00    // Always returns SCW_S_OK
#define SCW_AUTHPROTOCOL_PIN    0x01    // Personal Identification Number
#define SCW_AUTHPROTOCOL_DES	0x05	// DES authentication
#define SCW_AUTHPROTOCOL_3DES	0x06	// Triple DES authentication
#define SCW_AUTHPROTOCOL_RTE	0x07	// RTE applet as an auth. protocol
#define SCW_AUTHPROTOCOL_NEV    0xFF    // Always returns SCW_E_NOTAUTHENTICATED

/* Well-known UIDs */
#define SCW_PRINCIPALUID_INVALID        0x00    // Invalid UID
#define SCW_PRINCIPALUID_ANONYMOUS      0x01    

/* ResoureTypes */
#define SCW_RESOURCETYPE_FILE                   0x00
#define SCW_RESOURCETYPE_DIR                    0x10
#define SCW_RESOURCETYPE_COMMAND                0x20   // reserved for future use
#define SCW_RESOURCETYPE_CHANNEL                0x30   // reserved for future use
#define SCW_RESOURCETYPE_ANY                    0xE0

/* Resource Operation on RESOURCETYPE_FILE */
#define SCW_RESOURCEOPERATION_FILE_READ             (SCW_RESOURCETYPE_FILE | 0x01)
#define SCW_RESOURCEOPERATION_FILE_WRITE            (SCW_RESOURCETYPE_FILE | 0x02)
#define SCW_RESOURCEOPERATION_FILE_EXECUTE          (SCW_RESOURCETYPE_FILE | 0x03)
#define SCW_RESOURCEOPERATION_FILE_EXTEND           (SCW_RESOURCETYPE_FILE | 0x04)
#define SCW_RESOURCEOPERATION_FILE_DELETE           (SCW_RESOURCETYPE_FILE | 0x05)
#define SCW_RESOURCEOPERATION_FILE_GETATTRIBUTES    (SCW_RESOURCETYPE_FILE | 0x06)
#define SCW_RESOURCEOPERATION_FILE_SETATTRIBUTES    (SCW_RESOURCETYPE_FILE | 0x07)
#define SCW_RESOURCEOPERATION_FILE_CRYPTO	        (SCW_RESOURCETYPE_FILE | 0x08)
#define SCW_RESOURCEOPERATION_FILE_INCREASE	        (SCW_RESOURCETYPE_FILE | 0x09)
#define SCW_RESOURCEOPERATION_FILE_INVALIDATE       (SCW_RESOURCETYPE_FILE | 0x0A)
#define SCW_RESOURCEOPERATION_FILE_REHABILITATE     (SCW_RESOURCETYPE_FILE | 0x0B)


/* resourceOperation on RESOURCETYPE_DIR */
#define SCW_RESOURCEOPERATION_DIR_ACCESS            (SCW_RESOURCETYPE_DIR | 0x01)
#define SCW_RESOURCEOPERATION_DIR_CREATEFILE        (SCW_RESOURCETYPE_DIR | 0x02)
#define SCW_RESOURCEOPERATION_DIR_ENUM              (SCW_RESOURCETYPE_DIR | 0x03)
#define SCW_RESOURCEOPERATION_DIR_DELETE            (SCW_RESOURCETYPE_DIR | 0x04)
#define SCW_RESOURCEOPERATION_DIR_GETATTRIBUTES     (SCW_RESOURCETYPE_DIR | 0x05)
#define SCW_RESOURCEOPERATION_DIR_SETATTRIBUTES     (SCW_RESOURCETYPE_DIR | 0x06)

/* resourceOperation on any resource */
#define SCW_RESOURCEOPERATION_SETACL                ((BYTE)(SCW_RESOURCETYPE_ANY | 0x1D))
#define SCW_RESOURCEOPERATION_GETACL                ((BYTE)(SCW_RESOURCETYPE_ANY | 0x1E))
#define SCW_RESOURCEOPERATION_ANY                   ((BYTE)(SCW_RESOURCETYPE_ANY | 0x1F))

/* Cryptographic Mechanisms */
#define CM_SHA			0x80
#define CM_DES			0x90
#define CM_3DES			0xA0 // triple DES
#define CM_RSA			0xB0
#define CM_RSA_CRT		0xC0
#define CM_CRYPTO_NAME	0xF0 // mask for crypto mechanism names

#define CM_KEY_INFILE	0x01	// if key is passed in a file
#define CM_DATA_INFILE	0x02	// if data is passed in a file
#define CM_PROPERTIES	0x0F	// maks for crypto properites

// DES mode, keys and initial feedback buffer in cryptoBuffer
/* DES */

#define MODE_DES_ENCRYPT	0x00
#define MODE_DES_DECRYPT	0x20	//bit 5

#define MODE_DES_CBC		0x40	//bit 6
#define MODE_DES_MAC		0x10	//bit 4
#define MODE_DES_ECB		0x00

/* Triple DES */
#define MODE_TWO_KEYS_3DES		0x01	//bit 1 - if not set 3DES is working with 3 keys
#define MODE_THREE_KEYS_3DES	0x00

/* RSA */
#define MODE_RSA_SIGN		0x00
#define MODE_RSA_AUTH		0x01
#define MODE_RSA_KEYGEN		0x02

/* File System */
SCODE WINAPI hScwCreateFile(SCARDHANDLE hCard, WCSTR wszFileName, WCSTR wszAclFileName, HFILE *phFile);
SCODE WINAPI hScwCreateDirectory(SCARDHANDLE hCard, WCSTR wszDirName, WCSTR wszAclFileName);
SCODE WINAPI hScwDeleteFile(SCARDHANDLE hCard, WCSTR wszFileName);
SCODE WINAPI hScwCloseFile(SCARDHANDLE hCard, HFILE hFile);
SCODE WINAPI hScwReadFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes);
SCODE WINAPI hScwWriteFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes);
SCODE WINAPI hScwGetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET *pnFileLength);
SCODE WINAPI hScwSetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET nFileLength);
SCODE WINAPI hScwReadFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes);
SCODE WINAPI hScwWriteFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes);

SCODE WINAPI hScwGetFileAttributes(SCARDHANDLE hCard, WCSTR wszFileName, UINT16 *pnValue);
SCODE WINAPI hScwSetFileAttributes(SCARDHANDLE hCard, WCSTR wszFileName, UINT16 nValue);

SCODE WINAPI hScwSetFilePointer(SCARDHANDLE hCard, HFILE hFile, INT16 iDistance, BYTE bMode);
SCODE WINAPI hScwEnumFile(SCARDHANDLE hCard, WCSTR wszDirectoryName, UINT16 *pnFileCookie, WSTR wszFileName, TCOUNT nBufferSize);
SCODE WINAPI hScwSetFileACL(SCARDHANDLE hCard, WCSTR wszFileName, WCSTR wszAclFileName);
SCODE WINAPI hScwGetFileAclHandle(SCARDHANDLE hCard, WCSTR wszFileName, HFILE *phFile);

/* Access Control */
SCODE WINAPI hScwAuthenticateName(SCARDHANDLE hCard, WCSTR wszPrincipalName, BYTE *pbSupportData, TCOUNT nSupportDataLength);
SCODE WINAPI hScwDeauthenticateName(SCARDHANDLE hCard, WCSTR wszPrincipalName);
SCODE WINAPI hScwIsAuthenticatedName(SCARDHANDLE hCard, WCSTR wszPrincipalName);
SCODE WINAPI hScwIsAuthorized(SCARDHANDLE hCard, WCSTR wszResourceName, BYTE bOperation);
SCODE WINAPI hScwGetPrincipalUID(SCARDHANDLE hCard, WCSTR wszPrincipalName, TUID *pnPrincipalUID);
SCODE WINAPI hScwAuthenticateUID(SCARDHANDLE hCard, TUID nPrincipalUID, BYTE *pbSupportData, TCOUNT nSupportDataLength);
SCODE WINAPI hScwDeauthenticateUID(SCARDHANDLE hCard, TUID nPrincipalUID);
SCODE WINAPI hScwIsAuthenticatedUID(SCARDHANDLE hCard, TUID nPrincipalUID);

/* Runtime Environment (RTE) */
SCODE WINAPI hScwRTEExecute(SCARDHANDLE hCard, WCSTR wszCodeFileName, WCSTR wszDataFileName, UINT8 bRestart);

/* Cryptography */
SCODE WINAPI hScwCryptoInitialize(SCARDHANDLE hCard, BYTE bMechanism, BYTE *pbKeyMaterial);
SCODE WINAPI hScwCryptoAction(SCARDHANDLE hCard, BYTE *pbDataIn, TCOUNT nDataInLength, BYTE *pbDataOut, TCOUNT *pnDataOutLength);
SCODE WINAPI hScwCryptoUpdate(SCARDHANDLE hCard, BYTE *pbDataIn, TCOUNT nDataInLength);
SCODE WINAPI hScwCryptoFinalize(SCARDHANDLE hCard, BYTE *pbDataOut, TCOUNT *pnDataOutLength);
SCODE WINAPI hScwGenerateRandom(SCARDHANDLE hCard, BYTE *pbDataOut, TCOUNT nDataOutLength);

SCODE WINAPI hScwSetDispatchTable(SCARDHANDLE hCard, WCSTR wszFileName);

typedef struct {
	BYTE CLA;
	BYTE INS;
	BYTE P1;
	BYTE P2;
} ISO_HEADER;
typedef ISO_HEADER *LPISO_HEADER;
/*
	ScwExecute:
		I-:	lpxHdr (points to 4 bytes (CLA, INS, P1, P2))
		I-: InBuf (Incoming data from card's perspective (NULL -> no data in))
		I-: InBufLen (length of data pointed by InBuf)
		-O: OutBuf (Buffer that will receive the R-APDU (NULL -> no expected data))
		IO: pOutBufLen (I -> Size of OutBuf, O -> Number of bytes written in OutBuf)
		-O: pwSW (Card Status Word)
*/
SCODE WINAPI hScwExecute(SCARDHANDLE hCard, LPISO_HEADER lpxHdr, BYTE *InBuf, TCOUNT InBufLen, BYTE *OutBuf, TCOUNT *pOutBufLen, UINT16 *pwSW);

#ifdef __cplusplus
}
#endif

#endif	// ifndef _WPSCPROXY_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\client\dssetup_c_stub.c ===
#include "dssetup_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:

!INCLUDE $(NTMAKEENV)\makefile.plt

CLIENT_ACF = dssetup.acf
SERVER_ACF = dssetups.acf

CLIENT_INC_FILE = dssetup_c.h
SERVER_INC_FILE = dssetrpc.h

INCS  = -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(DS_INC_PATH) -I..\inc

# take MIDL_OPTIMIZATION_NT5 from tools\makefile.plt.

MIDL_FLAGS= $(MIDL_FLAGS) -out .\$(O)

CLIENT_FLAGS = -oldnames -c_ext -ms_ext $(MIDL_FLAGS)  -acf $(CLIENT_ACF) -header $(CLIENT_INC_FILE) -server none
SERVER_FLAGS = -oldnames -c_ext -ms_ext $(MIDL_FLAGS)  -acf $(SERVER_ACF) -header $(SERVER_INC_FILE) -client none

CPP = -cpp_cmd "$(MIDL_CPP)" 

#
# Separate client and server targets.  Note that the .h file produced
# when MIDL is run with the client .acf file attached differs from the
# .h file produced when MIDL is run with the server .acf file attached.
#

CLIENT_TARGETS = $(O)\dssetup_c.c  \
                 $(O)\$(CLIENT_INC_FILE)

SERVER_TARGETS = $(O)\dssetup_s.c  \
                 $(O)\$(SERVER_INC_FILE)

TARGETS = $(CLIENT_TARGETS) $(SERVER_TARGETS)

#
# MIDL COMPILE
#
$(CLIENT_TARGETS) : dssetup.idl $(CLIENT_ACF)
    midl $(CPP) $(MIDL_OPTIMIZATION_NT5) $(CLIENT_FLAGS) $(INCS) dssetup.idl

$(SERVER_TARGETS) : dssetup.idl $(SERVER_ACF)
    midl $(CPP) $(MIDL_OPTIMIZATION_NT5) $(SERVER_FLAGS) $(INCS) dssetup.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\inc\dssetcon.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetcon.h

Abstract:

    This file contains contains structures and definitions to be including
    in both the dssetup.idl file and regular C code

Author:

Environment:

Revision History:

--*/

#define DSROLE_OBFUSCATOR_LENGTH 8
#define DSROLE_MAX_PASSWORD_LENGTH PWLEN
#define DSROLE_SALT_LENGTH 20
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\inc\dssetimp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lsaimp.h

Abstract:

    Local Security Authority Protected Subsystem - Private Includes

Author:

    Scott Birrell       (ScottBi)       April 24, 1991

Environment:

Revision History:

--*/
#include <ntdef.h>
#define NT_INCLUDED
#include <windef.h>
#include <dsrole.h>
#include <dsrolep.h>
#include <lmcons.h>
#include <dssetcon.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\inc\dssetp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetp.ch

Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __DSSETP_H__
#define __DSSETP_H__

#include <winldap.h>
#include <dsysdbg.h>
#include <dssetrpc.h>
#include <dns.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <logonmsv.h>

#define DEB_TRACE_DS        0x00000008
#define DEB_TRACE_UPDATE    0x00000010
#define DEB_TRACE_LOCK      0x00000020
#define DEB_TRACE_SERVICES  0x00000040
#define DEB_TRACE_NET       0x00000080

#if DBG

    #ifdef ASSERT
        #undef ASSERT
    #endif

    #define ASSERT  DsysAssert

    DECLARE_DEBUG2( DsRole )

    #define DsRoleDebugOut( args ) DsRoleDebugPrint args

    VOID
    DsRoleDebugInitialize(
        VOID
        );


#else

    #define  DsRoleDebugOut(args)
    #define  DsRoleDebugInitialize()

#endif  // DBG


#define DSROLEP_EVENT_NAME L"\\DsRoleLsaEventName"
#define DSROLEP_PROD_KEY_PATH L"System\\CurrentControlSet\\Control\\ProductOptions"
#define DSROLEP_PROD_VALUE L"ProductType"
#define DSROLEP_SERVER_PRINCIPAL_NAME L"DsRole"

extern handle_t ClientBindingHandle;

//
// Determines whether a bit flag is turned on or not
//
#define FLAG_ON(flag,bits)        ((flag) & (bits))
#define FLAG_OFF(flag,bits)       (!FLAG_ON(flag,bits))

#define NELEMENTS(x)  (sizeof(x)/sizeof((x)[0]))

#define DSROLEP_ALLOCA(y,x) \
   __try {\
     y = alloca(x);\
   } __except ( GetExceptionCode() == STATUS_STACK_OVERFLOW) {\
     y=NULL;\
   }

#define DSROLEP_MIDL_ALLOC_AND_COPY_STRING_ERROR( dest, src, err )                              \
if ( (src) ) {                                                                                  \
    (dest) = MIDL_user_allocate(  (wcslen( (src) ) + 1) * sizeof( WCHAR ) );                    \
    if ( !(dest) ) {                                                                            \
        err = ERROR_NOT_ENOUGH_MEMORY;                                                          \
    } else {                                                                                    \
        wcscpy((dest), (src));                                                                  \
    }                                                                                           \
} else {                                                                                        \
    (dest) = NULL;                                                                              \
}

//
// Options for specifiying the behavior of the path validation function
//
#define DSROLEP_PATH_VALIDATE_EXISTENCE 0x00000001
#define DSROLEP_PATH_VALIDATE_LOCAL     0x00000002
#define DSROLEP_PATH_VALIDATE_NTFS      0x00000004


typedef enum _DSROLEP_MACHINE_TYPE {

    DSROLEP_MT_CLIENT = 0,
    DSROLEP_MT_STANDALONE,
    DSROLEP_MT_MEMBER

} DSROLEP_MACHINE_TYPE, *PDSROLEP_MACHINE_TYPE;

//
// Utility functions
//
DWORD
DsRolepDecryptPassword(
    IN PUNICODE_STRING EncryptedPassword,
    IN OUT PUNICODE_STRING DecryptedPassword,
    OUT PUCHAR Seed
    );

DWORD
DsRolepGetMachineType(
    IN OUT PDSROLEP_MACHINE_TYPE MachineType );

NTSTATUS
DsRolepInitialize(
    VOID
    );

NTSTATUS
DsRolepInitializePhase2(
    VOID
    );

DWORD
DsRolepSetProductType(
    IN DSROLEP_MACHINE_TYPE MachineType
    );

DWORD
DsRolepCreateAuthIdentForCreds(
    IN PWSTR Account,
    IN PWSTR Password,
    OUT PSEC_WINNT_AUTH_IDENTITY *AuthIdent
    );

VOID
DsRolepFreeAuthIdentForCreds(
    IN  PSEC_WINNT_AUTH_IDENTITY AuthIdent
    );

DWORD
DsRolepTimeSyncAndManageIPCConnect(
    IN PVOID  PromoteArgs,
    IN PWSTR  ReplicaServer
    );

DWORD
DsRolepForceTimeSync(
    IN HANDLE ImpToken,
    IN PWSTR TimeSource
    );

DWORD
DsRolepDnsNameToFlatName(
    IN  LPWSTR DnsName,
    OUT LPWSTR *FlatName,
    OUT PULONG StatusFlag
    );

DWORD
DsRolepValidatePath(
    IN  LPWSTR Path,
    IN  ULONG ValidationCriteria,
    OUT PULONG MatchingCriteria
    );

DWORD
DsRolepCopyDsDitFiles(
    IN LPWSTR DsPath
    );

DWORD
DsRolepSetDcSecurity(
    IN HANDLE ClientToken,
    IN LPWSTR SysvolRootPath,
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN BOOLEAN Upgrade,
    IN BOOLEAN Replica
    );

DWORD
DsRolepDsGetDcForAccount(
    IN LPWSTR Server OPTIONAL,
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN ULONG Flags,
    IN ULONG AccountBits,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );

DWORD
DsRolepSetMachineAccountType(
    IN LPWSTR Dc,
    IN HANDLE ClientToken,
    IN LPWSTR User,
    IN LPWSTR Password,
    IN LPWSTR AccountName,
    IN ULONG AccountBits,
    IN OUT WCHAR** AccountDn OPTIONAL
    );

NTSTATUS
DsRolepGetMixedModeFlags(
    IN PSID DomainSid,
    OUT PULONG Flags
    );

//
// Prototype from protos.h
//
ULONG
SpmpReportEvent(
    IN BOOL Unicode,
    IN WORD EventType,
    IN ULONG EventId,
    IN ULONG Category,
    IN ULONG SizeOfRawData,
    IN PVOID RawData,
    IN ULONG NumberOfStrings,
    ...
    );

DWORD
DsRolepGenerateRandomPassword(
    IN ULONG Length,
    IN WCHAR *Buffer
    );


DWORD
DsRolepDelnodePath(
    IN  LPWSTR Path,
    IN  ULONG BufferSize,
    IN  BOOLEAN DeleteRoot
    );

DWORD
DsRolepIsDnsNameChild(
    IN  LPWSTR ParentDnsName,
    IN  LPWSTR ChildDnsName
    );

DWORD
ImpDsRolepDsGetDcForAccount(
    IN HANDLE CallerToken,
    IN LPWSTR Server OPTIONAL,
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN ULONG Flags,
    IN ULONG AccountBits,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );

NET_API_STATUS
NET_API_FUNCTION
ImpNetpManageIPCConnect(
    IN  HANDLE  CallerToken,
    IN  LPWSTR  lpServer,
    IN  LPWSTR  lpAccount,
    IN  LPWSTR  lpPassword,
    IN  ULONG   fOptions
    );

NTSTATUS
ImpLsaOpenPolicy(
    IN HANDLE CallerToken,
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    );

NTSTATUS
ImpLsaDelete(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ObjectHandle
    );

NTSTATUS
ImpLsaQueryInformationPolicy(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );


NTSTATUS
ImpLsaOpenTrustedDomainByName(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    );

NTSTATUS
ImpLsaOpenTrustedDomain(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    );


NTSTATUS
ImpLsaCreateTrustedDomainEx(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    );


NTSTATUS
ImpLsaQueryTrustedDomainInfoByName(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
ImpLsaQueryInfoTrustedDomain(
    IN HANDLE CallerToken,
    IN LSA_HANDLE TrustedDomain,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
ImpLsaQueryDomainInformationPolicy(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
ImpLsaClose(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ObjectHandle
    );

#endif // __DSSETP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\cancel.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cancel.h

Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __CANCEL_H__
#define __CANCEL_H__

DWORD
DsRolepCancel(
    BOOL BlockUntilDone
    );

#endif // __CANCEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\client\rpcapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rpcapi.c

Abstract:

    This module contains the routines for the dssetup APIs that use RPC.  The
    routines in this module are merely wrappers that work as follows:

    Fuke copied lsa\uclient and hacked on to make it work for DsRole apis

Author:

    Mac McLain     (MacM)    April 14, 1997

Revision History:

--*/

#include <lsacomp.h>
#include "dssetup_c.h"
#include <rpcndr.h>
#include <dssetp.h>
#include <winreg.h>
#include <rpcasync.h>

#include <wxlpc.h>
#include <crypt.h>
#include <rc4.h>
#include <md5.h>
#include <winbase.h> //for RtlSecureZeroMemory

//
// Local prototypes
//
DWORD
DsRolepGetPrimaryDomainInformationDownlevel(
    IN LPWSTR Server,
    OUT PBYTE *Buffer
    );

DWORD
DsRolepGetProductTypeForServer(
    IN LPWSTR Server,
    IN OUT PNT_PRODUCT_TYPE ProductType
    );


DWORD
DsRolepEncryptPasswordStart(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR *Passwords,
    IN ULONG   Count,
    OUT RPC_BINDING_HANDLE *RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT OPTIONAL PUSER_SESSION_KEY UserSessionKey,
    IN OUT PDSROLEPR_ENCRYPTED_USER_PASSWORD *EncryptedUserPassword
    );

VOID
DsRolepEncryptPasswordEnd(
    IN RPC_BINDING_HANDLE RpcBindingHandle,
    IN HANDLE RedirHandle OPTIONAL,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD *EncryptedUserPassword OPTIONAL,
    IN ULONG Count
    );

DWORD
DsRolepHashkey(
    IN OUT LPWSTR key,
    OUT PUNICODE_STRING Hash
    );

DWORD
DsRolepEncryptHash(
    IN PUSER_SESSION_KEY UserSessionKey,
    IN OUT PUNICODE_STRING Syskey,
    OUT PDSROLEPR_ENCRYPTED_HASH EncryptedSyskey
    );

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// DS Setup and initialization routines                                   //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

BOOLEAN
DsRolepIsSetupRunning(
    VOID
    )
/*++

Routine Description:

    This routine determines if this call is being made during setup or not

Arguments:

    VOID

Return Value:

    TRUE -- The call is being made during setup

    FALSE -- The call is not being made during setup

--*/
{
    NTSTATUS Status;
    HANDLE InstallationEvent;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventName;
    BOOLEAN Setup = FALSE;

    //
    // If the following event exists, then we are in setup mode
    //
    RtlInitUnicodeString( &EventName,
                          L"\\INSTALLATION_SECURITY_HOLD" );
    InitializeObjectAttributes( &EventAttributes,
                                &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &InstallationEvent,
                          SYNCHRONIZE,
                          &EventAttributes );

    if ( NT_SUCCESS( Status) ) {

        NtClose( InstallationEvent );
        Setup = TRUE;

    }

    return( Setup );
}


DWORD
DsRolepGetPrimaryDomainInfoServerBind(
    IN OPTIONAL PDSROLE_SERVER_NAME   ServerName,
    OUT handle_t *BindHandle
    )
/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to bind to the LSA on some server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    BindingHandle = NULL;
    NTSTATUS Status;
    
    //
    // Can't go remote when running in setup mode
    //
    if ( DsRolepIsSetupRunning() && ServerName != NULL ) {

        return( STATUS_INVALID_SERVER_STATE );
    }

    Status = RpcpBindRpc ( ServerName,
                           L"lsarpc",
                           0,
                           &BindingHandle );

    if (!NT_SUCCESS(Status)) {

        DbgPrint("DsRolepGetPrimaryDomainInfoServerBind: RpcpBindRpc failed 0x%lx\n", Status);

    } else {

        *BindHandle = BindingHandle;
    }

    return RtlNtStatusToDosError( Status );

}


DWORD
DsRolepServerBind(
    IN OPTIONAL PDSROLE_SERVER_NAME   ServerName,
    OUT handle_t *BindHandle
    )
/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to bind to the LSA on some server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    BindingHandle      = NULL;
    DWORD       Win32Err           = ERROR_SUCCESS;
    WCHAR       *pwszStringBinding = NULL;
    BOOL        fAuth              = TRUE;

    //
    // Can't go remote when running in setup mode
    //
    if ( DsRolepIsSetupRunning() && ServerName != NULL ) {

        return( STATUS_INVALID_SERVER_STATE );
    }

    RpcTryExcept
    {
        Win32Err = RpcStringBindingComposeW(NULL,
                                            L"ncalrpc",
                                            NULL,
                                            L"dsrole",
                                            NULL,
                                            &pwszStringBinding);

        if (RPC_S_OK != Win32Err) {
            __leave;
        }

        Win32Err = RpcBindingFromStringBindingW(pwszStringBinding, 
                                                &BindingHandle);
        if (RPC_S_OK != Win32Err) {
            __leave;
        }


        Win32Err = RpcEpResolveBinding(BindingHandle, 
                                       dsrole_ClientIfHandle);
        
        if ( RPC_S_OK != Win32Err ) {
            __leave;
        }

        // Set authentication info using our process's credentials.

        Win32Err = RpcBindingSetAuthInfo(BindingHandle,
                                         NULL,
                                         /*Uses the default authentication 
                                         level for the specified 
                                         authentication service.*/
                                         RPC_C_AUTHN_LEVEL_DEFAULT,
                                         /*RPC_C_AUTHN_DEFAULT is specified, 
                                         the RPC run-time library uses 
                                         the RPC_C_AUTHN_WINNT authentication 
                                         service for remote procedure calls 
                                         made using hBinding */
                                         RPC_C_AUTHN_DEFAULT,
                                         NULL,
                                         //Default authentication service.
                                         RPC_C_AUTHN_DEFAULT);
        if (RPC_S_OK != Win32Err) {
            __leave;
        }
    
        
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        Win32Err = RpcExceptionCode();        
    }
    RpcEndExcept;

    if ( RPC_S_OK == Win32Err ) {

        *BindHandle = BindingHandle;

    } else {

        if (BindingHandle) {

            RpcpUnbindRpc ( BindingHandle );

        }

    }

    if ( pwszStringBinding )
    {
        RpcStringFree(&pwszStringBinding);
    }

    return( Win32Err );

}



VOID
DsRolepServerUnbind (
    IN OPTIONAL PDSROLE_SERVER_NAME  ServerName,
    IN handle_t           BindingHandle
    )

/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to unbind from the LSA server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNREFERENCED_PARAMETER( ServerName );     // This parameter is not used

    RpcpUnbindRpc ( BindingHandle );
    return;
}



DWORD
DsRolepApiReturnResult(
    ULONG ExceptionCode
    )

/*++

Routine Description:

    This function converts an exception code or status value returned
    from the client stub to a value suitable for return by the API to
    the client.

Arguments:

    ExceptionCode - The exception code to be converted.

Return Value:

    DWORD - The converted Nt Status code.

--*/

{
    //
    // Return the actual value if compatible with Nt status codes,
    // otherwise, return STATUS_UNSUCCESSFUL.
    //
    NTSTATUS Status;
    DWORD Results;

    if ( !NT_SUCCESS( ( NTSTATUS )ExceptionCode ) ) {

        Results = RtlNtStatusToDosError( ( NTSTATUS )ExceptionCode );

    } else {

        Results = ExceptionCode;
    }

    return( Results );
}



VOID
WINAPI
DsRoleFreeMemory(
    IN PVOID    Buffer
    )
/*++

Routine Description:


    Some setup services that return a potentially large amount of memory,
    such as an enumeration might, allocate the buffer in which the data
    is returned.  This function is used to free those buffers when they
    are no longer needed.

Parameters:

    Buffer - Pointer to the buffer to be freed.  This buffer must
        have been allocated by a previous dssetup service call.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    MIDL_user_free( Buffer );
}



DWORD
WINAPI
DsRoleDnsNameToFlatName(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsName,
    OUT LPWSTR *lpFlatName,
    OUT PULONG  lpStatusFlag
    )
/*++

Routine Description:

    This routine will get the default NetBIOS (or flat) domain name for the given Dns domain name

Arguments:

    lpServer - Server on which to remote the call (NULL is local)

    lpDnsName - Dns domain name to generate the flat name for

    lpFlatName - Where the flat name is returned. Must be freed via MIDL_user_free
        (or DsRoleFreeMemory)

    lpStatusFlag - Flags that indicate information about the returned name.  Valid flags are:
        DSROLE_FLATNAME_DEFAULT -- This is the default NetBIOS name for this dns domain name
        DSROLE_FLATNAME_UPGRADE -- This is the name that is current in use by this machine as
            a flat name and cannot be changed.

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;

    Win32Err = DsRolepServerBind( (PDSROLE_SERVER_NAME)lpServer,
                                  &Handle );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    RpcTryExcept {

        *lpFlatName = NULL;
        *lpStatusFlag = 0;

        Win32Err = DsRolerDnsNameToFlatName(
                         Handle,
                         ( LPWSTR )lpDnsName,
                         lpFlatName,
                         lpStatusFlag );

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepServerUnbind( (PDSROLE_SERVER_NAME)lpServer, Handle );

    return( Win32Err );
}



DWORD
WINAPI
DsRoleDcAsDc(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsDomainName,
    IN  LPCWSTR lpFlatDomainName,
    IN  LPCWSTR lpDomainAdminPassword OPTIONAL,
    IN  LPCWSTR lpSiteName OPTIONAL,
    IN  LPCWSTR lpDsDatabasePath,
    IN  LPCWSTR lpDsLogPath,
    IN  LPCWSTR lpSystemVolumeRootPath,
    IN  LPCWSTR lpParentDnsDomainName OPTIONAL,
    IN  LPCWSTR lpParentServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  LPCWSTR lpDsRepairPassword OPTIONAL,
    IN  ULONG Options,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    )
/*++

Routine Description:

    This routine will get the promote a server to be a DC in a domain

Arguments:

    lpServer - Server on which to remote the call (NULL is local)

    lpDnsDomainName - Dns domain name of the domain to install

    lpFlatDomainName - NetBIOS domain name of the domain to install

    lpDomainAdminPassword - Password to set on the administrator account if it is a new install

    SiteName - Name of the site this DC should belong to

    lpDsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    lpDsLogPath - Absolute path on the local machine where the Ds log files should go

    lpSystemVolumeRootPath - Absolute path on the local machine which will be the root of
        the system volume.

    lpParentDnsDomainName - Optional.  If present, set this domain up as a child of the
        specified domain

    lpParentServer - Optional.  If present, use this server in the parent domain to replicate
        the required information from

    lpAccount - User account to use when setting up as a child domain

    lpPassword - Password to use with the above account
    
    lpDsRepairPassword - Password to use for the admin account of the repair mode

    Options - Options to control the creation of the domain

    DsOperationHandle - Handle to the operation is returned here.

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;
    HANDLE RedirHandle = NULL;

#define DSROLEP_DC_AS_DC_DA_PWD_INDEX        0
#define DSROLEP_DC_AS_DC_PWD_INDEX           1
#define DSROLEP_DC_AS_DC_DS_REPAIR_PWD_INDEX 2
#define DSROLEP_DC_AS_DC_MAX_PWD_COUNT       3

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_DC_AS_DC_MAX_PWD_COUNT];
    LPCWSTR Passwords[DSROLEP_DC_AS_DC_MAX_PWD_COUNT];

    Passwords[DSROLEP_DC_AS_DC_DA_PWD_INDEX]        = lpDomainAdminPassword;
    Passwords[DSROLEP_DC_AS_DC_PWD_INDEX]           = lpPassword;
    Passwords[DSROLEP_DC_AS_DC_DS_REPAIR_PWD_INDEX] = lpDsRepairPassword;
    
    RtlZeroMemory( EncryptedPasswords, sizeof(EncryptedPasswords) );

    Win32Err = DsRolepEncryptPasswordStart( lpServer,
                                            Passwords,
                                            NELEMENTS(Passwords),
                                            &Handle,
                                            &RedirHandle,
                                            NULL,
                                            EncryptedPasswords );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }


    RpcTryExcept {

        Win32Err = DsRolerDcAsDc( Handle,
                                  ( LPWSTR )lpDnsDomainName,
                                  ( LPWSTR )lpFlatDomainName,
                                  EncryptedPasswords[DSROLEP_DC_AS_DC_DA_PWD_INDEX],
                                  ( LPWSTR )lpSiteName,
                                  ( LPWSTR )lpDsDatabasePath,
                                  ( LPWSTR )lpDsLogPath,
                                  ( LPWSTR )lpSystemVolumeRootPath,
                                  ( LPWSTR )lpParentDnsDomainName,
                                  ( LPWSTR )lpParentServer,
                                  ( LPWSTR )lpAccount,
                                  EncryptedPasswords[DSROLEP_DC_AS_DC_PWD_INDEX],
                                  EncryptedPasswords[DSROLEP_DC_AS_DC_DS_REPAIR_PWD_INDEX],
                                  Options,
                                  ( PDSROLER_HANDLE )DsOperationHandle );

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepEncryptPasswordEnd( Handle,
                               RedirHandle,
                               EncryptedPasswords,
                               NELEMENTS(EncryptedPasswords) );

    return( Win32Err );
}



DWORD
WINAPI
DsRoleDcAsReplica(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsDomainName,
    IN  LPCWSTR lpReplicaServer,
    IN  LPCWSTR lpSiteName OPTIONAL,
    IN  LPCWSTR lpDsDatabasePath,
    IN  LPCWSTR lpDsLogPath,
    IN  LPCWSTR lpRestorePath OPTIONAL,   
    IN  LPCWSTR lpSystemVolumeRootPath,
    IN OUT LPWSTR lpBootkey OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  LPCWSTR lpDsRepairPassword OPTIONAL,
    IN  ULONG Options,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    )
/*++

Routine Description:

    This routine will install a server as a replica of an existing domain.

Arguments:

    lpServer - OPTIONAL. Server to remote the call to.

    lpDnsDomainName - Dns domain name of the domain to install into

    lpReplicaServer -  The name of a Dc within the existing domain, against which to replicate

    lpSiteName - Name of the site this DC should belong to

    lpDsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    lpDsLogPath - Absolute path on the local machine where the Ds log files should go
    
    lpRestorepath - This is the path to a restored directory.

    lpSystemVolumeRootPath - Absolute path on the local machine which will be the root of
        the system volume.

    lpAccount - User account to use when setting up as a child domain

    lpPassword - Password to use with the above account
    
    lpDsRepairPassword - Password to use for the admin account of the repair mode

    Options - Options to control the creation of the domain

    DsOperationHandle - Handle to the operation is returned here.

Return Values:

--*/
{

    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    handle_t Handle = NULL;
    HANDLE RedirHandle = NULL;
    USER_SESSION_KEY UserSessionKey;
    UNICODE_STRING ClearBootKeyHash;
    DSROLEPR_ENCRYPTED_HASH EncryptedBootKey;
    
#define DSROLEP_DC_AS_REPLICA_PWD_INDEX           0
#define DSROLEP_DC_AS_REPLICA_DS_REPAIR_PWD_INDEX 1
#define DSROLEP_DC_AS_REPLICA_MAX_PWD_COUNT       2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_DC_AS_REPLICA_MAX_PWD_COUNT];
    LPCWSTR Passwords[DSROLEP_DC_AS_REPLICA_MAX_PWD_COUNT];

    Passwords[DSROLEP_DC_AS_REPLICA_PWD_INDEX]           = lpPassword;
    Passwords[DSROLEP_DC_AS_REPLICA_DS_REPAIR_PWD_INDEX] = lpDsRepairPassword;
    RtlZeroMemory( EncryptedPasswords, sizeof(EncryptedPasswords) );

    Win32Err = DsRolepEncryptPasswordStart( lpServer,
                                            Passwords,
                                            NELEMENTS(Passwords),
                                            &Handle,
                                            &RedirHandle,
                                            &UserSessionKey,
                                            EncryptedPasswords );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    if(lpBootkey)
    {
        Win32Err = DsRolepHashkey(lpBootkey,
                                  &ClearBootKeyHash
                                  );
        if (Win32Err != ERROR_SUCCESS) {
            return Win32Err;
        }

        Win32Err = DsRolepEncryptHash(&UserSessionKey,
                                      &ClearBootKeyHash,
                                      &EncryptedBootKey);
        if (Win32Err != ERROR_SUCCESS) {
            return Win32Err;
        }
    } else {
        EncryptedBootKey.EncryptedHash.Buffer = NULL;
        EncryptedBootKey.EncryptedHash.Length = 0;
        EncryptedBootKey.EncryptedHash.MaximumLength = 0;
    }
                                                  
    RpcTryExcept {

            Win32Err = DsRolerDcAsReplica( Handle,
                                         ( LPWSTR )lpDnsDomainName,
                                         ( LPWSTR )lpReplicaServer,
                                         ( LPWSTR )lpSiteName,
                                         ( LPWSTR )lpDsDatabasePath,
                                         ( LPWSTR )lpDsLogPath,
                                         ( LPWSTR )lpRestorePath,
                                         ( LPWSTR )lpSystemVolumeRootPath,
                                         EncryptedBootKey.EncryptedHash.Buffer==NULL?
                                           NULL:&EncryptedBootKey,
                                         ( LPWSTR )lpAccount,
                                         EncryptedPasswords[DSROLEP_DC_AS_REPLICA_PWD_INDEX],
                                         EncryptedPasswords[DSROLEP_DC_AS_REPLICA_DS_REPAIR_PWD_INDEX],
                                         Options,
                                         ( PDSROLER_HANDLE )DsOperationHandle );

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;

    if(EncryptedBootKey.EncryptedHash.Buffer)
    {
        MIDL_user_free(EncryptedBootKey.EncryptedHash.Buffer);
        EncryptedBootKey.EncryptedHash.Length=0;
        EncryptedBootKey.EncryptedHash.MaximumLength=0;
    }



    DsRolepEncryptPasswordEnd( Handle,
                               RedirHandle,
                               EncryptedPasswords,
                               NELEMENTS(EncryptedPasswords) );

    return( Win32Err );
}



DWORD
WINAPI
DsRoleDemoteDc(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsDomainName,
    IN  DSROLE_SERVEROP_DEMOTE_ROLE ServerRole,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  ULONG Options,
    IN  BOOL fLastDcInDomain,
    IN  ULONG cRemoveNCs,
    IN  LPCWSTR *pszRemoveNCs OPTIONAL,
    IN  LPCWSTR lpAdminPassword OPTIONAL,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    )
/*++

Routine Description:

    This routine will demote an existing Dc to a standalone or member server.

Arguments:

    lpServer - Server to remote the call to

    lpDnsDomainName - Name of the domain on this machine to demote.  If NULL, demote all of the
        domains on this machine

    ServerRole - The new role this machine should take

    lpAccount - OPTIONAL User account to use when deleting the trusted domain object

    lpPassword - Password to use with the above account

    Options - Options to control the demotion of the domain

    fLastDcInDomain - If TRUE, this is the last dc in the domain

    cRemoveNCs - Count of string pointers in pszRemoveNCs

    pszRemoveNCs - Array of (cRemoveNCs) strings. Strings are DNs of NDNCs to be removed

    lpAdminPassword - New local addmin password

    DsOperationHandle - Handle to the operation is returned here.

Return Values:

    ERROR_SUCCESS - Success
--*/

{

    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;
    HANDLE RedirHandle = NULL;

#define DSROLEP_DEMOTE_PWD_INDEX          0
#define DSROLEP_DEMOTE_ADMIN_PWD_INDEX    1
#define DSROLEP_DEMOTE_MAX_PWD_COUNT      2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_DEMOTE_MAX_PWD_COUNT];
    LPCWSTR Passwords[DSROLEP_DEMOTE_MAX_PWD_COUNT];

    Passwords[DSROLEP_DEMOTE_PWD_INDEX]   = lpPassword;
    Passwords[DSROLEP_DEMOTE_ADMIN_PWD_INDEX] = lpAdminPassword;
    RtlZeroMemory( EncryptedPasswords, sizeof(EncryptedPasswords) );

    Win32Err = DsRolepEncryptPasswordStart( lpServer,
                                            Passwords,
                                            NELEMENTS(Passwords),
                                            &Handle,
                                            &RedirHandle,
                                            NULL,
                                            EncryptedPasswords );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    RpcTryExcept {

        Win32Err = DsRolerDemoteDc( Handle,
                                      ( LPWSTR )lpDnsDomainName,
                                      ServerRole,
                                      ( LPWSTR )lpAccount,
                                      EncryptedPasswords[DSROLEP_DEMOTE_PWD_INDEX],
                                      Options,
                                      fLastDcInDomain,
                                      cRemoveNCs,
                                      pszRemoveNCs,
                                      EncryptedPasswords[DSROLEP_DEMOTE_ADMIN_PWD_INDEX],
                                      ( PDSROLER_HANDLE )DsOperationHandle );


    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepEncryptPasswordEnd( Handle,
                               RedirHandle,
                               EncryptedPasswords,
                               NELEMENTS(EncryptedPasswords) );

    return( Win32Err );
}


DWORD
WINAPI
DsRoleGetDcOperationProgress(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLE_SERVEROP_STATUS *ServerOperationStatus
    )
/*++

Routine Description:

    Gets the progress of the currently running operation

Arguments:

    lpServer - Server to remote the call to

    DsOperationHandle - Handle of currently running operation.  Returned by one of the DsRoleDcAs
        apis

    ServerOperationStatus - Where the current operation status is returned.  Must be freed via
        MIDL_user_free (or DsRoleFreeMemory)

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PDSROLER_SERVEROP_STATUS ServerStatus = NULL;
    handle_t Handle = NULL;

    Win32Err = DsRolepServerBind( (PDSROLE_SERVER_NAME)lpServer,
                                  &Handle );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    RpcTryExcept {

        Win32Err = DsRolerGetDcOperationProgress(
                         Handle,
                         (PDSROLER_HANDLE)&DsOperationHandle,
                         &ServerStatus );

        if ( Win32Err == ERROR_SUCCESS || Win32Err == ERROR_IO_PENDING ) {

            *ServerOperationStatus = ( PDSROLE_SERVEROP_STATUS )ServerStatus;
        }

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepServerUnbind( (PDSROLE_SERVER_NAME)lpServer, Handle );

    return( Win32Err );
}



DWORD
WINAPI
DsRoleGetDcOperationResults(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLE_SERVEROP_RESULTS *ServerOperationResults
    )
/*++

Routine Description:

    Gets the final results of an attempted promotion/demotion operation

Arguments:

    lpServer - Server to remote the call to

    DsOperationHandle - Handle of currently running operation.  Returned by one of the DsRoleDcAs
        apis

    ServerOperationResults - Where the current operation result is returned.  Must be freed via
        MIDL_user_free (or DsRoleFreeMemory)

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PDSROLER_SERVEROP_RESULTS ServerResults = NULL;
    handle_t Handle = NULL;

    Win32Err = DsRolepServerBind( (PDSROLE_SERVER_NAME)lpServer,
                                  &Handle );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    RpcTryExcept {

        *ServerOperationResults = 0;
        Win32Err = DsRolerGetDcOperationResults(
                         Handle,
                         (PDSROLER_HANDLE)&DsOperationHandle,
                         &ServerResults );

        if ( Win32Err == ERROR_SUCCESS ) {

            *ServerOperationResults = ( PDSROLE_SERVEROP_RESULTS )ServerResults;
        }

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepServerUnbind( (PDSROLE_SERVER_NAME)lpServer, Handle );

    return( Win32Err );
}



DWORD
WINAPI
DsRoleGetPrimaryDomainInformation(
    IN LPCWSTR lpServer OPTIONAL,
    IN DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PBYTE *Buffer )
/*++

Routine Description:

    Gets information on the machine

Arguments:

    lpServer - Server to remote the call to

    InfoLevel - What level of information is being requested.  Currently supported levels are:
        DsRolePrimaryDomainInfoBasic

    Buffer - Where the information is returned.  The returned pointer should be cast to the
        appropriate type for the info level passed in.  The returned buffer should be freed via
        MIDL_user_free (or DsRoleFreeMemory)


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PDSROLER_PRIMARY_DOMAIN_INFORMATION PrimaryDomainInfo = NULL;
    handle_t Handle = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    if ( Buffer == NULL ) {

        return( ERROR_INVALID_PARAMETER );
    }

    Win32Err = DsRolepGetPrimaryDomainInfoServerBind( (PDSROLE_SERVER_NAME)lpServer,
                                                      &Handle );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    if ( NULL == Handle) {

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    RpcTryExcept {

        *Buffer = NULL;
        Win32Err = DsRolerGetPrimaryDomainInformation(
                         Handle,
                         InfoLevel,
                         &PrimaryDomainInfo );

        *Buffer = ( PBYTE )PrimaryDomainInfo;

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Status = I_RpcMapWin32Status( RpcExceptionCode() );
        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;

    
    DsRolepServerUnbind( (PDSROLE_SERVER_NAME)lpServer, Handle );
    
    //
    // If this fails because we are calling a downlevel server, cobble up the information here
    //
    if ( ( Status == RPC_NT_UNKNOWN_IF || Status == RPC_NT_PROCNUM_OUT_OF_RANGE ) &&
         InfoLevel == DsRolePrimaryDomainInfoBasic ) {

         Win32Err = DsRolepGetPrimaryDomainInformationDownlevel( ( LPWSTR )lpServer, Buffer );

    }




    return( Win32Err );
}



DWORD
WINAPI
DsRoleCancel(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_SERVEROP_HANDLE DsOperationHandle
    )
/*++

Routine Description:

    Cancels a currently running operation

Arguments:

    lpServer - Server to remote the call to

    DsOperationHandle - Handle of currently running operation.  Returned by one of the DsRoleDcAs
        apis


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;

    Win32Err = DsRolepServerBind( (PDSROLE_SERVER_NAME)lpServer,
                                  &Handle );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    RpcTryExcept {

        Win32Err = DsRolerCancel( Handle,
                                  ( PDSROLER_HANDLE )&DsOperationHandle );

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepServerUnbind( (PDSROLE_SERVER_NAME)lpServer, Handle );

    return( Win32Err );
}


DWORD
WINAPI
DsRoleIfmHandleFree(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_IFM_OPERATION_HANDLE * pIfmHandle
    )
/*++

Routine Description:

    Cancels a currently running operation

Arguments:

    lpServer - Server to remote the call to

    DsOperationHandle - Handle of currently running operation.  Returned by one of the DsRoleDcAs
        apis


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;

    Win32Err = DsRolepServerBind( (PDSROLE_SERVER_NAME)lpServer,
                                  &Handle );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    RpcTryExcept {

        Win32Err = DsRolerIfmHandleFree( Handle,
                                         ( DSROLER_IFM_HANDLE ) pIfmHandle );

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepServerUnbind( (PDSROLE_SERVER_NAME)lpServer, Handle );

    return( Win32Err );
}



DWORD
WINAPI
DsRoleServerSaveStateForUpgrade(
    IN LPCWSTR lpAnswerFile OPTIONAL
    )
/*++

Routine Description:

    This function is to be invoked during setup and saves the required server state to
    complete the promotion following the reboot.  Following the successful completion
    of this API call, the server will be demoted to a member server in the same domain.

Arguments:

    lpAnswerFile -- Optional path to an answer file to be used by DCPROMO when it is
        invoked to do the upgrade


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;

    Win32Err = DsRolepServerBind( NULL,
                                  &Handle );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    RpcTryExcept {

        Win32Err = DsRolerServerSaveStateForUpgrade( Handle, ( LPWSTR )lpAnswerFile );

    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepServerUnbind( NULL, Handle );

    return( Win32Err );
}


DWORD
WINAPI
DsRoleUpgradeDownlevelServer(
    IN  LPCWSTR lpDnsDomainName,
    IN  LPCWSTR lpSiteName,
    IN  LPCWSTR lpDsDatabasePath,
    IN  LPCWSTR lpDsLogPath,
    IN  LPCWSTR lpSystemVolumeRootPath,
    IN  LPCWSTR lpParentDnsDomainName OPTIONAL,
    IN  LPCWSTR lpParentServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  LPCWSTR lpDsRepairPassword OPTIONAL,
    IN  ULONG Options,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    )
/*++

Routine Description:

    This routine process the information saved from a DsRoleServerSaveStateForUpgrade to
    promote a downlevel (NT4 or previous) server to an NT5 DC

Arguments:

    lpDnsDomainName - Dns domain name of the domain to install

    SiteName - Name of the site this DC should belong to

    lpDsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    lpDsLogPath - Absolute path on the local machine where the Ds log files should go

    lpSystemVolumeRootPath - Absolute path on the local machine which will be the root of
        the system volume.

    lpParentDnsDomainName - Optional.  If present, set this domain up as a child of the
        specified domain

    lpParentServer - Optional.  If present, use this server in the parent domain to replicate
        the required information from

    lpAccount - User account to use when setting up as a child domain

    lpPassword - Password to use with the above account
    
    lpDsRepairPassword - Password to use for the admin account of the repair mode

    Options - Options to control the creation of the domain

    DsOperationHandle - Handle to the operation is returned here.


Return Values:

    ERROR_SUCCESS - Success

--*/
{

    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;
    HANDLE RedirHandle = NULL;

#define DSROLEP_UPGRADE_PWD_INDEX              0
#define DSROLEP_UPGRADE_DS_REPAIR_PWD_INDEX    1
#define DSROLEP_UPGRADE_MAX_PWD_COUNT          2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_UPGRADE_MAX_PWD_COUNT];
    LPCWSTR Passwords[DSROLEP_UPGRADE_MAX_PWD_COUNT];

    Passwords[DSROLEP_UPGRADE_PWD_INDEX]   = lpPassword;
    Passwords[DSROLEP_UPGRADE_DS_REPAIR_PWD_INDEX] = lpDsRepairPassword;
    RtlZeroMemory( EncryptedPasswords, sizeof(EncryptedPasswords) );

    Win32Err = DsRolepEncryptPasswordStart( NULL,
                                            Passwords,
                                            NELEMENTS(Passwords),
                                            &Handle,
                                            &RedirHandle,
                                            NULL,
                                            EncryptedPasswords );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }


    RpcTryExcept {

        Win32Err = DsRolerUpgradeDownlevelServer( Handle,
                                                  ( LPWSTR )lpDnsDomainName,
                                                  ( LPWSTR )lpSiteName,
                                                  ( LPWSTR )lpDsDatabasePath,
                                                  ( LPWSTR )lpDsLogPath,
                                                  ( LPWSTR )lpSystemVolumeRootPath,
                                                  ( LPWSTR )lpParentDnsDomainName,
                                                  ( LPWSTR )lpParentServer,
                                                  ( LPWSTR )lpAccount,
                                                  EncryptedPasswords[DSROLEP_UPGRADE_PWD_INDEX],
                                                  EncryptedPasswords[DSROLEP_UPGRADE_DS_REPAIR_PWD_INDEX],
                                                  Options,
                                                  ( PDSROLER_HANDLE )DsOperationHandle );
        
    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepEncryptPasswordEnd( Handle,
                               RedirHandle,
                               EncryptedPasswords,
                               NELEMENTS(EncryptedPasswords) );


    return( Win32Err );
}


DWORD
WINAPI
DsRoleAbortDownlevelServerUpgrade(
    IN LPCWSTR lpAdminPassword,
    IN LPCWSTR lpAccount, OPTIONAL
    IN LPCWSTR lpPassword, OPTIONAL
    IN ULONG Options
    )
/*++

Routine Description:

    This routine cleans up the information saved from a DsRoleSaveServerStateForUpgrade call,
    leaving the machine as a member or standalone server

Arguments:

    lpAdminPassword - New local administrator account password

    lpAccount - User account to use when setting up as a child domain

    lpPassword - Password to use with the above account


Return Values:

    ERROR_SUCCESS - Success

--*/
{

    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;
    HANDLE RedirHandle = NULL;

#define DSROLEP_ABORT_PWD_INDEX         0
#define DSROLEP_ABORT_ADMIN_PWD_INDEX   1
#define DSROLEP_ABORT_MAX_PWD_COUNT     2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_ABORT_MAX_PWD_COUNT];
    LPCWSTR Passwords[DSROLEP_ABORT_MAX_PWD_COUNT];

    Passwords[DSROLEP_ABORT_PWD_INDEX]   = lpPassword;
    Passwords[DSROLEP_ABORT_ADMIN_PWD_INDEX] = lpAdminPassword;
    RtlZeroMemory( EncryptedPasswords, sizeof(EncryptedPasswords) );

    Win32Err = DsRolepEncryptPasswordStart( NULL,
                                            Passwords,
                                            NELEMENTS(Passwords),
                                            &Handle,
                                            &RedirHandle,
                                            NULL,
                                            EncryptedPasswords );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    RpcTryExcept {

        Win32Err = DsRolerAbortDownlevelServerUpgrade( Handle,
                                                       ( LPWSTR )lpAccount,
                                                       EncryptedPasswords[DSROLEP_ABORT_PWD_INDEX],
                                                       EncryptedPasswords[DSROLEP_ABORT_ADMIN_PWD_INDEX],
                                                       Options );
    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;


    DsRolepEncryptPasswordEnd( Handle,
                               RedirHandle,
                               EncryptedPasswords,
                               NELEMENTS(EncryptedPasswords) );


    return( Win32Err );
}

DWORD
WINAPI
DsRoleGetDatabaseFacts(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpRestorePath,
    OUT LPWSTR *lpDNSDomainName,
    OUT PULONG State,
    OUT DSROLE_IFM_OPERATION_HANDLE * pIfmHandle
    )
/*++

Routine Description:

    This function is the RPC procedure exposed to setup the server side
    IFM handle DsRolepCurrentIfmOperationHandle, which caches the information
    we'll need from the IFM system's registry.  This function also returns
    the relevant subset of this IFM system information to the caller (dcpromo).
    
    Note: We do this only once, because in the case that the IFM registry
    is in a non-writeable location (such as a CD), we will need to copy off
    the registry to a temporary location to use it.
    
    This function returns to the caller:
    1. the way the syskey is stored (State)
    2. the domain that the database came from (lpDNSDomainName)
    3. where the backup was taken from a GC or not (State)

Arguments:

    lpServer - The server to get the Facts from

    lpRestorePath - The location of the restored files.
    
    lpDNSDomainName - This parameter will recieve the name of the domain that this backup came
                      from

    State - The return Values that report How the syskey is stored and If the back was likely
              taken form a GC or not.

    pIfmHandle - Pointer to the IFM handle handed back.  This is primarily used
        to "free" the IFM System Info.


Return Values:

    Win32 Error

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;

    if(lpDNSDomainName == NULL ||
       IsBadWritePtr(lpDNSDomainName, sizeof(LPWSTR)) ||
       State == NULL ||
       IsBadWritePtr(State, sizeof(DWORD)) ||
       pIfmHandle == NULL ||
       IsBadWritePtr(pIfmHandle, sizeof(void *)) ){
        return ERROR_INVALID_PARAMETER;
    }

    Win32Err = DsRolepServerBind( (PDSROLE_SERVER_NAME)lpServer,
                                  &Handle );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );                     
    }
    
    RpcTryExcept {

        Win32Err = DsRolerGetDatabaseFacts( Handle,
                                          ( LPWSTR )lpRestorePath,
                                          ( LPWSTR * )lpDNSDomainName,
                                          ( PULONG )State,
                                          ( DSROLER_IFM_HANDLE * ) pIfmHandle );
    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;

    DsRolepServerUnbind( (PDSROLE_SERVER_NAME)lpServer, Handle );


    return Win32Err;
}



//
// Local functions
//
DWORD
DsRolepGetPrimaryDomainInformationDownlevel(
    IN LPWSTR Server,
    OUT PBYTE *Buffer
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle;
    PPOLICY_PRIMARY_DOMAIN_INFO PDI = NULL;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRole = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO ADI = NULL;
    UNICODE_STRING UnicodeServer;
    OBJECT_ATTRIBUTES OA;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC PDIB = NULL;
    DSROLE_MACHINE_ROLE MachineRole = DsRole_RoleStandaloneServer;
    NT_PRODUCT_TYPE ProductType;

    Win32Err = DsRolepGetProductTypeForServer( Server, &ProductType );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }


    InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL);
    if ( Server ) {

        RtlInitUnicodeString( &UnicodeServer, Server );
    }

    Status = LsaOpenPolicy( Server ? &UnicodeServer : NULL,
                            &OA,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyPrimaryDomainInformation,
                                            ( PVOID * ) &PDI );

        if ( NT_SUCCESS( Status ) ) {

            switch ( ProductType ) {
            case NtProductWinNt:
                if ( PDI->Sid == NULL ) {

                    MachineRole = DsRole_RoleStandaloneWorkstation;

                } else {

                    MachineRole = DsRole_RoleMemberWorkstation;

                }
                break;

            case NtProductServer:
                if ( PDI->Sid == NULL ) {

                    MachineRole = DsRole_RoleStandaloneServer;

                } else {

                    MachineRole = DsRole_RoleMemberServer;

                }
                break;

            case NtProductLanManNt:

                Status = LsaQueryInformationPolicy( PolicyHandle,
                                                    PolicyLsaServerRoleInformation,
                                                    ( PVOID * )&ServerRole );
                if ( NT_SUCCESS( Status ) ) {

                    if ( ServerRole->LsaServerRole == PolicyServerRolePrimary ) {

                        //
                        // If we think we're a primary domain controller, we'll need to
                        // guard against the case where we're actually standalone during setup
                        //
                        Status = LsaQueryInformationPolicy( PolicyHandle,
                                                            PolicyAccountDomainInformation,
                                                            ( PVOID * )&ADI );
                        if ( NT_SUCCESS( Status ) ) {


                            if ( PDI->Sid == NULL ||
                                 ADI->DomainSid == NULL ||
                                 !RtlEqualSid( ADI->DomainSid, PDI->Sid ) ) {

                                MachineRole = DsRole_RoleStandaloneServer;

                            } else {

                                MachineRole = DsRole_RolePrimaryDomainController;

                            }
                        }


                    } else {

                        MachineRole = DsRole_RoleBackupDomainController;
                    }
                }

                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

        }

        //
        // Build the return buffer
        //
        if ( NT_SUCCESS( Status ) ) {

            PDIB = MIDL_user_allocate( sizeof( DSROLE_PRIMARY_DOMAIN_INFO_BASIC ) +
                                       PDI->Name.Length + sizeof( WCHAR ) );

            if ( PDIB == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                RtlZeroMemory( PDIB, sizeof( DSROLE_PRIMARY_DOMAIN_INFO_BASIC ) +
                                       PDI->Name.Length + sizeof( WCHAR ) );

                PDIB->MachineRole = MachineRole;
                PDIB->DomainNameFlat = ( LPWSTR ) ( ( PBYTE )PDIB +
                                                sizeof( DSROLE_PRIMARY_DOMAIN_INFO_BASIC ) );
                RtlCopyMemory( PDIB->DomainNameFlat, PDI->Name.Buffer, PDI->Name.Length );

                *Buffer = ( PBYTE )PDIB;
            }
        }

        LsaClose( PolicyHandle );

        LsaFreeMemory( PDI );

        if ( ADI != NULL ) {

            LsaFreeMemory( ADI );
        }

        if ( ServerRole != NULL ) {

            LsaFreeMemory( ServerRole );
        }
    }

    Win32Err = RtlNtStatusToDosError( Status );

    return( Win32Err );
}


DWORD
DsRolepGetProductTypeForServer(
    IN LPWSTR Server,
    IN OUT PNT_PRODUCT_TYPE ProductType
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR RegServer = NULL;
    HKEY RemoteKey, ProductKey;
    PBYTE Buffer = NULL;
    ULONG Type, Size = 0;



    if ( Server == NULL ) {

        if ( RtlGetNtProductType( ProductType ) == FALSE ) {

            Win32Err = RtlNtStatusToDosError( STATUS_UNSUCCESSFUL );

        }

    } else {

        if ( wcslen( Server ) > 2 && *Server == L'\\' && *( Server + 1 ) == L'\\' ) {

            RegServer = Server;

        } else {

            RegServer = LocalAlloc( LMEM_FIXED, ( wcslen( Server ) + 3 ) * sizeof( WCHAR ) );

            if ( RegServer ) {

                swprintf( RegServer, L"\\\\%ws", Server );

            } else {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            }
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = RegConnectRegistry( RegServer,
                                           HKEY_LOCAL_MACHINE,
                                           &RemoteKey );

            if ( Win32Err == ERROR_SUCCESS ) {

                Win32Err = RegOpenKeyEx( RemoteKey,
                                         L"system\\currentcontrolset\\control\\productoptions",
                                         0,
                                         KEY_READ,
                                         &ProductKey );

                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = RegQueryValueEx( ProductKey,
                                                L"ProductType",
                                                0,
                                                &Type,
                                                0,
                                                &Size );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Buffer = LocalAlloc( LMEM_FIXED, Size );

                        if ( Buffer ) {

                            Win32Err = RegQueryValueEx( ProductKey,
                                                        L"ProductType",
                                                        0,
                                                        &Type,
                                                        Buffer,
                                                        &Size );

                            if ( Win32Err == ERROR_SUCCESS ) {

                                if ( !_wcsicmp( ( PWSTR )Buffer, L"LanmanNt" ) ) {

                                    *ProductType = NtProductLanManNt;

                                } else if ( !_wcsicmp( ( PWSTR )Buffer, L"ServerNt" ) ) {

                                    *ProductType = NtProductServer;

                                } else if ( !_wcsicmp( ( PWSTR )Buffer, L"WinNt" ) ) {

                                    *ProductType = NtProductWinNt;

                                } else {

                                    Win32Err = ERROR_UNKNOWN_PRODUCT;
                                }
                            }

                            LocalFree( Buffer );

                        } else {

                            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    RegCloseKey( ProductKey );
                }


                RegCloseKey( RemoteKey );
            }

        }

        if ( RegServer != Server ) {

            LocalFree( RegServer );
        }
    }

    return( Win32Err );

}

NTSTATUS
DsRolepRandomFill(
    IN ULONG BufferSize,
    IN OUT PUCHAR Buffer
)
/*++

Routine Description:

    This routine fills a buffer with random data.

Parameters:

    BufferSize - Length of the input buffer, in bytes.

    Buffer - Input buffer to be filled with random data.

Return Values:

    Errors from NtQuerySystemTime()


--*/
{
    if( RtlGenRandom(Buffer, BufferSize) )
    {
        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;
}

DWORD
DsRolepEncryptPasswordStart(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR *Passwords,
    IN ULONG   Count,
    OUT RPC_BINDING_HANDLE *RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT OPTIONAL PUSER_SESSION_KEY pUserSessionKey,
    IN OUT PDSROLEPR_ENCRYPTED_USER_PASSWORD *EncryptedUserPasswords
    )
/*++

Routine Description:

    This routine takes a number of cleartext unicode NT password from the user,
    and encrypts them with the session key.
    
    This routine's algorithm was taken from CliffV's work when encrypting the
    passwords for the NetrJoinDomain2 interface.

Parameters:

    ServerName - UNC server name of the server to remote the API to

    Passwords - the cleartext unicode NT passwords.
    
    Count - the number of password

    RpcBindingHandle - RPC handle used for acquiring a session key.

    RedirHandle - Returns a handle to the redir.  Since RpcBindingHandles don't represent
        and open connection to the server, we have to ensure the connection stays open
        until the server side has a chance to get this same UserSessionKey.  The only
        way to do that is to keep the connect open.

        Returns NULL if no handle is needed.
        
    UserSessionKey - OPTIONAL - Session Key used to encrypt passwords
    
    EncryptedUserPassword - receives the encrypted cleartext passwords.
        If lpPassword is NULL, a NULL is returned for that entry.

Return Values:

    If this routine returns NO_ERROR, the returned data must be freed using
        LocalFree.


--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    USER_SESSION_KEY UserSessionKey;
    PDSROLEPR_USER_PASSWORD UserPassword = NULL;
    ULONG PasswordSize;
    ULONG i;

    //
    // Initialization
    //

    *RpcBindingHandle = NULL;
    *RedirHandle = NULL;
    for ( i = 0; i < Count; i++ ) {
        EncryptedUserPasswords[i] = NULL;
    }

    //
    // Verify parameters
    //
    for ( i = 0; i < Count; i++ ) {
        if ( Passwords[i] ) {
            PasswordSize = wcslen( Passwords[i] ) * sizeof(WCHAR);
            if ( PasswordSize > DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
                WinError = ERROR_PASSWORD_RESTRICTION;
                goto Cleanup;
            }
        }
    }

    //
    // Get an RPC handle to the server.
    //

    WinError = DsRolepServerBind( (PDSROLE_SERVER_NAME) ServerName,
                                  RpcBindingHandle );

    if ( ERROR_SUCCESS != WinError ) {
        goto Cleanup;
    }

    //
    // Get the session key.
    //

    NtStatus = RtlGetUserSessionKeyClientBinding(
                   *RpcBindingHandle,
                   RedirHandle,
                   &UserSessionKey );

    if ( !NT_SUCCESS(NtStatus) ) {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //Return the UserSessionKey if requested
    if (pUserSessionKey) {
        CopyMemory(pUserSessionKey, &UserSessionKey, sizeof(UserSessionKey));
    }

    //
    // Encrypt the passwords
    //
    for ( i = 0; i < Count; i++ ) {
        

        if ( NULL == Passwords[i] ) {
            // Nothing to encrypt
            continue;
        }

        PasswordSize = wcslen( Passwords[i] ) * sizeof(WCHAR);

        //
        // Allocate a buffer to encrypt and fill it in.
        //
    
        UserPassword = LocalAlloc( 0, sizeof(DSROLEPR_USER_PASSWORD) );
    
        if ( UserPassword == NULL ) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    
        //
        // Copy the password into the tail end of the buffer.
        //
    
        RtlCopyMemory(
            ((PCHAR) UserPassword->Buffer) +
                (DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                PasswordSize,
            Passwords[i],
            PasswordSize );
    
        UserPassword->Length = PasswordSize;
    
        //
        // Fill the front of the buffer with random data
        //
    
        NtStatus = DsRolepRandomFill(
                    (DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        PasswordSize,
                    (PUCHAR) UserPassword->Buffer );
    
        if ( !NT_SUCCESS(NtStatus) ) {
            WinError = RtlNtStatusToDosError( NtStatus );
            goto Cleanup;
        }
    
        NtStatus = DsRolepRandomFill(
                    DSROLE_OBFUSCATOR_LENGTH,
                    (PUCHAR) UserPassword->Obfuscator );

        if ( !NT_SUCCESS(NtStatus) ) {
            WinError = RtlNtStatusToDosError( NtStatus );
            goto Cleanup;
        }
    
    
        //
        // The UserSessionKey is the same for the life of the session.  RC4'ing multiple
        //  strings with a single key is weak (if you crack one you've cracked them all).
        //  So compute a key that's unique for this particular encryption.
        //
        //
    
        MD5Init(&Md5Context);
    
        MD5Update( &Md5Context, (LPBYTE)&UserSessionKey, sizeof(UserSessionKey) );
        MD5Update( &Md5Context, UserPassword->Obfuscator, sizeof(UserPassword->Obfuscator) );
    
        MD5Final( &Md5Context );
    
        rc4_key( &Rc4Key, MD5DIGESTLEN, Md5Context.digest );

        //
        // Encrypt it.
        //  Don't encrypt the obfuscator.  The server needs that to compute the key.
        //
    
        rc4( &Rc4Key, sizeof(UserPassword->Buffer)+sizeof(UserPassword->Length), (LPBYTE) UserPassword->Buffer );

        EncryptedUserPasswords[i] = (PDSROLEPR_ENCRYPTED_USER_PASSWORD) UserPassword;
        UserPassword = NULL;

    }

    WinError = ERROR_SUCCESS;

Cleanup:

    if ( WinError != ERROR_SUCCESS ) {
        if ( UserPassword != NULL ) {
            LocalFree( UserPassword );
        }
        if ( *RpcBindingHandle != NULL ) {
            DsRolepServerUnbind( NULL, *RpcBindingHandle );
            *RpcBindingHandle = NULL;
        }
        if ( *RedirHandle != NULL ) {
            NtClose( *RedirHandle );
            *RedirHandle = NULL;
        }
        for ( i = 0; i < Count; i++ ) {
            if ( EncryptedUserPasswords[i] ) {
                LocalFree( EncryptedUserPasswords[i] );
                EncryptedUserPasswords[i] = NULL;
            }
        }
    }

    return WinError;
}


VOID
DsRolepEncryptPasswordEnd(
    IN RPC_BINDING_HANDLE RpcBindingHandle,
    IN HANDLE RedirHandle OPTIONAL,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD *EncryptedUserPasswords OPTIONAL,
    IN ULONG Count
    )
/*++

Routine Description:

    This routine takes the variables returned by DsRolepEncryptPasswordStart and
    frees them.

Parameters:

    RpcBindingHandle - RPC handle used for acquiring a session key.

    RedirHandle - Handle to the redirector

    EncryptedUserPasswords - the encrypted cleartext passwords.
    
    Count - the number of passwords

Return Values:

--*/
{
    ULONG i;

    //
    // Free the RPC binding handle.
    //

    if ( RpcBindingHandle != NULL ) {
        (VOID) DsRolepServerUnbind ( NULL, RpcBindingHandle );
    }

    //
    // Close the redir handle.
    //

    if ( RedirHandle != NULL ) {
        NtClose( RedirHandle );
    }

    //
    // Free the encrypted passwords.
    //

    for ( i = 0; i < Count; i++ ) {
        if ( EncryptedUserPasswords[i] != NULL ) {
            LocalFree( EncryptedUserPasswords[i] );
        }
    }

    return;
}

DWORD
DsRolepHashkey(
    IN OUT LPWSTR key,
    OUT PUNICODE_STRING Hash
)
/*++

    Routine Description

    This routine is used to store the boot type
    in the registry

    Paramaeters

        key - the user passed in Key
        
        Hash - the hash of the key

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    MD5_CTX Md5;
    if (!key) {
        return ERROR_INVALID_PARAMETER;
    }

    MD5Init( &Md5 );
    MD5Update( &Md5, (PUCHAR) key, wcslen(key)*sizeof(WCHAR) );
    MD5Final( &Md5 );

    RtlSecureZeroMemory( key, wcslen(key)*sizeof(WCHAR) );

    Hash->Buffer = (LPWSTR) MIDL_user_allocate(SYSKEY_SIZE);
    if (!Hash->Buffer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlCopyMemory(Hash->Buffer, Md5.digest, SYSKEY_SIZE);
    RtlSecureZeroMemory( Md5.digest, SYSKEY_SIZE );
    Hash->Length=SYSKEY_SIZE;
    Hash->MaximumLength=SYSKEY_SIZE;
    
    return ERROR_SUCCESS;
}

DWORD
DsRolepEncryptHash(
    IN PUSER_SESSION_KEY UserSessionKey,
    IN OUT PUNICODE_STRING Syskey,
    OUT PDSROLEPR_ENCRYPTED_HASH EncryptedSyskey
    )
/*++

    Routine Description

    This routine is used to store the boot type
    in the registry

    Paramaeters

        NewType Indicates the new boot type

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    
    //Init the buffer
    if (EncryptedSyskey) {
        EncryptedSyskey->EncryptedHash.Buffer = NULL;
    } else {
        WinError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //parameter checking
    //
    if ( !Syskey || !Syskey->Buffer || (Syskey->Length < 1) 
         || ! UserSessionKey) {
        WinError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //Init PDSROLEPR_ENCRYPTED_HASH structure
    EncryptedSyskey->EncryptedHash.Buffer = Syskey->Buffer;
    EncryptedSyskey->EncryptedHash.Length = Syskey->Length;
    EncryptedSyskey->EncryptedHash.MaximumLength = Syskey->MaximumLength;

    //Clear out the Syskey
    RtlSecureZeroMemory(Syskey,sizeof(*Syskey));
    
    //Create a Random Salt
    NtStatus = DsRolepRandomFill(
                DSROLE_SALT_LENGTH,
                EncryptedSyskey->Salt );

    if ( !NT_SUCCESS(NtStatus) ) {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //
    // The UserSessionKey is the same for the life of the session.  RC4'ing multiple
    //  strings with a single key is weak (if you crack one you've cracked them all).
    //  So compute a key that's unique for this particular encryption.
    //
    //

    MD5Init(&Md5Context);

    MD5Update( &Md5Context, (LPBYTE)UserSessionKey, sizeof(*UserSessionKey) );
    MD5Update( &Md5Context, EncryptedSyskey->Salt, sizeof(EncryptedSyskey->Salt) );

    MD5Final( &Md5Context );

    //
    // Encrypt it.
    //  Don't encrypt the salt.  The server needs that to compute the key.
    //
    rc4_key( &Rc4Key, MD5DIGESTLEN, Md5Context.digest );
    rc4( &Rc4Key, EncryptedSyskey->EncryptedHash.Length, (LPBYTE) EncryptedSyskey->EncryptedHash.Buffer );

    WinError = ERROR_SUCCESS;

Cleanup:

    if ( ERROR_SUCCESS != WinError ) {
        if (Syskey && Syskey->Buffer) {
             MIDL_user_free(Syskey->Buffer);
        }
        else if (EncryptedSyskey && EncryptedSyskey->EncryptedHash.Buffer) {
            MIDL_user_free(EncryptedSyskey->EncryptedHash.Buffer);
        }
    }

    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\cancel.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition

#include "cancel.h"

DWORD
DsRolepCancel(
    BOOL BlockUntilDone
    )
/*++

Routine Description:

    This routine will cancel a currently running operation

Arguments:

    BlockUntilDone - if TRUE, then this call waits for the current operation to
                     complete before returning. Otherwise return without waiting

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    BOOL     fWaitForCancelToFinish = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Canceling current operation...\n" ));

    //
    // Grab the global lock
    //
    LockOpHandle();

    //
    // Determine if we are in a cancelable state
    //
    if (  (DsRolepCurrentOperationHandle.OperationState == DSROLEP_FINISHED)
       || (DsRolepCurrentOperationHandle.OperationState == DSROLEP_CANCELING) ) {

        //
        // Cancel is happening or just finished, just leave
        //
        Win32Err = ERROR_SUCCESS;
        fWaitForCancelToFinish = FALSE;

        DsRolepLogPrint(( DEB_TRACE, "Cancel already happened or the operation is finished.\n" ));

    } else if ( !( (DsRolepCurrentOperationHandle.OperationState == DSROLEP_RUNNING)
                 ||(DsRolepCurrentOperationHandle.OperationState == DSROLEP_RUNNING_NON_CRITICAL)) ) {

        //
        // Invalid state transition requested
        //
        Win32Err = ERROR_NO_PROMOTION_ACTIVE;

    } else {

        // Tell the ds to cancel

        //
        // N.B.  This callout to the ds is made under lock.
        //
        DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsInstallCancel );

        if ( ERROR_SUCCESS == Win32Err ) {

            Win32Err = ( *DsrNtdsInstallCancel )();

        }

        if ( ERROR_SUCCESS == Win32Err )
        {
            Status = NtSetEvent( DsRolepCurrentOperationHandle.CancelEvent, NULL );

            if ( !NT_SUCCESS( Status ) ) {

                Win32Err = RtlNtStatusToDosError( Status );

            } else {

                DsRolepCurrentOperationHandle.OperationState = DSROLEP_CANCELING;

            }

        } else {

            DsRolepLogOnFailure( Win32Err,
                                 DsRolepLogPrint(( DEB_ERROR,
                                                   "Unable to cancel the ds%lu\n",
                                                   Win32Err )) );
        }
    }

    //
    // Release the lock
    //
    UnlockOpHandle();

    //
    // Now, wait for the operation to complete
    //
    if ( Win32Err == ERROR_SUCCESS 
      && fWaitForCancelToFinish  
      && BlockUntilDone  ) {

        DsRolepLogPrint(( DEB_TRACE, "Waiting for the role change operation to complete\n" ));

        Status = NtWaitForSingleObject( DsRolepCurrentOperationHandle.CompletionEvent, TRUE, 0 );

        if ( !NT_SUCCESS( Status ) ) {

            Win32Err = RtlNtStatusToDosError( Status );
        }
    }

    DsRolepLogPrint(( DEB_TRACE, "Request for cancel returning %lu\n", Win32Err ));

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\dispatch.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    Implementation of the server side of the DsRole API's

Author:

    Colin Brace        (ColinBr)    April 5, 1999.

Environment:

    User Mode

Revision History:

    Reorg'ed from code written by
    
    Mac McLain          (MacM)       Feb 10, 1997

--*/

#include <setpch.h>
#include <dssetp.h>
#include <dsgetdc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <lsarpc.h>
#include <db.h>
#include <lsasrvmm.h>
#include <lsaisrv.h>
#include <loadfn.h>
#include <lmjoin.h>
#include <netsetup.h>
#include <lmcons.h>
#include <lmerr.h>
#include <icanon.h>
#include <dsrole.h>
#include <dsrolep.h>
#include <dsconfig.h>
#include <winbase.h>  //for RtlSecureZeroMemory

#include <crypt.h>
#include <rc4.h>
#include <md5.h>
#include <wxlpc.h>

#include "secure.h"
#include "threadman.h"
#include "upgrade.h"
#include "cancel.h"


//
// Static global.  This flag is used to indicate that the system is installed enough to get
// us going.  There is no need to protect it, since it is only toggled from off to on
//
static BOOLEAN DsRolepSamInitialized = FALSE;

//
// Local forwards
//
DWORD
DsRolepWaitForSam(
    VOID
    );

DWORD
DsRolepCheckFilePaths(
    IN LPWSTR DsDirPath,
    IN LPWSTR DsLogPath,
    IN LPWSTR SysVolPath
    );

DWORD
DsRolepIsValidProductSuite(
    IN BOOL fNewForest,
    IN BOOL fReplica,
    IN LPWSTR DomainName
    );

DWORD
DsRolepDecryptPasswordsWithKey(
    IN handle_t RpcBindingHandle,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD * EncryptedPasswords,
    IN ULONG Count,
    IN OUT UNICODE_STRING *EncodedPasswords,
    OUT OPTIONAL PUSER_SESSION_KEY UserSessionKey,
    OUT PUCHAR Seed
    );

VOID
DsRolepFreePasswords(
    IN OUT UNICODE_STRING *Passwords,
    IN ULONG Count
    );

DWORD
DsRolepDecryptHash(
    IN PUSER_SESSION_KEY pUserSessionKey,
    IN PDSROLEPR_ENCRYPTED_HASH EncryptedBootkey,
    OUT PUNICODE_STRING *Bootkey
    );


//
// RPC dispatch routines
//
DWORD
DsRolerDcAsDc(
    IN  handle_t RpcBindingHandle,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FlatDomainName,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EDomainAdminPassword, OPTIONAL
    IN  LPWSTR SiteName OPTIONAL,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  LPWSTR SystemVolumeRootPath,
    IN  LPWSTR ParentDnsDomainName OPTIONAL,
    IN  LPWSTR ParentServer OPTIONAL,
    IN  LPWSTR Account OPTIONAL,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EPassword, OPTIONAL
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EDsRepairPassword, OPTIONAL
    IN  ULONG Options,
    OUT PDSROLER_HANDLE DsOperationHandle)
/*++

Routine Description:

    Rpc server routine for installing a server as a DC

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords       

    DnsDomainName - Dns domain name of the domain to install

    FlatDomainName - NetBIOS domain name of the domain to install

    EDomainAdminPassword - Encrypted password to set on the administrator account if it is a new install

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go

    SystemVolumeRootPath - Absolute path on the local machine which will be the root of
        the system volume.

    ParentDnsDomainName - Optional.  If present, set this domain up as a child of the
        specified domain

    Account - User account to use when setting up as a child domain

    EPassword - Encrypted password to use with the above account
    
    EDsRepairPassword - Encrypted password to use for the admin account of the repair mode

    Options - Options to control the creation of the domain

    DsOperationHandle - Handle to the operation is returned here.


Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A NULL return parameter was given

    ERROR_INVALID_STATE - This machine is not a server

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    DSROLEP_MACHINE_TYPE MachineRole;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs;
    UCHAR Seed = 0;

    HANDLE Policy = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC ServerInfo = NULL;

    BOOL fHandleInit = FALSE;

#define DSROLEP_DC_AS_DC_DA_PWD_INDEX        0
#define DSROLEP_DC_AS_DC_PWD_INDEX           1
#define DSROLEP_DC_AS_DC_DS_REPAIR_PWD_INDEX 2
#define DSROLEP_DC_AS_DC_MAX_PWD_COUNT       3

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_DC_AS_DC_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_DC_AS_DC_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_DC_AS_DC_DA_PWD_INDEX]        = EDomainAdminPassword;
    EncryptedPasswords[DSROLEP_DC_AS_DC_PWD_INDEX]           = EPassword;
    EncryptedPasswords[DSROLEP_DC_AS_DC_DS_REPAIR_PWD_INDEX] = EDsRepairPassword;

    RtlZeroMemory( Passwords, sizeof(Passwords) );

    //
    // Do some parameter checking
    //
    if ( !DsDatabasePath 
      || !DsLogPath 
      || !SystemVolumeRootPath  ) {

         return( ERROR_INVALID_PARAMETER );

    }

    //
    // UI Enforces MAX_PATH as the max length.
    //
    if ( (wcslen(DsDatabasePath)            > MAX_PATH) ||
         (wcslen(DsLogPath)                 > MAX_PATH) ||
         (wcslen(SystemVolumeRootPath)      > MAX_PATH) ) 
    {
        return( ERROR_INVALID_PARAMETER );    
    }

    //
    // Do some parameter checking
    //
    if (   !DnsDomainName 
        || !DsDatabasePath 
        || !DsLogPath 
        || !FlatDomainName 
        || !SystemVolumeRootPath ) {

         return( ERROR_INVALID_PARAMETER );

    }

    if ( !ParentDnsDomainName 
      && !SiteName )
    {
        // Site name must be specified when installing the root of the forest
        return ( ERROR_INVALID_PARAMETER );
    }

    if ( FLAG_ON( Options, DSROLE_DC_TRUST_AS_ROOT )
      && !ParentDnsDomainName  ) {

        //
        // When installing a new tree in an existing forest, 
        // the root domain DNS name must be present.
        //
        return ( ERROR_INVALID_PARAMETER );
    }

    if ( FLAG_ON( Options, DSROLE_DC_NO_NET )
      && ParentDnsDomainName ) {

        //
        // No net option when installing a child domain
        // does not make sense
        //
        return ( ERROR_INVALID_PARAMETER );
    }

    //
    // Do our necessary initializations
    //
    Win32Err = DsRolepInitializeOperationHandle( );
    if ( Win32Err != ERROR_SUCCESS ) {

        goto Cleanup;
    }
    fHandleInit = TRUE;

    //
    // Check the access of the caller
    //
    Win32Err = DsRolepCheckPromoteAccess( TRUE );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto Cleanup;
        
    }

    //
    // Init the logging
    //
    DsRolepInitializeLog();

    //
    // Check that the current OS configuration supports this request
    //
    Win32Err = DsRolepIsValidProductSuite((ParentDnsDomainName == NULL) ? TRUE : FALSE,
                                          FALSE,
                                          DnsDomainName);
    if ( ERROR_SUCCESS != Win32Err ) {
        goto Cleanup;
    }

    //
    // Dump the parameters to the log
    //

    DsRolepLogPrint(( DEB_TRACE,
                      "Promotion request for domain controller of new domain\n" ));

    DsRolepLogPrint(( DEB_TRACE,
                      "DnsDomainName  %ws\n",
                      DnsDomainName ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tFlatDomainName  %ws\n",
                      FlatDomainName ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSiteName  %ws\n",
                      DsRolepDisplayOptional( SiteName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSystemVolumeRootPath  %ws\n",
                      SystemVolumeRootPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tDsDatabasePath  %ws, DsLogPath  %ws\n",
                      DsDatabasePath, DsLogPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tParentDnsDomainName  %ws\n",
                      DsRolepDisplayOptional( ParentDnsDomainName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tParentServer  %ws\n",
                      DsRolepDisplayOptional( ParentServer ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tAccount %ws\n",
                      DsRolepDisplayOptional( Account ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tOptions  %lu\n",
                      Options ));

    //
    // Make sure that we are not a member of a domain
    //

    Win32Err = DsRolerGetPrimaryDomainInformation(NULL,
                                                  DsRolePrimaryDomainInfoBasic,
                                                  (PDSROLER_PRIMARY_DOMAIN_INFORMATION*)&ServerInfo);
    if (ERROR_SUCCESS == Win32Err) {
        ASSERT(ServerInfo);
        if(ServerInfo->MachineRole != DsRole_RoleStandaloneServer) {
            Win32Err = ERROR_CURRENT_DOMAIN_NOT_ALLOWED;
            DsRolepLogOnFailure( Win32Err,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "Verifying domain membership failed: %lu\n",
                                                   Win32Err )) );
            goto Cleanup;    
        }
    } else if (ERROR_SUCCESS == Win32Err){
        DsRoleFreeMemory(ServerInfo);
        ServerInfo = NULL;    
    } else {
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "DsRoleGetPrimaryDomainInformation failed: %lu\n",
                                               Win32Err )) );
        goto Cleanup;    
    }

    

    //
    // Verify the path names we are given
    //
    DsRolepLogPrint(( DEB_TRACE,"Validate supplied paths\n" ));
    Win32Err = DsRolepCheckFilePaths( DsDatabasePath,
                                      DsLogPath,
                                      SystemVolumeRootPath );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto Cleanup;
        
    }

    //
    // If we are doing a parent/child setup, verify our name
    //
    if (  ParentDnsDomainName &&
         !FLAG_ON( Options, DSROLE_DC_TRUST_AS_ROOT ) ) {

        DsRolepLogPrint(( DEB_TRACE, "Child domain creation -- check the new domain name is child of parent domain name.\n" ));

        Win32Err = DsRolepIsDnsNameChild( ParentDnsDomainName, DnsDomainName );
        if ( ERROR_SUCCESS != Win32Err ) {
            
            DsRolepLogOnFailure( Win32Err,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "Verifying the child domain dns name failed: %lu\n",
                                                   Win32Err )) );
            goto Cleanup;
        }

    }

    //
    // Validate the netbios domain name is not in use
    //
    DsRolepLogPrint(( DEB_TRACE,"Domain Creation -- check that the flat name is unique.\n" ));

    Win32Err = NetpValidateName( NULL,
                                 FlatDomainName,
                                 NULL,
                                 NULL,
                                 NetSetupNonExistentDomain );

    if ( FLAG_ON( Options, DSROLE_DC_NO_NET )
     && (Win32Err == ERROR_NETWORK_UNREACHABLE)) {

        //
        // See NT bug 386193.  This option allows a first DC in forest
        // to installed with no network (useful for evaluation)
        //
        DsRolepLogPrint(( DEB_TRACE,"Ignoring network unreachable status\n" ));

        Win32Err = ERROR_SUCCESS;
    }
    
    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Flat name validation of %ws failed with %lu\n",
                                               FlatDomainName,
                                               Win32Err )) );

        goto Cleanup;
    }

    // No workstations or domain controllers allowed

    Win32Err = DsRolepGetMachineType( &MachineRole );
    if ( Win32Err == ERROR_SUCCESS ) {

        switch ( MachineRole ) {
        case DSROLEP_MT_CLIENT:
        case DSROLEP_MT_MEMBER:

            Win32Err = ERROR_INVALID_SERVER_STATE;
            break;

        }
    }
    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_TRACE,"This operation is not valid on a workstation or domain controller\n" ));
        goto Cleanup;
    }

    //
    // At this point, we are good to go
    //
    DsRolepLogPrint(( DEB_TRACE,"Start the worker task\n" ));

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                NULL,
                                                &Seed );

    if ( ERROR_SUCCESS != Win32Err ) {

        goto Cleanup;
        
    }

    //
    // If everything is fine, go ahead and do the setup
    //
    Win32Err = DsRolepBuildPromoteArgumentBlock( DnsDomainName,
                                                 FlatDomainName,
                                                 SiteName,
                                                 DsDatabasePath,
                                                 DsLogPath,
                                                 NULL,
                                                 SystemVolumeRootPath,
                                                 NULL,
                                                 ParentDnsDomainName,
                                                 ParentServer,
                                                 Account,
                                                 &Passwords[DSROLEP_DC_AS_DC_PWD_INDEX],
                                                 &Passwords[DSROLEP_DC_AS_DC_DA_PWD_INDEX],
                                                 &Passwords[DSROLEP_DC_AS_DC_DS_REPAIR_PWD_INDEX],
                                                 Options,
                                                 Seed,
                                                 &PromoteArgs );

    DsRolepFreePasswords( Passwords,
                          NELEMENTS(Passwords) );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepSpinWorkerThread( DSROLEP_OPERATION_DC,
                                            ( PVOID )PromoteArgs );

        //
        // Once the thread has started, no more errors can occur in this
        // function
        //
        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepFreeArgumentBlock( &PromoteArgs, TRUE );
        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *DsOperationHandle = (DSROLER_HANDLE)&DsRolepCurrentOperationHandle;

    }

    //
    // That's it
    //

Cleanup:

    // Always reset to a known state
    if ( ERROR_SUCCESS != Win32Err && fHandleInit )
    {
        DsRolepResetOperationHandle( DSROLEP_IDLE );
    }

    if ( ServerInfo ) {
        DsRoleFreeMemory(ServerInfo);
        ServerInfo = NULL;
    }

    DsRolepLogPrint(( DEB_TRACE,"Request for promotion returning %lu\n", Win32Err ));

    return( Win32Err );
}




DWORD
DsRolerDcAsReplica(
    IN  handle_t RpcBindingHandle,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR ReplicaPartner,
    IN  LPWSTR SiteName OPTIONAL,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  LPWSTR RestorePath OPTIONAL,
    IN  LPWSTR SystemVolumeRootPath,
    IN  PDSROLEPR_ENCRYPTED_HASH lpEncryptedBootkey,
    IN  LPWSTR Account,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EPassword,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EDsRepairPassword,
    IN  ULONG Options,
    OUT PDSROLER_HANDLE DsOperationHandle)
/*++

Routine Description:

    Rpc server routine for installing a server a replica in an existing domain

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords

    DnsDomainName - Dns domain name of the domain to install into

    ReplicaPartner -  The name of a Dc within the existing domain, against which to replicate

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go

    SystemVolumeRootPath - Absolute path on the local machine which will be the root of
        the system volume.
        
    BootKey - needed for media installs where the password is not in the registry or on a disk
    
    cbBootKey - size of the bootkey

    Account - User account to use when setting up as a child domain

    EPassword - Encrypted password to use with the above account
    
    EDsRepairPassword - Encrypted password to use for the admin account of the repair mode

    Options - Options to control the creation of the domain

    DsOperationHandle - Handle to the operation is returned here.


Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A NULL return parameter was given

    ERROR_INVALID_STATE - This machine is not a server

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    DSROLEP_MACHINE_TYPE MachineRole;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs;
    USER_SESSION_KEY UserSessionKey;
    PUNICODE_STRING lpBootkey = NULL;
    UCHAR Seed;
    BOOL fLostRace;

#define DSROLEP_DC_AS_REPLICA_PWD_INDEX           0
#define DSROLEP_DC_AS_REPLICA_DS_REPAIR_PWD_INDEX 1
#define DSROLEP_DC_AS_REPLICA_MAX_PWD_COUNT       2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_DC_AS_REPLICA_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_DC_AS_REPLICA_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_DC_AS_REPLICA_PWD_INDEX]           = EPassword;
    EncryptedPasswords[DSROLEP_DC_AS_REPLICA_DS_REPAIR_PWD_INDEX] = EDsRepairPassword;

    RtlZeroMemory( Passwords, sizeof(Passwords) );

    //
    // Do some parameter checking
    //
    if ( !DnsDomainName 
      || !DsDatabasePath 
      || !DsLogPath 
      || !SystemVolumeRootPath
    ) {

         return( ERROR_INVALID_PARAMETER );

    }

    //
    // UI Enforces MAX_PATH as the max length.
    //
    if ( ( wcslen(DsDatabasePath)                > MAX_PATH) ||
         ( wcslen(DsLogPath)                     > MAX_PATH) ||
         ( (RestorePath && (wcslen(RestorePath)  > MAX_PATH)) ) ||
         ( wcslen(SystemVolumeRootPath)          > MAX_PATH) ) 
    {
        return( ERROR_INVALID_PARAMETER );    
    }

    //
    // Do our necessary initializations
    //
    Win32Err = DsRolepInitializeOperationHandle( );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepGetMachineType( &MachineRole );

        if ( Win32Err == ERROR_SUCCESS ) {

            switch ( MachineRole ) {
            case DSROLEP_MT_CLIENT:
            case DSROLEP_MT_MEMBER:

                DsRolepLogPrint(( DEB_TRACE,"This operation is not valid on a workstation or domain controller\n" ));
                Win32Err = ERROR_INVALID_SERVER_STATE;
                break;


            }
        }
    } 

    Win32Err = DsRolepCheckPromoteAccess( TRUE );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto Cleanup;
        
    }

    //
    // Init the logging
    //
    DsRolepInitializeLog();


    //
    // Check that the current OS configuration supports this request
    //
    Win32Err = DsRolepIsValidProductSuite(FALSE,
                                          TRUE,
                                          DnsDomainName);
    if ( ERROR_SUCCESS != Win32Err ) {
        goto Cleanup;
    }


    DsRolepLogPrint(( DEB_TRACE,
                      "Promotion request for replica domain controller\n" ));

    DsRolepLogPrint(( DEB_TRACE,
                      "DnsDomainName  %ws\n",
                      DnsDomainName ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tReplicaPartner  %ws\n",
                      DsRolepDisplayOptional( ReplicaPartner ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSiteName  %ws\n",
                      DsRolepDisplayOptional( SiteName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tDsDatabasePath  %ws, DsLogPath  %ws\n",
                      DsDatabasePath, DsLogPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSystemVolumeRootPath  %ws\n",
                      SystemVolumeRootPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tAccount %ws\n",
                      DsRolepDisplayOptional(Account) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tOptions  %lu\n",
                      Options ));

    //
    // Verify the path names we are given
    //

    DsRolepLogPrint(( DEB_TRACE,"Validate supplied paths\n" ));
    Win32Err = DsRolepCheckFilePaths( DsDatabasePath,
                                      DsLogPath,
                                      SystemVolumeRootPath );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto Cleanup;
        
    }

    if (RestorePath && Win32Err == ERROR_SUCCESS) {

        ASSERT(DsRolepCurrentOperationHandle.OperationState != DSROLEP_IDLE);

        // Grab the lock for the IFM info before Init Op handle.
        fLostRace = InterlockedCompareExchange(&(DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock),
                                               TRUE, 
                                               FALSE);

        if (fLostRace ||
            !DsRolepCurrentIfmOperationHandle.fIfmSystemInfoSet ||
            wcscmp(RestorePath, DsRolepCurrentIfmOperationHandle.IfmSystemInfo.wszRestorePath)) {
            // Something changed, the data (restore path) isn't the same as when
            // we initialized the handle for this restore operation!  Or we just
            // lost some sort of race, Dcpromo shouldn't be putting us in.
            ASSERT(!"inconsistency in model used to communicated with dcpromo.exe and lsasrv.dll");
            Win32Err = ERROR_INVALID_HANDLE;
        } 

        if (!fLostRace && Win32Err) {
            // We grabbed the lock but there was an error, so release
            // the lock, because we're not promoting.
            DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock = FALSE;
        }

    }

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                &UserSessionKey,
                                                &Seed );

    if ( Win32Err == ERROR_SUCCESS && lpEncryptedBootkey ) {

        Win32Err = DsRolepDecryptHash(&UserSessionKey,
                                      lpEncryptedBootkey,
                                      &lpBootkey);

    }

    //
    // If everything is fine, go ahead and do the setup
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_TRACE,"Start the worker task\n" ));

        Win32Err = DsRolepBuildPromoteArgumentBlock( DnsDomainName,
                                                     NULL,
                                                     SiteName,
                                                     DsDatabasePath,
                                                     DsLogPath,
                                                     RestorePath ? &(DsRolepCurrentIfmOperationHandle.IfmSystemInfo) : NULL,
                                                     SystemVolumeRootPath,
                                                     lpBootkey,
                                                     NULL,
                                                     ReplicaPartner,
                                                     Account,
                                                     &Passwords[DSROLEP_DC_AS_REPLICA_PWD_INDEX],
                                                     NULL,
                                                     &Passwords[DSROLEP_DC_AS_REPLICA_DS_REPAIR_PWD_INDEX],
                                                     Options,
                                                     Seed,
                                                     &PromoteArgs );
    
        DsRolepFreePasswords( Passwords,
                              NELEMENTS(Passwords) );
    
        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsRolepSpinWorkerThread( DSROLEP_OPERATION_REPLICA,
                                                ( PVOID )PromoteArgs );

            if ( Win32Err != ERROR_SUCCESS ) {

                DsRolepFreeArgumentBlock( &PromoteArgs, TRUE );
            }
        }

        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepResetOperationHandle( DSROLEP_IDLE );
        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *DsOperationHandle = (DSROLER_HANDLE)&DsRolepCurrentOperationHandle;

    }

Cleanup:

    DsRolepLogPrint(( DEB_TRACE,"Request for promotion returning %lu\n", Win32Err ));

    return( Win32Err );
}



DWORD
DsRolerDemoteDc(
    IN handle_t RpcBindingHandle,
    IN LPWSTR DnsDomainName OPTIONAL,
    IN DSROLE_SERVEROP_DEMOTE_ROLE ServerRole,
    IN LPWSTR Account OPTIONAL,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD EPassword,
    IN ULONG Options,
    IN BOOL LastDcInDomain,
    IN ULONG cRemoveNCs,
    IN LPCWSTR * pszRemoveNCs,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD EDomainAdminPassword,
    OUT PDSROLER_HANDLE DsOperationHandle
    )
/*++

Routine Description:

    Rpc server routine for demoting a dc to a server

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords                          

    DnsDomainName - Dns domain name of the domain to be demoted.  Null means all of the supported
        domain names

    ServerRole - The new role this machine should take

    Account - OPTIONAL User account to use when deleting the trusted domain object

    EPassword - Encrypted password to use with the above account

    Options - Options to control the demotion of the domain

    LastDcInDomain - If TRUE, the Dc being demoted is the last Dc in the domain.

    cRemoveNCs - Count of string pointers in pszRemoveNCs

    pszRemoveNCs - Array of (cRemoveNCs) strings. Strings are DNs of NDNCs to be removed

    EDomainAdminPassword - Encrypted password to set on the administrator account if it is a new install

    DsOperationHandle - Handle to the operation is returned here.


Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A NULL return parameter was given

    ERROR_INVALID_STATE - This machine is not a server

--*/
{
    DSROLEP_MACHINE_TYPE MachineRole;
    DWORD Win32Err;
    PDSROLEP_OPERATION_DEMOTE_ARGS DemoteArgs;
    UCHAR Seed;
    BOOL HandleInit = FALSE;

#define DSROLEP_DEMOTE_PWD_INDEX        0
#define DSROLEP_DEMOTE_ADMIN_PWD_INDEX  1
#define DSROLEP_DEMOTE_MAX_PWD_COUNT    2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_DEMOTE_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_DEMOTE_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_DEMOTE_PWD_INDEX] =       EPassword;
    EncryptedPasswords[DSROLEP_DEMOTE_ADMIN_PWD_INDEX] = EDomainAdminPassword;

    RtlZeroMemory( Passwords, sizeof(Passwords) );

    if (   (LastDcInDomain && (DsRoleServerMember == ServerRole))
        || ( (!LastDcInDomain && (DsRoleServerStandalone == ServerRole)) && !(Options&DSROLE_DC_FORCE_DEMOTE) )
        || ((Options&DSROLE_DC_FORCE_DEMOTE) && (DsRoleServerMember == ServerRole)) ){

        //
        // These configurations are not supported
        //
        return ERROR_INVALID_PARAMETER;
    }

    if ( (pszRemoveNCs == NULL) && (cRemoveNCs != 0) ) 
    {
        //
        // cRemoveNCs must be zero if pszRemoveNCs is NULL
        //
        return ERROR_INVALID_PARAMETER;    
    }

    //
    // Do our necessary initializations
    //
    Win32Err = DsRolepInitializeOperationHandle( );

    if ( Win32Err == ERROR_SUCCESS ) {

        HandleInit = TRUE;

        Win32Err = DsRolepGetMachineType( &MachineRole );

        if ( Win32Err == ERROR_SUCCESS ) {

            switch ( MachineRole ) {
            case DSROLEP_MT_CLIENT:
            case DSROLEP_MT_STANDALONE:

                DsRolepLogPrint(( DEB_TRACE,"This operation is only valid on a domain controller\n" ));
                Win32Err = ERROR_INVALID_SERVER_STATE;
                goto Cleanup;


            }
        }
    }

    //
    // Check the access right for demote
    //
    Win32Err = DsRolepCheckDemoteAccess( TRUE );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto Cleanup;
        
    }

    //
    // Initialize return value to NULL
    //

    *DsOperationHandle = NULL;

    DsRolepInitializeLog();

    DsRolepLogPrint(( DEB_TRACE,
                      "Request for demotion of domain controller\n" ));

    DsRolepLogPrint(( DEB_TRACE,
                      "DnsDomainName  %ws\n",
                      DsRolepDisplayOptional( DnsDomainName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tServerRole  %lu\n",
                      ServerRole ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tAccount %ws ",
                      DsRolepDisplayOptional( Account ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tOptions  %lu\n",
                      Options ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tLastDcInDomain  %S\n",
                      LastDcInDomain ? "TRUE" : "FALSE" ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tForced Demote  %S\n",
                      (Options&DSROLE_DC_FORCE_DEMOTE) ? "TRUE" : "FALSE" ));

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                NULL,
                                                &Seed );


    //
    // Spawn the demotion thread
    //
    if ( Win32Err == ERROR_SUCCESS ) {


        DsRolepLogPrint(( DEB_TRACE,"Start the worker task\n" ));

        Win32Err = DsRolepBuildDemoteArgumentBlock( ServerRole,
                                                    DnsDomainName,
                                                    Account,
                                                    &Passwords[DSROLEP_DEMOTE_PWD_INDEX],
                                                    Options,
                                                    ( BOOLEAN )LastDcInDomain,
                                                    cRemoveNCs,
                                                    (LPWSTR *) pszRemoveNCs,
                                                    &Passwords[DSROLEP_DEMOTE_ADMIN_PWD_INDEX],
                                                    Seed,
                                                    &DemoteArgs );

        DsRolepFreePasswords( Passwords,
                              NELEMENTS(Passwords) );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsRolepSpinWorkerThread( DSROLEP_OPERATION_DEMOTE,
                                                ( PVOID )DemoteArgs );

            if ( Win32Err != ERROR_SUCCESS ) {

                DsRolepFreeArgumentBlock( &DemoteArgs, FALSE );
            }
        }
    
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *DsOperationHandle = (DSROLER_HANDLE)&DsRolepCurrentOperationHandle;

    }

Cleanup:

    if ( ( Win32Err != ERROR_SUCCESS ) && HandleInit ) {

        DsRolepResetOperationHandle( DSROLEP_IDLE );

    }

    DsRolepLogPrint(( DEB_TRACE,"Request for demotion returning %lu\n", Win32Err ));

    return( Win32Err );
}



DWORD
DsRolerGetDcOperationProgress(
    IN PDSROLE_SERVER_NAME Server,
    IN PDSROLER_HANDLE DsOperationHandle,
    IN OUT PDSROLER_SERVEROP_STATUS *ServerOperationStatus
    )
/*++

Routine Description:

    Rpc server routine for determining the present state of the operation

Arguments:

    Server - Server the call was remoted to

    DsOperationHandle - Handle returned from a previous call

    ServerOperationStatus - Where the status information is returned

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_HANDLE - A bad Operation handle was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

     __try {

        if ( DsOperationHandle == NULL ||
             *DsOperationHandle != ( DSROLER_HANDLE )&DsRolepCurrentOperationHandle) {

           Win32Err = ERROR_INVALID_HANDLE;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err =  GetExceptionCode();
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepGetDcOperationProgress( ( PDSROLE_SERVEROP_HANDLE )DsOperationHandle,
                                                  ServerOperationStatus );
    }

    return( Win32Err );
}



DWORD
DsRolerGetDcOperationResults(
    IN PDSROLE_SERVER_NAME Server,
    IN PDSROLER_HANDLE DsOperationHandle,
    OUT PDSROLER_SERVEROP_RESULTS *ServerOperationResults
    )
/*++

Routine Description:

    Rpc server routine for determining the final results of the operation.  If the operation
    is not yet completed, this function will block until it does complete.

Arguments:

    Server - Server the call was remoted to

    DsOperationHandle - Handle returned from a previous call

    ServerOperationResults - Where the final operation results are returned.

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_HANDLE - A bad Operation handle was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

     __try {

        if ( DsOperationHandle == NULL ||
             *DsOperationHandle != ( DSROLER_HANDLE )&DsRolepCurrentOperationHandle) {

           Win32Err = ERROR_INVALID_HANDLE;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err =  GetExceptionCode();
    }

    if ( Win32Err == ERROR_SUCCESS ) {


        Win32Err = DsRolepGetDcOperationResults( ( PDSROLE_SERVEROP_HANDLE )DsOperationHandle,
                                                 ServerOperationResults );

        DsRolepCloseLog();
    }


    return( Win32Err );
}






DWORD
WINAPI
DsRolerDnsNameToFlatName(
    IN  LPWSTR Server OPTIONAL,
    IN  LPWSTR DnsName,
    OUT LPWSTR *FlatName,
    OUT PULONG StatusFlag
    )
/*++

Routine Description:

    Rpc server routine for determining the default flat (netbios) domain name for the given
    Dns domain name

Arguments:

    Server - Server the call was remoted to

    DnsName - Dns name to convert

    FlatName - Where the flat name is returned.  Alocated via MIDL_user_allocate

    StatusFlag - Where the status flag is returned

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad input or NULL return parameter was given
--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    if ( DnsName == NULL || FlatName == NULL || StatusFlag == NULL ) {

        return( ERROR_INVALID_PARAMETER );

    }

    Win32Err = DsRolepDnsNameToFlatName( DnsName,
                                         FlatName,
                                         StatusFlag );

    return( Win32Err );
}


#define GET_PDI_COPY_STRING_AND_INSERT( _unicode_, _buffer_ )                       \
if ( ( _unicode_)->Length == 0 ) {                                                  \
                                                                                    \
    ( _buffer_ ) = NULL;                                                            \
                                                                                    \
} else {                                                                            \
                                                                                    \
    ( _buffer_ ) = MIDL_user_allocate( (_unicode_)->Length + sizeof( WCHAR ) );     \
    if ( ( _buffer_ ) == NULL ) {                                                   \
                                                                                    \
        Win32Err = ERROR_NOT_ENOUGH_MEMORY;                                         \
        goto GetInfoError;                                                          \
                                                                                    \
    } else {                                                                        \
                                                                                    \
        BuffersToFree[ BuffersCnt++ ] = ( PBYTE )( _buffer_ );                      \
        RtlCopyMemory( ( _buffer_ ),                                                \
                       ( _unicode_ )->Buffer,                                       \
                       ( _unicode_ )->Length );                                     \
        ( _buffer_ )[ ( _unicode_ )->Length / sizeof( WCHAR ) ] = UNICODE_NULL;     \
    }                                                                               \
}

DWORD
WINAPI
DsRolerGetDatabaseFacts(
    IN  handle_t RpcBindingHandle,
    IN  LPWSTR lpRestorePath,
    OUT LPWSTR *lpDNSDomainName,
    OUT PULONG State,
    OUT DSROLER_IFM_HANDLE * pIfmHandle
    )
/*++

Routine Description:

    This function is the RPC procedure exposed to setup the server side
    IFM handle DsRolepCurrentIfmOperationHandle, which caches the information
    we'll need from the IFM system's registry.  This function also returns
    the relevant subset of this IFM system information to the caller (dcpromo).
    
    Note: We do this only once, because in the case that the IFM registry
    is in a non-writeable location (such as a CD), we will need to copy off
    the registry to a temporary location to use it.
    
    This function returns to the caller:
    1. the way the syskey is stored (State)
    2. the domain that the database came from (lpDNSDomainName)
    3. where the backup was taken from a GC or not (State)

Arguments:

    lpRestorePath - The location of the restored files.
    
    lpDNSDomainName - This parameter will recieve the name of the domain that this backup came
                      from

    State - The return Values that report How the syskey is stored and If the back was likely
              taken form a GC or not.
              
    pIfmHandle - Pointer to the IFM handle handed back.  This is primarily used
        to "free" the IFM System Info.


Return Values:

    Win32 Error

--*/
{
    DWORD Win32Err=ERROR_SUCCESS;
    DWORD fLostRace;
    DWORD cbSize;

    //
    // 1) Check parameters
    //
    Win32Err = DsRolepCheckPromoteAccess( FALSE );
    if ( ERROR_SUCCESS != Win32Err ) {
        return Win32Err;
    }      

    if( lpDNSDomainName == NULL || 
        IsBadWritePtr(lpDNSDomainName, sizeof(LPWSTR*)) ||
        State == NULL ||
        IsBadWritePtr(State, sizeof(DWORD)) ||
        pIfmHandle == NULL ||
        IsBadWritePtr(pIfmHandle, sizeof(DSROLER_IFM_HANDLE))
        ){
        ASSERT(!"inconsistency in model used to communicated with dcpromo.exe and lsasrv.dll");
        return(ERROR_INVALID_PARAMETER);
    }

    // Get the IFM Handle lock.
    fLostRace = InterlockedCompareExchange(&(DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock),
                                           TRUE, 
                                           FALSE);
    if (fLostRace ||
        DsRolepCurrentIfmOperationHandle.fIfmSystemInfoSet) {
        // Either we lost the race for the handle, or someone didn't
        // free before resetting the IFM sys info,in all cases we fail.
        ASSERT(!"inconsistency in model used to communicated with dcpromo.exe and lsasrv.dll");
        DsRolepLogPrint(( DEB_ERROR, "Couldn't get the IFM Handle lock during GetDbFacts().\n"));
        Win32Err = ERROR_INVALID_PARAMETER;
        if (!fLostRace) {
            // Won race, but erroring out.
            DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock = FALSE;
        }
        return(Win32Err);
    }

    //
    // 2) Get IFM System Info
    //
    // This sets up the Ifm operation context  with all the valueable
    // information from the IFM system's registry.
    //
    Win32Err =  DsRolepGetDatabaseFacts(lpRestorePath);
    
    //
    // 3) Set the out parameters
    //
    // If successful, the DsRolepCurrentIfmOperationHandle is setup.
    //
    if ( ERROR_SUCCESS == Win32Err ) {

        DsRolepCurrentIfmOperationHandle.fIfmSystemInfoSet = TRUE;

        // ASSERT( lpDNSDomainName && State...
        cbSize = wcslen(DsRolepCurrentIfmOperationHandle.IfmSystemInfo.wszDnsDomainName) + 1;
        cbSize *= sizeof(WCHAR);
        *lpDNSDomainName = MIDL_user_allocate(cbSize);
        if (*lpDNSDomainName == NULL) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            wcscpy(*lpDNSDomainName, DsRolepCurrentIfmOperationHandle.IfmSystemInfo.wszDnsDomainName);
            *State = DsRolepCurrentIfmOperationHandle.IfmSystemInfo.dwState;
            // Success, set IfmHandle out param ...
            *pIfmHandle = (DSROLER_IFM_HANDLE) &DsRolepCurrentIfmOperationHandle;

        }

    }
    DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock = FALSE;


    return(Win32Err);
}


DWORD
DsRolerIfmHandleFree(
    IN PDSROLE_SERVER_NAME Server,
    IN DSROLER_IFM_HANDLE * pIfmHandle
    )
/*++

Routine Description:

    Free's the server side allocated context information for an IFM install.

Arguments:

    Server - Server to remote the call to

    IfmHandle - Handle of currently IFM system info.  Returned by 
        DsRolerGetDatabaseFacts().


Return Values:

    Win32 Error.

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    BOOL fLostRace;

    Win32Err = DsRolepCheckPromoteAccess( FALSE );
    if ( ERROR_SUCCESS != Win32Err ) {
        return Win32Err;
    }      

    if ( pIfmHandle == NULL || 
         IsBadWritePtr(pIfmHandle, sizeof (DSROLER_IFM_HANDLE *)) ||
         *pIfmHandle != (( DSROLER_IFM_HANDLE )&DsRolepCurrentIfmOperationHandle)) {
        ASSERT(!"inconsistency in model used to communicated with dcpromo.exe and lsasrv.dll");
        Win32Err = ERROR_INVALID_HANDLE;
        return(Win32Err);
    }

    // We can clear the current state, as long as the handle itself isn't
    // locked, and we're not currently in an install operation consuming
    // the IFM data.
    fLostRace = InterlockedCompareExchange(&(DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock),
                                           TRUE, 
                                           FALSE);
    if (fLostRace ||
        !DsRolepCurrentIfmOperationHandle.fIfmSystemInfoSet) {
        // Either we lost the race for the handle, or there is no
        // data set, either way we fail and assert.
        ASSERT(!"inconsistency in model used to communicated with dcpromo.exe and lsasrv.dll");
        DsRolepLogPrint(( DEB_ERROR, "Couldn't get the IFM Handle lock during Free.\n"));
        Win32Err = ERROR_INVALID_HANDLE;
        if (!fLostRace) {
            // Won race, but erroring out.
            DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock = FALSE;
        }
        return(Win32Err);
    }

    DsRolepCurrentIfmOperationHandle.fIfmSystemInfoSet = FALSE; 
    
    DsRolepClearIfmParams();
    
    *pIfmHandle = NULL;

    DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock = FALSE; 

    return( Win32Err );
}



DWORD
DsRolerGetPrimaryDomainInformation(
    IN PDSROLE_SERVER_NAME Server,
    IN DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PDSROLER_PRIMARY_DOMAIN_INFORMATION *DomainInfo
    )
/*++

Routine Description:

    Determine the principal name to use for authenticated Rpc

Arguments:

    Server - Server the call was remoted to

    ServerPrincipal - Where the server principal name is returned


Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A NULL return parameter was given

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    PBYTE BuffersToFree[ 6 ];
    ULONG BuffersCnt = 0, i = 0;
    PDSROLER_PRIMARY_DOMAIN_INFO_BASIC BasicInfo = NULL;
    PDSROLE_UPGRADE_STATUS_INFO Upgrade = NULL;
    PDSROLE_OPERATION_STATE_INFO OperationStateInfo = 0;
    BOOLEAN IsUpgrade = FALSE;
    ULONG PreviousServerRole = 0;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRole = NULL;
    PPOLICY_DNS_DOMAIN_INFO CurrentDnsInfo = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    LSAPR_HANDLE PolicyHandle = NULL;
    LSAPR_OBJECT_ATTRIBUTES PolicyObject;
    GUID                    NullGuid;

    memset( &NullGuid, 0, sizeof(GUID) );
    #define IS_GUID_PRESENT(x)  (memcmp(&(x), &NullGuid, sizeof(GUID)))

    if ( DomainInfo == NULL ) {

        return( ERROR_INVALID_PARAMETER );
    }

    //
    // This particular interface cannot be called until the Lsa and Sam are fully initialized.
    // As such, we will have to wait until they are..
    //
    if ( !DsRolepSamInitialized ) {

        Win32Err = DsRolepWaitForSam();
        if ( Win32Err != ERROR_SUCCESS ) {

            return( Win32Err );
        }

        DsRolepSamInitialized = TRUE;
    }

    switch ( InfoLevel ) {
    case DsRolePrimaryDomainInfoBasic:

        BasicInfo = MIDL_user_allocate( sizeof( DSROLER_PRIMARY_DOMAIN_INFO_BASIC ) );

        if ( BasicInfo == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto GetInfoError;

        } else {

            BuffersToFree[ BuffersCnt++ ] = ( PBYTE )BasicInfo;
        }

        //
        // Open a handle to the policy and ensure the callers has access to read it
        //

        RtlZeroMemory(&PolicyObject, sizeof(PolicyObject));

        Status = LsarOpenPolicy(
                        NULL,   // Local LSA
                        &PolicyObject,
                        POLICY_VIEW_LOCAL_INFORMATION,
                        &PolicyHandle );

        if ( !NT_SUCCESS(Status) ) {
            Win32Err = RtlNtStatusToDosError( Status );
            goto GetInfoError;
        }


        //
        // Get the current information
        //
        Status =  LsarQueryInformationPolicy(
                            PolicyHandle,
                            PolicyDnsDomainInformationInt,
                            (PLSAPR_POLICY_INFORMATION *) &CurrentDnsInfo );

        if ( NT_SUCCESS( Status ) ) {

            //
            // Get the machine role
            //
            switch ( LsapProductType ) {
            case NtProductWinNt:
                if ( CurrentDnsInfo->Sid == NULL ) {

                    BasicInfo->MachineRole = DsRole_RoleStandaloneWorkstation;

                } else {

                    BasicInfo->MachineRole = DsRole_RoleMemberWorkstation;

                }
                break;

            case NtProductServer:
                if ( CurrentDnsInfo->Sid == NULL ) {

                    BasicInfo->MachineRole = DsRole_RoleStandaloneServer;

                } else {

                    BasicInfo->MachineRole = DsRole_RoleMemberServer;

                }
                break;

            case NtProductLanManNt:

                Status = LsarQueryInformationPolicy(
                                PolicyHandle,
                                PolicyLsaServerRoleInformation,
                                (PLSAPR_POLICY_INFORMATION *) &ServerRole );

                if (NT_SUCCESS( Status ) ) {

                    if ( ServerRole->LsaServerRole == PolicyServerRolePrimary ) {

                        //
                        // If we think we're a primary domain controller, we'll need to
                        // guard against the case where we're actually standalone during setup
                        //
                        Status = LsarQueryInformationPolicy(
                                    PolicyHandle,
                                    PolicyAccountDomainInformation,
                                    (PLSAPR_POLICY_INFORMATION *) &AccountDomainInfo );

                        if ( NT_SUCCESS( Status ) ) {


                            if ( CurrentDnsInfo->Sid == NULL ||
                                 AccountDomainInfo->DomainSid == NULL ||
                                 !RtlEqualSid( AccountDomainInfo->DomainSid,
                                               CurrentDnsInfo->Sid ) ) {

                                BasicInfo->MachineRole = DsRole_RoleStandaloneServer;

                            } else {

                                BasicInfo->MachineRole = DsRole_RolePrimaryDomainController;

                            }
                            LsaIFree_LSAPR_POLICY_INFORMATION(
                                    PolicyAccountDomainInformation,
                                    ( PLSAPR_POLICY_INFORMATION )AccountDomainInfo );
                        }


                    } else {

                        BasicInfo->MachineRole = DsRole_RoleBackupDomainController;
                    }

                    LsaIFree_LSAPR_POLICY_INFORMATION( PolicyLsaServerRoleInformation,
                                                       ( PLSAPR_POLICY_INFORMATION )ServerRole );
                }

                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

        }

        //
        // Now, build the rest of the information
        //
        if ( NT_SUCCESS( Status ) ) {


            if ( LsapDsIsRunning ) {

                BasicInfo->Flags = DSROLE_PRIMARY_DS_RUNNING;

                Status = DsRolepGetMixedModeFlags( CurrentDnsInfo->Sid, &( BasicInfo->Flags ) );

            } else {

                BasicInfo->Flags = 0;

            }

            if ( NT_SUCCESS( Status ) ) {

                //
                // Flat name
                //
                GET_PDI_COPY_STRING_AND_INSERT( &CurrentDnsInfo->Name, BasicInfo->DomainNameFlat );
    
                //
                // Dns domain name
                //
                GET_PDI_COPY_STRING_AND_INSERT( &CurrentDnsInfo->DnsDomainName, BasicInfo->DomainNameDns );
    
                //
                // Dns tree name
                //
                GET_PDI_COPY_STRING_AND_INSERT( &CurrentDnsInfo->DnsForestName, BasicInfo->DomainForestName );
    
                //
                // Finally, the Guid.
                //
                if ( IS_GUID_PRESENT(CurrentDnsInfo->DomainGuid) ) {
    
                    RtlCopyMemory( &BasicInfo->DomainGuid,
                                   &CurrentDnsInfo->DomainGuid,
                                   sizeof( GUID ) );
    
                    BasicInfo->Flags |= DSROLE_PRIMARY_DOMAIN_GUID_PRESENT;
                }

            }
        }

        if ( NT_SUCCESS( Status ) ) {

            *DomainInfo = ( PDSROLER_PRIMARY_DOMAIN_INFORMATION )BasicInfo;
            BuffersCnt = 0;

        } else {

            Win32Err = RtlNtStatusToDosError( Status );
        }


        break;

    case DsRoleUpgradeStatus:

        Win32Err = DsRolepQueryUpgradeInfo( &IsUpgrade,
                                            &PreviousServerRole );

        if ( Win32Err == ERROR_SUCCESS ) {

            Upgrade = MIDL_user_allocate( sizeof( DSROLE_UPGRADE_STATUS_INFO ) );

            if ( Upgrade == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;
                goto GetInfoError;

            } else {

                BuffersToFree[ BuffersCnt++ ] = ( PBYTE )Upgrade;

                //
                // Now, build the information
                //
                if ( IsUpgrade ) {

                    Upgrade->OperationState = DSROLE_UPGRADE_IN_PROGRESS;

                    switch ( PreviousServerRole ) {
                    case PolicyServerRoleBackup:
                        Upgrade->PreviousServerState = DsRoleServerBackup;
                        break;

                    case PolicyServerRolePrimary:
                        Upgrade->PreviousServerState = DsRoleServerPrimary;
                        break;

                    default:

                        Win32Err = ERROR_INVALID_SERVER_STATE;
                        break;

                    }

                } else {

                    RtlZeroMemory( Upgrade, sizeof( DSROLE_UPGRADE_STATUS_INFO ) );
                }

                //
                // Make sure to return the values if we should
                //
                if ( Win32Err == ERROR_SUCCESS ) {

                    *DomainInfo = ( PDSROLER_PRIMARY_DOMAIN_INFORMATION )Upgrade;
                    BuffersCnt = 0;

                }

            }
        }
        break;

    case DsRoleOperationState:

        OperationStateInfo = MIDL_user_allocate( sizeof( DSROLE_OPERATION_STATE_INFO ) );

        if ( OperationStateInfo == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto GetInfoError;

        }

        if ( RtlAcquireResourceExclusive( &DsRolepCurrentOperationHandle.CurrentOpLock, TRUE ) ) {

            DsRoleDebugOut(( DEB_TRACE_LOCK,
                             "Lock grabbed in DsRolerGetPrimaryDomainInformation\n"));

            if ( DSROLEP_OPERATION_ACTIVE( DsRolepCurrentOperationHandle.OperationState ) ) {

                OperationStateInfo->OperationState = DsRoleOperationActive;

            } else if ( DSROLEP_IDLE == DsRolepCurrentOperationHandle.OperationState ) {

                OperationStateInfo->OperationState = DsRoleOperationIdle;

            } else {

                ASSERT( DSROLEP_NEED_REBOOT == DsRolepCurrentOperationHandle.OperationState );

                //
                // If the assert isn't true, then we are very confused and should probably
                // indicate we need a reboot.
                //
                OperationStateInfo->OperationState = DsRoleOperationNeedReboot;
            }

            RtlReleaseResource( &DsRolepCurrentOperationHandle.CurrentOpLock );
            DsRoleDebugOut(( DEB_TRACE_LOCK, "Lock released\n" ));

            //
            // Set the out param
            //
            *DomainInfo = ( PDSROLER_PRIMARY_DOMAIN_INFORMATION )OperationStateInfo;

        } else {

            Win32Err = ERROR_BUSY;
        }

        break;



    default:
        Win32Err = ERROR_INVALID_PARAMETER;
        break;
    }

GetInfoError:

    if ( CurrentDnsInfo != NULL ) {

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           ( PLSAPR_POLICY_INFORMATION )CurrentDnsInfo );

    }


    //
    // Free any buffers that we may have allocated
    //
    for ( i = 0; i < BuffersCnt; i++ ) {

        MIDL_user_free( BuffersToFree[ i ] );
    }

    if ( PolicyHandle != NULL ) {
        LsarClose( &PolicyHandle );
    }

    return( Win32Err );
}






DWORD
DsRolerCancel(
    IN PDSROLE_SERVER_NAME Server,
    IN PDSROLER_HANDLE DsOperationHandle
    )
/*++

Routine Description:

    Cancels a currently running operation

Arguments:

    Server - Server to remote the call to

    DsOperationHandle - Handle of currently running operation.  Returned by one of the DsRoleDcAs
        apis


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

     __try {

        if ( DsOperationHandle == NULL ||
             *DsOperationHandle != ( DSROLER_HANDLE )&DsRolepCurrentOperationHandle) {

           Win32Err = ERROR_INVALID_HANDLE;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err =  GetExceptionCode();
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepCancel( TRUE );  // Block until done

    }

    return( Win32Err );
}


DWORD
DsRolerServerSaveStateForUpgrade(
    IN PDSROLE_SERVER_NAME Server,
    IN LPWSTR AnswerFile OPTIONAL
    )
/*++

Routine Description:

    This function is to be invoked during setup and saves the required server state to
    complete the promotion following the reboot.  Following the successful completion
    of this API call, the server will be demoted to a member server in the same domain.

Arguments:

    AnswerFile -- Optional path to an answer file to be used by DCPROMO during the subsequent
        invocation


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    //
    // Check the access of the caller
    //
    // N.B another access check would be to check that this is GUI mode
    // setup, but checking for admin is safer.  It works because setup.exe
    // runs under local system which has builtin\administrators in its
    // token.
    //
    Win32Err = DsRolepCheckPromoteAccess( FALSE );
    if ( ERROR_SUCCESS != Win32Err ) {

        return Win32Err;

    }

    (VOID) DsRolepInitializeLog();

    Win32Err = DsRolepSaveUpgradeState( AnswerFile );

    return( Win32Err );
}



DWORD
DsRolerUpgradeDownlevelServer(
    IN  handle_t RpcBindingHandle,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR SiteName,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  LPWSTR SystemVolumeRootPath,
    IN  LPWSTR ParentDnsDomainName OPTIONAL,
    IN  LPWSTR ParentServer OPTIONAL,
    IN  LPWSTR Account OPTIONAL,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EPassword,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EDsRepairPassword,
    IN  ULONG Options,
    OUT PDSROLER_HANDLE *DsOperationHandle
    )
/*++

Routine Description:

    This routine process the information saved from a DsRoleServerSaveStateForUpgrade to
    promote a downlevel (NT4 or previous) server to an NT5 DC

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords
    
    DnsDomainName - Dns domain name of the domain to install

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go

    SystemVolumeRootPath - Absolute path on the local machine which will be the root of
      the system volume.

    ParentDnsDomainName - Optional.  If present, set this domain up as a child of the
      specified domain

    ParentServer - Optional.  If present, use this server in the parent domain to replicate
      the required information from

    Account - User account to use when contacting other servers

    EPassword - Encrypted password to use with the above account
    
    EDsRepairPassword - Encrypted password to use for the admin account of the repair mode

    Options - Options to control the creation of the domain

    DsOperationHandle - Handle to the operation is returned here.


Return Values:

    ERROR_SUCCESS - Success
    ERROR_INVALID_SERVER_STATE - Not in upgrade mode

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    BOOLEAN IsUpgrade;
    ULONG PreviousServerState;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs;
    NTSTATUS Status;
    HANDLE LocalPolicy = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_DNS_DOMAIN_INFO PrimaryDomainInfo = NULL;
    UCHAR Seed = 0;

#define DSROLEP_UPGRADE_PWD_INDEX            0
#define DSROLEP_UPGRADE_DS_REPAIR_PWD_INDEX  1
#define DSROLEP_UPGRADE_MAX_PWD_COUNT        2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_UPGRADE_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_UPGRADE_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_UPGRADE_PWD_INDEX] = EPassword;
    EncryptedPasswords[DSROLEP_UPGRADE_DS_REPAIR_PWD_INDEX] = EDsRepairPassword;

    RtlZeroMemory( Passwords, sizeof(Passwords) );
    
    *DsOperationHandle = NULL;

    //
    // Do some parameter checking
    //
    if ( !DnsDomainName || !DsDatabasePath || !DsLogPath || !SystemVolumeRootPath ) {

        Win32Err = ERROR_INVALID_PARAMETER;
        goto DsRolepUpgradeError;

    }

    Win32Err = DsRolepInitializeOperationHandle( );
    if (ERROR_SUCCESS != Win32Err) {

        goto DsRolepUpgradeError;

    }
    
    //
    // Check the access of the caller
    //
    Win32Err = DsRolepCheckPromoteAccess( TRUE );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto DsRolepUpgradeError;
        
    }

    DsRolepInitializeLog();

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolerDcAsDc: DnsDomainName  %ws\n",
                      DnsDomainName ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSiteName  %ws\n",
                      DsRolepDisplayOptional( SiteName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSystemVolumeRootPath  %ws\n",
                      SystemVolumeRootPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tDsDatabasePath  %ws, DsLogPath  %ws\n",
                      DsDatabasePath, DsLogPath ));

    if ( ParentDnsDomainName ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "\tParentDnsDomainName  %ws\n",
                          ParentDnsDomainName ));

    }

    if ( ParentServer ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "\tParentServer  %ws\n",
                          ParentServer ));

    }

    if ( Account ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "\tAccount %ws\n",
                          Account ));
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "\tOptions  %lu\n",
                      Options ));

    Win32Err = DsRolepQueryUpgradeInfo( &IsUpgrade, &PreviousServerState );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto DsRolepUpgradeError;
    }

    if ( !IsUpgrade || PreviousServerState == PolicyServerRoleBackup ) {

        Win32Err = ERROR_INVALID_SERVER_STATE;
        goto DsRolepUpgradeError;

    }

    //
    // Verify the path names we are given
    //
    DsRolepLogPrint(( DEB_TRACE,"Validate supplied paths\n" ));
    Win32Err = DsRolepCheckFilePaths( DsDatabasePath,
                                      DsLogPath,
                                      SystemVolumeRootPath );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto DsRolepUpgradeError;
        
    }

    //
    // If we are doing a parent/child setup, verify our name
    //
    if ( Win32Err == ERROR_SUCCESS && ParentDnsDomainName &&
         !FLAG_ON( Options, DSROLE_DC_TRUST_AS_ROOT ) ) {

        Win32Err = DsRolepIsDnsNameChild( ParentDnsDomainName, DnsDomainName );
    }

    //
    // Get the current domain name
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &LocalPolicy );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( LocalPolicy,
                                                PolicyPrimaryDomainInformation,
                                                &PrimaryDomainInfo );

            LsaClose( LocalPolicy );
        }

        Win32Err = RtlNtStatusToDosError( Status );

    }

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                NULL,
                                                &Seed );

    //
    // Finally, we'll do the promotion
    //
    
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepBuildPromoteArgumentBlock( DnsDomainName,
                                                     PrimaryDomainInfo->Name.Buffer,
                                                     SiteName,
                                                     DsDatabasePath,
                                                     DsLogPath,
                                                     NULL,
                                                     SystemVolumeRootPath,
                                                     NULL,
                                                     ParentDnsDomainName,
                                                     ParentServer,
                                                     Account,
                                                     &Passwords[DSROLEP_UPGRADE_PWD_INDEX],
                                                     NULL,
                                                     &Passwords[DSROLEP_UPGRADE_DS_REPAIR_PWD_INDEX],
                                                     Options | DSROLE_DC_DOWNLEVEL_UPGRADE,
                                                     Seed,
                                                     &PromoteArgs );

    }

    DsRolepFreePasswords( Passwords,
                          NELEMENTS(Passwords) );


    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepSpinWorkerThread( DSROLEP_OPERATION_DC,
                                            ( PVOID )PromoteArgs );

        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepFreeArgumentBlock( &PromoteArgs, TRUE );
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepResetOperationHandle( DSROLEP_IDLE );
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *DsOperationHandle = (DSROLER_HANDLE)&DsRolepCurrentOperationHandle;

    }

    LsaFreeMemory( PrimaryDomainInfo );


DsRolepUpgradeError:

    return( Win32Err );
}



DWORD
DsRolerAbortDownlevelServerUpgrade(
    IN handle_t RpcBindingHandle,
    IN LPWSTR Account, OPTIONAL
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD EAccountPassword,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD EAdminPassword,
    IN ULONG Options
    )
/*++

Routine Description:

    This routine cleans up the information saved from a DsRoleSaveServerStateForUpgrade call,
    leaving the machine as a member or standalone server

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords                                   

    Account - User account to use when contacting other servers

    EPassword - Encrypted password to use with the above account

    EAdminPassword - Encrypted new local administrator account password
    
    Options - Options to control the behavior.  Currently support flags are:
        DSROLEP_ABORT_FOR_REPLICA_INSTALL   - The upgrade is being aborted to do a replica install

Return Values:

    ERROR_SUCCESS - Success
    ERROR_INVALID_PARAMETER - An invalid machine role was specified

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, Win32Err2;
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    BOOLEAN AccountInfoSet = FALSE, Impersonated = FALSE;
    UCHAR Seed = 0;
    UNICODE_STRING EPassword, EPassword2;
    WCHAR *OldAccountDn = NULL;
    WCHAR SecurityLogPath[MAX_PATH+1];
    PUNICODE_STRING Password = NULL;
    PUNICODE_STRING AdminPassword = NULL;
    HANDLE ClientToken = NULL;

#define DSROLEP_ABORT_PWD_INDEX        0
#define DSROLEP_ABORT_ADMIN_PWD_INDEX  1
#define DSROLEP_ABORT_MAX_PWD_COUNT    2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_ABORT_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_ABORT_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_ABORT_PWD_INDEX] = EAccountPassword;
    EncryptedPasswords[DSROLEP_ABORT_ADMIN_PWD_INDEX] = EAdminPassword;
    RtlZeroMemory( Passwords, sizeof(Passwords) );
    
    EPassword.Buffer = NULL;
    EPassword2.Buffer = NULL;

    //
    // Initialize the operation handle so we pull in the dynamically
    // loaded libraries
    //
    Win32Err = DsRolepInitializeOperationHandle( );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto Exit;
    }

    Win32Err = DsRolepCheckPromoteAccess( FALSE );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto Exit;
        
    }

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                NULL,
                                                &Seed );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto Exit;

    }
    RtlCopyMemory( &EPassword,  &Passwords[DSROLEP_ABORT_ADMIN_PWD_INDEX], sizeof(UNICODE_STRING));
    RtlCopyMemory( &EPassword2, &Passwords[DSROLEP_ABORT_PWD_INDEX], sizeof(UNICODE_STRING));

    DsRolepInitializeLog();

    if ( FLAG_ON( Options, DSROLEP_ABORT_FOR_REPLICA_INSTALL ) )
    {
        //
        // This is the NT4 to NT5 BDC upgrade.  Nothing to do
        // 
        //
        DsRolepLogPrint(( DEB_TRACE, "Performing NT4 to NT5 BDC upgrade.\n"));
        Win32Err = ERROR_SUCCESS;
        goto Exit;

    }

    Win32Err = DsRolepGetImpersonationToken( &ClientToken );
    if (ERROR_SUCCESS != Win32Err) {

        goto Exit;
    }

    //
    // First, find the Dc that has this account
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepDsGetDcForAccount( NULL,
                                             NULL,
                                             NULL,
                                             DS_DIRECTORY_SERVICE_REQUIRED |
                                                    DS_WRITABLE_REQUIRED |
                                                    DS_FORCE_REDISCOVERY |
                                                    DS_AVOID_SELF,
                                             UF_SERVER_TRUST_ACCOUNT,
                                             &DomainControllerInfo );

        if ( Win32Err == ERROR_SUCCESS ) {

            //
            // Set the machine account type
            //

            DsRolepLogPrint(( DEB_TRACE, "Searching for the machine account ...\n"));

            RtlRunDecodeUnicodeString( Seed, &EPassword2 );
            Win32Err = DsRolepSetMachineAccountType( DomainControllerInfo->DomainControllerName,
                                                     ClientToken,
                                                     Account,
                                                     EPassword2.Buffer,
                                                     NULL,
                                                     UF_WORKSTATION_TRUST_ACCOUNT,
                                                     &OldAccountDn );
            RtlRunEncodeUnicodeString( &Seed, &EPassword2 );

            if ( Win32Err == ERROR_SUCCESS ) {

                AccountInfoSet = TRUE;

            } else {

                DsRolepLogPrint(( DEB_TRACE, "DsRolepSetMachineAccountType returned %d\n",
                                  Win32Err ));
            }

            if ( OldAccountDn ) {

                // the machine object was moved
                DsRolepLogPrint(( DEB_TRACE, "Moved account %ws to %ws\n",
                                  Account,
                                  OldAccountDn ));
            }
        }

    }

    if ( ERROR_SUCCESS != Win32Err ) {

        goto Exit;
        
    }

    //
    // Set the security for a freshly installed NT5 server. See bug 391574
    //

    DsRolepLogPrint(( DEB_TRACE, "Setting security for server ...\n"));

    #define SECURITY_SRV_INF_FILE L"defltsv.inf"
    
    ZeroMemory( SecurityLogPath, (MAX_PATH+1)*sizeof(WCHAR) );
    if ( GetWindowsDirectory( SecurityLogPath, MAX_PATH ) )
    {
        //Ensure that the last Char is L'\0'
        SecurityLogPath[MAX_PATH] = L'\0';                                                    // -1 to ensure last char is not overwritten
        wcsncat( SecurityLogPath, L"\\security\\logs\\scesetup.log", ((sizeof(SecurityLogPath)/sizeof(WCHAR))-wcslen(SecurityLogPath)-1) );

        Win32Err  = DsrSceSetupSystemByInfName(SECURITY_SRV_INF_FILE,
                                               SecurityLogPath,                                                   
                                               AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY,
                                               SCESETUP_CONFIGURE_SECURITY,
                                               NULL,    // used only for GUI mode                                 
                                               NULL );  // used only for GUI mode
    
    } else {

        Win32Err = GetLastError();

    }

    if ( ERROR_SUCCESS != Win32Err ) {

        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_ERROR,
                                               "Setting security on server files failed with %lu\n",
                                               Win32Err )) );

        // This error has been handled
        Win32Err = ERROR_SUCCESS;
    }

    DsRolepLogPrint(( DEB_TRACE, "Setting security for server finished\n"));



    //
    // Change the user password
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        RtlRunDecodeUnicodeString( Seed, &EPassword );
        Win32Err = DsRolepSetBuiltinAdminAccountPassword( EPassword.Buffer );
        RtlRunEncodeUnicodeString( &Seed, &EPassword );

        //
        // Delete the upgrade information
        //
        if ( Win32Err == ERROR_SUCCESS ) {
    
            Win32Err = DsRolepDeleteUpgradeInfo();
        }
    }


    //
    // If that failed, try and restore the machine account info
    //
    if ( Win32Err != ERROR_SUCCESS && AccountInfoSet ) {

        RtlRunDecodeUnicodeString( Seed, &EPassword2 );
        Win32Err2 = DsRolepSetMachineAccountType( DomainControllerInfo->DomainControllerName,
                                                  ClientToken,
                                                  Account,
                                                  EPassword2.Buffer,
                                                  NULL,
                                                  UF_SERVER_TRUST_ACCOUNT,
                                                  &OldAccountDn );  //don't care about dn
        RtlRunEncodeUnicodeString( &Seed, &EPassword2 );

        if ( Win32Err2 != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_TRACE, "DsRolepSetMachineAccountType returned %d\n", Win32Err2 ));

        } else {

            if ( OldAccountDn ) {

                //
                // the machine object was moved back
                //
                DsRolepLogPrint(( DEB_TRACE, "Attempted to move account %ws to %ws\n",
                                 Account,
                                 OldAccountDn ));
            }
        }
    }

Exit:

    DsRolepFreePasswords( Passwords,
                          NELEMENTS(Passwords) );

    NetApiBufferFree( DomainControllerInfo );

    if ( OldAccountDn ) {

        RtlFreeHeap( RtlProcessHeap(), 0, OldAccountDn );
    }

    if (ClientToken) {
        CloseHandle(ClientToken);
    }

    (VOID) DsRolepResetOperationHandle( DSROLEP_IDLE ); 

    return( Win32Err );
}





//
// Local function definitions
//
DWORD
DsRolepWaitForSam(
    VOID
    )
/*++

Routine Description:

    This routine waits for the SAM_SERVICE_STARTED event

Arguments:

    VOID
Return Values:

    ERROR_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttributes;
    HANDLE EventHandle = NULL;

    //
    // Open the event
    //
    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED" );
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtCreateEvent( &EventHandle,
                            SYNCHRONIZE,
                            &EventAttributes,
                            NotificationEvent,
                            FALSE );


    //
    // If the event already exists, just open it.
    //
    if( Status == STATUS_OBJECT_NAME_EXISTS || Status == STATUS_OBJECT_NAME_COLLISION ) {

        Status = NtOpenEvent( &EventHandle,
                              SYNCHRONIZE,
                              &EventAttributes );
    }


    if ( NT_SUCCESS( Status ) ) {

        Status = NtWaitForSingleObject( EventHandle, TRUE, NULL );

        NtClose( EventHandle );
    }



    return( RtlNtStatusToDosError( Status ) );
}

DWORD
DsRolepCheckFilePaths(
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN LPWSTR SystemVolumeRootPath
    )
/*++

Routine Description:

Arguments:

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG VerifyOptions, VerifyResults;
    ULONG Length;

    //
    // Make sure that niether the log path nor the datapath path
    // is a subset of the SystemVolumeRootPath
    //
    Length = wcslen( SystemVolumeRootPath );
    if ( !_wcsnicmp( SystemVolumeRootPath, DsDatabasePath, Length )
      || !_wcsnicmp( SystemVolumeRootPath, DsLogPath, Length )   ) {

        DsRolepLogPrint(( DEB_TRACE, "Database paths subset of sysvol\n" ));

        WinError = ERROR_BAD_PATHNAME;
        
    }

    if ( WinError == ERROR_SUCCESS ) {

        VerifyOptions = DSROLEP_PATH_VALIDATE_LOCAL | DSROLEP_PATH_VALIDATE_EXISTENCE;
        WinError = DsRolepValidatePath( DsDatabasePath, VerifyOptions, &VerifyResults );

       if ( WinError == ERROR_SUCCESS ) {

           if ( VerifyResults != VerifyOptions ) {

               WinError = ERROR_BAD_PATHNAME;
           }
       }
    }

    if ( WinError == ERROR_SUCCESS ) {

        WinError = DsRolepValidatePath( DsLogPath, VerifyOptions, &VerifyResults );

        if ( WinError == ERROR_SUCCESS ) {

            if ( VerifyResults != VerifyOptions ) {

                WinError = ERROR_BAD_PATHNAME;
            }
        }
    }

    if ( WinError == ERROR_SUCCESS ) {

        VerifyOptions = DSROLEP_PATH_VALIDATE_LOCAL | DSROLEP_PATH_VALIDATE_NTFS;
        WinError = DsRolepValidatePath( SystemVolumeRootPath, VerifyOptions, &VerifyResults );

        if ( WinError == ERROR_SUCCESS ) {

            if ( VerifyResults != VerifyOptions ) {

                WinError = ERROR_BAD_PATHNAME;
            }
        }
    }

    return WinError;
}

BOOL
IsProductSuiteConfigured(
    WORD Suite
    )
{

    OSVERSIONINFOEXA  osvi;
    DWORDLONG dwlConditionMask = 0;

    //
    // Setup the request for the desired suite
    //
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    osvi.wSuiteMask = Suite;

    //
    // Setup the condition
    //
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_AND);

    return VerifyVersionInfoA(&osvi,
                              VER_SUITENAME,
                              dwlConditionMask);

}

BOOL
IsWebBlade(
    VOID
    )
{
    return IsProductSuiteConfigured(VER_SUITE_BLADE);
}

BOOL 
IsSBS(
    VOID
    )
{
    return IsProductSuiteConfigured(VER_SUITE_SMALLBUSINESS_RESTRICTED);
}

DWORD
DsRolepIsValidProductSuite(
    IN BOOL fNewForest,
    IN BOOL fReplica,
    IN LPWSTR DomainName
    )
/*++

Routine Description:

    This routine determines if the promotion request is valid for the
    current configuration of the OS.

Arguments:

    fNewForest -- a new forest is requested.
    
    fReplica -- a replica is requested
    
    DomainName -- the name of the domain to create or join
    
Return Values:

    ERROR_SUCCESS, ERROR_NOT_SUPPORTED, resource errors otherwise     

--*/
{
    DWORD err = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFOW DCInfo = NULL;

    if (IsWebBlade()) {
        // See Windows RAID issue 195265
        err = ERROR_NOT_SUPPORTED;
        goto Exit;
    }

    if (IsSBS()) {

        if (fReplica) {

            err = DsGetDcNameW(NULL,
                               DomainName,
                               NULL,
                               NULL,
                               0,
                               &DCInfo);
            if (ERROR_SUCCESS != err) {

                // Return the resource or configuration error
                DsRolepLogPrint((DEB_ERROR,
                                 "Request to find a DC for %ws failed (%d)\n", 
                                 DomainName, 
                                 err));
                goto Exit;
            }

            if ( !(DnsNameCompareEqual == DnsNameCompareEx_W(DomainName,
                                                             DCInfo->DnsForestName,
                                                             0 ))) {                       
                // See Windows issue 373388
                // Must be the root of the forest
                err = ERROR_NOT_SUPPORTED;
                goto Exit;
            }

        } else if (!fNewForest) {

            // See Windows NT issue 353854
            err = ERROR_NOT_SUPPORTED;
            goto Exit;
        }
    }

Exit:

    if (DCInfo) {
        NetApiBufferFree(DCInfo);
    }

    return err;
}



DWORD
DsRolepDecryptPasswordsWithKey(
    IN handle_t RpcBindingHandle,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD * EncryptedPasswords,
    IN ULONG Count,
    IN OUT UNICODE_STRING *EncodedPasswords,
    OUT OPTIONAL PUSER_SESSION_KEY pUserSessionKey,
    OUT PUCHAR Seed
    )
/*++

Routine Description:

    Decrypts a set of passwords encrypted with the user session key.

Arguments:

    RpcBindingHandle - Rpc Binding handle describing the session key to use.

    EncryptedPasswords - Encrypted passwords to decrypt.
    
    Count - the number of passwords

    EncodedPassword - Returns the Encoded password.
        The password has been encoded
        Buffer should be freed using LocalFree.
        
    UserSessionKey -  the Key used for decryption
        
    Seed - the seed that was used to encode the password        

Return Value:

    ERROR_SUCCESS; a resource or parameter error otherwise

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS Status;
    USER_SESSION_KEY UserSessionKey;
    RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;

    LPWSTR PasswordPart;

    ULONG i;

    //
    // Get the session key
    //
    Status = RtlGetUserSessionKeyServer(
                    (RPC_BINDING_HANDLE)RpcBindingHandle,
                    &UserSessionKey );

    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError( Status );
    }
    //
    // Return the Key if requested
    //
    if (pUserSessionKey) {
        CopyMemory(pUserSessionKey, &UserSessionKey, sizeof(UserSessionKey));
    }

    for ( i = 0; i < Count; i++ ) {

        PDSROLEPR_USER_PASSWORD Password = (PDSROLEPR_USER_PASSWORD) EncryptedPasswords[i];
        LPWSTR ClearPassword;
    
        //
        // Handle the trivial case
        //
        RtlInitUnicodeString( &EncodedPasswords[i], NULL );
        if ( Password == NULL ) {
            continue;
        }
    
        //
        // The UserSessionKey is the same for the life of the session.  RC4'ing multiple
        //  strings with a single key is weak (if you crack one you've cracked them all).
        //  So compute a key that's unique for this particular encryption.
        //
        //
    
        MD5Init(&Md5Context);
    
        MD5Update( &Md5Context, (LPBYTE)&UserSessionKey, sizeof(UserSessionKey) );
        MD5Update( &Md5Context, Password->Obfuscator, sizeof(Password->Obfuscator) );
    
        MD5Final( &Md5Context );
    
        rc4_key( &Rc4Key, MD5DIGESTLEN, Md5Context.digest );
    
    
        //
        // Decrypt the Buffer
        //
    
        rc4( &Rc4Key, sizeof(Password->Buffer)+sizeof(Password->Length), (LPBYTE) Password->Buffer );
    
        //
        // Check that the length is valid.  If it isn't bail here.
        //
    
        if (Password->Length > DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
            WinError = ERROR_INVALID_PASSWORD;
            goto Cleanup;
        }
    
        //
        // Return the password to the caller.
        //
    
        ClearPassword = LocalAlloc( 0,  Password->Length + sizeof(WCHAR) );
    
        if ( ClearPassword == NULL ) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    
        //
        // Copy the password into the buffer
        //
        RtlCopyMemory( ClearPassword,
                       ((PCHAR) Password->Buffer) +
                       (DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                       Password->Length,
                       Password->Length );
    
        ClearPassword[Password->Length/sizeof(WCHAR)] = L'\0';
    
        RtlInitUnicodeString( &EncodedPasswords[i], ClearPassword );

        //
        // Now encode it
        //
        RtlRunEncodeUnicodeString( Seed, &EncodedPasswords[i] );

    }

Cleanup:

    if ( WinError != ERROR_SUCCESS ) {

        for ( i = 0; i < Count; i++ ) {
            if ( EncodedPasswords[i].Buffer ) {
                LocalFree( EncodedPasswords[i].Buffer );
                RtlInitUnicodeString( &EncodedPasswords[i], NULL );
            }
        }
    }

    return WinError;
}


VOID
DsRolepFreePasswords(
    IN OUT UNICODE_STRING *Passwords,
    IN ULONG Count
    )

/*++

Routine Description:

    Frees the variables returned from DsRolepDecryptPasswordsWithKey

Arguments:

    Passwords - the encoded passwords to free
    
    Count - the number of passwords

Return Value:

    ERROR_SUCCESS; a resource or parameter error otherwise

--*/
{
    ULONG i;

    for ( i = 0; i < Count; i++ ) {

        if ( Passwords[i].Buffer ) {
             
            RtlSecureZeroMemory( Passwords[i].Buffer, Passwords[i].Length );
            LocalFree( Passwords[i].Buffer );
            RtlInitUnicodeString( &Passwords[i], NULL );
        }
    }
}

DWORD
DsRolepDecryptHash(
    IN PUSER_SESSION_KEY UserSessionKey,
    IN PDSROLEPR_ENCRYPTED_HASH EncryptedBootkey,
    OUT PUNICODE_STRING *Bootkey
    )
/*++

Routine Description:

    Decrypts the Boot key

Arguments:

    pUserSessionKey - Key used to encrypt the key
    
    Bootkey - The key to decrypt
    
Return Value:

    ERROR_SUCCESS; a resource or parameter error otherwise

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS Status;
    RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;

    //
    // Check that the length is valid.  If it isn't bail here.
    //

    if (EncryptedBootkey->EncryptedHash.Length != SYSKEY_SIZE) {
        WinError = ERROR_INVALID_PASSWORD;
        goto Cleanup;
    }

    //
    // The UserSessionKey is the same for the life of the session.  RC4'ing multiple
    //  strings with a single key is weak (if you crack one you've cracked them all).
    //  So compute a key that's unique for this particular encryption.
    //
    //

    MD5Init(&Md5Context);

    MD5Update( &Md5Context, (LPBYTE)UserSessionKey, sizeof(*UserSessionKey) );
    MD5Update( &Md5Context, EncryptedBootkey->Salt, sizeof(EncryptedBootkey->Salt) );

    MD5Final( &Md5Context );

    //
    // Decrypt the Buffer
    //

    rc4_key( &Rc4Key, MD5DIGESTLEN, Md5Context.digest );
    rc4( &Rc4Key, EncryptedBootkey->EncryptedHash.Length, (LPBYTE) EncryptedBootkey->EncryptedHash.Buffer );

    //
    // Return the password to the caller.
    //

    *Bootkey = &EncryptedBootkey->EncryptedHash;

Cleanup:

    return WinError;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\dsrolepl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsrolep.h

Abstract:

    Definitions and globals for internal only debug and support routines

Author:

    Mac McLain      (MacM)       Aug 11, 1997

Environment:

Revision History:

--*/
#ifndef __DSROLEP1_H__
#define __DSROLEP1_H__

#define DSROLEP_VERBOSE_LOGGING

#ifdef DSROLEP_VERBOSE_LOGGING

extern HANDLE DsRolepLogFile;

#define DSROLEP_LOGNAME L"\\debug\\DCPROMO.LOG"
#define DSROLEP_BAKNAME L"\\debug\\DCPROMO.BAK"

DWORD
DsRolepInitializeLog(
    VOID
    );

DWORD
DsRolepSetAndClearLog(
    VOID
    );

DWORD
DsRolepCloseLog(
    VOID
    );

VOID
DsRolepLogPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define DsRolepLogPrint( x )  DsRolepLogPrintRoutine x
#define DsRolepDisplayOptional( y ) y ? y : L"(NULL)"
#define DsRolepLogOnFailure( z, a ) if ( z != ERROR_SUCCESS ) a
#define DsRolepLogGuid( l, t, g )  g == NULL ? DsRolepLogPrint(( l, "%S (NULL)\n", t )) :       \
        DsRolepLogPrint(( l, "%S %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",            \
                        t,(g)->Data1,(g)->Data2,(g)->Data3,(g)->Data4[0],                       \
                        (g)->Data4[1],(g)->Data4[2],(g)->Data4[3],(g)->Data4[4],                \
                        (g)->Data4[5],(g)->Data4[6],(g)->Data4[7]))

#define DsRolepLogSid( l, t, s )                                                                \
{ LPWSTR sidstring;                                                                             \
  ConvertSidToStringSidW( s, &sidstring );                                                      \
  DsRolepLogPrint(( l, "%S %ws\n", t, sidstring ));                                             \
  LocalFree(sidstring);                                                                         \
}
                                                                                               
#define DsRolepUnicodestringtowstr( s, u )                                                      \
{ s = (WCHAR*)malloc(u.Length+sizeof(WCHAR));                                                               \
  if (s){                                                                                       \
      CopyMemory(s,u.Buffer,u.Length);                                                          \
      s[u.Length/sizeof(WCHAR)] = L'\0';                                                        \
  }                                                                                             \
}



#else

#define DsRolepInitializeLog()
#define DsRolepCloseLog()
#define DsRolepLogPrint( x )
#define DsRolepDisplayOptional( y )
#define DsRolepLogOnFailure( z, a )
#define DsRolepLogGuid( t, g )
#define DsRolepLogSid( t, s )
#define DsRolepSetAndClearLog()
#define DsRolepUnicodestringtowstr( s, u )
#endif

#endif // __DSROLEP1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\ds.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition
#include <wxlpc.h>

#include "secure.h"
#include "dsconfig.h"
#define STRSAFE_NO_DEPRECATE 1
#include "strsafe.h"

// Few forward delcarations
DWORD DsRolepGetRegString(HKEY hKey, WCHAR * wszValueName, WCHAR ** pwszOutValue);
DWORD NtdspRemoveROAttrib(WCHAR * DstPath);
DWORD NtdspClearDirectory(WCHAR * DirectoryName, BOOL    fRemoveRO);
DWORD DsRolepMakeAltRegistry(WCHAR *  wszOldRegPath, WCHAR *  wszNewRegPath, ULONG    cbNewRegPath);


DWORD
DsRolepInstallDs(
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FlatDomainName,
    IN  LPWSTR DnsTreeRoot,
    IN  LPWSTR SiteName,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  IFM_SYSTEM_INFO * pIfmSystemInfo,
    IN  LPWSTR SysVolRootPath,
    IN  PUNICODE_STRING Bootkey,
    IN  LPWSTR AdminAccountPassword,
    IN  LPWSTR ParentDnsName,
    IN  LPWSTR Server OPTIONAL,
    IN  LPWSTR Account OPTIONAL,
    IN  LPWSTR Password OPTIONAL,
    IN  LPWSTR SafeModePassword OPTIONAL,
    IN  LPWSTR SourceDomain OPTIONAL,
    IN  ULONG  Options,
    IN  BOOLEAN Replica,
    IN  HANDLE ImpersonateToken,
    OUT LPWSTR *InstalledSite,
    IN  OUT GUID *DomainGuid,
    OUT PSID   *NewDomainSid
    )
/*++

Routine Description:

    Wrapper for the routine that does the actual install.

Arguments:

    DnsDomainName - Dns domain name of the domain to install

    FlatDomainName - NetBIOS domain name of the domain to install

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go
    
    pIfmSystemInfo - Information about the IFM system and restore media used to
        dcpromo off.  If NULL, not an IFM promotion.

    EnterpriseSysVolPath -- Absolute path on the local machine for the enterprise wide
                            system volume

    DomainSysVolPath -- Absolute path on the local machine for the domain wide system volume

    AdminAccountPassword -- Administrator password to set for the domain

    ParentDnsName - Optional.  Parent domain name

    Server -- Optional.  Replica partner or name of Dc in parent domain

    Account - User account to use when setting up as a child domain

    Password - Password to use with the above account

    Replica - If TRUE, treat this as a replica install
    
    ImpersonateToken - the token of caller of the role change API

    InstalledSite - Name of the site the Dc was installed into

    DomainGuid - Where the new domain guid is returned

    NewDomainSid - Where the new domain sid is returned.

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTDS_INSTALL_INFO DsInstallInfo;
    PSEC_WINNT_AUTH_IDENTITY AuthIdent = NULL;
    BOOL fRewindServer = FALSE;

    RtlZeroMemory( &DsInstallInfo, sizeof( DsInstallInfo ) );

    if ( !Replica ) {

        if ( ParentDnsName == NULL ) {

            DsInstallInfo.Flags = NTDS_INSTALL_ENTERPRISE;

        } else {

            DsInstallInfo.Flags = NTDS_INSTALL_DOMAIN;
        }

    } else {

        DsInstallInfo.Flags = NTDS_INSTALL_REPLICA;
    }

    if ( FLAG_ON( Options, DSROLE_DC_ALLOW_DC_REINSTALL ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_DC_REINSTALL;
    }

    if ( FLAG_ON( Options, DSROLE_DC_ALLOW_DOMAIN_REINSTALL ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_DOMAIN_REINSTALL;
    }

    if ( FLAG_ON( Options, DSROLE_DC_DOWNLEVEL_UPGRADE ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_UPGRADE;
    }

    if ( FLAG_ON( Options, DSROLE_DC_TRUST_AS_ROOT ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_NEW_TREE;
    }

    if ( FLAG_ON( Options, DSROLE_DC_ALLOW_ANONYMOUS_ACCESS ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_ALLOW_ANONYMOUS;
    }

    if ( FLAG_ON( Options, DSROLE_DC_DEFAULT_REPAIR_PWD ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_DFLT_REPAIR_PWD;
    }

    if ( FLAG_ON( Options, DSROLE_DC_SET_FOREST_CURRENT ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_SET_FOREST_CURRENT;
    }

    if ( Server 
      && Server[0] == L'\\'  ) {
        //
        // Don't pass in \\
        //
        Server += 2;
        fRewindServer = TRUE;
    }

    DsInstallInfo.DitPath = ( PWSTR )DsDatabasePath;
    DsInstallInfo.LogPath = ( PWSTR )DsLogPath;
    DsInstallInfo.SysVolPath = (PWSTR)SysVolRootPath;
    DsInstallInfo.pIfmSystemInfo = pIfmSystemInfo;
    DsInstallInfo.BootKey = Bootkey->Buffer;
    DsInstallInfo.cbBootKey = Bootkey->Length;
    DsInstallInfo.SiteName = ( PWSTR )SiteName;
    DsInstallInfo.DnsDomainName = ( PWSTR )DnsDomainName;
    DsInstallInfo.FlatDomainName = ( PWSTR )FlatDomainName;
    DsInstallInfo.DnsTreeRoot = ( PWSTR )DnsTreeRoot;
    DsInstallInfo.ReplServerName = ( PWSTR )Server;
    DsInstallInfo.pfnUpdateStatus = DsRolepStringUpdateCallback;
    DsInstallInfo.pfnOperationResultFlags = DsRolepOperationResultFlagsCallBack;
    DsInstallInfo.AdminPassword = AdminAccountPassword;
    DsInstallInfo.pfnErrorStatus = DsRolepStringErrorUpdateCallback;
    DsInstallInfo.ClientToken = ImpersonateToken;
    DsInstallInfo.SafeModePassword = SafeModePassword;
    DsInstallInfo.SourceDomainName = SourceDomain;
    DsInstallInfo.Options = Options;

    if (pIfmSystemInfo) {

        ASSERT(pIfmSystemInfo->dwSchemaVersion);
        ASSERT(pIfmSystemInfo->wszDnsDomainName);
        DsInstallInfo.RestoredSystemSchemaVersion = pIfmSystemInfo->dwSchemaVersion;

        if(FALSE == DnsNameCompare_W(pIfmSystemInfo->wszDnsDomainName,
                                     DsInstallInfo.DnsDomainName)) {
            DSROLEP_FAIL2( ERROR_CURRENT_DOMAIN_NOT_ALLOWED, 
                           DSROLERES_WRONG_DOMAIN,
                           DsInstallInfo.DnsDomainName,
                           pIfmSystemInfo->wszDnsDomainName );
            return ERROR_CURRENT_DOMAIN_NOT_ALLOWED;
        }
    }
    
    //
    // Build the cred structure
    //
    Win32Err = DsRolepCreateAuthIdentForCreds( Account, Password, &AuthIdent );

    if ( Win32Err == ERROR_SUCCESS ) {

        DsInstallInfo.Credentials = AuthIdent;

        if (DsInstallInfo.pIfmSystemInfo == NULL) {

            Win32Err = DsRolepCopyDsDitFiles( DsDatabasePath );

        }

        if ( Win32Err == ERROR_SUCCESS ) {

            DSROLEP_CURRENT_OP0( DSROLEEVT_INSTALL_DS );

            DsRolepLogPrint(( DEB_TRACE_DS, "Calling NtdsInstall for %ws\n", DnsDomainName ));

            DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsInstall );

            if ( Win32Err == ERROR_SUCCESS ) {

                DsRolepSetAndClearLog();

                Win32Err = ( *DsrNtdsInstall )( &DsInstallInfo,
                                                InstalledSite,
                                                DomainGuid,
                                                NewDomainSid );

                DsRolepSetAndClearLog();

                DsRolepLogPrint(( DEB_TRACE_DS, "NtdsInstall for %ws returned %lu\n",
                                  DnsDomainName, Win32Err ));

#if DBG
                if ( Win32Err != ERROR_SUCCESS ) {

                    DsRolepLogPrint(( DEB_TRACE_DS, "NtdsInstall parameters:\n" ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tFlags: %lu\n", DsInstallInfo.Flags ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tDitPath: %ws\n", DsInstallInfo.DitPath ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tLogPath: %ws\n", DsInstallInfo.LogPath ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tSiteName: %ws\n", DsInstallInfo.SiteName ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tDnsDomainName: %ws\n",
                                      DsInstallInfo.DnsDomainName ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tFlatDomainName: %ws\n",
                                      DsInstallInfo.FlatDomainName ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tDnsTreeRoot: %ws\n",
                                      DsInstallInfo.DnsTreeRoot ? DsInstallInfo.DnsTreeRoot :
                                                                                    L"(NULL)" ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tReplServerName: %ws\n",
                                      DsInstallInfo.ReplServerName ?
                                                     DsInstallInfo.ReplServerName : L"(NULL)" ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tCredentials: %p\n",
                                      DsInstallInfo.Credentials ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tpfnUpdateStatus: %p\n",
                                      DsInstallInfo.pfnUpdateStatus ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tAdminPassword: %p\n",
                                      DsInstallInfo.AdminPassword ));
                }
#endif
            }
        }
        
        DsRolepFreeAuthIdentForCreds( AuthIdent );
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolepInstallDs returned %lu\n",
                      Win32Err ));

    if ( fRewindServer ) {

        Server -= 2;
        
    }

    return( Win32Err );
}




DWORD
DsRolepStopDs(
    IN  BOOLEAN DsInstalled
    )
/*++

Routine Description:

    "Uninitinalizes" the Lsa and stops the Ds

Arguments:

    DsInstalled -- If TRUE, stop the Ds.

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    if ( DsInstalled ) {

        NTSTATUS Status = LsapDsUnitializeDsStateInfo();

        if ( NT_SUCCESS( Status ) ) {

            DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsInstallShutdown );

            if ( Win32Err == ERROR_SUCCESS ) {

                Win32Err = ( *DsrNtdsInstallShutdown )();

                if ( Win32Err != ERROR_SUCCESS ) {

                    DsRoleDebugOut(( DEB_ERROR,
                                     "NtdsInstallShutdown failed with %lu\n", Win32Err ));
                }
            }

        } else {

            Win32Err = RtlNtStatusToDosError( Status );

        }

    }

    DsRolepLogOnFailure( Win32Err,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "DsRolepStopDs failed with %lu\n",
                                            Win32Err )) );

    return( Win32Err );
}



DWORD
DsRolepDemoteDs(
    IN LPWSTR DnsDomainName,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR AdminPassword,
    IN LPWSTR SupportDc,
    IN LPWSTR SupportDomain,
    IN HANDLE ImpersonateToken,
    IN BOOLEAN LastDcInDomain,
    IN ULONG  cRemoveNCs,
    IN LPWSTR * pszRemoveNCs,
    IN ULONG  Flags
    )
/*++

Routine Description:

    Wrapper for the routine that does the actual demotion.

Arguments:

    DnsDomainName - Dns domain name of the domain to demote

    Account - Account to use for the demotion

    Password - Password to use with the above account

    AdminPassword -- Administrator password to set for the domain

    SupportDc - Optional.  Name of a Dc in a domain (current or parent) to
        clean up Ds information

    SupportDomain - Optional.  Name of the domain (current or parent) to
        clean up Ds information
        
    ImpersonateToken - the token of caller of the role change API

    LastDcInDomain - If TRUE, this is the last Dc in the domain

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PSEC_WINNT_AUTH_IDENTITY AuthIdent = NULL;
    NTSTATUS Status;

    DSROLEP_CURRENT_OP0( DSROLEEVT_UNINSTALL_DS );

    DsRoleDebugOut(( DEB_TRACE_DS, "Calling NtdsDemote for %ws\n", DnsDomainName ));

    DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsDemote );

    if ( Win32Err == ERROR_SUCCESS ) {

        DsRolepSetAndClearLog();

        //
        // Build the cred structure
        //
        Win32Err = DsRolepCreateAuthIdentForCreds( Account, Password, &AuthIdent );

        if ( Win32Err == ERROR_SUCCESS ) {

            Status = LsapDsUnitializeDsStateInfo();

            if ( !NT_SUCCESS( Status ) ) {

                Win32Err = RtlNtStatusToDosError( Status );

            }

        }

        if ( Win32Err == ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_TRACE_DS, "Invoking NtdsDemote\n" ));

            Win32Err = ( *DsrNtdsDemote )( AuthIdent,
                                           AdminPassword,
                                           (LastDcInDomain ? NTDS_LAST_DC_IN_DOMAIN : 0)|DsRolepDemoteFlagsToNtdsFlags(Flags),
                                           SupportDc,
                                           ImpersonateToken,
                                           DsRolepStringUpdateCallback,
                                           DsRolepStringErrorUpdateCallback,
                                           cRemoveNCs,
                                           pszRemoveNCs );

            if ( Win32Err != ERROR_SUCCESS ) {

                //
                // Switch the LSA back to using the DS
                //
                LsapDsInitializeDsStateInfo( LsapDsDs );
            }

            //
            // Free the allocated creditials structure
            //
            DsRolepFreeAuthIdentForCreds( AuthIdent );
        }

        DsRolepSetAndClearLog();

        DsRolepLogPrint(( DEB_TRACE_DS, "NtdsDemote returned %lu\n",
                          Win32Err ));

    }

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolepDemoteDs returned %lu\n",
                      Win32Err ));

    DSROLEP_FAIL0( Win32Err, DSROLERES_DEMOTE_DS );
    return( Win32Err );
}





DWORD
DsRolepUninstallDs(
    VOID
    )
/*++

Routine Description:

    Uninstalls the Ds.

Arguments:

    VOID

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsInstallUndo );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err =  ( *DsrNtdsInstallUndo )( );

    }

    DsRoleDebugOut(( DEB_TRACE_DS, "NtdsUnInstall returned %lu\n", Win32Err ));

    return( Win32Err );

}

DWORD
DsRolepDemoteFlagsToNtdsFlags(
    DWORD Flags
    )
{
    DWORD fl = 0;

    fl |= ( FLAG_ON( Flags, DSROLE_DC_DONT_DELETE_DOMAIN ) ? NTDS_DONT_DELETE_DOMAIN : 0 );
    fl |= ( FLAG_ON( Flags, DSROLE_DC_FORCE_DEMOTE )       ? NTDS_FORCE_DEMOTE       : 0 );

    return fl;
}

DWORD
DsRolepLoadHive(
    IN LPWSTR Hive,
    IN LPWSTR KeyName
    )
/*++

Routine Description:

    This function will load a hive into the registry
    
Arguments:

    lpRestorePath - The location of the restored files.
    
    lpDNSDomainName - This parameter will recieve the name of the domain that this backup came
                      from

    State - The return Values that report How the syskey is stored and If the back was likely
              taken form a GC or not.


Return Values:

    ERROR_SUCCESS - Success

--*/

{
    DWORD Win32Err = ERROR_SUCCESS;

    Win32Err = RegLoadKeyW(
                      HKEY_LOCAL_MACHINE,        
                      KeyName, 
                      Hive);

    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_WARN, "Failed to load key %ws: %lu retrying\n",
                          Hive,
                          Win32Err ));
        RegUnLoadKeyW(
                  HKEY_LOCAL_MACHINE,
                  KeyName);
        Win32Err = RegLoadKeyW(
                      HKEY_LOCAL_MACHINE,        
                      KeyName, 
                      Hive);
        if (Win32Err != ERROR_SUCCESS) {
            DsRolepLogPrint(( DEB_ERROR, "Failed to load key %ws: %lu\n",
                          Hive,
                          Win32Err ));
            goto cleanup;
        }

    }

    cleanup:

    return Win32Err;

}


DWORD                            
WINAPI
DsRolepClearIfmParams(
    void
    )
/*++

Routine Description:

    Deallocate the IFM params.

Return Values:

    ERROR_SUCCESS

--*/
{
    IFM_SYSTEM_INFO * pIfm = &DsRolepCurrentIfmOperationHandle.IfmSystemInfo;

    ASSERT(DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock);
    
    //
    // Deallocate and clear the IFM_SYSTEM_INFO blob
    //

    if (pIfm->wszRestorePath) {
        LocalFree(pIfm->wszRestorePath);
    }
    if (pIfm->wszDnsDomainName) {
        LocalFree(pIfm->wszDnsDomainName);
    }
    if (pIfm->wszOriginalDitPath) {
        LocalFree(pIfm->wszOriginalDitPath);
    }
    if (pIfm->pvSysKey) {
        // We need to scrub the syskey from memory, before freeing it.
        memset(pIfm->pvSysKey, 0, pIfm->cbSysKey);
        LocalFree(pIfm->pvSysKey);
    }
    
    // Clear everything out...
    memset(pIfm, 0, sizeof(IFM_SYSTEM_INFO));

    return(ERROR_SUCCESS);

}

DWORD                            
WINAPI
DsRolepGetDatabaseFacts(
    IN  LPWSTR lpRestorePath
    )
/*++

Routine Description:

    This function will collect all the information from the IFM system's
    "restored" registry that is required for this IFM Dcpromo.
   
    This function will collect this information about the IFM system:
        1. the way the syskey is stored
            a. and the syskey itself if it was stored in the registry
        2. the domain that the database came from
        3. where the backup was taken from a GC or not
        4. the schema version
        5. the original IFM system's DIT/DB path.

Arguments:

    lpRestorePath - The location of the restored files.
    
    This function primarily sets up this global:
        DsRolepCurrentIfmOperationHandle.IfmSystemInfo

Return Values:

    Win32 Error

--*/
{

#define IFM_SYSTEM_KEY    L"ifmSystem"
#define IFM_SECURITY_KEY  L"ifmSecurity"
    
    WCHAR wszAltRegLoc[MAX_PATH+1] = L"\0";
    WCHAR regsystemfilepath[MAX_PATH+1];
    WCHAR regsecurityfilepath[MAX_PATH+1];
    DWORD controlset=0;
    DWORD BootType=0;
    DWORD GCready=0;
    DWORD type=REG_DWORD;
    DWORD size=sizeof(DWORD);
    HKEY  LsaKey=NULL;
    HKEY  hSystemKey=NULL;
    HKEY  phkOldlocation=NULL;
    HKEY  OldSecurityKey=NULL;
    DWORD Win32Err=ERROR_SUCCESS;
    BOOLEAN fWasEnabled=FALSE;
    NTSTATUS Status=STATUS_SUCCESS;
    BOOL SystemKeyloaded=FALSE;
    BOOL SecurityKeyloaded=FALSE;
    WCHAR *pStr = NULL;
    BOOL  bRetryInWriteableLoc = FALSE;

    // This is the structure this function initializes
    IFM_SYSTEM_INFO * pIfmSystemInfo = &(DsRolepCurrentIfmOperationHandle.IfmSystemInfo);

    // Some validation.
    ASSERT(DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock);
    ASSERT(!DsRolepCurrentIfmOperationHandle.fIfmSystemInfoSet);
    ASSERT( wcslen(lpRestorePath) <= MAX_PATH );
    
    //
    // Null out info ...
    //
    ZeroMemory(pIfmSystemInfo, sizeof(IFM_SYSTEM_INFO));

    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                 TRUE,           // Enable
                                 FALSE,          // not client; process wide
                                 &fWasEnabled );
    ASSERT( NT_SUCCESS( Status ) );
    

    //set up the location of the system registry file

    //
    // Set restore path
    //
    pIfmSystemInfo->wszRestorePath = LocalAlloc(LMEM_FIXED, (wcslen(lpRestorePath)+1)*sizeof(WCHAR));
    if (pIfmSystemInfo->wszRestorePath == NULL) {
        Win32Err = GetLastError();
        goto cleanup;
    }
    wcscpy(pIfmSystemInfo->wszRestorePath, lpRestorePath);


    //
    // On first try setup the system and security registry paths
    //
    regsystemfilepath[MAX_PATH] = L'\0';
    wcscpy(regsystemfilepath,lpRestorePath);
    wcsncat(regsystemfilepath,L"\\registry\\system",(MAX_PATH)-wcslen(regsystemfilepath));

    regsecurityfilepath[MAX_PATH] = L'\0';
    wcscpy(regsecurityfilepath,lpRestorePath);
    wcsncat(regsecurityfilepath,L"\\registry\\security",MAX_PATH-wcslen(regsecurityfilepath));

    //
    // First - Load the old IFM system's hive
    //

    //
    // Get the source path of the database and the log files from the old
    // registry
    //
    Win32Err = DsRolepLoadHive(regsystemfilepath,
                               IFM_SYSTEM_KEY);

    if (ERROR_SUCCESS != Win32Err) {

        if (Win32Err != ERROR_ACCESS_DENIED) {
            goto cleanup;
        }
        //
        // This can happen if the IFM Systems hive is on any
        // non-writeable directory, so in this case, we'll try
        // making a copy and retrying.
        //

        //
        // On a retry, copy off the hives, and then re-setup the
        // system and security registry paths
        //

        DsRolepLogPrint(( DEB_TRACE, "No access to IFM registry, copying off and retrying ...\n"));

        // Setup current registry location.
        wcscpy(regsystemfilepath,lpRestorePath);
        wcsncat(regsystemfilepath,L"\\registry",(MAX_PATH)-wcslen(regsystemfilepath));

        Win32Err = DsRolepMakeAltRegistry(regsystemfilepath, 
                                          wszAltRegLoc, 
                                          sizeof(wszAltRegLoc)/sizeof(wszAltRegLoc[0]));
        if (Win32Err) {
            // logged error already ...
            goto cleanup;
        }
        bRetryInWriteableLoc = TRUE;
        ASSERT(wszAltRegLoc[0] != L'\0');

        wcscpy(regsystemfilepath, wszAltRegLoc);
        wcscpy(regsecurityfilepath, wszAltRegLoc);
        wcsncat(regsystemfilepath, L"\\system", (MAX_PATH)-wcslen(regsystemfilepath));
        wcsncat(regsecurityfilepath, L"\\security", (MAX_PATH)-wcslen(regsecurityfilepath));

        // retry load IFM system's hives
        //
        Win32Err = DsRolepLoadHive(regsystemfilepath,
                                   IFM_SYSTEM_KEY);

        if (ERROR_SUCCESS != Win32Err) {
            goto cleanup;
        }

    }
    SystemKeyloaded = TRUE;

    //find the default controlset
    Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  L"ifmSystem\\Select",
                  0,
                  KEY_READ,
                  & LsaKey );

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Failed to open key: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    Win32Err = RegQueryValueExW( 
                LsaKey,
                L"Default",
                0,
                &type,
                (PUCHAR) &controlset,
                &size
                );

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Couldn't Discover proper controlset: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    Win32Err = RegCloseKey(LsaKey);
    LsaKey=NULL;
    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                      Win32Err ));
        goto cleanup;
    }

    //Find the boot type
    if (controlset == 1) {
        Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"ifmSystem\\ControlSet001\\Control\\Lsa",
                      0,
                      KEY_READ,
                      & LsaKey );
    } else {
        Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"ifmSystem\\ControlSet002\\Control\\Lsa",
                      0,
                      KEY_READ,
                      & LsaKey );
    }

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Failed to open key: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    Win32Err = RegQueryValueExW( 
                LsaKey,
                L"SecureBoot",
                0,
                &type,
                (PUCHAR) &BootType,
                &size
                );

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Couldn't Discover proper controlset: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    Win32Err = RegCloseKey(LsaKey);
    LsaKey=NULL;
    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                      Win32Err ));
        goto cleanup;
    }
    
    //find if a GC or not
    if (controlset == 1) {
        Win32Err = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,        
                      L"ifmSystem\\ControlSet001\\Services\\NTDS\\Parameters",  
                      0,
                      KEY_READ,
                      &phkOldlocation 
                    );
    } else {
        Win32Err = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,        
                      L"ifmSystem\\ControlSet002\\Services\\NTDS\\Parameters",  
                      0,
                      KEY_READ,
                      &phkOldlocation 
                    );
    }

    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_ERROR, "RegOpenKeyExW failed to discover the GC state of the database %d\n",
                      Win32Err ));
        goto cleanup;
    }

    Win32Err = RegQueryValueEx(
                      phkOldlocation,           
                      TEXT(GC_PROMOTION_COMPLETE), 
                      0,
                      &type,       
                      (VOID*)&GCready,        
                      &size      
                      );
    if (Win32Err != ERROR_SUCCESS && ERROR_FILE_NOT_FOUND != Win32Err) {
        DsRolepLogPrint(( DEB_ERROR, "RegQueryValueEx failed to discover the GC state of the database %d\n",
                      Win32Err ));
        goto cleanup;

    }

    Win32Err = RegQueryValueEx(
                      phkOldlocation,           
                      TEXT(SYSTEM_SCHEMA_VERSION), 
                      0,
                      &type,       
                      (VOID*)&(pIfmSystemInfo->dwSchemaVersion),        
                      &size      
                      );
    if (Win32Err != ERROR_SUCCESS && ERROR_FILE_NOT_FOUND != Win32Err) {
        DsRolepLogPrint(( DEB_ERROR, "RegQueryValueEx failed to discover the GC state of the database %d\n",
                      Win32Err ));
        goto cleanup;

    }

    //
    // Fill in the wszDitPath for later use.
    //
    Win32Err = DsRolepGetRegString(phkOldlocation,
                                   TEXT(FILEPATH_KEY),
                                   &(pIfmSystemInfo->wszOriginalDitPath));
    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_ERROR, "DsRolepGetRegString() failed to discover the old databae location %d\n",
                      Win32Err ));
        goto cleanup;
    }

    //
    // This code loads the system key from the old registry if 
    // it's supposed (BootType is right).  We ignore errors,
    // as install will print and do the right thing later on.

    //
    ASSERT(BootType);
    ASSERT(pIfmSystemInfo->dwSysKeyStatus == ERROR_SUCCESS);
    if (BootType == 1) {
        // 
        // Fill in the system key if we're supposed.
        //
        Win32Err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,         // handle to open key
                                 IFM_SYSTEM_KEY,  // subkey name
                                 0,   // reserved
                                 KEY_READ, // security access mask
                                 &hSystemKey    // handle to open key
                                 );
        if (Win32Err) {
            pIfmSystemInfo->dwSysKeyStatus = Win32Err;
            DsRolepLogPrint(( DEB_ERROR, "Failed to open key: %lu\n",
                              Win32Err ));
            Win32Err = ERROR_SUCCESS;
        } else {

            pIfmSystemInfo->cbSysKey = SYSKEY_SIZE;
            pIfmSystemInfo->pvSysKey = LocalAlloc(LMEM_FIXED, pIfmSystemInfo->cbSysKey);
            if (pIfmSystemInfo->pvSysKey == NULL) {
                pIfmSystemInfo->dwSysKeyStatus = GetLastError();
                // go on.
            } else {
                Win32Err = WxReadSysKeyEx(hSystemKey,
                                          &pIfmSystemInfo->cbSysKey,
                                          (PVOID)pIfmSystemInfo->pvSysKey);
                if (Win32Err) {
                    pIfmSystemInfo->dwSysKeyStatus = Win32Err;
                    DsRolepLogPrint(( DEB_ERROR, "WxReadSysKeyEx failed to get the syskey %d\n",
                                  Win32Err ));
                    Win32Err = ERROR_SUCCESS;
                }
                Win32Err = RegCloseKey(hSystemKey);
                if (Win32Err!=ERROR_SUCCESS) {
                    DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed  %d\n",
                                  Win32Err ));
                    Win32Err = ERROR_SUCCESS;
                }
            }
        }
 
    } else {
        // SysKey not set
        pIfmSystemInfo->dwSysKeyStatus = ERROR_FILE_NOT_FOUND;
        pIfmSystemInfo->cbSysKey = 0;
    }

    //
    // The System key is no longer needed unload it.
    //
    {
        DWORD tWin32Err = ERROR_SUCCESS;
    
        if ( phkOldlocation ) {
            tWin32Err = RegCloseKey(phkOldlocation);
            phkOldlocation = NULL;
            if ( tWin32Err != ERROR_SUCCESS ) {
                DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                              tWin32Err ));
            }
        }

        if(SystemKeyloaded){
            tWin32Err = RegUnLoadKeyW(
                          HKEY_LOCAL_MACHINE,
                          IFM_SYSTEM_KEY);
            SystemKeyloaded = FALSE;
            if ( tWin32Err != ERROR_SUCCESS) {
                DsRolepLogPrint(( DEB_ERROR, "RegUnLoadKeyW failed to unload system key with %d\n",
                              tWin32Err ));
            }
        }

    }

    Win32Err = DsRolepLoadHive(regsecurityfilepath,
                               IFM_SECURITY_KEY);

    if (ERROR_SUCCESS != Win32Err) {

        goto cleanup;

    }

    SecurityKeyloaded = TRUE;

    //open the security key to pass to LsapRetrieveDnsDomainNameFromHive()
    Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  L"ifmSecurity",
                  0,
                  KEY_READ,
                  & OldSecurityKey );

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Failed to open key: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    pIfmSystemInfo->wszDnsDomainName = LocalAlloc(0, ((DNS_MAX_NAME_LENGTH+1)*sizeof(WCHAR)));
    if(pIfmSystemInfo->wszDnsDomainName == NULL){
        Win32Err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    ZeroMemory(pIfmSystemInfo->wszDnsDomainName,DNS_MAX_NAME_LENGTH*sizeof(WCHAR));

    size = (DNS_MAX_NAME_LENGTH+1)*sizeof(WCHAR);

    //looking for the DNS name of the Domain that the replica is part of.

    Status = LsapRetrieveDnsDomainNameFromHive(OldSecurityKey,
                                               &size,
                                               pIfmSystemInfo->wszDnsDomainName
                                               );
    if (!NT_SUCCESS(Status)) {
        DsRolepLogPrint(( DEB_ERROR, "Failed to retrieve DNS domain name for hive : %lu\n",
                          RtlNtStatusToDosError(Status) ));
        Win32Err = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

    if (GCready) {
        pIfmSystemInfo->dwState |= DSROLE_DC_IS_GC;
    }

    if (BootType == 1) {
        pIfmSystemInfo->dwState |= DSROLE_KEY_STORED;
    } else if ( BootType == 2) {
        pIfmSystemInfo->dwState |= DSROLE_KEY_PROMPT;
    } else if ( BootType == 3) {
        pIfmSystemInfo->dwState |= DSROLE_KEY_DISK;
    } else {
        DsRolepLogPrint(( DEB_ERROR, "Didn't discover Boot type Error Unknown\n"));
        MIDL_user_free(pIfmSystemInfo->wszDnsDomainName);
        pIfmSystemInfo->wszDnsDomainName = NULL;
    }


    cleanup:
    {
        DWORD tWin32Err = ERROR_SUCCESS;
    
        if ( LsaKey ) {
            tWin32Err = RegCloseKey(LsaKey);
            LsaKey=NULL;
            if ( tWin32Err != ERROR_SUCCESS ) {
                DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                              tWin32Err ));
            }
        }

        if ( OldSecurityKey ) {
            tWin32Err = RegCloseKey(OldSecurityKey);
            OldSecurityKey=NULL;
            if ( tWin32Err != ERROR_SUCCESS ) {
                DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                              tWin32Err ));
            }
        }
    
        if ( phkOldlocation ) {
            tWin32Err = RegCloseKey(phkOldlocation);
            phkOldlocation=NULL;
            if ( tWin32Err != ERROR_SUCCESS ) {
                DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                              tWin32Err ));
            }
        }
        
        if(SystemKeyloaded){
            tWin32Err = RegUnLoadKeyW(
                          HKEY_LOCAL_MACHINE,
                          IFM_SYSTEM_KEY);
            if ( tWin32Err != ERROR_SUCCESS) {
                DsRolepLogPrint(( DEB_ERROR, "RegUnLoadKeyW failed with %d\n",
                              tWin32Err ));
            }
        }

        if (SecurityKeyloaded) {
            tWin32Err = RegUnLoadKeyW(
                          HKEY_LOCAL_MACHINE,
                          IFM_SECURITY_KEY);
            if ( tWin32Err != ERROR_SUCCESS) {
                DsRolepLogPrint(( DEB_ERROR, "RegUnLoadKeyW failed with %d\n",
                              tWin32Err ));
            }
        }

        if (bRetryInWriteableLoc && wszAltRegLoc[0] != L'\0') {
            // This also deletes the directory ...
            tWin32Err = NtdspClearDirectory( wszAltRegLoc , TRUE );
            if ( tWin32Err != ERROR_SUCCESS) {
                DsRolepLogPrint(( DEB_ERROR, "Failed (%d) to clear temporary registry from %ws\n",
                              tWin32Err, wszAltRegLoc ));
            }
        }

    }
    
    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                       FALSE,          // Disable
                       FALSE,          // not client; process wide
                       &fWasEnabled );
    ASSERT( NT_SUCCESS( Status ) );

    //
    // Validate and return
    //
    if (ERROR_SUCCESS == Win32Err){

        if (pIfmSystemInfo->wszRestorePath == NULL ||
            pIfmSystemInfo->wszDnsDomainName == NULL ||
            pIfmSystemInfo->wszOriginalDitPath == NULL) {

            ASSERT(!"prgrammer logic error");
            Win32Err = ERROR_DS_CODE_INCONSISTENCY;
        } else {
            DsRolepLogPrint(( DEB_TRACE, 
                              "IFM System Info: \n"
                              "\t Restore Path: %ws\n"
                              "\t Domain: %ws\n"
                              "\t Schema Version: %d\n"
                              "\t Original Dit Path: %ws\n"
                              "\t State: 0x%x\n"
                              "\t SysKey Loaded: %ws (%d)\n",    
                              pIfmSystemInfo->wszRestorePath,
                              pIfmSystemInfo->wszDnsDomainName,
                              pIfmSystemInfo->dwSchemaVersion,
                              pIfmSystemInfo->wszOriginalDitPath,
                              pIfmSystemInfo->dwState,
                              pIfmSystemInfo->pvSysKey ? L"yes" : L"no", pIfmSystemInfo->dwSysKeyStatus
                              ));
        }

    } else {
         
        // This safe to call, as it safely checks before de-allocating.
        DsRolepClearIfmParams();

    }

    return Win32Err;

}


DWORD
DsRolepGetRegString(
    HKEY   hKey,
    WCHAR * wszValueName,
    WCHAR ** pwszOutValue
    )
/*++

Routine Description:

    This gets and allocates (LocalAlloc) a string from the registry
    with the value name in the key provided.
    
Arguments:

    hKey - Opened key handle
    wszValueName - Name of the value label for the registry value desired.
    pwszOutValue - LocalAlloc()'d results of this string.

Return Values:

    Win32 Error

--*/
{
    DWORD   Win32Err;
    DWORD   type=REG_SZ;
    WCHAR * szOutTemp = NULL;
    DWORD   cbOutTemp = 0;

    ASSERT(pwszOutValue);
    *pwszOutValue = NULL;
    
    Win32Err = RegQueryValueEx(hKey,           
                               wszValueName, 
                               0,
                               &type,       
                               (VOID*)szOutTemp,        
                               &cbOutTemp);
    if (Win32Err != ERROR_SUCCESS && Win32Err != ERROR_MORE_DATA) {
        DsRolepLogPrint(( DEB_ERROR, "RegQueryValueEx failed with %d\n",
                      Win32Err ));
        goto cleanup;
    }

    ASSERT(cbOutTemp);

    szOutTemp = LocalAlloc(0, cbOutTemp);
    if (szOutTemp == NULL) {
        Win32Err = GetLastError();
        DsRolepLogPrint(( DEB_ERROR, "LocalAlloc() failed with %d\n",
                      Win32Err ));
        goto cleanup;
    }

    Win32Err = RegQueryValueEx(hKey,
                               wszValueName, 
                               0,
                               &type,       
                               (VOID*)szOutTemp,        
                               &cbOutTemp);
    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_ERROR, "RegQueryValueEx failed with %d\n",
                      Win32Err ));
        goto cleanup;

    }

  cleanup:

    if (Win32Err == ERROR_SUCCESS) {
        *pwszOutValue = szOutTemp;

    }

    return(Win32Err);
}

DWORD
NtdspRemoveROAttrib(
    WCHAR * DstPath
    )
{
    DWORD dwFileAttrs = 0;

    dwFileAttrs = GetFileAttributes(DstPath);
    if (dwFileAttrs == INVALID_FILE_ATTRIBUTES) {
        return(GetLastError());
    }

    if(dwFileAttrs & FILE_ATTRIBUTE_READONLY){
        // Hmmm, we've got a read only file for our DIT or LOG files ... that's no good...
        dwFileAttrs &= ~FILE_ATTRIBUTE_READONLY;
        dwFileAttrs ? dwFileAttrs : FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(DstPath, dwFileAttrs)){
            //
            // success - yeah, fall through ...
            //
        } else {
            // failure
            // There is not much we can do here, we'll probably fail later on, but
            // we'll give it a shot.  A failure here would likely indicate dcpromo
            // was broken in some other way though, such as bad permissions on the
            // db or logs directory.
            return(GetLastError());
        }
    } // else it's writeable, nothing to do :)

    return(ERROR_SUCCESS);
}

DWORD
NtdspClearDirectory(
    IN WCHAR * DirectoryName,
    IN BOOL    fRemoveRO
    )
/*++

Routine Description:

    This routine deletes all the files in Directory and, then
    if the directory is empty, removes the directory.
    
    NOTE: This was stolen from ntdsetup.dll

Parameters:

    DirectoryName: a null terminated string

Return Values:

    A value from winerror.h

    ERROR_SUCCESS - The check was done successfully.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    HANDLE          FindHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR           Path[ MAX_PATH+1 ];
    WCHAR           FilePath[ MAX_PATH+1 ];
    BOOL            fStatus;

    if ( !DirectoryName || DirectoryName[0] == L'\0' )
    {
        ASSERT(!"Programmer error");
        return ERROR_SUCCESS;
    }

    if ( wcslen(DirectoryName) > MAX_PATH - 4 )
    {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory( Path, sizeof(Path) );
    wcscpy( Path, DirectoryName );
    wcscat( Path, L"\\*.*" );

    RtlZeroMemory( &FindData, sizeof( FindData ) );
    FindHandle = FindFirstFile( Path, &FindData );
    if ( INVALID_HANDLE_VALUE == FindHandle )
    {
        WinError = GetLastError();
        goto ClearDirectoryExit;
    }

    do
    {

        if (  !FLAG_ON( FindData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY ) )
        {
            RtlZeroMemory( FilePath, sizeof(FilePath) );
            wcscpy( FilePath, DirectoryName );
            wcscat( FilePath, L"\\" );
            wcscat( FilePath, FindData.cFileName );

            fStatus = DeleteFile( FilePath );

            if (fRemoveRO && fStatus) {
                // perhaps it's RO ...
                NtdspRemoveROAttrib( FilePath );
                // now give it another go ...
                fStatus = DeleteFile( FilePath );
            }

            //
            // Even if error, continue on
            //
        }

        RtlZeroMemory( &FindData, sizeof( FindData ) );

    } while ( FindNextFile( FindHandle, &FindData ) );

    WinError = GetLastError();
    if ( ERROR_NO_MORE_FILES != WinError
      && ERROR_SUCCESS != WinError  )
    {
        goto ClearDirectoryExit;
    }
    WinError = ERROR_SUCCESS;

    //
    // Fall through to the exit
    //

ClearDirectoryExit:

    if ( ERROR_NO_MORE_FILES == WinError )
    {
        WinError = ERROR_SUCCESS;
    }

    if ( INVALID_HANDLE_VALUE != FindHandle )
    {
        FindClose( FindHandle );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        //
        // Try to remove the directory
        //
        fStatus = RemoveDirectory( DirectoryName );

        //
        // Ignore the error and continue on
        //

    }

    return WinError;
}


DWORD
WINAPI
DsRolepMakeAltRegistry(
    IN  WCHAR *  wszOldRegPath,
    OUT WCHAR *  wszNewRegPath,
    IN  ULONG    cbNewRegPath
    )
/*++

Routine Description:

    This routine will create an alternate location for the system
    and security hives/registries.  We create a directory which
    is returned in wszNewRegPath.
    
Arguments:

    wszOldRegPath [IN] - The path to copy the system and security hives from.
    wszNewRegPath [OUT] - The buffer to hold the location of the alternate hives.
    cbNewRegPath [IN] - The size of the wszNewRegPath buffer.
               

Return Values:

    Win32 Error

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR wszTempPath[MAX_PATH+1];
    WCHAR wszDest[MAX_PATH+1];
    SYSTEMTIME sTime;

    if (wszOldRegPath == NULL || wszOldRegPath[0] == L'\0' || cbNewRegPath < sizeof(WCHAR)) {
        ASSERT(!"Seems unlikely");
        return(ERROR_INVALID_PARAMETER);
    }
    wszNewRegPath[0] = L'\0';

    //
    // 1) Create temp registry directory.
    //

    // Determine the system root
    if (!GetEnvironmentVariable(L"temp", wszTempPath, sizeof(wszTempPath)/sizeof(wszTempPath[0]) )){
        Win32Err = GetLastError();
        DsRolepLogPrint(( DEB_ERROR, "Failed to retrieve environmental variable \"temp\" - 0x%x\n", Win32Err));
        goto cleanup;
    }

    //dwTime = GetSecondsSince1601();
    GetSystemTime( &sTime );
    Win32Err = StringCbPrintf(wszNewRegPath, cbNewRegPath, 
                              L"%ws\\ifm-reg-%d-%d-%d-%d-%d",
                              wszTempPath, sTime.wYear, sTime.wMonth, 
                              sTime.wDay, sTime.wMinute, sTime.wSecond);
    Win32Err = HRESULT_CODE(Win32Err);
    if (Win32Err) {
        wszNewRegPath[0] = L'\0'; // don't clean up directory
        DsRolepLogPrint(( DEB_ERROR, "Failed to format temp registry path 0x%x\n", Win32Err));
        goto cleanup;
    }

    if ( CreateDirectory( wszNewRegPath, NULL ) == FALSE ) {
        Win32Err = GetLastError() ? GetLastError() : ERROR_INVALID_PARAMETER;
        wszNewRegPath[0] = L'\0'; // don't clean up directory
        DsRolepLogPrint(( DEB_ERROR, "Failed to create temp directory for temp registry files 0x%x, %ws\n", wszNewRegPath, Win32Err));
        goto cleanup;
    }

    //
    // 2) Copy over registries of interest
    //
    
    DsRolepLogPrint(( DEB_TRACE, "Making copy of IFM registry to temp directry: %ws\n", wszNewRegPath));

    // First copy the system registry
    wcscpy(wszTempPath, wszOldRegPath);
    wcsncat(wszTempPath, L"\\system", (MAX_PATH)-wcslen(wszTempPath));
    wcscpy(wszDest, wszNewRegPath);
    wcsncat(wszDest, L"\\system", (MAX_PATH)-wcslen(wszDest));
    if ( CopyFile( wszTempPath, wszDest, TRUE ) == FALSE ) {
        Win32Err = GetLastError();
        DsRolepLogPrint(( DEB_ERROR, "Failed to copy file from %ws to %ws with 0x%x\n", wszTempPath, wszDest, Win32Err));
        goto cleanup;
    }

    // Then copy the security registry
    wcscpy(wszTempPath, wszOldRegPath);
    wcsncat(wszTempPath, L"\\security", (MAX_PATH)-wcslen(wszTempPath));
    wcscpy(wszDest, wszNewRegPath);
    wcsncat(wszDest, L"\\security", (MAX_PATH)-wcslen(wszDest));
    if ( CopyFile( wszTempPath, wszDest, TRUE ) == FALSE ) {
        Win32Err = GetLastError();
        DsRolepLogPrint(( DEB_ERROR, "Failed to copy file from %ws to %ws with 0x%x\n", wszTempPath, wszDest, Win32Err));
        goto cleanup;
    }

  cleanup:

    if (Win32Err && wszNewRegPath[0] != L'\0') {
        // Need to see if we can clean up what we did.
        NtdspClearDirectory( wszNewRegPath , TRUE );
        wszNewRegPath[0] = L'\0';
    }

    return(Win32Err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\ds.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ds.h
    
Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __DS_H__
#define __DS_H__

#include "dssetup_c.h"

DWORD
DsRolepInstallDs(
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FlatDomainName,
    IN  LPWSTR DnsTreeName,
    IN  LPWSTR SiteName,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  IFM_SYSTEM_INFO * pIfmSystemInfo,
    IN  LPWSTR SysVolRootPath,
    IN  PUNICODE_STRING Bootkey,
    IN  LPWSTR AdminAccountPassword,
    IN  LPWSTR ParentDnsName OPTIONAL,
    IN  LPWSTR Server OPTIONAL,
    IN  LPWSTR Account OPTIONAL,
    IN  LPWSTR Password OPTIONAL,
    IN  LPWSTR SafeModePassword OPTIONAL,
    IN  LPWSTR SourceDomain,
    IN  ULONG Options,
    IN  BOOLEAN Replica,
    IN  HANDLE  ImpersonateToken,
    OUT LPWSTR *InstalledSite,
    IN  OUT GUID   *DomainGuid,
    OUT PSID   *NewDomainSid
    );

DWORD
DsRolepStopDs(
    IN  BOOLEAN DsInstalled
    );

DWORD
DsRolepUninstallDs(
    );

DWORD
DsRolepDemoteDs(
    IN LPWSTR DnsDomainName,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR DomainAdminPassword,
    IN LPWSTR SupportDc,
    IN LPWSTR SupportDomain,
    IN HANDLE ImpersonateToken,
    IN BOOLEAN LastDcInDomain,
    IN ULONG  cRemoveNCs,
    IN LPWSTR * pszRemoveNCs,
    IN ULONG  flags
    );


DWORD
DsRolepDemoteFlagsToNtdsFlags(
    DWORD Flags
    );

DWORD
WINAPI
DsRolepGetDatabaseFacts(
    IN  LPWSTR lpRestorePath
    );

DWORD                            
WINAPI
DsRolepClearIfmParams(
    void
    );

DWORD
DsRolepTreeCopy(
    IN LPWSTR Source,
    IN LPWSTR Dest
    );


#endif // __DS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\dssetup_s_stub.c ===
#include "dssetup_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\log.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    log.c

Abstract:

    Implementation of the internal debug and support routines

Author:

    Colin Brace              April 5, 1999

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <loadfn.h>
#include <samrpc.h>
#include <samisrv.h>
#include <nlrepl.h>
#include <lmjoin.h>
#include <netsetp.h>
#include <lmaccess.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>

#define UNICODE_BYTE_ORDER_MARK 0xFEFF

//
// Global handle to the log file
//
HANDLE DsRolepLogFile = NULL;
CRITICAL_SECTION LogFileCriticalSection;

#define LockLogFile()    RtlEnterCriticalSection( &LogFileCriticalSection );
#define UnlockLogFile()  RtlLeaveCriticalSection( &LogFileCriticalSection );

//
// log file name
//
#define DSROLEP_LOGNAME L"\\debug\\DCPROMO.LOG"
#define DSROLEP_BAKNAME L"\\debug\\DCPROMO.BAK"

DWORD
DsRolepInitializeLogHelper(
    IN DWORD TimesCalled
    )
/*++

Routine Description:

    Initializes the debugging log file used by DCPROMO and the dssetup apis
    
    N.B. This will not delete a previous log file; rather it will continue
    to use the same one.

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR LogFileName[ MAX_PATH + 1 ];
    WCHAR bakLogFileName[ MAX_PATH + 1 ];
    WCHAR cBOM = UNICODE_BYTE_ORDER_MARK;
    BOOLEAN fSuccess;

    ASSERT(TimesCalled <= 2 && L"MoveFile failed to move file but reported success.");
    if (TimesCalled > 2) {
        DsRoleDebugOut(( DEB_ERROR,
                         "MoveFile failed to move file but reported success.\n",
                         dwErr ));
        return ERROR_GEN_FAILURE;
    }

    LockLogFile();

    //
    // Construct the log file name
    //
    if ( !GetWindowsDirectoryW( LogFileName,
                                sizeof(LogFileName)/sizeof(*LogFileName) ) ) {

        dwErr = GetLastError();
        DsRoleDebugOut(( DEB_ERROR,
                         "GetWindowsDirectory failed with %lu\n",
                         dwErr ));
        goto Exit;
    }
    wcsncat( LogFileName, DSROLEP_LOGNAME, MAX_PATH-wcslen(LogFileName) );
    DsRoleDebugOut(( DEB_TRACE,
                     "Logfile name: %ws\n",
                     LogFileName ));

    //
    // Open the file
    //
    DsRolepLogFile = CreateFileW( LogFileName,
                                  GENERIC_WRITE | GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

    if ( DsRolepLogFile == INVALID_HANDLE_VALUE ) {

        dwErr = GetLastError();

        DsRoleDebugOut(( DEB_ERROR,
                         "CreateFile on %ws failed with %lu\n",
                         LogFileName,
                         dwErr ));
        DsRolepLogFile = NULL;
        goto Exit;
    }

    if ( ERROR_ALREADY_EXISTS != GetLastError() ) {
        //This is a unicode file so if it was just
        //created the Byte-order Mark needs to be
        //added to the beginning of the file.

        DWORD lpNumberOfBytesWritten = 0;

        if ( !WriteFile(DsRolepLogFile,
                        (LPCVOID)&cBOM,
                        sizeof(WCHAR), 
                        &lpNumberOfBytesWritten,
                        NULL) )
        {
            dwErr = GetLastError();
            DsRoleDebugOut(( DEB_ERROR,
                         "WriteFile on %ws failed with %lu\n",
                         LogFileName,
                         dwErr ));
            goto Exit;
        }

        ASSERT(lpNumberOfBytesWritten == sizeof(WCHAR));

    } else {
        //See if the opened file is UNICODE
        //if not move it and create a new file.
        WCHAR wcBuffer = 0;
        DWORD lpNumberOfBytesRead = 0;

        if ( !ReadFile(DsRolepLogFile,
                       (LPVOID)&wcBuffer,
                       sizeof(WCHAR),
                       &lpNumberOfBytesRead,
                       NULL) ) 
        {
            dwErr = GetLastError();
            DsRoleDebugOut(( DEB_ERROR,
                         "ReadFile on %ws failed with %lu\n",
                         LogFileName,
                         dwErr ));
            goto Exit;    
        }

        ASSERT(lpNumberOfBytesRead == sizeof(WCHAR));

        if (cBOM != wcBuffer) {
            //This is not a UNICODE FILE Move it.
            //Create a New Dcpromo Log

            //
            // Construct the bak log file name
            //
            if ( !GetWindowsDirectoryW( bakLogFileName,
                                        sizeof(bakLogFileName)/sizeof(*bakLogFileName) ) ) {
        
                dwErr = GetLastError();
                DsRoleDebugOut(( DEB_ERROR,
                                 "GetWindowsDirectory failed with %lu\n",
                                 dwErr ));
                goto Exit;
            }
            wcsncat( bakLogFileName, DSROLEP_BAKNAME, MAX_PATH-wcslen(bakLogFileName) );
            DsRoleDebugOut(( DEB_TRACE,
                             "Logfile name: %ws\n",
                             bakLogFileName ));

            if ( DsRolepLogFile ) {
        
                 CloseHandle( DsRolepLogFile );
                 DsRolepLogFile = NULL;
                
            }

            //move the file
            if ( !MoveFile(LogFileName,                           
                           bakLogFileName) )
            {
                 dwErr = GetLastError();
                 DsRoleDebugOut(( DEB_ERROR,
                                  "MoveFile From %ws to %ws failed with %lu\n",
                                  LogFileName,
                                  bakLogFileName,
                                  dwErr ));
                 goto Exit;
            }

            UnlockLogFile();

            return DsRolepInitializeLogHelper(TimesCalled+1);
        
        }


    }

    //No longer need read access so reopen the file
    //with just write access.

    if ( DsRolepLogFile ) {
        
         CloseHandle( DsRolepLogFile );
         DsRolepLogFile = NULL;
        
    }

    DsRolepLogFile = CreateFileW( LogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

    //
    // Goto to the end of the file
    //
    if( SetFilePointer( DsRolepLogFile,
                        0, 0,
                        FILE_END ) == 0xFFFFFFFF ) {

        dwErr = GetLastError();
        DsRoleDebugOut(( DEB_ERROR,
                         "SetFilePointer failed with %lu\n",
                         dwErr ));
        goto Exit;
    }

    //
    // That's it
    //
    ASSERT( ERROR_SUCCESS == dwErr );

Exit:

    if ( (ERROR_SUCCESS != dwErr)
      && (NULL != DsRolepLogFile)   ) {

        CloseHandle( DsRolepLogFile );
        DsRolepLogFile = NULL;
        
    }

    UnlockLogFile();

    return( dwErr );
}

DWORD
DsRolepInitializeLog(
    VOID
    )
/*++

Routine Description:

    Initializes the debugging log file used by DCPROMO and the dssetup apis
    
    N.B. This will not delete a previous log file; rather it will continue
    to use the same one.

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{

    //caller the helper function for the first time.
    return DsRolepInitializeLogHelper(1);

}



DWORD
DsRolepCloseLog(
    VOID
    )
/*++

Routine Description:

    Closes the debugging log file used by DCPROMO and the dssetup apis

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD dwErr = ERROR_SUCCESS;

    LockLogFile();

    if ( DsRolepLogFile != NULL ) {

        CloseHandle( DsRolepLogFile );
        DsRolepLogFile = NULL;
    }

    UnlockLogFile();

    return( dwErr );
}



//
// Stolen and hacked up from netlogon code
//

VOID
DsRolepDebugDumpRoutine(
    IN DWORD DebugFlag,
    IN LPWSTR Format,
    va_list arglist
    )

{
    #define DsRolepDebugDumpRoutine_BUFFERSIZE 1024

    WCHAR OutputBuffer[DsRolepDebugDumpRoutine_BUFFERSIZE];
    ULONG length;
    DWORD BytesWritten;
    SYSTEMTIME SystemTime;
    static BeginningOfLine = TRUE;

    //
    // If we don't have an open log file, just bail
    //
    if ( DsRolepLogFile == NULL ) {

        return;
    }

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        CHAR  *Prolog;

        if ( FLAG_ON( DebugFlag, DEB_ERROR ) ) {
            Prolog = "[ERROR] ";
        } else if ( FLAG_ON( DebugFlag, DEB_WARN ) ) {
            Prolog = "[WARNING] ";
        } else if (  FLAG_ON( DebugFlag, DEB_TRACE ) 
                  || FLAG_ON( DebugFlag, DEB_TRACE_DS ) ) {
            Prolog = "[INFO] ";
        } else {
            Prolog = "";
        }

        //
        // Put the timestamp at the begining of the line.
        //
        GetLocalTime( &SystemTime );
        length += (ULONG) wsprintfW( &OutputBuffer[length],
                                     L"%02u/%02u %02u:%02u:%02u %S",
                                     SystemTime.wMonth,
                                     SystemTime.wDay,
                                     SystemTime.wHour,
                                     SystemTime.wMinute,
                                     SystemTime.wSecond,
                                     Prolog );
    }

    //
    // Put a the information requested by the caller onto the line
    //
    length += (ULONG) wvsprintfW(&OutputBuffer[length],
                                 Format, 
                                 arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == L'\n' );
    if ( BeginningOfLine ) {

        OutputBuffer[length-1] = L'\r';
        OutputBuffer[length] = L'\n';
        OutputBuffer[length+1] = L'\0';
        length++;
    }

    ASSERT( length <= sizeof( OutputBuffer ) / sizeof( WCHAR ) );

    //
    // Grab the lock
    //
    LockLogFile();

    //
    // Write the debug info to the log file.
    //
    if ( !WriteFile( DsRolepLogFile,
                     OutputBuffer,
                     length*sizeof(WCHAR),
                     &BytesWritten,
                     NULL ) ) {

        DsRoleDebugOut(( DEB_ERROR,
                         "Log write of %ws failed with %lu\n",
                         OutputBuffer,
                         GetLastError() ));
    }

    DsRoleDebugOut(( DebugFlag,
                     "%ws",
                     OutputBuffer ));



    //
    // Release the lock
    //
    UnlockLogFile();

    return;

}

VOID
DsRolepLogPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    PWCHAR WFormat = NULL;
    va_list arglist;
    DWORD WinErr = ERROR_SUCCESS;
    DWORD Bufsize = strlen(Format)+1;

    WFormat = (PWCHAR)malloc(Bufsize*sizeof(WCHAR));
    if ( WFormat ) {
        MultiByteToWideChar(CP_ACP,
                            0,
                            Format,
                            -1,
                            WFormat,
                            Bufsize
                            );
    } else {
        DsRoleDebugOut(( DEB_ERROR,
                         "Log write failed with %lu\n",
                         ERROR_NOT_ENOUGH_MEMORY ));
    }

    va_start(arglist, Format);

    if ( WFormat ) {
        DsRolepDebugDumpRoutine( DebugFlag, WFormat, arglist );
    }
    
    va_end(arglist);

    if (WFormat) {
        free(WFormat);
    }
}

DWORD
DsRolepSetAndClearLog(
    VOID
    )
/*++

Routine Description:

    Flushes the log and seeks to the end of the file

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD dwErr = ERROR_SUCCESS;

    LockLogFile();

    if ( DsRolepLogFile != NULL ) {

        if( SetFilePointer( DsRolepLogFile,
                            0, 0,
                            FILE_END ) == 0xFFFFFFFF ) {

            dwErr = GetLastError();
        }

        if( FlushFileBuffers( DsRolepLogFile ) == FALSE ) {

            dwErr = GetLastError();
        }
    }

    UnlockLogFile();

    return( dwErr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\log.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    log.h

Abstract:

    Definitions and globals for internal only debug and support routines

Author:

    Mac McLain      (MacM)       Aug 11, 1997

Environment:

Revision History:

--*/
#ifndef __LOG_H__
#define __LOG_H__

#define DSROLEP_VERBOSE_LOGGING

#ifdef DSROLEP_VERBOSE_LOGGING


#define DEB_TRACE_DS        0x00000008
#define DEB_TRACE_UPDATE    0x00000010
#define DEB_TRACE_LOCK      0x00000020
#define DEB_TRACE_SERVICES  0x00000040
#define DEB_TRACE_NET       0x00000080

//
// exported so it can be init'ed in DsRolepInitialize
//
extern CRITICAL_SECTION LogFileCriticalSection;

DWORD
DsRolepInitializeLog(
    VOID
    );

DWORD
DsRolepSetAndClearLog(
    VOID
    );

DWORD
DsRolepCloseLog(
    VOID
    );

VOID
DsRolepLogPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define DsRolepLogPrint( x )  DsRolepLogPrintRoutine x
#define DsRolepDisplayOptional( y ) y ? y : L"(NULL)"
#define DsRolepLogOnFailure( z, a ) if ( z != ERROR_SUCCESS ) a
#define DsRolepLogGuid( l, t, g )  g == NULL ? DsRolepLogPrint(( l, "%S (NULL)\n", t )) :       \
        DsRolepLogPrint(( l, "%S %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",            \
                        t,(g)->Data1,(g)->Data2,(g)->Data3,(g)->Data4[0],                       \
                        (g)->Data4[1],(g)->Data4[2],(g)->Data4[3],(g)->Data4[4],                \
                        (g)->Data4[5],(g)->Data4[6],(g)->Data4[7]))

#define DsRolepLogSid( l, t, s )                                                                \
{ LPWSTR sidstring;                                                                             \
  ConvertSidToStringSidW( s, &sidstring );                                                      \
  DsRolepLogPrint(( l, "%S %ws\n", t, sidstring ));                                             \
  LocalFree(sidstring);                                                                         \
}

#define DsRolepUnicodestringtowstr( s, u )                                                      \
{ s = (WCHAR*)malloc(u.Length+sizeof(WCHAR));                                                               \
  if (s){                                                                                       \
      CopyMemory(s,u.Buffer,u.Length);                                                          \
      s[u.Length/sizeof(WCHAR)] = L'\0';                                                        \
  }                                                                                             \
}



#else

#define DsRolepInitializeLog()
#define DsRolepCloseLog()
#define DsRolepLogPrint( x )
#define DsRolepDisplayOptional( y )
#define DsRolepLogOnFailure( z, a )
#define DsRolepLogGuid( t, g )
#define DsRolepLogSid( t, s )
#define DsRolepSetAndClearLog()
#define DsRolepUnicodestringtowstr( s, u )
#endif

#endif // __LOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\loadfn.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    loadfn.h

Abstract:

    Definitions and globals for dynamically loading the required functions from
    the setup dlls

Author:

    Mac McLain      (MacM)       June 11, 1997

Environment:

Revision History:

--*/
#ifndef __LOADFN_H__
#define __LOADFN_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines NTDSSET_ALLOCATE
//
#ifdef EXTERN
    #undef EXTERN
#endif

#ifdef NTDSSET_ALLOCATE
    #define EXTERN
#else
    #define EXTERN extern
#endif


#include <scesetup.h>

typedef DWORD ( *DSR_NtdsInstall )(
            IN PNTDS_INSTALL_INFO InstallInfo,
            OUT LPWSTR *InstalledSiteName, OPTIONAL
            OUT GUID   *NewDnsDomainGuid,  OPTIONAL
            OUT PSID   *NewDnsDomainSid    OPTIONAL
            );

typedef DWORD ( *DSR_NtdsInstallShutdown )(
            VOID
            );

typedef DWORD ( *DSR_NtdsInstallUndo )(
            VOID
            );

typedef DWORD ( *DSR_NtdsGetDefaultDnsName )(
            OUT OPTIONAL WCHAR *DnsName,
            IN  OUT ULONG *DnsNameLength
            );

typedef DWORD ( *DSR_NtdsSetReplicaMachineAccount )(
            IN SEC_WINNT_AUTH_IDENTITY *Credentials,
            IN HANDLE                   ClientToken,                
            IN LPWSTR                   DcName,
            IN LPWSTR                   AccountName,
            IN ULONG                    AccountFlags,
            IN OUT WCHAR**              AccountDn OPTIONAL
            );

typedef DWORD ( *DSR_NtdsPrepareForDemotion ) (
            IN ULONG                    Flags,
            IN LPWSTR                   ServerName,
            IN SEC_WINNT_AUTH_IDENTITY *Credentials,       OPTIONAL
            IN CALLBACK_STATUS_TYPE     pfnStatusCallBack, OPTIONAL
            IN CALLBACK_ERROR_TYPE      pfnErrorStatus,    OPTIONAL
            IN HANDLE                   ClientToken,       OPTIONAL
            IN ULONG                    cRemoveNCs,                           
            IN LPWSTR *                 pszRemoveNCs,      OPTIONAL
            OUT PNTDS_DNS_RR_INFO      *pDnsRRInfo
            );

typedef DWORD ( *DSR_NtdsPrepareForDemotionUndo ) (
            VOID
            );

typedef DWORD ( *DSR_NtdsDemote ) (
            IN PSEC_WINNT_AUTH_IDENTITY Credentials,   OPTIONAL
            IN LPWSTR                   AdminPassword, OPTIONAL
            IN DWORD                    Flags,
            IN LPWSTR                   ServerName,
            IN HANDLE                   ClientToken,
            IN CALLBACK_STATUS_TYPE     pfnStatusCallBack, OPTIONAL
            IN CALLBACK_ERROR_TYPE      pfnErrorCallBack,   OPTIONAL
            IN ULONG                    cRemoveNCs,                           
            IN LPWSTR *                 pszRemoveNCs       OPTIONAL
            );

typedef DWORD ( *DSR_NtdsInstallCancel ) (
            VOID
            );

typedef DWORD ( *DSR_NtdsInstallReplicateFull ) (
            IN CALLBACK_STATUS_TYPE     pfnStatusCallBack,
            IN HANDLE                   ClientToken,
            IN ULONG                    ulRepOptions
            );

typedef DWORD ( *DSR_NtdsFreeDnsRRInfo ) (
            IN PNTDS_DNS_RR_INFO     pDnsRRInfo
            );
//
// Security editor prototypes
//
typedef DWORD ( WINAPI *DSR_SceDcPromoteSecurityEx ) (
    IN HANDLE ClientToken,
    IN ULONG Options,
    IN CALLBACK_STATUS_TYPE pfnStatusCallBack
    );

typedef DWORD ( WINAPI *DSR_SceDcPromoCreateGPOsInSysvolEx ) (
    IN HANDLE ClientToken,
    IN LPWSTR Domain,
    IN LPWSTR SysvolRoot,
    IN ULONG Options,
    IN CALLBACK_STATUS_TYPE pfnStatusCallBack
    );

typedef DWORD ( WINAPI *DSR_SceSetupSystemByInfName ) (
    IN PWSTR InfFullName,
    IN PCWSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area,
    IN UINT nFlag,
    IN PSCE_NOTIFICATION_CALLBACK_ROUTINE pSceNotificationCallBack OPTIONAL,
    IN OUT PVOID pValue OPTIONAL
    );

//
// NTFRS initialization prototypes
//
typedef DWORD ( *DSR_NtFrsApi_PrepareForPromotionW ) (
            IN CALLBACK_ERROR_TYPE      pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_PrepareForDemotionW ) (
            IN CALLBACK_ERROR_TYPE      pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_PrepareForDemotionUsingCredW ) (
            IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
            IN HANDLE ClientToken,
            IN CALLBACK_ERROR_TYPE     pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_StartPromotionW ) (
            IN PWCHAR   ParentComputer,                         OPTIONAL
            IN PWCHAR   ParentAccount,                          OPTIONAL
            IN PWCHAR   ParentPassword,                         OPTIONAL
            IN DWORD    DisplayCallBack(IN PWCHAR Display),     OPTIONAL
            IN CALLBACK_ERROR_TYPE      pfnErrorCallBack,       OPTIONAL
            IN PWCHAR   ReplicaSetName,
            IN PWCHAR   ReplicaSetType,
            IN DWORD    ReplicaSetPrimary,
            IN PWCHAR   ReplicaSetStage,
            IN PWCHAR   ReplicaSetRoot
            );

typedef DWORD ( *DSR_NtFrsApi_StartDemotionW ) (
            IN PWCHAR   ReplicaSetName,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_WaitForPromotionW ) (
            IN DWORD    TimeoutInMilliSeconds,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_WaitForDemotionW ) (
            IN DWORD    TimeoutInMilliSeconds,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_CommitPromotionW ) (
            IN DWORD    TimeoutInMilliSeconds,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_CommitDemotionW ) (
            IN DWORD    TimeoutInMilliSeconds,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_AbortPromotionW ) (
            VOID
            );

typedef DWORD ( *DSR_NtFrsApi_AbortDemotionW ) (
            VOID
            );

#ifndef W32TIME_PROMOTE

//
// w32time doesn't currently have any exported headers.
//
#define W32TIME_PROMOTE 0x1
#define W32TIME_DEMOTE  0x2
#define W32TIME_PROMOTE_FIRST_DC_IN_TREE 0x4
#define W32TIME_DEMOTE_LAST_DC_IN_DOMAIN 0x8

#endif

typedef VOID ( *DSR_W32TimeDcPromo ) (
        DWORD dwFlags
        );

EXTERN DSR_NtdsInstall DsrNtdsInstall;
EXTERN DSR_NtdsInstallShutdown DsrNtdsInstallShutdown;
EXTERN DSR_NtdsInstallUndo DsrNtdsInstallUndo;
EXTERN DSR_NtdsGetDefaultDnsName DsrNtdsGetDefaultDnsName;
EXTERN DSR_NtdsSetReplicaMachineAccount DsrNtdsSetReplicaMachineAccount;
EXTERN DSR_NtdsPrepareForDemotion DsrNtdsPrepareForDemotion;
EXTERN DSR_NtdsPrepareForDemotionUndo DsrNtdsPrepareForDemotionUndo;
EXTERN DSR_NtdsDemote DsrNtdsDemote;
EXTERN DSR_NtdsInstallCancel DsrNtdsInstallCancel;
EXTERN DSR_NtdsInstallReplicateFull DsrNtdsInstallReplicateFull;
EXTERN DSR_NtdsFreeDnsRRInfo DsrNtdsFreeDnsRRInfo;
EXTERN DSR_SceDcPromoteSecurityEx DsrSceDcPromoteSecurityEx;
EXTERN DSR_SceDcPromoCreateGPOsInSysvolEx DsrSceDcPromoCreateGPOsInSysvolEx;
EXTERN DSR_SceSetupSystemByInfName DsrSceSetupSystemByInfName;
EXTERN DSR_NtFrsApi_PrepareForPromotionW DsrNtFrsApi_PrepareForPromotionW;
EXTERN DSR_NtFrsApi_PrepareForDemotionW DsrNtFrsApi_PrepareForDemotionW;
EXTERN DSR_NtFrsApi_PrepareForDemotionUsingCredW DsrNtFrsApi_PrepareForDemotionUsingCredW;
EXTERN DSR_NtFrsApi_StartPromotionW DsrNtFrsApi_StartPromotionW;
EXTERN DSR_NtFrsApi_StartDemotionW DsrNtFrsApi_StartDemotionW;
EXTERN DSR_NtFrsApi_WaitForPromotionW DsrNtFrsApi_WaitForPromotionW;
EXTERN DSR_NtFrsApi_WaitForDemotionW DsrNtFrsApi_WaitForDemotionW;
EXTERN DSR_NtFrsApi_CommitPromotionW DsrNtFrsApi_CommitPromotionW;
EXTERN DSR_NtFrsApi_CommitDemotionW DsrNtFrsApi_CommitDemotionW;
EXTERN DSR_NtFrsApi_AbortPromotionW DsrNtFrsApi_AbortPromotionW;
EXTERN DSR_NtFrsApi_AbortDemotionW DsrNtFrsApi_AbortDemotionW;
EXTERN DSR_W32TimeDcPromo DsrW32TimeDcPromo;

DWORD
DsRolepLoadSetupFunctions(
    VOID
    );

VOID
DsRolepUnloadSetupFunctions(
    VOID
    );

VOID
DsRolepInitSetupFunctions(
    VOID
    );

//
// N.B.  If this assert fires, then the operation handle lock
// has been misused.
//
#define DSROLE_GET_SETUP_FUNC( status, pfunc )              \
if ( pfunc == NULL ) {                                      \
    ASSERT( pfunc );                                        \
    status = DsRolepLoadSetupFunctions();                   \
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\loadfn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#define NTDSSET_ALLOCATE    // Cause extern allocations to happen here
#include "loadfn.h"
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition

#include "secure.h"


//
// Global data
//
HANDLE NtDsSetupDllHandle = NULL;
HANDLE SceSetupDllHandle = NULL;
HANDLE NtfrsApiDllHandle = NULL;
HANDLE W32TimeDllHandle = NULL;

#define DSROLE_LOAD_FPTR( status, handle, fbase )                   \
if ( status == ERROR_SUCCESS ) {                                    \
                                                                    \
    Dsr##fbase = ( DSR_##fbase)GetProcAddress( handle, #fbase );    \
                                                                    \
    if ( Dsr##fbase == NULL ) {                                     \
                                                                    \
        status = ERROR_PROC_NOT_FOUND;                              \
    }                                                               \
}

DWORD
DsRolepLoadSetupFunctions(
    VOID
    )
/*++

Routine Description:

    This function will load all of the function pointers as utilized from Ntdsetup.dll
    
    N.B.  This routine must be called when the global op handle lock is held.

Arguments:

    VOID

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    HANDLE DllHandle = NULL;

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    if ( NtDsSetupDllHandle == NULL ) {

        DllHandle = LoadLibraryA( "Ntdsetup" );

        if ( DllHandle == NULL ) {

            DsRolepLogPrint(( DEB_ERROR, "Failed to load NTDSETUP.DLL\n" ));
            Win32Err = ERROR_MOD_NOT_FOUND;

        } else {

            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstall );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstallShutdown );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstallUndo );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsGetDefaultDnsName );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsPrepareForDemotion );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsPrepareForDemotionUndo );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsDemote );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsSetReplicaMachineAccount );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstallCancel );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstallReplicateFull );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsFreeDnsRRInfo );

            NtDsSetupDllHandle = DllHandle;
        }

        //
        // Load the ones for secsetup
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            DllHandle = LoadLibraryA( "scecli" );

            if ( DllHandle == NULL ) {

                DsRolepLogPrint(( DEB_ERROR, "Failed to load SCECLI.DLL\n" ));
                Win32Err = ERROR_MOD_NOT_FOUND;

            } else {

                DSROLE_LOAD_FPTR( Win32Err, DllHandle, SceDcPromoteSecurityEx );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, SceDcPromoCreateGPOsInSysvolEx );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, SceSetupSystemByInfName );

                SceSetupDllHandle = DllHandle;

            }
        }

        //
        // Load the ones for ntfrsapi
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            DllHandle = LoadLibraryA( "ntfrsapi" );

            if ( DllHandle == NULL ) {

                DsRolepLogPrint(( DEB_ERROR, "Failed to load NTFRSAPI.DLL\n" ));
                Win32Err = ERROR_MOD_NOT_FOUND;

            } else {

                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_PrepareForPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_PrepareForDemotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_PrepareForDemotionUsingCredW  );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_StartPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_StartDemotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_WaitForPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_WaitForDemotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_CommitPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_CommitDemotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_AbortPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_AbortDemotionW );

                NtfrsApiDllHandle = DllHandle;

            }
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            DllHandle = LoadLibraryA( "w32time" );
            if ( DllHandle == NULL ) {

                DsRolepLogPrint(( DEB_ERROR, "Failed to load W32TIME.DLL\n" ));
                Win32Err = ERROR_MOD_NOT_FOUND;

            } else {

                DSROLE_LOAD_FPTR( Win32Err, DllHandle, W32TimeDcPromo );

                W32TimeDllHandle = DllHandle;

            }
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepUnloadSetupFunctions();
    }

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    return( Win32Err );
}


VOID
DsRolepUnloadSetupFunctions(
    VOID
    )
/*++

Routine Description:

    This function will unload the dll handles loaded by DsRolepLoadSetupFunctions
    
    
    N.B.  This routine must be called when the global op handle lock is held.

Arguments:

    VOID

Returns:

    VOID

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    if ( NtDsSetupDllHandle != NULL ) {

        FreeLibrary( NtDsSetupDllHandle );
        NtDsSetupDllHandle = NULL;

    }

    if ( SceSetupDllHandle != NULL ) {

        FreeLibrary( SceSetupDllHandle );
        SceSetupDllHandle = NULL;

    }

    if ( NtfrsApiDllHandle != NULL ) {

        FreeLibrary( NtfrsApiDllHandle );
        NtfrsApiDllHandle = NULL;
    }

    if ( W32TimeDllHandle != NULL ) {

        FreeLibrary( W32TimeDllHandle );
        W32TimeDllHandle = NULL;
    }

    DsRolepInitSetupFunctions();

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    return;
}


VOID
DsRolepInitSetupFunctions(
    VOID
    )
/*++

Routine Description:

    This function will initialize the setup function pointers to NULL

Arguments:

    VOID

Returns:

    VOID

--*/
{
    DsrNtdsInstall = NULL;
    DsrNtdsInstallShutdown = NULL;
    DsrNtdsInstallUndo = NULL;
    DsrNtdsGetDefaultDnsName = NULL;
    DsrNtdsPrepareForDemotion = NULL;
    DsrNtdsPrepareForDemotionUndo = NULL;
    DsrNtdsDemote = NULL;
    DsrNtdsSetReplicaMachineAccount = NULL;
    DsrNtdsInstallCancel = NULL;
    DsrNtdsFreeDnsRRInfo = NULL;
    DsrSceDcPromoteSecurityEx = NULL;
    DsrSceDcPromoCreateGPOsInSysvolEx = NULL;
    DsrNtFrsApi_PrepareForPromotionW = NULL;
    DsrNtFrsApi_PrepareForDemotionW = NULL;
    DsrNtFrsApi_StartPromotionW = NULL;
    DsrNtFrsApi_StartDemotionW = NULL;
    DsrNtFrsApi_WaitForPromotionW = NULL;
    DsrNtFrsApi_WaitForDemotionW = NULL;
    DsrNtFrsApi_CommitPromotionW = NULL;
    DsrNtFrsApi_CommitDemotionW = NULL;
    DsrNtFrsApi_AbortPromotionW = NULL;
    DsrNtFrsApi_AbortDemotionW = NULL;
    DsrW32TimeDcPromo = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\lsa.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition
#include <Sddl.h>

#include "secure.h"
#include "lsa.h"


DWORD
DsRolepSetLsaInformationForReplica(
    IN HANDLE CallerToken,
    IN LPWSTR ReplicaPartner,
    IN LPWSTR Account,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This function will set the local Lsa database information to that of the replica partner

Arguments:

    ReplicaPartner -- Replica partner to get the information from

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    UNICODE_STRING PartnerServer;
    HANDLE LocalPolicy = NULL , PartnerPolicy = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PBYTE Buffer;
    ULONG i;
    BOOLEAN UseAdded = FALSE;
    PWSTR FullServerPath = NULL;
    POLICY_INFORMATION_CLASS InfoClasses[ ] = {

        PolicyDnsDomainInformation
    };

    if ( !ReplicaPartner ) {

        return( ERROR_INVALID_PARAMETER );
    }

    DSROLEP_CURRENT_OP1( DSROLEEVT_SET_LSA_FROM, ReplicaPartner );

    //
    // Open both lsas
    //
    RtlInitUnicodeString( &PartnerServer, ReplicaPartner );

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = ImpLsaOpenPolicy( CallerToken,
                              &PartnerServer,
                              &ObjectAttributes,
                               MAXIMUM_ALLOWED,
                               &PartnerPolicy
                              );

    if ( Status == STATUS_ACCESS_DENIED ) {
        WCHAR *BufPartnerServer = NULL;
        BufPartnerServer = (WCHAR*)malloc(PartnerServer.Length+sizeof(WCHAR));
        if (BufPartnerServer) {
            CopyMemory(BufPartnerServer,PartnerServer.Buffer,PartnerServer.Length);
            BufPartnerServer[PartnerServer.Length/sizeof(WCHAR)] = L'\0';
            DsRolepLogPrint(( DEB_TRACE,
                              "LsaOpenPolicy on %ws failed with  0x%lx. Establishing use.\n",
                              BufPartnerServer, Status ));
            free(BufPartnerServer);
        }
        //
        // Try establishing a session first...
        //
        if ( *ReplicaPartner != L'\\' ) {

            FullServerPath = RtlAllocateHeap( RtlProcessHeap(), 0,
                                              ( wcslen( ReplicaPartner ) + 3 ) * sizeof( WCHAR ) );
            if ( FullServerPath == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                swprintf( FullServerPath, L"\\\\%ws", ReplicaPartner );
                Status = STATUS_SUCCESS;
            }

        } else {

            FullServerPath = ReplicaPartner;
            Status = STATUS_SUCCESS;
        }

        if ( NT_SUCCESS( Status ) ) {


            Win32Err = ImpNetpManageIPCConnect( CallerToken,
                                                FullServerPath,
                                                Account,
                                                Password,
                                                NETSETUPP_CONNECT_IPC );

            if ( Win32Err == ERROR_SUCCESS ) {

                UseAdded = TRUE;

                Status = ImpLsaOpenPolicy( CallerToken,
                                          &PartnerServer,
                                          &ObjectAttributes,
                                           MAXIMUM_ALLOWED,
                                          &PartnerPolicy );

            } else {

                 DsRolepLogPrint(( DEB_TRACE,
                                   "NetUseAdd to %ws failed with %lu\n",
                                   FullServerPath, Win32Err ));
                //
                // Temp status code so we know a failure occurred.
                //
                Status = STATUS_UNSUCCESSFUL;
            }

        }

    } else if ( !NT_SUCCESS( Status ) ) {

        WCHAR *BufPartnerServer = NULL;
        BufPartnerServer = (WCHAR*)malloc(PartnerServer.Length+sizeof(WCHAR));
        if (BufPartnerServer) {
            CopyMemory(BufPartnerServer,PartnerServer.Buffer,PartnerServer.Length);
            BufPartnerServer[PartnerServer.Length/sizeof(WCHAR)] = L'\0';
            DsRolepLogPrint(( DEB_TRACE,
                              "LsaOpenPolicy on %ws failed with  0x%lx.\n",
                              BufPartnerServer, Status ));
            free(BufPartnerServer);
        }

    }

    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &LocalPolicy );

        if ( !NT_SUCCESS( Status ) ) {

            DsRolepLogPrint(( DEB_TRACE,
                              "Local LsaOpenPoolicy returned 0x%lx\n",
                              Status ));

        }
    }

    for ( i = 0;
          i < sizeof( InfoClasses ) / sizeof( POLICY_INFORMATION_CLASS ) && NT_SUCCESS( Status );
          i++ ) {


        Status = ImpLsaQueryInformationPolicy( CallerToken,
                                              PartnerPolicy,
                                              InfoClasses[ i ],
                                              &Buffer );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaSetInformationPolicy( LocalPolicy,
                                              InfoClasses[ i ],
                                              Buffer );

            LsaFreeMemory( Buffer );
        }

        DsRolepLogPrint(( DEB_TRACE,
                          "Setting Lsa policy %lu returned 0x%lx\n",
                          InfoClasses[ i ], Status ));


    }

    //
    // Now, the same for the Efs policy
    //
    if ( NT_SUCCESS( Status ) ) {

        Status = ImpLsaQueryDomainInformationPolicy( CallerToken,
                                                     PartnerPolicy,
                                                     PolicyDomainEfsInformation,
                                                    &Buffer );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaSetDomainInformationPolicy( LocalPolicy,
                                                    PolicyDomainEfsInformation,
                                                    Buffer );
            DsRolepLogPrint(( DEB_TRACE,
                              "Setting Efs policy from %ws returned 0x%lx\n",
                              ReplicaPartner, Status ));

            LsaFreeMemory( Buffer );

        } else {

            DsRolepLogPrint(( DEB_TRACE,
                              "Reading Efs policy from %ws returned 0x%lx\n",
                              ReplicaPartner, Status ));

            if ( Status ==  STATUS_OBJECT_NAME_NOT_FOUND ) {

                Status = STATUS_SUCCESS;
            }

        }
    }


    if ( LocalPolicy ) {

        LsaClose( LocalPolicy );
    }

    if ( PartnerPolicy ) {

        ImpLsaClose( CallerToken, PartnerPolicy );
    }

    if ( UseAdded ) {

        Win32Err = ImpNetpManageIPCConnect( CallerToken,
                                            FullServerPath,
                                            Account,
                                            Password,
                                            (NETSETUPP_DISCONNECT_IPC|NETSETUPP_USE_LOTS_FORCE) );

    }

    if ( FullServerPath && FullServerPath != ReplicaPartner ) {

        RtlFreeHeap( RtlProcessHeap(), 0, FullServerPath );
    }

    //
    // We won't bother cleaning up any of the information we set on the local machine in
    // the failure case, since it won't hurt anything to have it here.
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RtlNtStatusToDosError( Status );
    }

    DsRoleDebugOut(( DEB_TRACE_DS, "DsRolepSetLsaInformationForReplica %lu\n", Win32Err ));

    DsRolepLogOnFailure( Win32Err,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "DsRolepSetLsaInformationForReplica failed with %lu\n",
                                           Win32Err )) );
    return( Win32Err );

}


DWORD
DsRolepSetLsaDomainPolicyInfo(
    IN LPWSTR DnsDomainName,
    IN LPWSTR FlatDomainName,
    IN LPWSTR EnterpriseDnsName,
    IN GUID *DomainGuid,
    IN PSID DomainSid,
    DWORD  InstallOptions,
    OUT PDSROLEP_DOMAIN_POLICY_INFO BackupDomainInfo
    )
/*++

Routine Description:

    This routine sets the PolicyAccountDomainInformation and
    PolicyDnsDomainInformation in the lsa to reflect the
    recent role changes.

Arguments:

    DnsDomainName - The Dns domain name of the newly installed Domain/Dc

    FlatDomainName - The NetBIOS domain name of the newly installed Domain/Dc

    EnterpriseDnsName - The Dns domain name of the root of the enterprise

    DomainGuid - The new domain guid

    DomainSid - The new domain sid

    InstallOptions : this describes the kind of install (new domain, enterprise,
                                                         or replica)
    DomainGuid - The guid of the new domain is returned here

Returns:

    ERROR_SUCCESS - Success; win error otherwise

--*/
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    POLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo;
    POLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo;
    POLICY_DNS_DOMAIN_INFO DnsDomainInfo;
    LSA_HANDLE PolicyHandle = NULL;

    //
    // If we are setting up the replica, we don't have things like the flat domain name and
    // the domain sid, so we'll use the information we have backed up.
    //
    if ( FlatDomainName == NULL || DomainSid == NULL ) {

        RtlCopyMemory( &AccountDomainInfo.DomainName,
                       &BackupDomainInfo->DnsDomainInfo->Name,
                       sizeof( UNICODE_STRING ) );
        AccountDomainInfo.DomainSid = BackupDomainInfo->DnsDomainInfo->Sid ;

    } else {

        RtlInitUnicodeString( &AccountDomainInfo.DomainName,
                              FlatDomainName);

        AccountDomainInfo.DomainSid = DomainSid;
    }

    //
    // Open the Lsa
    //
    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_WRITE,
                            &PolicyHandle );


    //
    // Set the AccountDomain information first
    //
    if ( NT_SUCCESS( Status ) ) {

        //
        // Set the values in the Account Domain Policy structure.
        //
        WCHAR *BufDomainName = NULL;

        DsRolepLogPrint(( DEB_TRACE, "Setting AccountDomainInfo to:\n" ));

        BufDomainName = (WCHAR*)malloc(AccountDomainInfo.DomainName.Length+sizeof(WCHAR));
        if (BufDomainName) {
            CopyMemory(BufDomainName,AccountDomainInfo.DomainName.Buffer,AccountDomainInfo.DomainName.Length);
            BufDomainName[AccountDomainInfo.DomainName.Length/sizeof(WCHAR)] = L'\0';
            DsRolepLogPrint(( DEB_TRACE,
                              "\tDomain: %ws\n",
                              BufDomainName, Status ));
            free(BufDomainName);
        }

        DsRolepLogSid( DEB_TRACE, "\tSid: ", AccountDomainInfo.DomainSid );


        Status = LsaSetInformationPolicy( PolicyHandle,
                                          PolicyAccountDomainInformation,
                                          ( PVOID )&AccountDomainInfo );

        DsRolepLogOnFailure( RtlNtStatusToDosError( Status ),
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Setting AccountDomainInformation failed with 0x%lx\n",
                                                RtlNtStatusToDosError( Status ) )) );

    }


    //
    // Set the Dns domain information
    //
    if ( NT_SUCCESS( Status ) && !FLAG_ON( InstallOptions, NTDS_INSTALL_REPLICA ) ) {

        RtlInitUnicodeString( &DnsDomainInfo.Name, FlatDomainName );
        RtlInitUnicodeString( &DnsDomainInfo.DnsDomainName, DnsDomainName );
        RtlInitUnicodeString( &DnsDomainInfo.DnsForestName, EnterpriseDnsName );
        RtlCopyMemory( &DnsDomainInfo.DomainGuid, DomainGuid, sizeof( GUID ) );
        DnsDomainInfo.Sid = DomainSid;

        Status = LsaSetInformationPolicy( PolicyHandle,
                                          PolicyDnsDomainInformation,
                                          ( PVOID )&DnsDomainInfo );

        DsRolepLogOnFailure( RtlNtStatusToDosError( Status ),
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Setting DnsDomainInformation failed with 0x%lx\n",
                                                RtlNtStatusToDosError( Status ) )) );
    }


    //
    // If it isn't a replica, wipe the efs policy
    //
    if ( NT_SUCCESS( Status ) && !FLAG_ON( InstallOptions, NTDS_INSTALL_REPLICA ) ) {

        Status = LsaSetDomainInformationPolicy( PolicyHandle,
                                                PolicyDomainEfsInformation,
                                                NULL );

        if ( Status ==  STATUS_OBJECT_NAME_NOT_FOUND ) {

            Status = STATUS_SUCCESS;
        }

        DsRolepLogOnFailure( RtlNtStatusToDosError( Status ),
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Erasing EfsPolicy failed with 0x%lx\n",
                                                Status )) );
    }


    //
    // Now, cleanup and exit
    //
    if ( PolicyHandle ) {

        LsaClose( PolicyHandle );
    }


    return( RtlNtStatusToDosError( Status ) );

}



DWORD
DsRolepBackupDomainPolicyInfo(
    IN PLSA_HANDLE LsaHandle, OPTIONAL
    OUT PDSROLEP_DOMAIN_POLICY_INFO DomainInfo
    )
/*++

Routine Description

    This routine reads and saves in a global the state of the
    account domain policy and primary domain policy so if an error
    occurs then the original state can be preserved.

Parameters

    DomainInfo : pointer, to be filled in by this routine

Return Values

    ERROR_SUCCESS if no errors; a winerror otherwise

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_HANDLE PolicyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;

    ASSERT(DomainInfo);

    if ( DomainInfo->PolicyBackedUp ) {

        return( STATUS_SUCCESS );
    }

    if ( LsaHandle == NULL ) {
        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &PolicyHandle );

    } else {

        PolicyHandle = LsaHandle;
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy(
                       PolicyHandle,
                       PolicyDnsDomainInformation,
                       ( PVOID * )&DomainInfo->DnsDomainInfo);
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy(
                       PolicyHandle,
                       PolicyAccountDomainInformation,
                       ( PVOID * )&DomainInfo->AccountDomainInfo);
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy(
                       PolicyHandle,
                       PolicyLsaServerRoleInformation,
                       ( PVOID * )&DomainInfo->ServerRoleInfo);
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryDomainInformationPolicy(
                       PolicyHandle,
                       PolicyDomainEfsInformation,
                       ( PVOID * )&DomainInfo->EfsPolicy );

        if ( NT_SUCCESS( Status ) ) {

            DomainInfo->EfsPolicyPresent = TRUE;

        } else {

            //
            // It's ok for the Efs policy not to have existed
            //
            if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                DomainInfo->EfsPolicyPresent = TRUE;
                Status = STATUS_SUCCESS;

            } else {

                DomainInfo->EfsPolicyPresent = FALSE;

            }
        }
    }

    if ( PolicyHandle && PolicyHandle != LsaHandle ) {

        LsaClose( PolicyHandle );
    }


    if ( NT_SUCCESS( Status ) ) {

        DomainInfo->PolicyBackedUp = TRUE;
    }

    return( RtlNtStatusToDosError( Status ) );

}



DWORD
DsRolepRestoreDomainPolicyInfo(
    IN PDSROLEP_DOMAIN_POLICY_INFO DomainInfo
    )
/*++

Routine Description

    This routine sets the account and primary domain information to be
    the values that were stored of by DsRolepBackupDomainPolicyInformation.

Parameters

    DomainInfo : pointer, expected to be filled

Return Values

    ERROR_SUCCESS if no errors; a winerror otherwise

    ERROR_INVALID_DATA - The data was never successfully backed up

--*/
{

    NTSTATUS Status, Status2;
    HANDLE   PolicyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;

    ASSERT(DomainInfo);

    if ( !DomainInfo->PolicyBackedUp ) {

        return( ERROR_INVALID_DATA );
    }

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_WRITE,
                            &PolicyHandle );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaSetInformationPolicy( PolicyHandle,
                                          PolicyDnsDomainInformation,
                                          ( PVOID )DomainInfo->DnsDomainInfo );


        Status2 = LsaSetInformationPolicy( PolicyHandle,
                                           PolicyAccountDomainInformation,
                                           ( PVOID )DomainInfo->AccountDomainInfo );

        if ( NT_SUCCESS( Status ) && !NT_SUCCESS( Status2 ) ) {

            Status = Status2;
        }

        //
        // Restore the Efs policy, if it exists
        //
        if ( NT_SUCCESS( Status ) && DomainInfo->EfsPolicyPresent ) {

            Status = LsaSetDomainInformationPolicy( PolicyHandle,
                                                    PolicyDomainEfsInformation,
                                                    ( PVOID )DomainInfo->EfsPolicy );
        }


        Status2 = LsaClose( PolicyHandle );

        if ( NT_SUCCESS( Status ) ) {

            Status = Status2;
        }

    }

    DsRolepLogOnFailure( Status,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "RestoreDomainPolicyInfo failed with 0x%lx\n",
                                           Status )) );

    return( RtlNtStatusToDosError( Status ) );
}



DWORD
DsRolepFreeDomainPolicyInfo(
    IN PDSROLEP_DOMAIN_POLICY_INFO DomainInfo
    )
/*++

Routine Description

    This routine free the structures that were allocated during
    DsRolepBackupDomainPolicyInformation.

Parameters

    DomainInfo : pointer, expected to be filled so the fields can be freed

Return Values

    ERROR_SUCCESS if no errors; a winerror otherwise

--*/
{
    if ( DomainInfo->AccountDomainInfo ) {

        LsaFreeMemory( DomainInfo->AccountDomainInfo );
    }

    if ( DomainInfo->DnsDomainInfo ) {

        LsaFreeMemory( DomainInfo->DnsDomainInfo );
    }

    if ( DomainInfo->ServerRoleInfo ) {

        LsaFreeMemory( DomainInfo->ServerRoleInfo );
    }

    if ( DomainInfo->EfsPolicyPresent ) {

        LsaFreeMemory( DomainInfo->EfsPolicy );
    }

    return ERROR_SUCCESS;
}

DWORD
DsRolepUpgradeLsaToDs(
    BOOLEAN InitializeLsa
    )
/*++

Routine Description:

    Prompts Lsa to upgrade all the information it stores in the registry into the Ds

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD WinError = ERROR_SUCCESS;


    if ( InitializeLsa ) {

        //
        // Make the Lsa think that we're initialized
        //
        DSROLEP_CURRENT_OP0( DSROLEEVT_SET_LSA );

        //
        // Make the Lsa think that we're initialized
        //
        Status = LsapDsInitializeDsStateInfo( LsapDsDsSetup );

        if ( !NT_SUCCESS( Status ) ) {

            DsRolepLogPrint(( DEB_TRACE,
                              "Failed to convince Lsa to reinitialize: 0x%lx\n",
                              Status ));

        } else {

            Status = LsaIUpgradeRegistryToDs( FALSE );

        }

    }
    return( WinError == ERROR_SUCCESS ? RtlNtStatusToDosError( Status ) : WinError );
}


VOID
DsRolepFindSelfAndParentInForest(
    IN PLSAPR_FOREST_TRUST_INFO ForestTrustInfo,
    OUT PLSAPR_TREE_TRUST_INFO CurrentEntry,
    IN PUNICODE_STRING LocalDomain,
    OUT PLSAPR_TREE_TRUST_INFO *ParentEntry,
    OUT PLSAPR_TREE_TRUST_INFO *OwnEntry
    )
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG i;
    BOOLEAN ParentKnown = FALSE;


    if ( *ParentEntry && *OwnEntry ) {

        return;

    }

    if ( ForestTrustInfo->ParentDomainReference ) {

        CurrentEntry = ForestTrustInfo->ParentDomainReference;
        ParentKnown = TRUE;
    }

    for ( i = 0; i < CurrentEntry->Children && *OwnEntry == NULL; i++ ) {

        if ( RtlCompareUnicodeString(
                    ( PUNICODE_STRING )&CurrentEntry->ChildDomains[ i ].DnsDomainName,
                    LocalDomain,
                    TRUE ) == 0  ) {

            *OwnEntry = &CurrentEntry->ChildDomains[ i ];
            *ParentEntry = CurrentEntry;
            break;
        }

        if ( !ParentKnown ) {

            DsRolepFindSelfAndParentInForest( ForestTrustInfo,
                                              &CurrentEntry->ChildDomains[ i ],
                                              LocalDomain,
                                              ParentEntry,
                                              OwnEntry );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\netname.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netname.c

Abstract:

    Miscellaneous network naming helper functions

Author:

    Mac McLain          (MacM)       Oct 16, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <netsetup.h>
#include <lsarpc.h>
#include <db.h>
#include <lsasrvmm.h>
#include <lsaisrv.h>

#include <dns.h>
#include <dnsapi.h>

#define MAX_NAME_ATTEMPTS   260

DWORD
WINAPI
DsRolepDnsNameToFlatName(
    IN  LPWSTR DnsName,
    OUT LPWSTR *FlatName,
    OUT PULONG StatusFlag
    )
/*++

Routine Description:

    Determines the suggested netbios domain name for the given dns name

Arguments:

    DnsName - The Dns domain name to generate a flat name for

    FlatName - Where the flat name is to be returned

    StatusFlag - Where the status is returned

Returns:

    STATUS_SUCCESS - Success

--*/
{
    DWORD Win32Error = ERROR_SUCCESS;
    NTSTATUS Status;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo;
    BOOLEAN FindFromDns = TRUE;
    WCHAR NbDomainName[ DNLEN + 1], NbNameAdd[ 4 ];
    PWSTR Current = NULL;
    WCHAR BaseChar;
    ULONG CurrentAttempt = 0;
    ULONG i,j;


    *StatusFlag = 0;

    DsRolepLogPrint(( DEB_TRACE,
                      "Getting NetBIOS name for Dns name %ws\n",
                      DnsName ));

    //
    // First, see if we are part of domain currently or not.  If we are, then it's a simple
    // matter of returning the current Netbios domain name.
    //
    Status = LsaIQueryInformationPolicyTrusted(
                 PolicyAccountDomainInformation,
                 ( PLSAPR_POLICY_INFORMATION * )&AccountDomainInfo );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaIQueryInformationPolicyTrusted(
                     PolicyDnsDomainInformation,
                     ( PLSAPR_POLICY_INFORMATION * )&DnsDomainInfo );

        if ( !NT_SUCCESS( Status ) ) {

            LsaIFree_LSAPR_POLICY_INFORMATION(
                    PolicyAccountDomainInformation,
                    ( PLSAPR_POLICY_INFORMATION )AccountDomainInfo );
        }


    }

    if ( NT_SUCCESS( Status ) ) {


        if ( DnsDomainInfo->Sid == NULL || AccountDomainInfo->DomainSid == NULL ||
             !RtlEqualSid( AccountDomainInfo->DomainSid, DnsDomainInfo->Sid ) ) {

            //
            // We're not a member of the domain
            //
            FindFromDns = TRUE;

        } else {

            //
            // We are a domain member
            //
            WCHAR *BufDomainName = NULL;
            BufDomainName = (WCHAR*)malloc(DnsDomainInfo->Name.Length+sizeof(WCHAR));
            if (BufDomainName) {
              CopyMemory(BufDomainName,DnsDomainInfo->Name.Buffer,DnsDomainInfo->Name.Length);
              BufDomainName[DnsDomainInfo->Name.Length/sizeof(WCHAR)] = L'\0';
              DsRolepLogPrint(( DEB_TRACE,
                              "Using existing NetBIOS domain name %ws\n",
                              BufDomainName ));
              free(BufDomainName);
            }

            *FlatName = MIDL_user_allocate(
                                    ( DnsDomainInfo->Name.Length + 1 ) * sizeof( WCHAR ) );

            if ( *FlatName == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                RtlCopyMemory( *FlatName, DnsDomainInfo->Name.Buffer,
                                DnsDomainInfo->Name.Length );
                ( *FlatName )[DnsDomainInfo->Name.Length / sizeof( WCHAR )] = UNICODE_NULL;
                *StatusFlag = DSROLE_FLATNAME_UPGRADE;
                *StatusFlag |= DSROLE_FLATNAME_DEFAULT;
                FindFromDns = FALSE;
            }

        }

        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyAccountDomainInformation,
                ( PLSAPR_POLICY_INFORMATION )AccountDomainInfo );

        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyDnsDomainInformation,
                ( PLSAPR_POLICY_INFORMATION )DnsDomainInfo );
    }

    //
    // If there was no domain name defined, we'll have to get one from the dns name
    //
    if ( Win32Error == ERROR_SUCCESS && FindFromDns ) {

        //
        // Ok, to start with, pull off the first DNLEN characters from the DNS name
        //
        RtlZeroMemory(NbDomainName, sizeof(WCHAR)*(DNLEN+1) );
        wcsncpy( NbDomainName, DnsName, DNLEN );

        Current = wcschr( NbDomainName, L'.' );

        if ( Current ) {

            *Current = UNICODE_NULL;
        }

        //
        // See if the name is currently in use or not
        //
        DsRolepLogPrint(( DEB_TRACE,
                          "Testing default NetBIOS name %ws\n",
                          NbDomainName ));

        Win32Error = NetpValidateName( NULL,
                                       NbDomainName,
                                       NULL,
                                       NULL,
                                       NetSetupNonExistentDomain );

        if ( Win32Error == ERROR_SUCCESS ) {

            *StatusFlag = DSROLE_FLATNAME_DEFAULT;

        } else if ( Win32Error == ERROR_DUP_NAME ) {

            //
            // Position on the last character in the name
            //
            Current = NbDomainName + wcslen( NbDomainName ) - 1;

            ASSERT(Current <= (NbDomainName + DNLEN - 1));

            //
            // If our name is less than the max.  Set our current next to the last character
            //
            if ( (NbDomainName + DNLEN - 1) != Current ) {

                Current++;
                *( Current + 1 ) = UNICODE_NULL;
            }


            while ( CurrentAttempt < MAX_NAME_ATTEMPTS ) {

                _ultow( CurrentAttempt, NbNameAdd, 10 );

                ASSERT( wcslen( NbNameAdd ) < 4 );

                //
                // See if we need to adjust the position of where we copy
                //
                if ( CurrentAttempt == 10 || CurrentAttempt == 100 ) {

                    if ( (NbDomainName + DNLEN) < (Current + wcslen(NbNameAdd)) ) {

                        Current--;
                    }
                }

                wcscpy( Current, NbNameAdd );

                DsRolepLogPrint(( DEB_TRACE,
                                  "Testing default NetBIOS name %ws\n",
                                  NbDomainName ));

                Win32Error = NetpValidateName( NULL,
                                               NbDomainName,
                                               NULL,
                                               NULL,
                                               NetSetupNonExistentDomain );

                //
                // If we've found a name that is in use, try again
                //
                if ( Win32Error != ERROR_DUP_NAME ) {

                    break;
                }

                CurrentAttempt++;
            }

        }


        //
        // If we found a valid name, return it
        //
        if ( Win32Error == ERROR_SUCCESS ) {

            *FlatName = MIDL_user_allocate( ( wcslen( NbDomainName ) + 1 ) * sizeof( WCHAR ) );
            if ( *FlatName == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                wcscpy( *FlatName, NbDomainName );

                DsRolepLogPrint(( DEB_TRACE,
                                  "Found usable NetBIOS domain name %ws\n",
                                  NbDomainName ));

            }

        }

    }



    return( Win32Error );
}





DWORD
DsRolepIsDnsNameChild(
    IN  LPWSTR ParentDnsName,
    IN  LPWSTR ChildDnsName
    )
/*++

Routine Description:

    Determines whether the child dns domain name is indeed a child of the parent.  This means
    that the only difference between the names is the left most component of the child dns name.

Arguments:

    ParentDnsName - The Dns domain name of the parent

    ChildDnsName - The Dns name of the childe .

Returns:

    STATUS_SUCCESS - Success

    ERROR_INVALID_DOMAINNAME - The child dns name is not a child of the parent dns name

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    PWSTR Sep = wcschr( ChildDnsName, L'.' );

    if ( Sep == NULL || !DnsNameCompare_W( Sep + 1, ParentDnsName ) ) {

        Win32Err = ERROR_INVALID_DOMAINNAME;

    }

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\lsa.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetp.ch

Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __LSA_H__
#define __LSA_H__

#include <lsarpc.h>
#include <lsaisrv.h>

typedef struct {

    BOOLEAN PolicyBackedUp;
    BOOLEAN EfsPolicyPresent;
    PPOLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo;
    PPOLICY_DNS_DOMAIN_INFO      DnsDomainInfo;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo;
    PPOLICY_DOMAIN_EFS_INFO EfsPolicy;

} DSROLEP_DOMAIN_POLICY_INFO, *PDSROLEP_DOMAIN_POLICY_INFO;

DWORD
DsRolepSetLsaDnsInformationNoParent(
    IN  LPWSTR DnsDomainName
    );

DWORD
DsRolepSetLsaInformationForReplica(
    IN HANDLE CallerToken,
    IN LPWSTR ReplicaPartner,
    IN LPWSTR Account,
    IN LPWSTR Password
    );

DWORD
DsRolepSetLsaDomainPolicyInfo(
    IN LPWSTR DnsDomainName,
    IN LPWSTR FlatDomainName,
    IN LPWSTR EnterpriseDnsName,
    IN GUID *DomainGuid,
    IN PSID DomainSid,
    DWORD  InstallOptions,
    OUT PDSROLEP_DOMAIN_POLICY_INFO DomainPolicyInfo
    );


DWORD
DsRolepBackupDomainPolicyInfo(
    IN PLSA_HANDLE LsaHandle, OPTIONAL
    OUT PDSROLEP_DOMAIN_POLICY_INFO DomainInfo
    );

DWORD
DsRolepRestoreDomainPolicyInfo(
    IN PDSROLEP_DOMAIN_POLICY_INFO DomainPolicyInfo
    );

DWORD
DsRolepFreeDomainPolicyInfo(
    IN PDSROLEP_DOMAIN_POLICY_INFO DomainPolicyInfo
    );

DWORD
DsRolepUpgradeLsaToDs(
    BOOLEAN InitializeLsa
    );

VOID
DsRolepFindSelfAndParentInForest(
    IN PLSAPR_FOREST_TRUST_INFO ForestTrustInfo,
    OUT PLSAPR_TREE_TRUST_INFO CurrentEntry,
    IN PUNICODE_STRING LocalDomain,
    OUT PLSAPR_TREE_TRUST_INFO *ParentEntry,
    OUT PLSAPR_TREE_TRUST_INFO *OwnEntry
    );

#endif // __LSA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\ophandle.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ophandle.c

Abstract:

    Routines to manipulate the global operation handle            

Author:

    Colin Brace        (ColinBr)     April 5, 1999

Environment:

    User Mode

Revision History:

    Reorganized from
    
    Mac McLain          (MacM)       Feb 10, 1997

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <spmgr.h>  // For SetupPhase definition

#include "secure.h"
#include "ophandle.h"

//
// Global data -- init'ed to an idle state in DsRoleInitialize
//
DSROLEP_OPERATION_HANDLE   DsRolepCurrentOperationHandle;
DSROLEP_IFM_OPERATION_HANDLE DsRolepCurrentIfmOperationHandle = { 0 };

DWORD
DsRolepInitializeOperationHandle(
    VOID
    )
/*++

Routine Description:

    Does the initialization of the operation handle.  The operation handle controls state
    and actions of the ds setup apis

Arguments:

    VOID

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES EventAttr;
    UNICODE_STRING EventName;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Grab the lock
    //
    LockOpHandle();

    if ( DSROLEP_IDLE != DsRolepCurrentOperationHandle.OperationState ) {

        //
        // Not idle?  Bail
        //
        Win32Err = ERROR_PROMOTION_ACTIVE;

    } else {

        Win32Err = DsRolepGetImpersonationToken(&DsRolepCurrentOperationHandle.ClientToken);
        if (ERROR_SUCCESS != Win32Err) {
            DsRolepCurrentOperationHandle.ClientToken=NULL;
            DsRolepLogPrintRoutine(DEB_WARN, "Cannot get user Token for Format Message: %ul\n",
                                   Win32Err);
            Win32Err = ERROR_SUCCESS;
            //if Error log and continue
        }

        //
        // We are idle, and hence ready to perform a role change
        //
        RtlInitUnicodeString(&EventName, DSROLEP_EVENT_NAME);

        InitializeObjectAttributes(&EventAttr, &EventName, 0, NULL, NULL);

        Status = NtCreateEvent( &DsRolepCurrentOperationHandle.CompletionEvent,
                                EVENT_ALL_ACCESS,
                                &EventAttr,
                                NotificationEvent,
                                FALSE);
        if (Status == STATUS_OBJECT_NAME_COLLISION ) {

            //
            // If the event exists but the operation active flag is clear, we'll
            // go ahead and use the event
            //
            Status = NtResetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );
        }


        if ( NT_SUCCESS( Status ) ) {

            //
            // Create the cancel event
            //
            Status = NtCreateEvent( &DsRolepCurrentOperationHandle.CancelEvent,
                                    EVENT_MODIFY_STATE | SYNCHRONIZE ,
                                    NULL,
                                    NotificationEvent,
                                    FALSE );

            if ( NT_SUCCESS( Status ) ) {

                //
                // We are ready to roll!
                //

                DsRolepCurrentOperationHandle.OperationState = DSROLEP_RUNNING;

                //
                // Set the initial message
                //
                DsRolepCurrentOperationHandle.MsgIndex = DSROLERES_STARTING;
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            //
            // Load the functions we'll need
            //
            Win32Err = DsRolepLoadSetupFunctions();

        }

    }


    //
    // Release the lock
    //
    UnlockOpHandle();

    if ( ERROR_SUCCESS != Win32Err
       || !NT_SUCCESS( Status ) ) {

        if ( ERROR_SUCCESS == Win32Err ) {

            Win32Err = RtlNtStatusToDosError( Status );

        }

        DsRolepLogPrint(( DEB_ERROR, "Internal error trying to initialize operation handle (%lu).\n", Win32Err ));

        //
        // Reset the handle state
        //
        DsRolepResetOperationHandle( DSROLEP_IDLE );
    }

    return( Win32Err );
}



DWORD
DsRolepResetOperationHandle(
    DSROLEP_OPERATION_STATE OpState
    )
/*++

Routine Description:

    Resets the operation handle following a failed or successful completion 
    of the operation

Arguments:

    VOID

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES EventAttr;
    UNICODE_STRING EventName;
    NTSTATUS Status = STATUS_SUCCESS;

    // These are the only two states that make sense
    ASSERT( (OpState == DSROLEP_IDLE) || (OpState == DSROLEP_NEED_REBOOT) );

    //
    // Lock the operation handle
    //
    LockOpHandle();

    // It should always be active
    ASSERT( DSROLEP_OPERATION_ACTIVE( DsRolepCurrentOperationHandle.OperationState) );
    if ( DSROLEP_OPERATION_ACTIVE( DsRolepCurrentOperationHandle.OperationState) )
    {
        if(DsRolepCurrentOperationHandle.ClientToken){
            CloseHandle(DsRolepCurrentOperationHandle.ClientToken);
            DsRolepCurrentOperationHandle.ClientToken = NULL;
        }
        //
        // Release the resource of the operation handle
        //
        if ( DsRolepCurrentOperationHandle.CompletionEvent ) {

            Status = NtClose( DsRolepCurrentOperationHandle.CompletionEvent );
            DsRolepCurrentOperationHandle.CompletionEvent = NULL;

            if ( !NT_SUCCESS( Status ) ) {

                DsRoleDebugOut(( DEB_TRACE_DS,
                                 "Failed to close event handle: 0x%lx\n", Status ));
            }
        }

        if ( DsRolepCurrentOperationHandle.CancelEvent ) {

            Status = NtClose( DsRolepCurrentOperationHandle.CancelEvent );
            DsRolepCurrentOperationHandle.CancelEvent = NULL;

            if ( !NT_SUCCESS( Status ) ) {

                DsRoleDebugOut(( DEB_TRACE_DS,
                                 "Failed to close event handle: 0x%lx\n", Status ));
            }
        }

        if ( DsRolepCurrentOperationHandle.OperationThread != NULL ) {

            CloseHandle( DsRolepCurrentOperationHandle.OperationThread );
            DsRolepCurrentOperationHandle.OperationThread = NULL;
        }

        //
        // Unload the global functions
        //
        DsRolepUnloadSetupFunctions();

        //
        // Clear the static variables
        //
        DsRolepResetOperationHandleLockHeld();

        //
        // Reset the operation state
        //
        DsRolepCurrentOperationHandle.OperationState = OpState;

        //
        // Reset the IFM operation
        //
        DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock = FALSE;
    }

    //
    // Release the lock
    //
    UnlockOpHandle();

    if ( !NT_SUCCESS( Status ) ) {

        Win32Err = RtlNtStatusToDosError( Status );
    }

    return( Win32Err );

}


VOID
DsRolepResetOperationHandleLockHeld(
    VOID
    )
/*++

Routine Description:

    Resets the operation handle following a failed or successful completion of the operation

Arguments:

    VOID

Returns:

    VOID

--*/
{

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    if ( DsRolepCurrentOperationHandle.Parameter1 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter1 );
        DsRolepCurrentOperationHandle.Parameter1 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter2 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter2 );
        DsRolepCurrentOperationHandle.Parameter2 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter3 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter3 );
        DsRolepCurrentOperationHandle.Parameter3 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter4 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter4 );
        DsRolepCurrentOperationHandle.Parameter4 = NULL;
    }

    DsRolepCurrentOperationHandle.CompletionEvent = NULL;
    DsRolepCurrentOperationHandle.OperationState = DSROLEP_IDLE;
    DsRolepCurrentOperationHandle.OperationStatus = 0;
    DsRolepCurrentOperationHandle.MsgIndex = 0;
    DsRolepCurrentOperationHandle.DisplayStringCount = 0;
    DsRolepCurrentOperationHandle.MsgModuleHandle = NULL;
    DsRolepCurrentOperationHandle.UpdateStringDisplayable = NULL;
    DsRolepCurrentOperationHandle.FinalResultStringDisplayable = NULL;
    DsRolepCurrentOperationHandle.InstalledSiteName = NULL;
    DsRolepCurrentOperationHandle.OperationResultFlags = 0;

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    return;

}

DWORD
DsRolepSetCurrentOperationStatus(
    IN ULONG MsgIndex,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    )
/*++

Routine Description:

    Internal routine for updating the current operation handle statics

Arguments:

    MsgIndex - Display message resource index

    Parameter1 - First display parameter

    Parameter2 - Second display parameter

    Parameter3 - Third display parameter

    Parameter4 - Fourth display parameter


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG Size;

    ASSERT( MsgIndex != 0 );

    //
    // Grab the lock
    //
    LockOpHandle();

    DsRolepCurrentOperationHandle.MsgIndex = MsgIndex;

    //
    // Release previously held parameters
    //
    if ( DsRolepCurrentOperationHandle.Parameter1 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter1 );
        DsRolepCurrentOperationHandle.Parameter1 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter2 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter2 );
        DsRolepCurrentOperationHandle.Parameter2 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter3 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter3 );
        DsRolepCurrentOperationHandle.Parameter3 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter4 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter4 );
        DsRolepCurrentOperationHandle.Parameter4 = NULL;
    }

    //
    // Copy the new ones in
    //
    if ( Parameter1 ) {
        Size = (wcslen( Parameter1 ) + 1) * sizeof(WCHAR);
        DsRolepCurrentOperationHandle.Parameter1 = LocalAlloc( 0, Size );
        if ( !DsRolepCurrentOperationHandle.Parameter1 ) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto ReleaseLock;
        }
        wcscpy( DsRolepCurrentOperationHandle.Parameter1, Parameter1  );
    }

    if ( Parameter2 ) {
        Size = (wcslen( Parameter2 ) + 1) * sizeof(WCHAR);
        DsRolepCurrentOperationHandle.Parameter2 = LocalAlloc( 0, Size );
        if ( !DsRolepCurrentOperationHandle.Parameter2 ) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto ReleaseLock;
        }
        wcscpy( DsRolepCurrentOperationHandle.Parameter2, Parameter2 );
    }

    if ( Parameter3 ) {
        Size = (wcslen( Parameter3 ) + 1) * sizeof(WCHAR);
        DsRolepCurrentOperationHandle.Parameter3 = LocalAlloc( 0, Size );
        if ( !DsRolepCurrentOperationHandle.Parameter3 ) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto ReleaseLock;
        }
        wcscpy( DsRolepCurrentOperationHandle.Parameter3, Parameter3 );
    }

    if ( Parameter4 ) {
        Size = (wcslen( Parameter4 ) + 1) * sizeof(WCHAR);
        DsRolepCurrentOperationHandle.Parameter4 = LocalAlloc( 0, Size );
        if ( !DsRolepCurrentOperationHandle.Parameter4 ) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto ReleaseLock;
        }
        wcscpy( DsRolepCurrentOperationHandle.Parameter4, Parameter4 );
    }

    {
        PWSTR DisplayString;
        DWORD E2;
        E2 = DsRolepFormatOperationString(
                           DsRolepCurrentOperationHandle.MsgIndex,
                           &DisplayString,
                           DsRolepCurrentOperationHandle.Parameter1,
                           DsRolepCurrentOperationHandle.Parameter2,
                           DsRolepCurrentOperationHandle.Parameter3,
                           DsRolepCurrentOperationHandle.Parameter4 );

        if ( E2 == ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_TRACE, "%ws", DisplayString ));
            MIDL_user_free( DisplayString );
        }
    }

ReleaseLock:

    //
    // Don't forget to release the lock
    //
    UnlockOpHandle();


    return( Win32Err );
}



DWORD
DsRolepSetFailureMessage(
    IN DWORD FailureStatus,
    IN ULONG MsgIndex,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    )
/*++

Routine Description:

    Internal routine for updating the failure return string

Arguments:

    FailureStatus - Error code for the failure

    MsgIndex - Display message resource index

    Parameter1 - First display parameter

    Parameter2 - Second display parameter

    Parameter3 - Third display parameter

    Parameter4 - Fourth display parameter


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR DisplayString = NULL;

    ASSERT( MsgIndex != 0 );

    Win32Err = DsRolepFormatOperationString( MsgIndex,
                                             &DisplayString,
                                             Parameter1,
                                             Parameter2,
                                             Parameter3,
                                             Parameter4 );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepStringErrorUpdateCallback( DisplayString, FailureStatus );

        MIDL_user_free( DisplayString );
    }

    return( Win32Err );
}



DWORD
DsRolepSetOperationDone(
    IN DWORD Flags,
    IN DWORD OperationStatus
    )
/*++

Routine Description:

    Indicates that the requested operation has completed

Arguments:

    Flags -- currently : DSROLEP_OP_DEMOTION
                         DSROLEP_OP_PROMOTION
                                             
    OperationStatus - Final status of the requsted operation

Returns:

    ERROR_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Grab the lock
    //
    LockOpHandle();

    DSROLEP_CURRENT_OP0( DSROLEEVT_PROMOTION_COMPLETE );
    DsRolepCurrentOperationHandle.OperationState = DSROLEP_FINISHED;

    if ( DsRolepCurrentOperationHandle.OperationStatus == 0 
     ||  (OperationStatus == ERROR_CANCELLED) ) {

        DsRolepCurrentOperationHandle.OperationStatus = OperationStatus;
    }

    if ( ERROR_SUCCESS == DsRolepCurrentOperationHandle.OperationStatus ) {

        //
        // Log an event indicating the role has changed
        //
        DWORD MsgId = 0;
        if ( Flags & DSROLEP_OP_DEMOTION ) {

            MsgId = DSROLERES_DEMOTE_SUCCESS;
            
        } else if ( Flags & DSROLEP_OP_PROMOTION ) {

            MsgId = DSROLERES_PROMOTE_SUCCESS;
            
        } else if ( Flags & DSROLEP_OP_DEMOTION_FORCED ) {

            MsgId = DSROLERES_FORCE_DEMOTE_SUCCESS;
        
        } else {

            ASSERT( FALSE && !"Bad Parameter" );

        }

        SpmpReportEvent( TRUE,
                         EVENTLOG_INFORMATION_TYPE,
                         MsgId,
                         0,
                         0,
                         NULL,
                         0 );
    }

    //
    // If the operation was cancelled, give the same error message every
    // time
    //
    if ( ERROR_CANCELLED == DsRolepCurrentOperationHandle.OperationStatus ) {

        (VOID) DsRolepSetFailureMessage( ERROR_CANCELLED,
                                         DSROLERES_OP_CANCELLED,
                                         NULL, NULL, NULL, NULL );
    }

    //
    // Signal the completion event
    //
    Status = NtSetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );

    DsRoleDebugOut(( DEB_TRACE_DS, "DsRolepSetOperationDone[ %lu ]\n",
                      OperationStatus ));


    //
    // Release the lock
    //
    UnlockOpHandle();

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolepSetOperationDone returned %lu\n",
                       RtlNtStatusToDosError( Status ) ));


    return( RtlNtStatusToDosError( Status ) );
}


DWORD
DsRolepGetDcOperationProgress(
    IN PDSROLE_SERVEROP_HANDLE DsOperationHandle,
    IN OUT PDSROLER_SERVEROP_STATUS *ServerOperationStatus
    )
/*++

Routine Description:

    Implementation of the RPC server for determining the current level of progress of an
    operation

Arguments:

    DsOperationHandle - Handle to an open operation

    ServerOperationStatus - Where the status is returned.

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    //
    // Grab the lock
    //
    LockOpHandle();

    //
    // Allocate the return structure
    //
    *ServerOperationStatus = MIDL_user_allocate( sizeof( DSROLER_SERVEROP_STATUS ) );

    if ( *ServerOperationStatus == NULL )  {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        //
        // Build the return string
        //
        if ( DsRolepCurrentOperationHandle.MsgIndex == 0  ) {

            ( *ServerOperationStatus )->CurrentOperationDisplayString = MIDL_user_allocate(
                ( wcslen( DsRolepCurrentOperationHandle.UpdateStringDisplayable ) + 1 ) *
                                                                            sizeof( WCHAR ) );


            if ( ( *ServerOperationStatus )->CurrentOperationDisplayString == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                wcscpy( ( *ServerOperationStatus )->CurrentOperationDisplayString,
                        DsRolepCurrentOperationHandle.UpdateStringDisplayable );

                //
                // Set the status flags if they exist
                //
                if ( DsRolepCurrentOperationHandle.OperationState == DSROLEP_RUNNING_NON_CRITICAL ) {

                    ( *ServerOperationStatus )->OperationStatus =
                                                        DSROLE_CRITICAL_OPERATIONS_COMPLETED;
                } else {

                    ( *ServerOperationStatus )->OperationStatus = 0;

                }

                ( *ServerOperationStatus )->CurrentOperationDisplayStringIndex =
                            DsRolepCurrentOperationHandle.DisplayStringCount == 0 ? 0 :
                                    DsRolepCurrentOperationHandle.DisplayStringCount - 1;
            }

        } else {

            Win32Err = DsRolepFormatOperationString(
                           DsRolepCurrentOperationHandle.MsgIndex,
                           &( *ServerOperationStatus )->CurrentOperationDisplayString,
                           DsRolepCurrentOperationHandle.Parameter1,
                           DsRolepCurrentOperationHandle.Parameter2,
                           DsRolepCurrentOperationHandle.Parameter3,
                           DsRolepCurrentOperationHandle.Parameter4 );
        }

        if ( Win32Err != ERROR_SUCCESS ) {

            MIDL_user_free( *ServerOperationStatus );
            *ServerOperationStatus = NULL;
        }
    }

    //
    // If the operation isn't completed, return that information to the caller
    //
    if ( Win32Err == ERROR_SUCCESS &&
         DsRolepCurrentOperationHandle.OperationState != DSROLEP_FINISHED ) {

        Win32Err = ERROR_IO_PENDING;
    }

    //
    // Release the lock
    //
    UnlockOpHandle();

    return( Win32Err );
}



DWORD
DsRolepFormatOperationString(
    IN ULONG MsgId,
    OUT LPWSTR *FormattedString,
    ...
    )
/*++

Routine Description:

    Allocates and formats the buffer string to be returned

Arguments:

    MsgId - Which message id to format

    FormattedString - Where the string is allocated.  Allocation uses MIDL_user_allocate

    ... - va_list of arguments for the formatted string

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR MsgBuffer[ 512 + 1];
    PWSTR Msg = MsgBuffer;
    ULONG MsgLength = (sizeof(MsgBuffer) / sizeof(MsgBuffer[0]) ) - 1;
    ULONG Length;
    BOOL  fSuccess = FALSE;
    BOOL  fTokenCreatedLocally = FALSE;
    va_list ArgList;

    va_start( ArgList, FormattedString );

    //
    // Load the module handle for lsasrv.dll, so we can get our messages
    //
    if ( DsRolepCurrentOperationHandle.MsgModuleHandle == NULL ) {

        DsRolepCurrentOperationHandle.MsgModuleHandle = GetModuleHandle( L"LSASRV" );

        ASSERT( DsRolepCurrentOperationHandle.MsgModuleHandle );

        if ( DsRolepCurrentOperationHandle.MsgModuleHandle == NULL ) {

            return( GetLastError() );
        }
    }

    //
    //  If we don't have a clientToken then get one at the
    //
    if ( DsRolepCurrentOperationHandle.ClientToken == NULL ) {

        Win32Err = DsRolepGetImpersonationToken(&DsRolepCurrentOperationHandle.ClientToken);
        if (ERROR_SUCCESS != Win32Err) {
            DsRolepCurrentOperationHandle.ClientToken = NULL;
            DsRolepLogPrintRoutine(DEB_WARN, "Cannot get user Token for Format Message: %d\n",
                                   Win32Err);
            Win32Err = ERROR_SUCCESS;
            //if error clear and continue, errors here are not fatal
        } else {

            fTokenCreatedLocally = TRUE;

        }

    }
    
    //
    // Get the required buffer size
    //

    //
    // FormatMessage complains when given a NULL input buffer, so we'll pass in one, even though
    // it won't be used because of the size being 0.
    //
    if (DsRolepCurrentOperationHandle.ClientToken) {
    
        fSuccess = ImpersonateLoggedOnUser(DsRolepCurrentOperationHandle.ClientToken);

    }
    // if we couldn't impersonate we continue anyway.
    if (!fSuccess) {
        DsRolepLogPrintRoutine(DEB_WARN, "Cannot get user locale for Format Message: %d\n",
                               GetLastError());
    }

    Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                            DsRolepCurrentOperationHandle.MsgModuleHandle,
                            MsgId, 0, Msg, MsgLength, &ArgList );

    if ( Length == 0 ) {

        Win32Err = GetLastError();

        ASSERT( Win32Err != ERROR_MR_MID_NOT_FOUND );

        if ( Win32Err == ERROR_INSUFFICIENT_BUFFER ) {

            Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    DsRolepCurrentOperationHandle.MsgModuleHandle,
                                    MsgId, 0, ( PWSTR )&Msg, 0, &ArgList );
            if ( Length == 0 ) {

                Win32Err = GetLastError();

            } else {

                Win32Err = ERROR_SUCCESS;
            }

        }

    }

    if (fSuccess) {
        fSuccess = RevertToSelf();
        if (!fSuccess) {
            DsRolepLogPrintRoutine(DEB_WARN, "Cannot reset to system security setting: %d\n",
                                   GetLastError());
        }
    }

    //if we create a token for this call then we need to clear it out.
    if(DsRolepCurrentOperationHandle.ClientToken && fTokenCreatedLocally){
        CloseHandle(DsRolepCurrentOperationHandle.ClientToken);
        DsRolepCurrentOperationHandle.ClientToken = NULL;
    }

    if( Win32Err == ERROR_SUCCESS ) {

        //
        // Allocate a buffer
        //
        Length = ( wcslen( Msg ) + 1 ) * sizeof( WCHAR );
        *FormattedString = MIDL_user_allocate( Length );

        if ( *FormattedString == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            RtlCopyMemory( *FormattedString, Msg, Length );

        }
    }

    if ( Msg != MsgBuffer ) {

        LocalFree( Msg );
    }

    return( Win32Err );
}


VOID
DsRolepSetCriticalOperationsDone(
    VOID
    )
/*++

Routine Description:

    Indicates to our current operation status block that the critical portion of the install
    has been completed...


Arguments:

    VOID

Returns:

    VOID

--*/
{
    //
    // Grab the lock
    //
    LockOpHandle();

    DsRolepCurrentOperationHandle.OperationState = DSROLEP_RUNNING_NON_CRITICAL;

    //
    // Release the lock
    //
    UnlockOpHandle();

    return;
}



VOID
DsRolepIncrementDisplayStringCount(
    VOID
    )
/*++

Routine Description:

    Increments the count of the successfully started display update strings.  This is always
    the index into the list of DisplayStrings PLUS ONE.


Arguments:

    VOID

Returns:

    VOID

--*/
{
    //
    // Grab the lock
    //
    LockOpHandle();

    DsRolepCurrentOperationHandle.DisplayStringCount++;

    //
    // Release the lock
    //
    UnlockOpHandle();

    return;
}



DWORD
DsRolepGetDcOperationResults(
    IN  PDSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLER_SERVEROP_RESULTS *ServerOperationResults
    )
/*++

Routine Description:

    Gets the results of the final operation.  If the operation has not yet completed, this
    function will block until it does

Arguments:

    DsOperationHandle - Handle to an open operation

    ServerOperationResults - Where the result is returned.

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    DSROLEP_OPERATION_STATE  OpState;
    BOOLEAN fNeedReboot = FALSE;


    //
    // Parameter checking
    //
    if ( !ServerOperationResults ) {

        return ERROR_INVALID_PARAMETER;
        
    }

    //
    // Make sure an operation is active
    //
    LockOpHandle();

    OpState = DsRolepCurrentOperationHandle.OperationState;

    UnlockOpHandle();

    //
    // It's an error if the operation isn't active
    //
    if ( !DSROLEP_OPERATION_ACTIVE( OpState ) ) {

        return ERROR_NO_PROMOTION_ACTIVE;

    }

    //
    // Wait for the operation to complete
    //
    Status = NtWaitForSingleObject( DsRolepCurrentOperationHandle.CompletionEvent, TRUE, NULL );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Lock the handle
        //
        LockOpHandle();

        //
        // Allocate the return structure
        //
        *ServerOperationResults = MIDL_user_allocate( sizeof( DSROLER_SERVEROP_RESULTS ) );

        if ( *ServerOperationResults == NULL )  {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            ( *ServerOperationResults )->OperationResultsFlags = 0;

            //
            // Build the return string
            //
            if ( DsRolepCurrentOperationHandle.OperationStatus != ERROR_SUCCESS ||
                 DsRolepCurrentOperationHandle.MsgIndex == 0  ) {

                DSROLEP_MIDL_ALLOC_AND_COPY_STRING_ERROR(
                    ( *ServerOperationResults )->OperationStatusDisplayString,
                    DsRolepCurrentOperationHandle.OperationStatus != ERROR_SUCCESS ?
                            DsRolepCurrentOperationHandle.FinalResultStringDisplayable :
                            DsRolepCurrentOperationHandle.UpdateStringDisplayable,
                    Win32Err );

            } else {

                Win32Err = DsRolepFormatOperationString(
                               DsRolepCurrentOperationHandle.MsgIndex,
                               &( *ServerOperationResults )->OperationStatusDisplayString,
                               DsRolepCurrentOperationHandle.Parameter1,
                               DsRolepCurrentOperationHandle.Parameter2,
                               DsRolepCurrentOperationHandle.Parameter3,
                               DsRolepCurrentOperationHandle.Parameter4 );
            }


            if ( Win32Err == ERROR_SUCCESS ) {

                ( *ServerOperationResults )->OperationStatus =
                                            DsRolepCurrentOperationHandle.OperationStatus;
                DsRoleDebugOut(( DEB_TRACE_DS,
                                 "Returning status %lu\n",
                                 DsRolepCurrentOperationHandle.OperationStatus ));

                // If the operation finished successfully, we need
                // a reboot
                if ( ERROR_SUCCESS == DsRolepCurrentOperationHandle.OperationStatus )
                {    
                    fNeedReboot = TRUE;
                }
            }

            //
            // Return the site name, if it exists
            //
            if ( Win32Err == ERROR_SUCCESS ) {

                DSROLEP_MIDL_ALLOC_AND_COPY_STRING_ERROR(
                    ( *ServerOperationResults)->ServerInstalledSite,
                    DsRolepCurrentOperationHandle.InstalledSiteName,
                    Win32Err );

                if ( Win32Err != ERROR_SUCCESS ) {

                    MIDL_user_free(
                             ( *ServerOperationResults )->OperationStatusDisplayString );
                }
            }

            //
            // Set the flags, if necessary
            //
            if ( Win32Err == ERROR_SUCCESS ) {

                    ( *ServerOperationResults )->OperationResultsFlags |=
                        DsRolepCurrentOperationHandle.OperationResultFlags;
            }

            if ( Win32Err != ERROR_SUCCESS ) {

                MIDL_user_free( *ServerOperationResults );
                *ServerOperationResults = NULL;
            }


            UnlockOpHandle();

            //
            // Reset our current operation handle
            //
            DsRolepResetOperationHandle( fNeedReboot ? DSROLEP_NEED_REBOOT : DSROLEP_IDLE );


        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RtlNtStatusToDosError( Status );
    }


    return( Win32Err );
}

DWORD
DsRolepOperationResultFlagsCallBack(
    IN DWORD Flags
    )
/*++

Routine Description:

    Internal routine for updating the Operation Results Flags

Arguments:

    Flags - DWORD of flags to | with current flags


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    LockOpHandle();

    DsRolepCurrentOperationHandle.OperationResultFlags |= Flags;

    UnlockOpHandle();

    return( Win32Err );
}

DWORD
DsRolepStringUpdateCallback(
    IN  PWSTR StringUpdate
    )
/*++

Routine Description:

    Internal routine for updating the current operation handle statics

Arguments:

    StringUpdate - Displayables string to set in place of the current parameters


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG len;

    //
    // Grab the lock
    //
    LockOpHandle();

    DsRolepCurrentOperationHandle.MsgIndex   = 0;
    DsRolepCurrentOperationHandle.Parameter1 = 0;
    DsRolepCurrentOperationHandle.Parameter2 = 0;
    DsRolepCurrentOperationHandle.Parameter3 = 0;
    DsRolepCurrentOperationHandle.Parameter4 = 0;

    if ( StringUpdate ) {

        DsRolepLogPrint(( DEB_TRACE, "%ws\n", StringUpdate ));
        
    } else {

        Win32Err = ERROR_INVALID_PARAMETER;
        goto Exit;

    }
    
    DsRoleDebugOut(( DEB_TRACE_UPDATE,
                     "DsRolepSetCurrentOperationStatus for string %ws\n",
                     StringUpdate ));

    if ( DsRolepCurrentOperationHandle.UpdateStringDisplayable ) {

        RtlFreeHeap( RtlProcessHeap(), 0, DsRolepCurrentOperationHandle.UpdateStringDisplayable );
        
    }

    DsRolepCurrentOperationHandle.UpdateStringDisplayable =
        RtlAllocateHeap( RtlProcessHeap(), 0,
                         ( wcslen( StringUpdate ) + 1 ) * sizeof( WCHAR ) );

    if ( DsRolepCurrentOperationHandle.UpdateStringDisplayable == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        wcscpy( DsRolepCurrentOperationHandle.UpdateStringDisplayable, StringUpdate );

    }

    //
    // Don't forget to release the lock
    //
    UnlockOpHandle();

Exit:

    return( Win32Err );
}



DWORD
DsRolepStringErrorUpdateCallback(
    IN PWSTR String,
    IN DWORD ErrorCode
    )
/*++

Routine Description:

    Internal routine for updating the last failure operation

Arguments:

    String - Displayable error string

    ErrorCode - Error code associated with this failure

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    //
    // Grab the lock
    //
    LockOpHandle();

    if ( (ERROR_SUCCESS == DsRolepCurrentOperationHandle.OperationStatus) 
      || (ERROR_CANCELLED == ErrorCode)  ) {

        //
        // Cancel overides previous error codes
        //

        if ( DsRolepCurrentOperationHandle.FinalResultStringDisplayable ) {
            RtlFreeHeap( RtlProcessHeap(), 0, DsRolepCurrentOperationHandle.FinalResultStringDisplayable );
        }

        DsRolepCurrentOperationHandle.FinalResultStringDisplayable =
          RtlAllocateHeap( RtlProcessHeap(), 0, ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );

        if ( DsRolepCurrentOperationHandle.FinalResultStringDisplayable == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            wcscpy( DsRolepCurrentOperationHandle.FinalResultStringDisplayable, String );
            DsRolepCurrentOperationHandle.OperationStatus = ErrorCode;
            DsRoleDebugOut(( DEB_TRACE_UPDATE,
                             "DsRolepStringErrorUpdateCallback for error %lu and string %ws\n",
                             ErrorCode,
                             String ));


            DsRolepLogPrint(( DEB_TRACE, "Error - %ws (%d)\n", String, ErrorCode ));
        }
    }

    //
    // Release the lock
    //
    UnlockOpHandle();

    return( Win32Err );
}

DWORD
DsRolepSetOperationHandleSiteName(
    IN LPWSTR SiteName
    )
{
    LockOpHandle();

    DsRolepCurrentOperationHandle.InstalledSiteName = SiteName;

    UnlockOpHandle();

    return ERROR_SUCCESS;

}

BOOLEAN
DsRolepCurrentThreadOwnsLock(
    VOID
    )
/*++

  Routine Description

        Tests wether the current thread owns the lock

--*/
{
    ULONG_PTR ExclusiveOwnerThread = (ULONG_PTR) DsRolepCurrentOperationHandle.CurrentOpLock.ExclusiveOwnerThread;
    ULONG_PTR CurrentThread = (ULONG_PTR) (NtCurrentTeb())->ClientId.UniqueThread;

    if ((DsRolepCurrentOperationHandle.CurrentOpLock.NumberOfActive <0) && (ExclusiveOwnerThread==CurrentThread))
        return TRUE;

    return FALSE;
}


VOID
DsRolepClearErrors(
    VOID
    )
/*++

  Routine Description

        This routine clears the global status.  The purpose of this is to 
        clear errors that components may have set after the demotion is 
        unrollable and should not return errors.
        
--*/
{

    //
    // Grab the lock
    //
    LockOpHandle();

    if ( DsRolepCurrentOperationHandle.OperationStatus != ERROR_SUCCESS ) {

        //
        // Set a warning that something went wrong
        //
        DsRolepLogPrint(( DEB_TRACE, "Clearing a global error" ));

        DSROLEP_SET_NON_FATAL_ERROR( DsRolepCurrentOperationHandle.OperationStatus );

    } 

    if ( DsRolepCurrentOperationHandle.FinalResultStringDisplayable ) {

        RtlFreeHeap( RtlProcessHeap(), 0, DsRolepCurrentOperationHandle.FinalResultStringDisplayable );
        DsRolepCurrentOperationHandle.FinalResultStringDisplayable = NULL;

    }
        
    DsRolepCurrentOperationHandle.OperationStatus = ERROR_SUCCESS;       

    //
    // Release the lock
    //
    UnlockOpHandle();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\ophandle.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ophandle.h

Abstract:

    Routines to manipulate the global DsRole operation handle

Author:

    Colin Brace         (ColinBr)       April 5, 1999

Environment:

    User Mode

Revision History:

--*/
#ifndef __OPHANDLE_H__
#define __OPHANDLE_H__

//
// First, a type definition of the finite difference states a role operation
// can be in
//

//
//  Operation State diagram of a role change
//
//           
//     /-----------------------\
//     |    (operation failed  |  
//     |     or cancelled)     |
//     v                       ^
//  Idle <--> Running  --> Finished  ---------------> Need Reboot
//            |    |           ^      (operation
//            |    |           |       succeeded)
//            |    |           |
//            |    |           |
//            |    v           |
//            |  Cancelling -->|
//            |    ^           ^
//            |    |           |
//            |    |           |
//            |    |           |
//            v    ^           |
//         Running             |
//       Non Critical ---------/ 
//
//
// N.B. Running to Idle to a rare error case, where the worker thread could
//      not be created.
//
//

typedef enum _DSROLEP_OPERATION_STATE {

    DSROLEP_IDLE = 0,
    DSROLEP_RUNNING,
    DSROLEP_RUNNING_NON_CRITICAL,
    DSROLEP_CANCELING,
    DSROLEP_FINISHED,
    DSROLEP_NEED_REBOOT

} DSROLEP_OPERATION_STATE;

#define DSROLEP_OPERATION_ACTIVE( Op ) \
    ( (Op == DSROLEP_IDLE) || (Op == DSROLEP_NEED_REBOOT) ? FALSE : TRUE )

//
// Now, the definition of the global operation handle that controls a role
// change
// 
// Whenever reading or writing a value to the operation handle, you must 
// lock the structure first.
//
// Use LockOpHandle() and UnLockOpHandle().
// 
//
typedef struct _DSROLEP_OPERATION_HANDLE {

    RTL_RESOURCE CurrentOpLock;
    DSROLEP_OPERATION_STATE OperationState;
    HANDLE CompletionEvent;
    HANDLE OperationThread;
    HANDLE MsgModuleHandle;
    HANDLE CancelEvent;
    HANDLE ClientToken;
    ULONG OperationStatus;
    ULONG MsgIndex;
    ULONG DisplayStringCount;
    PVOID Parameter1;
    PVOID Parameter2;
    PVOID Parameter3;
    PVOID Parameter4;
    PWSTR UpdateStringDisplayable;
    PWSTR FinalResultStringDisplayable;
    PWSTR InstalledSiteName;
    DWORD OperationResultFlags;

} DSROLEP_OPERATION_HANDLE, *PDSROLEP_OPERATION_HANDLE;

extern DSROLEP_OPERATION_HANDLE   DsRolepCurrentOperationHandle;

//
// Type definition for the server handle
//
typedef DSROLE_SERVEROP_HANDLE *PDSROLE_SERVEROP_HANDLE;

//
// Macros for locking the the operation handle
//
#define LockOpHandle() RtlAcquireResourceExclusive( &DsRolepCurrentOperationHandle.CurrentOpLock, TRUE );
#define UnlockOpHandle() RtlReleaseResource( &DsRolepCurrentOperationHandle.CurrentOpLock );

//
// Function for knowing is current thread owns the lock
//

BOOLEAN
DsRolepCurrentThreadOwnsLock(
    VOID
    );

//
// Macros for setting the current operation state
//
#define DSROLEP_CURRENT_OP0( msg )                                          \
        DsRolepSetCurrentOperationStatus( msg, NULL, NULL, NULL, NULL );

#define DSROLEP_CURRENT_OP1( msg, p1 )                                      \
        DsRolepSetCurrentOperationStatus( msg, ( PVOID )p1, NULL, NULL, NULL );

#define DSROLEP_CURRENT_OP2( msg, p1, p2 )                                  \
        DsRolepSetCurrentOperationStatus( msg, ( PVOID )p1, ( PVOID )p2,    \
                                          NULL, NULL );
#define DSROLEP_CURRENT_OP3( msg, p1, p2, p3 )                              \
        DsRolepSetCurrentOperationStatus( msg, ( PVOID )p1, ( PVOID )p2,    \
                                          NULL, NULL );
#define DSROLEP_CURRENT_OP4( msg, p1, p2, p3, p4 )                          \
        DsRolepSetCurrentOperationStatus( msg, ( PVOID )p1, ( PVOID )p2,    \
                                          ( PVOID )p3, ( PVOID )p4 );

#define DSROLEP_FAIL0( err, msg )                                           \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, NULL, NULL, NULL, NULL );

#define DSROLEP_FAIL1( err, msg, p1 )                                       \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, ( PVOID )( p1 ), NULL, NULL, NULL );

#define DSROLEP_FAIL2( err, msg, p1, p2 )                                   \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, ( PVOID )( p1 ), ( PVOID )( p2 ), NULL, NULL );

#define DSROLEP_FAIL3( err, msg, p1, p2, p3 )                           \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, ( PVOID )( p1 ), ( PVOID )( p2 ), \
                                  ( PVOID )( p3 ), NULL );

#define DSROLEP_FAIL4( err, msg, p1, p2, p3, p4 )                           \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, ( PVOID )( p1 ), ( PVOID )( p2 ), \
                                  ( PVOID )( p3 ), ( PVOID )( p4 ) );

#define DSROLEP_SET_NON_FATAL_ERROR( Err )                DsRolepCurrentOperationHandle.OperationResultFlags |= DSROLE_NON_FATAL_ERROR_OCCURRED;
#define DSROLEP_SET_NON_CRIT_REPL_ERROR( )                DsRolepCurrentOperationHandle.OperationResultFlags |= DSROLE_NON_CRITICAL_REPL_NOT_FINISHED;
#define DSROLEP_SET_IFM_RESTORED_DATABASE_FILES_MOVED( )  DsRolepCurrentOperationHandle.OperationResultFlags |= DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED;

//
// Macro to determine whether to cancel an operation or not
//
#define DSROLEP_CHECK_FOR_CANCEL( WErr )                                  \
{                                                                         \
    LockOpHandle();                                                       \
    if( DsRolepCurrentOperationHandle.OperationState == DSROLEP_CANCELING \
     && (WErr == ERROR_SUCCESS)) {                                        \
                                                                          \
        WErr = ERROR_CANCELLED;                                           \
    }                                                                     \
    UnlockOpHandle();                                                     \
}

#define DSROLEP_CHECK_FOR_CANCEL_EX( WErr, Label )                        \
{                                                                         \
    LockOpHandle();                                                       \
    if( DsRolepCurrentOperationHandle.OperationState == DSROLEP_CANCELING \
     && (WErr == ERROR_SUCCESS)) {                                        \
                                                                          \
        WErr = ERROR_CANCELLED;                                           \
        UnlockOpHandle();                                                 \
        goto Label;                                                       \
    }                                                                     \
    UnlockOpHandle();                                                     \
}

//
// Prototypes for worker functions
//
DWORD
DsRolepGetDcOperationProgress(
    IN PDSROLE_SERVEROP_HANDLE DsOperationHandle,
    IN OUT PDSROLER_SERVEROP_STATUS *ServerOperationStatus
    );

DWORD
DsRolepGetDcOperationResults(
    IN  PDSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLER_SERVEROP_RESULTS *ServerOperationResults
    );

DWORD
DsRolepSetOperationHandleSiteName(
    IN LPWSTR SiteName
    );

VOID
DsRolepSetCriticalOperationsDone(
    VOID
    );

DWORD
DsRolepInitializeOperationHandle(
    VOID
    );

typedef enum _DSROLEP_OPERATION_TYPE {

    DSROLEP_OPERATION_DC = 0,
    DSROLEP_OPERATION_REPLICA,
    DSROLEP_OPERATION_DEMOTE

} DSROLEP_OPERATION_TYPE, *PDSROLEP_OPERATION_TYPE;

DWORD
DsRolepResetOperationHandle(
    DSROLEP_OPERATION_STATE OpState
    );

VOID
DsRolepResetOperationHandleLockHeld(
    VOID
    );

DWORD
DsRolepSetCurrentOperationStatus(
    IN ULONG MsgIndex,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    );

DWORD
DsRolepSetFailureMessage(
    IN DWORD FailureStatus,
    IN ULONG MsgIndex,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    );


VOID
DsRolepClearErrors(
    VOID
    );

#define DSROLEP_OP_PROMOTION        0x00000001
#define DSROLEP_OP_DEMOTION         0x00000002
#define DSROLEP_OP_DEMOTION_FORCED  0x00000004

DWORD
DsRolepSetOperationDone(
    IN DWORD Flags,
    IN DWORD OperationStatus
    );

DWORD
DsRolepFormatOperationString(
    IN ULONG MsgId,
    OUT LPWSTR *FormattedString,
    ...
    );

DWORD
DsRolepStringUpdateCallback(
    IN  PWSTR StringUpdate
    );

DWORD
DsRolepStringErrorUpdateCallback(
    IN PWSTR String,
    IN DWORD ErrorCode
    );

DWORD
DsRolepOperationResultFlagsCallBack(
    IN DWORD Flags
    );

//
// The IFM handle is a context blob of information that is used for IFM 
// install data that can't be shared with dcpromo.
//
// The fIfmOpHandleLock is set to TRUE when there is anyone:
//
//      setting the IfmSystemInfo (DsRolerGetDatabaseFacts())
//      clearing the IfmSystemInfo (DsRolerIfmHandleFree()) or
//      consuming the IfmSystemInfo (DsRolerDcAsReplica())
//
// The fIfmOpHandleLock gets unset on exit of DsRolerGetDatabaseFacts() 
// or DsRolerIfmHandleFree() if they grabbed the lock, and on any
// transition through "finished" for the OperationState in call to
// DsRolepResetOperationHandle() with DSROLEP_IDLE or DSROLEP_NEED_REBOOT
//
//
typedef struct _DSROLEP_IFM_OPERATION_HANDLE {
    
    DWORD   fIfmOpHandleLock;
    DWORD   fIfmSystemInfoSet;

    // Information from the IFM System's registry
    IFM_SYSTEM_INFO IfmSystemInfo;

} DSROLEP_IFM_OPERATION_HANDLE, *PDSROLEP_IFM_OPERATION_HANDLE;
extern DSROLEP_IFM_OPERATION_HANDLE   DsRolepCurrentIfmOperationHandle;

#endif // __OPHANDLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\services.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    services.c

Abstract:

    Routines to manage nt service configurations for promotion and demotion

Author:

    Colin Brace    ColinBr     March 29, 1999.

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>

#include <malloc.h>  // alloca

#include <lmcons.h>  // net api definitions
#include <lmsvc.h>   // service names
#include <ismapi.h>  //defines ISM_SERVICE_CONTROL_REMOVE_STOP

#include "services.h"

//
// These last 3 magic values supplied by Shirish Koti (koti) to setup up
// ras services for macintosh on a domain controller
//
#define DSROLEP_MSV10_PATH    L"SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0"
#define DSROLEP_RASSFM_NAME   L"Auth2"
#define DSROLEP_RASSFM_VALUE  L"RASSFM"

//
// Global Data for this module
//

//
// Table based data for the intrinsic nt services
//
typedef struct _DSROLEP_SERVICE_ITEM
{
    LPWSTR ServiceName;       // name of the service to configure

    ULONG  ConfigureOn;       // the dsrole flag to enable the service

    ULONG  ConfigureOff;      // the dsrole flag to disable the service

    ULONG  RevertSettings;    // the dsrole flags to use to revert settings

    LPWSTR Dependencies[3]; // the dependencies the service has when enabled

} DSROLEP_SERVICE_ITEM;

//
// These are services that run on machines that are part of a domain
//
DSROLEP_SERVICE_ITEM DsRoleDomainServices[] = 
{
    {
        SERVICE_W32TIME,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_NETLOGON,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_DEMANDSTART,
        0,
        NULL, NULL, NULL
    }
};

ULONG DsRoleDomainServicesCount = sizeof(DsRoleDomainServices) / sizeof(DsRoleDomainServices[0]);

//
// These are servers that run on machines that are domain controllers
//
DSROLEP_SERVICE_ITEM DsRoleDomainControllerServices[] = 
{
    // This was set to AUTOSTART in W2K. In Whistler we set RPC Locator to DemandStart
    // both on promotions and demotions.
    {
        SERVICE_RPCLOCATOR,
        DSROLEP_SERVICE_DEMANDSTART,
        DSROLEP_SERVICE_DEMANDSTART,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_ISMSERV,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_DISABLED | DSROLEP_SERVICE_STOP_ISM,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_KDC,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_DISABLED,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_TRKSVR,
        DSROLEP_SERVICE_NOOP,
        DSROLEP_SERVICE_DEMANDSTART,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_TRKWKS,
        DSROLEP_SERVICE_DEMANDSTART,
        DSROLEP_SERVICE_NOOP,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_NETLOGON,
        DSROLEP_SERVICE_AUTOSTART | DSROLEP_SERVICE_DEP_ADD,
        DSROLEP_SERVICE_AUTOSTART | DSROLEP_SERVICE_DEP_REMOVE,
        DSROLEP_SERVICES_INVALID,
        SERVICE_SERVER, NULL, NULL
    }
};

ULONG DsRoleDomainControllerServicesCount = sizeof(DsRoleDomainControllerServices) / sizeof(DsRoleDomainControllerServices[0]);

//
// Local forwards
//
DWORD
DsRolepSetRegStringValue(
    IN LPWSTR Path,
    IN LPWSTR ValueName,
    IN LPWSTR Value
    );

DWORD
DsRolepConfigureGenericServices(
    IN DSROLEP_SERVICE_ITEM *ServiceArray,
    IN ULONG                 ServiceCount,
    IN ULONG                 Flags
    );

DWORD
DsRolepMakeAdjustedDependencyList(
    IN HANDLE hSvc,
    IN DWORD  ServiceOptions,
    IN LPWSTR Dependency,
    OUT LPWSTR *DependenyList
    );

DWORD
DsRolepGetServiceConfig(
    IN SC_HANDLE hScMgr,
    IN LPWSTR ServiceName,
    IN SC_HANDLE ServiceHandle,
    IN LPQUERY_SERVICE_CONFIG *ServiceConfig
    );
    
//
// Small helper functions
//
DWORD DsRolepFlagsToServiceFlags(
    IN DWORD f
    )
{

    if ( FLAG_ON( f, DSROLEP_SERVICE_BOOTSTART ) ) return SERVICE_BOOT_START;
    if ( FLAG_ON( f, DSROLEP_SERVICE_SYSTEM_START ) ) return SERVICE_SYSTEM_START;
    if ( FLAG_ON( f, DSROLEP_SERVICE_AUTOSTART ) ) return SERVICE_AUTO_START;
    if ( FLAG_ON( f, DSROLEP_SERVICE_DEMANDSTART ) ) return SERVICE_DEMAND_START;
    if ( FLAG_ON( f, DSROLEP_SERVICE_DISABLED ) ) return SERVICE_DISABLED;
    
    // No flag, no change
    return SERVICE_NO_CHANGE;
}

WCHAR* DsRolepFlagsToString(
    IN DWORD f
    )
{
    if ( FLAG_ON( f, DSROLEP_SERVICE_BOOTSTART ) ) return L"SERVICE_BOOT_START";
    if ( FLAG_ON( f, DSROLEP_SERVICE_SYSTEM_START ) ) return L"SERVICE_SYSTEM_START";
    if ( FLAG_ON( f, DSROLEP_SERVICE_AUTOSTART ) ) return L"SERVICE_AUTO_START";
    if ( FLAG_ON( f, DSROLEP_SERVICE_DEMANDSTART ) ) return L"SERVICE_DEMAND_START";
    if ( FLAG_ON( f, DSROLEP_SERVICE_DISABLED ) ) return L"SERVICE_DISABLED";
    
    // No flag, no change
    return L"SERVICE_NO_CHANGE";
}


DWORD DsRolepServiceFlagsToDsRolepFlags(
    IN DWORD f
    )
{

    if ( f == SERVICE_BOOT_START ) return DSROLEP_SERVICE_BOOTSTART;
    if ( f == SERVICE_SYSTEM_START ) return DSROLEP_SERVICE_SYSTEM_START;
    if ( f == SERVICE_AUTO_START ) return DSROLEP_SERVICE_AUTOSTART;
    if ( f == SERVICE_DEMAND_START ) return DSROLEP_SERVICE_DEMANDSTART;
    if ( f == SERVICE_DISABLED ) return DSROLEP_SERVICE_DISABLED;
    if ( f == SERVICE_NO_CHANGE ) return 0;

    ASSERT( FALSE && !"Unknown service start type" );

    // This is safe
    return DSROLEP_SERVICE_DEMANDSTART;
}

//
// Exported (from this file) functions
//
DWORD
DsRolepConfigureDomainControllerServices(
    IN DWORD Flags
    )

/*++

Routine Description

Parameters

Return Values

    ERROR_SUCCESS if no errors; a system service error otherwise.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    //
    // Configure the registry for RASSFM service
    //
    if ( FLAG_ON( Flags, DSROLEP_SERVICES_ON ) ) {

        WinError = DsRolepSetRegStringValue(DSROLEP_MSV10_PATH,
                                              DSROLEP_RASSFM_NAME,
                                              DSROLEP_RASSFM_VALUE);

        //
        // This is not fatal -- log message
        //

        WinError = ERROR_SUCCESS;
        
    }

    //
    // Configure the intrinsic nt services
    //
    WinError = DsRolepConfigureGenericServices( DsRoleDomainControllerServices,
                                                DsRoleDomainControllerServicesCount,
                                                Flags );

                                         

    //
    // No need to undo RASSFM change
    //

    return WinError;
}

DWORD
DsRolepConfigureDomainServices(
    DWORD Flags
    )
/*++

Routine Description

Parameters

Return Values

    ERROR_SUCCESS if no errors; a system service error otherwise.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    //
    // Configure the intrinsic nt services
    //
    WinError = DsRolepConfigureGenericServices( DsRoleDomainServices,
                                                DsRoleDomainServicesCount,
                                                Flags );

    return WinError;
}


DWORD
DsRolepStartNetlogon(
    VOID
    )
{
    DWORD WinError = ERROR_SUCCESS;

    WinError  = DsRolepConfigureService( SERVICE_NETLOGON,
                                         DSROLEP_SERVICE_START,
                                         NULL,
                                         NULL );
    return WinError;
}

DWORD
DsRolepStopNetlogon(
    OUT BOOLEAN *WasRunning
    )
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG PreviousSettings = 0;

    WinError  = DsRolepConfigureService( SERVICE_NETLOGON,
                                         DSROLEP_SERVICE_STOP,
                                         NULL,
                                         &PreviousSettings );

    if (  (ERROR_SUCCESS == WinError) 
       && WasRunning ) {

        *WasRunning = (BOOLEAN) FLAG_ON( PreviousSettings, DSROLEP_SERVICE_START );
                       
    }

    return WinError;
}

//
// Local functions
//

DWORD
DsRolepSetRegStringValue(LPWSTR Path,
                         LPWSTR ValueName,
                         LPWSTR Value)
/*++

Routine Description

    This routine sets Value as a REG_SZ value on the value ValueName
    on the key Path

Parameters

    Path,  a registry path relative to HKLM

    ValueName, a null-terminated string

    Value, a null terminated string

Return Values

    ERROR_SUCCESS if no errors; a system service error otherwise.

--*/
{
    DWORD WinErroror = ERROR_INVALID_PARAMETER, WinErroror2;
    HKEY  hKey;

    ASSERT(Path);
    ASSERT(ValueName);
    ASSERT(Value);

    if (Path && ValueName && Value) {

        WinErroror = RegCreateKey(HKEY_LOCAL_MACHINE,
                                  Path,
                                  &hKey);

        if (ERROR_SUCCESS == WinErroror) {

            WinErroror = RegSetValueEx(hKey,
                                       ValueName,
                                       0, // reserved
                                       REG_SZ,
                                       (VOID*)Value,
                                       (wcslen(Value)+1)*sizeof(WCHAR));


            WinErroror2 = RegCloseKey(hKey);
            ASSERT(ERROR_SUCCESS == WinErroror2);

        }

    }

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolepSetRegStringValue on %ws\\%ws to %ws returned %lu\n",
                      Path,
                      ValueName,
                      Value,
                      WinErroror ));


    return WinErroror;

}

DWORD
DsRolepConfigureGenericServices(
    IN DSROLEP_SERVICE_ITEM *ServiceArray,
    IN ULONG                 ServiceCount,
    IN ULONG                 Flags
    )
/*++

Routine Description:

Arguments:

Returns:

--*/
{

    DWORD WinError = ERROR_SUCCESS;
    ULONG ServicesInstalled;



    //
    // Configure each service
    //
    for ( ServicesInstalled = 0;
            ServicesInstalled < ServiceCount && (WinError == ERROR_SUCCESS);
                ServicesInstalled++ ) {


        ULONG *RevertSettings = &ServiceArray[ServicesInstalled].RevertSettings;
        ULONG Operation = 0;

        //
        // Check for cancel before contining if we are not reverting
        //
        if ( !FLAG_ON( Flags, DSROLEP_SERVICES_REVERT ) ) {
            
            DSROLEP_CHECK_FOR_CANCEL( WinError );
            if ( ERROR_SUCCESS != WinError ) {
                break;
            }
        }

        //
        // Determine the operation flag
        //
        if ( FLAG_ON( Flags, DSROLEP_SERVICES_ON ) ) {

            Operation |= ServiceArray[ServicesInstalled].ConfigureOn;
            *RevertSettings = 0;

        } else if ( FLAG_ON( Flags, DSROLEP_SERVICES_OFF ) ) {

            Operation |= ServiceArray[ServicesInstalled].ConfigureOff;
            *RevertSettings = 0;

        } else if ( FLAG_ON( Flags, DSROLEP_SERVICES_REVERT ) ) {

            Operation |= ServiceArray[ServicesInstalled].RevertSettings;

            //
            // N.B. We don't want to set the revert settings when we are
            // reverting!
            //
            RevertSettings = NULL;

        } 
        
        if (Operation == DSROLEP_SERVICE_NOOP) {

            continue;

        }
        
        if ( FLAG_ON( Flags, DSROLEP_SERVICES_START ) ) {

            Operation |= DSROLEP_SERVICE_START;

        } else if ( FLAG_ON( Flags, DSROLEP_SERVICES_STOP ) ) {
            
            Operation |= DSROLEP_SERVICE_STOP;
        }

        // If this is a forced demotion we don't want to fail on errors
        // configuring the services
        if ( FLAG_ON( Flags, DSROLEP_SERVICES_IGNORE_ERRORS ) ) {

            Operation |= DSROLEP_SERVICE_IGNORE_ERRORS;

        }

        //
        // Currently we don't handle more than one dependency
        //
        ASSERT( NULL == ServiceArray[ ServicesInstalled ].Dependencies[1] );

        // We should do something
        ASSERT( 0 != Operation );

        //
        // Configure the service
        //
        WinError = DsRolepConfigureService( ServiceArray[ ServicesInstalled ].ServiceName,
                                            Operation,
                                            ServiceArray[ ServicesInstalled ].Dependencies[0],
                                            RevertSettings
                                            );

    }

    //
    // If there is an error, undo the work already done
    //
    if (  ERROR_SUCCESS != WinError 
      && !FLAG_ON( Flags, DSROLEP_SERVICES_REVERT )  ) {

        DWORD WinError2;
        ULONG i;

        for ( i = 0; i < ServicesInstalled; i++ ) {
    
            //
            // Configure the service
            //
            WinError2 = DsRolepConfigureService( ServiceArray[ i ].ServiceName,
                                                 ServiceArray[ServicesInstalled].RevertSettings,
                                                 ServiceArray[ i ].Dependencies[0],
                                                 NULL  // we don't need to know revert settings
                                                 );
    
            //
            // This should succeed, though since this is the undo path it is
            // not critical
            //
            ASSERT( ERROR_SUCCESS == WinError2 );
        }
    }


    return WinError;
}

DWORD
DsRolepConfigureService(
    IN LPWSTR ServiceName,
    IN ULONG ServiceOptions,
    IN LPWSTR  Dependency OPTIONAL,
    OUT ULONG *RevertServiceOptions OPTIONAL
    )
/*++

Routine Description:

    Starts, stops, or modifies the configuration of a service.

Arguments:

    ServiceName - Service to configure

    ServiceOptions - Stop, start, dependency add/remove, or configure

    Dependency - a null terminated string identify a dependency

    ServiceWasRunning - Optional.  When stopping a service, the previous service state
                        is returned here

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad service option was given

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    SC_HANDLE hScMgr = NULL, hSvc = NULL;
    ULONG OpenMode = 0;
    LPENUM_SERVICE_STATUS DependentServices = NULL;
    ULONG DependSvcSize = 0, DependSvcCount = 0, i;
    LPWSTR NewDependencyList = NULL;
    DWORD NewStartType = SERVICE_NO_CHANGE;
    ULONG UpdateMsgId = DSROLEEVT_CONFIGURE_SERVICE;

    //
    // If the service doesn't stop within two minutes minute, continue on
    //
    ULONG AccumulatedSleepTime;
    ULONG MaxSleepTime = 120000;


    BOOLEAN ConfigChangeRequired = FALSE;
    BOOLEAN RunChangeRequired = FALSE;

    DWORD   PreviousStartType = SERVICE_NO_CHANGE;
    BOOLEAN fServiceWasRunning = FALSE;


    //
    // Parameter checks
    //
    ASSERT( ! (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_ADD )
           && (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_REMOVE ))) );

    ASSERT( ! (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_AUTOSTART )
           && (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DISABLED ))) );

    ASSERT( ! (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_START )
           && (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP ))) );

    //
    // Do some logic to determine the open mode of the service
    //
    NewStartType = DsRolepFlagsToServiceFlags( ServiceOptions );

    if ( (SERVICE_NO_CHANGE != NewStartType)                ||
        FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_ADD )  ||
        FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_REMOVE ))
    {
        ConfigChangeRequired = TRUE;
    }

    if( ConfigChangeRequired ) {

        OpenMode |= SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG;
    }

    if( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP ) ) {

        OpenMode |= SERVICE_STOP | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_QUERY_STATUS;
        UpdateMsgId = DSROLEEVT_STOP_SERVICE;
        RunChangeRequired = TRUE;
    }

    if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP_ISM ) ) {

        OpenMode |= SERVICE_USER_DEFINED_CONTROL;

    }

    if( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_START ) ) {

        OpenMode |= SERVICE_START | SERVICE_QUERY_STATUS;
        UpdateMsgId = DSROLEEVT_START_SERVICE;
        RunChangeRequired = TRUE;
    }
    
    //
    // Open the service control manager
    //
    hScMgr = OpenSCManager( NULL,
                            SERVICES_ACTIVE_DATABASE,
                            GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

    if ( hScMgr == NULL ) {

        WinError = GetLastError();
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Can't contact the service controller manager (%lu)\n",
                                                WinError )) );
        goto Cleanup;

    }

    //
    // Open the service
    //
    hSvc = OpenService( hScMgr,
                        ServiceName,
                        OpenMode );

    if ( hSvc == NULL ) {

        WinError = GetLastError();
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "OpenService on %ws failed with %lu\n",
                                                ServiceName,
                                                WinError )) );
        goto Cleanup;
    } 

    
    DSROLEP_CURRENT_OP1( UpdateMsgId, ServiceName );

    //
    // Determine if the service is running if we are going to be stopping or
    // starting it
    //
    if( RunChangeRequired ) {

        SERVICE_STATUS SvcStatus;

        if( QueryServiceStatus( hSvc,&SvcStatus ) == FALSE ) {
    
            WinError = GetLastError();
            goto Cleanup;
        }
    
        if ( SvcStatus.dwCurrentState == SERVICE_RUNNING ) {
    
            fServiceWasRunning = TRUE;
                                        
        }
    }

    //
    // Determine the current start type if we are going to be changing it
    //
    if ( ConfigChangeRequired ) {

        LPQUERY_SERVICE_CONFIG ServiceConfig = NULL;
        DWORD                  Size = 0;
        BOOL                   fSuccess;

        QueryServiceConfig( hSvc,
                            ServiceConfig,
                            Size,
                            &Size );

        ASSERT( GetLastError() == ERROR_INSUFFICIENT_BUFFER );

        DSROLEP_ALLOCA( (PVOID)ServiceConfig, Size);
        if ( !ServiceConfig ) {

            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;

        }
        
        fSuccess = QueryServiceConfig( hSvc,
                                       ServiceConfig,
                                       Size,
                                      &Size );

        if ( !fSuccess ) {
            WinError = GetLastError();
            goto Cleanup;
        }

        PreviousStartType = ServiceConfig->dwStartType;
    }

    //
    // Do the config change
    //
    if ( ConfigChangeRequired ) {

        //
        // Make a new dependency list
        //
    
        if ( Dependency ) {
    
            WinError = DsRolepMakeAdjustedDependencyList( hSvc,
                                                          ServiceOptions,
                                                          Dependency,
                                                          &NewDependencyList );
    
            if ( ERROR_SUCCESS != WinError ) {
                goto Cleanup;
            }
        
        }

        //
        // Change the service with new parameters
        //
        if ( ChangeServiceConfig( hSvc,
                                  SERVICE_NO_CHANGE,
                                  NewStartType,
                                  SERVICE_NO_CHANGE,
                                  NULL,
                                  NULL,
                                  0,
                                  NewDependencyList,
                                  NULL, NULL, NULL ) == FALSE ) {
    
            WinError = GetLastError();
            DsRolepLogOnFailure( WinError,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "ChangeServiceConfig on %ws failed with %lu\n",
                                                   ServiceName,
                                                   WinError )) );

            goto Cleanup;
        }

    }

    // Stop the service.
    if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP ) || FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP_ISM ) ) {
    
        SERVICE_STATUS  SvcStatus;
    
        WinError = ERROR_SUCCESS;
    
        //
        // Enumerate all of the dependent services first
        //
        if(EnumDependentServices( hSvc,
                                  SERVICE_ACTIVE,
                                  NULL,
                                  0,
                                  &DependSvcSize,
                                  &DependSvcCount ) == FALSE ) {
    
            WinError = GetLastError();
        }
    
    
    
        if ( WinError == ERROR_MORE_DATA ) {
    
            DependentServices = RtlAllocateHeap( RtlProcessHeap(), 0, DependSvcSize );
    
            if ( DependentServices == NULL) {
    
                WinError = ERROR_OUTOFMEMORY;
    
            } else {
    
                if( EnumDependentServices( hSvc,
                                           SERVICE_ACTIVE,
                                           DependentServices,
                                           DependSvcSize,
                                           &DependSvcSize,
                                           &DependSvcCount ) == FALSE ) {
    
                    WinError = GetLastError();
    
                } else {
    
                    for ( i = 0; i < DependSvcCount; i++) {
    
                        DsRoleDebugOut(( DEB_TRACE,
                                          "Service %ws depends on %ws\n",
                                          DependentServices[i].lpServiceName,
                                          ServiceName ));
    
                        WinError = DsRolepConfigureService(
                                         DependentServices[i].lpServiceName,
                                         DSROLEP_SERVICE_STOP,
                                         NULL,
                                         NULL ); 

                        if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_IGNORE_ERRORS ) ) {

                            // We don't want to fail when the flag is set.
                            WinError = ERROR_SUCCESS;

                        } else if ( WinError != ERROR_SUCCESS ) {
    
                            break;
                        }
    
                    }
                }
    
                RtlFreeHeap( RtlProcessHeap(), 0, DependentServices );
            }
    
        }
    
    
        if ( WinError == ERROR_SUCCESS ) {
    
            if ( (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP_ISM )?
                  ControlService( hSvc,
                                  ISM_SERVICE_CONTROL_REMOVE_STOP,
                                  &SvcStatus ):
                  ControlService( hSvc,
                                  SERVICE_CONTROL_STOP,
                                  &SvcStatus )) == FALSE ) {
    
                WinError = GetLastError();
    
                //
                // It's not an error if the service wasn't running
                //
                if ( WinError == ERROR_SERVICE_NOT_ACTIVE ) {
    
                    WinError = ERROR_SUCCESS;
                }
    
            } else {
    
                WinError = ERROR_SUCCESS;
    
                //
                // Wait for the service to stop
                //
                AccumulatedSleepTime = 0;
                while ( TRUE ) {
    
                    if( QueryServiceStatus( hSvc,&SvcStatus ) == FALSE ) {
    
                        WinError = GetLastError();
                    }
    
                    if ( WinError != ERROR_SUCCESS ||
                                        SvcStatus.dwCurrentState == SERVICE_STOPPED) {
    
                        break;
                    
                    }

                    if ( AccumulatedSleepTime < MaxSleepTime ) {

                        if ( 0 == SvcStatus.dwWaitHint ) {

                            //if we are told not to wait we will
                            //wait for 5 seconds anyway.
                            //bug # 221482

                            Sleep ( 5000 );
                            AccumulatedSleepTime += 5000;

                        } else  {

                            Sleep( SvcStatus.dwWaitHint );
                            AccumulatedSleepTime += SvcStatus.dwWaitHint;

                        }

                    } else {

                        //
                        // Give up and return an error
                        //
                        WinError = WAIT_TIMEOUT;
                        break;
                    }
                }
            }
    
            DsRoleDebugOut(( DEB_TRACE, "StopService on %ws returned %lu\n",
                              ServiceName, WinError ));
    
        }
    
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "StopService on %ws failed with %lu\n",
                                               ServiceName,
                                               WinError )) );

        if ( ERROR_SUCCESS != WinError ) {
            goto Cleanup;
        }
    
    }

    if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_START ) ) {

        //
        // See about changing its state
        //
        if ( StartService( hSvc, 0, NULL ) == FALSE ) {

            WinError = GetLastError();

        } else {

            WinError = ERROR_SUCCESS;
        }

        DsRoleDebugOut(( DEB_TRACE, "StartService on %ws returned %lu\n",
                          ServiceName, WinError ));
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "StartService on %ws failed with %lu\n",
                                               ServiceName,
                                               WinError )) );

        if ( ERROR_SUCCESS != WinError ) {
            goto Cleanup;
        }

    }

    //
    // Success! By the time we are here, we have completed the task asked
    // of us, so set the Revert parameter
    //
    ASSERT( ERROR_SUCCESS == WinError );
    if ( RevertServiceOptions ) {

        *RevertServiceOptions = 0;

        if( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP ) 
         && fServiceWasRunning   ) {

            *RevertServiceOptions |= DSROLEP_SERVICE_START;
        }
    
        if(  FLAG_ON( ServiceOptions, DSROLEP_SERVICE_START ) 
          && !fServiceWasRunning ) {

            *RevertServiceOptions |= DSROLEP_SERVICE_STOP;
        }

        if ( PreviousStartType != SERVICE_NO_CHANGE ) {
            *RevertServiceOptions |= DsRolepServiceFlagsToDsRolepFlags( PreviousStartType );
        }

        if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_ADD ) ) {
            *RevertServiceOptions |= DSROLEP_SERVICE_DEP_REMOVE;
        }

        if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_REMOVE ) ) {
            *RevertServiceOptions |= DSROLEP_SERVICE_DEP_ADD;
        }
    }

Cleanup:

    if ( hSvc ) {

        CloseServiceHandle( hSvc );

    }

    if ( hScMgr ) {
        
        CloseServiceHandle( hScMgr );

    }

    if ( NewDependencyList ) {

        RtlFreeHeap(RtlProcessHeap(), 0, NewDependencyList);
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Configuring service %ws to %lu returned %lu\n",
                      ServiceName,
                      ServiceOptions,
                      WinError ));

    if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_IGNORE_ERRORS ) ) {

        if ( WinError != ERROR_SUCCESS ) {
        
            //log an event that states that the new start type
            // couldn't be set for the service.
            SpmpReportEvent( TRUE,
                             EVENTLOG_WARNING_TYPE,
                             DSROLERES_FAILED_CONFIGURE_SERVICE_STARTTYPE,
                             0,
                             sizeof( ULONG ),
                             &WinError,
                             2,
                             DsRolepFlagsToString(ServiceOptions),
                             ServiceName);

            DSROLEP_SET_NON_FATAL_ERROR( WinError );

            if ( Dependency ) {

                //log an event that states that the new start type
                // couldn't be set for the service.
                SpmpReportEvent( TRUE,
                                 EVENTLOG_WARNING_TYPE,
                                 DSROLERES_FAILED_CONFIGURE_SERVICE_DEPENDENCY,
                                 0,
                                 sizeof( ULONG ),
                                 &WinError,
                                 2,
                                 ServiceName,
                                 Dependency);

            }

        }

        //We don't fail promotion because of errors configuring services
        //when this flag is set.
        WinError = ERROR_SUCCESS;

    }

    DSROLEP_FAIL1( WinError, DSROLERES_SERVICE_CONFIGURE, ServiceName );

    return( WinError );
}

DWORD
DsRolepMakeAdjustedDependencyList(
    IN HANDLE hSvc,
    IN DWORD  ServiceOptions,
    IN LPWSTR Dependency,
    OUT LPWSTR *NewDependencyList
    )
/*++

Routine Description

    This function adds or removes Dependency from the service referred to
    by hSvc.

Parameters

    hSvc, a handle to an open service

    ServiceOptions,  either DSROLEP_SERVICE_DEP_REMOVE or DSROLEP_SERVICE_DEP_ADD

    Dependency, null terminated string

    NewDependencyList, a block list of strings to freed by the caller

Return Values

    ERROR_SUCCESS if no errors; a system service error otherwise.

--*/
{
    DWORD WinError = STATUS_SUCCESS;
    BOOLEAN fDone = FALSE;

    WCHAR *CurrentDependency;
    ULONG CurrentDependencyLength;

    ULONG DependencySize;
    ULONG DependencyListSize;
    ULONG NewDependencyListSize;

    LPWSTR TempDependencyList = NULL;
    WCHAR  *CurrNewList;

    LPQUERY_SERVICE_CONFIG ServiceConfigInfo=NULL;

    //
    // Query for the existing dependencies
    //
    WinError = DsRolepGetServiceConfig(NULL,
                                       NULL,
                                       hSvc,
                                       &ServiceConfigInfo);

    if (ERROR_SUCCESS != WinError) {
        goto Cleanup;
    }


    if (FLAG_ON(ServiceOptions, DSROLEP_SERVICE_DEP_ADD)) {


        // Get the size of the dependency
        DependencySize = (wcslen(Dependency) + 1)*sizeof(WCHAR); // for NULL

        // Get the size of the dependency list
        DependencyListSize = 0;
        CurrentDependency = ServiceConfigInfo->lpDependencies;
        while (CurrentDependency && *CurrentDependency != L'\0') {

            // Get the current list size
            if (!_wcsicmp(CurrentDependency, Dependency)) {
                //
                // Dependency is already here
                //
                break;
                fDone = TRUE;
            }

            CurrentDependencyLength = wcslen(CurrentDependency) + 1; // for NULL
            DependencyListSize += CurrentDependencyLength * sizeof(WCHAR);

            CurrentDependency += CurrentDependencyLength;

        }

        if ( fDone ) {

            WinError = ERROR_SUCCESS;
            goto Cleanup;
        }


        // Calculate the size of the new dependency list
        NewDependencyListSize = DependencyListSize +
                                DependencySize     +
                                sizeof(WCHAR);  // the whole string of strings
                                                // NULL terminated
        //
        // Now allocate a space to hold the new dependency array
        //
        TempDependencyList = RtlAllocateHeap(RtlProcessHeap(),
                                             0,
                                             NewDependencyListSize);
        if (!TempDependencyList) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlZeroMemory(TempDependencyList, NewDependencyListSize);
        RtlCopyMemory(TempDependencyList,
                      ServiceConfigInfo->lpDependencies,
                      DependencyListSize);
        RtlCopyMemory(&TempDependencyList[DependencyListSize/sizeof(WCHAR)],
                      Dependency,
                      DependencySize);

    } else if (FLAG_ON(ServiceOptions, DSROLEP_SERVICE_DEP_REMOVE)) {

        // Get the size of the dependency
        DependencySize = (wcslen(Dependency) + 1)*sizeof(WCHAR); // for NULL

        // Get the size of the dependency list
        DependencyListSize = 0;
        CurrentDependency = ServiceConfigInfo->lpDependencies;
        while (CurrentDependency && *CurrentDependency != L'\0') {

            CurrentDependencyLength = wcslen(CurrentDependency) + 1; // for NULL
            DependencyListSize += CurrentDependencyLength * sizeof(WCHAR);

            CurrentDependency += CurrentDependencyLength;

        }

        // Calculate the size of the new dependency list
        NewDependencyListSize = DependencyListSize +
                                sizeof(WCHAR);  // the whole string of strings
                                                // NULL terminated
        //
        // Now allocate a space to hold the new dependency array
        // This is overkill, but not much.
        //
        TempDependencyList = RtlAllocateHeap(RtlProcessHeap(),
                                             0,
                                             NewDependencyListSize);
        if (!TempDependencyList) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlZeroMemory(TempDependencyList, NewDependencyListSize);

        CurrentDependency = ServiceConfigInfo->lpDependencies;
        CurrNewList = TempDependencyList;

        while (CurrentDependency && *CurrentDependency != L'\0') {

            CurrentDependencyLength = wcslen(CurrentDependency) + 1; // for NULL

            // Get the current list size
            if (!_wcsicmp(CurrentDependency, Dependency)) {
                //
                // This is the one - don't copy it
                //
            } else {
                wcscpy(CurrNewList, CurrentDependency);
                CurrNewList += CurrentDependencyLength;
            }

            CurrentDependency += CurrentDependencyLength;
        }

    }

Cleanup:

    if (WinError != ERROR_SUCCESS && TempDependencyList) {
        RtlFreeHeap(RtlProcessHeap(), 0, TempDependencyList);
        *NewDependencyList = NULL;
    } else {
        *NewDependencyList = TempDependencyList;
    }

    if (ServiceConfigInfo) {

        RtlFreeHeap(RtlProcessHeap(), 0, ServiceConfigInfo);
    }

    return( WinError );
}


DWORD
DsRolepGetServiceConfig(
    IN SC_HANDLE hScMgr,
    IN LPWSTR ServiceName,
    IN SC_HANDLE ServiceHandle,
    IN LPQUERY_SERVICE_CONFIG *ServiceConfig
    )
/*++

Routine Description:

Parameters:

Return Values:

    ERROR_SUCCESS
    ERROR_NOT_ENOUGH_MEMORY

--*/
{
    DWORD Win32Error;
    SC_HANDLE hService;
    ULONG SizeNeeded;

#if DBG
    if (!ServiceHandle) {
        ASSERT(ServiceName);
        ASSERT(hScMgr);
    }
#endif

    if (!ServiceHandle) {

        hService = OpenService( hScMgr,
                                ServiceName,
                                SERVICE_QUERY_CONFIG );
    } else {

        hService = ServiceHandle;

    }

    if (hService) {

        SizeNeeded = 0;
        Win32Error = ERROR_SUCCESS;
        if (!QueryServiceConfig(hService,
                                NULL,
                                0,
                                &SizeNeeded)) {

            Win32Error = GetLastError();

        }
        ASSERT(Win32Error == ERROR_INSUFFICIENT_BUFFER);
        ASSERT( SizeNeeded > 0 );

        *ServiceConfig = RtlAllocateHeap(RtlProcessHeap(),
                                         0,
                                         SizeNeeded);
        if (*ServiceConfig) {

            Win32Error = ERROR_SUCCESS;
            if (!QueryServiceConfig(hService,
                                    *ServiceConfig,
                                    SizeNeeded,
                                    &SizeNeeded)) {

                Win32Error = GetLastError();
            }

        } else {

            Win32Error = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (!ServiceHandle) {
            CloseServiceHandle(hService);
        }

    } else {

        Win32Error = GetLastError();

    }

    DsRolepLogOnFailure( Win32Error,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "DsRolepGetServiceConfig on %ws failed with %lu\n",
                                            ServiceName,
                                            Win32Error )) );

    return Win32Error;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\secure.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    secure.h

Abstract:

    Security related routines

Author:

    Colin Brace   (ColinBr)

Environment:

    User Mode

Revision History:

--*/
#ifndef __SECURE_H__
#define __SECURE_H__

BOOLEAN
DsRolepCreateInterfaceSDs(
    VOID
    );

DWORD
DsRolepCheckPromoteAccess(
    BOOLEAN PerformAudit
    );

DWORD
DsRolepCheckDemoteAccess(
    BOOLEAN PerformAudit
    );

DWORD
DsRolepGetImpersonationToken(
    OUT HANDLE *ImpersonationToken
    );

DWORD
DsRolepCheckCallDsRoleInterfaceAccess(
    VOID
    );

#endif // __SECURE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\secure.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    secure.c

Abstract:

    Security related routines

Author:

    Colin Brace   (ColinBr)

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>

#include "secure.h"
#include <ntsam.h>
#include <samrpc.h>
#include <samisrv.h> 

//
// Data global to this module only
//
SECURITY_DESCRIPTOR DsRolepPromoteSD;
SECURITY_DESCRIPTOR DsRolepDemoteSD;
SECURITY_DESCRIPTOR DsRolepCallDsRoleInterfaceSD;


//
// Unlocalized string descriptors for promotion/demotion audits to use
// when unable to load localized resources for some reason.
//
#define DSROLE_AUDIT_PROMOTE_DESC    L"Domain Controller Promotion"
#define DSROLE_AUDIT_DEMOTE_DESC     L"Domain Controller Demotion"
#define DSROLE_AUDIT_INTERFACE_DESC  L"DsRole Interface"


//
// Used to audit anyone attempting server role change operations
//
SID WORLD_SID = {SID_REVISION,
                 1,
                 SECURITY_WORLD_SID_AUTHORITY,
                 SECURITY_WORLD_RID};


//                                         
// DsRole related access masks
//
#define DSROLE_ROLE_CHANGE_ACCESS     0x00000001

#define DSROLE_ALL_ACCESS            (STANDARD_RIGHTS_REQUIRED    | \
                                      DSROLE_ROLE_CHANGE_ACCESS )

GENERIC_MAPPING DsRolepInfoMapping = 
{
    STANDARD_RIGHTS_READ,                  // Generic read
    STANDARD_RIGHTS_WRITE,                 // Generic write
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    DSROLE_ALL_ACCESS                      // Generic all
};

//
// Function definitions
//

BOOLEAN
DsRolepMakeSecurityDescriptor(
    PSECURITY_DESCRIPTOR psd,
    PSID psid,
    PACL pacl,
    PACL psacl
    )
/*++

Routine Description:

    This routine creates the Security Descriptor    

Arguments:

    PSECURITY_DESCRIPTOR psd - a pointer to a SECURITY_DESCRIPTOR which will be constucted
    
    PSID psid - The Sid for the SECURITY_DESCRIPTOR
    
    PACL pacl - The Acl to place on the security Descriptor

Returns:

    TRUE if successful; FALSE otherwise         
    

--*/   
{
    BOOLEAN fSuccess = TRUE;

    if ( !InitializeSecurityDescriptor( psd,
                                        SECURITY_DESCRIPTOR_REVISION ) ) {
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorOwner( psd,
                                      psid,
                                      FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorGroup( psd,
                                      psid,
                                      FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorDacl( psd,
                                     TRUE,  // DACL is present
                                     pacl,
                                     FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorSacl( psd,
                                     psacl != NULL ? TRUE : FALSE,  
                                     psacl,
                                     FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }

    Cleanup:

    return fSuccess;

}

BOOLEAN
DsRolepCreateInterfaceSDs(
    VOID
    )
/*++

Routine Description:

    This routine creates the in memory access control lists that 
    are used to perform security checks on callers of the DsRoler
    API's.
    
    The model is as follows:
    
    Promote: the caller must have the builtin admin SID
    
    Demote: the caller must have the builtin admin SID
    
    CalltheDsRoleInterface: the caller must have the builtin admin SID
    

Arguments:

    None.          

Returns:

    TRUE if successful; FALSE otherwise         
    

--*/
{
    NTSTATUS Status;
    BOOLEAN  fSuccess = TRUE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG AclLength = 0;
    ULONG SaclLength = 0;
    PSID BuiltinAdminsSid = NULL;
    PSID *AllowedSids [] = 
    {
        &BuiltinAdminsSid
    };
    ULONG cAllowedSids = sizeof(AllowedSids) / sizeof(AllowedSids[0]);
    ULONG i;
    PACL DsRolepPromoteAcl = NULL;
    PACL DsRolepDemoteAcl = NULL;
    PACL DsRolepCallDsRoleInterfaceAcl = NULL;
    PACL DsRolepSacl = NULL;


    //
    // Build the builtin administrators sid
    //
    Status = RtlAllocateAndInitializeSid(
             &NtAuthority,
             2,
             SECURITY_BUILTIN_DOMAIN_RID,
             DOMAIN_ALIAS_RID_ADMINS,
             0, 0, 0, 0, 0, 0,
             &BuiltinAdminsSid
             );
    if ( !NT_SUCCESS( Status ) ) {
        fSuccess = FALSE;
        goto Cleanup;
    }
    
    //
    // Determine the required size of the SACL
    //
    SaclLength = sizeof( ACL ) + 
                 sizeof( SYSTEM_AUDIT_ACE ) +
                 GetLengthSid( &WORLD_SID );

    //
    // Make the SACL for auditing role change operation attempts
    //
    DsRolepSacl = LocalAlloc( 0, SaclLength );
    if ( !DsRolepSacl ) {
        fSuccess = FALSE;
        goto Cleanup;
    }
    
    if ( !InitializeAcl( DsRolepSacl, SaclLength, ACL_REVISION ) ) {
        fSuccess = FALSE;
        goto Cleanup;
    }
    
    Status = AddAuditAccessAce(
                 DsRolepSacl,
                 ACL_REVISION,
                 DSROLE_ROLE_CHANGE_ACCESS,
                 &WORLD_SID,
                 TRUE,
                 TRUE
                 );

    if ( !NT_SUCCESS(Status) ) {
        fSuccess = FALSE;
        goto Cleanup;
    }                
    
    //
    // Calculate how much space we'll need for the ACL
    //
    AclLength = sizeof( ACL );
    for ( i = 0; i < cAllowedSids; i++ ) {

        AclLength += (sizeof( ACCESS_ALLOWED_ACE ) 
                    - sizeof(DWORD) 
                    + GetLengthSid((*AllowedSids[i])) );
    }
    
    DsRolepPromoteAcl = LocalAlloc( 0, AclLength );
    if ( !DsRolepPromoteAcl ) {
        fSuccess = FALSE;
        goto Cleanup;
    }

    if ( !InitializeAcl( DsRolepPromoteAcl, AclLength, ACL_REVISION ) ) {
        fSuccess = FALSE;
        goto Cleanup;
    }

    for ( i = 0; i < cAllowedSids; i++ ) {

        if ( !AddAccessAllowedAce( DsRolepPromoteAcl,
                                   ACL_REVISION,
                                   DSROLE_ALL_ACCESS,
                                   *(AllowedSids[i]) ) ) {
            fSuccess = FALSE;
            goto Cleanup;
        }
        
    }

    //
    // Now make the security descriptor
    //
    fSuccess = DsRolepMakeSecurityDescriptor(&DsRolepPromoteSD,
                                             BuiltinAdminsSid,
                                             DsRolepPromoteAcl,
                                             DsRolepSacl);
    if (!fSuccess) {

        goto Cleanup;

    }
    
    //
    // Make the demote access check the same
    //
    DsRolepDemoteAcl = LocalAlloc( 0, AclLength );
    if ( !DsRolepDemoteAcl ) {
        fSuccess = FALSE;
        goto Cleanup;
    }
    RtlCopyMemory( DsRolepDemoteAcl, DsRolepPromoteAcl, AclLength );

    //
    // Now make the security descriptor
    //
    fSuccess = DsRolepMakeSecurityDescriptor(&DsRolepDemoteSD,
                                             BuiltinAdminsSid,
                                             DsRolepDemoteAcl,
                                             DsRolepSacl);
    if (!fSuccess) {

        goto Cleanup;

    }
    
    //
    // Make the Call interface access check the same
    //
    DsRolepCallDsRoleInterfaceAcl = LocalAlloc( 0, AclLength );
    if ( !DsRolepCallDsRoleInterfaceAcl ) {
        fSuccess = FALSE;
        goto Cleanup;
    }
    RtlCopyMemory( DsRolepCallDsRoleInterfaceAcl, DsRolepPromoteAcl, AclLength );

    //
    // Now make the security descriptor
    //
    fSuccess = DsRolepMakeSecurityDescriptor(&DsRolepCallDsRoleInterfaceSD,
                                             BuiltinAdminsSid,
                                             DsRolepCallDsRoleInterfaceAcl,
                                             NULL);
    if (!fSuccess) {

        goto Cleanup;

    }
    

Cleanup:

    if ( !fSuccess ) {

        for ( i = 0; i < cAllowedSids; i++ ) {
            if ( *(AllowedSids[i]) ) {
                RtlFreeHeap( RtlProcessHeap(), 0, *(AllowedSids[i]) );
            }
        }
        if ( DsRolepPromoteAcl ) {
            LocalFree( DsRolepPromoteAcl );
        }
        if ( DsRolepDemoteAcl ) {
            LocalFree( DsRolepDemoteAcl );
        }
        if ( DsRolepCallDsRoleInterfaceAcl ) {
            LocalFree( DsRolepCallDsRoleInterfaceAcl );
        }
        if ( DsRolepSacl ) {
            LocalFree( DsRolepSacl );
        }     
    }

    return fSuccess;
}


DWORD
DsRolepCheckClientAccess(
    PSECURITY_DESCRIPTOR pSD,
    DWORD                DesiredAccess,
    BOOLEAN              PerformAudit
    )
/*++

Routine Description:

    This routine grabs a copy of the client's token and then performs
    an access to make the client has the privlege found in pSD

Arguments:

    pSD: a valid security descriptor
    
    DesiredAccess: the access mask the client is asking for
    
    PerformAudit: Indicates if system object access audits should occur.  If 
                  TRUE then DnsDomainName must point to a null terminated 
                  string.

Returns:

    ERROR_SUCCESS, ERROR_ACCESS_DENIED, or system error

--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    BOOL   fStatus = FALSE;
    BOOL   fAccessAllowed = FALSE;
    HANDLE ClientToken = 0;
    DWORD  AccessGranted = 0;
    BYTE   Buffer[500];
    PRIVILEGE_SET *PrivilegeSet = (PRIVILEGE_SET*)Buffer;
    DWORD         PrivilegeSetSize = sizeof(Buffer);
    BOOL fGenerateOnClose = FALSE;
    RPC_STATUS rpcStatus = RPC_S_OK;
    DWORD MessageId;
    PWSTR ObjectNameString = NULL;
    PWSTR ObjectTypeString = NULL;
    ULONG  len = 0;
                                  
    WinError = DsRolepGetImpersonationToken( &ClientToken );

    if ( ERROR_SUCCESS == WinError ) {

        //
        // For promotion/demote we must perform an object access audit
        //
        if (PerformAudit) {
                        
            //
            // Load the ObjectName string
            //
            WinError = DsRolepFormatOperationString(
                           DSROLEEVT_AUDIT_INTERFACE_DESC,
                           &ObjectTypeString
                           );

            if ( ERROR_SUCCESS != WinError ) {
                //
                // Fallback to an unlocalized string on error.
                //
                ObjectTypeString = DSROLE_AUDIT_INTERFACE_DESC;
            
            } else {
                //
                // Strip the \r\n DsRolepFormatOperationString adds.
                //
                ObjectTypeString[wcslen(ObjectTypeString) -2] = '\0';    
            }
            
            //
            // Load the ObjectType string for this operation
            //
            MessageId = (pSD == &DsRolepPromoteSD) ? 
                            DSROLEEVT_AUDIT_PROMOTE_DESC :
                            DSROLEEVT_AUDIT_DEMOTE_DESC; 
            
            WinError = DsRolepFormatOperationString(
                           MessageId,
                           &ObjectNameString
                           );

            if ( ERROR_SUCCESS != WinError ) {
                //
                // Fallback to an unlocalized string on error.
                //
                ObjectNameString = (pSD == &DsRolepPromoteSD) ? 
                                        DSROLE_AUDIT_PROMOTE_DESC :
                                        DSROLE_AUDIT_DEMOTE_DESC; 
            } else {
                //
                // Strip the \r\n DsRolepFormatOperationString adds.
                //
                ObjectNameString[wcslen(ObjectNameString) -2] = '\0';    
            }     
             
            //
            // Impersonate the caller as required by AccessCheckAndAuditAlarmW
            //
            WinError = RpcImpersonateClient( 0 );

            if ( WinError == ERROR_SUCCESS ) {  
            
                fStatus = AccessCheckAndAuditAlarmW(
                              SAMP_SAM_COMPONENT_NAME,
                              NULL,
                              ObjectTypeString,                              
                              ObjectNameString,
                              pSD,
                              DesiredAccess,
                              &DsRolepInfoMapping,
                              FALSE,
                              &AccessGranted,
                              &fAccessAllowed,
                              &fGenerateOnClose );
                
                rpcStatus = RpcRevertToSelf( );
                ASSERT(!rpcStatus);  
            }
            
        } else {
                    
            fStatus = AccessCheck(  
                          pSD,
                          ClientToken,
                          DesiredAccess,
                          &DsRolepInfoMapping,
                          PrivilegeSet,
                          &PrivilegeSetSize,
                          &AccessGranted,
                          &fAccessAllowed );
        }

        if ( !fStatus ) {

            WinError = GetLastError();

        } else {

            if ( !fAccessAllowed ) {

                WinError = ERROR_ACCESS_DENIED;

            }
        }
    }

    if ( ClientToken ) {

        NtClose( ClientToken );
        
    }
    
    //
    // Free resource strings
    //
    if ( ObjectNameString ) {
        
        MIDL_user_free( ObjectNameString ); 
    }
    
    if ( ObjectTypeString ) {
        
        MIDL_user_free( ObjectTypeString ); 
    }

    return WinError;

}


DWORD
DsRolepCheckPromoteAccess(
    BOOLEAN PerformAudit
    )
{
    return DsRolepCheckClientAccess( &DsRolepPromoteSD, 
                                     DSROLE_ROLE_CHANGE_ACCESS,
                                     PerformAudit );
}

DWORD
DsRolepCheckDemoteAccess(
    BOOLEAN PerformAudit
    )
{
    return DsRolepCheckClientAccess( &DsRolepDemoteSD, 
                                     DSROLE_ROLE_CHANGE_ACCESS,
                                     PerformAudit );
}

DWORD
DsRolepCheckCallDsRoleInterfaceAccess(
    VOID
    )
{
    return DsRolepCheckClientAccess( &DsRolepCallDsRoleInterfaceSD, 
                                     DSROLE_ROLE_CHANGE_ACCESS,
                                     FALSE );
}


DWORD
DsRolepGetImpersonationToken(
    OUT HANDLE *ImpersonationToken
    )
/*++

Routine Description:

    This function will impersonate the invoker of this call and then duplicate their token

Arguments:

    ImpersonationToken - Where the duplicated token is returned

Returns:

    ERROR_SUCCESS - Success


--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttrs;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;
    HANDLE ClientToken;
    RPC_STATUS rpcStatus = RPC_S_OK;

    //
    // Impersonate the caller
    //
    Win32Err = RpcImpersonateClient( 0 );

    if ( Win32Err == ERROR_SUCCESS ) {

        Status = NtOpenThreadToken( NtCurrentThread(),
                                    TOKEN_QUERY | TOKEN_DUPLICATE,
                                    TRUE,
                                    &ClientToken );
                                 
        rpcStatus = RpcRevertToSelf( );
        ASSERT(!rpcStatus);

        if ( NT_SUCCESS( Status ) ) {

            //
            // Duplicate the token
            //
            InitializeObjectAttributes( &ObjAttrs, NULL, 0L, NULL, NULL );
            SecurityQofS.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
            SecurityQofS.ImpersonationLevel = SecurityImpersonation;
            SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
            SecurityQofS.EffectiveOnly = FALSE;
            ObjAttrs.SecurityQualityOfService = &SecurityQofS;
            Status = NtDuplicateToken( ClientToken,
                                       TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_DUPLICATE,
                                       &ObjAttrs,
                                       FALSE,
                                       TokenImpersonation,
                                       ImpersonationToken );


            NtClose( ClientToken );
        }

        if ( !NT_SUCCESS( Status ) ) {

            Win32Err = RtlNtStatusToDosError( Status );
        }

    }

    return( Win32Err );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\setpch.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    setpch.h

Abstract:

    DsSetup and configuration - precompiled includes for C Server Side

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

Revision History:

--*/

#ifndef __SETPCH_H__
#define __SETPCH_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dssetrpc.h>
#include <dsrole.h>
#include <lsapmsgs.h>
#include <lsacomp.h>
#include <ntdsetup.h>
#include <log.h>
#include <secure.h>
#include <ophandle.h>
#include <lsa.h>
#include <ds.h>

#endif // __SETPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\rpcinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rpcinit.c

Abstract:

    DSROLE - RPC Server Initialization

Author:

    Scott Birrell       (ScottBi)      April 29, 1991
    Mac McLain          (MacM)         April 14, 1997 - Copied from lsa\server

Environment:

Revision History:

--*/

#include <setpch.h>
#include <dssetp.h>
#include <dssetrpc.h>
#include "ds.h"
#include "ophandle.h"


VOID DSROLER_HANDLE_rundown(
    DSROLER_HANDLE LsaHandle
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle.

Arguments:

    None.

Return Value:

--*/

{

}



VOID 
DSROLER_IFM_HANDLE_rundown(
    DSROLER_IFM_HANDLE IfmHandle
    )
{
    BOOL fLostRace;

    fLostRace = InterlockedCompareExchange(&(DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock),
                                           TRUE, 
                                           FALSE);
    if (fLostRace ||
        (DsRolepCurrentOperationHandle.OperationState != DSROLEP_IDLE)) {
        // Not safe to try to clean up here, but we've either lost the
        // race, or dcpromo is in the middle of consuming the IFM args.
        return;
    }

    DsRolepCurrentIfmOperationHandle.fIfmSystemInfoSet = FALSE; 

    DsRolepClearIfmParams();

    DsRolepCurrentIfmOperationHandle.fIfmOpHandleLock = FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\setutl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <samisrv.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition
#include <ntdsetup.h>
#include <shlwapi.h>

#include "threadman.h"
#include "secure.h"
#include "cancel.h"

#if DBG
    DEFINE_DEBUG2(DsRole);

    DEBUG_KEY   DsRoleDebugKeys[] = {
        {DEB_ERROR,         "Error"},
        {DEB_WARN,          "Warn"},
        {DEB_TRACE,         "Trace"},
        {DEB_TRACE_DS,      "NtDs"},
        {DEB_TRACE_UPDATE,  "Update"},
        {DEB_TRACE_LOCK,    "Lock"},
        {DEB_TRACE_SERVICES,"Services"},
        {DEB_TRACE_NET,     "Net"},
        {0,                 NULL }
        };

VOID
DsRoleDebugInitialize()
{
    DsRoleInitDebug(DsRoleDebugKeys);
}

#endif // DBG


BOOL
DsRolepShutdownNotification(
    DWORD   dwCtrlType
    );


//
// Global data for this module
//
BOOLEAN GlobalOpLockHeld = FALSE;

RPC_STATUS
DsRolepIsLRPC(
    void *ctx,
    BOOL *fIsLRPC
    )
/*++

Routine Description:

    Will check to see if the call was made over LRPC or not.

Arguments:

    Context - Pointer to an RPC_IF_ID server binding handle representing the client.

Returns:

    RPC_S_OK - Success

--*/

{
    BOOL fAllowProtocol = FALSE;
    BOOL fCorrectEndpoint = FALSE;
    PWCHAR pBinding = NULL;
    PWCHAR pProtSeq = NULL;
    PWCHAR pEndPoint = NULL;
    RPC_STATUS rpcErr = RPC_S_OK;

    *fIsLRPC = FALSE;

    rpcErr = RpcBindingToStringBinding(ctx,
                                       &pBinding);
	if (rpcErr != RPC_S_OK)
    {
        goto Cleanup;
    }

    // We're only interested in the protocol sequence
    // so we can use NULL for all other parameters.

    rpcErr = RpcStringBindingParse(pBinding,
                                   NULL,
                                   &pProtSeq,
                                   NULL,
                                   &pEndPoint,
                                   NULL);
    if (rpcErr != RPC_S_OK)
    {
        goto Cleanup;
    }

    // Check that the client request
    // was made using LRPC.
    if (_wcsicmp(L"ncalrpc",(LPCTSTR)pProtSeq) == 0)
        fAllowProtocol = TRUE;

    // Check that the endpoint use was dsrole
    if (_wcsicmp(L"dsrole",(LPCTSTR)pEndPoint) == 0)
        fCorrectEndpoint = TRUE;

    if (fCorrectEndpoint && fAllowProtocol) {
        *fIsLRPC = TRUE;
    }

    Cleanup:

    if (pProtSeq)
        RpcStringFree(&pProtSeq);

    if (pBinding)
	    RpcStringFree(&pBinding);

    if (pEndPoint) {
        RpcStringFree(&pEndPoint);
    }

	return rpcErr;
}

RPC_STATUS
RPC_ENTRY
DsRolepSecurityCallback(
  IN RPC_IF_HANDLE *Interface,
  IN void *Context
)
/*++

Routine Description:

    Security callback for the DsRole APIs.  Called from LsaSrv
    DsRolerGetDcOperationProgress return init

Arguments:

    Interface - UUID and version of the interface.

    Context - Pointer to an RPC_IF_ID server binding handle representing the client.


Returns:

    RPC_S_OK - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    RPC_STATUS rpcErr = RPC_S_OK;
    BOOL  fIsLRPC = FALSE;

    //
    // Check the access of the caller
    //
    Win32Err = DsRolepCheckCallDsRoleInterfaceAccess();
    if ( ERROR_SUCCESS != Win32Err ) {

        rpcErr = RPC_S_ACCESS_DENIED;
        goto Exit;

    }

    //
    // Check to see that the call came over LRPC
    //
    rpcErr = DsRolepIsLRPC(Context,
                           &fIsLRPC);
    if ( RPC_S_OK == rpcErr ) {

        if(!fIsLRPC)
            rpcErr = RPC_S_ACCESS_DENIED;

    } else {

        goto Exit;

    }

    Exit:

    return rpcErr;

}

VOID
DsRolepRegisterDsRoleInterfaceOnServer(
    VOID
    )
/*++

Routine Description:

    Registers the DsRole interface on Server machines.

Arguments:

    VOID


Returns:

    VOID

--*/
{
    RPC_STATUS RPCError = RPC_S_OK;
    NT_PRODUCT_TYPE    NtProductType = 0;

    if ( RtlGetNtProductType(&NtProductType) ) {

        if ( NtProductLanManNt == NtProductType ||
             NtProductServer   == NtProductType )
        {

            RPCError = RpcServerRegisterIfEx( dsrole_ServerIfHandle,
                                              NULL,
                                              NULL,
                                              RPC_IF_ALLOW_SECURE_ONLY,
                                              RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                              DsRolepSecurityCallback);

            if (RPC_S_OK != RPCError) {
                DsRoleDebugOut(( DEB_ERROR,
                                 "RpcServerRegisterIfEx failed %d\n",
                                 RPCError ));
            }

            RPCError = RpcServerUseProtseqEp(
                                        L"ncalrpc",
                                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,   // max concurrent calls
                                        L"dsrole",                        // end point
                                        NULL                              // security descriptor
                                        );

            if ( RPCError != RPC_S_OK )
            {
                DsRoleDebugOut((DEB_ERROR,
                                "RpcServerUseProtseqEp failed for ncalrpc: %d\n",
                                RPCError));

            }

        }

    }

}


NTSTATUS
DsRolepInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the server portion of the DsRole APIs.  Called from LsaSrv
    DsRolerGetDcOperationProgress return init

Arguments:

    VOID


Returns:

    STATUS_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RPC_STATUS RPCError = RPC_S_OK;
    PWSTR KerbPrinc;

    //
    // Zero out global operation handle
    //
    RtlZeroMemory( &DsRolepCurrentOperationHandle, sizeof(DsRolepCurrentOperationHandle));

    //
    // Init the lock
    //
    RtlInitializeResource( &DsRolepCurrentOperationHandle.CurrentOpLock );


    //
    // Grab the lock
    //
    LockOpHandle();
    GlobalOpLockHeld = TRUE;

    DsRolepResetOperationHandleLockHeld();

    DsRoleDebugInitialize();

    RPCError = RpcServerRegisterIf( dssetup_ServerIfHandle,
                                    NULL,
                                    NULL );
    if (RPC_S_OK != RPCError) {
        DsRoleDebugOut(( DEB_ERROR,
                         "RpcServerRegisterIf failed %d\n",
                         RPCError ));
    }

    DsRolepRegisterDsRoleInterfaceOnServer();

    DsRolepInitSetupFunctions();

    //
    // Create the SD's that are used to perform access checks for DsRoler
    // callers
    //
    if ( !DsRolepCreateInterfaceSDs() ) {

        return STATUS_NO_MEMORY;

    }

    try {

        Status = RtlInitializeCriticalSection( &LogFileCriticalSection );

        } except ( 1 ) {

        Status =  STATUS_NO_MEMORY;
    }

    if(NT_SUCCESS(Status)) {
        //
        // Register our shutdown routine
        //

        if (!SetConsoleCtrlHandler(DsRolepShutdownNotification, TRUE)) {
            DsRoleDebugOut(( DEB_ERROR,
                             "SetConsoleCtrlHandler failed %d\n",
                             GetLastError() ));
        }

        if (!SetProcessShutdownParameters(480, SHUTDOWN_NORETRY)) {
            DsRoleDebugOut(( DEB_ERROR,
                             "SetProcessShutdownParameters failed %d\n",
                             GetLastError() ));
        }
    }



    return( Status );
}




NTSTATUS
DsRolepInitializePhase2(
    VOID
    )
/*++

Routine Description:

    Second phase of the promotion/demotion api initialization.  This initialization is slated
    to happen after the Lsa has finished all of it's initializations

Arguments:

    VOID


Returns:

    STATUS_SUCCESS - Success

    STATUS_UNSUCCESSFUL -- The function was called when the global lock wasn't held

--*/
{
    ULONG RpcStatus = STATUS_SUCCESS;
    PWSTR KerbPrinc;

    ASSERT( GlobalOpLockHeld );

    if ( !GlobalOpLockHeld ) {

        return( STATUS_UNSUCCESSFUL );
    }

    if ( !SetupPhase ) {

        //
        // Register the Rpc authenticated server info
        //
        RpcStatus = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_KERBEROS,
                                                 &KerbPrinc);

        if ( RpcStatus == RPC_S_OK ) {

            DsRoleDebugOut(( DEB_TRACE_DS, "Kerberos Principal name: %ws\n",
                             KerbPrinc ));

            RpcStatus = RpcServerRegisterAuthInfo(KerbPrinc,
                                                  RPC_C_AUTHN_GSS_NEGOTIATE,
                                                  NULL,
                                                  NULL);
            RpcStringFree( &KerbPrinc );

        } else {

            DsRoleDebugOut(( DEB_TRACE_DS, "RpcServerInqDefaultPrincName failed with %lu\n",
                             RpcStatus ));

            RpcStatus = RPC_S_OK;

        }

        if ( RpcStatus == RPC_S_OK) {

            RpcStatus = RpcServerRegisterAuthInfo( DSROLEP_SERVER_PRINCIPAL_NAME,
                                                   RPC_C_AUTHN_GSS_NEGOTIATE,
                                                   NULL,
                                                   NULL );

            if ( RpcStatus != RPC_S_OK ) {

                DsRoleDebugOut(( DEB_ERROR,
                                 "RpcServerRegisterAuthInfo for %ws failed with 0x%lx\n",
                                 DSROLEP_SERVER_PRINCIPAL_NAME,
                                 RpcStatus ));
                RpcStatus = RPC_S_OK;
            }

        }
    }


    //
    // Release the lock, as was opened in Initialization, phase 1
    //
    GlobalOpLockHeld = FALSE;
    RtlReleaseResource( &DsRolepCurrentOperationHandle.CurrentOpLock );

    return( RpcStatus == RPC_S_OK ? STATUS_SUCCESS : RPC_NT_UNKNOWN_AUTHZ_SERVICE );
}




DWORD
DsRolepGetMachineType(
    IN OUT PDSROLEP_MACHINE_TYPE MachineType
    )
/*++

Routine Description:

    Determines the type of machine this is being run on.

Arguments:

    MachineType - Where the machine type is being returned

Returns:

    STATUS_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    if ( LsapProductType == NtProductWinNt ) {

        *MachineType = DSROLEP_MT_CLIENT;

    } else if ( LsapProductType == NtProductServer ) {

        *MachineType = DSROLEP_MT_STANDALONE;

    } else {

        *MachineType = DSROLEP_MT_MEMBER;

    }

    return( Win32Err );
}


DWORD
DsRolepSetProductType(
    IN DSROLEP_MACHINE_TYPE MachineType
    )
/*++

Routine Description:

    Changes the role of the product to the type specified.

Arguments:

    MachineType - Type of ProductRole to set

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad service option was given

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR MachineSz = NULL;
    HKEY ProductHandle;
    ULONG Size = 0;

    switch ( MachineType ) {
    case DSROLEP_MT_STANDALONE:
        MachineSz = L"ServerNT";
        Size = sizeof( L"ServerNT" );
        break;

    case DSROLEP_MT_MEMBER:
        MachineSz = L"LanmanNT";
        Size = sizeof( L"LanmanNT");
        break;

    case DSROLEP_MT_CLIENT:
    default:

        Win32Err = ERROR_INVALID_PARAMETER;
        break;
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 DSROLEP_PROD_KEY_PATH,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_WRITE,            // desired access
                                 &ProductHandle );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = RegSetValueEx( ProductHandle,
                                      (LPCWSTR)DSROLEP_PROD_VALUE,
                                      0,
                                      REG_SZ,
                                      (CONST BYTE *)MachineSz,
                                      Size );


            RegCloseKey( ProductHandle );
        }
    }

    DsRoleDebugOut(( DEB_TRACE_DS, "SetProductType to %ws returned %lu\n",
                     MachineSz, Win32Err ));

    DsRolepLogPrint(( DEB_TRACE,
                      "SetProductType to %lu [%ws] returned %lu\n",
                       MachineType,
                       DsRolepDisplayOptional(MachineSz),
                       Win32Err ));

    DSROLEP_FAIL1( Win32Err, DSROLERES_PRODUCT_TYPE, MachineSz );


    return( Win32Err );
}

DWORD
DsRolepCreateAuthIdentForCreds(
    IN PWSTR Account,
    IN PWSTR Password,
    OUT PSEC_WINNT_AUTH_IDENTITY *AuthIdent
    )
/*++

Routine Description:

    Internal routine to create an AuthIdent structure for the given creditentials

Arguments:

    Account - Account name

    Password - Password for the account

    AuthIdent - AuthIdentity struct to allocate and fill in.


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed.

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR UserCredentialString = NULL;

    ASSERT( AuthIdent );

    //
    // If there are no creds, just return
    //
    if ( Account == NULL ) {

        *AuthIdent = NULL;
        return( Win32Err );
    }

    *AuthIdent = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( SEC_WINNT_AUTH_IDENTITY ) );

    if ( *AuthIdent == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        RtlZeroMemory( *AuthIdent, sizeof( SEC_WINNT_AUTH_IDENTITY ) );
        UserCredentialString = RtlAllocateHeap( RtlProcessHeap(), 0,
                                                ( wcslen( Account ) + 1 ) * sizeof( WCHAR ) );
        if ( UserCredentialString ) {

            wcscpy( UserCredentialString, Account );

            ( *AuthIdent )->User = wcsstr( UserCredentialString, L"\\" );

            if ( ( *AuthIdent )->User ) {

               //
               // There is a domain name
               //
               *( ( *AuthIdent )->User ) = L'\0';
               ( ( *AuthIdent )->User )++;
               ( *AuthIdent )->Domain = UserCredentialString;

            } else {

               ( *AuthIdent )->User = UserCredentialString;
               ( *AuthIdent )->Domain = L"";

            }

            if ( ( *AuthIdent )->User ) {

                ( *AuthIdent )->UserLength = wcslen( ( *AuthIdent )->User );
            }

            if ( ( *AuthIdent )->Domain ) {

                ( *AuthIdent )->DomainLength = wcslen( ( *AuthIdent )->Domain );
            }

            ( *AuthIdent )->Password = Password;

            if ( Password ) {

                ( *AuthIdent )->PasswordLength = wcslen( Password );
            }

            ( *AuthIdent )->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        } else {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            //
            // Free the memory allocated for the top level structure
            //
            RtlFreeHeap( RtlProcessHeap(), 0, *AuthIdent );
            *AuthIdent = NULL;
        }
    }

    return( Win32Err );
}


VOID
DsRolepFreeAuthIdentForCreds(
    IN  PSEC_WINNT_AUTH_IDENTITY AuthIdent
    )
/*++

Routine Description:

    Free the authident structure allocated above

Arguments:

    AuthIdent - AuthIdentity struct to free


Returns:

    VOID

--*/
{

    if ( AuthIdent ) {

        if ( AuthIdent->Domain == NULL ) {

            RtlFreeHeap( RtlProcessHeap(), 0, AuthIdent->User );

        } else {

            if ( *AuthIdent->Domain != L'\0' ) {

                RtlFreeHeap( RtlProcessHeap(), 0, AuthIdent->Domain );
            }
        }

        RtlFreeHeap( RtlProcessHeap(), 0, AuthIdent );
    }

}

NTSTATUS
ImpLsaOpenPolicy(
    IN HANDLE CallerToken,
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    )
/*++

Routine Description:

    This routine impersonates CallerToken and then calls into LsaOpenPolicy.

    This purpose of this routine is call into the LSA on a different machine
    using the RDR session for the caller of the DsRole API.  The caller is
    represented by CallerToken.  This is necessary because the RDR sessions
    are keyed by (logon id/remote server name) and we don't want to use the
    logon id of the lsass.exe process since this is a shared logon id for
    lsass.exe and services.exe and will lead to unresolable credentials
    conflict.

    N.B.  The LSA rpc calls that follow the (Imp)LsaOpenPolicy will use the
    handle returned by this function and then magically uses the right RDR
    session to make the RPC call.

Arguments:

    CallerToken - the token of the DsRole involker

    Others -- see LsaOpenPolicy


Returns:

    STATUS_ACCESS_DENIED if the impersonattion fails.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaOpenPolicy( SystemName,
                                ObjectAttributes,
                                DesiredAccess,
                                PolicyHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

DWORD
ImpDsRolepDsGetDcForAccount(
    IN HANDLE CallerToken,
    IN LPWSTR Server OPTIONAL,
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN ULONG Flags,
    IN ULONG AccountBits,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
/*++

Routine Description:

    This function will impersoniate logged on user and call DsRolepDsGetDcForAccount

Arguments:

    CallerToken - The Token of the DsRole involker.

    Server - The server to call GetDc on.

    Domain - Domain to find the Dc for

    Account - Account to look for.  If NULL, the current computer name is used

    Flags - Flags to bas in to the GetDc call

    AccountBits - Account control bits to search for

    DomainControllerInfo - Where the info is returned

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        WinError = DsRolepDsGetDcForAccount(Server,
                                            Domain,
                                            Account,
                                            Flags,
                                            AccountBits,
                                            DomainControllerInfo
                                            );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );

    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        WinError = ERROR_ACCESS_DENIED;
    }

    return WinError;
}

NET_API_STATUS
NET_API_FUNCTION
ImpNetpManageIPCConnect(
    IN  HANDLE  CallerToken,
    IN  LPWSTR  lpServer,
    IN  LPWSTR  lpAccount,
    IN  LPWSTR  lpPassword,
    IN  ULONG   fOptions
    )
/*++

Routine Description:

    This routine impersonates CallerToken and then calls into
    NetpManageIPCConnect.

    This purpose of this routine is to create a RDR using the logon id of
    the caller of the DsRole api's.  The caller is represented by CallerToken.
    This is necessary because the RDR sessions are keyed by
    (logon id/remote server name) and we don't want to use the
    logon id of the lsass.exe process since this is a shared logon id for
    lsass.exe and services.exe and will lead to unresolable credentials
    conflict.

Arguments:

    CallerToken - the token of the DsRole involker

    Others -- see LsaOpenPolicy


Returns:

    STATUS_ACCESS_DENIED if the impersonattion fails.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        WinError = NetpManageIPCConnect( lpServer,
                                         lpAccount,
                                         lpPassword,
                                         fOptions );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );

    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        WinError = ERROR_ACCESS_DENIED;
    }

    return WinError;

}


DWORD
DsRolepGenerateRandomPassword(
    IN ULONG Length,
    IN WCHAR *Buffer
    )
/*++

Routine Description:

    This local function is used to generate a random password of no more than the
    specified length.  It is assumed that the destination buffer is of sufficient length.

Arguments:

    Length - Length of the buffer

    Buffer - Buffer to fill

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG PwdLength, i;
    LARGE_INTEGER Time;
    HCRYPTPROV CryptProvider = 0;


    PwdLength = Length;

    //
    // Generate a random password.
    //
    if ( CryptAcquireContext( &CryptProvider,
                              NULL,
                              NULL,
                              PROV_RSA_FULL,
                              CRYPT_VERIFYCONTEXT ) ) {

        if ( CryptGenRandom( CryptProvider,
                              PwdLength * sizeof( WCHAR ),
                              ( LPBYTE )Buffer ) ) {

            Buffer[ PwdLength ] = UNICODE_NULL;

            //
            // Make sure there are no NULL's in the middle of the list
            //
            for ( i = 0; i < PwdLength; i++ ) {

                if ( Buffer[ i ] == UNICODE_NULL ) {

                    Buffer[ i ] = 0xe;
                }
            }

        } else {

            Win32Err = GetLastError();
        }

        CryptReleaseContext( CryptProvider, 0 );


    } else {

        Win32Err = GetLastError();
    }

    return( Win32Err );

}
DWORD
DsRolepCopyDsDitFiles(
    IN LPWSTR DsPath
    )
/*++

Routine Description:

    This function copies the initial database files from the install point to the
    specified Ds database directory

Arguments:

    DsPath - Path where the Ds database files are to reside

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR Source[MAX_PATH + 1];
    WCHAR Dest[MAX_PATH + 1];
    ULONG SrcLen = 0, DestLen = 0;
    PWSTR Current;
    ULONG i;
    PWSTR DsDitFiles[] = {
        L"ntds.dit"
        };

    ASSERT(wcslen(DsPath) < MAX_PATH);

    if( ExpandEnvironmentStrings( L"%WINDIR%\\system32\\", Source, MAX_PATH ) == FALSE ) {

        Win32Err = GetLastError();

    } else {

        SrcLen = wcslen( Source );
        wcscpy( Dest, DsPath );

        if ( *(Dest + (wcslen( DsPath ) - 1 )) != L'\\' ) {

            wcscat( Dest, L"\\" );
        }

        DestLen = wcslen( Dest );

    }

    //
    // Then, create the destination directory
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Current = wcschr( DsPath + 4, L'\\' );

        while ( Win32Err == ERROR_SUCCESS ) {

            if ( Current != NULL ) {

                *Current = UNICODE_NULL;

            }

            if ( CreateDirectory( DsPath, NULL ) == FALSE ) {


                Win32Err = GetLastError();

                if ( Win32Err == ERROR_ALREADY_EXISTS) {

                    Win32Err = ERROR_SUCCESS;

                } else if ( Win32Err == ERROR_ACCESS_DENIED ) {

                    if ( PathIsRoot(DsPath) ) {

                        //If the path given to CreateDirectory is a root path then
                        //it will fail with ERROR_ACCESS_DENIED instead of
                        //ERROR_ALREADY_EXISTS but the path is still a valid one for
                        //ntds.dit and the log files to be placed in.

                        Win32Err = ERROR_SUCCESS;

                    }
                }
            }

            if ( Current != NULL ) {

                *Current = L'\\';

                Current = wcschr( Current + 1, L'\\' );

            } else {

                break;

            }

        }
    }

    //
    // Then copy them.
    //
    for ( i = 0; i < sizeof( DsDitFiles) / sizeof( PWSTR ) && Win32Err == ERROR_SUCCESS ; i++ ) {

        //make sure that the last char is a NULL
        Source[sizeof(Source)/sizeof(*Source)-1] = L'\0';
        Dest[sizeof(Dest)/sizeof(*Dest)-1] = L'\0';
        wcsncpy( Source + SrcLen, DsDitFiles[i], sizeof(Source)/sizeof(*Source)-1-SrcLen );
        wcsncpy( Dest + DestLen, DsDitFiles[i], sizeof(Dest)/sizeof(*Dest)-1-DestLen );

        DSROLEP_CURRENT_OP2( DSROLEEVT_COPY_DIT, Source, Dest );
        if ( CopyFile( Source, Dest, TRUE ) == FALSE ) {

            Win32Err = GetLastError();

            if ( Win32Err == ERROR_ALREADY_EXISTS ||
                 Win32Err == ERROR_FILE_EXISTS ) {

                Win32Err = ERROR_SUCCESS;

            } else {

                DsRolepLogPrint(( DEB_ERROR, "Failed to copy install file %ws to %ws: %lu\n",
                                  Source, Dest, Win32Err ));
            }
        }
    }

    return( Win32Err );
}


#define DSROLEP_SEC_SYSVOL   L"SYSVOL"
#define DSROLEP_SEC_DSDIT    L"DSDIT"
#define DSROLEP_SEC_DSLOG    L"DSLOG"

DWORD
DsRolepSetDcSecurity(
    IN HANDLE ClientToken,
    IN LPWSTR SysVolRootPath,
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN BOOLEAN Upgrade,
    IN BOOLEAN Replica
    )
/*++

Routine Description:

    This function will invoke the security editor to set the security on the Dc install files

Arguments:

    SysVolRootPath - Root used for the system volume

    DsDatabasePath - Path to where the Ds database files go

    DsLogPath - Path to where the Ds log files go

    Upgrade - If TRUE, the machine is undergoing an upgrade

    Replica - If TRUE, the machine is going through an upgrade

Returns:

    ERROR_SUCCESS - Success

--*/
{

    DWORD Win32Err = ERROR_SUCCESS, i;
    PWSTR Paths[ 3 ], Tags[ 3 ];
    ULONG Options = 0;

    Paths[ 0 ] = SysVolRootPath;
    Paths[ 1 ] = DsDatabasePath;
    Paths[ 2 ] = DsLogPath;
    Tags[ 0 ] = DSROLEP_SEC_SYSVOL;
    Tags[ 1 ] = DSROLEP_SEC_DSDIT;
    Tags[ 2 ] = DSROLEP_SEC_DSLOG;

    //
    // Set the environment variables.  secedt uses the environment variables to pass around
    // information, so we will set the for the duration of this function
    //
    if ( Win32Err == ERROR_SUCCESS ) {


        ASSERT( sizeof( Paths ) / sizeof( PWSTR ) == sizeof( Tags ) / sizeof( PWSTR ) );
        for ( i = 0; i < sizeof( Paths ) / sizeof( PWSTR ) && Win32Err == ERROR_SUCCESS; i++ ) {

            if ( SetEnvironmentVariable( Tags[ i ], Paths[ i ] ) == FALSE ) {

                Win32Err = GetLastError();
                DsRolepLogPrint(( DEB_TRACE,
                                  "SetEnvironmentVariable %ws = %ws failed with %lu\n",
                                  Tags[ i ],
                                  Paths[ i ],
                                  Win32Err ));
                break;
            }
        }
    }

    //
    // Now, invoke the security editing code
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DsRolepSetAndClearLog();
        DSROLEP_CURRENT_OP0( DSROLEEVT_SETTING_SECURITY );

        Options |= Upgrade ? SCE_PROMOTE_FLAG_UPGRADE : 0;
        Options |= Replica ? SCE_PROMOTE_FLAG_REPLICA : 0;

        Win32Err = ( *DsrSceDcPromoteSecurityEx )( ClientToken,
                                                   Options,
                                                   DsRolepStringUpdateCallback );
        DsRolepSetAndClearLog();
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_ERROR,
                                               "Setting security on Dc files failed with %lu\n",
                                               Win32Err )) );
    }


    //
    // Delete the environment variables
    //
    for ( i = 0; i < sizeof( Paths ) / sizeof( PWSTR ); i++ ) {

        if ( SetEnvironmentVariable( Tags[ i ], NULL ) == FALSE ) {

            DsRolepLogPrint(( DEB_TRACE,
                             "SetEnvironmentVariable %ws = NULL failed with %lu\n",
                             Tags[ i ],
                             GetLastError() ));
        }
    }

    //
    // Currently, setting the security will not cause the promote to fail
    //
    if ( Win32Err != ERROR_SUCCESS ) {

        //
        // Raise an event
        //
        SpmpReportEvent( TRUE,
                         EVENTLOG_WARNING_TYPE,
                         DSROLERES_FAIL_SET_SECURITY,
                         0,
                         sizeof( ULONG ),
                         &Win32Err,
                         1,
                         SCE_DCPROMO_LOG_PATH );

        DSROLEP_SET_NON_FATAL_ERROR( Win32Err );

    }

    Win32Err = ERROR_SUCCESS;

    return( Win32Err );
}




DWORD
DsRolepDsGetDcForAccount(
    IN LPWSTR Server OPTIONAL,
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN ULONG Flags,
    IN ULONG AccountBits,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
/*++

Routine Description:

    This function is equivalent to DsGetDcName but will search for the Dc that holds the
    specified account.

Arguments:

    ReplicaServer - The server to call GetDc on.

    Domain - Domain to find the Dc for

    Account - Account to look for.  If NULL, the current computer name is used

    Flags - Flags to bas in to the GetDc call

    AccountBits - Account control bits to search for

    DomainControllerInfo - Where the info is returned

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    ULONG Length = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // If we have no account, use the computer name
    //
    if ( Account == NULL ) {

        if ( GetComputerName( ComputerName, &Length ) == FALSE ) {

            Win32Err = GetLastError();

        } else {

            wcscat( ComputerName, SSI_SECRET_PREFIX );
            Account = ComputerName;
        }
    }

    //
    // Now, do the find
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DSROLEP_CURRENT_OP2( DSROLEEVT_FIND_DC_FOR_ACCOUNT, Domain, Account );
        Win32Err = DsGetDcNameWithAccountW( Server,
                                            Account,
                                            AccountBits,
                                            Domain,
                                            NULL,
                                            NULL,
                                            Flags,
                                            DomainControllerInfo );

        if ( ERROR_NO_SUCH_USER == Win32Err ) {

            //
            // The error should read "no machine account", not "no user"
            // since we are searching for a machine account.
            //

            Win32Err = ERROR_NO_TRUST_SAM_ACCOUNT;
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_DC,
                                 ( PWSTR ) ( ( *DomainControllerInfo )->DomainControllerName + 2 ),
                                 Domain );

        } else {

            DsRolepLogPrint(( DEB_ERROR, "Failed to find a DC for domain %ws: %lu\n",
                              Domain, Win32Err ));

        }


    }



    return( Win32Err );
}




DWORD
DsRolepSetMachineAccountType(
    IN LPWSTR Dc,
    IN HANDLE ClientToken,
    IN LPWSTR User,
    IN LPWSTR Password,
    IN LPWSTR AccountName,
    IN ULONG AccountBits,
    IN OUT WCHAR** AccountDn
    )
{
    DWORD Win32Err = ERROR_SUCCESS, Win32Err2;
    USER_INFO_1 *CurrentUI1;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    ULONG Length = MAX_COMPUTERNAME_LENGTH + 1;
    PSEC_WINNT_AUTH_IDENTITY AuthIdent = NULL;

    //
    // If we have no account, use the computer name
    //
    if ( AccountName == NULL ) {

        if ( GetComputerName( ComputerName, &Length ) == FALSE ) {

            Win32Err = GetLastError();

        } else {

            wcscat( ComputerName, SSI_SECRET_PREFIX );
            AccountName = ComputerName;
        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepCreateAuthIdentForCreds( User, Password, &AuthIdent );
    }

    //
    // Call the support dll
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_TRACE, "Searching for the machine account for %ws on %ws...\n",
                           AccountName, Dc ));

        DSROLEP_CURRENT_OP0( DSROLEEVT_MACHINE_ACCT );

        DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsSetReplicaMachineAccount );

        if ( Win32Err == ERROR_SUCCESS ) {

            if ( Dc && *Dc == L'\\' ) {

                Dc += 2;
            }

            Win32Err = (*DsrNtdsSetReplicaMachineAccount)( AuthIdent,
                                                           ClientToken,
                                                           Dc,
                                                           AccountName,
                                                           AccountBits,
                                                           AccountDn );
        }

        DsRolepLogPrint(( DEB_TRACE, "NtdsSetReplicaMachineAccount returned %d\n", Win32Err ));

        DsRolepFreeAuthIdentForCreds( AuthIdent );
    }

    return( Win32Err );
}

DWORD
DsRolepTimeSyncAndManageIPCConnect(
    IN PVOID vpPromoteArgs,
    IN PWSTR ReplicaServer
    )
/*++

Routine Description:

    This function forces a time sync with the specified server and will
    Manage the IPC connection

Arguments:

    PromoteArgs - Args passed to the dsrole api's

    ReplicaServer - The target of the operation

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs = (PDSROLEP_OPERATION_PROMOTE_ARGS)vpPromoteArgs;

    //
    // Force the time synch
    //
    DsRolepLogPrint(( DEB_TRACE, "Forcing time sync\n"));

    if ( FLAG_ON( PromoteArgs->Options, DSROLE_DC_FORCE_TIME_SYNC ) ) {


        WinError = DsRolepForceTimeSync( PromoteArgs->ImpersonateToken,
                                         ReplicaServer );

        if ( ERROR_SUCCESS != WinError ) {

            // the machine object was moved
           DsRolepLogPrint(( DEB_WARN, "Time sync with %ws failed with %d\n",
                             ReplicaServer,
                             WinError ));

           WinError = ERROR_SUCCESS;

        }

    }

    //
    // Attempt to start a RDR connection because we will need one later on
    //

    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    WinError = ImpNetpManageIPCConnect( PromoteArgs->ImpersonateToken,
                                        ReplicaServer,
                                        PromoteArgs->Account,
                                        PromoteArgs->Password.Buffer,
                                        NETSETUPP_CONNECT_IPC );

    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
    if ( WinError != ERROR_SUCCESS ) {

        DSROLEP_FAIL1( WinError, DSROLERES_NET_USE, ReplicaServer );
        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to establish the session with %ws: 0x%lx\n", ReplicaServer,
                          WinError ));

    }

    return WinError;

}


DWORD
DsRolepForceTimeSync(
    IN HANDLE ImpToken,
    IN PWSTR TimeSource
    )
/*++

Routine Description:

    This function forces a time sync with the specified server

Arguments:

    TimeSource - Server to use for the time source

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR ServerName = NULL;
    PTIME_OF_DAY_INFO TOD;
    HANDLE ThreadToken = 0;
    TOKEN_PRIVILEGES Enabled, Previous;
    DWORD PreviousSize;
    TIME_FIELDS TimeFields;
    LARGE_INTEGER SystemTime;

    BOOL connected=FALSE;
    NETRESOURCE NetResource;
    WCHAR *remotename=NULL;

    BOOL fSuccess = FALSE;

    if ( !TimeSource ) {
        Win32Err = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Build the server name with preceeding \\'s
    //
    if ( *TimeSource != L'\\' ) {

        ServerName = RtlAllocateHeap( RtlProcessHeap(), 0,
                                      ( wcslen( TimeSource ) + 3 ) * sizeof( WCHAR ) );

        if ( ServerName == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            DsRolepLogPrint(( DEB_ERROR, "Failed to open a NULL session with %ws for time sync.  Out of Memory. Failed with %d\n",
                             TimeSource,
                             Win32Err ));
            goto cleanup;

        } else {

            swprintf( ServerName, L"\\\\%ws", TimeSource );
        }

    } else {

        ServerName = TimeSource;
    }

    //
    // Enable the systemtime privilege
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Status = NtOpenThreadToken( NtCurrentThread(),
                                    TOKEN_READ | TOKEN_WRITE,
                                    TRUE,
                                    &ThreadToken );

        if ( Status == STATUS_NO_TOKEN ) {

            Status = NtOpenProcessToken( NtCurrentProcess(),
                                         TOKEN_WRITE | TOKEN_READ,
                                         &ThreadToken );
        }

        if ( NT_SUCCESS( Status ) ) {

            Enabled.PrivilegeCount = 1;
            Enabled.Privileges[0].Luid.LowPart = SE_SYSTEMTIME_PRIVILEGE;
            Enabled.Privileges[0].Luid.HighPart = 0;
            Enabled.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            PreviousSize = sizeof( Previous );

            Status = NtAdjustPrivilegesToken( ThreadToken,
                                              FALSE,
                                              &Enabled,
                                              sizeof( Enabled ),
                                              &Previous,
                                              &PreviousSize );
            //
            // Since we modified the thread token and the thread is shortlived, we won't bother
            // restoring it later.
            //
        }

        if ( ThreadToken ) {

            NtClose( ThreadToken );

        }



        Win32Err = RtlNtStatusToDosError( Status );
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_ERROR,
                                               "Failed to enable the SE_SYSTEMTIME_PRIVILEGE: %lu\n",
                                               Win32Err )) );

    }


    //
    // Get the remote time
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DSROLEP_CURRENT_OP1( DSROLEEVT_TIMESYNC, TimeSource );

        fSuccess = ImpersonateLoggedOnUser( ImpToken );
        if ( !fSuccess ) {

            DsRolepLogPrint(( DEB_TRACE,
                              "Failed to impersonate caller, error %lu\n",
                              GetLastError() ));

            //
            // We couldn't impersonate?
            //


            // We will continue anyway

        }

    }



    remotename = RtlAllocateHeap(
                  RtlProcessHeap(), 0,
                   sizeof(WCHAR)*(wcslen(L"\\ipc$")+wcslen(ServerName)+1));
    if ( remotename == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;
        DsRolepLogPrint(( DEB_ERROR, "Failed to open a NULL session with %ws for time sync.  Out of Memory. Failed with %d\n",
                             ServerName,
                             Win32Err ));

    }

    wsprintf(remotename,L"%s\\ipc$",ServerName);

    NetResource.dwType=RESOURCETYPE_ANY;
    NetResource.lpLocalName=NULL;
    NetResource.lpRemoteName=remotename;
    NetResource.lpProvider=NULL;

    //get permission to access the server
    Win32Err=WNetAddConnection2W(&NetResource,
                             L"",
                             L"",
                             0);
    if ( Win32Err == NO_ERROR ) {
        connected=TRUE;
    }
    else {
        DsRolepLogPrint(( DEB_WARN, "Failed to open a NULL session with %ws for time sync.  Failed with %d\n",
                         ServerName,
                         Win32Err ));
        //We will attempt to Time sync anyway
    }

    Win32Err = NetRemoteTOD( ServerName, ( LPBYTE * )&TOD );

    if ( Win32Err == ERROR_SUCCESS ) {

        TimeFields.Hour = ( WORD )TOD->tod_hours;
        TimeFields.Minute = ( WORD )TOD->tod_mins;
        TimeFields.Second = ( WORD )TOD->tod_secs;
        TimeFields.Milliseconds = ( WORD )TOD->tod_hunds * 10;
        TimeFields.Day = ( WORD )TOD->tod_day;
        TimeFields.Month = ( WORD )TOD->tod_month;
        TimeFields.Year = ( WORD )TOD->tod_year;

        if ( !RtlTimeFieldsToTime( &TimeFields, &SystemTime ) ) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            if ( connected ) {
                WNetCancelConnection2(remotename,
                                  0,
                                  TRUE);
            }

            if( remotename ) {

                RtlFreeHeap( RtlProcessHeap(), 0, remotename );

            }

            fSuccess = RevertToSelf();
            ASSERT( fSuccess );
            connected=FALSE;

            Status = NtSetSystemTime( &SystemTime, NULL );

            if ( !NT_SUCCESS( Status ) ) {

                DsRolepLogPrint(( DEB_ERROR, "NtSetSystemTime failed with 0x%lx\n", Status ));
            }


        }


        Win32Err = RtlNtStatusToDosError( Status );

        NetApiBufferFree( TOD );

    } else {

        DsRolepLogPrint(( DEB_ERROR, "Failed to get the current time on %ws: %lu\n",
                          TimeSource, Win32Err ));

    }




    //
    // For the IDS, consider a failure here non-fatal
    //
    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "NON-FATAL error forcing a time sync (%lu).  Ignoring\n",
                          Win32Err ));
        Win32Err = ERROR_SUCCESS;

    }

    cleanup:

    if ( connected ) {
        WNetCancelConnection2(remotename,
                          0,
                          TRUE);


        if( remotename ) {

            RtlFreeHeap( RtlProcessHeap(), 0, remotename );

        }

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    }


    return( Win32Err );
}




NTSTATUS
DsRolepGetMixedModeFlags(
    IN PSID DomainSid,
    OUT PULONG Flags
    )
/*++

Routine Description:

    This routine will determine whether the machine is currently in mixed mode or not

Arguments:

    Flags - Pointer to a flags value to be altered.  If the machine is a mixed mode, we simply
        or in the proper value.

Return Values:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN mixedDomain;

    Status = SamIMixedDomain2( DomainSid, &mixedDomain );

    if ( NT_SUCCESS( Status ) && mixedDomain) {
        *Flags |= DSROLE_PRIMARY_DS_MIXED_MODE;
    }

    return( Status );
}


BOOL
DsRolepShutdownNotification(
    DWORD   dwCtrlType
    )
/*++

Routine Description:

    This routine is called by the system when system shutdown is occuring.

    It stops a role change if one is in progress.

Arguments:

    dwCtrlType -- the notification


Return Value:

    FALSE - to allow any other shutdown routines in this process to
        also be called.

--*/
{
    if ( dwCtrlType == CTRL_SHUTDOWN_EVENT ) {

        //
        // Cancel the operation
        //
        (VOID) DsRolepCancel( FALSE );  // Don't block

    }

    return FALSE;
}

DWORD
DsRolepDeregisterNetlogonDnsRecords(
    PNTDS_DNS_RR_INFO pInfo
    )
/*++

Routine Description:

    This routine is called during demotion to call netlogon to deregister
    its the service DNS records for this domain controller

Arguments:

    pInfo -- structure containing the parameters for the deregistration

Return Value:

    An error from DsDeregisterDnsHostRecordsW

--*/
{

    DWORD WinError = ERROR_SUCCESS;
    HKEY  hNetlogonParms = NULL;
    BOOL  fDoDeregistration = TRUE;

    if ( !pInfo ) {
        return STATUS_SUCCESS;
    }

#define NETLOGON_PATH L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters"
#define AVOID_DNS_DEREG_KEY L"AvoidDnsDeregOnShutdown"

    WinError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             NETLOGON_PATH,
                             0,
                             KEY_READ,
                             &hNetlogonParms );

    if ( ERROR_SUCCESS == WinError ) {

        DWORD val = 0;
        DWORD len = sizeof(DWORD);
        DWORD type;

        WinError = RegQueryValueEx( hNetlogonParms,
                                    AVOID_DNS_DEREG_KEY,
                                    0,
                                    &type,
                                    (BYTE*)&val,
                                    &len );

        if ( (ERROR_SUCCESS == WinError)
         &&  (type == REG_DWORD)
         &&  (val == 0)       ) {

            //
            // Don't bother; netlogon has already done the deregistration.
            //
            fDoDeregistration = FALSE;
        }

        RegCloseKey( hNetlogonParms );
    }

    if ( fDoDeregistration ) {

        //
        // Ask netlogon to do the deregistration
        //
        WinError = DsDeregisterDnsHostRecordsW( NULL, // go local
                                                pInfo->DnsDomainName,
                                                &pInfo->DomainGuid,
                                                &pInfo->DsaGuid,
                                                pInfo->DnsHostName );
    } else {

        WinError = ERROR_SUCCESS;

    }

    return WinError;

}

NTSTATUS
ImpLsaDelete(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ObjectHandle
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaDelete( ObjectHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );

    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

NTSTATUS
ImpLsaQueryInformationPolicy(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            InformationClass,
                                            Buffer );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;
}


NTSTATUS
ImpLsaOpenTrustedDomainByName(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaOpenTrustedDomainByName( PolicyHandle,
                                             TrustedDomainName,
                                             DesiredAccess,
                                             TrustedDomainHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

NTSTATUS
ImpLsaOpenTrustedDomain(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaOpenTrustedDomain( PolicyHandle,
                                       TrustedDomainSid,
                                       DesiredAccess,
                                       TrustedDomainHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}


NTSTATUS
ImpLsaCreateTrustedDomainEx(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaCreateTrustedDomainEx( PolicyHandle,
                                           TrustedDomainInformation,
                                           AuthenticationInformation,
                                           DesiredAccess,
                                           TrustedDomainHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

NTSTATUS
ImpLsaQueryTrustedDomainInfoByName(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaQueryTrustedDomainInfoByName( PolicyHandle,
                                                  TrustedDomainName,
                                                  InformationClass,
                                                  Buffer );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

NTSTATUS
ImpLsaQueryInfoTrustedDomain(
    IN HANDLE CallerToken,
    IN LSA_HANDLE TrustedDomain,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaQueryInfoTrustedDomain( TrustedDomain,
                                            InformationClass,
                                            Buffer );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;
}

NTSTATUS
ImpLsaQueryDomainInformationPolicy(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaQueryDomainInformationPolicy( PolicyHandle,
                                                  InformationClass,
                                                  Buffer );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

NTSTATUS
ImpLsaClose(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaClose( ObjectHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\services.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    services.h

Abstract:

    Routines to manage nt service configurations for promotion and demotion
    
Author:

    Colin Brace    ColinBr     March 29, 1999.

Environment:

    User Mode

Revision History:

--*/


//
// Control bits for the "Flags" parameter
// 

// Not a valid flag
#define DSROLEP_SERVICES_INVALID        0x0

// Configure start type of services to become new role
#define DSROLEP_SERVICES_ON             0x00000001

// Configure start type of services to leave old role
#define DSROLEP_SERVICES_OFF            0x00000002

// Stop or start services -- can be used with above flags
#define DSROLEP_SERVICES_STOP           0x00000004
#define DSROLEP_SERVICES_START          0x00000008

// Configure services back to original state -- no other flags
// above are valid with this flags
#define DSROLEP_SERVICES_REVERT         0x00000010

// Ignores any errors that may occur
#define DSROLEP_SERVICES_IGNORE_ERRORS  0x00000020

//
// This routine configures the services relevant to a domain controller
//
DWORD
DsRolepConfigureDomainControllerServices(
    IN DWORD Flags
    );

//
// This routine configures the services relevant to a member of a domain
// (including domain controllers)
//
DWORD
DsRolepConfigureDomainServices(
    IN DWORD Flags
    );

//
// Simple routines to manage netlogon running state (not
//
DWORD
DsRolepStartNetlogon(
    VOID
    );

DWORD
DsRolepStopNetlogon(
    OUT BOOLEAN *WasRunning
    );

//
// A "low level" routine to manipulate a service directly
//

//
// Options for controlling services (through the ServiceOptions)
//
#define DSROLEP_SERVICE_NOOP          0x00000000

#define DSROLEP_SERVICE_STOP          0x00000001
#define DSROLEP_SERVICE_START         0x00000002

#define DSROLEP_SERVICE_BOOTSTART     0x00000004
#define DSROLEP_SERVICE_SYSTEM_START  0x00000008
#define DSROLEP_SERVICE_AUTOSTART     0x00000010
#define DSROLEP_SERVICE_DEMANDSTART   0x00000020
#define DSROLEP_SERVICE_DISABLED      0x00000040

#define DSROLEP_SERVICE_DEP_ADD       0x00000080
#define DSROLEP_SERVICE_DEP_REMOVE    0x00000100

#define DSROLEP_SERVICE_STOP_ISM      0x00000200
#define DSROLEP_SERVICE_IGNORE_ERRORS 0x00000400

DWORD
DsRolepConfigureService(
    IN  LPWSTR  ServiceName,
    IN  ULONG   ServiceOptions,
    IN  LPWSTR  Dependency OPTIONAL,
    OUT ULONG * PreviousSettings  OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\sysvol.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sysvol.h

Abstract:

    Routines to manage the system volume installation            

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __SYSVOL_H__
#define __SYSVOL_H__

DWORD
DsRolepRemoveSysVolPath(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName,
    IN  GUID *DomainGuid
    );

DWORD
DsRolepCreateSysVolPath(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FrsReplicaServer, OPTIONAL
    IN  LPWSTR Account,
    IN  LPWSTR Password,
    IN  PWSTR Site,
    IN  BOOLEAN FirstDc
    );

DWORD
DsRolepFinishSysVolPropagation(
    IN BOOLEAN Commit,
    IN BOOLEAN Promote
    );

DWORD
DsRolepSetFrsInfoForDelete(
    IN GUID *ReplicaDomainGuid,
    IN BOOLEAN Restore
    );

DWORD
DsRolepSetNetlogonSysVolPath(
    IN LPWSTR SysVolRoot,
    IN LPWSTR DomainName,
    IN BOOLEAN IsUpgrade,
    IN PBOOLEAN OkToCleanup
    );

DWORD
DsRolepCleanupOldNetlogonInformation(
    VOID
    );


#endif // __SYSVOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\trustdom.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    trustdom.c

Abstract:

    Implementation of the functions to manage the trust link between 2 servers

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <db.h>
#include <lsads.h>
#include <lsasrvmm.h>
#include <lsaisrv.h>
#include <lmcons.h>
#include <cryptdll.h>
#include <winbase.h> // For RtlSecureZeroMemory

#include "trustdom.h"

DWORD
DsRolepSetLsaDnsInformationNoParent(
    IN  LPWSTR DnsDomainName
    )
/*++

Routine Description:

    In the case where we are installing as a standalong or root Dc, set the Lsa
    POLICY_DNS_DOMAIN_INFORMATION DnsForestName value to point to ourselves.

Arguments:

    DnsDomainName - Dns domain path to set

Returns:

    ERROR_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPOLICY_DNS_DOMAIN_INFO CurrentDnsInfo;
    PLSAPR_POLICY_INFORMATION  LsaPolicy;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Policy;

    //
    // Open our local policy
    //
    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_WRITE,
                            &Policy );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Get the current information
        //
        Status =  LsaQueryInformationPolicy( Policy,
                                             PolicyDnsDomainInformation,
                                             ( PVOID * )&LsaPolicy );
        if ( NT_SUCCESS( Status ) ) {

            //
            // Add in the new...
            //
            CurrentDnsInfo = (PPOLICY_DNS_DOMAIN_INFO)LsaPolicy;
            RtlInitUnicodeString( &CurrentDnsInfo->DnsForestName, DnsDomainName );

            DsRolepLogPrint(( DEB_TRACE, "Configuring DnsForestName to %ws\n",
                              DnsDomainName ));

            //
            // And write it out..
            //
            Status = LsaSetInformationPolicy( Policy,
                                              PolicyDnsDomainInformation,
                                              LsaPolicy );


            //
            // Don't want to actually free the passed in buffer
            //
            RtlZeroMemory( &CurrentDnsInfo->DnsForestName, sizeof( UNICODE_STRING ) );

            LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation, LsaPolicy );

        }

        LsaClose( Policy );

    }

    DsRolepLogOnFailure( Status,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "DsRolepSetLsaDnsInformationNoParent failed with 0x%lx\n",
                                           Status )) );

    return( RtlNtStatusToDosError( Status ) );
}



DWORD
DsRolepCreateTrustedDomainObjects(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN LPWSTR DnsDomainName,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo,
    IN ULONG Options
    )
/*++

Routine Description:

    Creates the trusted domain object on the domains if they should exist and sets the
    Lsa POLICY_DNS_DOMAIN_INFORMATION DnsTree value to either the value of our parent in
    a parent/child install, or as the root otherwise.

Arguments:

    ParentDc - Optional.  Name of the parent Dc

    DnsDomainName - Dns name of the domain we're installing into

    ParentDnsDomainInfo - DNS domain information obtained from the parent

    Options - Options that dictate what steps are taken

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ParentServer;
    HANDLE LocalPolicy = NULL , ParentPolicy = NULL;
    PPOLICY_DNS_DOMAIN_INFO LocalDnsInfo = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE ParentTrustedDomain = NULL;

    WCHAR GeneratedPassword[ PWLEN + 1 ];
    ULONG Length = PWLEN;

    LSA_AUTH_INFORMATION AuthData;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx;

    DSROLEP_CURRENT_OP1( DSROLEEVT_SET_LSA_FROM, ParentDc );

    //
    // Make the Lsa think that we're initialized
    //
    Status = LsapDsInitializeDsStateInfo( LsapDsDsSetup );

    if ( !NT_SUCCESS( Status ) ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to convince Lsa to reinitialize: 0x%lx\n",
                          Status ));

        return( RtlNtStatusToDosError( Status ) );
    }


    //
    // Prepare the Auth Info
    //
    RtlZeroMemory( &AuthInfoEx, sizeof(AuthInfoEx) );
    RtlZeroMemory( &AuthData, sizeof(AuthData) );
    RtlZeroMemory( &GeneratedPassword, sizeof(GeneratedPassword) );

    Win32Err = DsRolepGenerateRandomPassword( Length,
                                              GeneratedPassword );

    if ( ERROR_SUCCESS == Win32Err ) {

        Status = NtQuerySystemTime( &AuthData.LastUpdateTime );

        if ( NT_SUCCESS( Status ) ) {

            AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
            AuthData.AuthInfoLength = Length;
            AuthData.AuthInfo = (PUCHAR)GeneratedPassword;

            AuthInfoEx.IncomingAuthInfos = 1;
            AuthInfoEx.IncomingAuthenticationInformation = &AuthData;
            AuthInfoEx.IncomingPreviousAuthenticationInformation = NULL;


            AuthInfoEx.OutgoingAuthInfos = 1;
            AuthInfoEx.OutgoingAuthenticationInformation = &AuthData;
            AuthInfoEx.OutgoingPreviousAuthenticationInformation = NULL;

        }

    } else {


        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to generate a trust password: %lu\n",
                          Win32Err ));

        Status = STATUS_UNSUCCESSFUL;
    }


    if ( NT_SUCCESS( Status ) ) {

        //
        // Open both lsas
        //
        RtlInitUnicodeString( &ParentServer, ParentDc );

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = ImpLsaOpenPolicy( CallerToken,
                                  &ParentServer,
                                  &ObjectAttributes,
                                   POLICY_TRUST_ADMIN | POLICY_VIEW_LOCAL_INFORMATION,
                                   &ParentPolicy
                                   );

        if ( NT_SUCCESS( Status ) ) {

            RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
            Status = LsaOpenPolicy( NULL,
                                    &ObjectAttributes,
                                    POLICY_TRUST_ADMIN | POLICY_VIEW_LOCAL_INFORMATION,
                                    &LocalPolicy );
        } else {

            DsRolepLogPrint(( DEB_TRACE,
                              "OpenPolicy on %ws failed with 0x%lx\n",
                              ParentDc,
                              Status ));
        }

    }

    //
    // Get our local dns domain information
    //
    if ( NT_SUCCESS( Status ) ) {


        Status = LsaQueryInformationPolicy( LocalPolicy,
                                            PolicyDnsDomainInformation,
                                            &LocalDnsInfo );
    }

    //
    // Now, create the trusted domain objects
    //
    if ( NT_SUCCESS( Status ) ) {

        DSROLEP_CURRENT_OP1( DSROLEEVT_CREATE_PARENT_TRUST,
                             ParentDnsDomainInfo->DnsDomainName.Buffer );


        if ( !FLAG_ON( Options, DSROLE_DC_PARENT_TRUST_EXISTS ) ||
             FLAG_ON( Options, DSROLE_DC_CREATE_TRUST_AS_REQUIRED ) ) {

            DsRoleDebugOut(( DEB_TRACE_DS, "Creating trust object ( %lu ) on %ws\n",
                             Options,
                             ParentDc ));

            Status = DsRolepCreateParentTrustObject( CallerToken,
                                                     ParentPolicy,
                                                     LocalDnsInfo,
                                                     Options,
                                                     &AuthInfoEx,
                                                     &ParentTrustedDomain );

            if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

                DSROLEP_FAIL2( RtlNtStatusToDosError( Status ),
                               DSROLERES_PARENT_TRUST_EXISTS, ParentDc, DnsDomainName );

            } else {

                DSROLEP_FAIL2( RtlNtStatusToDosError( Status ),
                               DSROLERES_PARENT_TRUST_FAIL, DnsDomainName, ParentDc );
            }
        }

        //
        // Now the child
        //
        if ( NT_SUCCESS( Status ) ) {

            DSROLEP_CURRENT_OP1( DSROLEEVT_CREATE_TRUST,
                                 LocalDnsInfo->DnsDomainName.Buffer );
            Status = DsRolepCreateChildTrustObject( CallerToken,
                                                    ParentPolicy,
                                                    LocalPolicy,
                                                    ParentDnsDomainInfo,
                                                    LocalDnsInfo,
                                                    &AuthInfoEx,
                                                    Options );


            if ( !NT_SUCCESS( Status ) ) {

                DsRolepLogPrint(( DEB_TRACE,
                                  "DsRolepCreateChildTrustObject failed: 0x%lx\n",
                                  Status ));

            }
            //
            // If we created the parent object, we had better try and delete it now.  Note that
            // it isn't fatal if we can't
            //
            if ( !NT_SUCCESS( Status ) && !FLAG_ON( Options, DSROLE_DC_PARENT_TRUST_EXISTS ) ) {

                NTSTATUS Status2;

                Status2 = ImpLsaDelete( CallerToken, ParentTrustedDomain );

                if ( !NT_SUCCESS( Status2 ) ) {

                    DsRolepLogPrint(( DEB_TRACE,
                                      "LsaDelete of ParentTrustedDomain failed: 0x%lx\n",
                                      Status2 ));

                }


            } else {

                if ( ParentTrustedDomain ) {

                    ImpLsaClose( CallerToken, ParentTrustedDomain );
                }
            }
        }
    }

    LsaFreeMemory( LocalDnsInfo );

    if ( LocalPolicy ) {

        LsaClose( LocalPolicy );
    }

    if ( ParentPolicy ) {

        ImpLsaClose( CallerToken, ParentPolicy );
    }

    // Don't leave the information in the pagefile
    RtlSecureZeroMemory( &AuthInfoEx, sizeof(AuthInfoEx) );
    RtlSecureZeroMemory( &AuthData, sizeof(AuthData) );
    RtlSecureZeroMemory( &GeneratedPassword, sizeof(GeneratedPassword) );

    //
    // We won't bother cleaning up any of the DnsTreeInformation we set on the local machine in
    // the failure case, since it won't hurt anything to have it here.
    //


    return( RtlNtStatusToDosError( Status ) );
}

NTSTATUS
DsRolepHandlePreExistingTrustObject(
                        IN HANDLE Token, OPTIONAL
                        IN LSA_HANDLE Lsa,
                        TRUSTED_DOMAIN_INFORMATION_EX *pTDIEx,
                        TRUSTED_DOMAIN_AUTH_INFORMATION * pAuthInfoEx,
                        IN BOOLEAN ReuseQuarantineBit,
                        OUT PLSA_HANDLE TrustedDomainHandle
                        )
/*++

  This routine does the appropriate handling for the case of the pre existing
  trust object ( ie opening the object, checking if it were the right one
  and then deleting it if required

  Paramters

    Token -- token to impersonate if necessary (used when talking to remote
             server)

    Lsa  Handle to the LSA
    pTDIEx the TDO that is being created that recieved the object name collision error

    ReuseQuarantineBit - If quarantine bit is set on the existing object, do we
                            keep it or erase it?

  Return Values

    STATUS_SUCCESS
    Other Error Codes
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_HANDLE    TrustedDomain = 0;
    ULONG DesiredAccess = DELETE;

    *TrustedDomainHandle = 0;

    // We should have something to go on
    ASSERT(   pTDIEx->Sid
           || (pTDIEx->FlatName.Length > 0)
           || (pTDIEx->Name.Length > 0) );

    if( ReuseQuarantineBit ) {

        DesiredAccess |= TRUSTED_QUERY_DOMAIN_NAME;
    }

    //
    // We have a conflict, either by name or by sid.
    // Try to open by sid, dns domain name, and then flat domain name
    //
    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    if (  (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        && pTDIEx->Sid ) {

        if ( ARGUMENT_PRESENT(Token) ) {

            Status = ImpLsaOpenTrustedDomain( Token,
                                              Lsa,
                                              pTDIEx->Sid,
                                              DesiredAccess,
                                           ( PVOID * )&TrustedDomain);

        } else {

            Status = LsaOpenTrustedDomain( Lsa,
                                           pTDIEx->Sid,
                                           DesiredAccess,
                                           ( PVOID * )&TrustedDomain);

        }


        if ( !NT_SUCCESS( Status ) ) {

            DsRolepLogPrint(( DEB_WARN,
                              "Failed to find trust object by sid: 0x%lx\n",
                              Status ));

            if ( STATUS_NO_SUCH_DOMAIN == Status ) {

                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }

        }
    }

    if ( (Status == STATUS_OBJECT_NAME_NOT_FOUND)
      && pTDIEx->Name.Length > 0   ) {

        //
        // Couldn't find by sid -- try dns name
        //
        if ( ARGUMENT_PRESENT(Token) ) {

            Status = ImpLsaOpenTrustedDomainByName( Token,
                                                    Lsa,
                                                  &pTDIEx->Name,
                                                   DesiredAccess,
                                                 ( PVOID * ) &TrustedDomain );

        } else {

            Status = LsaOpenTrustedDomainByName( Lsa,
                                                &pTDIEx->Name,
                                                 DesiredAccess,
                                                 ( PVOID * ) &TrustedDomain );

        }
        if ( !NT_SUCCESS( Status ) ) {

            WCHAR *BufpTDIEx = NULL;
            DsRolepUnicodestringtowstr( BufpTDIEx, pTDIEx->Name )
            if (BufpTDIEx) {
                DsRolepLogPrint(( DEB_WARN,
                                  "Failed to find trust object for %ws: 0x%lx\n",
                                  BufpTDIEx,
                                  Status ));
                free(BufpTDIEx);
            }
        }
    }

    if ( (Status == STATUS_OBJECT_NAME_NOT_FOUND)
      && pTDIEx->FlatName.Length > 0 ) {

        //
        // Couldn't find by dns name -- try flat name
        //
        if ( ARGUMENT_PRESENT(Token) ) {

            Status = ImpLsaOpenTrustedDomainByName( Token,
                                                    Lsa,
                                                   &pTDIEx->FlatName,
                                                   DesiredAccess,
                                                 ( PVOID * )&TrustedDomain );
        } else {

            Status = LsaOpenTrustedDomainByName( Lsa,
                                                 &pTDIEx->FlatName,
                                                 DesiredAccess,
                                                 ( PVOID * )&TrustedDomain );
        }

        if ( !NT_SUCCESS( Status ) ) {

            WCHAR *BufpTDIEx = NULL;
            DsRolepUnicodestringtowstr( BufpTDIEx, pTDIEx->FlatName )
            if (BufpTDIEx) {
                DsRolepLogPrint(( DEB_WARN,
                                  "Failed to find trust object for %ws: 0x%lx\n",
                                  BufpTDIEx,
                                  Status ));
                free(BufpTDIEx);
            }
        }
    }

    //
    // If reusing the quarantine bit is asked, query the TDO to see
    //  if the domain is quarantined.
    //
    if( NT_SUCCESS( Status ) && ReuseQuarantineBit ) {

        PTRUSTED_DOMAIN_INFORMATION_EX Buffer;

        if( ARGUMENT_PRESENT( Token ) ) {

            Status = ImpLsaQueryInfoTrustedDomain( Token,
                                                   TrustedDomain,
                                                   TrustedDomainInformationEx,
                                                   &Buffer );

        } else {

            Status = LsaQueryInfoTrustedDomain(    TrustedDomain,
                                                   TrustedDomainInformationEx,
                                                   &Buffer );

        }

        //
        // If successfully queried, and the domain is quarantined, then
        //  modify the new object to quarantine as well.
        //
        if( NT_SUCCESS( Status ) ) {

            if( FLAG_ON( Buffer->TrustAttributes, TRUST_ATTRIBUTE_QUARANTINED_DOMAIN ) ) {

                pTDIEx->TrustAttributes |= TRUST_ATTRIBUTE_QUARANTINED_DOMAIN;
            }

            LsaFreeMemory( Buffer );
        }
    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // We found it
        //
        ASSERT( 0 != TrustedDomain );

        if ( ARGUMENT_PRESENT(Token) ) {

            Status = ImpLsaDelete( Token, TrustedDomain );

        }  else {

            Status = LsaDelete( TrustedDomain );

        }

        if ( NT_SUCCESS( Status ) ) {

            //
            // Raise an event that we had deleted an existing trust object
            //
            SpmpReportEvent( TRUE,
                             EVENTLOG_WARNING_TYPE,
                             DSROLERES_INCOMPATIBLE_TRUST,
                             0,
                             sizeof( ULONG ),
                             &Status,
                             1,
                             pTDIEx->Name.Buffer );

            DSROLEP_SET_NON_FATAL_ERROR( 0 );

        } else {

            DsRolepLogPrint(( DEB_WARN,
                              "Failed to delete trust object: 0x%lx\n",
                              Status ));

        }

    } else {

        DsRolepLogPrint(( DEB_WARN,
                          "Couldn't find existing trust object: 0x%lx\n",
                          Status ));

    }

    //
    // At this point, we tried our best to remove the offending object
    // Retry the create
    //
    Status = STATUS_SUCCESS;

    DsRolepLogPrint(( DEB_TRACE, "Attempting to recreate trust object\n" ));


    //
    // Now, let us go ahead and recreate the trust object on the
    // parent
    //
    if ( ARGUMENT_PRESENT(Token) ) {
        Status = ImpLsaCreateTrustedDomainEx( Token,
                                              Lsa,
                                              pTDIEx,
                                              pAuthInfoEx,
                                              DELETE,  // the only thing we do with
                                                    // this handle is delete on
                                                    // failure
                                             &TrustedDomain );

    } else {

        Status = LsaCreateTrustedDomainEx( Lsa,
                                           pTDIEx,
                                           pAuthInfoEx,
                                           DELETE,  // the only thing we do with
                                                    // this handle is delete on
                                                    // failure
                                           &TrustedDomain );
    }

    if ( !NT_SUCCESS( Status ) ) {

        //
        // We want to capture and examine these cases
        //
        WCHAR *BufpTDIEx = NULL;

        ASSERT( NT_SUCCESS( Status ) );

        DsRolepUnicodestringtowstr( BufpTDIEx, pTDIEx->Name )
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Second Trust creation"
                              "with %ws failed with 0x%lx\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        }
    }

    if (NT_SUCCESS(Status))
    {
        *TrustedDomainHandle = TrustedDomain;
    }
    else
    {
        ASSERT(!TrustedDomain);
    }


    return (Status);

}


NTSTATUS
DsRolepCreateParentTrustObject(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ParentLsa,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDnsInfo,
    IN ULONG Options,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    Creates the trusted domain object on the parent domain.  If the object does not exist,
    it will create the object and initialize it with a random password

Arguments:

    CallerToken - token to impersonate when talking to remote server

    ParentLsa - Handle to the Lsa on the parent Dc

    ChildDnsInfo - POLICY_DNS_DOMAIN_INFORMAITON from ourself

    Options - Options that dictate what steps are taken

    TrustedDomainHandle - Where the trusted domain handle is returned

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR GeneratedPassword[ PWLEN + 1 ];
    TRUSTED_DOMAIN_INFORMATION_EX TDIEx;
    LSA_AUTH_INFORMATION AuthData;
    PTRUSTED_DOMAIN_INFORMATION_EX TrustInfoEx = NULL;
    LSA_HANDLE TrustedDomain;
    LARGE_INTEGER Time;
    ULONG Seed, Length = PWLEN, i, Win32Err;
    PSID OpenSid = NULL;
    BOOLEAN DeleteExistingTrust = FALSE;

    RtlCopyMemory( &TDIEx.Name, &ChildDnsInfo->DnsDomainName,
                   sizeof( UNICODE_STRING ) );
    RtlCopyMemory( &TDIEx.FlatName, &ChildDnsInfo->Name,
                   sizeof( UNICODE_STRING ) );
    TDIEx.Sid = ChildDnsInfo->Sid;

    if ( TDIEx.Name.Length &&
         TDIEx.Name.Buffer[ ( TDIEx.Name.Length - 1 ) / sizeof(WCHAR)] == L'.' ) {

        TDIEx.Name.Buffer[ ( TDIEx.Name.Length - 1 ) / sizeof(WCHAR)] = UNICODE_NULL;
        TDIEx.Name.Length -= sizeof(WCHAR);

    }

    TDIEx.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
    TDIEx.TrustType = TRUST_TYPE_UPLEVEL;
    TDIEx.TrustAttributes = TRUST_ATTRIBUTE_WITHIN_FOREST;

    {
        WCHAR *BufpTDIEx = NULL;

        DsRolepLogPrint(( DEB_TRACE, "Creating trusted domain object on parent\n" ));
        DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.Name );
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "\tDnsDomain: %ws\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        }

        DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.FlatName );
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "\tFlat name: %ws\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        }
        DsRolepLogPrint(( DEB_TRACE, "\tDirection: %lu\n", TDIEx.TrustDirection ));
        DsRolepLogPrint(( DEB_TRACE, "\tType: %lu\n", TDIEx.TrustType ));
        DsRolepLogPrint(( DEB_TRACE, "\tAttributes: 0x%lx\n", TDIEx.TrustAttributes ));
    }

    Status = ImpLsaCreateTrustedDomainEx( CallerToken,
                                          ParentLsa,
                                         &TDIEx,
                                          AuthInfoEx,
                                          DELETE,  // we may have to delete on
                                                // rollback
                                       &TrustedDomain );
    if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

        DsRolepLogPrint(( DEB_TRACE, "Parent trust object already exists on parent\n" ));

        //
        // If this is a downlevel upgrade scenario, then we want to use the quarantine
        //  bit of the existing TDO, since it is possible to have a child domain quarantined.
        //

        Status = DsRolepHandlePreExistingTrustObject(
                        CallerToken,
                        ParentLsa,
                        &TDIEx,
                        AuthInfoEx,
                        ( BOOLEAN ) FLAG_ON( Options, DSROLE_DC_DOWNLEVEL_UPGRADE ),
                        &TrustedDomain
                        );


    } else if ( Status != STATUS_SUCCESS ) {

        WCHAR *BufpTDIEx = NULL;

        DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.Name );
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Parent LsaCreateTrustedDomainEx on %ws failed with 0x%lx\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        }

    }

    if ( NT_SUCCESS( Status ) ) {

        *TrustedDomainHandle = TrustedDomain;

    }

    return( Status );
}


#pragma warning(push)
#pragma warning(disable:4701) // Compiler can't tell if TDIEx.TrustDirection is initialized before use

NTSTATUS
DsRolepCreateChildTrustObject(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ParentLsa,
    IN LSA_HANDLE ChildLsa,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsInfo,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDnsInfo,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx,
    IN ULONG Options
    )
/*++

Routine Description:

    Creates the trusted domain object on the child domain.  It does this by reading the
    auth info stored on the parent object, swapping its order, and writing it on the child
    object

Arguments:

    ParentLsa - Handle to the Lsa on the parent Dc

    ChildLsa - Handle to our local Lsa

    ParentDnsInfo - POLICY_DNS_DOMAIN_INFORMATION from our parent Dc

    ChildDnsInfo - POLICY_DNS_DOMAIN_INFORMAITON from ourself

    Options - Options that dictate what steps are taken

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, SecondaryStatus;
    TRUSTED_DOMAIN_INFORMATION_EX TDIEx;
    PTRUSTED_DOMAIN_INFORMATION_EX ParentEx;
    PTRUSTED_DOMAIN_AUTH_INFORMATION ParentAuthData;
    LSA_HANDLE TrustedDomain = 0;
    UNICODE_STRING ChildDnsName;

    //
    // Basically, we'll create a trusted domain object with no auth data, and then pull over the
    // auth data from our parent.
    //
    RtlCopyMemory( &TDIEx.Name, &ParentDnsInfo->DnsDomainName,
                   sizeof( UNICODE_STRING ) );
    RtlCopyMemory( &TDIEx.FlatName, &ParentDnsInfo->Name,
                   sizeof( UNICODE_STRING ) );
    TDIEx.Sid = ParentDnsInfo->Sid;
    TDIEx.TrustAttributes = TRUST_ATTRIBUTE_WITHIN_FOREST;

    //
    // Note that if the parent object exists, we'll want to read it's properties, and
    // set our trust up accordingly
    //
    if ( FLAG_ON( Options, DSROLE_DC_PARENT_TRUST_EXISTS ) ) {

        Status = ImpLsaQueryTrustedDomainInfoByName( CallerToken,
                                                     ParentLsa,
                                                    &ChildDnsInfo->DnsDomainName,
                                                    TrustedDomainInformationEx,
                                                   ( PVOID * )&ParentEx );

        if ( !NT_SUCCESS( Status ) ) {

            WCHAR *BufDnsDomainName = NULL;

            DsRolepUnicodestringtowstr( BufDnsDomainName, ChildDnsInfo->DnsDomainName );
            if (BufDnsDomainName) {
                DsRolepLogPrint(( DEB_TRACE,
                                  "Failed to read trust info from parent for %ws: 0x%lx\n",
                                  BufDnsDomainName,
                                  Status ));
                free(BufDnsDomainName);
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            //
            // Make sure that the trust on the parent object is correct
            //
            if ( ChildDnsInfo->Sid == NULL ||
                 ParentEx->Sid == NULL ||
                 !RtlEqualSid( ChildDnsInfo->Sid, ParentEx->Sid ) ||
                 RtlEqualUnicodeString( &ChildDnsInfo->Name, &ParentEx->Name, TRUE ) ) {

                Status = STATUS_DOMAIN_TRUST_INCONSISTENT;
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            TDIEx.TrustDirection = 0;
            TDIEx.TrustType = 0;
            if ( FLAG_ON( ParentEx->TrustDirection, TRUST_DIRECTION_INBOUND ) ) {

                TDIEx.TrustDirection |= TRUST_DIRECTION_OUTBOUND;
            }

            if ( FLAG_ON( ParentEx->TrustDirection, TRUST_DIRECTION_OUTBOUND ) ) {

                TDIEx.TrustDirection |= TRUST_DIRECTION_INBOUND;
            }

            TDIEx.TrustType = ParentEx->TrustType;

            LsaFreeMemory( ParentEx );
        }

        DSROLEP_FAIL1( RtlNtStatusToDosError( Status ),
                       DSROLERES_NO_PARENT_TRUST, ParentDnsInfo->DnsDomainName.Buffer );


    } else {

        TDIEx.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
        TDIEx.TrustType = TRUST_TYPE_UPLEVEL;

        RtlCopyMemory( &ChildDnsName, &ChildDnsInfo->DnsDomainName, sizeof( UNICODE_STRING ) );
        if ( ChildDnsName.Buffer[ (ChildDnsName.Length - 1) / sizeof(WCHAR)] == L'.' ) {

            ChildDnsName.Buffer[ (ChildDnsName.Length - 1) / sizeof(WCHAR)] = UNICODE_NULL;
            ChildDnsName.Length -= sizeof(WCHAR);

        }
    }

    if ( NT_SUCCESS( Status ) ) {

        {
            WCHAR *BufpTDIEx = NULL;

            DsRolepLogPrint(( DEB_TRACE, "Creating trusted domain object on child\n" ));
            DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.Name );
            if (BufpTDIEx) {
                DsRolepLogPrint(( DEB_TRACE,
                                  "\tDnsDomain: %ws\n",
                                  BufpTDIEx,
                                  Status ));
                free(BufpTDIEx);
            }

            DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.FlatName );
            if (BufpTDIEx) {
                DsRolepLogPrint(( DEB_TRACE,
                                  "\tFlat name: %ws\n",
                                  BufpTDIEx,
                                  Status ));
                free(BufpTDIEx);
            }
            DsRolepLogPrint(( DEB_TRACE, "\tDirection: %lu\n", TDIEx.TrustDirection ));
            DsRolepLogPrint(( DEB_TRACE, "\tType: %lu\n", TDIEx.TrustType ));
            DsRolepLogPrint(( DEB_TRACE, "\tAttributes: 0x%lx\n", TDIEx.TrustAttributes ));
        }

        Status = LsaCreateTrustedDomainEx( ChildLsa,
                                           &TDIEx,
                                           AuthInfoEx,
                                           0,   // no access necessary
                                           &TrustedDomain );

    }

    if (STATUS_OBJECT_NAME_COLLISION==Status)
    {
        //
        // The object might actually exist, in cases we are upgrading from NT4 etc
        //
        DsRolepLogPrint(( DEB_TRACE, "Child domain trust object already exists on child\n" ));

        //
        // Even during NT4 upgrade, we don't want to preserve the quarantine bit, since
        //  quarantining parent will cause unexpected behavior.
        //
        Status = DsRolepHandlePreExistingTrustObject(
                                NULL,
                                ChildLsa,
                                &TDIEx,
                                AuthInfoEx,
                                FALSE,
                                &TrustedDomain
                                );


    }

    if ( !NT_SUCCESS( Status ) ) {

        WCHAR *BufpTDIEx = NULL;

        DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.Name );
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Child LsaCreateTrustedDomainEx on %ws failed with 0x%lx\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        }

        DSROLEP_FAIL1( RtlNtStatusToDosError( Status ),
                       DSROLERES_NO_PARENT_TRUST, ParentDnsInfo->DnsDomainName.Buffer );

    } else {

        //
        // We should have a trusted domain object
        //
        ASSERT( 0 != TrustedDomain );
        if ( TrustedDomain ) {

            LsaClose( TrustedDomain );

        }
    }

    return( Status );
}

#pragma warning(pop)




DWORD
DsRolepRemoveTrustedDomainObjects(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo,
    IN ULONG Options
    )
/*++

Routine Description:

    This function will remove the trusted domain objects as a link is being torn down.
    It will determine who the trust is with, and remove the local trust to that object.
    Optionally, it will also remove the trust from the parent

Arguments:

    ParentDc - Optional name of a Dc on our parent

    ParentDnsDomainInfo - DNS Domain information from the parent

    Options - Whether to remove the parents object or not

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad option was provided

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ParentServer;
    HANDLE LocalPolicy = NULL , ParentPolicy = NULL;
    HANDLE Trust;
    PPOLICY_DNS_DOMAIN_INFO LocalDnsInfo = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;

    DSROLEP_CURRENT_OP0( DSROLEEVT_DELETE_TRUST );

    //
    // If there is no parent Dc, there is no trust...
    //
    if ( ParentDc == NULL ) {

        return( ERROR_SUCCESS );
    }

    //
    // Open both lsas
    //
    RtlInitUnicodeString( &ParentServer, ParentDc );

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = ImpLsaOpenPolicy( CallerToken,
                              &ParentServer,
                              &ObjectAttributes,
                              MAXIMUM_ALLOWED,
                              &ParentPolicy );

    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &LocalPolicy );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "OpenPolicy on %ws failed with 0x%lx\n",
                          ParentDc,
                          Status ));
    }

    //
    // Get the DnsTree information from the local machine
    //
    if ( NT_SUCCESS( Status ) ) {


        Status = LsaQueryInformationPolicy( LocalPolicy,
                                            PolicyDnsDomainInformation,
                                            &LocalDnsInfo );
    }

    //
    // Now, open the parent trusted domain object
    //
    if ( NT_SUCCESS( Status ) && FLAG_ON( Options, DSROLE_DC_DELETE_PARENT_TRUST )  ) {

        Status = ImpLsaOpenTrustedDomain( CallerToken,
                                         ParentPolicy,
                                         LocalDnsInfo->Sid,
                                         DELETE,
                                         &Trust );

        if ( NT_SUCCESS( Status ) ) {

            Status = ImpLsaDelete( CallerToken, Trust );

        } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            Status = STATUS_SUCCESS;

        }

    }

    //
    // Now, the local one
    //
    if ( NT_SUCCESS( Status ) ) {

        Status = LsaOpenTrustedDomain( LocalPolicy,
                                       ParentDnsDomainInfo->Sid,
                                       DELETE,
                                       &Trust );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaDelete( Trust );

        } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            Status = STATUS_SUCCESS;

        }

    }


    //
    // Cleanup
    //
    LsaFreeMemory( LocalDnsInfo );

    if ( LocalPolicy ) {

        LsaClose( LocalPolicy );
    }

    if ( ParentPolicy ) {

        ImpLsaClose( CallerToken, ParentPolicy );
    }

    return( RtlNtStatusToDosError( Status ) );
}



DWORD
DsRolepDeleteParentTrustObject(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDomainInfo
    )
/*++

Routine Description:

    Deletes the trusted domain object on the parent domain.

Arguments:

    ParentDc - Name of a Dc in the parent domain to connect to

    ChildDnsInfo - POLICY_DNS_DOMAIN_INFORMAITON from ourself

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ParentServer;
    HANDLE ParentPolicy = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE ParentTrustedDomain, TrustedDomain;

    RtlInitUnicodeString( &ParentServer, ParentDc );

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = ImpLsaOpenPolicy( CallerToken,
                              &ParentServer,
                              &ObjectAttributes,
                               POLICY_TRUST_ADMIN|POLICY_VIEW_LOCAL_INFORMATION,
                              &ParentPolicy );

    if ( NT_SUCCESS( Status ) ) {

        Status = ImpLsaOpenTrustedDomain( CallerToken,
                                          ParentPolicy,
                                          ChildDomainInfo->Sid,
                                          DELETE,
                                         &TrustedDomain );

        if ( NT_SUCCESS( Status ) ) {

            Status = ImpLsaDelete( CallerToken, TrustedDomain );

            if ( !NT_SUCCESS( Status ) ) {

                ImpLsaClose( CallerToken, TrustedDomain );
            }
        }

        ImpLsaClose( CallerToken, ParentPolicy );
    }


    return( RtlNtStatusToDosError( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\threadman.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetp.ch

Abstract:

    Routines the

Author:

    Colin Brace        (ColinBr)    April 5, 1999
Environment:

    User Mode

Revision History:

    Mac McLain          (MacM)       Feb 10, 1997
    
--*/
#ifndef __THREADMAN_H__
#define __THREADMAN_H__

//
// Arguments for the promote thread
//
typedef struct _DSROLEP_OPERATION_PROMOTE_ARGS {

    LPWSTR DnsDomainName;
    LPWSTR FlatDomainName;
    LPWSTR SiteName;
    LPWSTR DsDatabasePath;
    LPWSTR DsLogPath;
    IFM_SYSTEM_INFO * pIfmSystemInfo;
    LPWSTR SysVolRootPath;
    UNICODE_STRING Bootkey;
    LPWSTR Parent;
    LPWSTR Server;
    LPWSTR Account;
    UNICODE_STRING Password;
    UNICODE_STRING DomainAdminPassword;
    ULONG Options;
    HANDLE ImpersonateToken;
    UCHAR Decode;
    UNICODE_STRING SafeModePassword;
} DSROLEP_OPERATION_PROMOTE_ARGS, *PDSROLEP_OPERATION_PROMOTE_ARGS;

//
// Argument threads for the demotion thread
//
typedef struct _DSROLEP_OPERATION_DEMOTE_ARGS {

    DSROLE_SERVEROP_DEMOTE_ROLE ServerRole;
    LPWSTR DomainName;
    LPWSTR Account;
    UNICODE_STRING Password;
    BOOLEAN LastDcInDomain;
    ULONG  cRemoveNCs;
    LPWSTR * pszRemoveNCs;
    UNICODE_STRING AdminPassword;
    ULONG Options;
    HANDLE ImpersonateToken;
    UCHAR Decode;
} DSROLEP_OPERATION_DEMOTE_ARGS, *PDSROLEP_OPERATION_DEMOTE_ARGS;


//
// Prototypes for thread functions
//
DWORD
DsRolepThreadPromoteDc(
    IN PVOID ArgumentBlock
    );

DWORD
DsRolepThreadPromoteReplica(
    IN PVOID ArgumentBlock
    );

DWORD
DsRolepThreadDemote(
    IN PVOID ArgumentBlock
    );

DWORD
DsRolepSpinWorkerThread(
    IN DSROLEP_OPERATION_TYPE Operation,
    IN PVOID ArgumentBlock
    );

DWORD
DsRolepBuildPromoteArgumentBlock(
    IN LPWSTR DnsDomainName,
    IN LPWSTR FlatDomainName,
    IN LPWSTR SiteName,
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN IFM_SYSTEM_INFO * pIfmSystemInfo,
    IN LPWSTR SystemVolumeRootPath,
    IN PUNICODE_STRING Bootkey,
    IN LPWSTR Parent,
    IN LPWSTR Server,
    IN LPWSTR Account,
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING DomainAdminPassword,
    IN PUNICODE_STRING SafeModeAdminPassword,
    IN ULONG Options,
    IN UCHAR PasswordSeed,
    IN OUT PDSROLEP_OPERATION_PROMOTE_ARGS *Promote
    );

DWORD
DsRolepBuildDemoteArgumentBlock(
    IN DSROLE_SERVEROP_DEMOTE_ROLE ServerRole,
    IN LPWSTR DnsDomainName,
    IN LPWSTR Account,
    IN PUNICODE_STRING Password,
    IN ULONG Options,
    IN BOOL LastDcInDomain,
    IN ULONG cRemoveNCs,
    IN LPWSTR * pszRemoveNCs,
    IN PUNICODE_STRING DomainAdminPassword,
    IN UCHAR PasswordSeed,
    OUT PDSROLEP_OPERATION_DEMOTE_ARGS *Demote
    );


VOID
DsRolepFreeArgumentBlock(
    IN PVOID ArgumentBlock,
    IN BOOLEAN Promote
    );

#endif // __THREADMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\threadman.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    threadman.c

Abstract:

    Implementation of the thread and thread management routines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmsname.h>
#include <loadfn.h>
#include <lsarpc.h>
#include <db.h>
#include <lsasrvmm.h>
#include <lsaisrv.h>
#include <lmaccess.h>
#include <netsetp.h>
#include <samrpc.h>   // for samisrv.h
#include <samisrv.h>  // for nlrepl.h
#include <nlrepl.h>   // for I_NetNotifyDsChange
#include <Lmshare.h>  // for NetShareDel()
#include <autoenr.h>  // for CertAutoRemove()

#include "secure.h"
#include "services.h"
#include "upgrade.h"
#include "trustdom.h"
#include "sysvol.h"
#include "lsa.h"
#include "ds.h"

#include "threadman.h"


// forward from setutl.h
DWORD
DsRolepDeregisterNetlogonDnsRecords(
    PNTDS_DNS_RR_INFO pInfo
    );

//
// Helpful macros
//
#define DSROLEP_MAKE_DNS_RELATIVE(name)                                         \
if(name) {                                                                      \
    DWORD _StripAbsoluteLength_ = wcslen( name );                               \
    if ( *(name + _StripAbsoluteLength_ - 1 ) == L'.' ) {                       \
        *(name + _StripAbsoluteLength_ - 1 ) = UNICODE_NULL;                    \
    }                                                                           \
}

#define DSROLEP_ALLOC_AND_COPY_STRING_EXIT( dest, src, label )                                  \
if ( (src) ) {                                                                                  \
    (dest) = RtlAllocateHeap( RtlProcessHeap(), 0, (wcslen( (src) ) + 1) * sizeof( WCHAR ) );   \
    if ( !(dest) ) {                                                                            \
        goto label;                                                                             \
    } else {                                                                                    \
        wcscpy((dest), (src));                                                                  \
    }                                                                                           \
} else {                                                                                        \
    (dest) = NULL;                                                                              \
}

#define DSROLEP_ALLOC_BYTES( dest, src, size, label )                                  \
if ( (src) ) {                                                                                  \
    (dest) = RtlAllocateHeap( RtlProcessHeap(), 0, (size));   \
    if ( !(dest) ) {                                                                            \
        goto label;                                                                             \
    }                                                                                          \
} else {                                                                                        \
    (dest) = NULL;                                                                              \
}

#define DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( dest, src, label )                          \
if ( (src) && (src)->Buffer ) {                                                                                  \
    (dest)->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, (src)->MaximumLength );              \
    if ( (dest)->Buffer == NULL ) {                                                             \
        goto label;                                                                             \
    } else {                                                                                    \
        (dest)->Length = (src)->Length;                                                         \
        (dest)->MaximumLength = (src)->MaximumLength;                                           \
        RtlCopyMemory( (dest)->Buffer, (src)->Buffer, (src)->MaximumLength );                   \
    }                                                                                           \
} else {                                                                                        \
    RtlZeroMemory( (dest), sizeof( UNICODE_STRING ) );                                          \
}


//
// Function definitions
//
DWORD                        
DsRolepBuildPromoteArgumentBlock(
    IN LPWSTR DnsDomainName,
    IN LPWSTR FlatDomainName,
    IN LPWSTR SiteName,
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN IFM_SYSTEM_INFO * pIfmSystemInfo,
    IN LPWSTR SystemVolumeRootPath,
    IN PUNICODE_STRING Bootkey,
    IN LPWSTR Parent,
    IN LPWSTR Server,
    IN LPWSTR Account,
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING DomainAdminPassword,
    IN PUNICODE_STRING SafeModePassword,
    IN ULONG Options,
    IN UCHAR PasswordSeed,
    IN OUT PDSROLEP_OPERATION_PROMOTE_ARGS *Promote
    )
/*++

Routine Description:

    Builds an argument structure to pass into one of the promote worker functions.  Since the
    rpc call will return before the thread completes, we'll have to copy all our argument strings.

    Since parameters may be changed through out the course of promotion, we assume allocations
    are made from the process heap.


    Resultant argument block should be freed via DsRolepFreeArgumentBlock

Arguments:

    DnsDomainName - Dns domain name of the domain to install

    FlatDomainName - Flat (NetBIOS) domain name of the domain to install

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go
    
    pIfmSystemInfo - Information about the IFM system and restore media used to
        dcpromo off.  If NULL, not an IFM promotion.

    SystemVolumeRootPath - Absolute path on the local machine to be the root of the system
        volume root path.
        
    Bootkey - Needed when you don't have the key in the registry or on a disk
    
    cbBootkey - size of the bootkey

    Parent - Optional.  Parent domain name

    Server -- Optional.  Replica partner or server in parent domain

    Account - User account to use when setting up as a child domain

    Password - Password to use with the above account

    DomainAdminPassword - Password to set the domain administartor account

    Options - Options to control the creation of the domain

    PasswordSeed - Seed used to hide the passwords

    Promote - Where the allocated argument block is returned


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD WinError = ERROR_NOT_ENOUGH_MEMORY;

    *Promote = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( DSROLEP_OPERATION_PROMOTE_ARGS ) );
    if ( *Promote == NULL ) {

        goto BuildPromoteDone;
    }

    RtlZeroMemory( *Promote, sizeof( DSROLEP_OPERATION_PROMOTE_ARGS ) );

    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->DnsDomainName, DnsDomainName, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->FlatDomainName, FlatDomainName, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->SiteName, SiteName, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->DsDatabasePath, DsDatabasePath, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->DsLogPath, DsLogPath, BuildPromoteDone );
    (*Promote)->pIfmSystemInfo = pIfmSystemInfo; // guaranteed to be good through promotion.

    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->SysVolRootPath, SystemVolumeRootPath, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->Parent, Parent, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->Server, Server, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->Account, Account, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Promote)->Password), Password,
                                                BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Promote)->DomainAdminPassword),
                                                DomainAdminPassword, BuildPromoteDone );

    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Promote)->SafeModePassword),
                                                SafeModePassword, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Promote)->Bootkey),
                                                Bootkey, BuildPromoteDone );
    (*Promote)->Options = Options;
    (*Promote)->Decode = PasswordSeed;

    WinError = DsRolepGetImpersonationToken( &(*Promote)->ImpersonateToken );

BuildPromoteDone:

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepFreeArgumentBlock( Promote, TRUE );
    }

    return( WinError );
}




DWORD
DsRolepBuildDemoteArgumentBlock(
    IN DSROLE_SERVEROP_DEMOTE_ROLE ServerRole,
    IN LPWSTR DnsDomainName,
    IN LPWSTR Account,
    IN PUNICODE_STRING Password,
    IN ULONG Options,
    IN BOOL LastDcInDomain,
    IN ULONG cRemoveNCs,
    IN LPWSTR * pszRemoveNCs,
    IN PUNICODE_STRING AdminPassword,
    IN UCHAR PasswordSeed,
    IN OUT PDSROLEP_OPERATION_DEMOTE_ARGS *Demote
    )
/*++

Routine Description:

    Builds an argument structure to pass into the demote worker functions.  Since the rpc call
    will return before the thread completes, we'll have to copy all our argument strings.

    Resultant argument block should be freed via DsRolepFreeArgumentBlock

Arguments:

    ServerRole - New role for the server

    DnsDomainName - Dns domain name of the domain to uninstall.  NULL means all of them

    Account - User account to use when setting up as a child domain

    Password - Password to use with the above account

    Options - Options to control the creation of the domain

    LastDcInDomain - If TRUE, the Dc being demoted is the last Dc in the domain.

    AdminPassword - Password to set on the administrator account if it is a new install

    PasswordSeed - Seed used to hide the passwords

    Demote - Where the allocated argument block is returned


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD WinError = ERROR_NOT_ENOUGH_MEMORY;
    ULONG i;

    *Demote = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( DSROLEP_OPERATION_DEMOTE_ARGS ) );

    if ( *Demote == NULL ) {

        goto BuildDemoteDone;
    }

    RtlZeroMemory( *Demote, sizeof( DSROLEP_OPERATION_DEMOTE_ARGS ) );

    (*Demote)->ServerRole = ServerRole;
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Demote)->DomainName, DnsDomainName, BuildDemoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Demote)->Account, Account, BuildDemoteDone );
    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Demote)->Password), Password, BuildDemoteDone );
    (*Demote)->LastDcInDomain = ( LastDcInDomain != 0 );
    (*Demote)->cRemoveNCs = cRemoveNCs;
    DSROLEP_ALLOC_BYTES( (*Demote)->pszRemoveNCs, pszRemoveNCs, (cRemoveNCs * sizeof(LPWSTR)), BuildDemoteDone );
    for(i = 0; i < cRemoveNCs; i++){
        DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Demote)->pszRemoveNCs[i], pszRemoveNCs[i], BuildDemoteDone );
    }

    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Demote)->AdminPassword),
                                                AdminPassword,
                                                BuildDemoteDone );
    (*Demote)->Options = Options;
    (*Demote)->Decode = PasswordSeed;

    WinError = DsRolepGetImpersonationToken( & (*Demote)->ImpersonateToken );

BuildDemoteDone:

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepFreeArgumentBlock( Demote, FALSE );
    }

    return( WinError );
}



VOID
DsRolepFreeArgumentBlock(
    IN PVOID *ArgumentBlock,
    IN BOOLEAN Promote
    )
/*++

Routine Description:

    Frees an arugment block allocated via DsRolepBuildPromote/DemoteArgumentBlock
    Since parameters may be changed through out the course of promotion, we assume allocations
    are made from the process heap.

Arguments:

    ArgumentBlock - Argument block to free

    Promote - If TRUE, this is a promote argument block.  If FALSE, it's a demote arg block

Returns:

    VOID

--*/
{
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArg;
    PDSROLEP_OPERATION_DEMOTE_ARGS Demote;
    PVOID HeapHandle = RtlProcessHeap();
    ULONG i;

    if ( !ArgumentBlock ) {

        return;
    }

    //
    // Free it all
    //
    if ( Promote ) {

        PromoteArg = ( PDSROLEP_OPERATION_PROMOTE_ARGS )*ArgumentBlock;

        RtlFreeHeap( HeapHandle, 0, PromoteArg->DnsDomainName );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->FlatDomainName );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->SiteName );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->DsDatabasePath );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->DsLogPath );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->SysVolRootPath );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->Parent );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->Server );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->Account );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->Password.Buffer );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->DomainAdminPassword.Buffer );

        if ( PromoteArg->ImpersonateToken ) {

            NtClose( PromoteArg->ImpersonateToken );
        }

    } else {

        Demote = ( PDSROLEP_OPERATION_DEMOTE_ARGS )*ArgumentBlock;
        RtlFreeHeap( HeapHandle, 0, Demote->Account );
        RtlFreeHeap( HeapHandle, 0, Demote->Password.Buffer );
        RtlFreeHeap( HeapHandle, 0, Demote->DomainName );
        RtlFreeHeap( HeapHandle, 0, Demote->AdminPassword.Buffer );
        for(i = 0; i < Demote->cRemoveNCs; i++){
            RtlFreeHeap( HeapHandle, 0, Demote->pszRemoveNCs[i] );
        }
        RtlFreeHeap( HeapHandle, 0, Demote->pszRemoveNCs );
        if ( Demote->ImpersonateToken ) {

            NtClose( Demote->ImpersonateToken );
        }
    }

    RtlFreeHeap( HeapHandle, 0, *ArgumentBlock );
}



DWORD
DsRolepSpinWorkerThread(
    IN DSROLEP_OPERATION_TYPE Operation,
    IN PVOID ArgumentBlock
    )
/*++

Routine Description:

    This function actually creates the worker thread that will do the promot/demote


Arguments:

    Operation - Demote, Promote as DC, or Promote as Replica

    ArgumentBlock - Block of arguments appropriate for the operation


Returns:

    ERROR_SUCCESS - Success

    INVALID_PARAMETER - An unexpected operation type encounterd

--*/
{
    DWORD WinError = ERROR_SUCCESS, IgnoreError;
    NTSTATUS NtStatus;
    DWORD ThreadId;

    //
    // The basic premise is that we'll utilize the Completion event to indicate when
    // the thread is full initialized.
    //
    NtStatus = NtResetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );
    WinError = RtlNtStatusToDosError( NtStatus );

    if ( ERROR_SUCCESS == WinError ) {

        switch ( Operation) {
        case DSROLEP_OPERATION_DC:

            DsRolepCurrentOperationHandle.OperationThread = CreateThread(
                        NULL,
                        0,
                        ( LPTHREAD_START_ROUTINE )DsRolepThreadPromoteDc,
                        ArgumentBlock,
                        0,
                        &ThreadId );
            break;


        case DSROLEP_OPERATION_REPLICA:

            DsRolepCurrentOperationHandle.OperationThread = CreateThread(
                        NULL,
                        0,
                        ( LPTHREAD_START_ROUTINE )DsRolepThreadPromoteReplica,
                        ArgumentBlock,
                        0,
                        &ThreadId );
            break;

        case DSROLEP_OPERATION_DEMOTE:

            DsRolepCurrentOperationHandle.OperationThread = CreateThread(
                        NULL,
                        0,
                        ( LPTHREAD_START_ROUTINE )DsRolepThreadDemote,
                        ArgumentBlock,
                        0,
                        &ThreadId );
            break;

        default:

            DsRoleDebugOut(( DEB_ERROR,
                             "Unexpected operation %lu encountered\n", Operation ));

            WinError = ERROR_INVALID_PARAMETER;
            break;


        }

        //
        // Check for failure
        //
        if ( WinError == ERROR_SUCCESS &&
             DsRolepCurrentOperationHandle.OperationThread == NULL ) {

             WinError = GetLastError();
        }


        //
        // If it worked, wait for the thread to indicate its ready
        //
        if ( WinError == ERROR_SUCCESS ) {

            if ( WaitForSingleObject( DsRolepCurrentOperationHandle.CompletionEvent,
                                      INFINITE ) == WAIT_FAILED ) {

                WinError = GetLastError();

            } else {

                NtResetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );
            }
        }

    }

    if ( WinError == ERROR_SUCCESS ) {

        DsRoleDebugOut(( DEB_TRACE,
                         "Thread %lu successfully started\n", ThreadId ));

    } else {

        DsRolepLogPrint(( DEB_ERROR,
                             "Thread %lu unsuccessfully started: %lu\n", ThreadId, WinError ));

    }


    return( WinError );
}




DWORD
DsRolepThreadPromoteDc(
    IN PVOID ArgumentBlock
    )
/*++

Routine Description:

    This function actually "promotes" a server to a dc of an new domain.  Additionally, this
    domain can be set up as a child of an existing domain. This is accomplished by:
        Installing the Ds as a replica
        Setting the DnsDomainTree LSA information
        Optionally configuring it as a child of an existing domain
        Configuring the KDC

Arguments:

    ArgumentBlock - Block of arguments appropriate for the operation


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD IgnoreError;
    PWSTR ParentDc = NULL;
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs = ( PDSROLEP_OPERATION_PROMOTE_ARGS )ArgumentBlock;
    DSROLEP_DOMAIN_POLICY_INFO BackupDomainPolicyInfo;
    ULONG FindOptions;
    GUID DomainGuid;
    PWSTR InstalledSite = NULL;
    PSID NewDomainSid = NULL;
    PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo = NULL;
    PWSTR DnsDomainTreeName = NULL;


    //
    // BOOLEAN's to maintain state
    //
    // N.B. The order of these booleans is the order in which they
    //      are changed -- please maintain order and make sure that
    //      the PromoteUndo section undoes them in the reverse order
    //
    BOOLEAN IPCConnection                   = FALSE;  // resource -- release on exit
    BOOLEAN RestartNetlogon                 = FALSE;
    BOOLEAN SysVolCreated                   = FALSE;
    BOOLEAN CleanupNetlogon                 = FALSE;  // nothing to undo
    BOOLEAN DsInstalled                     = FALSE;
    BOOLEAN DsRunning                       = FALSE;
    BOOLEAN DomainPolicyInfoChanged         = FALSE;
    BOOLEAN DomainServicesChanged           = FALSE; 
    BOOLEAN DomainControllerServicesChanged = FALSE; 
    BOOLEAN TrustCreated                    = FALSE;
    BOOLEAN ProductTypeChanged              = FALSE;

    //
    // Init the stack space
    //
    RtlZeroMemory(&BackupDomainPolicyInfo, sizeof(BackupDomainPolicyInfo));

    //
    // Set our event to indicate we're starting
    //
    NtSetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );

    //
    // If we have an existing domain in the forest to install from and we
    // weren't given a site or source server name, we need to make a dsgetdc
    // name.
    //
    if ( PromoteArgs->Server ) {

        ParentDc = PromoteArgs->Server;
        
    }

    if ( PromoteArgs->Parent != NULL  &&
         ( (PromoteArgs->Server == NULL) 
        || (PromoteArgs->SiteName == NULL) )    ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "No source DC or no site name specified. Searching for dc in domain %ws: ( DS_REQUIRED | WRITABLE )\n",
                          PromoteArgs->Parent ));


        DSROLEP_CURRENT_OP1( DSROLEEVT_SEARCH_DC, PromoteArgs->Parent );

        FindOptions = DS_DIRECTORY_SERVICE_REQUIRED | DS_WRITABLE_REQUIRED | DS_FORCE_REDISCOVERY | DS_RETURN_DNS_NAME;

        WinError = DsGetDcName(NULL, 
                               PromoteArgs->Parent, 
                               NULL, 
                               NULL,
                               FindOptions,
                              &DomainControllerInfo );

        if ( ERROR_SUCCESS != WinError ) { 

            DsRolepLogPrint(( DEB_TRACE, 
                             "Couldn't find domain controller in domain %ws (error: %d)\n", 
                             ParentDc,
                             WinError ));

            if ( PromoteArgs->Server == NULL ) {

                //
                // This is a fatal error if we can't find a dc in the parent domain
                // If we have a server, then we can derive a site name later on if
                // necessary
                //
                DSROLEP_FAIL1( WinError, DSROLERES_FIND_DC, PromoteArgs->Parent );
    
                DsRolepLogPrint(( DEB_ERROR,
                                  "Failed to find a dc for %ws: %lu\n",
                                  PromoteArgs->Parent,
                                  WinError ));
    
                goto PromoteUndo;
            
            }

            //
            // This isn't fatal since we are a source server
            //
            DsRolepLogPrint(( DEB_TRACE, "Using supplied domain controller: %ws\n", ParentDc ));
            WinError = ERROR_SUCCESS;

        } else {

            //
            // The dsgetdcname succeeded
            //
            if ( PromoteArgs->Server == NULL ) {

                //
                // Use the found domain controller
                //

                DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_DC,
                                     PromoteArgs->Parent,
                                     ParentDc );
    
                DsRolepLogPrint(( DEB_TRACE_DS, "No user specified source DC\n" ));
                ParentDc = DomainControllerInfo->DomainControllerName;
    
            }

            //
            // Determine the site that we are going to be installed in
            // the results of the parent query
            //
            if ( PromoteArgs->SiteName == NULL ) {
    
                DsRolepLogPrint(( DEB_TRACE_DS, "No user specified site\n" ));
    
                PromoteArgs->SiteName = DomainControllerInfo->ClientSiteName;
    
                if ( (PromoteArgs->SiteName == NULL) 
                  && (!_wcsicmp(ParentDc, DomainControllerInfo->DomainControllerName))  ) {
    
                    DsRolepLogPrint(( DEB_TRACE_DS, "This machine is not in a configured site ... using source DC's site.\n" ));
    
                    PromoteArgs->SiteName = DomainControllerInfo->DcSiteName;
    
                } else {
    
                    //
                    // We can't find a site.  That's ok -- the ds will find one for
                    // us
                    //
                }

            }

            if ( PromoteArgs->SiteName ) {
                
                DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_SITE,
                                     PromoteArgs->SiteName,
                                     PromoteArgs->Parent );
            } else {
    
                DsRolepLogPrint(( DEB_TRACE_DS, "This machine is not in a configured site\n" ));
            }
        }

    } else {

        //
        // The caller supplied both the source server and site name
        //
        ParentDc = PromoteArgs->Server;

        DsRolepLogPrint(( DEB_TRACE, "Using supplied domain controller: %ws\n", ParentDc ));
        DsRolepLogPrint(( DEB_TRACE, "Using supplied site: %ws\n", PromoteArgs->SiteName ));
    }

    //
    // Ok, we have determined the our source domain controller and destination
    // site
    //

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Force the time synch
    //
    if (   ParentDc 
        && FLAG_ON( PromoteArgs->Options, DSROLE_DC_FORCE_TIME_SYNC ) ) {

        

        WinError = DsRolepForceTimeSync( PromoteArgs->ImpersonateToken,
                                         ParentDc );

        if ( ERROR_SUCCESS != WinError ) {

           DsRolepLogPrint(( DEB_WARN, "Time sync with %ws failed with %d\n",
                             ParentDc,
                             WinError ));

        //
           // This is not a fatal error
           //
           WinError = ERROR_SUCCESS;

        }
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // If we are setting up a child domain, establish a session first
    //
    if ( ParentDc ) {

        RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
        WinError = ImpNetpManageIPCConnect( PromoteArgs->ImpersonateToken,
                                            ParentDc,
                                            PromoteArgs->Account,
                                            PromoteArgs->Password.Buffer,
                                            NETSETUPP_CONNECT_IPC );

        RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
        if ( ERROR_SUCCESS != WinError ) {

            DSROLEP_FAIL1( WinError, DSROLERES_NET_USE, ParentDc );
            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to establish the session with %ws: 0x%lx\n", ParentDc,
                              WinError ));
            goto PromoteUndo;

        }
        IPCConnection = TRUE;

    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // If we have a parent dc, get the LSA policy from it
    //

    //
    // Strip the trailing '.' from the Dns name if we happen to have an absolute name
    //
    DSROLEP_MAKE_DNS_RELATIVE( PromoteArgs->DnsDomainName );
    DnsDomainTreeName = PromoteArgs->DnsDomainName;
    if ( ParentDc ) {

        NTSTATUS Status;
        UNICODE_STRING ParentServer;
        HANDLE ParentPolicy = NULL;
        OBJECT_ATTRIBUTES ObjectAttributes;

        DSROLEP_CURRENT_OP1( DSROLEEVT_MACHINE_POLICY, ParentDc );

        RtlInitUnicodeString( &ParentServer, ParentDc );

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = ImpLsaOpenPolicy( PromoteArgs->ImpersonateToken,
                                       &ParentServer,
                                       &ObjectAttributes,
                                        MAXIMUM_ALLOWED,
                                       &ParentPolicy );

        if ( NT_SUCCESS( Status ) ) {

            Status = ImpLsaQueryInformationPolicy( PromoteArgs->ImpersonateToken,
                                                   ParentPolicy,
                                                   PolicyDnsDomainInformation,
                                                  &ParentDnsDomainInfo );

            ImpLsaClose( PromoteArgs->ImpersonateToken, ParentPolicy );
        }

        //
        // We'll have to build it as a NULL terminated string
        //
        if ( NT_SUCCESS( Status ) && ParentDnsDomainInfo->DnsForestName.Length  ) {

            if ( ParentDnsDomainInfo->DnsForestName.Buffer[
                    ParentDnsDomainInfo->DnsForestName.Length / sizeof( WCHAR ) ] == UNICODE_NULL ) {

                DnsDomainTreeName = ( PWSTR )ParentDnsDomainInfo->DnsForestName.Buffer;

            } else {

                DnsDomainTreeName = RtlAllocateHeap(
                                        RtlProcessHeap(), 0,
                                        ParentDnsDomainInfo->DnsForestName.Length + sizeof( WCHAR ) );

                if ( DnsDomainTreeName == NULL ) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    RtlCopyMemory( DnsDomainTreeName,
                                   ParentDnsDomainInfo->DnsForestName.Buffer,
                                   ParentDnsDomainInfo->DnsForestName.Length );

                    DnsDomainTreeName[ ParentDnsDomainInfo->DnsForestName.Length /
                                                                sizeof( WCHAR ) ] = UNICODE_NULL;
                }
            }

        }


        WinError = RtlNtStatusToDosError( Status );

        DSROLEP_FAIL1( WinError, DSROLERES_POLICY_READ_REMOTE, ParentDc );

        if ( ERROR_SUCCESS != WinError ) {

            goto PromoteUndo;

        }
    }


    //
    // If we are doing a root install, make sure we were given the forest root
    // as our parent
    //
    if ( FLAG_ON( PromoteArgs->Options, DSROLE_DC_TRUST_AS_ROOT ) ) {

         DSROLEP_MAKE_DNS_RELATIVE( PromoteArgs->Parent );
         DSROLEP_MAKE_DNS_RELATIVE( DnsDomainTreeName );
         if ( _wcsicmp( PromoteArgs->Parent, DnsDomainTreeName ) ) {

            //
            // Names don't match... We can't allow this...
            //
            DsRolepLogPrint(( DEB_ERROR,
                              "Tried to specify domain %ws as a forest root but "
                              "%ws is the actual root\n",
                              PromoteArgs->Parent,
                              DnsDomainTreeName ));

            WinError = ERROR_INVALID_DOMAINNAME;
            DSROLEP_FAIL1( WinError, DSROLERES_NOT_FOREST_ROOT, PromoteArgs->Parent );

            goto PromoteUndo;
         }
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Make a back up of the local policy...
    //
    WinError = DsRolepBackupDomainPolicyInfo( NULL, &BackupDomainPolicyInfo );

    if ( ERROR_SUCCESS != WinError ) {

        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_READ_LOCAL );

        goto PromoteUndo;
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Stop netlogon
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_STOP_SERVICE, SERVICE_NETLOGON );
    WinError = DsRolepStopNetlogon( &RestartNetlogon );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_WARN, "Failed to stop NETLOGON (%d)\n", WinError ));

        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Stopped NETLOGON\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Create the system volume information so we can seed the system volume while the Ds is
    // installing
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_CREATE_SYSVOL, PromoteArgs->SysVolRootPath );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    WinError = DsRolepCreateSysVolPath( PromoteArgs->SysVolRootPath,
                                        PromoteArgs->DnsDomainName,
                                        ParentDc,
                                        PromoteArgs->Account,
                                        PromoteArgs->Password.Buffer,
                                        PromoteArgs->SiteName,
                                        TRUE );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );

    DSROLEP_CURRENT_OP1( DSROLEEVT_SVSETUP, PromoteArgs->SysVolRootPath );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to create the system volume (%d)\n", WinError ));
        goto PromoteUndo;

    }
    SysVolCreated = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Created the system volume\n" ));
    
    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Setup the Ds
    //
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->DomainAdminPassword );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->SafeModePassword );
    WinError = DsRolepInstallDs( PromoteArgs->DnsDomainName,
                                 PromoteArgs->FlatDomainName,
                                 DnsDomainTreeName,
                                 PromoteArgs->SiteName,
                                 PromoteArgs->DsDatabasePath,
                                 PromoteArgs->DsLogPath,
                                 PromoteArgs->pIfmSystemInfo,
                                 PromoteArgs->SysVolRootPath,
                                 &(PromoteArgs->Bootkey),
                                 PromoteArgs->DomainAdminPassword.Buffer,
                                 PromoteArgs->Parent,
                                 ParentDc,
                                 PromoteArgs->Account,
                                 PromoteArgs->Password.Buffer,
                                 PromoteArgs->SafeModePassword.Buffer,
                                 PromoteArgs->Parent,
                                 PromoteArgs->Options,
                                 FALSE,
                                 PromoteArgs->ImpersonateToken,
                                 &InstalledSite,
                                 &DomainGuid,
                                 &NewDomainSid );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->DomainAdminPassword );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->SafeModePassword );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to install the directory service (%d)\n", WinError ));
        goto PromoteUndo;
    }
    DsRunning = TRUE;
    DsInstalled = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Installed the directory service\n", WinError ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the LSA domain policy
    //
    WinError = DsRolepSetLsaDomainPolicyInfo( PromoteArgs->DnsDomainName,
                                              PromoteArgs->FlatDomainName,
                                              DnsDomainTreeName,
                                              &DomainGuid,
                                              NewDomainSid,
                                              NTDS_INSTALL_DOMAIN,
                                              &BackupDomainPolicyInfo );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the LSA policy (%d)\n", WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_WRITE_LOCAL );

        goto PromoteUndo;
    }
    DomainPolicyInfoChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Set the LSA policy\n"));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Configure the domain relative services
    //
    WinError = DsRolepConfigureDomainServices( DSROLEP_SERVICES_ON  );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to configure the domain services (%d)\n", WinError ));

        goto PromoteUndo;

    }
    DomainServicesChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Configured the domain services\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Configure the domain controller relative services
    //
    WinError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_ON );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to configure the domain controller services (%d)\n", WinError ));
        goto PromoteUndo;

    }
    DomainControllerServicesChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Configured the domain controller services\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Finally, upgrade the Lsa to the Ds.
    //
    WinError = DsRolepUpgradeLsaToDs( TRUE );

    if ( ERROR_SUCCESS != WinError ) {

        DSROLEP_FAIL0( WinError, DSROLERES_LSA_UPGRADE );
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Upgrade of the LSA into the DS failed with %lu\n",
                                                WinError )) );

        goto PromoteUndo;
        
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );
    

    //
    // Create the trust objects and set the DnsDomainTree information
    //
    if ( ParentDc ) {

        WinError = DsRolepCreateTrustedDomainObjects( PromoteArgs->ImpersonateToken,
                                                      ParentDc,
                                                      PromoteArgs->DnsDomainName,
                                                      ParentDnsDomainInfo,
                                                      PromoteArgs->Options );
        if ( WinError != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR, "Failed to create trusted domain objects (%d)\n", WinError ));

            goto PromoteUndo;

        }
        TrustCreated = TRUE;

        DsRolepLogPrint(( DEB_TRACE, "Created trusted domain objects\n" ));
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Create the GPO for policy
    //
    WinError = ( *DsrSceDcPromoCreateGPOsInSysvolEx )( PromoteArgs->ImpersonateToken,
                                                       PromoteArgs->DnsDomainName,
                                                       PromoteArgs->SysVolRootPath,
                                                       FLAG_ON( PromoteArgs->Options,
                                                                  DSROLE_DC_DOWNLEVEL_UPGRADE ) ?
                                                                    SCE_PROMOTE_FLAG_UPGRADE :
                                                                    0,
                                                       DsRolepStringUpdateCallback );

    if ( ERROR_SUCCESS != WinError ) {
        
        DSROLEP_FAIL1( WinError, DSROLERES_GPO_CREATION, PromoteArgs->DnsDomainName );
    
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Creation of GPO failed with %lu\n",
                                               WinError )) );
        goto PromoteUndo;

    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Created GPO\n" ));
    

    //
    // Stop the Ds
    //
    DsRolepStopDs( DsRunning );
    DsRunning = FALSE;


    //
    // If the install succeeded, make sure to save off the new site name
    //
    WinError = DsRolepSetOperationHandleSiteName( InstalledSite );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to copy site name (%d)\n", WinError ));

        goto PromoteUndo;

    }
    //
    // If we update it, NULL out the local parameter so we don't attempt to delete it
    //

    InstalledSite = NULL;

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the computers Dns domain name
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_SET_COMPUTER_DNS, PromoteArgs->DnsDomainName );
    WinError = NetpSetDnsComputerNameAsRequired( PromoteArgs->DnsDomainName );
    if ( ERROR_SUCCESS != WinError ) {
        
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "NetpSetDnsComputerNameAsRequired to %ws failed with %lu\n",
                                               PromoteArgs->DnsDomainName,
                                               WinError )) );
        DSROLEP_FAIL1( WinError, DSROLERES_SET_COMPUTER_DNS, PromoteArgs->DnsDomainName );

        goto PromoteUndo;
    }

    //
    // Restart netlogon if it was stopped and if a failure occurred
    //

    //
    // Complete the sysvol replication
    //
    WinError = DsRolepFinishSysVolPropagation( TRUE, TRUE );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to complete system volume replication (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Completed system volume replication\n"));
    
    //
    // Next, set the sysvol path for netlogon
    //
    WinError = DsRolepSetNetlogonSysVolPath( PromoteArgs->SysVolRootPath,
                                             PromoteArgs->DnsDomainName,
                                             ( BOOLEAN )FLAG_ON( PromoteArgs->Options,
                                                                 DSROLE_DC_DOWNLEVEL_UPGRADE ),
                                             &CleanupNetlogon );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set system volume path for NETLOGON (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Set system volume path for NETLOGON\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the machine role
    //
    WinError = DsRolepSetProductType( DSROLEP_MT_MEMBER );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the product type (%d)\n", WinError ));

        goto PromoteUndo;
        
    }
    ProductTypeChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Set the product type\n" ));


    //
    // Set the security on the dc files
    //
    WinError = DsRolepSetDcSecurity( PromoteArgs->ImpersonateToken,
                                     PromoteArgs->SysVolRootPath,
                                     PromoteArgs->DsDatabasePath,
                                     PromoteArgs->DsLogPath,
                                     ( BOOLEAN )FLAG_ON( PromoteArgs->Options,
                                                                 DSROLE_DC_DOWNLEVEL_UPGRADE ),
                                     FALSE );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set security on domain controller (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Set security on domain controller\n"));


    DsRolepSetCriticalOperationsDone();

    //
    // From here to do the end, perform, and only perform, non critical 
    // operations
    //

    //
    // Indicate that we are no longer doing upgrades, if applicable
    //
    if ( FLAG_ON( PromoteArgs->Options, DSROLE_DC_DOWNLEVEL_UPGRADE ) ) {

        WinError = DsRolepDeleteUpgradeInfo();

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to cleanup upgrade info (%d)\n",
                                               WinError )) );

        if (ERROR_SUCCESS == WinError) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Removed upgrade info\n" ));
        }

        // This error isn't interesting to propogate
        WinError = ERROR_SUCCESS;
    }

    //
    // Remove any old netlogon stuff if we got that far
    //
    if ( CleanupNetlogon ) {

        WinError = DsRolepCleanupOldNetlogonInformation();

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to cleanup old netlogon information (%d)\n",
                                               WinError )) );

        if (ERROR_SUCCESS == WinError) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Removed old netlogon information\n" ));
        }

        // This error isn't interesting to propogate
        WinError = ERROR_SUCCESS;
    }

    //
    // Set the default logon domain to the current domain name
    //
    WinError = DsRolepSetLogonDomain( PromoteArgs->FlatDomainName, FALSE );
    if ( ERROR_SUCCESS != WinError ) {
        
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to set default logon domain to %ws (%d)\n",
                                                PromoteArgs->FlatDomainName,
                                                WinError )) );

        if (ERROR_SUCCESS == WinError) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Set default logon domain to %ws\n",
                              PromoteArgs->FlatDomainName ));
        }

        //
        // This is no reason to fail
        //
        WinError = ERROR_SUCCESS;

    }

    //
    // Notify the time server we have completed the promotion
    //
    {
        DWORD dwTimeFlags = W32TIME_PROMOTE;

        if (  FLAG_ON( PromoteArgs->Options, DSROLE_DC_TRUST_AS_ROOT )
           || (NULL == PromoteArgs->Parent) ) {
            //
            // Any tree root, including the root of the forest
            // should have this flag.
            //
            dwTimeFlags |= W32TIME_PROMOTE_FIRST_DC_IN_TREE;
        }

        (*DsrW32TimeDcPromo)( dwTimeFlags );
    }

    //
    // By this time, we have successfully completed the promotion operation
    //
    ASSERT( ERROR_SUCCESS == WinError );

    
PromoteExit:

    // The DS should not be running at this point
    ASSERT( FALSE == DsRunning );

    //
    // Release any resources
    //

    //
    // Tear down the session to the parent, if we have one
    //
    if ( IPCConnection ) {

        RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
        IgnoreError = ImpNetpManageIPCConnect( PromoteArgs->ImpersonateToken,
                                             ParentDc,
                                             PromoteArgs->Account,
                                             PromoteArgs->Password.Buffer,
                                             (NETSETUPP_DISCONNECT_IPC | NETSETUPP_USE_LOTS_FORCE));
        RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
        if ( IgnoreError != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_WARN,
                             "Failed to destroy the session with %ws: 0x%lx\n", ParentDc,
                             IgnoreError ));
        }

        IPCConnection = FALSE;
    }

    if ( ParentDnsDomainInfo ) {

        if ( DnsDomainTreeName != ParentDnsDomainInfo->DnsForestName.Buffer ) {

            RtlFreeHeap( RtlProcessHeap(), 0, DnsDomainTreeName );
        }

        LsaFreeMemory( ParentDnsDomainInfo );
    }
    
    if ( InstalledSite ) {
        RtlFreeHeap( RtlProcessHeap(), 0, InstalledSite );
    }

    if ( NewDomainSid ) {
        RtlFreeHeap( RtlProcessHeap(), 0, NewDomainSid );
    }

    DsRolepFreeDomainPolicyInfo( &BackupDomainPolicyInfo );

    if ( DomainControllerInfo != NULL ) {

        if ( PromoteArgs->SiteName == DomainControllerInfo->DcSiteName ||
             PromoteArgs->SiteName == DomainControllerInfo->ClientSiteName ) {

            PromoteArgs->SiteName = NULL;
        }

        NetApiBufferFree( DomainControllerInfo );

    }

    DsRolepFreeArgumentBlock( &ArgumentBlock, TRUE );

    //
    // Reset our operation handle and set the final operation status
    //
    DsRolepSetOperationDone( DSROLEP_OP_PROMOTION, WinError );

    ExitThread( WinError );

    return( WinError );


PromoteUndo:

    //
    // Something must have failed if we are undoing
    //
    ASSERT( WinError != ERROR_SUCCESS );

    if ( ProductTypeChanged ) {

        IgnoreError = DsRolepSetProductType( DSROLEP_MT_STANDALONE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback product type (%d)\n",
                                                IgnoreError )) );

        ProductTypeChanged = FALSE;
    }

    if ( TrustCreated ) {

        IgnoreError = DsRolepRemoveTrustedDomainObjects( PromoteArgs->ImpersonateToken,
                                                       ParentDc,
                                                       ParentDnsDomainInfo,
                                                       FLAG_ON( PromoteArgs->Options,
                                                        DSROLE_DC_PARENT_TRUST_EXISTS ) ?
                                                            0 :
                                                            DSROLE_DC_DELETE_PARENT_TRUST );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback trusted domain object creations (%d)\n",
                                                IgnoreError )) );

        TrustCreated = FALSE;
    }

    if ( DomainControllerServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain controller services configuration (%d)\n",
                                                IgnoreError )) );
        DomainControllerServicesChanged = FALSE;
    }

    if ( DomainServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain services configuration (%d)\n",
                                                IgnoreError )) );
        DomainServicesChanged = FALSE;
    }

    if ( DomainPolicyInfoChanged ) {

        IgnoreError  = DsRolepRestoreDomainPolicyInfo(&BackupDomainPolicyInfo);

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain policy information (%d)\n",
                                                IgnoreError )) );
        DomainPolicyInfoChanged = FALSE;
    }

    if ( DsRunning ) {

        IgnoreError = DsRolepStopDs( DsRunning );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to stop the directory service (%d)\n",
                                                IgnoreError )) );
            
        DsRunning = FALSE;
        
    }

    if ( DsInstalled ) {

        IgnoreError = DsRolepUninstallDs( );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback directory service installation (%d)\n",
                                                IgnoreError )) );
        DsInstalled = FALSE;
    }



    if ( SysVolCreated ) {

        IgnoreError =  DsRolepFinishSysVolPropagation( FALSE, TRUE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to abort system volume installation (%d)\n",
                                                IgnoreError )) );

        IgnoreError = DsRolepRemoveSysVolPath( PromoteArgs->SysVolRootPath,
                                               PromoteArgs->DnsDomainName,
                                              &DomainGuid );

        
        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to remove system volume path (%d)\n",
                                                IgnoreError )) );
        SysVolCreated = FALSE;
    }


    if ( RestartNetlogon ) {

        IgnoreError = DsRolepStartNetlogon();

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to restart netlogon (%d)\n",
                                                IgnoreError )) );

        RestartNetlogon = FALSE;
    }


    //
    // We are finished the undo -- exit the thread
    //
    ASSERT( ERROR_SUCCESS != WinError );

    goto PromoteExit;

}





DWORD
DsRolepThreadPromoteReplica(
    IN PVOID ArgumentBlock
    )
/*++

Routine Description:

    This function actually "promotes" a server to a replica of an existing domain.  This is
    accomplished by:
        Installing the Ds as a replica
        Setting the DnsDomainTree LSA information
        Configuring the KDC

    Required are the Dns domain name and the name of a replica within the domain, and the
    Db and Log paths

Arguments:

    ArgumentBlock - Block of arguments appropriate for the operation


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS, IgnoreError;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs = (PDSROLEP_OPERATION_PROMOTE_ARGS)ArgumentBlock;
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    PDOMAIN_CONTROLLER_INFO ClientSiteInfo = NULL;
    DSROLEP_DOMAIN_POLICY_INFO BackupDomainPolicyInfo;
    ULONG FindOptions = 0;
    GUID DomainGuid;
    PWSTR InstalledSite = NULL, ReplicaServer = NULL;
    PSID NewDomainSid = NULL;
    WCHAR LocalMachineAccountName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    ULONG Length = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // BOOLEAN's to maintain state
    //
    // N.B. The order of these booleans is the order in which they
    //      are changed -- please maintain order and make sure that
    //      the PromoteUndo section undoes them in the reverse order
    //
    BOOLEAN IPCConnection                   = FALSE;  // resource -- release on exit
    BOOLEAN RestartNetlogon                 = FALSE;
    BOOLEAN SysVolCreated                   = FALSE;
    BOOLEAN DsInstalled                     = FALSE;
    BOOLEAN DsRunning                       = FALSE;
    BOOLEAN DomainPolicyInfoChanged         = FALSE;
    BOOLEAN DomainControllerServicesChanged = FALSE; 
    BOOLEAN ProductTypeChanged              = FALSE;


    RtlZeroMemory(&BackupDomainPolicyInfo, sizeof(BackupDomainPolicyInfo));

    //
    // Set our event to indicate we're starting
    //
    NtSetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );

    //
    // Get the account name
    //
    if ( GetComputerName( LocalMachineAccountName, &Length ) == FALSE ) {

        WinError = GetLastError();

        DsRolepLogPrint(( DEB_ERROR, "Failed to get computer name (%d)\n", WinError ));

        goto PromoteUndo;

    } else {

        wcscat( LocalMachineAccountName, L"$" );
    }

    //
    // Strip the trailing '.' from the Dns name if we happen to have an absolute name
    //
    DSROLEP_MAKE_DNS_RELATIVE( PromoteArgs->DnsDomainName );

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    if (PromoteArgs->Server) {

        WinError = DsRolepTimeSyncAndManageIPCConnect((PVOID)PromoteArgs,
                                                      PromoteArgs->Server);

        if ( WinError != ERROR_SUCCESS ) {
            
            goto PromoteUndo;
    
        }

        ReplicaServer = PromoteArgs->Server;

        IPCConnection = TRUE;

    }

    //
    // Find the server that holds the machine account for this machine
    //
    FindOptions = DS_DIRECTORY_SERVICE_REQUIRED | DS_WRITABLE_REQUIRED | DS_FORCE_REDISCOVERY |
                  DS_RETURN_DNS_NAME;
    WinError = ImpDsRolepDsGetDcForAccount( PromoteArgs->ImpersonateToken,
                                            PromoteArgs->Server,
                                            PromoteArgs->DnsDomainName,
                                            LocalMachineAccountName,
                                            FindOptions,
                                            UF_WORKSTATION_TRUST_ACCOUNT |
                                               UF_SERVER_TRUST_ACCOUNT,
                                            &DomainControllerInfo );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to get domain controller for account %ws (%d)\n", LocalMachineAccountName, WinError ));

        DSROLEP_FAIL1( WinError, DSROLERES_FIND_DC, PromoteArgs->DnsDomainName );

        goto PromoteUndo;
        
    }

    //
    // Determine source server
    //
    if ( NULL == PromoteArgs->Server ) {

        //
        // No server was passed -- use the result of the dsgetdc
        //
        ReplicaServer = DomainControllerInfo->DomainControllerName;

    } else {

        ReplicaServer = PromoteArgs->Server;

        if ( !DnsNameCompare_W(*(PromoteArgs->Server)==L'\\'?(PromoteArgs->Server)+2:PromoteArgs->Server,
                               *(DomainControllerInfo->DomainControllerName)==L'\\'?(DomainControllerInfo->DomainControllerName)+2:DomainControllerInfo->DomainControllerName ) ) {

            WinError = ERROR_DS_UNWILLING_TO_PERFORM;

            DsRolepLogPrint(( DEB_ERROR, "DsGetDcForAccount Failed to get the requested domain controller %ws for account %ws (%d)\n",
                              PromoteArgs->Server,
                              LocalMachineAccountName,
                              WinError));

            DSROLEP_FAIL3( WinError, 
                           DSROLERES_FAILED_FIND_REQUESTED_DC, 
                           PromoteArgs->Server,
                           LocalMachineAccountName,
                           DomainControllerInfo->DomainControllerName );

            goto PromoteUndo;
        
        }

    }

    //
    // Determine destination site
    //
    // Site need to be chosen by the following rules
    // 1) If a site is given new DC should be placed into that site.
    // 2) If no site is given new DC should end up in site base on IP.
    // 3) If no site and subnet not defined but replica partner is given then new DC should end up in replica partner's site
    // 4) If have none of the above then site is random.
    //
    if ( PromoteArgs->SiteName == NULL ) {

        if ( PromoteArgs->Server == NULL ) {
        
            PromoteArgs->SiteName = DomainControllerInfo->ClientSiteName;

        } else {

            WinError = DsGetDcName( NULL,
                                    PromoteArgs->DnsDomainName,
                                    NULL,
                                    NULL,
                                    FindOptions,
                                    &ClientSiteInfo );

            if ( ERROR_SUCCESS != WinError ) {

                DsRolepLogPrint(( DEB_ERROR, "Failed to find site for %ws (%d)\n", LocalMachineAccountName, WinError ));
        
                DSROLEP_FAIL1( WinError, DSROLERES_FAILED_FIND_SITE, LocalMachineAccountName );

                goto PromoteUndo;
                
            }

            PromoteArgs->SiteName = ClientSiteInfo->ClientSiteName;

        }

        if ( PromoteArgs->SiteName == NULL ) {

            if ( ClientSiteInfo ) {
            
                NetApiBufferFree(ClientSiteInfo);
                ClientSiteInfo = NULL;

            }

            PromoteArgs->SiteName = DomainControllerInfo->DcSiteName;

        }
    }

    DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_SITE,
                         PromoteArgs->SiteName,
                         ReplicaServer );


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    if (!IPCConnection) {

        WinError = DsRolepTimeSyncAndManageIPCConnect((PVOID)PromoteArgs,
                                                      ReplicaServer);

        if ( WinError != ERROR_SUCCESS ) {
            
            goto PromoteUndo;
    
        }

        IPCConnection = TRUE;

    }


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Stop netlogon
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_STOP_SERVICE, SERVICE_NETLOGON );

    WinError = DsRolepStopNetlogon( &RestartNetlogon );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to stop NETLOGON (%d)\n", WinError ));

        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Stopped NETLOGON\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Create the system volume information
    //
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    WinError = DsRolepCreateSysVolPath( PromoteArgs->SysVolRootPath,
                                        PromoteArgs->DnsDomainName,
                                        ReplicaServer,
                                        PromoteArgs->Account,
                                        PromoteArgs->Password.Buffer,
                                        PromoteArgs->SiteName,
                                        FALSE );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to create system volume path (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Created system volume path\n" ));

    SysVolCreated = TRUE;

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Setup the Ds
    //
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->DomainAdminPassword );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->SafeModePassword );
    WinError = DsRolepInstallDs( PromoteArgs->DnsDomainName,
                                 PromoteArgs->FlatDomainName,
                                 NULL,    // DnsTreeRoot not used for replica installs
                                 PromoteArgs->SiteName,
                                 PromoteArgs->DsDatabasePath,
                                 PromoteArgs->DsLogPath,
                                 PromoteArgs->pIfmSystemInfo,
                                 PromoteArgs->SysVolRootPath,
                                 &(PromoteArgs->Bootkey),
                                 PromoteArgs->DomainAdminPassword.Buffer,
                                 PromoteArgs->Parent,
                                 ReplicaServer,
                                 PromoteArgs->Account,
                                 PromoteArgs->Password.Buffer,
                                 PromoteArgs->SafeModePassword.Buffer,
                                 PromoteArgs->DnsDomainName,
                                 PromoteArgs->Options,
                                 TRUE,
                                 PromoteArgs->ImpersonateToken,
                                 &InstalledSite,
                                 &DomainGuid,
                                 &NewDomainSid );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->DomainAdminPassword );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->SafeModePassword );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to install to Directory Service (%d)\n", WinError ));
        goto PromoteUndo;
        
    }
    DsRunning = TRUE;
    DsInstalled = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Installed Directory Service\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the lsa domain information to reflect the new security database
    // that was brought in.  The Set below does not set the DnsDomainInformation,
    // since the flat name is not yet known.  The DnsDomainInformation gets
    // set by the DsRolepSetLsaInformationForReplica call following.
    //
    WinError = DsRolepBackupDomainPolicyInfo( NULL, &BackupDomainPolicyInfo );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to make backup of LSA policy (%d)\n", WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_READ_LOCAL );
        goto PromoteUndo;
        
    }

    WinError = DsRolepSetLsaDomainPolicyInfo( PromoteArgs->DnsDomainName,
                                              PromoteArgs->FlatDomainName,
                                              NULL,
                                              &DomainGuid,
                                              NewDomainSid,
                                              NTDS_INSTALL_REPLICA,
                                              &BackupDomainPolicyInfo );
    if ( ERROR_SUCCESS != WinError  ) {
        
        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_WRITE_LOCAL );
        goto PromoteUndo;

    }
    DomainPolicyInfoChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Wrote the LSA policy information for the local machine\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // This extra call is necessary to get the dns tree information
    //
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    WinError = DsRolepSetLsaInformationForReplica( PromoteArgs->ImpersonateToken,
                                                   ReplicaServer,
                                                   PromoteArgs->Account,
                                                   PromoteArgs->Password.Buffer );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
    if ( ERROR_SUCCESS != WinError ) {
        
        DSROLEP_FAIL1( WinError, DSROLERES_POLICY_READ_REMOTE, ReplicaServer );
        goto PromoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE, "Read the LSA policy information from %ws\n", 
                      ReplicaServer ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Configure the services for a domain controller
    //
    WinError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_ON );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to configure domain controller services (%d)\n", WinError ));
        
        goto PromoteUndo;
    }
    DomainControllerServicesChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Configured domain controller services\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the computers Dns domain name
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_SET_COMPUTER_DNS, PromoteArgs->DnsDomainName );
    WinError = NetpSetDnsComputerNameAsRequired( PromoteArgs->DnsDomainName );
    if ( ERROR_SUCCESS != WinError ) {
        
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "NetpSetDnsComputerNameAsRequired to %ws failed with %lu\n",
                                               PromoteArgs->DnsDomainName,
                                               WinError )) );
        DSROLEP_FAIL1( WinError, DSROLERES_SET_COMPUTER_DNS, PromoteArgs->DnsDomainName );
        goto PromoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE, "Set the computer's Dns domain name to %ws.\n",
                      PromoteArgs->DnsDomainName ));

    //
    // Complete the sysvol replication
    //
    if ( SysVolCreated ) {

        WinError = DsRolepFinishSysVolPropagation( TRUE, TRUE );
        if ( ERROR_SUCCESS != WinError ) {

            DsRolepLogPrint(( DEB_ERROR, "Failed to complete system volume replication (%d)\n", WinError ));

            goto PromoteUndo;
            
        }

        DsRolepLogPrint(( DEB_TRACE, "Completed system volume replication\n" ));
    }
    
    //
    // Set the machine role
    //
    WinError = DsRolepSetProductType( DSROLEP_MT_MEMBER );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the product type (%d)\n", WinError ));

        goto PromoteUndo;
    }
    DsRolepLogPrint(( DEB_TRACE, "Set the product type\n" ));

    ProductTypeChanged = TRUE;

    //
    // Save off the new site name
    //
    WinError = DsRolepSetOperationHandleSiteName( InstalledSite );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the operation handle(%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    //
    // If we update it, NULL out the local parameter so we don't attempt to delete it
    //
    InstalledSite = NULL;


    //
    // Next, set the sysvol path for netlogon
    //
    WinError = DsRolepSetNetlogonSysVolPath( PromoteArgs->SysVolRootPath,
                                             PromoteArgs->DnsDomainName,
                                             FALSE,
                                             NULL );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the system volume path for NETLOGON (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Set the system volume path for NETLOGON\n" ));

    //
    // Finally, set the security on the dc files
    //
    WinError = DsRolepSetDcSecurity( PromoteArgs->ImpersonateToken,
                                     PromoteArgs->SysVolRootPath,
                                     PromoteArgs->DsDatabasePath,
                                     PromoteArgs->DsLogPath,
                                     ( BOOLEAN )FLAG_ON( PromoteArgs->Options,
                                                                 DSROLE_DC_DOWNLEVEL_UPGRADE ),
                                     TRUE );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set security for the domain controller (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Set security for the domain controller\n" ));


    //
    // We have done all operations for the promotion; now continue replicating
    // ds information until done, or cancelled
    //
    DsRolepLogPrint(( DEB_TRACE, "Replicating non critical information\n" ));

    DsRolepSetCriticalOperationsDone();

    if ( !FLAG_ON( PromoteArgs->Options, DSROLE_DC_CRITICAL_REPLICATION_ONLY ) ) {

        //in the Install From Media case we do not want to do a full sync of the
        //Non-Critical objects
        if ((PromoteArgs->pIfmSystemInfo != NULL)) {
            WinError = (*DsrNtdsInstallReplicateFull) ( DsRolepStringUpdateCallback, PromoteArgs->ImpersonateToken, NTDS_IFM_PROMOTION );
        } else {
            WinError = (*DsrNtdsInstallReplicateFull) ( DsRolepStringUpdateCallback, PromoteArgs->ImpersonateToken, 0 );
        }
    
        if ( WinError != ERROR_SUCCESS ) {
    
            //
            // Error code doesn't matter, but we'll log it anyway
            //
            DsRolepLogOnFailure( WinError,
                                 DsRolepLogPrint(( DEB_WARN,
                                                  "Non critical replication returned %lu\n", WinError )) );
        
            if (ERROR_SUCCESS == WinError) {
                DsRolepLogPrint(( DEB_TRACE, "Replicating non critical information (Complete)\n" ));
            }
            if ( ERROR_SUCCESS != WinError ) {
        
                DSROLEP_SET_NON_CRIT_REPL_ERROR();
            }
    
            WinError = ERROR_SUCCESS;
            
        }
        
    } else {

        DsRolepLogPrint(( DEB_TRACE, "User specified to not replicate non-critical data\n" ));

    }


    //
    // Indicate that we are no longer doing upgrades, if applicable
    //
    if ( FLAG_ON( PromoteArgs->Options, DSROLE_DC_DOWNLEVEL_UPGRADE ) ) {

        WinError = DsRolepDeleteUpgradeInfo();

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to remove upgrade information (%d)\n",
                                               WinError )) );
        // This error isn't interesting to propogate
        WinError = ERROR_SUCCESS;

    }

    //
    // Remove any old netlogon stuff if we got that far
    //
    WinError = DsRolepCleanupOldNetlogonInformation();

    if ( (FLAG_ON( PromoteArgs->Options, DSROLE_DC_DOWNLEVEL_UPGRADE )) && ERROR_SUCCESS != WinError ) {

        if (ERROR_SUCCESS == WinError) {
            DsRolepLogPrint(( DEB_TRACE, "Removed any old netlogon information\n" ));
        }

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to clean up old netlogon information (%d)\n",
                                                WinError )) );

    }

    WinError = ERROR_SUCCESS;


    //
    // Set the default logon domain to the current domain name
    //

    //
    // We'll have to get it from the backed up policy information, since it isn't actually
    // passed in
    //
    WinError = DsRolepSetLogonDomain(
                   ( PWSTR )BackupDomainPolicyInfo.DnsDomainInfo->Name.Buffer,
                   FALSE );
    if ( ERROR_SUCCESS != WinError ) {

        PWCHAR bufDnsDomainInfo = NULL;

        bufDnsDomainInfo = (WCHAR*)malloc(BackupDomainPolicyInfo.DnsDomainInfo->Name.Length+sizeof(WCHAR));

        if (bufDnsDomainInfo) {
            CopyMemory(bufDnsDomainInfo,
                       BackupDomainPolicyInfo.DnsDomainInfo->Name.Buffer,
                       BackupDomainPolicyInfo.DnsDomainInfo->Name.Length);
            bufDnsDomainInfo[BackupDomainPolicyInfo.DnsDomainInfo->Name.Length/sizeof(WCHAR)] = L'\0';
        
        
            DsRolepLogOnFailure( WinError,
                                 DsRolepLogPrint(( DEB_WARN,
                                                   "Failed to set default logon domain to %ws (%d)\n",
                                                    bufDnsDomainInfo,
                                                    WinError )) );
    
            if (ERROR_SUCCESS == WinError) {
                DsRolepLogPrint(( DEB_TRACE, "Set default logon domain to %ws\n",
                                              bufDnsDomainInfo ));
            }

            free(bufDnsDomainInfo);

        }

        //
        // This is not worth failing for
        //
        WinError = ERROR_SUCCESS;

    }

    //
    // Stop the ds
    //
    DsRolepStopDs( DsRunning );
    DsRunning = FALSE;

    DsRolepLogPrint(( DEB_TRACE, "Stopped the DS\n" ));

    //
    // Notify the time server we have completed the promotion
    //
    (*DsrW32TimeDcPromo)( W32TIME_PROMOTE );

    
    //
    // Set Netlogon registry key during DCPromo to ensure that kerberos is talking 
    // to a DC w/ new User AccountControl flag
    //
    IgnoreError = NetpStoreIntialDcRecord(DomainControllerInfo);
    if ( IgnoreError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_WARN,
                         "Failed to set Netlogon registry key during DCPromo %ws\r\n",
                         IgnoreError ));
    }

    //
    // At this point we have succeeded the promotion
    //
    ASSERT( ERROR_SUCCESS == WinError );


PromoteExit:


    //
    // Released acquired resources
    //
    if ( IPCConnection ) {

        RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
        IgnoreError = ImpNetpManageIPCConnect( PromoteArgs->ImpersonateToken,
                                               ReplicaServer,
                                               PromoteArgs->Account,
                                               PromoteArgs->Password.Buffer,
                                              (NETSETUPP_DISCONNECT_IPC | NETSETUPP_USE_LOTS_FORCE ) );
        RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
        if ( IgnoreError != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR,
                             "Failed to destroy the session with %ws: 0x%lx\n", ReplicaServer,
                             IgnoreError ));
        }
        IPCConnection = FALSE;
    }


    if ( DomainControllerInfo != NULL ) {

        if ( PromoteArgs->SiteName == DomainControllerInfo->ClientSiteName ||
             PromoteArgs->SiteName == DomainControllerInfo->DcSiteName ) {

            PromoteArgs->SiteName = NULL;
        }

        NetApiBufferFree( DomainControllerInfo );

    }

    if ( ClientSiteInfo != NULL ) {

        if ( PromoteArgs->SiteName == ClientSiteInfo->ClientSiteName ||
             PromoteArgs->SiteName == ClientSiteInfo->DcSiteName ) {

            PromoteArgs->SiteName = NULL;
        }

        NetApiBufferFree( ClientSiteInfo );

    }

    RtlFreeHeap( RtlProcessHeap(), 0, InstalledSite );
    RtlFreeHeap( RtlProcessHeap(), 0, NewDomainSid );

    DsRolepFreeDomainPolicyInfo(&BackupDomainPolicyInfo);
    //
    // Reset our operation handle
    //
    DsRolepSetOperationDone( DSROLEP_OP_PROMOTION, WinError );

    DsRolepFreeArgumentBlock( &ArgumentBlock, TRUE );

    ExitThread( WinError );
    return( WinError );

PromoteUndo:

    //
    // Something must have failed to have gotten us here
    //
    ASSERT( ERROR_SUCCESS != WinError );

    if ( ProductTypeChanged ) {

        IgnoreError = DsRolepSetProductType( DSROLEP_MT_STANDALONE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback product type (%d)\n",
                                                IgnoreError )) );

        ProductTypeChanged = FALSE;
    }

    if ( DomainControllerServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain controller services configuration (%d)\n",
                                                IgnoreError )) );

        DomainControllerServicesChanged = FALSE;
    }

    if ( DomainPolicyInfoChanged ) {

        IgnoreError = DsRolepRestoreDomainPolicyInfo(&BackupDomainPolicyInfo);

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to restore domain policy information (%d)\n",
                                                IgnoreError )) );
        DomainPolicyInfoChanged = FALSE;
    }

    if ( DsRunning ) {
        
        IgnoreError = DsRolepStopDs( DsRunning );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to stop the directory service (%d)\n",
                                                IgnoreError )) );
        DsRunning = FALSE;
    }

    if ( DsInstalled ) {

        IgnoreError = DsRolepUninstallDs( );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to undo the directory service installation (%d)\n",
                                                IgnoreError )) );
        DsInstalled = FALSE;
    }

    if ( SysVolCreated ) {

        IgnoreError = DsRolepFinishSysVolPropagation( FALSE, TRUE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to abort system volume installation (%d)\n",
                                                IgnoreError )) );

        IgnoreError = DsRolepRemoveSysVolPath( PromoteArgs->SysVolRootPath,
                                               PromoteArgs->DnsDomainName,
                                               &DomainGuid );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to remove system volume path (%d)\n",
                                                IgnoreError )) );

        SysVolCreated = FALSE;

    }

    if ( RestartNetlogon ) {

        IgnoreError = DsRolepStartNetlogon();

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to restart NETLOGON (%d)\n",
                                                IgnoreError )) );
        RestartNetlogon = FALSE;
    }

    //
    // That's it -- terminate the operation
    // 

    ASSERT( ERROR_SUCCESS != WinError );

    goto PromoteExit;

}



DWORD
DsRolepThreadDemote(
    IN PVOID ArgumentBlock
    )
/*++

Routine Description:

    This function actually "demotes" a dc to standalone or member server.  This is
    accomplished by:
        Uninstalling the Ds
        Configuring the KDC
        Changing the product type
        Removing the system volume tree

    Required is the new server role

Arguments:

    ArgumentBlock - Block of arguments appropriate for the operation


Returns:

    ERROR_SUCCESS - Success

    ERROR_NO_SUCH_DOMAIN - The local domain information could not be located

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

    ERROR_DS_CANT_ON_NON_LEAF - The domain is not a leaf domain

--*/
{
    DWORD WinError = ERROR_SUCCESS, IgnoreError;
    NET_API_STATUS NetStatus = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    PDSROLEP_OPERATION_DEMOTE_ARGS DemoteArgs = ( PDSROLEP_OPERATION_DEMOTE_ARGS )ArgumentBlock;
    DSROLEP_DOMAIN_POLICY_INFO BackupDomainPolicyInfo;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    HANDLE Policy = NULL;
    NTSTATUS Status;
    PWSTR ParentDomainName = NULL, CurrentDomain = NULL, SupportDc = NULL;
    PWSTR SupportDomain = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN fNoNetworkOperations = FALSE;

    ULONG ServicesOffFlags = DSROLEP_SERVICES_OFF | DSROLEP_SERVICES_STOP;
    ULONG ServicesOnFlags = DSROLEP_SERVICES_REVERT;

    PNTDS_DNS_RR_INFO pDnsRRInfo = NULL;

    ULONG Flags = 0;
    PSEC_WINNT_AUTH_IDENTITY Credentials = NULL;

    ULONG FindOptions = DS_DIRECTORY_SERVICE_REQUIRED | 
                                DS_WRITABLE_REQUIRED | 
                                DS_FORCE_REDISCOVERY | 
                                DS_AVOID_SELF |
                                DS_RETURN_DNS_NAME;

    //
    // BOOLEAN's to maintain state
    //
    // N.B. The order of these booleans is the order in which they
    //      are changed -- please maintain order and make sure that
    //      the DemoteUndo section undoes them in the reverse order
    //
    BOOLEAN IPCConnection                   = FALSE;  // resource -- release on exit
    BOOLEAN DsPrepareDemote                 = FALSE;
    BOOLEAN FrsDemote                       = FALSE;
    BOOLEAN NotifiedNetlogonToDeregister    = FALSE;
    BOOLEAN RestartNetlogon                 = FALSE;
    BOOLEAN DomainControllerServicesChanged = FALSE; 
    BOOLEAN DomainServicesChanged           = FALSE; 
    BOOLEAN Unrollable                      = FALSE;  // at this point, don't
    // try to rollback
    //
    // Set our event to indicate we're starting
    //
    NtSetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );

    //
    // If This is a Forced Demotion then we will not do any network
    // operations
    //
    if ( FLAG_ON( DemoteArgs->Options, DSROLE_DC_FORCE_DEMOTE ) ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "Performing Forced Demotion"));
    
        fNoNetworkOperations = TRUE;

        //We also do not want to fail if we couldn't configure services
        ServicesOffFlags |= DSROLEP_SERVICES_IGNORE_ERRORS;

    }

    //
    // Get the current domain information, potentially the parent Domain and see if
    // we are valid to be demoted
    //
    DSROLEP_CURRENT_OP0( DSROLEEVT_LOCAL_POLICY );

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &Policy );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( Policy,
                                            PolicyDnsDomainInformation,
                                            &DnsDomainInfo );

    }

    if ( !NT_SUCCESS( Status ) ) {

        WinError = RtlNtStatusToDosError( Status );
        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_READ_LOCAL );
        goto DemoteUndo;
    }

    if ( DemoteArgs->DomainName == NULL ) {

        CurrentDomain = DnsDomainInfo->DnsDomainName.Buffer;

    } else {

        //
        // Strip the trailing '.' from the Dns name if we happen to have an absolute name
        //
        DSROLEP_MAKE_DNS_RELATIVE( DemoteArgs->DomainName );

        CurrentDomain = DemoteArgs->DomainName;
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Determine whether it is legal to demote this domain.  Also, get the parent Dns domain name
    //
    if ( DemoteArgs->LastDcInDomain && !fNoNetworkOperations ) {

        PLSAPR_FOREST_TRUST_INFO ForestTrustInfo = NULL;
        PLSAPR_TREE_TRUST_INFO OwnEntry = NULL, ParentEntry = NULL;

        Status = LsaIQueryForestTrustInfo( Policy,
                                           &ForestTrustInfo );
        WinError = RtlNtStatusToDosError( Status );

        if ( WinError == ERROR_SUCCESS ) {

            //
            // Check the root
            //
            if ( RtlCompareUnicodeString(
                    ( PUNICODE_STRING )&ForestTrustInfo->RootTrust.DnsDomainName,
                    &DnsDomainInfo->DnsDomainName,
                    TRUE ) == 0  ) {

                OwnEntry = &ForestTrustInfo->RootTrust;
                ParentEntry = NULL;

            } else {

                //
                // Find our own entry in the list and our parent...
                //
                DsRolepFindSelfAndParentInForest( ForestTrustInfo,
                                                  &ForestTrustInfo->RootTrust,
                                                  &DnsDomainInfo->DnsDomainName,
                                                  &ParentEntry,
                                                  &OwnEntry );
            }

            if ( OwnEntry == NULL ) {

                WinError = ERROR_NO_SUCH_DOMAIN;

            } else {

                //
                // If we have children, it's an error
                //
                if ( OwnEntry->Children != 0 ) {

                    WCHAR *BufOwnEntry = NULL;
                    DsRolepUnicodestringtowstr( BufOwnEntry, OwnEntry->DnsDomainName )
                    if (BufOwnEntry) {
                      DsRolepLogPrint(( DEB_TRACE,
                                      "We ( %ws ) think we have %lu children\n",
                                      BufOwnEntry,
                                      OwnEntry->Children ));
                      free(BufOwnEntry);
                    } else {
                      DsRolepLogPrint(( DEB_TRACE,
                                      "We think we have %lu children: Can display string ERROR_NOT_ENOUGH_MEMORY\n",
                                      OwnEntry->Children ));
                    }

                    WinError = ERROR_DS_CANT_ON_NON_LEAF;
                }

                //
                // Copy off our parent information
                //
                if ( WinError == ERROR_SUCCESS && ParentEntry != NULL ) {

                    WCHAR *BufOwnEntry = NULL;
                    DsRolepUnicodestringtowstr( BufOwnEntry, OwnEntry->DnsDomainName )
                    if (BufOwnEntry) {
                      DsRolepLogPrint((DEB_TRACE,
                                      "Domain %ws is our parent parent\n",
                                      BufOwnEntry));
                      free(BufOwnEntry);
                    } else {
                      DsRolepLogPrint(( DEB_TRACE,
                                      "Domain (?) is our parent parent: Can display domain string ERROR_NOT_ENOUGH_MEMORY\n"));
                    }

                    ParentDomainName = RtlAllocateHeap(
                                  RtlProcessHeap(), 0,
                                  ParentEntry->DnsDomainName.Length + sizeof( WCHAR ) );
                    if ( ParentDomainName == NULL ) {

                        WinError = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        RtlCopyMemory( ParentDomainName,
                                       ParentEntry->DnsDomainName.Buffer,
                                       ParentEntry->DnsDomainName.Length );
                        ParentDomainName[
                            ParentEntry->DnsDomainName.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
                    }
                }

            }
        }

        LsaIFreeForestTrustInfo( ForestTrustInfo );

        if ( ERROR_SUCCESS != WinError ) {

            DSROLEP_FAIL1( WinError, DSROLERES_LEAF_DOMAIN, CurrentDomain );
            goto DemoteUndo;
            
        }

    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );


    //
    // Locate a Dc to help with the demotion
    //
    if ( !fNoNetworkOperations ) {
    
        if ( DemoteArgs->LastDcInDomain ) {
    
            SupportDomain = ParentDomainName;
    
        } else {
    
            SupportDomain = CurrentDomain;
        }

    }

    //
    // If this is the last domain in the enterprise, there will be no
    // parent domain and possibly no replicas to assist.
    //
    // Note: netlogon is still running, so use the avoid self flag
    //
    if ( SupportDomain ) {

        DSROLEP_CURRENT_OP1( DSROLEEVT_SEARCH_DC, SupportDomain  );

        if ( !DemoteArgs->LastDcInDomain )
        {
            //
            // Demoting a replica - find someone with our machine account
            //
            WCHAR LocalMachineAccountName[ MAX_COMPUTERNAME_LENGTH + 2 ];
            ULONG Length = sizeof(LocalMachineAccountName) / sizeof(LocalMachineAccountName[0]);

            //
            // Get the account name
            //
            if ( GetComputerName( LocalMachineAccountName, &Length ) == FALSE ) {

                WinError = GetLastError();

                DsRolepLogPrint(( DEB_ERROR, "Failed to get computer name (%d)\n", WinError ));

                goto DemoteUndo;
        
            } else {

                wcscat( LocalMachineAccountName, L"$" );
                WinError = DsRolepDsGetDcForAccount( NULL,
                                                     SupportDomain,
                                                     LocalMachineAccountName,
                                                     FindOptions,
                                                     UF_WORKSTATION_TRUST_ACCOUNT |
                                                        UF_SERVER_TRUST_ACCOUNT,
                                                     &DomainControllerInfo );
            }

        } else {

            WinError = DsGetDcName( NULL, SupportDomain, NULL, NULL,
                                    FindOptions,
                                    &DomainControllerInfo );
        }

        if ( ERROR_SUCCESS != WinError ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to find a domain controller for %ws: %lu\n",
                              SupportDomain, WinError ));
            
            DSROLEP_FAIL1( WinError, DSROLERES_FIND_DC, SupportDomain );

            goto DemoteUndo;
        }

        SupportDc = DomainControllerInfo->DomainControllerName;
        if ( *SupportDc == L'\\' ) {

            SupportDc += 2;
        }

        DsRolepLogPrint(( DEB_TRACE_DS, "Support Dc in %ws is %ws\n",
                          SupportDomain,
                          SupportDc ));
        DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_DC,
                             SupportDc,
                             SupportDomain );
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Attempt to establish a RDR session with our support DC
    // if necessary
    //
    if ( SupportDc ) {
        
        //
        // Impersonate to get logon id of caller
        //
        RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );
        WinError = ImpNetpManageIPCConnect( DemoteArgs->ImpersonateToken,
                                            SupportDc,
                                            DemoteArgs->Account,
                                            DemoteArgs->Password.Buffer,
                                            NETSETUPP_CONNECT_IPC );
    
        RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );
        if ( ERROR_SUCCESS != WinError ) {
    
            DSROLEP_FAIL1( WinError, DSROLERES_NET_USE, SupportDc );
            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to establish the session with %ws: 0x%lx\n", SupportDc,
                              WinError ));
            goto DemoteUndo;
    
        }
        IPCConnection = TRUE;
    }

    if ( DemoteArgs->LastDcInDomain ) {
    
        Flags |= NTDS_LAST_DC_IN_DOMAIN;
    }

    Flags |= DsRolepDemoteFlagsToNtdsFlags( DemoteArgs->Options );

    if ( !fNoNetworkOperations ) {
    
        //
        // Prepare the ds for demotion
        //
    
        DSROLE_GET_SETUP_FUNC( WinError, DsrNtdsPrepareForDemotion );
        ASSERT( ERROR_SUCCESS == WinError );
    
        RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );
    
        WinError = DsRolepCreateAuthIdentForCreds(DemoteArgs->Account,
                                                  DemoteArgs->Password.Buffer,
                                                  &Credentials);
    
        if ( ERROR_SUCCESS == WinError ) {
    
            DSROLEP_CURRENT_OP0( DSROLEEVT_PREPARE_DEMOTION );
    
            //
            // If this is a Force demotion. There is nothing to prepare.
            //
            
            WinError = ( *DsrNtdsPrepareForDemotion ) ( Flags,
                                                        SupportDc,
                                                        Credentials,
                                                        DsRolepStringUpdateCallback,
                                                        DsRolepStringErrorUpdateCallback,
                                                        DemoteArgs->ImpersonateToken,
                                                        DemoteArgs->cRemoveNCs,
                                                        DemoteArgs->pszRemoveNCs,
                                                        &pDnsRRInfo );
    
        
            RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );
    
            if ( ERROR_SUCCESS != WinError ) {
    
                DsRolepLogPrint(( DEB_ERROR, "Failed to prepare the Directory Service for uninstallation (%d)\n", WinError ));
    
                goto DemoteUndo;
                
            }
            DsPrepareDemote = TRUE;
    
        } else {
    
            DsRolepLogPrint(( DEB_ERROR, "Failed to create authentication credentials (%d)\n", WinError ));
    
            goto DemoteUndo;
        }

    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Start the sysvol demotions
    //
    RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );

    WinError = ( *DsrNtFrsApi_PrepareForDemotionUsingCredW ) ( Credentials,
                                                               DemoteArgs->ImpersonateToken,
                                                              DsRolepStringErrorUpdateCallback );


    RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to get computer name (%d)\n", WinError ));
        DSROLEP_FAIL0( WinError, DSROLERES_SYSVOL_DEMOTION );
        goto DemoteUndo;
        
    }

    WinError = ( *DsrNtFrsApi_StartDemotionW )( CurrentDomain,
                                                DsRolepStringErrorUpdateCallback );
    
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to start system volume demotion on domain (%d)\n",
                          WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_SYSVOL_DEMOTION );
        goto DemoteUndo;
        
    }
    // At this point we have signalled one frs replica set to be demote so
    // we must wait on it
    FrsDemote = TRUE;

    WinError = ( *DsrNtFrsApi_StartDemotionW )( L"ENTERPRISE",
                                                DsRolepStringErrorUpdateCallback );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to start system volume demotion on enterprise (%d)\n",
                          WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_SYSVOL_DEMOTION );
        goto DemoteUndo;

    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Started system volume demotion on enterprise\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Note that if a failure occurs after we uninstall the Ds, than we will not attempt to
    // reinstall it, since we don't have enough information to do so.  In that case, the machine
    // will be in a somewhat inconsistent state.  However, some errors are acceptable:
    //
    //   Failure to delete the trusted domain object - Continuable
    //   Stoping the KDC - Continuable
    //
    //
    // Also, note that "uninstalling the DS" also sets the LSA account domain
    // sid and the server role so no errors should be returned to the caller
    // after uninstalling the DS. The machine will become the new role on the
    // next reboot.
    //

    WinError = DsRolepBackupDomainPolicyInfo( NULL, &BackupDomainPolicyInfo );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to backup LSA domain policy (%d)\n",
                          WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_READ_LOCAL );
        goto DemoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Read the LSA policy information from the local machine\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );


    //
    // Set netlogon we are demoting so it will deregister the DNS records
    // This will be skiped if this is a Forced demotion since it is a 
    // networking operation.
    //
    if ( !fNoNetworkOperations ) {

        Status = I_NetNotifyDsChange( NlDcDemotionInProgress );

        if ( !NT_SUCCESS( Status ) ) {
    
            WinError = RtlNtStatusToDosError( Status );
            
            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to tell NETLOGON to deregister records (%d)\n",
                              WinError ));
            goto DemoteUndo;
        }
    
        DsRolepLogPrint(( DEB_TRACE,
                          "Informed NETLOGON to deregister records\n" ));
    
        NotifiedNetlogonToDeregister = TRUE;

    }

    //
    // Stop netlogon
    //
    WinError = DsRolepStopNetlogon( &RestartNetlogon );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to stop NETLOGON (%d)\n",
                          WinError ));

        //We don't want to fail because we couldn't stop netlogon
        //during a forced demotion
        if ( !fNoNetworkOperations ) {

            goto DemoteUndo;

        }

        //log an event that states that netlogon could not
        //be stopped during the forced demotion.
        SpmpReportEvent( TRUE,
                         EVENTLOG_WARNING_TYPE,
                         DSROLERES_FAILED_STOPPING_NETLOGON,
                         0,
                         sizeof( ULONG ),
                         &WinError,
                         0 );

        DSROLEP_SET_NON_FATAL_ERROR( WinError );

        WinError = ERROR_SUCCESS;

    }

    if ( RestartNetlogon ) {
    
        DsRolepLogPrint(( DEB_TRACE,
                          "Stopped NETLOGON\n" ));

    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Disable the domain controller services
    //
    WinError  = DsRolepConfigureDomainControllerServices( ServicesOffFlags );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to configure domain controller services (%d)\n",
                          WinError ));
        goto DemoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Configured domain controller services\n" ));

    DomainControllerServicesChanged = TRUE;
        
    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Disable the domain related services if necessary
    //
    if ( DemoteArgs->ServerRole == DsRoleServerStandalone ) {

        WinError  = DsRolepConfigureDomainServices( ServicesOffFlags );

        if ( ERROR_SUCCESS != WinError ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to configure domain services (%d)\n",
                              WinError ));

            goto DemoteUndo;

        }
        DsRolepLogPrint(( DEB_TRACE,
                      "Configured domain services\n" ));

        DomainServicesChanged = TRUE;
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Remove the Ds
    //
    RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );
    RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->AdminPassword );
    WinError = DsRolepDemoteDs( CurrentDomain,
                                DemoteArgs->Account,
                                DemoteArgs->Password.Buffer,
                                DemoteArgs->AdminPassword.Buffer,
                                SupportDc,
                                SupportDomain,
                                DemoteArgs->ImpersonateToken,
                                DemoteArgs->LastDcInDomain,
                                DemoteArgs->cRemoveNCs,
                                DemoteArgs->pszRemoveNCs,
                                DemoteArgs->Options
                                 );

    RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );
    RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->AdminPassword );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to demote the directory service (%d)\n",
                          WinError ));
        goto DemoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "This machine is no longer a domain controller\n" ));

    //
    // The operation cannot be cancelled at this point since the ds has
    // been removed from the machine and from the enterprise
    //
    Unrollable = TRUE;

    //
    // Optionally remove the trust with the parent
    //
    if ( DemoteArgs->LastDcInDomain &&
         ParentDomainName != NULL && 
         !fNoNetworkOperations ) {

        //
        // Establish a session first -- should be a no-op since we already
        // have a connection
        //
        RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );
        WinError = ImpNetpManageIPCConnect( DemoteArgs->ImpersonateToken,
                                            SupportDc,
                                            DemoteArgs->Account,
                                            DemoteArgs->Password.Buffer,
                                            NETSETUPP_CONNECT_IPC );

        RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );
        if ( WinError == ERROR_SUCCESS ) {

            WinError = DsRolepDeleteParentTrustObject( DemoteArgs->ImpersonateToken,
                                                       SupportDc,
                                                       DnsDomainInfo );

            if ( WinError != ERROR_SUCCESS ) {

                DsRolepLogOnFailure( WinError,
                                     DsRolepLogPrint(( DEB_WARN,
                                                       "Failed to delete the "
                                                       "trust on %ws: %lu\n",
                                                       SupportDc,
                                                       WinError )) );
                if (ERROR_SUCCESS == WinError) {
                    DsRolepLogPrint(( DEB_TRACE,
                                      "Deleted the trust on %ws\n",
                                       SupportDc ));
                }
            }

        } else {

            // This is not a fatal error
            DsRolepLogPrint(( DEB_WARN,
                              "Failed to establish the session with %ws: 0x%lx\n", SupportDc,
                              WinError ));

        }

        //
        // This error is not fatal
        //
        if ( ERROR_SUCCESS != WinError )
        {

            SpmpReportEvent( TRUE,
                             EVENTLOG_WARNING_TYPE,
                             DSROLERES_FAILED_TO_DELETE_TRUST,
                             0,
                             sizeof( ULONG ),
                             &WinError,
                             1,
                             ParentDomainName );

            DSROLEP_SET_NON_FATAL_ERROR( WinError );

            // Error case is handled

            WinError = ERROR_SUCCESS;
        }
    }

    //
    // Finish our NTFRS demotion
    //
    if ( FrsDemote ) {

        WinError = DsRolepFinishSysVolPropagation( TRUE,
                                                   FALSE );

        if ( ERROR_SUCCESS != WinError ) {

            DsRolepLogOnFailure( WinError,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "Failed to finish system volume demotion (%d)\n",
                                                    WinError )) );

            if (ERROR_SUCCESS == WinError) {
                    DsRolepLogPrint(( DEB_TRACE,
                                      "Finished system volume demotion\n" ));
            }
            
        }

        //
        // It is not fatal if the FRS fails at this point
        //
        if ( ERROR_SUCCESS != WinError )
        {
            SpmpReportEvent( TRUE,
                             EVENTLOG_WARNING_TYPE,
                             DSROLERES_FAILED_TO_DEMOTE_FRS,
                             0,
                             sizeof( ULONG ),
                             &WinError,
                             0,
                             NULL );

            DSROLEP_SET_NON_FATAL_ERROR( WinError );

        }

        // Reset status code
        WinError = ERROR_SUCCESS;

    }

    //
    // Call into the SCE so we can be configured to be a server
    //
    WinError = ( *DsrSceDcPromoteSecurityEx )( DemoteArgs->ImpersonateToken,
                                               SCE_PROMOTE_FLAG_DEMOTE,
                                               DsRolepStringUpdateCallback );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_ERROR,
                                               "Setting security on server files failed with %lu\n",
                                               WinError )) );

        if (ERROR_SUCCESS == WinError) {
                DsRolepLogPrint(( DEB_TRACE,
                                  "Set security on server files\n" ));
        }

        // This error has been handled
        WinError = ERROR_SUCCESS;
    }

    //
    // remove all trusted root certificates from DC when the machine will dis-join from the enterprise
    //
    if (DemoteArgs->ServerRole == DsRoleServerStandalone) {

        if (!CertAutoRemove(CERT_AUTO_REMOVE_COMMIT)){

            DsRolepLogPrint(( DEB_WARN,
                              "Failed to remove all trusted root certificates from this machine: (%d)\n",
                              GetLastError()));

        }

    }

    //Delete persistent shares if not done so already.
    NetStatus = NetShareDel( NULL, L"SYSVOL", 0);

    if(NetStatus != ERROR_SUCCESS && NetStatus != NERR_NetNameNotFound) {

        DsRolepLogPrint(( DEB_WARN,
                          "Failed to destroy the share SYSVOL.  Failed with %d\n", NetStatus ));

    }


    NetStatus = NetShareDel( NULL, L"NETLOGON", 0);

    if(NetStatus != ERROR_SUCCESS && NetStatus != NERR_NetNameNotFound) {

        DsRolepLogPrint(( DEB_WARN,
                          "Failed to destroy the share NETLOGON.  Failed with %d\n", NetStatus ));

    }

    //
    // Notify the time server we have completed the demotion
    //
    {

        DWORD dwTimeFlags = W32TIME_DEMOTE;

        if ( DemoteArgs->LastDcInDomain ) {
            //
            // If this is the last Dc in Domain then
            // include this flag.
            //
            dwTimeFlags |= W32TIME_DEMOTE_LAST_DC_IN_DOMAIN;

        }

        (*DsrW32TimeDcPromo)( dwTimeFlags );

    }

    //
    // At this point we have successfully completed the demotion
    //
    ASSERT( ERROR_SUCCESS == WinError );

    //
    // Clear errors components may have erroneously set while running
    //
    DsRolepClearErrors();

DemoteExit:

    if ( Policy ) {

        LsaClose( Policy );
    }

    if ( Credentials ) {

        RtlFreeHeap( RtlProcessHeap(), 0, Credentials );

    }

    if ( pDnsRRInfo ) {

        ( *DsrNtdsFreeDnsRRInfo )(pDnsRRInfo);
        
    }

    //
    // Tear down the session to the parent, if we have one
    //
    if ( IPCConnection ) {

        RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );
        IgnoreError = ImpNetpManageIPCConnect( DemoteArgs->ImpersonateToken,
                                               SupportDc,
                                               DemoteArgs->Account,
                                               DemoteArgs->Password.Buffer,
                                               (NETSETUPP_DISCONNECT_IPC|NETSETUPP_USE_LOTS_FORCE) );
        RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );
        if ( IgnoreError != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_WARN,
                             "Failed to destroy the session with %ws: 0x%lx\n", SupportDc,
                             IgnoreError ));
        }

        IPCConnection = FALSE;
    }

    //
    // Reset our operation handle
    //
    if ( !fNoNetworkOperations ) {
    
        DsRolepSetOperationDone( DSROLEP_OP_DEMOTION, WinError );

    } else {

        DsRolepSetOperationDone( DSROLEP_OP_DEMOTION_FORCED, WinError );

    }

    DsRolepFreeArgumentBlock( &ArgumentBlock, FALSE );

    LsaFreeMemory( DnsDomainInfo );

    RtlFreeHeap( RtlProcessHeap(), 0, ParentDomainName );

    NetApiBufferFree( DomainControllerInfo );

    
    ExitThread( WinError );
    return( WinError );

DemoteUndo:

    //
    // Assert that aomething went wrong if we are here
    //
    ASSERT( ERROR_SUCCESS != WinError );

    //
    // We shouldn't be here if we are in an unrollable state
    //
    ASSERT( FALSE == Unrollable );

    if ( FrsDemote ) {

        IgnoreError = DsRolepFinishSysVolPropagation( FALSE,
                                                      FALSE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to abort system volume demotion (%d)\n",
                                                IgnoreError )) );

        FrsDemote = FALSE;
    }

    if ( NotifiedNetlogonToDeregister ) {

        //
        // "NlDcDemotionCompleted" sounds strange here since the demotion
        // failed.  However, the meaning is that netlogon should now continue
        // to perform as if demotion is not running.  No need to set in the
        // success case since NETLOGON won't be restarted.
        //

        Status = I_NetNotifyDsChange( NlDcDemotionCompleted );
        IgnoreError = RtlNtStatusToDosError( Status );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to tell NETLOGON that demotion is over (%d)\n",
                                                IgnoreError )) );

        NotifiedNetlogonToDeregister = FALSE;
        
    }

    if ( RestartNetlogon ) {

        IgnoreError = DsRolepStartNetlogon();

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to restart netlogon (%d)\n",
                                                IgnoreError )) );

        RestartNetlogon = FALSE;
    }

    if ( DomainControllerServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain controller services configuration (%d)\n",
                                                IgnoreError )) );

        DomainControllerServicesChanged = FALSE;
    }

    if ( DomainServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain controller services configuration (%d)\n",
                                                IgnoreError )) );

        DomainServicesChanged = FALSE;
    }

    if ( DsPrepareDemote ) {

        IgnoreError = ( *DsrNtdsPrepareForDemotionUndo ) ();

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to undo directory service preparation for demotion (%d)\n",
                                                IgnoreError )) );


        DsPrepareDemote = FALSE;

    }

    //
    // Ok -- we have rolled back, make sure we still have an error and then 
    // exit
    //
    ASSERT( ERROR_SUCCESS != WinError );

    goto DemoteExit;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\sysvol.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sysvol.c

Abstract:

    Miscellaneous routines to manage and manipulate the system volume tree

Author:

    Mac McLain          (MacM)       Oct 16, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <loadfn.h>
#include <ntfrsipi.h>
#include <shlwapi.h>
#include "sysvol.h"

//
// Local function prototypes
//
DWORD
DsRolepCreateSysVolLinks(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName
    );

DWORD
DsRolepRemoveDirectoryOrLink(
    IN  LPWSTR Path
    );

DWORD
DsRolepTreeCopy(
    IN LPWSTR Source,
    IN LPWSTR Dest
    );

DWORD
DsRolepValidatePath(
    IN  LPWSTR Path,
    IN  ULONG ValidationCriteria,
    OUT PULONG MatchingCriteria
    )
/*++

Routine Description:

    This function will validate the path against the specified criteria.  This can include
    whether it is local or not, whether it is NTFS, etc.

    If the function returns success, the MatchingCriteria can be examined to find out which
    of the ValidationCriteria are set

Arguments:

    Path - Path to validate

    ValidationCriteria - What to check for.  Refer to DSROLEP_PATH_VALIDATE_*.

    MatchingCriteria - This is where the indications of validity are returned.  If the path
        meets the check, the corresponding bit from the ValidationCriteria is turned on
        here.


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    DWORD Info, Flags, Len;
    WCHAR PathRoot[ 4 ];
    WCHAR Type[ 6 ];

    DsRolepLogPrint(( DEB_TRACE,
                      "Validating path %ws.\n",
                      Path ));


    *MatchingCriteria = 0;
    if ( FLAG_ON( ValidationCriteria, DSROLEP_PATH_VALIDATE_EXISTENCE ) ) {

        Info = GetFileAttributes( Path );

        if ( Info == 0xFFFFFFFF ) {

            Win32Err = GetLastError();

            DsRolepLogPrint(( DEB_ERROR,
                              "\tCan't get file attributes (%lu)\n",
                              Win32Err ));

        } else if ( FLAG_ON( Info, FILE_ATTRIBUTE_DIRECTORY ) ) {

            *MatchingCriteria |= DSROLEP_PATH_VALIDATE_EXISTENCE;

            DsRolepLogPrint(( DEB_TRACE,
                              "\tPath is a directory\n" ));
        } else {

            DsRolepLogPrint(( DEB_WARN,
                              "\tPath is a NOT directory\n" ));

        }

    }

    if ( Win32Err == ERROR_SUCCESS ) {

        wcsncpy( PathRoot, Path, 3 );
        PathRoot[ 3 ] = UNICODE_NULL;
    }

    if ( Win32Err == ERROR_SUCCESS &&
         FLAG_ON( ValidationCriteria, DSROLEP_PATH_VALIDATE_LOCAL ) ) {

        Info = GetDriveType( PathRoot );

        if ( Info == DRIVE_FIXED ) {

            *MatchingCriteria |= DSROLEP_PATH_VALIDATE_LOCAL;

            DsRolepLogPrint(( DEB_TRACE,
                              "\tPath is on a fixed disk drive.\n" ));
        } else {

            DsRolepLogPrint(( DEB_WARN,
                              "\tPath is NOT on a fixed disk drive.\n" ));
        }
    }

    if ( Win32Err == ERROR_SUCCESS &&
         FLAG_ON( ValidationCriteria, DSROLEP_PATH_VALIDATE_NTFS ) ) {

        if ( GetVolumeInformation( PathRoot, NULL, 0, NULL, &Len,
                                   &Flags, Type, sizeof( Type ) / sizeof( WCHAR ) ) == FALSE ) {

           Win32Err = GetLastError();

           //
           // If we've already failed to validate the information, we'll return ERROR_SUCCESS.
           //
           if ( *MatchingCriteria != ( ValidationCriteria & ~DSROLEP_PATH_VALIDATE_NTFS ) ) {

               Win32Err = ERROR_SUCCESS;
           } else {

               DsRolepLogPrint(( DEB_TRACE,
                                 "\tCan't determine if path is on an NTFS volume.\n" ));
           }

        } else {

           if ( _wcsicmp( Type, L"NTFS" ) == 0 ) {

               *MatchingCriteria |= DSROLEP_PATH_VALIDATE_NTFS;

               DsRolepLogPrint(( DEB_TRACE,
                                 "\tPath is on an NTFS volume\n" ));
           } else {

               DsRolepLogPrint(( DEB_WARN,
                                 "\tPath is NOT on an NTFS volume\n" ));

           }
        }
    }

    return( Win32Err );
}


#define DSROLEP_SV_SYSVOL       L"sysvol"
#define DSROLEP_SV_DOMAIN       L"domain"
#define DSROLEP_SV_STAGING_AREA L"staging areas"
#define DSROLEP_SV_STAGING      L"staging"
#define DSROLEP_SV_SCRIPTS      L"scripts"

#define DSROLEP_LONG_PATH_PREFIX    L"\\\\?\\"
DWORD
DsRolepCreateSysVolPath(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FrsReplicaServer, OPTIONAL
    IN  LPWSTR Account,
    IN  LPWSTR Password,
    IN  PWSTR Site,
    IN  BOOLEAN FirstDc
    )
/*++

Routine Description:

    This function will create the system volume tree for use by NTFRS.

Arguments:

    Path - Root path under which to create the system volume tree

    DnsDomainName - Dns domain name

    FrsReplicaServer - The OPTIONAL name of the server to replicate the sysvol from

    Site - Site this Dc is in

    FirstDc - If TRUE, this is the first Dc in a domain

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, Win32Err2;
    PWSTR RelativePaths[] = {
        DSROLEP_SV_DOMAIN,
        DSROLEP_SV_DOMAIN L"\\" DSROLEP_SV_SCRIPTS,  // DO NOT CHANGE THIS POSITION without also
                                                     // updating ScriptsIndex below
        DSROLEP_SV_STAGING_AREA,
        DSROLEP_SV_STAGING,
        DSROLEP_SV_STAGING L"\\" DSROLEP_SV_DOMAIN,
        DSROLEP_SV_SYSVOL                           // This must always be the last thing
                                                    // in the list

        };
    ULONG ScriptsIndex = 1; // DO NOT CHANGE THIS with out changing the position of the
                            // DOMAIN\\SCRIPTS entry above
    PWSTR CreatePath = NULL, PathEnd = NULL;
    PWSTR StagingPath = NULL, StagingPathEnd;
    ULONG MaxPathLen, i;
    BOOLEAN RootCreated = FALSE;

    //
    // Make sure the buffer is big enough to hold everything.  The
    // longest path is the domain root under the staging area
    //
    MaxPathLen = sizeof( DSROLEP_LONG_PATH_PREFIX ) +
                 ( wcslen( Path ) * sizeof( WCHAR ) ) +
                 sizeof( WCHAR ) +
                 sizeof( DSROLEP_SV_STAGING_AREA ) +
                 sizeof( WCHAR ) +
                 ( ( wcslen( DnsDomainName ) + 1 ) * sizeof( WCHAR ) );




    CreatePath = RtlAllocateHeap( RtlProcessHeap(), 0, MaxPathLen );

    if ( CreatePath == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        //
        // The path exceeds max path, so prepend the \\?\ that allows
        // for paths greater than max path
        //
        if ( MaxPathLen > MAX_PATH * sizeof( WCHAR ) ) {

            swprintf( CreatePath,
                      L"\\\\?\\%ws",
                      Path );

        } else {

            wcscpy( CreatePath, Path );
        }
    }



    //
    // Create the root path, if it doesn't exist
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        PathEnd = CreatePath + wcslen( CreatePath );

         if ( CreateDirectory( CreatePath, NULL ) == FALSE ) {

            Win32Err = GetLastError();

            if ( Win32Err == ERROR_ALREADY_EXISTS) {

                //
                // The path exists, so delete it...
                //
                DsRolepLogPrint(( DEB_TRACE,
                                  "Deleting current sysvol path %ws \n",
                                  CreatePath ));
                Win32Err = DsRolepDelnodePath( CreatePath,
                                               MaxPathLen,
                                               FALSE );

                if ( Win32Err == ERROR_INVALID_PARAMETER ) {

                    Win32Err = ERROR_SUCCESS;
                }

            } else if ( Win32Err == ERROR_ACCESS_DENIED && PathIsRoot(CreatePath) ){

                //The sysvol cannot be path at a root directry (i.e. d:\)
                //note: d:\sysvol would be legal
                DSROLEP_FAIL0( Win32Err, DSROLERES_FAILED_SYSVOL_CANNOT_BE_ROOT_DIRECTORY )
                goto Exit;

            } else {

                DsRolepLogPrint(( DEB_TRACE,
                                  "Failed to create path %ws: %lu\n",
                                  CreatePath,
                                  Win32Err ));
            }

        } else {

            RootCreated = TRUE;

        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *PathEnd = L'\\';
        PathEnd++;
    } else {

        //
        // Bail, with a specific error
        //
        DSROLEP_FAIL0( Win32Err, DSROLERES_SYSVOL_DIR_ERROR )

        goto Exit;

    }

    //
    // Now, create the rest of the paths...
    //
    for ( i = 0;
          i < sizeof( RelativePaths ) / sizeof( PWSTR ) &&
            Win32Err == ERROR_SUCCESS;
          i++ ) {


        //
        // Only create the scripts directory on the first dc
        //
        if ( i == ScriptsIndex && !FirstDc ) {

            continue;
        }
        wcscpy( PathEnd, RelativePaths[ i ] );

        if( CreateDirectory( CreatePath, NULL ) == FALSE ) {

            Win32Err = GetLastError();

            DsRolepLogPrint(( DEB_TRACE,
                              "Failed to create path %ws: %lu\n",
                               CreatePath,
                               Win32Err ));
            break;


        }
    }

    //
    // Then, create the symbolic links
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        *PathEnd = UNICODE_NULL;
        Win32Err = DsRolepCreateSysVolLinks( Path, DnsDomainName );
    }

    //
    // Prepare for replication of sysvol
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Make sure the path for the staging area is large enough
        //
        StagingPath = RtlAllocateHeap( RtlProcessHeap(), 0, MaxPathLen );

        if ( StagingPath == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // The path exceeds max path, so prepend the \\?\ that allows
            // for paths greater than max path
            //
            swprintf( StagingPath,
                      L"\\\\?\\%ws",
                      Path );
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            StagingPathEnd = StagingPath + wcslen( StagingPath );

            if ( *StagingPathEnd != L'\\' ) {

                *StagingPathEnd = L'\\';
                StagingPathEnd++;
            }

            DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtFrsApi_PrepareForPromotionW );

            if ( Win32Err == ERROR_SUCCESS ) {

                ASSERT( DsrNtFrsApi_PrepareForPromotionW );
                Win32Err = ( *DsrNtFrsApi_PrepareForPromotionW )( DsRolepStringErrorUpdateCallback );

                if ( Win32Err == ERROR_SUCCESS ) {

                    //
                    // Build the domain sysvol
                    //
                    swprintf( StagingPathEnd,
                              L"%ws\\%ws",
                              DSROLEP_SV_STAGING_AREA,
                              DnsDomainName );

                    swprintf( PathEnd,
                              L"%ws\\%ws",
                              DSROLEP_SV_SYSVOL,
                              DnsDomainName );

                    Win32Err = ( *DsrNtFrsApi_StartPromotionW )(
                                   FrsReplicaServer,
                                   Account,
                                   Password,
                                   DsRolepStringUpdateCallback,
                                   DsRolepStringErrorUpdateCallback,
                                   DnsDomainName,
                                   NTFRSAPI_REPLICA_SET_TYPE_DOMAIN,
                                   FirstDc,
                                   StagingPath,
                                   CreatePath );

                    if ( Win32Err != ERROR_SUCCESS ) {


                        DsRolepLogPrint(( DEB_ERROR,
                                          "NtFrsApi_StartPromotionW on %ws / %ws / %ws failed with %lu\n",
                                          DnsDomainName,
                                          StagingPath,
                                          CreatePath,
                                          Win32Err ));
                        Win32Err2 = DsRolepFinishSysVolPropagation( FALSE, TRUE );
                        ASSERT( Win32Err2 == ERROR_SUCCESS );
                    }

                } else {

                    DsRolepLogPrint(( DEB_ERROR,
                                      "NtFrsApi_PrepareForPromotionW failed with %lu\n",
                                      Win32Err ));

                }
            }

        }
    }

    //
    // If something failed, delete the created sysvol tree
    //
    if ( Win32Err != ERROR_SUCCESS ) {

        Win32Err2 = DsRolepDelnodePath( CreatePath,
                                        MaxPathLen,
                                        RootCreated );

        if ( Win32Err2 != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_TRACE,
                              "Failed to delete path %ws: %lu\n",
                              CreatePath,
                              Win32Err2 ));
        }

    }

Exit:

    //
    // Free the path buffers if allocated
    //
    if ( CreatePath  ) {

        RtlFreeHeap( RtlProcessHeap(), 0, CreatePath );
    }

    if ( StagingPath  ) {

        RtlFreeHeap( RtlProcessHeap(), 0, StagingPath );
    }

    return( Win32Err );
}

DWORD
DsRolepRemoveSysVolPath(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName,
    IN  GUID *DomainGuid
    )
/*++

Routine Description:

    This function will remote the create system volume tree

Arguments:

    Path - Root path under which to create the system volume tree

    DnsDomainName - Dns domain name

    DomainGuid - The Guid of the new domain

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    //
    // If we can't reset the FRS domain guid, do NOT remove the tree.  Otherwise, this
    // delete will propagate around!
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepDelnodePath( Path, ( wcslen( Path ) + 1 ) * sizeof( WCHAR ), TRUE );
    }

    return( Win32Err );
}



#define DSROLEP_ALL_STR L"\\*.*"
DWORD
DsRolepDelnodePath(
    IN  LPWSTR Path,
    IN  ULONG BufferSize,
    IN  BOOLEAN DeleteRoot
    )
/*++

Routine Description:

    This function removes the specified file path

Arguments:

    Path - Root path to delete

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle = INVALID_HANDLE_VALUE;
    ULONG Len, PathLen = wcslen( Path );
    PWSTR FullPath, FindPath;
    WCHAR PathBuff[ MAX_PATH + 1];


    //
    // See if we need to allocate a buffer
    //
    Len = sizeof( DSROLEP_ALL_STR ) + ( PathLen * sizeof( WCHAR ) );
    if ( BufferSize >= Len ) {

        FindPath = Path;
        wcscat( FindPath, DSROLEP_ALL_STR );

    } else {

        FindPath = RtlAllocateHeap( RtlProcessHeap(), 0, Len );

        if ( FindPath == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            swprintf( FindPath, L"%ws%ws", Path, DSROLEP_ALL_STR );
        }
    }


    if ( Win32Err == ERROR_SUCCESS ) {

        FindHandle = FindFirstFile( FindPath, &FindData );

        if ( FindHandle == INVALID_HANDLE_VALUE ) {

            Win32Err = GetLastError();

            //
            // If we get back a path not found error, it's probably a link that we delete the
            // supporting storage for.  This is not considered an error.
            //
            if ( Win32Err == ERROR_PATH_NOT_FOUND ) {

                Win32Err = ERROR_NO_MORE_FILES;
            }


            if ( Win32Err != ERROR_SUCCESS && Win32Err != ERROR_NO_MORE_FILES ) {

                DsRolepLogPrint(( DEB_ERROR,
                                  "FindFirstFile on %ws failed with %lu\n",
                                  FindPath, Win32Err ));
            }

        }

    }


    while ( Win32Err == ERROR_SUCCESS ) {

        if ( wcscmp( FindData.cFileName, L"." ) &&
             wcscmp( FindData.cFileName, L".." ) ) {

            Len = ( wcslen( FindData.cFileName ) + 1 + PathLen + 1 ) * sizeof( WCHAR );

            if ( Len > sizeof( FullPath ) ) {

                FullPath = RtlAllocateHeap( RtlProcessHeap(), 0, Len );

                if ( FullPath == NULL ) {

                    Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                }

            } else {

                FullPath = PathBuff;
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                Path[ PathLen ] = UNICODE_NULL;
                swprintf( FullPath, L"%ws\\%ws", Path, FindData.cFileName );


                if ( FLAG_ON( FindData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY ) ) {

                    Win32Err = DsRolepDelnodePath( FullPath, Len, TRUE );

                } else {

                    //
                    //  Remove the readonly/hidden bits
                    //
                    SetFileAttributes( FullPath,
                                       FILE_ATTRIBUTE_NORMAL );


                    if ( DeleteFileW( FullPath ) == FALSE ) {

                        Win32Err = GetLastError();
                        if ( Win32Err != ERROR_SUCCESS ) {

                            DsRolepLogPrint(( DEB_ERROR,
                                              "DeleteFileW on %ws failed with %lu\n",
                                              FullPath, Win32Err ));
                        }
                    }
                }
            }

            if ( FullPath != PathBuff ) {

                RtlFreeHeap( RtlProcessHeap(), 0, FullPath );
            }
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            if ( FindNextFile( FindHandle, &FindData ) == FALSE ) {

                Win32Err = GetLastError();
            }

            if ( Win32Err != ERROR_SUCCESS && Win32Err != ERROR_NO_MORE_FILES ) {

                DsRolepLogPrint(( DEB_ERROR,
                                  "FindNextFile after on %ws failed with %lu\n",
                                  FindData.cFileName, Win32Err ));
            }
        }
    }

    //
    // Close the handle before trying to remove the directory
    //
    if ( FindHandle != INVALID_HANDLE_VALUE ) {

        FindClose( FindHandle );
    }

    if ( Win32Err == ERROR_SUCCESS || Win32Err == ERROR_NO_MORE_FILES ) {

        Win32Err = ERROR_SUCCESS;

    }

    //
    // Remove the directory
    //
    if ( DeleteRoot && Win32Err == ERROR_SUCCESS ) {


        Win32Err = DsRolepRemoveDirectoryOrLink( Path );

        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Removal of path %ws failed with %lu\n",
                              Path, Win32Err ));
        }
    }

    //
    // Cleanup
    //
    if ( FindPath != Path ) {

        RtlFreeHeap( RtlProcessHeap(), 0, FindPath );
    }

    return( Win32Err );
}



DWORD
DsRolepRemoveDirectoryOrLink(
    IN  LPWSTR Path
    )
/*++

Routine Description:

    This function removes the symbolic link or directory indicated

Arguments:

    Path - Path to remove


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Attributes;
    UNICODE_STRING NtPath;
    OBJECT_ATTRIBUTES ObjectAttrs;
    HANDLE Handle;
    IO_STATUS_BLOCK IOSb;
    FILE_DISPOSITION_INFORMATION Disposition = {
        TRUE
        };

    Attributes = GetFileAttributes( Path );
    Attributes &= ~( FILE_ATTRIBUTE_HIDDEN    |
                        FILE_ATTRIBUTE_SYSTEM |
                        FILE_ATTRIBUTE_READONLY );

    if ( !SetFileAttributes( Path, Attributes ) ) {

        return( GetLastError() );
    }

    //
    // Initialize
    //
    NtPath.Buffer = NULL;

    //
    // Convert the name
    //
    if ( RtlDosPathNameToNtPathName_U( Path, &NtPath, NULL, NULL ) == FALSE ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Open the object
    //
    if ( NT_SUCCESS( Status ) ) {

        InitializeObjectAttributes( &ObjectAttrs, &NtPath, OBJ_CASE_INSENSITIVE, NULL, NULL );

        Status = NtOpenFile( &Handle,
                             SYNCHRONIZE | FILE_READ_DATA | DELETE,
                             &ObjectAttrs,
                             &IOSb,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             FILE_OPEN_FOR_BACKUP_INTENT            |
                                    FILE_OPEN_REPARSE_POINT         |
                                    FILE_SYNCHRONOUS_IO_NONALERT );


        if ( NT_SUCCESS( Status ) ) {

            Status = NtSetInformationFile( Handle,
                                           &IOSb,
                                           &Disposition,
                                           sizeof( Disposition ),
                                           FileDispositionInformation );

            NtClose( Handle );
        }
    }

    //
    // Free the memory
    //
    if ( NtPath.Buffer ) {

        RtlFreeUnicodeString( &NtPath );
    }


    if ( !NT_SUCCESS( Status )  ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to delete %ws: 0x%lx\n",
                          Path,
                          Status ));
    }

    return( RtlNtStatusToDosError( Status ) );
}


#pragma warning(push)
#pragma warning(disable:4701)


DWORD
DsRolepCreateSymLink(
    IN  LPWSTR LinkPath,
    IN  LPWSTR LinkValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING Link, Value, DosValue;
    OBJECT_ATTRIBUTES ObjectAttrs;
    HANDLE Handle;
    IO_STATUS_BLOCK IOSb;
    PREPARSE_DATA_BUFFER ReparseBufferHeader = NULL;
    PCHAR ReparseBuffer = NULL;
    ULONG Len;

    //
    // Initialize
    //
    Link.Buffer = NULL;
    Value.Buffer = NULL;

    //
    // Convert the names
    //
    if ( RtlDosPathNameToNtPathName_U( LinkPath, &Link, NULL, NULL ) ) {

        if ( RtlDosPathNameToNtPathName_U( LinkValue, &Value, NULL, NULL ) ) {

            RtlInitUnicodeString( &DosValue, LinkValue );

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Open the object
    //
    if ( NT_SUCCESS( Status ) ) {

        InitializeObjectAttributes( &ObjectAttrs, &Link, OBJ_CASE_INSENSITIVE, NULL, NULL );
        Status = NtCreateFile( &Handle,
                               SYNCHRONIZE | FILE_WRITE_DATA,
                               &ObjectAttrs,
                               &IOSb,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                               FILE_OPEN,
                               FILE_OPEN_REPARSE_POINT,
                               NULL,
                               0 );

        if ( NT_SUCCESS( Status ) ) {

            Len = ( FIELD_OFFSET( REPARSE_DATA_BUFFER,
                                 MountPointReparseBuffer.PathBuffer ) -
                    REPARSE_DATA_BUFFER_HEADER_SIZE ) +
                    Value.Length + sizeof(UNICODE_NULL) +
                    DosValue.Length + sizeof(UNICODE_NULL);

            ReparseBufferHeader = RtlAllocateHeap( RtlProcessHeap(),
                                                   0,
                                                   REPARSE_DATA_BUFFER_HEADER_SIZE + Len );
            if ( ReparseBufferHeader == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                ReparseBufferHeader->ReparseDataLength = (USHORT)Len;
                ReparseBufferHeader->Reserved = 0;
                ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
                ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength =
                                                            Value.Length;
                ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset =
                                                            Value.Length + sizeof( UNICODE_NULL );
                ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength =
                                                            DosValue.Length;
                RtlCopyMemory( ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
                               Value.Buffer,
                               Value.Length );

                RtlCopyMemory( (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
                                    Value.Length + sizeof(UNICODE_NULL),
                                DosValue.Buffer,
                                DosValue.Length );

                ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;

                Status = NtFsControlFile( Handle,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &IOSb,
                                          FSCTL_SET_REPARSE_POINT,
                                          ReparseBufferHeader,
                                          REPARSE_DATA_BUFFER_HEADER_SIZE +
                                                           ReparseBufferHeader->ReparseDataLength,
                                          NULL,
                                          0 );

                RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );

            }

            NtClose( Handle );
        }

    }
    //
    // Free any allocated strings
    //
    if ( Link.Buffer ) {

        RtlFreeUnicodeString( &Link );
    }

    if ( Value.Buffer ) {

        RtlFreeUnicodeString( &Value );
    }

    if ( !NT_SUCCESS( Status )  ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to create the link between %ws and %ws: 0x%lx\n",
                          LinkPath,
                          LinkValue,
                          Status ));
    }

    return( RtlNtStatusToDosError( Status ) );
}

#pragma warning(pop)



DWORD
DsRolepCreateSysVolLinks(
    IN  LPWSTR Path,
    IN  PWSTR DnsDomainName
    )
/*++

Routine Description:

    This function creates the symbolic links used by the system volume tree

Arguments:

    Path - Root path under which to create the links

    DnsDomainName - The Dns domain name of the new domain


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR DestPathBuf[ MAX_PATH + 5];
    WCHAR LinkPathBuf[ MAX_PATH + 5];
    PWSTR DestPath = DestPathBuf, LinkPath = LinkPathBuf;
    PWSTR DestPathEnd = NULL, LinkPathEnd = NULL;
    ULONG MaxPathLen, DnsDomainNameSize, Len = wcslen( Path );


    if ( * ( Path + Len - 1 ) == L'\\' ) {

        Len--;
        *( Path + Len ) = UNICODE_NULL;
    }

    //
    // The longest destination path is the path\\staging\\DnsDomainName
    //
    MaxPathLen = (ULONG)(( sizeof( DSROLEP_SV_STAGING L"\\" ) + 1 ) +
                 ( ( wcslen ( DnsDomainName ) + 1 ) * sizeof( WCHAR ) ) +
                 ( ( Len + 5 ) * sizeof( WCHAR ) ));

    if ( MaxPathLen > sizeof( DestPathBuf ) / 4 ) {

        DestPath = RtlAllocateHeap( RtlProcessHeap(), 0, MaxPathLen );

        if ( DestPath == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // The path exceeds max path, so prepend the \\?\ that allows
            // for paths greater than max path
            //
            swprintf( DestPath,
                      L"\\\\?\\%ws\\",
                      Path );
        }

    } else {

        swprintf( DestPath, L"%ws\\", Path );
    }



    //
    // The longest link path is the domain named one
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DestPathEnd = DestPath + wcslen( DestPath );

        DnsDomainNameSize = wcslen( DnsDomainName ) * sizeof( WCHAR );

        MaxPathLen = (ULONG)(sizeof( DSROLEP_SV_STAGING_AREA )  + 1 +
                     sizeof( DSROLEP_SV_SYSVOL ) +
                     ( ( wcslen( Path ) + 5 ) * sizeof( WCHAR ) )+
                     DnsDomainNameSize);

        if ( MaxPathLen > sizeof( LinkPathBuf ) / 4 ) {

            LinkPath = RtlAllocateHeap( RtlProcessHeap(), 0, MaxPathLen );

            if ( LinkPath == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                //
                // The path exceeds max path, so prepend the \\?\ that allows
                // for paths greater than max path
                //
                swprintf( LinkPath,
                          L"\\\\?\\%ws\\%ws\\",
                          Path,
                          DSROLEP_SV_SYSVOL );
            }

        } else {

            swprintf( LinkPath, L"%ws\\%ws\\", Path, DSROLEP_SV_SYSVOL );
        }

    }

    //
    // Then, the domain path
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        LinkPathEnd = LinkPath + wcslen( LinkPath );

        wcscpy( DestPathEnd, DSROLEP_SV_DOMAIN );
        wcscpy( LinkPathEnd, DnsDomainName );

        if ( CreateDirectory( LinkPath, NULL ) == FALSE ) {

            Win32Err = GetLastError();

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to create the link directory %ws: %lu\n",
                              LinkPath,
                              Win32Err ));
        } else {

            Win32Err = DsRolepCreateSymLink( LinkPath, DestPath );
        }
    }

    //
    // Finally, the domain link for the staging area.
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        LinkPathEnd--;
        while ( *( LinkPathEnd - 1 ) != L'\\' ) {

            LinkPathEnd--;
        }

        swprintf( DestPathEnd, L"%ws\\%ws", DSROLEP_SV_STAGING, DSROLEP_SV_DOMAIN  );
        swprintf( LinkPathEnd, L"%ws\\%ws", DSROLEP_SV_STAGING_AREA, DnsDomainName );

        if ( CreateDirectory( LinkPath, NULL ) == FALSE ) {

            Win32Err = GetLastError();

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to create the link directory %ws: %lu\n",
                              LinkPath,
                              Win32Err ));
        } else {

            Win32Err = DsRolepCreateSymLink( LinkPath, DestPath );
        }
    }

    //
    // Clean up any allocated buffers
    //
    if ( DestPath != DestPathBuf ) {

        RtlFreeHeap( RtlProcessHeap(), 0, DestPath );
    }

    if ( LinkPath != LinkPathBuf ) {

        RtlFreeHeap( RtlProcessHeap(), 0, LinkPath );
    }

    return( Win32Err );
}



#define DSROLEP_FRS_PATH        \
L"\\Registry\\Machine\\System\\CurrentControlSet\\services\\NtFrs\\parameters\\sysvol\\"
#define DSROLEP_FRS_COMMAND     L"ReplicaSetCommand"
#define DSROLEP_FRS_NAME        L"ReplicaSetName"
#define DSROLEP_FRS_TYPE        L"ReplicaSetType"
#define DSROLEP_FRS_SITE        L"ReplicaSetSite"
#define DSROLEP_FRS_PRIMARY     L"ReplicaSetPrimary"
#define DSROLEP_FRS_STAGE       L"ReplicationStagePath"
#define DSROLEP_FRS_ROOT        L"ReplicationRootPath"
#define DSROLEP_FRS_CREATE      L"Create"
#define DSROLEP_FRS_DELETE      L"Delete"

#define DSROLEP_NETLOGON_PATH        \
L"System\\CurrentControlSet\\services\\Netlogon\\parameters\\"
#define DSROLEP_NETLOGON_SYSVOL     L"SysVol"
#define DSROLEP_NETLOGON_SCRIPTS    L"Scripts"

DWORD
DsRolepGetNetlogonScriptsPath(
    IN HKEY NetlogonHandle,
    OUT LPWSTR *ScriptsPath
    )
/*++

Routine Description:

    This function reads the old netlogon scripts path and expands it to a valid path

Arguments:

    NetlogonHandle - Open handle to the netlogon parameters registry key

    ScriptsPath -- Where the expanded path is retunred.

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR TempPath = NULL;
    ULONG Type, Length = 0;

    //
    // First, get the current scripts path
    //
    Win32Err = RegQueryValueEx( NetlogonHandle,
                                DSROLEP_NETLOGON_SCRIPTS,
                                0, // reserved
                                &Type,
                                0,
                                &Length );

    if ( Win32Err == ERROR_SUCCESS ) {

        *ScriptsPath = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

        if ( *ScriptsPath == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            Win32Err = RegQueryValueEx( NetlogonHandle,
                                        DSROLEP_NETLOGON_SCRIPTS,
                                        0,
                                        &Type,
                                        ( PBYTE )*ScriptsPath,
                                        &Length );


            if ( Win32Err == ERROR_SUCCESS && Type == REG_EXPAND_SZ ) {

                Length = ExpandEnvironmentStrings( *ScriptsPath,
                                                   TempPath,
                                                   0 );
                if ( Length == 0 ) {

                    Win32Err = GetLastError();

                } else {

                    TempPath = RtlAllocateHeap( RtlProcessHeap(), 0,
                                                ( Length + 1 ) * sizeof( WCHAR ) );

                    if ( TempPath == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Length = ExpandEnvironmentStrings( *ScriptsPath,
                                                           TempPath,
                                                           Length );
                        if ( Length == 0 ) {

                            Win32Err = GetLastError();
                            RtlFreeHeap( RtlProcessHeap(), 0, TempPath );

                        } else {

                            RtlFreeHeap( RtlProcessHeap(), 0, *ScriptsPath );
                            *ScriptsPath = TempPath;
                        }

                    }
                }
            }
        }
    }

    return( Win32Err );
}


DWORD
DsRolepSetNetlogonSysVolPath(
    IN LPWSTR SysVolRoot,
    IN LPWSTR DnsDomainName,
    IN BOOLEAN IsUpgrade,
    IN OUT PBOOLEAN OkToCleanup
    )
/*++

Routine Description:

    This function sets the root of the system volume in the Netlogon parameters section
    of the registry.  The value is set under the key SysVol.

Arguments:

    SysVolRoot - Path to the root of the system volume to be set

    DnsDomainName - Name of the dns domain name

    IsUpgrade - If TRUE, this means that logon scripts are moved

    OkToCleanup - A flag is returned here indicating whether the old scripts can be cleaned up

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    HKEY  NetlogonHandle = NULL;
    PWSTR OldScriptsPath = NULL, NewScriptsPath = NULL, TempPath, FullSysVolPath = NULL;
    ULONG Type, Length;

    if ( OkToCleanup ) {

        *OkToCleanup =  FALSE;
    }

    //
    // Build the full scripts path
    //
    FullSysVolPath = RtlAllocateHeap( RtlProcessHeap(), 0,
                                       ( wcslen( SysVolRoot ) + 1 )  * sizeof( WCHAR ) +
                                        sizeof( DSROLEP_SV_SYSVOL ) );

    if ( FullSysVolPath == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        wcscpy( FullSysVolPath, SysVolRoot );

        if ( FullSysVolPath[ wcslen( FullSysVolPath ) - 1 ] != L'\\' ) {

            wcscat( FullSysVolPath, L"\\" );
        }

        wcscat( FullSysVolPath, DSROLEP_SV_SYSVOL );

        SysVolRoot = FullSysVolPath;
    }

    //
    // Open the netlogon key
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 DSROLEP_NETLOGON_PATH,
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 &NetlogonHandle );

        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to open %ws: %lu\n", DSROLEP_NETLOGON_PATH, Win32Err ));

            return( Win32Err );
        }

        //
        // First, set the sysvol key
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = RegSetValueEx( NetlogonHandle,
                                      DSROLEP_NETLOGON_SYSVOL,
                                      0,
                                      REG_SZ,
                                      ( CONST PBYTE )SysVolRoot,
                                      ( wcslen( SysVolRoot ) + 1 ) * sizeof( WCHAR ) );

            if ( Win32Err != ERROR_SUCCESS ) {

                DsRolepLogPrint(( DEB_ERROR,
                                  "Failed to set %ws: %lu\n", DSROLEP_NETLOGON_SYSVOL, Win32Err ));

            }

        }
    }

    //
    // If this is an upgrade, move the scripts...
    //
    if ( Win32Err == ERROR_SUCCESS && IsUpgrade ) {

        Win32Err = DsRolepGetNetlogonScriptsPath( NetlogonHandle,
                                                  &OldScriptsPath );


        if ( Win32Err == ERROR_SUCCESS ) {

            //
            // Build the new scripts path
            //
            Length = wcslen( SysVolRoot ) + 1 + wcslen( DnsDomainName ) + 1 +
                            ( sizeof( DSROLEP_NETLOGON_SCRIPTS ) / sizeof( WCHAR ) + 1 );

            if ( Length > MAX_PATH ) {

                Length += 5;
            }


            NewScriptsPath = RtlAllocateHeap( RtlProcessHeap(), 0,
                                              Length  * sizeof( WCHAR ) );

            if ( NewScriptsPath == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                if ( Length > MAX_PATH ) {

                    wcscpy( NewScriptsPath, L"\\\\?\\" );

                } else {

                    *NewScriptsPath = UNICODE_NULL;
                }

                wcscat( NewScriptsPath, SysVolRoot );

                if ( NewScriptsPath[ wcslen( SysVolRoot ) - 1 ] != L'\\' ) {

                    wcscat( NewScriptsPath, L"\\" );
                }

                wcscat( NewScriptsPath, DnsDomainName );
                wcscat( NewScriptsPath, L"\\" );
                wcscat( NewScriptsPath, DSROLEP_NETLOGON_SCRIPTS );
            }
        }

        //
        // Now, the copy...
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            DSROLEP_CURRENT_OP2( DSROLEEVT_MOVE_SCRIPTS, OldScriptsPath, NewScriptsPath );

            Win32Err = DsRolepTreeCopy( OldScriptsPath, NewScriptsPath );

            if ( Win32Err != ERROR_SUCCESS ) {


                DsRolepLogPrint(( DEB_ERROR,
                                  "DsRolepTreeCopy from %ws to %ws failed with %lu\n",
                                  OldScriptsPath,
                                  NewScriptsPath,
                                  Win32Err ));

            }
            DSROLEP_CURRENT_OP0( DSROLEEVT_SCRIPTS_MOVED );
        }





        if ( Win32Err != ERROR_SUCCESS ) {

            //
            // Raise the an event
            //
            SpmpReportEvent( TRUE,
                             EVENTLOG_WARNING_TYPE,
                             DSROLERES_FAIL_SCRIPT_COPY,
                             0,
                             sizeof( ULONG ),
                             &Win32Err,
                             2,
                             OldScriptsPath,
                             NewScriptsPath );

            DSROLEP_SET_NON_FATAL_ERROR( Win32Err );

            Win32Err = ERROR_SUCCESS;

        }

        RtlFreeHeap( RtlProcessHeap(), 0, OldScriptsPath );
        RtlFreeHeap( RtlProcessHeap(), 0, NewScriptsPath );

    }

    if ( OkToCleanup ) {
        *OkToCleanup = TRUE;
    }

    //
    // Close the handle
    //
    if ( NetlogonHandle ) {

        RegCloseKey( NetlogonHandle );
    }

    RtlFreeHeap( RtlProcessHeap(), 0, FullSysVolPath );

    return( Win32Err );
}


DWORD
DsRolepCleanupOldNetlogonInformation(
    VOID
    )
/*++

Routine Description:

    This function cleans up the old netlogon scripts information, including deleting the
    registry key and deleting the old scripts.  It should only be called after netlogon has'
    been successfully upgraded

Arguments:


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err, Win32Err2;
    HKEY  NetlogonHandle = NULL;
    PWSTR OldScriptsPath = NULL;

    DsRolepLogPrint(( DEB_TRACE,
                      "Cleaning up old Netlogon information\n"));
    //
    // Open the netlogon key
    //
    Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             DSROLEP_NETLOGON_PATH,
                             0,
                             KEY_READ | KEY_WRITE,
                             &NetlogonHandle );

    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to open %ws: %lu\n", DSROLEP_NETLOGON_PATH, Win32Err ));

    } else {

        Win32Err = DsRolepGetNetlogonScriptsPath( NetlogonHandle,
                                                  &OldScriptsPath );
        if ( ERROR_FILE_NOT_FOUND == Win32Err) {

            Win32Err = ERROR_SUCCESS;
            goto cleanup;

        }

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsRolepDelnodePath( OldScriptsPath, wcslen( OldScriptsPath), FALSE );

        }

        //
        // Finally, delete the scripts key
        //
        Win32Err2 = RegDeleteValue( NetlogonHandle, DSROLEP_NETLOGON_SCRIPTS );

        if ( Win32Err2 != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to delete registry key %ws: %lu\n",
                              DSROLEP_NETLOGON_SCRIPTS, Win32Err2 ));

        }

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = Win32Err2;
        }

    }

    cleanup:

    if ( NetlogonHandle ) {
        RegCloseKey( NetlogonHandle );
    }

    if ( OldScriptsPath ) {
        RtlFreeHeap( RtlProcessHeap(), 0, OldScriptsPath );
    }

    return( Win32Err );
}






DWORD
DsRolepFinishSysVolPropagation(
    IN BOOLEAN Commit,
    IN BOOLEAN Promote
    )
/*++

Routine Description:

    This function will commit or abort an NTFRS initial propagation

Arguments:

    Commit - If TRUE, the operation is committed.  If FALSE, the operation is aborted

    Promote - If TRUE, the operation is a promotion.  If FALSE, the operation is a demotion

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    if ( Commit ) {

        if ( Promote ) {

            ASSERT( DsrNtFrsApi_WaitForPromotionW );
            Win32Err = ( *DsrNtFrsApi_WaitForPromotionW )( INFINITE,
                                                           DsRolepStringErrorUpdateCallback );

            if ( Win32Err == ERROR_SUCCESS ) {

                ASSERT( DsrNtFrsApi_CommitPromotionW );
                Win32Err = ( *DsrNtFrsApi_CommitPromotionW )( INFINITE,
                                                              DsRolepStringErrorUpdateCallback );
            }

        } else {

            ASSERT( DsrNtFrsApi_WaitForDemotionW );
            Win32Err = ( *DsrNtFrsApi_WaitForDemotionW )( INFINITE,
                                                          DsRolepStringErrorUpdateCallback );

            if ( Win32Err == ERROR_SUCCESS ) {

                ASSERT( DsrNtFrsApi_CommitDemotionW );
                Win32Err = ( *DsrNtFrsApi_CommitDemotionW )( INFINITE,
                                                             DsRolepStringErrorUpdateCallback );
            }
        }

    } else {

        if ( Promote ) {

            ASSERT( DsrNtFrsApi_AbortPromotionW );
            Win32Err = ( *DsrNtFrsApi_AbortPromotionW )();

        } else {

            ASSERT( DsrNtFrsApi_AbortDemotionW );
            Win32Err =  ( *DsrNtFrsApi_AbortDemotionW )();
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "DsRolepFinishSysVolPropagation (%S %S) failed with %lu\n",
                          Commit ? "Commit" : "Abort",
                          Promote ? "Promote" : "Demote",
                          Win32Err ));

    }
    return( Win32Err );
}


DWORD
DsRolepAllocAndCopyPath(
    IN LPWSTR Source,
    IN LPWSTR Component,
    OUT LPWSTR *FullPath
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG Len = 0;
    BOOL ExtPath = FALSE;

    Len = wcslen( Source ) + 1 + wcslen( Component ) + 1;

    if ( Len > MAX_PATH ) {

        Len += 5;
        ExtPath = TRUE;
    }

    *FullPath = RtlAllocateHeap( RtlProcessHeap(), 0, Len * sizeof( WCHAR ) );

    if ( *FullPath == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {


        if ( ExtPath ) {

            swprintf( *FullPath, L"\\\\?\\%ws\\%ws", Source, Component );

        } else {

            swprintf( *FullPath, L"%ws\\%ws", Source, Component );
        }
    }

    return( Win32Err );
}



DWORD
DsRolepTreeCopy(
    IN LPWSTR Source,
    IN LPWSTR Dest
    )
/*++

Routine Description:

    This function will do a tree copy from the source directory to the destination

Arguments:

    Source - Source dir

    Dest - Dest dir

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WIN32_FIND_DATA FindData;
    PWSTR SourcePath = NULL, DestPath = NULL, TempPath;
    HANDLE FindHandle = INVALID_HANDLE_VALUE;

    //
    // Build the path for findfirst/findnext
    //
    Win32Err = DsRolepAllocAndCopyPath( Source,
                                        L"*.*",
                                        &SourcePath );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto TreeCopyError;
    }


    //
    // Now, enumerate the paths
    //
    FindHandle = FindFirstFile( SourcePath, &FindData );

    if ( FindHandle == INVALID_HANDLE_VALUE ) {

        Win32Err = GetLastError();
        DsRolepLogPrint(( DEB_ERROR,
                          "FindFirstFile on %ws failed with %lu\n",
                          Source, Win32Err ));
        goto TreeCopyError;
    }



    while ( Win32Err == ERROR_SUCCESS ) {

        if ( wcscmp( FindData.cFileName, L"." ) &&
             wcscmp( FindData.cFileName, L".." ) ) {

            //
            // Build the source path
            //
            Win32Err = DsRolepAllocAndCopyPath( Source,
                                                FindData.cFileName,
                                                &TempPath );

            if ( Win32Err == ERROR_SUCCESS ) {

                RtlFreeHeap( RtlProcessHeap(), 0, SourcePath );
                SourcePath = TempPath;

            } else {

                goto TreeCopyError;
            }

            //
            // Build the destination path
            //
            Win32Err = DsRolepAllocAndCopyPath( Dest,
                                                FindData.cFileName,
                                                &TempPath );

            if ( Win32Err == ERROR_SUCCESS ) {

                RtlFreeHeap( RtlProcessHeap(), 0, DestPath );
                DestPath = TempPath;

            } else {

                goto TreeCopyError;
            }


            //
            // Now, either do the copy, or copy the directory
            //
            if ( FLAG_ON( FindData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY ) ) {

                if ( CreateDirectory( DestPath, NULL ) == FALSE ) {

                    Win32Err = GetLastError();
                    DsRolepLogPrint(( DEB_ERROR,
                                      "CreateDirectory on %ws failed with %lu\n",
                                      DestPath, Win32Err ));

                } else {

                    Win32Err = DsRolepTreeCopy( SourcePath, DestPath );
                }

            } else {

                if ( CopyFile( SourcePath, DestPath, FALSE ) == FALSE ) {

                    Win32Err = GetLastError();
                    DsRolepLogPrint(( DEB_ERROR,
                                      "CopyFile from %ws to %ws failed with %lu\n",
                                      SourcePath, DestPath, Win32Err ));

                }
            }
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            if ( FindNextFile( FindHandle, &FindData ) == FALSE ) {

                Win32Err = GetLastError();
            }

            if ( Win32Err != ERROR_SUCCESS && Win32Err != ERROR_NO_MORE_FILES ) {

                DsRolepLogPrint(( DEB_ERROR,
                                  "FindNextFile after on %ws failed with %lu\n",
                                  FindData.cFileName, Win32Err ));
            }
        }
    }

TreeCopyError:

    //
    // Close the handle
    //
    if ( FindHandle != INVALID_HANDLE_VALUE ) {

        FindClose( FindHandle );
    }

    if ( Win32Err == ERROR_NO_MORE_FILES ) {

        Win32Err = ERROR_SUCCESS;

    }

    //
    // Cleanup
    //
    if ( SourcePath ) {

        RtlFreeHeap( RtlProcessHeap(), 0, SourcePath );
    }

    if ( DestPath ) {

        RtlFreeHeap( RtlProcessHeap(), 0, DestPath );
    }

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\trustdom.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    trustdom.h

Abstract:

    Routines to manage trusts during promotion/demotion

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __TRUSTDOM_H__
#define __TRUSTDOM_H__

DWORD
DsRolepCreateTrustedDomainObjects(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN LPWSTR DnsDomainName,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo,
    IN ULONG Options
    );

NTSTATUS
DsRolepCreateParentTrustObject(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ParentLsa,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDnsInfo,
    IN ULONG Options,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx,
    OUT PLSA_HANDLE TrustedDomainHandle
    );

DWORD
DsRolepDeleteParentTrustObject(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDomainInfo
    );

NTSTATUS
DsRolepCreateChildTrustObject(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ParentLsa,
    IN LSA_HANDLE ChildLsa,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsInfo,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDnsInfo,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx,
    IN ULONG Options
    );

DWORD
DsRolepRemoveTrustedDomainObjects(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo,
    IN ULONG Options
    );


#endif // __TRUSTDOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\upgrade.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetp.ch

Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __UPGRADE_H__
#define __UPGRADE_H__

DWORD
DsRolepSaveUpgradeState(
    IN LPWSTR AnswerFile
    );

DWORD
DsRolepDeleteUpgradeInfo(
    VOID
    );

DWORD
DsRolepQueryUpgradeInfo(
    OUT PBOOLEAN IsUpgrade,
    OUT PULONG ServerRole
    );

DWORD
DsRolepSetLogonDomain(
    IN LPWSTR Domain,
    IN BOOLEAN FailureAllowed
    );

DWORD
DsRolepGetBuiltinAdminAccountName(
    OUT LPWSTR *BuiltinAdmin
    );

DWORD
DsRolepSetBuiltinAdminAccountPassword(
    IN LPWSTR Password
    );

#endif // __UPGRADE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\dsrole\server\upgrade.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    upgrade.c

Abstract:

    Implements the server side of the routines to upgrade NT4 (downlevel) servers

Author:

    Mac McLain          (MacM)       24 January, 1998

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <loadfn.h>
#include <ntlsa.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>

#define DSROLEP_UPGRADE_KEY         L"Security\\"
#define DSROLEP_UPGRADE_VALUE       L"Upgrade"
#define DSROLEP_UPGRADE_WINLOGON    \
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\"
#define DSROLEP_UPGRADE_SAVE_PREFIX L"DcpromoOld_"
#define DSROLEP_UPGRADE_AUTOADMIN   L"AutoAdminLogon"
#define DSROLEP_UPGRADE_AUTOPASSWD  L"DefaultPassword"
#define DSROLEP_UPGRADE_DEFDOMAIN   L"DefaultDomainName"
#define DSROLEP_UPGRADE_DEFUSER     L"DefaultUserName"
#define DSROLEP_UPGRADE_AUTOUSERINIT    L"Userinit"
#define DSROLEP_UPGRADE_DCPROMO     L",dcpromo /upgrade"
#define DSROLEP_UPGRADE_ANSWERFILE  L"/answer:"

DWORD
DsRolepSetLogonDomain(
    IN LPWSTR Domain,
    IN BOOLEAN FailureAllowed
    )
/*++

Routine Description:

    This function sets the default logon domain for winlogon

Arguments:

    Domain -- Default logon domain

    FailureAllowed -- If true, a failure is not considered catastrophic

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    HKEY  WinlogonHandle = NULL;

    //
    // Open the key
    //
    Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             DSROLEP_UPGRADE_WINLOGON,
                             0,
                             KEY_READ | KEY_WRITE,
                             &WinlogonHandle );

    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Default logon domain
        //
        Win32Err = RegSetValueEx( WinlogonHandle,
                                  DSROLEP_UPGRADE_DEFDOMAIN,
                                  0,
                                  REG_SZ,
                                  ( CONST PBYTE )Domain,
                                  ( wcslen( Domain ) + 1 ) * sizeof( WCHAR ) );

        RegCloseKey( WinlogonHandle );
    }

    if ( Win32Err != ERROR_SUCCESS && FailureAllowed ) {

        //
        // Raise an event
        //
        SpmpReportEvent( TRUE,
                         EVENTLOG_WARNING_TYPE,
                         DSROLERES_FAIL_LOGON_DOMAIN,
                         0,
                         sizeof( ULONG ),
                         &Win32Err,
                         1,
                         Domain );

        DSROLEP_SET_NON_FATAL_ERROR( Win32Err );
        Win32Err = ERROR_SUCCESS;
    }

    return( Win32Err );
}

DWORD
DsRolepClearLsaSecretAutoLogonPassword()
/*++

Routine Description:

    This function is to be invoked during setup and deletes the
    auto logon password that was save in a lsa secret.
    
Arguments:

    
Return Values:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    LSAPR_OBJECT_ATTRIBUTES ObjectAttributes;
    LSAPR_HANDLE LsaPolicyHandle = NULL;

    LSAPR_UNICODE_STRING  lusSecretName, lusSecretNameOld;
    PLSAPR_CR_CIPHER_VALUE plusSecretData = NULL;
    USHORT SecretNameLength, SecretNameOldLength;

    NTSTATUS status   = STATUS_SUCCESS;
    DWORD    Win32Err = ERROR_SUCCESS;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    // Get a handle to the Policy object.
    status = LsarOpenPolicy(NULL,    //local machine
                            &ObjectAttributes, 
                            POLICY_CREATE_SECRET |
                            POLICY_READ,
                            &LsaPolicyHandle);
    if (!NT_SUCCESS(status)) {

        Win32Err = LsaNtStatusToWinError(status);
        goto Cleanup;

    }

    //Initialize an LSA_UNICODE_STRING 
    SecretNameLength = (USHORT)wcslen(DSROLEP_UPGRADE_AUTOPASSWD);
    lusSecretName.Buffer = DSROLEP_UPGRADE_AUTOPASSWD;
    lusSecretName.Length = SecretNameLength * sizeof(WCHAR);
    lusSecretName.MaximumLength = (SecretNameLength+1) * sizeof(WCHAR);

    //Initialize an LSA_UNICODE_STRING 
    SecretNameOldLength = (USHORT)wcslen(DSROLEP_UPGRADE_SAVE_PREFIX
                                            DSROLEP_UPGRADE_AUTOPASSWD);
    lusSecretNameOld.Buffer = DSROLEP_UPGRADE_SAVE_PREFIX
                                    DSROLEP_UPGRADE_AUTOPASSWD;
    lusSecretNameOld.Length = SecretNameOldLength * sizeof(WCHAR);
    lusSecretNameOld.MaximumLength = (SecretNameOldLength+1) * sizeof(WCHAR);

    //erase the autologon password
    status = LsarStorePrivateData(LsaPolicyHandle,
                                  &lusSecretName,
                                  NULL);
    if (!NT_SUCCESS(status)) {

        Win32Err = LsaNtStatusToWinError(status);
        goto Cleanup;

    }

    //get the value of any secret that may currently be stored there
    //and save it off to a different location
    status = LsarRetrievePrivateData(LsaPolicyHandle, 
                                     &lusSecretNameOld, 
                                     &plusSecretData);

    if ( status != STATUS_OBJECT_NAME_NOT_FOUND ) {

        if ( !NT_SUCCESS(status) ) {
    
            Win32Err = LsaNtStatusToWinError(status);
            goto Cleanup;
            
        } else {

            //store the value else where
            status = LsarStorePrivateData(LsaPolicyHandle,
                                          &lusSecretName,
                                          plusSecretData);
            RtlSecureZeroMemory(plusSecretData->Buffer,plusSecretData->Length);
            if (!NT_SUCCESS(status)) {
        
                Win32Err = LsaNtStatusToWinError(status);
                goto Cleanup;
        
            }

            //erase the value
            status = LsarStorePrivateData(LsaPolicyHandle,
                                          &lusSecretNameOld,
                                          NULL);
            if (!NT_SUCCESS(status)) {
        
                Win32Err = LsaNtStatusToWinError(status);
                goto Cleanup;
        
            }

        }

    }

Cleanup:

    if( NULL != LsaPolicyHandle )
    {

        LsaClose(LsaPolicyHandle);

    }

    if ( plusSecretData ) {

        LsaFreeMemory(plusSecretData);

    }

    return Win32Err;



}

DWORD
DsRolepSaveUpgradePasswordForAutoLogonAsLsaSecret(
    IN LPWSTR NewAdminPassword)
/*++

Routine Description:

    This function is to be invoked during setup and saves the admin password for
    autologon as a lsa secret.

Arguments:

    NewAdminPassword -- Password to save as a LSASECRET

Return Values:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/

{
    LSAPR_OBJECT_ATTRIBUTES ObjectAttributes;
    LSAPR_HANDLE LsaPolicyHandle;

    LSAPR_UNICODE_STRING  lusSecretName, lusSecretNameOld;
    PLSAPR_CR_CIPHER_VALUE plusSecretData = NULL;
    PLSAPR_CR_CIPHER_VALUE plusSecretDataNew = NULL;
    USHORT SecretNameLength, SecretNameOldLength, SecretDataLength;
    
    NTSTATUS status   = STATUS_SUCCESS;
    DWORD    Win32Err = ERROR_SUCCESS;

    LSAP_CR_CIPHER_KEY *SessionKey = NULL;

    LSAP_CR_CLEAR_VALUE lusSecretDataClear;

    // Object attributes are reserved, so initialize to zeroes.
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    // Get a handle to the Policy object.
    status = LsarOpenPolicy(NULL,    //local machine
                            &ObjectAttributes, 
                            POLICY_CREATE_SECRET |
                            POLICY_READ,
                            &LsaPolicyHandle);
    if (!NT_SUCCESS(status)) {

        Win32Err = LsaNtStatusToWinError(status);
        goto Cleanup;

    }

   
    //Initialize an LSA_UNICODE_STRING 
    SecretNameLength = (USHORT)wcslen(DSROLEP_UPGRADE_AUTOPASSWD);
    lusSecretName.Buffer = DSROLEP_UPGRADE_AUTOPASSWD;
    lusSecretName.Length = SecretNameLength * sizeof(WCHAR);
    lusSecretName.MaximumLength = (SecretNameLength+1) * sizeof(WCHAR);

    //Initialize an LSA_UNICODE_STRING 
    SecretNameOldLength = (USHORT)wcslen(DSROLEP_UPGRADE_SAVE_PREFIX
                                            DSROLEP_UPGRADE_AUTOPASSWD);
    lusSecretNameOld.Buffer = DSROLEP_UPGRADE_SAVE_PREFIX
                                    DSROLEP_UPGRADE_AUTOPASSWD;
    lusSecretNameOld.Length = SecretNameOldLength * sizeof(WCHAR);
    lusSecretNameOld.MaximumLength = (SecretNameOldLength+1) * sizeof(WCHAR);

    //get the value of any secret that may currently be stored there
    //and save it off to a different location
    status = LsarRetrievePrivateData(LsaPolicyHandle, 
                                     &lusSecretName, 
                                     &plusSecretData);

    if ( status != STATUS_OBJECT_NAME_NOT_FOUND ) {

        if ( !NT_SUCCESS(status) ) {
    
            Win32Err = LsaNtStatusToWinError(status);
            goto Cleanup;
            
        } else {

            //store the value else where
            status = LsarStorePrivateData(LsaPolicyHandle,
                                          &lusSecretNameOld,
                                          plusSecretData);
            RtlSecureZeroMemory(plusSecretData->Buffer,plusSecretData->Length);
            if (!NT_SUCCESS(status)) {
        
                Win32Err = LsaNtStatusToWinError(status);
                goto Cleanup;
        
            }

            //erase the value
            status = LsarStorePrivateData(LsaPolicyHandle,
                                          &lusSecretName,
                                          NULL);
            if (!NT_SUCCESS(status)) {
        
                Win32Err = LsaNtStatusToWinError(status);
                goto Cleanup;
        
            }

        }

    } 

    //Save the admin password

    //Initialize the Password LSA_UNICODE_STRING 
    SecretDataLength = (USHORT)wcslen(NewAdminPassword);
    lusSecretDataClear.Buffer = (PUCHAR)NewAdminPassword;
    lusSecretDataClear.Length = SecretDataLength * sizeof(WCHAR);
    lusSecretDataClear.MaximumLength = (SecretDataLength+1) * sizeof(WCHAR);

    //
    // Obtain the Session Key to be used to two-way encrypt the
    // Current Value.
    //

    status = LsapCrServerGetSessionKey( LsaPolicyHandle, &SessionKey);
    if (!NT_SUCCESS(status)) {
        
        Win32Err = LsaNtStatusToWinError(status);
        goto Cleanup;

    }

    //
    // Encrypt the Current Value if specified and not too long.
    //


    status = LsapCrEncryptValue(
                 &lusSecretDataClear,
                 SessionKey,
                 (PLSAP_CR_CIPHER_VALUE*)&plusSecretDataNew
                 );

    if (!NT_SUCCESS(status)) {

        goto Cleanup;
    }

    status = LsarStorePrivateData(LsaPolicyHandle,
                                  &lusSecretName,
                                  plusSecretDataNew);
    RtlSecureZeroMemory(plusSecretDataNew->Buffer,plusSecretDataNew->Length);
    LsapCrFreeMemoryValue(plusSecretDataNew);
    if (!NT_SUCCESS(status)) {

        Win32Err = LsaNtStatusToWinError(status);
        goto Cleanup;

    }

Cleanup:

    if( NULL != LsaPolicyHandle )
    {

        LsaClose(LsaPolicyHandle);

    }

    if ( SessionKey ) {

        MIDL_user_free(SessionKey);

    }

    if ( plusSecretData ) {

        LsaFreeMemory(plusSecretData);

    }

    if (plusSecretDataNew) {

        LsapCrFreeMemoryValue(plusSecretDataNew);

    }

    return Win32Err;

}

#pragma warning(push)
#pragma warning(disable:4701)

DWORD
DsRolepSaveUpgradeState(
    IN LPWSTR AnswerFile
    )
/*++

Routine Description:

    This function is to be invoked during setup and saves the required server state to
    complete the promotion following the reboot.  Following the successful completion
    of this API call, the server will be demoted to a member server in the same domain.

Arguments:

    AnswerFile -- Optional path to an answer file to be used by DCPROMO during the subsequent
        invocation

Return Values:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    LSAPR_HANDLE PolicyHandle = NULL;
    POLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE  Handle = NULL;
    HKEY WinlogonHandle, UpgradeKey;
    ULONG Disp, Length;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    PBYTE UserInitBuffer, TempBuffer;
    DWORD Type;
    LPWSTR NewAdminPassword = NULL;
    
    WCHAR  Buffer[MAX_PATH];
    LPWSTR AdminName = Buffer;
    LPWSTR DefaultAdminName = L"Administrator";

    //
    // Get the localized Admin
    // 
    Length = sizeof(Buffer)/sizeof(Buffer[0]);

    Status = SamIGetDefaultAdministratorName( AdminName,
                                             &Length );

    if ( !NT_SUCCESS(Status) ) {

        DsRolepLogOnFailure( ERROR_GEN_FAILURE,
                            DsRolepLogPrint(( DEB_TRACE,
                                               "SamIGetDefaultAdministratorName failed with 0x%x\n",
                                               Status )) );

        AdminName = DefaultAdminName;
        Status = STATUS_SUCCESS;

    }

    DsRolepInitializeOperationHandle();

    //
    // Steps involved: Set new SAM hives
    //                 Save LSA state
    //                 Set auto admin logon

    //
    // Invoke the SAM save code.  It returns the new account domain sid
    //
    DSROLEP_CURRENT_OP0( DSROLEEVT_UPGRADE_SAM );
    Win32Err = NtdsPrepareForDsUpgrade( &AccountDomainInfo,
                                        &NewAdminPassword );
    DsRolepLogOnFailure( Win32Err,
                        DsRolepLogPrint(( DEB_TRACE,
                                           "NtdsPrepareForDsUpgrade failed with %lu\n",
                                           Win32Err )) );


    //
    // Set the new lsa account domain sid
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                POLICY_READ | POLICY_WRITE |
                                            POLICY_VIEW_LOCAL_INFORMATION | POLICY_TRUST_ADMIN,
                                &PolicyHandle );


        if ( NT_SUCCESS( Status ) ) {

            //
            // Set the new policy info
            //
            Status = LsaSetInformationPolicy( PolicyHandle,
                                              PolicyAccountDomainInformation,
                                              ( PVOID ) &AccountDomainInfo );

        }

        Win32Err = RtlNtStatusToDosError( Status );

        RtlFreeHeap( RtlProcessHeap(), 0, AccountDomainInfo.DomainSid );
        RtlFreeHeap( RtlProcessHeap(), 0, AccountDomainInfo.DomainName.Buffer );
    }

    //
    // Set the LSA registry keys that let the server know on the next reboot that this
    // is an upgrade
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Get the current server role
        //
        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyLsaServerRoleInformation,
                                            ( PVOID )&ServerRoleInfo );

        Win32Err = RtlNtStatusToDosError( Status );

        if ( Win32Err == ERROR_SUCCESS ) {

            //
            // Open the key
            //
            if ( Win32Err == ERROR_SUCCESS ) {

                Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                         DSROLEP_UPGRADE_KEY,
                                         0,
                                         KEY_READ | KEY_WRITE,
                                         &UpgradeKey );
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Set the server role
                //
                Win32Err = RegSetValueEx( UpgradeKey,
                                          DSROLEP_UPGRADE_VALUE,
                                          0,
                                          REG_DWORD,
                                          ( CONST PBYTE )&ServerRoleInfo->LsaServerRole,
                                          sizeof( DWORD ) );
                RegCloseKey( UpgradeKey );
            }


            LsaFreeMemory( ServerRoleInfo );

        }

    }

    //
    // Set the machine to do auto admin logon
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Get the computer name. That will be used for the default logon domain
        //
        Length = MAX_COMPUTERNAME_LENGTH + 1;

        if ( GetComputerName( ComputerName, &Length ) == FALSE ) {

            Win32Err = GetLastError();

        } else {

            //
            // Open the root key
            //
            Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                     DSROLEP_UPGRADE_WINLOGON,
                                     0,
                                     KEY_READ | KEY_WRITE,
                                     &WinlogonHandle );

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Auto logon
                //

                //
                // First, see if the value currently exists...
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_AUTOADMIN,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_AUTOADMIN,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_AUTOADMIN,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                        }

                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    Win32Err = ERROR_SUCCESS;
                }


                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = RegSetValueEx( WinlogonHandle,
                                              DSROLEP_UPGRADE_AUTOADMIN,
                                              0,
                                              REG_SZ,
                                              ( CONST PBYTE )L"1",
                                              2 *  sizeof ( WCHAR ) );
                }
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Set the account password
                //
                //
                // First, see if the value currently exists...
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_AUTOPASSWD,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_AUTOPASSWD,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_AUTOPASSWD,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                        }

                        RtlSecureZeroMemory( TempBuffer, Length );
                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    Win32Err = ERROR_SUCCESS;

                }

                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = DsRolepSaveUpgradePasswordForAutoLogonAsLsaSecret(NewAdminPassword);

                    RtlSecureZeroMemory(NewAdminPassword,
                                        NewAdminPassword ? wcslen(NewAdminPassword)*sizeof(WCHAR) : 0);

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Win32Err = RegDeleteValue( WinlogonHandle,
                                               DSROLEP_UPGRADE_AUTOPASSWD );

                    }
                    
                    //If there is no autologon password value then RegDeleteValue will return
                    // ERROR_FILE_NOT_FOUND.  We shouldn't fail due to this.
                    if ( Win32Err == ERROR_FILE_NOT_FOUND ) {
        
                        Win32Err = ERROR_SUCCESS;
    
                    }
                
                }
                
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Set the user name to be administrator
                //

                //
                // First, see if the value currently exists...
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_DEFUSER,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_DEFUSER,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_DEFUSER,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                        }

                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    Win32Err = ERROR_SUCCESS;
                }


                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = RegSetValueEx( WinlogonHandle,
                                              DSROLEP_UPGRADE_DEFUSER,
                                              0,
                                              REG_SZ,
                                              ( CONST PBYTE )AdminName,
                                              ( wcslen( AdminName ) + 1 ) * sizeof( WCHAR ) );
                }
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Set the logon domain to the machine
                //
                //
                // First, see if the value currently exists...
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_DEFDOMAIN,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_DEFDOMAIN,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_DEFDOMAIN,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                        }

                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    Win32Err = ERROR_SUCCESS;
                }


                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = RegSetValueEx( WinlogonHandle,
                                              DSROLEP_UPGRADE_DEFDOMAIN,
                                              0,
                                              REG_SZ,
                                              ( CONST PBYTE )ComputerName,
                                              ( wcslen( ComputerName ) + 1 ) * sizeof( WCHAR ) );
                }
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Finally, set dcpromo to autostart
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_AUTOUSERINIT,
                                            0, // reserved
                                            &Type,
                                            0,
                                            &Length );

                if ( Win32Err == ERROR_SUCCESS ) {

                    Length += sizeof( DSROLEP_UPGRADE_DCPROMO );

                    if ( AnswerFile ) {

                        Length += sizeof( DSROLEP_UPGRADE_ANSWERFILE ) +
                                   ( wcslen( AnswerFile ) * sizeof( WCHAR ) );
                    }

                    UserInitBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                                      Length );
                    if ( UserInitBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_AUTOUSERINIT,
                                                    0,
                                                    &Type,
                                                    UserInitBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {
                            wcscat( ( PWSTR )UserInitBuffer, DSROLEP_UPGRADE_DCPROMO );

                            if ( AnswerFile ) {

                                wcscat( ( PWSTR )UserInitBuffer, DSROLEP_UPGRADE_ANSWERFILE );
                                wcscat( ( PWSTR )UserInitBuffer, AnswerFile );
                            }

                            Status = RegSetValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_AUTOUSERINIT,
                                                    0,
                                                    Type,
                                                    UserInitBuffer,
                                                    ( wcslen( ( PWSTR )UserInitBuffer ) + 1 ) *
                                                                    sizeof( WCHAR ) );
                        }

                    }


                    RtlFreeHeap( RtlProcessHeap(), 0, UserInitBuffer );
                }


                RegCloseKey( WinlogonHandle );

            }

        }
    }

    if ( PolicyHandle ) {

        LsaClose( PolicyHandle );
    }

    //
    // Set the product types
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepSetProductType( DSROLEP_MT_STANDALONE );

    }

    if ( NewAdminPassword ) {

        RtlSecureZeroMemory(NewAdminPassword, (wcslen(NewAdminPassword)+1)*sizeof(WCHAR) );
        RtlFreeHeap( RtlProcessHeap(), 0, NewAdminPassword );

    }

    return( Win32Err );
}

#pragma warning(pop)


DWORD
DsRolepDeleteUpgradeInfo(
    VOID
    )
/*++

Routine Description:

    This function deletes the saved information

Arguments:

    VOID


Return Values:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, RestoreError = Win32Err;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HKEY WinlogonHandle, UpgradeKey;
    PWSTR Remove, Next, DeletePath;
    PBYTE UserInitBuffer, TempBuffer;
    DWORD Type, Length = 0;

    //
    // Remove autostarting dcpromo
    //

    //
    // Open the root key
    //
    Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             DSROLEP_UPGRADE_WINLOGON,
                             0,
                             KEY_READ | KEY_WRITE,
                             &WinlogonHandle );

#if DBG
    DsRolepLogOnFailure( Win32Err,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "RegOpenKeyEx on %ws failed with %lu\n",
                                           DSROLEP_UPGRADE_WINLOGON,
                                           Win32Err )) );
#endif

    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Stop dcpromo from autostarting...
        //
        Win32Err = RegQueryValueEx( WinlogonHandle,
                                    DSROLEP_UPGRADE_AUTOUSERINIT,
                                    0, // reserved
                                    &Type,
                                    0,
                                    &Length );

#if DBG
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "RegQueryValyueEx on %ws failed with %lu\n",
                                               DSROLEP_UPGRADE_AUTOUSERINIT,
                                               Win32Err )) );
#endif
        if ( Win32Err == ERROR_SUCCESS ) {


            UserInitBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                              Length );
            if ( UserInitBuffer == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_AUTOUSERINIT,
                                            0,
                                            &Type,
                                            UserInitBuffer,
                                            &Length );

#if DBG
                DsRolepLogOnFailure( Win32Err,
                                     DsRolepLogPrint(( DEB_TRACE,
                                                       "RegQueryValyueEx on %ws failed with %lu\n",
                                                       DSROLEP_UPGRADE_AUTOUSERINIT,
                                                       Win32Err )) );
#endif
                if ( Win32Err == ERROR_SUCCESS ) {

                    Remove = wcsstr ( ( PWSTR )UserInitBuffer, DSROLEP_UPGRADE_DCPROMO );

                    if ( Remove ) {

                        Next = Remove + ( ( sizeof( DSROLEP_UPGRADE_DCPROMO ) - sizeof( WCHAR ) ) /
                                                                                sizeof( WCHAR ) );
                        while ( *Next ) {

                            *Remove++ = *Next++;
                        }
                        *Remove = UNICODE_NULL;

                        Status = RegSetValueEx( WinlogonHandle,
                                                DSROLEP_UPGRADE_AUTOUSERINIT,
                                                0,
                                                Type,
                                                UserInitBuffer,
                                                ( wcslen( ( PWSTR )UserInitBuffer ) + 1 ) *
                                                                sizeof( WCHAR ) );
#if DBG
                        DsRolepLogOnFailure( Win32Err,
                                             DsRolepLogPrint(( DEB_TRACE,
                                                               "RegQSetValyueEx on %ws failed with %lu\n",
                                                                DSROLEP_UPGRADE_AUTOUSERINIT,
                                                                Win32Err )) );
#endif
                    }
                }

            }


            RtlFreeHeap( RtlProcessHeap(), 0, UserInitBuffer );
        }


        if ( Win32Err == ERROR_SUCCESS ) {

            //
            // Auto logon
            //

            //
            // Restore the old values, if they exist
            //
            DeletePath = DSROLEP_UPGRADE_AUTOADMIN;
            Length = 0;
            Win32Err = RegQueryValueEx( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_AUTOADMIN,
                                        0,
                                        &Type,
                                        0,
                                        &Length );
            if ( Win32Err == ERROR_SUCCESS ) {

                TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                if ( TempBuffer == NULL ) {

                    Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                } else {

                    Win32Err = RegQueryValueEx( WinlogonHandle,
                                                DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_AUTOADMIN,
                                                0,
                                                &Type,
                                                TempBuffer,
                                                &Length );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Win32Err = RegSetValueEx( WinlogonHandle,
                                                  DSROLEP_UPGRADE_AUTOADMIN,
                                                  0,
                                                  Type,
                                                  TempBuffer,
                                                  Length );
                        RegDeleteValue( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_AUTOADMIN );
                    }

                    RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                }


            } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                Win32Err = RegDeleteValue( WinlogonHandle, DeletePath );
                DsRolepLogOnFailure( Win32Err,
                                     DsRolepLogPrint(( DEB_TRACE,
                                                       "RegDeleteKey on %ws failed with %lu\n",
                                                       DeletePath,
                                                       Win32Err )) );
                //
                // An error here is not considered fatal...
                //
                Win32Err = ERROR_SUCCESS;
            }

            //
            // Restore the default user logon name
            //
            DeletePath = DSROLEP_UPGRADE_DEFUSER;
            Length = 0;
            Win32Err = RegQueryValueEx( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_DEFUSER,
                                        0,
                                        &Type,
                                        0,
                                        &Length );
            if ( Win32Err == ERROR_SUCCESS ) {

                TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                if ( TempBuffer == NULL ) {

                    Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                } else {

                    Win32Err = RegQueryValueEx( WinlogonHandle,
                                                DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_DEFUSER,
                                                0,
                                                &Type,
                                                TempBuffer,
                                                &Length );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Win32Err = RegSetValueEx( WinlogonHandle,
                                                  DSROLEP_UPGRADE_DEFUSER,
                                                  0,
                                                  Type,
                                                  TempBuffer,
                                                  Length );
                        RegDeleteValue( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_DEFUSER );
                    }

                    RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                }


            } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                Win32Err = RegDeleteValue( WinlogonHandle, DeletePath );
                DsRolepLogOnFailure( Win32Err,
                                     DsRolepLogPrint(( DEB_TRACE,
                                                       "RegDeleteKey on %ws failed with %lu\n",
                                                       DeletePath,
                                                       Win32Err )) );
                //
                // An error here is not considered fatal...
                //
                Win32Err = ERROR_SUCCESS;
            }

            //
            // Restore the default domain name
            //
            DeletePath = DSROLEP_UPGRADE_DEFDOMAIN;
            Length = 0;
            Win32Err = RegQueryValueEx( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_DEFDOMAIN,
                                        0,
                                        &Type,
                                        0,
                                        &Length );
            if ( Win32Err == ERROR_SUCCESS ) {

                TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                if ( TempBuffer == NULL ) {

                    Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                } else {

                    Win32Err = RegQueryValueEx( WinlogonHandle,
                                                DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_DEFDOMAIN,
                                                0,
                                                &Type,
                                                TempBuffer,
                                                &Length );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Win32Err = RegSetValueEx( WinlogonHandle,
                                                  DSROLEP_UPGRADE_DEFDOMAIN,
                                                  0,
                                                  Type,
                                                  TempBuffer,
                                                  Length );
                        RegDeleteValue( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_DEFDOMAIN );
                    }

                    RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                }


            } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                Win32Err = RegDeleteValue( WinlogonHandle, DeletePath );
                DsRolepLogOnFailure( Win32Err,
                                     DsRolepLogPrint(( DEB_TRACE,
                                                       "RegDeleteKey on %ws failed with %lu\n",
                                                       DeletePath,
                                                       Win32Err )) );
                //
                // An error here is not considered fatal...
                //
                Win32Err = ERROR_SUCCESS;
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Delete the account password
                //
                Win32Err = DsRolepClearLsaSecretAutoLogonPassword();

                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_SAVE_PREFIX
                                                                       DSROLEP_UPGRADE_AUTOPASSWD,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_SAVE_PREFIX
                                                                       DSROLEP_UPGRADE_AUTOPASSWD,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_AUTOPASSWD,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                            RegDeleteValue( WinlogonHandle,
                                            DSROLEP_UPGRADE_SAVE_PREFIX
                                                                     DSROLEP_UPGRADE_AUTOPASSWD );
                        }

                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    DeletePath = DSROLEP_UPGRADE_AUTOPASSWD;
                    Win32Err = RegDeleteValue( WinlogonHandle, DeletePath );
                    DsRolepLogOnFailure( Win32Err,
                                         DsRolepLogPrint(( DEB_TRACE,
                                                           "RegDeleteKey on %ws failed with %lu\n",
                                                           DeletePath,
                                                           Win32Err )) );
                    //
                    // An error here is not considered fatal...
                    //
                    Win32Err = ERROR_SUCCESS;
                }
            }

            if ( Win32Err != ERROR_SUCCESS ) {

                //
                // Raise an event
                //
                SpmpReportEvent( TRUE,
                                 EVENTLOG_WARNING_TYPE,
                                 DSROLERES_FAIL_DISABLE_AUTO_LOGON,
                                 0,
                                 sizeof( ULONG ),
                                 &Win32Err,
                                 1,
                                 DeletePath );

                DSROLEP_SET_NON_FATAL_ERROR( Win32Err );
                Win32Err = ERROR_SUCCESS;

            }
        }


        RegCloseKey( WinlogonHandle );

    }

    //
    // Delete the registry key that LSA uses to determine if this is an upgrade
    //


    //
    // Open the key
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 DSROLEP_UPGRADE_KEY,
                                 0,
                                 DELETE | KEY_SET_VALUE,
                                 &UpgradeKey );

#if DBG
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "RegOpenKey on %ws failed with %lu\n",
                                               DSROLEP_UPGRADE_KEY,
                                               Win32Err )) );
#endif
        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = RegDeleteValue( UpgradeKey, DSROLEP_UPGRADE_VALUE );

            if ( ERROR_FILE_NOT_FOUND == Win32Err ) {

                // This is ok.
                Win32Err = ERROR_SUCCESS;
                
            }
#if DBG
            DsRolepLogOnFailure( Win32Err,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "RegDeleteKey on %ws failed with %lu\n",
                                                   DSROLEP_UPGRADE_KEY,
                                                   Win32Err )) );
#endif
            RegCloseKey( UpgradeKey );
        }
    }

    //
    // Finally remove the nt4 LSA information
    //

    //
    // Remove the nt4 LSA stuff that has been put into the registry
    //
    LsapDsUnitializeDsStateInfo();

    Status = LsaIUpgradeRegistryToDs( TRUE );

    RestoreError = RtlNtStatusToDosError( Status );

    DsRolepLogOnFailure( RestoreError,
                         DsRolepLogPrint(( DEB_WARN,
                                           "Failed to cleanup NT4 LSA (%d)\n",
                                           RestoreError )) );

    if ( ERROR_SUCCESS != RestoreError
      && ERROR_SUCCESS == Win32Err ) {

        Win32Err = RestoreError;
        
    }

    return( Win32Err );
}



DWORD
DsRolepQueryUpgradeInfo(
    OUT PBOOLEAN IsUpgrade,
    OUT PULONG ServerRole
    )
/*++

Routine Description:

    This function queries the current update information.

Arguments:

    IsUpgrade - A pointer to a BOOLEAN to hold a value of TRUE if there is upgrade information
                saved away, or a FALSE if not

    ServerRole - If this is an upgrade, the previous server role is returned here.


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    HKEY UpgradeKey;
    ULONG Type, Length = sizeof( ULONG );

    //
    // Open the upgrade key
    //
    Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             DSROLEP_UPGRADE_KEY,
                             0,
                             KEY_READ | KEY_WRITE,
                             &UpgradeKey );

    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Finally, set dcpromo to autostart
        //
        Win32Err = RegQueryValueEx( UpgradeKey,
                                    DSROLEP_UPGRADE_VALUE,
                                    0, // reserved
                                    &Type,
                                    ( PBYTE )ServerRole,
                                    &Length );
        if ( Win32Err == ERROR_SUCCESS ) {

            *IsUpgrade = TRUE;

        }

        RegCloseKey( UpgradeKey );

    }

    if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

        Win32Err = ERROR_SUCCESS;
        *IsUpgrade = FALSE;
    }

    return( Win32Err );
}


DWORD
DsRolepGetBuiltinAdminAccountName(
    OUT LPWSTR *BuiltinAdmin
    )
/*++

Routine Description:

    This routine finds the alias name for the builtin user account ADMINISTRATOR

Arguments:

    BuiltinAdmin - Where the admin name is returned

Return Values:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY UaspNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD SidBuff[ sizeof( SID ) / sizeof( DWORD ) + 5];
    PSID Sid = ( PSID )SidBuff;
    SID_NAME_USE SNE;
    LPWSTR Domain = NULL;
    LPWSTR Name = NULL;
    ULONG NameLen = 0, DomainLen = 0;


    //
    // Build the sid
    //
    RtlInitializeSid( Sid, &UaspNtAuthority, 2 );
    *( RtlSubAuthoritySid( Sid, 0 ) ) = SECURITY_BUILTIN_DOMAIN_RID;
    *( RtlSubAuthoritySid( Sid, 1 ) ) = DOMAIN_USER_RID_ADMIN;

    if ( LookupAccountSid( NULL,
                           Sid,
                           NULL,
                           &NameLen,
                           NULL,
                           &DomainLen,
                           &SNE ) == FALSE ) {

        Win32Err = GetLastError();

        if ( Win32Err == ERROR_INSUFFICIENT_BUFFER ) {

            Win32Err = ERROR_SUCCESS;

            Name = RtlAllocateHeap( RtlProcessHeap(), 0, NameLen * sizeof( WCHAR ) );

            Domain = RtlAllocateHeap( RtlProcessHeap(), 0, DomainLen * sizeof( WCHAR ) );

            if ( !Name || !Domain ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                if ( LookupAccountSid( NULL,
                                       Sid,
                                       Name,
                                       &NameLen,
                                       Domain,
                                       &DomainLen,
                                       &SNE ) == FALSE ) {

                    Win32Err = GetLastError();
                }

            }
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        RtlFreeHeap( RtlProcessHeap(), 0, Domain );
        RtlFreeHeap( RtlProcessHeap(), 0, Name );
    }

    return( Win32Err );
}


DWORD
DsRolepSetBuiltinAdminAccountPassword(
    IN LPWSTR Password
    )
/*++

Routine Description:

    This routine will change the password on the builtin administrator account to the one
    specified

Arguments:

    Password - Password to set

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAM_HANDLE SamHandle, SamDomainHandle, SamAdministrator;
    PPOLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo;
    LSA_HANDLE PolicyHandle;
    USER_ALL_INFORMATION UserAllInfo;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UserPassword;


    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );


    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            ( PVOID * )&AccountDomainInfo );

        LsaClose( PolicyHandle );
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = SamConnect( NULL,
                             &SamHandle,
                             MAXIMUM_ALLOWED,
                             &ObjectAttributes );

        if ( NT_SUCCESS( Status ) ) {

            //
            // Open the builtin domain
            //
            Status = SamOpenDomain( SamHandle,
                                    MAXIMUM_ALLOWED,
                                    AccountDomainInfo->DomainSid,
                                    &SamDomainHandle );

            if ( NT_SUCCESS( Status ) ) {

                Status = SamOpenUser( SamDomainHandle,
                                      MAXIMUM_ALLOWED,
                                      DOMAIN_USER_RID_ADMIN,
                                      &SamAdministrator );

                if ( NT_SUCCESS( Status ) ) {

                    RtlZeroMemory( &UserAllInfo, sizeof( USER_ALL_INFORMATION ) );

                    RtlInitUnicodeString( &UserPassword, Password );

                    UserAllInfo.NtPassword = UserPassword;
                    UserAllInfo.NtPasswordPresent = TRUE;
                    UserAllInfo.WhichFields = USER_ALL_NTPASSWORDPRESENT;

                    Status = SamSetInformationUser( SamAdministrator,
                                                    UserAllInformation,
                                                    ( PSAMPR_USER_INFO_BUFFER )&UserAllInfo );

                    SamCloseHandle( SamAdministrator );

                }

                SamCloseHandle( SamDomainHandle );
            }

            SamCloseHandle( SamHandle );
        }

        LsaFreeMemory( AccountDomainInfo );
    }


    return( RtlNtStatusToDosError( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\delprof\delprof.h ===
//*************************************************************
//  File name: delprof.h
//
//  Description:  header file for delprof.c
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************


//
// Strings
//

#define IDS_USAGE1              1
#define IDS_USAGE2              2
#define IDS_USAGE3              3
#define IDS_USAGE4              4
#define IDS_USAGE5              5
#define IDS_USAGE6              6
#define IDS_USAGE7              7
#define IDS_USAGE8              8
#define IDS_USAGE9              9
#define IDS_CONFIRM            10
#define IDS_CONFIRMDAYS        11
#define IDS_NO                 12
#define IDS_FAILEDPROFILELIST  13
#define IDS_FAILEDENUM         14
#define IDS_FAILEDPATHQUERY    15
#define IDS_FAILEDOPENPROFILE  16
#define IDS_SKIPPROFILE        17
#define IDS_DELETEPROMPT       18
#define IDS_DELETING           19
#define IDS_SUCCESS            20
#define IDS_FAILED             21


typedef struct _DELETEITEM {
    LPTSTR lpSubKey;
    LPTSTR lpProfilePath;
    BOOL   bDir;
    struct _DELETEITEM * pNext;
} DELETEITEM, *LPDELETEITEM;


//
// Date conversion functions
//

void APIENTRY gdate_daytodmy(LONG days, int FAR* yrp, int FAR* monthp, int FAR* dayp);
LONG APIENTRY gdate_dmytoday(int yr, int month, int day);
int APIENTRY gdate_monthdays(int month, int year);
int APIENTRY gdate_weekday(long daynr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\delprof\delprof.c ===
//*************************************************************
//  File name: delprof.c
//
//  Description:  Utility to delete user profiles
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <locale.h>
#include <strsafe.h>
#include "delprof.h"
#include "userenv.h"

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define VALID_COMPUTER_NAME_LENGTH  MAX_COMPUTERNAME_LENGTH + 3  // including \\ with Null terminator

    
//
// Globals
//

BOOL bQuiet;
BOOL bIgnoreErrors;
BOOL bPromptBeforeDelete;
BOOL bLocalComputer = FALSE;
TCHAR szComputerName[MAX_PATH];
TCHAR szSystemRoot[2*MAX_PATH];
TCHAR szSystemDrive[2*MAX_PATH];
LONG lDays;
HINSTANCE hInst;
LPDELETEITEM lpDeleteList;
LONG lCurrentDateInDays;


//*************************************************************
//
//  Usage()
//
//  Purpose:    prints the usage info
//
//  Parameters: void
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

void Usage (void)
{
    TCHAR szTemp[200];

    LoadString (hInst, IDS_USAGE1, szTemp, ARRAYSIZE(szTemp));
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE2, szTemp, ARRAYSIZE(szTemp));
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE3, szTemp, ARRAYSIZE(szTemp));
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE4, szTemp, ARRAYSIZE(szTemp));
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE5, szTemp, ARRAYSIZE(szTemp));
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE6, szTemp, ARRAYSIZE(szTemp));
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE7, szTemp, ARRAYSIZE(szTemp));
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE8, szTemp, ARRAYSIZE(szTemp));
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE9, szTemp, ARRAYSIZE(szTemp));
    _tprintf(szTemp);
}


//*************************************************************
//
//  InitializeGlobals()
//
//  Purpose:    Initializes the global variables
//
//  Parameters: void
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

void InitializeGlobals (void)
{
    OSVERSIONINFO ver;
    SYSTEMTIME systime;


    //
    // Initialize global variables
    //

    bQuiet = FALSE;
    bIgnoreErrors = FALSE;
    bPromptBeforeDelete = FALSE;
    szComputerName[0] = TEXT('\0');
    lDays = 0;
    lpDeleteList = NULL;

    setlocale(LC_ALL,"");

    hInst = GetModuleHandle(TEXT("delprof.exe"));

    GetLocalTime (&systime);

    lCurrentDateInDays = gdate_dmytoday(systime.wYear, systime.wMonth, systime.wDay);
}


//*************************************************************
//
//  CheckGlobals()
//
//  Purpose:    Checks the global variables
//
//  Parameters: void
//
//  Return:     DWORD - ERROR_SUCCESS for success
//                      win32 error code for failure
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

DWORD CheckGlobals (void)
{
    DWORD dwSize;
    HRESULT hr;
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR szTemp[MAX_PATH];

    //
    // If szComputerName is still NULL, fill in the computer name
    // we're running on.
    //

    if (szComputerName[0] == TEXT('\0')) {

       szComputerName[0] = TEXT('\\');
       szComputerName[1] = TEXT('\\');

       dwSize = ARRAYSIZE(szComputerName) - 2;
       if (!GetComputerName(szComputerName + 2, &dwSize)) {
           return GetLastError();
       }

       bLocalComputer = TRUE;

    } else {

       //
       // Make sure that the computer name starts with \\
       //

       if (szComputerName[0] != TEXT('\\')) {
           szTemp[0] = TEXT('\\');
           szTemp[1] = TEXT('\\');

           hr = StringCchCopy(szTemp + 2, ARRAYSIZE(szTemp) - 2, szComputerName);
           if (FAILED(hr))
               return HRESULT_CODE(hr);
           
           hr = StringCchCopy(szComputerName, ARRAYSIZE(szComputerName), szTemp);
           if (FAILED(hr))
               return HRESULT_CODE(hr);
       }
    }


    //
    // If the user has requested to run in Quiet mode,
    // then we turn off the prompt on every delete option.
    //

    if (bQuiet) {
        bPromptBeforeDelete = FALSE;
    }

    return ERROR_SUCCESS;

}


//*************************************************************
//
//  ParseCommandLine()
//
//  Purpose:    Parses the command line
//
//  Parameters: lpCommandLine   -   Command line
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL ParseCommandLine (LPTSTR lpCommandLine)
{
    LPTSTR lpTemp;
    DWORD  cchTemp;
    TCHAR  szDays[32];


    //
    // Check for NULL command line
    //

    if (!lpCommandLine || !*lpCommandLine)
        return TRUE;


    //
    // Find the executable name
    //

    while (*lpCommandLine && (_tcsncmp(lpCommandLine, TEXT("delprof"), 7) != 0)) {
        lpCommandLine++;
    }

    if (!*lpCommandLine) {
        return TRUE;
    }


    //
    // Find the first argument
    //

    while (*lpCommandLine && ((*lpCommandLine != TEXT(' ')) &&
                              (*lpCommandLine != TEXT('/')) &&
                              (*lpCommandLine != TEXT('-')))) {
        lpCommandLine++;
    }


    //
    // Skip white space
    //

    while (*lpCommandLine && (*lpCommandLine == TEXT(' '))) {
        lpCommandLine++;
    }

    if (!*lpCommandLine) {
        return TRUE;
    }


    //
    // We should be at the first argument now.
    //

    if ((*lpCommandLine != TEXT('/')) &&  (*lpCommandLine != TEXT('-'))) {
        Usage();
        return FALSE;
    }


    while (1) {

        //
        // Increment the pointer and branch to the correct argument.
        //

        lpCommandLine++;

        switch (*lpCommandLine) {

            case TEXT('?'):
                Usage();
                ExitProcess(0);
                break;

            case TEXT('Q'):
            case TEXT('q'):
                bQuiet = TRUE;
                lpCommandLine++;
                break;

            case TEXT('I'):
            case TEXT('i'):
                bIgnoreErrors = TRUE;
                lpCommandLine++;
                break;

            case TEXT('P'):
            case TEXT('p'):
                bPromptBeforeDelete = TRUE;
                lpCommandLine++;
                break;

            case TEXT('C'):
            case TEXT('c'):

                //
                // Find the colon
                //

                lpCommandLine++;

                if (*lpCommandLine != TEXT(':')) {
                   Usage();
                   return FALSE;
                }


                //
                // Find the first character
                //

                lpCommandLine++;

                if (!*lpCommandLine) {
                   Usage();
                   return FALSE;
                }

                //
                // Copy the computer name
                //

                cchTemp = 0;
                lpTemp = szComputerName;
                while (*lpCommandLine && (cchTemp < ARRAYSIZE(szComputerName) - 1) &&
                       ((*lpCommandLine != TEXT(' ')) &&
                        (*lpCommandLine != TEXT('/')))){
                      *lpTemp++ = *lpCommandLine++;
                      cchTemp++;
                }

                if (cchTemp > VALID_COMPUTER_NAME_LENGTH) {
                    Usage();
                    return FALSE;
                }

                *lpTemp = TEXT('\0');

                break;

            case TEXT('D'):
            case TEXT('d'):

                //
                // Find the colon
                //
                
                lpCommandLine++;

                if (*lpCommandLine != TEXT(':')) {
                   Usage();
                   return FALSE;
                }


                //
                // Find the first character
                //

                lpCommandLine++;

                if (!*lpCommandLine) {
                   Usage();
                   return FALSE;
                }

                //
                // Copy the number of days (in characters)
                //

                lpTemp = szDays;
                cchTemp = 0;
                while (*lpCommandLine && (cchTemp < ARRAYSIZE(szDays) - 1) && 
                       ((*lpCommandLine != TEXT(' ')) &&
                        (*lpCommandLine != TEXT('/')) &&
                        (*lpCommandLine != TEXT('-')))) {
                      *lpTemp++ = *lpCommandLine++;
                      cchTemp++;
                }
                
                *lpTemp = TEXT('\0');


                //
                // Convert the days into a number
                //

                lDays = _ttol(szDays);
                break;

            default:
                Usage();
                return FALSE;
        }


        //
        // Skip white space
        //

        while (*lpCommandLine && (*lpCommandLine == TEXT(' '))) {
            lpCommandLine++;
        }


        if (!*lpCommandLine) {
            return TRUE;
        }


        //
        // We should be at the next argument now.
        //

        if ((*lpCommandLine != TEXT('/')) && (*lpCommandLine != TEXT('-'))) {
            Usage();
            return FALSE;
        }
    }

    return TRUE;
}


//*************************************************************
//
//  Confirm()
//
//  Purpose:    Confirm the user really wants to delete the profiles
//
//  Parameters: void
//
//  Return:     TRUE if we should continue
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL Confirm ()
{
    TCHAR szTemp[200];
    TCHAR tChar, tTemp;


    //
    // If we are prompting for every profile, then don't
    // give the general prompt.
    //

    if (bPromptBeforeDelete) {
        return TRUE;
    }


    //
    // If the user is requesting a specific day count,
    // give a more appropriate confirmation message.
    //

    if (lDays > 0) {
        LoadString (hInst, IDS_CONFIRMDAYS, szTemp, ARRAYSIZE(szTemp));
        _tprintf (szTemp, szComputerName, lDays);
    } else {
        LoadString (hInst, IDS_CONFIRM, szTemp, ARRAYSIZE(szTemp));
        _tprintf (szTemp, szComputerName);
    }

    tChar = _gettchar();

    tTemp = tChar;
    while (tTemp != TEXT('\n')) {
        tTemp = _gettchar();
    }


    if ((tChar == TEXT('Y')) || (tChar == TEXT('y'))) {
        return TRUE;
    }


    //
    // If the user didn't press Y/y, then we bail.
    //

    LoadString (hInst, IDS_NO, szTemp, ARRAYSIZE(szTemp));
    _tprintf (szTemp);

    return FALSE;
}


//*************************************************************
//
//  PrintLastError()
//
//  Purpose:    Displays the last error string to the user
//
//  Parameters: lError  -   error code
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

void PrintLastError(LONG lError)
{
   TCHAR szMessage[MAX_PATH];

   FormatMessage(
            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            lError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
            szMessage,
            ARRAYSIZE(szMessage),
            NULL);

   _tprintf (szMessage);
}


//*************************************************************
//
//  AddNode()
//
//  Purpose:    Adds a new node to the link list
//
//  Parameters: szSubKey        -   SubKey
//              szProfilePath   -   Profile Path (or NULL)
//              bDir            -   Directory or file
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   szProfilePath can be NULL.  In this case, we
//              are just removing the bogus registry entry.
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL AddNode (LPTSTR szSubKey, LPTSTR szProfilePath, BOOL bDir)
{
    LPDELETEITEM lpItem, lpTemp;
    UINT uAlloc = 0;
    DWORD cchSubKeyWithNull = 0, cchProfilePathWithNull = 0;
    HRESULT hr;


    //
    // Create a new node
    //

    cchSubKeyWithNull = lstrlen(szSubKey) + 1;
    uAlloc = sizeof(DELETEITEM) + cchSubKeyWithNull * sizeof(TCHAR);

    if (szProfilePath) {
        cchProfilePathWithNull = lstrlen(szProfilePath) + 1;
        uAlloc += cchProfilePathWithNull * sizeof(TCHAR);
    }

    lpItem = LocalAlloc (LPTR, uAlloc);

    if (!lpItem) {
        return FALSE;
    }

    lpItem->lpSubKey = (LPTSTR)((LPBYTE)lpItem + sizeof(DELETEITEM));
    hr = StringCchCopy(lpItem->lpSubKey, cchSubKeyWithNull, szSubKey);
    if (FAILED(hr)) {
        LocalFree(lpItem);
        return FALSE;
    }

    if (szProfilePath) {
        lpItem->lpProfilePath = lpItem->lpSubKey + lstrlen(szSubKey) + 1;
        hr = StringCchCopy(lpItem->lpProfilePath, cchProfilePathWithNull, szProfilePath);
        if (FAILED(hr)) {
            LocalFree(lpItem);
            return FALSE;
        }
    } else {
        lpItem->lpProfilePath = NULL;
    }

    lpItem->bDir = bDir;


    //
    // Add this node to the global lpItemList
    //

    if (lpDeleteList) {
        lpTemp = lpDeleteList;

        while (lpTemp->pNext) {
            lpTemp = lpTemp->pNext;
        }

        lpTemp->pNext = lpItem;
    } else {
        lpDeleteList = lpItem;
    }

    return TRUE;
}


//*************************************************************
//
//  GetProfileDateInDays()
//
//  Purpose:    Gets the profile date in days.
//
//  Parameters: szProfilePath   -   Profile path
//              bDir            -   Directory or file
//
//  Return:     age in days.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

LONG GetProfileDateInDays(LPTSTR szProfilePath, BOOL bDir)
{
    TCHAR szTemp[MAX_PATH];
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    LONG days;
    SYSTEMTIME systime;
    FILETIME ft;
    HRESULT  hr;


    if (bDir) {

        //
        // Tack on ntuser.* to find the registry hive.
        //

        hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), szProfilePath);
        if (FAILED(hr))
            return lCurrentDateInDays;
        
        hr = StringCchCat(szTemp, ARRAYSIZE(szTemp), TEXT("\\ntuser.*"));
        if (FAILED(hr))
            return lCurrentDateInDays;

        hFile = FindFirstFile (szTemp, &fd);

    } else {

        //
        // szProfilePath points to a file.
        //

        hFile = FindFirstFile (szProfilePath, &fd);
    }


    if (hFile != INVALID_HANDLE_VALUE) {

        FindClose (hFile);

        FileTimeToLocalFileTime (&fd.ftLastWriteTime, &ft);
        FileTimeToSystemTime (&ft, &systime);

        days = gdate_dmytoday(systime.wYear, systime.wMonth, systime.wDay);

    } else {
        days = lCurrentDateInDays;
    }

    return days;
}


//*************************************************************
//
//  CheckProfile()
//
//  Purpose:    Checks if the given profile should be deleted.
//              If so, it is added to the list.
//
//  Parameters: hKeyLM    -   Local Machine key
//              hKeyUsers - HKEY_USERS key
//              lpSid     -   Sid string (key name)
//
//  Return:     TRUE if successful
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL CheckProfile (HKEY hKeyLM, HKEY hKeyUsers, LPTSTR lpSid)
{
    LONG lResult;
    HKEY hkey = NULL;
    TCHAR szSubKey[MAX_PATH];
    DWORD dwSize, dwType;
    TCHAR szTemp[MAX_PATH];
    TCHAR szProfilePath[MAX_PATH];
    TCHAR szError[200];
    DWORD dwAttribs;
    BOOL  bDir;
    LONG  lProfileDateInDays;
    HRESULT hr;


    //
    // Check if the profile is in use
    //

    lResult = RegOpenKeyEx (hKeyUsers, lpSid, 0, KEY_READ, &hkey);

    if (lResult == ERROR_SUCCESS) {
        RegCloseKey (hkey);
        return TRUE;
    }


    //
    // Open the profile information
    //

    hr = StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), 
                         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s"),
                         lpSid);
    if (FAILED(hr)) {
        PrintLastError(HRESULT_CODE(hr));
        return FALSE;
    }

    lResult = RegOpenKeyEx (hKeyLM,
                            szSubKey,
                            0,
                            KEY_READ,
                            &hkey);

    if (lResult != ERROR_SUCCESS) {
        LoadString (hInst, IDS_FAILEDOPENPROFILE, szError, ARRAYSIZE(szError));
        _tprintf(szError, lpSid);
        PrintLastError(lResult);
        return FALSE;
    }


    //
    // Query for the ProfileImagePath
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    lResult = RegQueryValueEx (hkey,
                               TEXT("ProfileImagePath"),
                               NULL,
                               &dwType,
                               (LPBYTE)szTemp,
                               &dwSize);
    RegCloseKey(hkey);
    hkey = NULL;

    if (lResult != ERROR_SUCCESS) {
        LoadString (hInst, IDS_FAILEDPATHQUERY, szError, ARRAYSIZE(szError));
        _tprintf(szError, lpSid);
        PrintLastError(lResult);
        return FALSE;
    }


    //
    // Expand the path.
    //

    if (_tcsnicmp(TEXT("%SystemRoot%"), szTemp, 12) == 0) {
        hr = StringCchPrintf(szProfilePath, ARRAYSIZE(szProfilePath), TEXT("%s\\%s"), szSystemRoot, szTemp+13);
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            return FALSE;
        }
    }
    else if (_tcsnicmp(TEXT("%SystemDrive%"), szTemp, 13) == 0) {
        hr = StringCchPrintf(szProfilePath, ARRAYSIZE(szProfilePath), TEXT("%s\\%s"), szSystemDrive, szTemp+14);
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            return FALSE;
        }
    }
    else if (NULL == _tcschr(szTemp, TEXT('%')) && !bLocalComputer) {
        if (TEXT(':') == szTemp[1])
            szTemp[1] = TEXT('$');
        hr = StringCchPrintf(szProfilePath, ARRAYSIZE(szProfilePath), TEXT("%s\\%s"), szComputerName, szTemp);
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            return FALSE;
        }
    }
    else {
        LoadString (hInst, IDS_SKIPPROFILE, szError, ARRAYSIZE(szError));
        _tprintf(szError, szTemp);
        return TRUE;
    }
    //
    // Is this a directory or a file?
    //

    dwAttribs = GetFileAttributes (szProfilePath);

    if (dwAttribs == -1) {
        AddNode (szSubKey, NULL, FALSE);
        return TRUE;
    }

    bDir = (dwAttribs & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;


    //
    // Check Time/Date stamp.  If the profile date is older
    // than the amount specified, add it to the delete list.
    //

    lProfileDateInDays = GetProfileDateInDays(szProfilePath, bDir);

    if (lCurrentDateInDays >= lProfileDateInDays) {

        if ((lCurrentDateInDays - lProfileDateInDays) >= lDays) {
            AddNode (szSubKey, szProfilePath, bDir);
        }
    }

    return TRUE;
}


//*************************************************************
//
//  DelProfiles()
//
//  Purpose:    Deletes the user profiles
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL DelProfiles(void)
{
    HKEY hKeyLM = NULL, hKeyUsers = NULL, hKeyProfiles = NULL;
    HKEY hKeyCurrentVersion = NULL;
    LONG lResult;
    BOOL bResult = FALSE, bTemp;
    TCHAR szError[200];
    DWORD dwIndex = 0, dwNameSize;
    DWORD dwBufferSize;
    TCHAR szName[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    TCHAR tChar, tTemp;
    FILETIME ft;
    LPDELETEITEM lpTemp;
    LPTSTR pSid, lpEnd;
    DWORD lProfileKeyLen;
    HRESULT hr;


    lProfileKeyLen = lstrlen(TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"))+1;

    //
    // Open the registry
    //

    lResult = RegConnectRegistry(szComputerName, HKEY_LOCAL_MACHINE, &hKeyLM);

    if (lResult != ERROR_SUCCESS) {
        PrintLastError(lResult);
        goto Exit;
    }

    lResult = RegConnectRegistry(szComputerName, HKEY_USERS, &hKeyUsers);

    if (lResult != ERROR_SUCCESS) {
        PrintLastError(lResult);
        goto Exit;
    }

    //
    // Get the value of %SystemRoot% and %SystemDrive% relative to the computer
    //

    lResult = RegOpenKeyEx(hKeyLM,
                           TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                           0,
                           KEY_READ,
                           &hKeyCurrentVersion);
   
            
    if (lResult != ERROR_SUCCESS) {
        PrintLastError(lResult);
        goto Exit;
    }

    dwBufferSize = sizeof(szTemp);

    lResult = RegQueryValueEx(hKeyCurrentVersion,
                              TEXT("SystemRoot"),
                              NULL,
                              NULL,
                              (BYTE *) szTemp,
                              &dwBufferSize);

    if (lResult != ERROR_SUCCESS) {
        PrintLastError(lResult);
        goto Exit;
    }

    if (!bLocalComputer) {
        szTemp[1] = TEXT('$');

        hr = StringCchCopy(szSystemRoot, ARRAYSIZE(szSystemRoot), szComputerName);
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            goto Exit;
        }
        hr = StringCchCat(szSystemRoot, ARRAYSIZE(szSystemRoot), TEXT("\\")); 
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            goto Exit;
        }
        hr = StringCchCat(szSystemRoot, ARRAYSIZE(szSystemRoot), szTemp); 
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            goto Exit;
        }
                
        hr = StringCchCopy(szSystemDrive, ARRAYSIZE(szSystemDrive), szComputerName);
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            goto Exit;
        }
        hr = StringCchCat(szSystemDrive, ARRAYSIZE(szSystemDrive), TEXT("\\")); 
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            goto Exit;
        }
        hr = StringCchCatN(szSystemDrive, ARRAYSIZE(szSystemDrive), szTemp, 2); 
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            goto Exit;
        }
    }
    else {
        szSystemDrive[0] = TEXT('\0');
        hr = StringCchCatN(szSystemDrive, ARRAYSIZE(szSystemDrive), szTemp, 2);
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            goto Exit;
        }
        hr = StringCchCopy(szSystemRoot, ARRAYSIZE(szSystemRoot), szTemp);
        if (FAILED(hr)) {
            PrintLastError(HRESULT_CODE(hr));
            goto Exit;
        }
    }

    //
    // Open the ProfileList key
    //

    lResult = RegOpenKeyEx (hKeyLM,
                            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyProfiles);

    if (lResult != ERROR_SUCCESS) {

        LoadString (hInst, IDS_FAILEDPROFILELIST, szError, ARRAYSIZE(szError));
        _tprintf(szError);
        PrintLastError(lResult);
        goto Exit;
    }


    //
    // Enumerate the profiles
    //

    dwNameSize = ARRAYSIZE(szName);
    lResult = RegEnumKeyEx(hKeyProfiles,
                           dwIndex,
                           szName,
                           &dwNameSize,
                           NULL,
                           NULL,
                           NULL,
                           &ft);


    while (lResult == ERROR_SUCCESS) {

        //
        // Hand the profile info off to CheckProfile
        // to determine if the profile should be deleted or not.
        //

        if (!CheckProfile (hKeyLM, hKeyUsers, szName)) {
            if (!bIgnoreErrors) {
                goto Exit;
            }
        }


        //
        // Reset for the next loop
        //
        dwIndex++;
        dwNameSize = ARRAYSIZE(szName);

        lResult = RegEnumKeyEx(hKeyProfiles,
                               dwIndex,
                               szName,
                               &dwNameSize,
                               NULL,
                               NULL,
                               NULL,
                               &ft);
    }


    //
    // Check for errors
    //

    if (lResult != ERROR_NO_MORE_ITEMS) {
        LoadString (hInst, IDS_FAILEDENUM, szError, ARRAYSIZE(szError));
        _tprintf(szError);
        PrintLastError(lResult);
        goto Exit;
    }


    //
    // Remove profiles
    //

    lpTemp = lpDeleteList;

    while (lpTemp) {

        if (lpTemp->lpProfilePath) {

            //
            // Prompt before deleting the profile (if approp).
            //

            if (bPromptBeforeDelete) {

                while (1) {
                    LoadString (hInst, IDS_DELETEPROMPT, szError, ARRAYSIZE(szError));
                    _tprintf (szError, lpTemp->lpProfilePath);


                    tChar = _gettchar();

                    tTemp = tChar;
                    while (tTemp != TEXT('\n')) {
                        tTemp = _gettchar();
                    }

                    if ((tChar == TEXT('N')) || (tChar == TEXT('n'))) {
                        goto LoopAgain;
                    }

                    if ((tChar == TEXT('A')) || (tChar == TEXT('a'))) {
                        bPromptBeforeDelete = FALSE;
                        break;
                    }

                    if ((tChar == TEXT('Y')) || (tChar == TEXT('y'))) {
                        break;
                    }
                }
            }

            //
            // Delete the profile
            //

            LoadString (hInst, IDS_DELETING, szError, ARRAYSIZE(szError));
            _tprintf (szError, lpTemp->lpProfilePath);

            pSid = lpTemp->lpSubKey+lProfileKeyLen;

            bTemp = DeleteProfile(pSid, lpTemp->lpProfilePath, ((bLocalComputer)? NULL:szComputerName));            

            if (bTemp) {
                LoadString (hInst, IDS_SUCCESS, szError, ARRAYSIZE(szError));
                _tprintf (szError, lpTemp->lpProfilePath);

            } else {
                LoadString (hInst, IDS_FAILED, szError, ARRAYSIZE(szError));
                _tprintf (szError, lpTemp->lpProfilePath);
                PrintLastError(GetLastError());
            }
        } else {

            //
            // If there isn't a profile path, then we are just
            // cleaning up the bogus registry entry.
            //

            bTemp = TRUE;

            //
            // Clean up the registry.
            //

            RegDeleteKey (hKeyLM, lpTemp->lpSubKey);

        }


        //
        // Did the clean up fail?
        //

        if (!bTemp) {
            if (!bIgnoreErrors) {
                goto Exit;
            }
        }

LoopAgain:
        lpTemp = lpTemp->pNext;
    }


    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (hKeyCurrentVersion)
        RegCloseKey(hKeyCurrentVersion);

    if (hKeyProfiles)
        RegCloseKey(hKeyProfiles);

    if (hKeyLM)
        RegCloseKey(hKeyLM);

    if (hKeyUsers)
        RegCloseKey(hKeyUsers);


    if (lpDeleteList) {
        do {
            lpTemp = lpDeleteList->pNext;
            LocalFree (lpDeleteList);
            lpDeleteList = lpTemp;
        } while (lpDeleteList);
    }

    return bResult;
}


//*************************************************************
//
//  main()
//
//  Purpose:    main entry point
//
//  Parameters: argc    -   number of arguments
//              argv    -   arguments
//
//  Return:     0 if successful
//              1 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

int __cdecl main( int argc, char *argv[])
{
    DWORD dwErr;

    //
    // Initialize the globals
    //

    InitializeGlobals();


    //
    // Parse the command line
    //

    if (!ParseCommandLine(GetCommandLine())) {
        return 1;
    }


    //
    // Check the globals variables
    //

    dwErr = CheckGlobals();
    if (ERROR_SUCCESS != dwErr) {
        PrintLastError(dwErr);
        return 1;
    }


    //
    // Confirmation
    //

    if (!bQuiet) {
        if (!Confirm()) {
            return 1;
        }
    }


    //
    // Remove the profiles
    //

    if (!DelProfiles()) {
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpdas\events.h ===
//*************************************************************
//
//  Events.h    -   header file for events.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "gpdasevt.h"
#include "smartptr.h"
#include <strsafe.h>

class CEvents
{
    private:
        BOOL            m_bError;       // the kind of error to log
        DWORD           m_dwId;         // id of the msg
        XPtrLF<LPTSTR>  m_xlpStrings;   // Array to store arguments
        WORD            m_cStrings;     // Number of elements already in the array
        WORD            m_cAllocated;   // Number of elements allocated
        BOOL            m_bInitialised; // Initialised ?
        BOOL            m_bFailed;      // Failed in processing ?

        // Not implemented.
        CEvents(const CEvents& x);
        CEvents& operator=(const CEvents& x);


        BOOL ReallocArgStrings();


    public:
        CEvents(BOOL bError, DWORD dwId );
        BOOL AddArg(LPTSTR szArg);
        BOOL AddArg(DWORD dwArg);
        BOOL AddArgHex(DWORD dwArg);
        BOOL Report();
        ~CEvents();
};

extern TCHAR MessageResourceFile[];
BOOL ShutdownEvents (void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\common\util.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains the shared utility rountines for dealing with
    sid to string conversion, services, path manipulation etc.

Author:

    Cenk Ergan (cenke) - 2001/05/07

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ginacomn.h>

/***************************************************************************\
* Sid To String routines
*
* GetUserSid - Builds a user's sid from his token.
* GetSidString - Builds a sid string from a user's token.
* DeleteSidString - Free's sid string allocated by GetSidString.
*
* History:
* 03-23-01 Cenke        Copied from userinit\gposcript.cpp
* 06-07-01 Cenke        Fixed memory leak
\***************************************************************************/

PSID
GcGetUserSid( 
    HANDLE UserToken 
    )
{
    PTOKEN_USER pUser;
    PTOKEN_USER pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;

    //
    // Allocate space for the user info
    //
    pUser = (PTOKEN_USER) LocalAlloc( LMEM_FIXED, BytesRequired );
    if ( !pUser )
    {
        return 0;
    }

    //
    // Read in the UserInfo
    //
    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL )
    {
        //
        // Allocate a bigger buffer and try again.
        //
        pTemp = (PTOKEN_USER) LocalReAlloc( pUser, BytesRequired, LMEM_MOVEABLE );
        if ( !pTemp )
        {
            LocalFree(pUser);
            return 0;
        }

        pUser = pTemp;
        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pUser);
        return 0;
    }

    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if ( !pSid )
    {
        LocalFree(pUser);
        return NULL;
    }

    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pSid);
        pSid = 0;
    }

    return pSid;
}

LPWSTR
GcGetSidString( 
    HANDLE UserToken 
    )
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;

    //
    // Get the user sid
    //
    UserSid = GcGetUserSid( UserToken );
    if ( !UserSid )
    {
        return 0;
    }

    //
    // Convert user SID to a string.
    //
    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString,
                                            UserSid,
                                            (BOOLEAN)TRUE ); // Allocate
    LocalFree( UserSid );

    if ( !NT_SUCCESS(NtStatus) )
    {
        return 0;
    }

    return UnicodeString.Buffer ;
}

VOID
GcDeleteSidString( 
    LPWSTR SidString 
    )
{
    UNICODE_STRING String;

    RtlInitUnicodeString( &String, SidString );
    RtlFreeUnicodeString( &String );
}

/***************************************************************************\
* GcWaitForServiceToStart
*
* Waits for the specified service to start.
*
* History:
* 03-23-01 Cenke        Copied from winlogon\wlxutil.c
\***************************************************************************/

BOOL 
GcWaitForServiceToStart (
    LPTSTR lpServiceName, 
    DWORD dwMaxWait
    )
{
    BOOL bStarted = FALSE;
    DWORD dwSize = 512;
    DWORD StartTickCount;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG lpServiceConfig = NULL;

    //
    // OpenSCManager and the service.
    //
    hScManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!hScManager) {
        goto Exit;
    }

    hService = OpenService(hScManager, lpServiceName,
                           SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);
    if (!hService) {
        goto Exit;
    }

    //
    // Query if the service is going to start
    //
    lpServiceConfig = LocalAlloc (LPTR, dwSize);
    if (!lpServiceConfig) {
        goto Exit;
    }

    if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Exit;
        }

        LocalFree (lpServiceConfig);

        lpServiceConfig = LocalAlloc (LPTR, dwSize);

        if (!lpServiceConfig) {
            goto Exit;
        }

        if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {
            goto Exit;
        }
    }

    if (lpServiceConfig->dwStartType != SERVICE_AUTO_START) {
        goto Exit;
    }

    //
    // Loop until the service starts or we think it never will start
    // or we've exceeded our maximum time delay.
    //

    StartTickCount = GetTickCount();

    while (!bStarted) {

        if ((GetTickCount() - StartTickCount) > dwMaxWait) {
            break;
        }

        if (!QueryServiceStatus(hService, &ServiceStatus )) {
            break;
        }

        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
            if (ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED) {
                Sleep(500);
            } else {
                break;
            }
        } else if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {

            bStarted = TRUE;

        } else if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING) {
            Sleep(500);
        } else {
            Sleep(500);
        }
    }


Exit:

    if (lpServiceConfig) {
        LocalFree (lpServiceConfig);
    }

    if (hService) {
        CloseServiceHandle(hService);
    }

    if (hScManager) {
        CloseServiceHandle(hScManager);
    }

    return bStarted;
}


/***************************************************************************\
* GcCheckSlash
*
* Checks for an ending slash and adds one if it is missing.
*
* Parameters: lpDir   -   directory
* Return:     Pointer to the end of the string
*
* History:
* 06-19-95 EricFlo        Created
\***************************************************************************/

LPTSTR 
GcCheckSlash (
    LPTSTR lpDir
    )
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

/***************************************************************************\
* GcIsUNCPath
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL 
GcIsUNCPath(
    LPTSTR lpPath
    )
{
    if (lpPath[0] == TEXT('\\') && lpPath[1] == TEXT('\\')) {
        return(TRUE);
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpdas\events.cpp ===
//*************************************************************
//
//  Events.cpp    -   Routines to handle the event log
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "stdafx.h"
#include "rsopdbg.h"
#include "events.h"


HANDLE  hEventLog = NULL;
TCHAR   EventSourceName[] = TEXT("GPDAS");
TCHAR   MessageResourceFile[] = TEXT("%systemroot%\\system32\\rsopprov.exe");



//*************************************************************
//
//  InitializeEvents()
//
//  Purpose:    Opens the event log
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/17/95     ericflo    Created
//
//*************************************************************

BOOL InitializeEvents (void)
{

    //
    // Open the event source
    //

    hEventLog = RegisterEventSource(NULL, EventSourceName);

    if (hEventLog) {
        return TRUE;
    }

    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("InitializeEvents:  Could not open event log.  Error = %d"), GetLastError());

    return FALSE;
}



//*************************************************************
//
//  Implementation of CEvents
//
//*************************************************************



//*************************************************************
//  CEvents::CEvents
//  Purpose:    Constructor
//
//  Parameters: 
//      bError  - Error or informational
//      dwId    - Id of the eventlog msg
//
//
//  allocates a default sized array for the messages
//*************************************************************

#define DEF_ARG_SIZE 10

CEvents::CEvents(BOOL bError, DWORD dwId ) : 
                          m_cStrings(0), m_cAllocated(0), m_bInitialised(FALSE),
                          m_bError(bError), m_dwId(dwId), m_bFailed(TRUE)
{
    //
    // Allocate a default size for the message
    //
    
    m_xlpStrings = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*DEF_ARG_SIZE);
    m_cAllocated = DEF_ARG_SIZE;
    if (!m_xlpStrings) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::CEvent  Cannot log event, failed to allocate memory, error %d"), GetLastError());
        return;
    }


    //
    // Initialise eventlog if it is not already initialised
    //
    
    if (!hEventLog) {
        if (!InitializeEvents()) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::CEvent  Cannot log event, no handle"));
            return;
        }
    }

    m_bInitialised = TRUE;    
    m_bFailed = FALSE;
}



//*************************************************************
//  CEvents::~CEvents()
//
//  Purpose:    Destructor
//
//  Parameters: void
//
//  frees the memory
//*************************************************************

CEvents::~CEvents()
{
    for (int i = 0; i < m_cStrings; i++)
        if (m_xlpStrings[i])
            LocalFree(m_xlpStrings[i]);
}

//*************************************************************
//
//  CEvents::ReallocArgStrings
//
//  Purpose: Reallocates the buffer for storing arguments in case
//           the buffer runs out
//
//  Parameters: void
//
//  reallocates
//*************************************************************

BOOL CEvents::ReallocArgStrings()
{
    XPtrLF<LPTSTR>  aStringsNew;


    //
    // first allocate a larger buffer
    //
    
    aStringsNew = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*(m_cAllocated+DEF_ARG_SIZE));

    if (!aStringsNew) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::CEvent  Couldn't allocate memory"));
        m_bFailed = TRUE;        
        return FALSE;            
    }


    //
    // copy the arguments
    //
    
    for (int i = 0; i < (m_cAllocated); i++) {
        aStringsNew[i] = m_xlpStrings[i];
    }
    
    m_xlpStrings = aStringsNew.Acquire();        
    m_cAllocated+= DEF_ARG_SIZE;

    return TRUE;
}



//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters: 
//
//*************************************************************

BOOL CEvents::AddArg(LPTSTR szArg)
{
    if ((!m_bInitialised) || (m_bFailed)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArg:  Cannot log event, not initialised or failed before"));    
        return FALSE;
    }
    
    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;            
    }

    DWORD dwLength = lstrlen(szArg) + 1;
    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (dwLength));

    if (!m_xlpStrings[m_cStrings]) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArg  Cannot allocate memory, error = %d"), GetLastError());
        m_bFailed = TRUE;        
        return FALSE;            
    }

    HRESULT hr = StringCchCopy(m_xlpStrings[m_cStrings], dwLength, szArg);

    if(FAILED(hr)){
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::StringCchCopy failed with error = %d"), hr);
        m_bFailed = TRUE;        
        return FALSE;
    }

    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters: 
//
//*************************************************************

BOOL CEvents::AddArg(DWORD dwArg)
{
    if ((!m_bInitialised) || (m_bFailed)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArg(dw):  Cannot log event, not initialised or failed before"));    
        return FALSE;
    }
    
    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;            
    }

    // 2^32 < 10^10

    DWORD dwLength = 20;
    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * dwLength);

    if (!m_xlpStrings[m_cStrings]) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArg(dw)  Cannot allocate memory, error = %d"), GetLastError());
        m_bFailed = TRUE;        
        return FALSE;            
    }
    
    HRESULT hr = StringCchPrintf(m_xlpStrings[m_cStrings], dwLength, TEXT("%d"), dwArg);

    if(FAILED(hr)){
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::StringCchPrintf failed with error = %d"), hr);
        m_bFailed = TRUE;        
        return FALSE; 
    }

    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters: 
//
//*************************************************************

BOOL CEvents::AddArgHex(DWORD dwArg)
{
    if ((!m_bInitialised) || (m_bFailed)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArgHex:  Cannot log event, not initialised or failed before"));    
        return FALSE;
    }
    
    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;            
    }

    DWORD dwLength = 20;
    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * dwLength);

    if (!m_xlpStrings[m_cStrings]) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArgHex  Cannot allocate memory, error = %d"), GetLastError());
        m_bFailed = TRUE;        
        return FALSE;            
    }
    

    HRESULT hr = StringCchPrintf(m_xlpStrings[m_cStrings], dwLength, TEXT("%#x"), dwArg);

    if(FAILED(hr)){
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::StringCchPrintf failed with error = %d"), hr);
        m_bFailed = TRUE;
        return FALSE;
    }

    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::Report
//
//  Purpose: Actually collectes all the arguments and reports it to
//           the eventlog
//
//  Parameters: void
//
//*************************************************************

BOOL CEvents::Report()
{
    PSID pSid = NULL; // no sid being reportewd currently
    WORD wType=0;
    BOOL bResult = TRUE;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvents::Report:  Cannot log event, not initialised or failed before"));    
        return FALSE;
    }
    


    if ( m_bError ) {
        wType = EVENTLOG_ERROR_TYPE;
    } else {
        wType = EVENTLOG_INFORMATION_TYPE;
    }
            
    
    if (!ReportEvent(hEventLog, wType, 0, m_dwId, pSid, m_cStrings, 0, (LPCTSTR *)((LPTSTR *)m_xlpStrings), NULL)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING,  TEXT("CEvents::Report: ReportEvent failed.  Error = %d"), GetLastError());
        bResult = FALSE;
    }


    return bResult;
}


//*************************************************************
//
//  ShutdownEvents()
//
//  Purpose:    Stops the event log
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/17/95     ericflo    Created
//
//*************************************************************

BOOL ShutdownEvents (void)
{
    BOOL bRetVal = TRUE;

    if (hEventLog) {
        bRetVal = DeregisterEventSource(hEventLog);
        hEventLog = NULL;
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\delprof\gdate.c ===
/****************************** Module Header *******************************
* Module Name: GDATE.C
*
* Contains date conversion functions.
*
* Functions:
*
* gdi_isleap()
* gdate_daytodmy()
* gdate_dmytoday()
* gdate_monthdays()
* gdate_weeklyday()
*
* Comments:  This code stolen from windiff.exe
*
****************************************************************************/

#include <windows.h>
#include <string.h>

//#include "gutils.h"


BOOL gdi_isleap(LONG year);

/*---static data--------------------------------------------*/

int monthdays[] = {
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
};


/***************************************************************************
 * Function: gdate_daytomy
 *
 * Purpose:
 *
 * converts day to d/m/y
 */
void APIENTRY
gdate_daytodmy(LONG days, int FAR* yrp, int FAR* monthp, int FAR* dayp)
{
        int years;
        int nleaps;
        int month;
        int mdays;

        /* get number of completed years and calc leap days */
        years = (int) (days / 365);
        days = days % 365;
        nleaps = (years / 4) - (years / 100) + (years / 400);
        while (nleaps > days) {
                days += 365;
                years--;
                nleaps = (years / 4) - (years / 100) + (years / 400);
        }
        days -= nleaps;

        /* add one year for current (non-complete) year */
        years++;


        /* current month */
        for (month = 0; month < 12; month++) {
                mdays = monthdays[month];
                if (gdi_isleap(years) && (month == 1)) {
                        mdays++;
                }
                if (days == mdays) {
                        days = 0;
                        month++;
                        break;
                } else if (days < mdays) {
                        break;
                } else {
                        days -= mdays;
                }
        }
        /* conv month from 0-11 to 1-12 */
        if (monthp != NULL) {
                *monthp = month+1;
        }
        if (dayp != NULL) {
                *dayp = (int) days + 1;
        }
        if (yrp != NULL) {
                *yrp = years;
        }
}


/***************************************************************************
 * Function: gdate_dmytoday
 *
 * Purpose:
 *
 * converts d/m/y to a day
 */ 
LONG APIENTRY
gdate_dmytoday(int yr, int month, int day)
{
        int nleaps;
        int i;
        long ndays;

        /* exclude the current year */
        yr--;
        nleaps = (yr / 4) - (yr / 100) + (yr / 400);

        /* in any given year, day 0 is jan1 */
        month--;
        day--;
        ndays = 0;
        for (i = 0; i < month ; i++) {
                ndays += monthdays[i];
                if (gdi_isleap(yr+1) && (i == 1)) {
                        ndays++;
                }
        }
        ndays = ndays + day + nleaps + (yr * 365L);
        return(ndays);
}

/***************************************************************************
 * Function: gdate_monthdays
 *
 * Purpose:
 *
 * Gets number of days in month
 */
int APIENTRY
gdate_monthdays(int month, int year)
{
        int ndays;

        ndays = monthdays[month - 1];
        if (gdi_isleap(year) && (month == 2)) {
                ndays++;
        }
        return(ndays);
}

/***************************************************************************
 * Function: gdate_weekday
 *
 * Purpose:
 * 
 * Gets the day of the week
 */
int APIENTRY
gdate_weekday(long daynr)
{
        return((int) ((daynr + 1) % 7));
}


/***************************************************************************
 * Function: gdi_isleap
 *
 * Purpose:
 * 
 * Determines whether the year is a leap year
 */
BOOL
gdi_isleap(LONG year)
{
        if ( ((year % 4) == 0) &&
                (((year % 100) != 0) ||
                ((year % 400) == 0))) {
                        return TRUE;
        } else {
                return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpdas\gpdas.cpp ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  gpdas.cpp
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

#include "stdafx.h"
#include "planprov.h"
#include "gpdas.h"
#include <lm.h>
#include <dsgetdc.h>
#define SECURITY_WIN32
#include <security.h>
#include "userenv.h"
#include "userenvp.h"
#include "rsopinc.h"
#include "rsoputil.h"
#include "rsopdbg.h"
#include "rsopsec.h"
#include "Indicate.h"
#include "events.h"
#include "gpfilter.h"


CDebug dbgRsop(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 TRUE );


CDebug dbgCommon(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 FALSE );


extern "C" PSID GetUserSid (HANDLE UserToken);


class CAutoNetApiBufferFree
{
private:
        LPVOID _pV;

public:
        CAutoNetApiBufferFree(LPVOID pV)
           : _pV(pV)
        {
        }

        ~CAutoNetApiBufferFree()
        {
            if (_pV)
                NetApiBufferFree(_pV);
        }
};


bool SplitName(LPCWSTR pszUser, LPWSTR* ppszUserDomain, LPWSTR* ppszUserName)
{
        HRESULT     hr  =   S_OK;
        if(!pszUser)
        {
                return false;
        }

        *ppszUserDomain = NULL;
        *ppszUserName = NULL;

        wchar_t* p = wcschr(pszUser, L'\\');

        if(p)
        {
                LONG userDomainLength = (LONG)(p - pszUser);
                if(!userDomainLength)
                {
                        return false;
                }

                *ppszUserDomain = new wchar_t[userDomainLength + 1];
                if(!*ppszUserDomain)
                {
                        return false;
                }

                int userNameLength = wcslen(pszUser) - userDomainLength - 1;
                *ppszUserName = new wchar_t[userNameLength + 1];
                if(!*ppszUserName)
                {
                        delete[] *ppszUserDomain;
                        *ppszUserDomain = NULL;
                        return false;
                }

                wcsncpy(*ppszUserDomain, pszUser, userDomainLength);
                hr = StringCchCopy(*ppszUserName, userNameLength + 1, pszUser + userDomainLength + 1);

                if(FAILED(hr))
                {
                    delete[] *ppszUserDomain;
                    delete[] *ppszUserName;
                    *ppszUserDomain = NULL;
                    *ppszUserName = NULL;
                    return false;
                }
        }
        else
        {
                int userNameLength = wcslen(pszUser);
                *ppszUserName = new wchar_t[userNameLength + 1];
                if(!*ppszUserName)
                {
                        return false;
                }

                *ppszUserDomain = NULL;

                hr = StringCchCopy(*ppszUserName, userNameLength + 1, pszUser);

                if(FAILED(hr))
                {
                    delete[] *ppszUserName;
                    *ppszUserName = NULL;
                    return false;
                }

        }

        return true;
}


//*************************************************************
//
//  RsopPlanningModeProvider::RsopPlanningModeProvider()
//
//  Purpose:   Constructor
//
//*************************************************************

RsopPlanningModeProvider::RsopPlanningModeProvider()
    : m_pWbemServices(NULL),
      m_bInitialized(FALSE),
      m_pStream(NULL)
{
    _Module.IncrementServiceCount();

    m_xbstrMachName = L"computerName";
    if ( !m_xbstrMachName )
        return;

    m_xbstrMachSOM = L"computerSOM";
    if ( !m_xbstrMachSOM )
        return;

    m_xbstrMachGroups = L"computerSecurityGroups";
    if ( !m_xbstrMachGroups )
        return;

    m_xbstrUserName = L"userName";
    if ( !m_xbstrUserName )
        return;

    m_xbstrUserSOM = L"userSOM";
    if ( !m_xbstrUserSOM )
        return;

    m_xbstrUserGroups = L"userSecurityGroups";
    if ( !m_xbstrUserGroups )
        return;

    m_xbstrSite = L"site";
    if ( !m_xbstrSite )
         return;

    m_xbstrUserGpoFilter = L"userGPOFilters";
    if ( !m_xbstrUserGpoFilter )
         return;
    
    m_xbstrComputerGpoFilter = L"computerGPOFilters";
    if ( !m_xbstrComputerGpoFilter )
         return;

    m_xbstrFlags = L"flags";
    if ( !m_xbstrFlags )
         return;
    
    m_xbstrNameSpace = L"nameSpace";
    if ( !m_xbstrNameSpace )
        return;

    m_xbstrResult = L"hResult";
    if ( !m_xbstrResult )
         return;

    m_xbstrExtendedInfo = L"ExtendedInfo";
    if ( !m_xbstrExtendedInfo )
         return;

    m_xbstrClass = L"RsopPlanningModeProvider";
    if ( !m_xbstrClass )
       return;

    // m_xptrInvokerName = 0;

    m_bInitialized = TRUE;
}


//*************************************************************
//
//  Initialize()
//
//  Purpose:    WbemProvider's initialize method
//
//  Parameters: See IWbemProivderInit::Initialize
//
//  Return:     hresult
//
//*************************************************************

STDMETHODIMP RsopPlanningModeProvider::Initialize( LPWSTR pszUser,
                                                   LONG lFlags,
                                                   LPWSTR pszNamespace,
                                                   LPWSTR pszLocale,
                                                   IWbemServices __RPC_FAR *pNamespace,
                                                   IWbemContext __RPC_FAR *pCtx,
                                                   IWbemProviderInitSink __RPC_FAR *pInitSink )
{
    HRESULT hr;

    if ( !m_bInitialized ) {
        hr = pInitSink->SetStatus(E_FAIL, 0);
        return hr;
    }

    if ( !pszUser )
    {
        hr = pInitSink->SetStatus(E_INVALIDARG, 0);
        return hr;
    }

    if(m_pWbemServices)
    {
        m_pWbemServices->Release();
        m_pWbemServices = NULL;
    }

    m_pWbemServices = pNamespace;
    m_pWbemServices->AddRef();

    hr = CoMarshalInterThreadInterfaceInStream(__uuidof(IWbemServices), m_pWbemServices, &m_pStream);
    if(SUCCEEDED(hr))
        hr = pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    else
    {
        m_pWbemServices->Release();
        hr = pInitSink->SetStatus(hr, 0);
    }

    return hr;
}


//*************************************************************
//
//  ExecMethodAsync()
//
//  Purpose:    Execute method
//
//  Parameters: See IWbemServices::ExecMethodAsync
//
//  Return:     hresult
//
//*************************************************************



STDMETHODIMP RsopPlanningModeProvider::ExecMethodAsync( BSTR bstrObject,
                                                        BSTR bstrMethod,
                                                        long lFlags,
                                                        IWbemContext* pCtx,
                                                        IWbemClassObject* pInParams,
                                                        IWbemObjectSink* pResponseHandler )
{

    dbgRsop.Initialize(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 FALSE );


    dbgCommon.Initialize(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 FALSE );
    //
    // Initialize the return status object to fail status
    //

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecMethodAsync: Entering") );

    CFailRetStatus retStatus( pResponseHandler );
    HRESULT hr;
    XInterface<IWbemLocator> xLocator;

    hr = CoCreateInstance(  CLSID_WbemLocator,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IWbemLocator,
                            (LPVOID *) &xLocator );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync: CoCreateInstance returned 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    IWbemClassObject* pProvClass = NULL;
    IWbemClassObject* pOutClass = NULL;
    IWbemClassObject* pOutParams = NULL;
    IWbemServices* pWbemServices = NULL;

    hr = CoGetInterfaceAndReleaseStream(m_pStream, __uuidof(IWbemServices), (void**)&pWbemServices);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoGetInterfaceAndReleaseStream failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    hr = pWbemServices->GetObject( m_xbstrClass, WBEM_FLAG_RETURN_WBEM_COMPLETE, pCtx, &pProvClass, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetObject failed with 0x%x."), hr );

        // Try to marshall stream back before quiting
        HRESULT hrMarshall = CoMarshalInterThreadInterfaceInStream(__uuidof(IWbemServices), pWbemServices, &m_pStream);
        if ( FAILED(hrMarshall) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoMarshallInterThreadInterfaceInStream failed with 0x%x."), hrMarshall );
            m_pStream = NULL;
        }
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xProvClass( pProvClass );

    hr = CoMarshalInterThreadInterfaceInStream(__uuidof(IWbemServices), pWbemServices, &m_pStream);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoMarshallInterThreadInterfaceInStream failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    hr = pProvClass->GetMethod( bstrMethod, 0, NULL, &pOutClass);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetMethod failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xOutClass( pOutClass );

    hr = pOutClass->SpawnInstance(0, &pOutParams);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::SpawnInstance failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xOutParams( pOutParams );
    
    XHandle  xhUserToken;

    {
        XImpersonate xImp;

        if ( FAILED( xImp.Status() ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoImpersonateClient() failed with 0x%x."), xImp.Status() );
            retStatus.SetError( xImp.Status() );
            return xImp.Status();
        }

        BOOL bRet = OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &xhUserToken);
        
        if(!bRet)
            hr = HRESULT_FROM_WIN32(GetLastError());
        
        // call revert 

        HRESULT hrRev = xImp.Revert();

        if (FAILED(hrRev)){
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Failed to revert context with 0x%x"), hrRev);
            retStatus.SetError(hrRev);
            return hrRev;
        }
        
        if (!bRet) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Openthreadtoken failed with 0x%x after impersonation"), hr );
            retStatus.SetError(hr);
            return hr;
        }
    }

    if ( _wcsicmp( (WCHAR *) bstrMethod, L"RsopDeleteSession" ) == 0 )
    {
        VARIANT vNameSpace;
        hr = pInParams->Get( m_xbstrNameSpace, 0, &vNameSpace, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine name failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvNameSpace( &vNameSpace );

        if ( vNameSpace.vt == VT_NULL )
            hr = E_INVALIDARG;
        else {
            hr = ProviderDeleteRsopNameSpace( xLocator, 
                                              vNameSpace.bstrVal,
                                              xhUserToken, 
                                              NULL, 
                                              SETUP_NS_PM);
        }

        VARIANT var;
        var.vt = VT_I4;
        var.lVal = hr;

        hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        hr = pResponseHandler->Indicate(1, &pOutParams);
        if ( FAILED( hr ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

    }
    else if ( _wcsicmp( (WCHAR *) bstrMethod, L"RsopCreateSession" ) == 0 )
    {
        //
        // Code for RsopCreateSession method
        //

        BOOL bMachineData = TRUE;
        BOOL bUserData = TRUE;

        VARIANT vMachName;
        VariantInit( &vMachName );
        hr = pInParams->Get( m_xbstrMachName, 0, &vMachName, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine name failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvMachName( &vMachName );

        VARIANT vMachSOM;
        VariantInit( &vMachSOM );
        hr = pInParams->Get( m_xbstrMachSOM, 0, &vMachSOM, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine SOM failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }

        if ( vMachSOM.vt == VT_EMPTY || vMachSOM.vt == VT_NULL )
        {
            if ( vMachName.vt == VT_EMPTY || vMachName.vt == VT_NULL )
            {
                dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod:: Machine name and SOM are NULL."));
                bMachineData = FALSE;
            }
            else
            {
                DWORD         dwMachLength = wcslen( vMachName.bstrVal ) + 2;
                XPtrLF<WCHAR> szMachine = LocalAlloc( LPTR, ( dwMachLength ) * sizeof( WCHAR ) );

                if ( !szMachine )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Not enough memory 0x%x."), hr );
                    retStatus.SetError( hr );
                    return hr;
                }

                hr = StringCchCopy( szMachine, dwMachLength, vMachName.bstrVal );
                
                if(FAILED(hr))
                {
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::StringCchCpy failed with 0x%x."), hr );
                    retStatus.SetError( hr );
                    return hr;
                }

                XBStr xbstrSOM = GetSOM( szMachine );

                if ( !xbstrSOM )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine SOM failed with 0x%x."), hr );
                    retStatus.SetError( hr );
                    return hr;
                }

                vMachSOM.vt = VT_BSTR;
                vMachSOM.bstrVal = xbstrSOM.Acquire();
            }
        }

        CProgressIndicator  Indicator(  pResponseHandler,
                                        (lFlags & WBEM_FLAG_SEND_STATUS) != 0 );
        Indicator.IncrementBy( 5 );

        //
        // vMachSOM is going to have at least empty data in it all cases
        //

        XVariant xvMachSOM( &vMachSOM );

        VARIANT vUserName;
        VariantInit( &vUserName );
        hr = pInParams->Get( m_xbstrUserName, 0, &vUserName, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get user name failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvUserName( &vUserName );

        VARIANT vUserSOM;
        VariantInit( &vUserSOM );
        hr = pInParams->Get( m_xbstrUserSOM, 0, &vUserSOM, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get user SOM failed with 0x%x."), GetLastError() );
            retStatus.SetError( hr );
            return hr;
        }
        if ( vUserSOM.vt == VT_EMPTY || vUserSOM.vt == VT_NULL )
        {
            if ( vUserName.vt == VT_EMPTY || vUserName.vt == VT_NULL )
            {
                dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod:: User name and SOM are NULL."));
                bUserData = FALSE;
            }
            else
            {
                XBStr xbstrSOM = GetSOM( vUserName.bstrVal );

                if ( !xbstrSOM )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get user SOM failed with 0x%x."), GetLastError() );
                    retStatus.SetError( hr );
                    return hr;
                }

                vUserSOM.vt = VT_BSTR;
                vUserSOM.bstrVal = xbstrSOM.Acquire();
            }
        }

        //
        // vUserSOM is going to have at least empty data in it all cases
        //

        XVariant xvUserSOM( &vUserSOM );

        //
        // Nothing was asked for..
        //

        if ( (!bMachineData) && (!bUserData) ) {
            hr = S_OK;
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: User and machine (both name and SOM) are NULL."));
            retStatus.SetError( WBEM_E_INVALID_PARAMETER );
            return hr;
        }


        VARIANT vMachGroups;
        hr = pInParams->Get( m_xbstrMachGroups, 0, &vMachGroups, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine groups failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvMachGroups( &vMachGroups );


        VARIANT vUserGroups;
        hr = pInParams->Get( m_xbstrUserGroups, 0, &vUserGroups, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get user groups failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvUserGroups( &vUserGroups );


        VARIANT vSite;
        hr = pInParams->Get( m_xbstrSite, 0, &vSite, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get site failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvSite( &vSite );


        //
        // Add computer gpo filters
        //

        VARIANT vComputerGpoFilter;
        hr = pInParams->Get( m_xbstrComputerGpoFilter, 0, &vComputerGpoFilter, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get Gpo filter failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvComputerGpoFilter( &vComputerGpoFilter );

        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::Gpo filter:Adding Computer filters") );

        CGpoFilter computerGpoFilter;
        hr = computerGpoFilter.Add( &vComputerGpoFilter );
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Gpo filter:Add failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        
        //
        // Add user gpo filters
        //

        VARIANT vUserGpoFilter;
        hr = pInParams->Get( m_xbstrUserGpoFilter, 0, &vUserGpoFilter, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get Gpo filter failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        
        XVariant xvUserGpoFilter( &vUserGpoFilter );

        CGpoFilter userGpoFilter;
        
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::Gpo filter:Adding User filters") );
        
        hr = userGpoFilter.Add( &vUserGpoFilter );
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Gpo filter:Add failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        
        VARIANT vFlags;
        VariantInit( &vFlags );
        hr = pInParams->Get( m_xbstrFlags, 0, &vFlags, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get dwFlags failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }

        DWORD dwFlags = vFlags.vt == VT_EMPTY || vFlags.vt == VT_NULL ? 0 : vFlags.ulVal;
        dwFlags &= ~FLAG_INTERNAL_MASK;

        if ( dwFlags & FLAG_NO_GPO_FILTER )
        {
            dwFlags |= FLAG_NO_CSE_INVOKE;
        }
            
        //
        // do some parameter checks
        //

        if ((dwFlags & FLAG_LOOPBACK_MERGE) && (dwFlags & FLAG_LOOPBACK_REPLACE)) {            
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Loopback merge and replace, both are specified. failing"));
            retStatus.SetError( WBEM_E_INVALID_PARAMETER );
            return S_OK;
        }

        if (dwFlags & FLAG_LOOPBACK_MERGE) {            
            
            if (!bMachineData || !bUserData) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Loopback mode both user AND computer data needs to be specified"));
                retStatus.SetError( WBEM_E_INVALID_PARAMETER );
                return S_OK;
            }
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod:: Loopback merge mode specified"));
        }


        if (dwFlags & FLAG_LOOPBACK_REPLACE) {
            if (!bMachineData) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Loopback mode computer data needs to be specified"));
                retStatus.SetError( WBEM_E_INVALID_PARAMETER );
                return S_OK;
            }
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod:: Loopback replace mode specified"));
        }

        //
        // Below is a hack...
        // In case of replace mode, user som or account doesn't need to be supplied...
        // but we need to fool the rest of the code to think that user data is specified
        // and desired and we need to access check againt user som alone. 
        // Copy Mach som to user som
        //

        if (dwFlags & FLAG_LOOPBACK_REPLACE) {
            xvUserSOM = NULL;
        
            // reinit user som
            VariantInit( &vUserSOM );
            vUserSOM.vt = VT_BSTR;
            vUserSOM.bstrVal = SysAllocString(vMachSOM.bstrVal);
        
            if (!vUserSOM.bstrVal) {
                hr = E_OUTOFMEMORY;
                retStatus.SetError( hr );
                return hr;
            }
        
            xvUserSOM = &vUserSOM;
        }


        //
        // We can dump out all the input parameters here later on.
        // Currently dumping only remote Computer.
        //

        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::---------------RsopCreateSession::Input Parameters--------------------"));
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::dwFlags = 0x%x"), dwFlags);
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::---------------RsopCreateSession::Input Parameters--------------------"));

        
        // by this point we have finished all param checks. All future errors needs to be
        // returned in the method specific hResult 

        //
        // Check for access before entering policy critical section
        //

        DWORD dwExtendedInfo = 0;

        hr = AuthenticateUser(  xhUserToken,
                                vMachSOM.vt != VT_NULL ? vMachSOM.bstrVal : 0,
                                vUserSOM.vt != VT_NULL ? vUserSOM.bstrVal : 0,
                                FALSE, 
                                &dwExtendedInfo );
        if ( FAILED( hr ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: AuthenticateUser() failed with 0x%x."), hr );
        }


        //
        // Synchronize with garbage collection thread in userenv.dll by acquiring Group Policy critical section
        //

        if (SUCCEEDED(hr)) {
            
            XCriticalPolicySection criticalPolicySectionUSER( EnterCriticalPolicySection(FALSE) );
            if( !criticalPolicySectionUSER )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::EnterCriticalPolicySection (user) failed with 0x%x"), hr );
                retStatus.SetError( hr );
                return hr;
            }

            XCriticalPolicySection criticalPolicySectionMACHINE( EnterCriticalPolicySection(TRUE) );
            if(!criticalPolicySectionMACHINE)
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::EnterCriticalPolicySection (machine) failed with 0x%x"), hr );
                retStatus.SetError( hr );
                return hr;
            }

            XPtrLF<WCHAR> xwszNameSpace; 

            XPtrLF<SID> xSid = GetUserSid(xhUserToken);
            if (!xSid) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetUserSid failed."));
                return HRESULT_FROM_WIN32(E_FAIL);
            }


            hr = SetupNewNameSpace( &xwszNameSpace,
                                    0, // namespace on this machine
                                    NULL, xSid,
                                    xLocator, SETUP_NS_PM, NULL);
            if ( FAILED( hr ) )
            {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::SetupNewNameSpace failed with 0x%x"), hr );
            }
            else 
            {

                BOOL bOk;
                bOk  = GenerateRsopPolicy(  dwFlags,
                                            vMachName.vt == VT_NULL ? 0 : vMachName.bstrVal,
                                            vMachSOM.vt == VT_NULL ? 0 : vMachSOM.bstrVal,
                                            vMachGroups.vt == VT_NULL ? 0 : vMachGroups.parray,
                                            vUserName.vt == VT_NULL ? 0 : vUserName.bstrVal,
                                            vUserSOM.vt == VT_NULL ? 0 : vUserSOM.bstrVal,
                                            vUserGroups.vt == VT_NULL ? 0 : vUserGroups.parray,
                                            vSite.vt == VT_NULL ? 0 : vSite.bstrVal,
                                            xwszNameSpace,
                                            &Indicator,
                                            &computerGpoFilter,
                                            &userGpoFilter );
                if ( !bOk )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    if ( SUCCEEDED( hr ) )
                    {
                        hr = E_FAIL;
                    }

                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GenerateRsopPolicy failed with 0x%x"), hr );

                    HRESULT hrDel = DeleteRsopNameSpace( xwszNameSpace, xLocator );
                    if ( FAILED( hrDel ) )
                    {
                        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::DeleteRsopNameSpace failed with 0x%x"), hrDel );
                    }
                }
                else
                {
                    XBStr xbstrNS( xwszNameSpace );
                    if ( !xbstrNS )
                    {
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Memory allocate failed") );
                        retStatus.SetError( hr );
                        return hr;
                    }

                    VARIANT var;
                    var.vt = VT_BSTR;
                    var.bstrVal = xbstrNS;
                    hr = pOutParams->Put( m_xbstrNameSpace, 0, &var, 0);
                    if ( FAILED(hr) )
                    {
                        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put namespace failed with 0x%x"), hr );
                        retStatus.SetError( hr );
                        return hr;
                    }
                }
            }
        }
        
        VARIANT var;
        var.vt = VT_I4;
        var.lVal = hr;

        hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
        if ( FAILED( hr ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        var.lVal = dwExtendedInfo;
        hr = pOutParams->Put( m_xbstrExtendedInfo, 0, &var, 0);
        if ( FAILED( hr ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        //
        // change all returns to retStatus = error_code; return S_OK;
        //

        hr = Indicator.SetComplete();
        if ( FAILED( hr ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Increment() failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        hr = pResponseHandler->Indicate(1, &pOutParams);
        if ( FAILED( hr ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\common\optlogon.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    optlogon.c

Abstract:

    This module contains the shared rountines for the optimized logon.

Author:

    Cenk Ergan (cenke) - 2001/05/07

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ginacomn.h>

//
// The registry values under ProfileList\%UserSidString% checked when 
// determining if we should logon by cached credentials by default.
//

#define GC_PROFILE_LIST_PATH               L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"
#define GC_NEXT_LOGON_CACHEABLE_VALUE_NAME L"NextLogonCacheable"
#define GC_SYNC_LOGON_SCRIPT_VALUE_NAME    L"RunLogonScriptSync"
#define GC_OPTIMIZED_LOGON_VALUE_NAME      L"OptimizedLogonStatus"

/***************************************************************************\
* GcCheckIfProfileAllowsCachedLogon
*
* Returns whether profile settings are not compatible with doing fast-cached
* logons every logon, e.g. roaming profile, remote home directory etc.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD
GcCheckIfProfileAllowsCachedLogon(
    PUNICODE_STRING HomeDirectory,
    PUNICODE_STRING ProfilePath,
    PWCHAR UserSidString,
    PDWORD NextLogonCacheable
    )
{
    DWORD ErrorCode;
    DWORD LogonCacheable;
    DWORD UserPreference;

    //
    // Start with the assumption that the logon is not cacheable.
    //

    ErrorCode = ERROR_SUCCESS;
    LogonCacheable = FALSE;

    //
    // Is the home directory on the network (i.e. a UNC path)?
    //

    if (HomeDirectory &&
        HomeDirectory->Length > 4 && 
        GcIsUNCPath(HomeDirectory->Buffer)) {
        goto cleanup;        
    }

    //
    // Is the profile path on the network (i.e. a UNC path)?
    //

    if (ProfilePath &&
        ProfilePath->Length > 4 && 
        GcIsUNCPath(ProfilePath->Buffer)) {

        //
        // Check if the user has explicitly requested his roaming profile to
        // be local on this machine.
        //

        UserPreference = GcGetUserPreferenceValue(UserSidString);

        //
        // If user preference is not 0, then the roaming user profile is not 
        // set to be local on this machine: we can't do optimized logon.
        //

        if (UserPreference) {
            goto cleanup;
        }
    }

    //
    // The logon is cacheable.
    //

    LogonCacheable = TRUE;

  cleanup:

    if (ErrorCode == ERROR_SUCCESS) {
        *NextLogonCacheable = LogonCacheable;
    }

    return ErrorCode;
}
 
/***************************************************************************\
* GcCheckIfLogonScriptsRunSync
*
* Returns whether logons scripts are to be run synchronously.
* Default is asynchronous.
*
* History:
* 04-25-01 Cenke        Created
\***************************************************************************/
BOOL 
GcCheckIfLogonScriptsRunSync(
    PWCHAR UserSidString
    )
{
    DWORD ErrorCode;
    BOOL bSync = FALSE;

    ErrorCode = GcAccessProfileListUserSetting(UserSidString,
                                               FALSE,
                                               GC_SYNC_LOGON_SCRIPT_VALUE_NAME,
                                               &(DWORD)bSync);

    if (ErrorCode != ERROR_SUCCESS) {
        bSync = FALSE;
    }

    return bSync;
}

/***************************************************************************\
* GcAccessProfileListUserSetting
*
* Queries or sets a DWORD value for the specified user under the local 
* machine profile list key.
*
* History:
* 05-01-01 Cenke        Created
\***************************************************************************/
DWORD
GcAccessProfileListUserSetting (
    PWCHAR UserSidString,
    BOOL SetValue,
    PWCHAR ValueName,
    PDWORD Value
    )
{
    HKEY ProfileListKey;
    HKEY UserProfileKey;
    ULONG Result;
    DWORD ErrorCode;
    DWORD ValueType;
    DWORD Size;

    //
    // Initialize locals.
    //

    UserProfileKey = NULL;
    ProfileListKey = NULL;
    
    //
    // Open the ProfileList registry key.
    //

    Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          GC_PROFILE_LIST_PATH,
                          0,
                          KEY_READ,
                          &ProfileListKey);

    if (Result != ERROR_SUCCESS) {
        ErrorCode = Result;
        goto cleanup;
    }

    //
    // Open the user's profile key under the ProfileList key using user's SID.
    //

    Result = RegOpenKeyEx(ProfileListKey,
                          UserSidString,
                          0,
                          KEY_READ | KEY_WRITE,
                          &UserProfileKey);

    if (Result != ERROR_SUCCESS) {
        ErrorCode = Result;
        goto cleanup;
    }

    if (SetValue) {

        //
        // Set the value.
        //

        Result = RegSetValueEx(UserProfileKey,
                               ValueName,
                               0,
                               REG_DWORD,
                               (BYTE *) Value,
                               sizeof(DWORD));

        if (Result != ERROR_SUCCESS) {
            ErrorCode = Result;
            goto cleanup;
        }

    } else {

        //
        // Query the value.
        //

        Size = sizeof(DWORD);

        Result = RegQueryValueEx(UserProfileKey,
                                 ValueName,
                                 0,
                                 &ValueType,
                                 (BYTE *) Value,
                                 &Size);

        if (Result != ERROR_SUCCESS) {
            ErrorCode = Result;
            goto cleanup;
        }

    }

    //
    // We are done.
    //
    
    ErrorCode = ERROR_SUCCESS;

  cleanup:

    if (ProfileListKey) {
        RegCloseKey(ProfileListKey);
    }

    if (UserProfileKey) {
        RegCloseKey(UserProfileKey);
    }

    return ErrorCode;
}
   

/***************************************************************************\
* GcGetNextLogonCacheable
*
* Returns whether we are allowed to perform a cached logon at the next logon.
* For instance, if last time we logged on using cached credentials, our attempt 
* at background logon failed for a reason (e.g. password expired) we want to 
* force the user to hit the network logon path to deal with.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD
GcGetNextLogonCacheable(
    PWCHAR UserSidString,
    PDWORD NextLogonCacheable
    )
{
    DWORD ErrorCode;

    ErrorCode = GcAccessProfileListUserSetting(UserSidString,
                                               FALSE,
                                               GC_NEXT_LOGON_CACHEABLE_VALUE_NAME,
                                               NextLogonCacheable);
                                             
    return ErrorCode;
}

/***************************************************************************\
* GcSetNextLogonCacheable
*
* Sets whether we are allowed to perform a cached logon at the next logon.
* For instance, if after logging on the user with cached credentials our attempt 
* at background logon fails for a reason (e.g. password expired) we want to 
* force the user to hit the network logon path to deal with.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD
GcSetNextLogonCacheable(
    PWCHAR UserSidString,
    DWORD NextLogonCacheable
    )
{
    DWORD ErrorCode;

    ErrorCode = GcAccessProfileListUserSetting(UserSidString,
                                               TRUE,
                                               GC_NEXT_LOGON_CACHEABLE_VALUE_NAME,
                                               &NextLogonCacheable);
                                             
    return ErrorCode;
}

/***************************************************************************\
* GcSetOptimizedLogonStatus
*
* Saves optimized logon status for the user in the profile list.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD
GcSetOptimizedLogonStatus(
    PWCHAR UserSidString,
    DWORD OptimizedLogonStatus
    )
{
    DWORD ErrorCode;

    ErrorCode = GcAccessProfileListUserSetting(UserSidString,
                                               TRUE, 
                                               GC_OPTIMIZED_LOGON_VALUE_NAME,
                                               &OptimizedLogonStatus);

    return ErrorCode;
}

/***************************************************************************\
* GcGetUserPreferenceValue
*
* Gets user preference flags on whether the user's roaming profile is set
* to be local on this machine.
*
* History:
* 05-01-01 Cenke        Copied from gina\userenv\profile.cpp
\***************************************************************************/
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")
#define PROFILE_LOCALONLY            TEXT("LocalProfile")
#define USER_PREFERENCE              TEXT("UserPreference")
#define USERINFO_LOCAL               0
#define USERINFO_UNDEFINED           99
const TCHAR c_szBAK[] = TEXT(".bak");

DWORD 
GcGetUserPreferenceValue(
    LPTSTR SidString
    )
{
    TCHAR LocalProfileKey[MAX_PATH];
    DWORD RegErr, dwType, dwSize, dwTmpVal, dwRetVal = USERINFO_UNDEFINED;
    LPTSTR lpEnd;
    HKEY hkeyProfile, hkeyPolicy;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SYSTEM_POLICIES_KEY,
                     0, KEY_READ,
                     &hkeyPolicy) == ERROR_SUCCESS) {

        dwSize = sizeof(dwTmpVal);
        RegQueryValueEx(hkeyPolicy,
                        PROFILE_LOCALONLY,
                        NULL, &dwType,
                        (LPBYTE) &dwTmpVal,
                        &dwSize);

        RegCloseKey (hkeyPolicy);
        if (dwTmpVal == 1) {
            dwRetVal = USERINFO_LOCAL;
            return dwRetVal;
        }
    }    
   
    if (SidString != NULL) {

        //
        // Query for the UserPreference value
        //

        lstrcpy(LocalProfileKey, GC_PROFILE_LIST_PATH);
        lpEnd = GcCheckSlash (LocalProfileKey);
        lstrcpy(lpEnd, SidString);

        RegErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              LocalProfileKey,
                              0,
                              KEY_READ,
                              &hkeyProfile);


        if (RegErr == ERROR_SUCCESS) {

            dwSize = sizeof(dwRetVal);
            RegQueryValueEx(hkeyProfile,
                            USER_PREFERENCE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwRetVal,
                            &dwSize);

            RegCloseKey (hkeyProfile);
        }

        lstrcat(LocalProfileKey, c_szBAK);
        RegErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              LocalProfileKey,
                              0,
                              KEY_READ,
                              &hkeyProfile);


        if (RegErr == ERROR_SUCCESS) {

            dwSize = sizeof(dwRetVal);
            RegQueryValueEx(hkeyProfile,
                            USER_PREFERENCE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwRetVal,
                            &dwSize);

            RegCloseKey (hkeyProfile);
        }
    }

    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpdas\rsopprov.cpp ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  gpdas.h
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "planprov.h"
#include <sddl.h>
#include "GPDAS.h"
#include "events.h"
#include "rsopdbg.h"
#include "rsopsec.h"

const WCHAR* RSOP_PLANNING_SERVICENAME = L"rsopprov";

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RsopPlanningModeProvider, RsopPlanningModeProvider)
END_OBJECT_MAP()

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    CComModule::Init(p, h, plibid);

    // set up the initial service status
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}


//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { (LPWSTR) RSOP_PLANNING_SERVICENAME, _ServiceMain },
        { NULL, NULL }
    };
    ::StartServiceCtrlDispatcher(st);
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPWSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(RSOP_PLANNING_SERVICENAME, _Handler);
    if (m_hServiceStatus == NULL)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CServiceModule::ServiceMain failed to Register ServiceCtrlHandler with error %d."), GetLastError() );
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);

}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    default:
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CServiceModule::Handler Wrong opcode passed to handler %d."), dwOpcode );
    }
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPWSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode);
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
    _Module.dwThreadID = GetCurrentThreadId();

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    _ASSERTE(SUCCEEDED(hr));

    if ( ! SUCCEEDED(hr) )
        return;
    
    //
    // Get a security descriptor to pass to CoInitializeSecurity -- note
    // that this also returns sids and acls that are part of the security
    // descriptor -- we need to free these once the service shuts down, but
    // we cannot free them before then.
    //
    
    XPtrLF<SECURITY_DESCRIPTOR> xAbsoluteSD;
    CSecDesc                    RelativeSD;

    RelativeSD.AddAdministrators( COM_RIGHTS_EXECUTE );
    RelativeSD.AddAuthUsers( COM_RIGHTS_EXECUTE );
    RelativeSD.AddLocalSystem( COM_RIGHTS_EXECUTE );

    RelativeSD.AddAdministratorsAsGroup();
    RelativeSD.AddAdministratorsAsOwner();

    xAbsoluteSD = RelativeSD.MakeSD();

    if ( ! xAbsoluteSD )
    {
        DWORD Status = GetLastError();

        hr = HRESULT_FROM_WIN32(Status);    
    }

    if (SUCCEEDED(hr)) 
    {
        hr = CoInitializeSecurity(xAbsoluteSD, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
        _ASSERTE(SUCCEEDED(hr));
    }

    if (FAILED(hr))
    {
        goto Run_Exit;
    }

    if ( SUCCEEDED(hr) )
    {
        hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE);
        _ASSERTE(SUCCEEDED(hr));
    }

    if ( ! SUCCEEDED(hr) )
    {
        goto Run_Exit;
    }

    SetServiceStatus(SERVICE_RUNNING);

    MSG msg;
    BOOL bRet;

    while ((bRet = GetMessage(&msg, 0, 0, 0)) != 0)
    {
        if (-1 == bRet) 
        {
            // Error occured while receiving message
            break;
        }

        DispatchMessage(&msg);
    }

    _Module.RevokeClassObjects();


Run_Exit:

    CoUninitialize();    
}

LONG CServiceModule::IncrementServiceCount()
{
    LONG l;

   l = CoAddRefServerProcess();
   dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CServiceModule::IncrementServiceCount. Ref count = %d."), l);
   return l;
}

LONG CServiceModule::DecrementServiceCount()
{
    LONG srvRefCount = CoReleaseServerProcess();
    
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CServiceModule::DecrementServiceCount. Ref count = %d. "), srvRefCount);

    if (srvRefCount == 0) {
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CServiceModule::Unlock Ref count came down to zero. Exitting."));
    }
    return srvRefCount;
}


/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI wWinMain(HINSTANCE hInstance,
    HINSTANCE /*hPrevInstance*/, LPWSTR lpCmdLine, int /*nShowCmd*/)
{
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_RSOPPROVLib);
    _Module.Start();

    ShutdownEvents();    

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpdas\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RSOPPROV.rc
//
#define IDS_SERVICENAME                 100
#define IDR_RSOPPROV                    100
#define IDS_GPDAS_DESC                  101
#define IDR_RsopPlanningModeProvider    102

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpdas\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE0):	..\idl\$(O)\$(@F)
    copy ..\idl\$(O)\$(@F) $@

$(O)\RSoP.MFL $(O)\RSoP.MOF: RSoPCore.MOF RSoPCls.MOF
    mofcomp -MOF:$(O)\RSoP.MOF -MFL:$(O)\RSoP.MFL -Amendment:ms_409 RSoPCore.MOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpdas\gpdas.h ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  gpdas.h
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

#if !defined(AFX_GPDAS_H__6A79C813_70A7_4024_A840_66B2D92A23E8__INCLUDED_)
#define AFX_GPDAS_H__6A79C813_70A7_4024_A840_66B2D92A23E8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "stdafx.h"
#include "resource.h"
#include <wbemidl.h>
#include "smartptr.h"
#include <strsafe.h>

class RsopPlanningModeProvider : public IWbemProviderInit,
                                 public IWbemServices,
                                 public CComObjectRoot,
                                 public CComCoClass<RsopPlanningModeProvider,&CLSID_RsopPlanningModeProvider>
{
public:
        RsopPlanningModeProvider();

        ~RsopPlanningModeProvider()
        {
            if(m_pWbemServices)
                m_pWbemServices->Release();

            _Module.DecrementServiceCount();
        }

BEGIN_COM_MAP(RsopPlanningModeProvider)
        COM_INTERFACE_ENTRY(IWbemProviderInit)
        COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(RsopPlanningModeProvider)

DECLARE_REGISTRY_RESOURCEID(IDR_RsopPlanningModeProvider)

public:

    //
    // IWbemServices methods
    //

    STDMETHOD(OpenNamespace)(const BSTR Namespace,long lFlags,IWbemContext* pCtx,IWbemServices** ppWorkingNamespace,IWbemCallResult** ppResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CancelAsyncCall)(IWbemObjectSink *pSink){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CancelAsyncRequest)(long lAsyncRequestHandle){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(QueryObjectSink)( long lFlags,IWbemObjectSink **ppResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(GetObject)(const BSTR ObjectPath, long lFlags, IWbemContext* pCtx, IWbemClassObject** ppObject, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(GetObjectAsync)(const BSTR ObjectPath,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(PutClass)(IWbemClassObject* pObject, long lFlags, IWbemContext* pCtx,IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(PutClassAsync)(IWbemClassObject* pObject, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(DeleteClass)(const BSTR Class, long lFlags, IWbemContext* pCtx, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(DeleteClassAsync)(const BSTR Class, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CreateClassEnum)(const BSTR Superclass, long lFlags, IWbemContext* pCtx, IEnumWbemClassObject** ppEnum){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CreateClassEnumAsync)(const BSTR Superclass, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(PutInstance)(IWbemClassObject* pInst, long lFlags, IWbemContext* pCtx, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(PutInstanceAsync)(IWbemClassObject* pInst, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(DeleteInstance)(const BSTR ObjectPath, long lFlags, IWbemContext* pCtx, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(DeleteInstanceAsync)(const BSTR ObjectPath, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CreateInstanceEnum)(const BSTR Class, long lFlags, IWbemContext* pCtx, IEnumWbemClassObject** ppEnum){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CreateInstanceEnumAsync)(const BSTR Class, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecQuery)(const BSTR QueryLanguage, const BSTR Query, long lFlags, IWbemContext* pCtx, IEnumWbemClassObject** ppEnum){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecQueryAsync)(const BSTR QueryLanguage, const BSTR Query, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecNotificationQuery)(const BSTR QueryLanguage, const BSTR Query, long lFlags, IWbemContext* pCtx, IEnumWbemClassObject** ppEnum){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecNotificationQueryAsync)(const BSTR QueryLanguage, const BSTR Query, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecMethod)(const BSTR ObjectPath, const BSTR MethodName, long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, IWbemClassObject** ppOutParams, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecMethodAsync)(const BSTR ObjectPath, const BSTR MethodName, long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, IWbemObjectSink* pResponseHandler);

    //
    // IWbemProviderInit methods
    //

    STDMETHOD(Initialize)(LPWSTR pszUser, LONG lFlags, LPWSTR pszNamespace, LPWSTR pszLocale,IWbemServices __RPC_FAR *pNamespace,
                          IWbemContext __RPC_FAR *pCtx, IWbemProviderInitSink __RPC_FAR *pInitSink);

private:

    IWbemServices*          m_pWbemServices;
    LPSTREAM                m_pStream;

    BOOL                    m_bInitialized;
    XBStr                   m_xbstrMachName;
    XBStr                   m_xbstrMachSOM;
    XBStr                   m_xbstrMachGroups;
    XBStr                   m_xbstrUserName;
    XBStr                   m_xbstrUserSOM;
    XBStr                   m_xbstrUserGroups;
    XBStr                   m_xbstrSite;
    XBStr                   m_xbstrUserGpoFilter;
    XBStr                   m_xbstrComputerGpoFilter;
    XBStr                   m_xbstrFlags;
    XBStr                   m_xbstrNameSpace;
    XBStr                   m_xbstrResult;
    XBStr                   m_xbstrExtendedInfo;
    XBStr                   m_xbstrClass;
};

#endif // !defined(AFX_GPDAS_H__6A79C813_70A7_4024_A840_66B2D92A23E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpdas\stdafx.h ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  stdafx.h
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

#if !defined(AFX_STDAFX_H__1BB94413_1005_4129_B577_B9A060FFDA25__INCLUDED_)
#define AFX_STDAFX_H__1BB94413_1005_4129_B577_B9A060FFDA25__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
    void ServiceMain(DWORD dwArgc, LPWSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    LONG IncrementServiceCount();
    LONG DecrementServiceCount();
    void SetServiceStatus(DWORD dwState);


//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPWSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
   
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
};

extern CServiceModule _Module;

#include <atlcom.h>
#include <comdef.h>

#endif // !defined(AFX_STDAFX_H__1BB94413_1005_4129_B577_B9A060FFDA25__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpdas\stdafx.cpp ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  stdafx.cpp
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\client\app_client.c ===
#include <app_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\client\bind.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  apis.cxx
//
//*************************************************************

#include "appmgmt.hxx"

handle_t    ghRpc = 0;

DWORD
Bind()
{
    SC_HANDLE       hSC;
    SC_HANDLE       hAppSvc;
    USHORT*         pwszStringBinding;
    SERVICE_STATUS  ServiceStatus;
    DWORD           Status;
    DWORD           Retries;
    DWORD           MaxRetries;
    BOOL            bServiceStarted;
    BOOL            bStatus;

    if ( ghRpc )
        return ERROR_SUCCESS;

    hSC = 0;
    hAppSvc = 0;

    Status = ERROR_SUCCESS;

    hSC = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE );

    if ( hSC )
        hAppSvc = OpenService( hSC, L"appmgmt", SERVICE_QUERY_STATUS | SERVICE_START );

    if ( ! hAppSvc )
    {
        Status = GetLastError();
        goto BindEnd;
    }

    bServiceStarted = FALSE;

    Retries = 0;
    MaxRetries = MAX_SERVICE_START_WAIT_TIME / SERVICE_RETRY_INTERVAL;

    do
    {
        bStatus = QueryServiceStatus( hAppSvc, &ServiceStatus );

        if ( ! bStatus )
        {
            Status = GetLastError();
            goto BindEnd;
        }

        switch ( ServiceStatus.dwCurrentState )
        {
        case SERVICE_STOPPED :
            bStatus = StartService( hAppSvc, NULL, NULL );

            if ( ! bStatus )
            {
                Status = GetLastError();
                goto BindEnd;
            }
            break;
        case SERVICE_START_PENDING :
            DWORD dwNewMaxRetries;

            dwNewMaxRetries = ServiceStatus.dwWaitHint / SERVICE_RETRY_INTERVAL;

            if ( dwNewMaxRetries < MaxRetries )
            {
                MaxRetries = dwNewMaxRetries;
            }

            break;
        case SERVICE_STOP_PENDING :
            break;
        case SERVICE_RUNNING :
            bServiceStarted = TRUE;
            break;
        default :
            ASSERT(0);
            Status = ERROR_INVALID_SERVICE_CONTROL;
            goto BindEnd;
        }

        if ( bServiceStarted )
            break;

        Sleep( SERVICE_RETRY_INTERVAL );

        Retries++;

    } while ( Retries <= MaxRetries ) ;

    if ( ! bServiceStarted )
    {
        Status = ERROR_SERVICE_REQUEST_TIMEOUT;
        goto BindEnd;
    }

    Status = RpcStringBindingCompose(
                NULL,
                (PUSHORT)L"ncalrpc",
                NULL,
                (PUSHORT)L"appmgmt",
                NULL,
                &pwszStringBinding );

    if ( ERROR_SUCCESS == Status )
    {
        if ( ! ghRpc )
        {
            Status = RpcBindingFromStringBinding(
                        pwszStringBinding,
                        &ghRpc );
        }
    
        RpcStringFree( &pwszStringBinding );
    }

BindEnd:

    if ( hAppSvc )
        CloseServiceHandle( hAppSvc );

    if ( hSC )
        CloseServiceHandle( hSC );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\client\cltevnts.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  cltevnts.cxx
//
//*************************************************************

#include "appmgmt.hxx"

void
CEvents::ZAPInstall(
    DWORD       ErrorStatus,
    WCHAR *     pwszDeploymentName,
    WCHAR *     pwszGPOName,
    WCHAR *     pwszPath
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_ZAP_FAILED,
            FALSE,
            4,
            pwszDeploymentName,
            pwszGPOName,
            pwszPath,
            wszStatus );
    }
    else
    {
        Report(
            EVENT_APPMGMT_ZAP,
            FALSE,
            2,
            pwszDeploymentName,
            pwszGPOName );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\client\main.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  main.cxx
//
//*************************************************************

#include "appmgmt.hxx"

extern "C" BOOLEAN
AppmgmtInitialize(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH :
        InitDebugSupport( DEBUGMODE_CLIENT );
        gpEvents = new CEvents();
        break;
    case DLL_PROCESS_DETACH :
        if ( ghRpc )
            RpcBindingFree( &ghRpc );
        delete gpEvents;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\client\apis.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998-2000
//  All rights reserved
//
//  apis.cxx
//
//*************************************************************

#include "appmgmt.hxx"

static CLoadMsi * gLoadMsi = 0;
static WCHAR * gpwszWinsta = 0;

static DWORD ReportInstallStatus(
    PINSTALLCONTEXT pInstallContext,
    DWORD           InstallStatus,
    BOOL            bUninstall,
    WCHAR *         pwszDeploymentName,
    WCHAR *         pwszGPOName,
    WCHAR *         pwszDeploymentId
    );

DWORD WINAPI
InstallApplication(
    IN  PINSTALLDATA pInstallData
    )
{
    APPKEY              AppKey;
    HINSTANCE           hMsi;
    MSICONFIGUREPRODUCTEXW * pfnConfigureProduct;
    PINSTALLCONTEXT     pInstallContext;
    APPLICATION_INFO    InstallInfo;
    UNINSTALL_APPS      UninstallApps;
    DWORD               InstallUILevel;
    INSTALLUILEVEL      OldUILevel;
    DWORD               UninstallCount;
    DWORD               n;
    DWORD               ExtraStatus;
    DWORD               Status;
    BOOL                bStatus;
    boolean             bInstall;

    Status = Bind();

    if ( Status != ERROR_SUCCESS )
        return Status;

    if ( DebugLevelOn(DM_VERBOSE) )
    {
        WCHAR *             pwszCommandLine;
        WCHAR               UserName[32];
        DWORD               NameLength;

        NameLength = sizeof(UserName) / sizeof(WCHAR);
        UserName[0] = 0;

        GetUserName( UserName, &NameLength );

        pwszCommandLine = GetCommandLine();
        if ( ! pwszCommandLine )
            pwszCommandLine = L"";

        DebugMsg((DM_VERBOSE, IDS_INSTALL_REQUEST, pwszCommandLine, UserName));
    }

    AppKey.Type = pInstallData->Type;
    AppKey.ProcessorArchitecture = DEFAULT_ARCHITECTURE;

    switch ( pInstallData->Type )
    {
    case APPNAME :
        AppKey.uType.AppName.Name = pInstallData->Spec.AppName.Name;
        memcpy( &AppKey.uType.AppName.PolicyId, &pInstallData->Spec.AppName.GPOId, sizeof(GUID) );
        break;
    case FILEEXT :
        AppKey.uType.FileExt = pInstallData->Spec.FileExt;
        break;
    case PROGID :
        AppKey.uType.ProgId = pInstallData->Spec.ProgId;
        break;
    case COMCLASS :
        AppKey.uType.COMClass.Clsid = pInstallData->Spec.COMClass.Clsid;
        AppKey.uType.COMClass.ClsCtx = pInstallData->Spec.COMClass.ClsCtx;

        break;
    default :
        return ERROR_INVALID_PARAMETER;
    }

    pInstallContext = 0;
    memset( &InstallInfo, 0, sizeof(InstallInfo) );
    memset( &UninstallApps, 0, sizeof(UninstallApps) );

    Status = InstallBegin(
                ghRpc,
                &AppKey,
                &pInstallContext,
                &InstallInfo,
                &UninstallApps );

    if ( Status != ERROR_SUCCESS )
        return Status;

    CLoadMsi    LoadMsi( Status );

    if ( Status != ERROR_SUCCESS )
        goto InstallApplicationExit;

    if ( InstallInfo.pwszSetupCommand )
    {
        HINSTANCE           hShell32;
        SHELLEXECUTEEXW *   pfnShellExecuteEx;
        SHELLEXECUTEINFO    ShellExInfo;
        WCHAR *             pwszCommand;
        WCHAR *             pwszParams;
        WCHAR *             pwszDirectory;

        pwszDirectory = NULL;

        pfnShellExecuteEx = 0;
        hShell32 = LoadLibrary( L"shell32.dll" );

        if ( hShell32 )
            pfnShellExecuteEx = (SHELLEXECUTEEXW *) GetProcAddress( hShell32, "ShellExecuteExW" );

        if ( ! pfnShellExecuteEx )
            Status = GetLastError();

        if ( ERROR_SUCCESS == Status )
        {
            pwszCommand = InstallInfo.pwszSetupCommand;

            if ( L'"' == pwszCommand[0] )
            {
                pwszParams = wcschr( &pwszCommand[1], L'"' );
                if ( pwszParams )
                    pwszCommand++;
            }
            else
            {
                pwszParams = wcschr( pwszCommand, L' ' );
            }

            if ( pwszParams )
            {
                *pwszParams++ = 0;
                while ( L' ' == *pwszParams )
                    pwszParams++;
            }
        }

        //
        // Need to set the current directory to that 
        // containing the actual executable
        //
        if ( ERROR_SUCCESS == Status )
        {
            WCHAR* pwszDirectoryEnd;

            //
            // Find the last pathsep, which marks the
            // end of the containing directory -- if we 
            // don't find it, the admin specified some strange
            // path and we'll just end up passing NULL for
            // the current directory
            //
            pwszDirectoryEnd = wcsrchr( pwszCommand, L'\\' );

            if ( pwszDirectoryEnd )
            {
                //
                // Get a copy of the full path that we can
                // truncate to the containing directory
                //
                pwszDirectory = StringDuplicate( pwszCommand );

                if ( pwszDirectory )
                {
                    //
                    // Truncate to the containing directory
                    //
                    pwszDirectory[ pwszDirectoryEnd - pwszCommand ] = L'\0';
                }
                else
                {
                    Status = ERROR_OUTOFMEMORY;
                }
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            ShellExInfo.cbSize = sizeof( ShellExInfo );
            ShellExInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
            ShellExInfo.hwnd = NULL;
            ShellExInfo.lpVerb = NULL;
            ShellExInfo.lpFile = pwszCommand;
            ShellExInfo.lpParameters = pwszParams;
            ShellExInfo.lpDirectory = pwszDirectory;
            ShellExInfo.nShow = SW_SHOWNORMAL;
            ShellExInfo.hProcess = 0;

            DebugMsg((DM_VERBOSE, IDS_LEGACY_INSTALL, pwszCommand));

            bStatus = (*pfnShellExecuteEx)( &ShellExInfo );

            if ( ! bStatus )
                Status = GetLastError();
        }

        delete [] pwszDirectory;

        if ( hShell32 )
            FreeLibrary( hShell32 );

        if ( (ERROR_SUCCESS == Status) && ShellExInfo.hProcess )
        {
            Status = WAIT_OBJECT_0;

            if ( LoadUser32Funcs() )
            {
                MSG     msg;
                HANDLE  Handles[2];

                Handles[0] = ShellExInfo.hProcess;

                for (;;)
                {
                    Status = (*pfnMsgWaitForMultipleObjects)( 1, Handles, FALSE, INFINITE, QS_ALLINPUT );

                    if ( (WAIT_OBJECT_0+1) == Status )
                    {
                        if ( (*pfnPeekMessageW)( &msg, NULL, 0, 0, PM_REMOVE) )
                        {
                            (*pfnTranslateMessage)( &msg );
                            (*pfnDispatchMessageW)( &msg );
                        }
                        continue;
                    }

                    break;
                }
            }

            CloseHandle( ShellExInfo.hProcess );

            if ( WAIT_OBJECT_0 == Status )
                Status = ERROR_SUCCESS;
            else
                Status = GetLastError();
        }

        gpEvents->ZAPInstall(
                    Status,
                    InstallInfo.pwszDeploymentName,
                    InstallInfo.pwszGPOName,
                    pwszCommand );

        goto InstallApplicationExit;
    }

    OldUILevel = (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NOCHANGE, NULL );

    if ( UninstallApps.Products > 0 )
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_BASIC, NULL );

    for ( UninstallCount = 0; UninstallCount < UninstallApps.Products; )
    {
        if ( UninstallApps.ApplicationInfo[UninstallCount].Flags & APPINFOFLAG_UNINSTALL )
        {
            DebugMsg((DM_VERBOSE, IDS_UNINSTALL, UninstallApps.ApplicationInfo[UninstallCount].pwszDeploymentName, UninstallApps.ApplicationInfo[UninstallCount].pwszGPOName));

            //
            // The MsiQueryProductState could fail due to out of memory -- it could
            // return INSTALL_STATE_UNKNOWN in out of memory situations, and we would incorrectly
            // unmanage the application -- so we use MsiGetProductInfo which returns a status
            // that allows us to distinguish these cases
            //
            Status = gpfnMsiGetProductInfo(
                UninstallApps.ApplicationInfo[UninstallCount].pwszProductCode,
                INSTALLPROPERTY_PACKAGECODE,
                NULL,
                NULL);

            //
            // If the product is installed, try to uninstall.  If it exists but has
            // bad configuration data, attempt the uninstall anyway in the hope that
            // it will get removed
            //
            if ( ( ERROR_SUCCESS == Status ) ||
                 ( ERROR_BAD_CONFIGURATION == Status ) )
            {
                //
                // ERROR_SUCCESS_REBOOT_INITIATED here will be treated as an error
                // since we don't want to attempt to do an install if the machine
                // is being rebooted.
                // The two REJECTED errors can be encountered when the application is 
                // only advertised and is prevented from (un)installing by policy.
                //
                Status = (*gpfnMsiConfigureProductEx)( UninstallApps.ApplicationInfo[UninstallCount].pwszProductCode, INSTALLLEVEL_MAXIMUM, INSTALLSTATE_ABSENT, NULL );

                if ( ERROR_SUCCESS_REBOOT_REQUIRED == Status )
                {
                    Status = ERROR_SUCCESS;
                }
                else if ( (ERROR_INSTALL_PACKAGE_REJECTED == Status) ||
                          (ERROR_INSTALL_TRANSFORM_REJECTED == Status) )
                {
                    Status = InstallUnmanageApp( pInstallContext, UninstallApps.ApplicationInfo[UninstallCount].pwszDeploymentId, TRUE );
                }
            }
            else if ( ERROR_UNKNOWN_PRODUCT == Status )
            {
                //
                // If we didn't find the product, treat this as a successful removal
                // since the desired state, absence of the app, is achieved.
                //
                Status = ERROR_SUCCESS;
            }

            ReportInstallStatus(
                pInstallContext,
                Status,
                TRUE,
                UninstallApps.ApplicationInfo[UninstallCount].pwszDeploymentName,
                UninstallApps.ApplicationInfo[UninstallCount].pwszGPOName,
                UninstallApps.ApplicationInfo[UninstallCount].pwszDeploymentId);
        }

        // Nothing to do here for an orphaned app.

        if ( ERROR_SUCCESS == Status )
            UninstallCount++;

        if ( Status != ERROR_SUCCESS )
            goto InstallApplicationRollback;
    }

    Status = InstallManageApp( pInstallContext, InstallInfo.pwszDeploymentId, ERROR_SUCCESS, &bInstall );

    if ( Status != ERROR_SUCCESS )
        goto InstallApplicationRollback;

    if ( InstallInfo.Flags & APPINFOFLAG_FULLUI )
        InstallUILevel = INSTALLUILEVEL_FULL;
    else // InstallInfo.Flags & APPINFOFLAG_BASICUI
        InstallUILevel = INSTALLUILEVEL_BASIC;

    if ( (APPNAME == pInstallData->Type) && (InstallInfo.Flags & APPINFOFLAG_BASICUI) )
        InstallUILevel |= INSTALLUILEVEL_ENDDIALOG;

    (void) (*gpfnMsiSetInternalUI)( (INSTALLUILEVEL) InstallUILevel, NULL );

    if ( InstallInfo.pwszDescriptor )
    {
        DebugMsg((DM_VERBOSE, IDS_INSTALL_DESC, InstallInfo.pwszDeploymentName, InstallInfo.pwszGPOName));
        Status = (*gpfnMsiProvideComponentFromDescriptor)( InstallInfo.pwszDescriptor, NULL, NULL, NULL );
        REMAP_DARWIN_STATUS( Status );

        ReportInstallStatus(
            pInstallContext,
            Status,
            FALSE,
            InstallInfo.pwszDeploymentName,
            InstallInfo.pwszGPOName,
            InstallInfo.pwszDeploymentId);
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_INSTALL_PC, InstallInfo.pwszDeploymentName, InstallInfo.pwszGPOName));
        Status = (*gpfnMsiConfigureProductEx)( InstallInfo.pwszProductCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_DEFAULT, NULL );
        REMAP_DARWIN_STATUS( Status );

        ReportInstallStatus(
            pInstallContext,
            Status,
            FALSE,
            InstallInfo.pwszDeploymentName,
            InstallInfo.pwszGPOName,
            InstallInfo.pwszDeploymentId);
    }

    (void) (*gpfnMsiSetInternalUI)( OldUILevel, NULL );

    //
    // If the added app was already managed, any error must be ignored, we don't want to
    // unmanage it in this case.  Darwin rollback & repair should handle these cases.
    //
    if ( (Status != ERROR_SUCCESS) && (InstallInfo.Flags & APPINFOFLAG_ALREADYMANAGED) )
        goto InstallApplicationExit;

    if ( ERROR_SUCCESS == Status )
    {
        //
        // Now we can finally unmanage any upgraded apps.
        // If these fail, it will be fixed up in a subsequent run of policy.
        //
        for ( n = 0; n < UninstallCount; n++ )
            ExtraStatus = InstallUnmanageApp( pInstallContext, UninstallApps.ApplicationInfo[n].pwszDeploymentId, FALSE );

        goto InstallApplicationExit;
    }

    //
    // Failed to install the new app, unmanage it and fall through to our rollback.
    //

    ExtraStatus = InstallUnmanageApp( pInstallContext, InstallInfo.pwszDeploymentId, FALSE );

InstallApplicationRollback:

    for ( n = 0; n < UninstallCount; n++ )
    {
        bInstall = FALSE;
        ExtraStatus = InstallManageApp( pInstallContext, UninstallApps.ApplicationInfo[n].pwszDeploymentId, Status, &bInstall );
        if ( (ERROR_SUCCESS == ExtraStatus) && bInstall )
        {
            (void) (*gpfnMsiConfigureProductEx)( UninstallApps.ApplicationInfo[n].pwszProductCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_DEFAULT, NULL );
            gpEvents->Install( Status, UninstallApps.ApplicationInfo[n].pwszDeploymentName, UninstallApps.ApplicationInfo[n].pwszGPOName );
        }
    }

InstallApplicationExit:

    if ( pInstallContext )
        InstallEnd( (Status == ERROR_SUCCESS), &pInstallContext );

    FreeApplicationInfo( &InstallInfo );

    while ( UninstallApps.Products )
        FreeApplicationInfo( &UninstallApps.ApplicationInfo[--UninstallApps.Products] );
    LocalFree( UninstallApps.ApplicationInfo );

    return Status;
}

DWORD WINAPI
UninstallApplication(
    IN  WCHAR *     ProductCode,
    IN  DWORD       dwStatus
    )
{
    DWORD   Status;

    Status = Bind();

    if ( Status != ERROR_SUCCESS )
        return Status;

    return ARPRemoveApp( ghRpc, ProductCode, dwStatus );
}

DWORD WINAPI
CommandLineFromMsiDescriptor(
    IN  WCHAR *     Descriptor,
    OUT WCHAR *     CommandLine,
    IN OUT DWORD *  CommandLineLength
    )
{
    INSTALLUILEVEL  NewUILevel;
    INSTALLUILEVEL  OldUILevel;
    HKEY    hkAppmgmt;
    WCHAR   ProductCode[40];
    DWORD   Size;
    DWORD   ArgStart;
    DWORD   Status;

    Status = ERROR_SUCCESS;

    //
    // For this api we can not affort to dynamically load/unload msi each time, it 
    // is just called too frequently.
    // We'll store the load object in a global rather then a static in case we 
    // add support for a call-in mechanism to free this.
    //
    if ( ! gLoadMsi )
        gLoadMsi = new CLoadMsi( Status );

    if ( gLoadMsi && (Status != ERROR_SUCCESS) )
    {
        delete gLoadMsi;
        gLoadMsi = 0;
    }

    if ( Status != ERROR_SUCCESS )
        return Status;

    if ( ! LoadUser32Funcs() )
        return ERROR_OUTOFMEMORY;

    //
    // We get the process window station in order to detect processes running
    // in non-interactive desktops where Darwin UI is not possible.  Darwin
    // itself is not aware of these situations.
    //
    if ( ! gpwszWinsta )
    {
        HWINSTA hWinsta;
        BOOL    bStatus;

        hWinsta = (*pfnGetProcessWindowStation)();

        if ( hWinsta )
        {
            Size = 0;
            (void) (*pfnGetUserObjectInformationW)( hWinsta, UOI_NAME, NULL, 0, &Size );

            gpwszWinsta = new WCHAR[Size/2];
            if ( gpwszWinsta )
            {
                bStatus = (*pfnGetUserObjectInformationW)( hWinsta, UOI_NAME, gpwszWinsta, Size, &Size );
                if ( ! bStatus )
                {
                    Status = GetLastError();
                    delete [] gpwszWinsta;
                    gpwszWinsta = 0;
                }
            }
            else
                Status = ERROR_OUTOFMEMORY;

            (*pfnCloseWindowStation)( hWinsta );
        }

        //
        // Since this code was added very late (just before nt5 rc3) we don't
        // treat an error in getting the window station handle as a failure in
        // this API.  Too many unknowns with the security configuration of
        // services.  We'll treat this case as a non-winsta0 process.
        //
    }

    if ( Status != ERROR_SUCCESS )
        return Status;

    //
    // If we can't grab the winsta handle or can confirm that this is a
    // non-winsta0 process, we fix the ui level to none.
    //
    if ( (0 == gpwszWinsta) || (lstrcmp( L"WinSta0", gpwszWinsta ) != 0) )
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NONE, NULL );

    OldUILevel = (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NOCHANGE, NULL );

    //
    // Some processes, like the dcom service, may not be able to handle UI
    // of any kind.  So if the UI level is currently set to none we never
    // change it.
    //
    if ( OldUILevel != INSTALLUILEVEL_NONE )
    {
        Status = (*gpfnMsiDecomposeDescriptor)(
                        Descriptor,
                        ProductCode,
                        NULL,
                        NULL,
                        NULL );

        if ( Status != ERROR_SUCCESS )
            return Status;

        Status = RegOpenKeyEx(
                        HKEY_CURRENT_USER,
                        APPMGMTKEY,
                        0,
                        KEY_READ,
                        &hkAppmgmt );

        if ( ERROR_SUCCESS == Status )
        {
            Size = sizeof( NewUILevel );

            Status = RegQueryValueEx(
                             hkAppmgmt,
                             ProductCode,
                             NULL,
                             NULL,
                             (PBYTE) &NewUILevel,
                             &Size );

            RegCloseKey( hkAppmgmt );
        }

        if ( ERROR_SUCCESS == Status )
            (*gpfnMsiSetInternalUI)( NewUILevel, NULL );
    }

    //
    // Returns a quoted exe path with appended args.  The forth parameter
    // is obsolete and returns no usefull value.
    //
    Status = (*gpfnMsiProvideComponentFromDescriptor)(
                    Descriptor,
                    CommandLine,
                    CommandLineLength,
                    &ArgStart );

    REMAP_DARWIN_STATUS( Status );

    if ( Status != ERROR_SUCCESS )
        DebugMsg((DM_VERBOSE, IDS_DESC_FAIL, Descriptor, Status));

    (*gpfnMsiSetInternalUI)( OldUILevel, NULL );

    return Status;
}

DWORD WINAPI
GetLocalManagedApplications(
    IN  BOOL                        bUserApps,
    OUT LPDWORD                     pdwApps,
    OUT PLOCALMANAGEDAPPLICATION *  prgLocalApps
    )

{
    PLOCALMANAGEDAPPLICATION    pLocalApps;
    HKEY    hkRoot;
    HKEY    hkAppmgmt;
    HKEY    hkApp;
    WCHAR   wszDeploymentId[44];
    DWORD   Size;
    DWORD   Index;
    DWORD   Apps;
    DWORD   Status;

    *pdwApps = 0;
    *prgLocalApps = 0;

    Status = ERROR_SUCCESS;

    if ( bUserApps )
        Status = RegOpenCurrentUser( KEY_READ, &hkRoot );
    else
        hkRoot = HKEY_LOCAL_MACHINE;

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = RegOpenKeyEx(
                hkRoot,
                APPMGMTKEY,
                0,
                KEY_READ,
                &hkAppmgmt );

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = RegQueryInfoKey (
                hkAppmgmt,
                NULL,
                NULL,
                NULL,
                &Apps,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL );

    if ( ERROR_SUCCESS == Status )
    {
        pLocalApps = (PLOCALMANAGEDAPPLICATION) LocalAlloc( LMEM_ZEROINIT, Apps * sizeof(LOCALMANAGEDAPPLICATION) );
        if ( ! pLocalApps )
            Status = ERROR_OUTOFMEMORY;
    }

    if ( Status != ERROR_SUCCESS )
    {
        RegCloseKey( hkAppmgmt );
        if ( bUserApps )
            RegCloseKey( hkRoot );
        return ERROR_SUCCESS;
    }

    for ( Index = 0; Index < Apps; Index++ )
    {
        Status = RegEnumKey(
                    hkAppmgmt,
                    Index,
                    wszDeploymentId,
                    sizeof(wszDeploymentId) / sizeof(WCHAR) );

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegOpenKeyEx(
                        hkAppmgmt,
                        wszDeploymentId,
                        0,
                        KEY_READ,
                        &hkApp );
        }

        if ( Status != ERROR_SUCCESS )
            break;

        Size = sizeof(DWORD);

        Status = RegQueryValueEx(
                    hkApp,
                    APPSTATEVALUE,
                    0,
                    NULL,
                    (LPBYTE) &pLocalApps[Index].dwState,
                    &Size );

        if ( ERROR_SUCCESS == Status )
            Status = ReadStringValue( hkApp, DEPLOYMENTNAMEVALUE, &pLocalApps[Index].pszDeploymentName );

        if ( ERROR_SUCCESS == Status )
            Status = ReadStringValue( hkApp, GPONAMEVALUE, &pLocalApps[Index].pszPolicyName );

        if ( ERROR_SUCCESS == Status )
            Status = ReadStringValue( hkApp, PRODUCTIDVALUE, &pLocalApps[Index].pszProductId );

        RegCloseKey( hkApp );

        if ( Status != ERROR_SUCCESS )
            break;
    }

    if ( Status != ERROR_SUCCESS )
    {
        for ( Index = 0; Index < Apps; Index++ )
        {
            LocalFree( pLocalApps[Index].pszDeploymentName );
            LocalFree( pLocalApps[Index].pszPolicyName );
            LocalFree( pLocalApps[Index].pszProductId );
        }
        LocalFree( pLocalApps );
    }
    else
    {
        *prgLocalApps = pLocalApps;
        *pdwApps = Apps;
    }

    RegCloseKey( hkAppmgmt );
    if ( bUserApps )
        RegCloseKey( hkRoot );

    return Status;
}

void WINAPI
GetLocalManagedApplicationData(
    WCHAR *             ProductCode,
    LPWSTR *            DisplayName,
    LPWSTR *            SupportUrl
    )
{
    HKEY    hkRoot;
    HKEY    hkAppmgmt;
    HKEY    hkApp;
    WCHAR   wszDeploymentId[44]; 
    WCHAR   wszProductId[40];
    DWORD   Index;
    DWORD   Size;
    DWORD   Status;
    BOOL    bUser;

    *DisplayName = 0;
    *SupportUrl = 0;

    for ( int i = 0; i < 2; i++ )
    {
        Status = ERROR_SUCCESS;
        bUser = (0 == i);

        if ( bUser )
            Status = RegOpenCurrentUser( KEY_READ, &hkRoot );
        else
            hkRoot = HKEY_LOCAL_MACHINE;
    
        if ( Status != ERROR_SUCCESS )
            break;

        hkAppmgmt = 0;
    
        Status = RegOpenKeyEx(
                    hkRoot,
                    APPMGMTKEY,
                    0,
                    KEY_READ,
                    &hkAppmgmt );
    
        if ( bUser )
            RegCloseKey( hkRoot );

        if ( ERROR_SUCCESS == Status )
        {
            DWORD InstallUI;

            Size = sizeof(InstallUI);

            // This is the hint that we will use to determine if this product is managed.
            Status = RegQueryValueEx(
                        hkAppmgmt,
                        ProductCode,
                        NULL,
                        NULL,
                        (LPBYTE) &InstallUI,
                        &Size );
        }

        if ( Status != ERROR_SUCCESS )
        {
            if ( hkAppmgmt )
                RegCloseKey( hkAppmgmt );
            continue;
        }

        for ( Index = 0 ;; Index++ )
        {
            Status = RegEnumKey(
                        hkAppmgmt,
                        Index,
                        wszDeploymentId,
                        sizeof(wszDeploymentId) / sizeof(WCHAR) );
    
            if ( ERROR_SUCCESS == Status )
            {
                Status = RegOpenKeyEx(
                            hkAppmgmt,
                            wszDeploymentId,
                            0,
                            KEY_READ,
                            &hkApp );
            }

            if ( Status != ERROR_SUCCESS )
                break;
    
            Size = sizeof(wszProductId);
            wszProductId[0] = 0;
            (void) RegQueryValueEx( hkApp, PRODUCTIDVALUE, NULL, NULL, (LPBYTE) wszProductId, &Size );
    
            if ( lstrcmpi( ProductCode, wszProductId ) != 0 )
            {
                RegCloseKey( hkApp );
                continue;
            }
    
            (void) ReadStringValue( hkApp, DEPLOYMENTNAMEVALUE, DisplayName );
            (void) ReadStringValue( hkApp, SUPPORTURL, SupportUrl );

            RegCloseKey( hkApp );
            break;
        }
    
        RegCloseKey( hkAppmgmt );

        if ( *DisplayName || *SupportUrl )
            break;
    }
}

DWORD WINAPI
GetManagedApplications(
    IN  GUID*                pCategory,
    IN  DWORD                dwQueryFlags,
    IN  DWORD                dwInfoLevel,
    OUT LPDWORD              pdwApps,
    OUT PMANAGEDAPPLICATION* prgManagedApps)
{
    LONG             Status;
    MANAGED_APPLIST  AppList;

    //
    // Initialize the out parameters
    //
    if (pdwApps) {
        *pdwApps = NULL;
    }

    if (prgManagedApps) {
        *prgManagedApps = NULL;
    }

    //
    // Validate caller parameters that aren't passed to the
    // rpc interface -- other parameters will be validated
    // by the server
    //
    if (!pdwApps || !prgManagedApps) {
        return ERROR_INVALID_PARAMETER;
    }

    Status = Bind();

    if ( Status != ERROR_SUCCESS )
        return Status;

    //
    // Initialize our stack variables
    //
    memset(&AppList, 0, sizeof(AppList));

    //
    // Call the method on the server.
    //
    Status = GetManagedApps( ghRpc, pCategory, dwQueryFlags, dwInfoLevel, &AppList);

    //
    // On success, set the caller's out parameters to refer
    // to the results returned by the server
    //
    if ( ERROR_SUCCESS == Status)
    {
        *pdwApps = AppList.Applications;
        *prgManagedApps = (PMANAGEDAPPLICATION) AppList.rgApps;
    }

    return Status;
}

static DWORD
ReportInstallStatus(
    PINSTALLCONTEXT pInstallContext,
    DWORD           InstallStatus,
    BOOL            bUninstall,
    WCHAR *         pwszDeploymentName,
    WCHAR *         pwszGPOName,
    WCHAR *         pwszDeploymentId
    )
{
    DWORD Status;
    DWORD dwEventId;

    Status = ERROR_SUCCESS;

    //
    // First, report the correct event based on whether
    // this is an install or an uninstall
    //
    if ( ! bUninstall )
    {
        gpEvents->Install(
            InstallStatus,
            pwszDeploymentName,
            pwszGPOName
            );    

        ( ERROR_SUCCESS == InstallStatus ) ? 
            ( dwEventId = EVENT_APPMGMT_INSTALL ) : ( dwEventId = EVENT_APPMGMT_INSTALL_FAILED );
    }
    else
    {
        gpEvents->Uninstall(
            InstallStatus,
            pwszDeploymentName,
            pwszGPOName
            );    

        ( ERROR_SUCCESS == InstallStatus ) ? 
            ( dwEventId = EVENT_APPMGMT_UNINSTALL ) : ( dwEventId = EVENT_APPMGMT_UNINSTALL_FAILED );
    }

    //
    // If there was an error, log a failure status
    //
    if ( ERROR_SUCCESS != InstallStatus )
    {
        Status = RsopReportInstallFailure(
            pInstallContext,
            pwszDeploymentId,
            dwEventId);
    }

    return Status;
}


DWORD WINAPI
GetManagedApplicationCategories(
    DWORD                dwReserved,
    APPCATEGORYINFOLIST* pAppCategory
    )
{
    DWORD           Status;
    APPCATEGORYLIST CategoryList;
    
    if ( ( 0 != dwReserved ) ||
         ! pAppCategory )
    {
        return ERROR_INVALID_PARAMETER;
    }

    memset( &CategoryList, 0, sizeof( CategoryList ) );

    Status = Bind();

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = GetManagedAppCategories(
        ghRpc,
        &CategoryList);

    *pAppCategory = *( ( APPCATEGORYINFOLIST* ) &CategoryList );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\common\cres.h ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Resource.h
//
//  Header file for app.rc
//
//*************************************************************

// Client defs
#define IDS_CLIENT_UNINSTALL    2000
#define IDS_INSTALL_PC          2001
#define IDS_INSTALL_DESC        2002
#define IDS_DESC_FAIL           2003
#define IDS_LEGACY_INSTALL      2004
#define IDS_INSTALL_REQUEST     2005

// Server defs
#define IDS_STRING              3000
#define IDS_USER                3001
#define IDS_MACHINE             3002
#define IDS_ADDASSIGNED         3003
#define IDS_ADDPUBLISHED        3004
#define IDS_GPO_NAME            3005
#define IDS_GPO_FILESYSPATH     3006
#define IDS_GPO_DSPATH          3007
#define IDS_ADDORPHANED         3008
#define IDS_INSTALLED           3009
#define IDS_REMOVE_POLICY       3010
#define IDS_PROCESSGPT_RETURN   3011
#define IDS_NOIMPERSONATE       3012
#define IDS_NUMAPPS             3013
#define IDS_ADDUNINSTALLED      3014
#define IDS_UNKNOWN             3015
#define IDS_USERAPPS_NOCAT      3016
#define IDS_CSENUMAPPS_FAIL     3017
#define IDS_ASSIGN              3018
#define IDS_GETLOCALAPPS_FAIL   3019
#define IDS_CREATEDIR_FAIL      3020
#define IDS_NOCHANGES           3021
#define IDS_GET_LOCAL_APPS      3022
#define IDS_CHECK_APP_FOUND     3023
#define IDS_CSPATH              3024
#define IDS_NOCSPATH            3025
#define IDS_LOCALASSIGN_APP     3026
#define IDS_LOCALPUBLISHED_APP  3027
#define IDS_ADDUNKNOWN          3028
#define IDS_CHECK_APP_NOTFOUND  3029
#define IDS_UNINSTALL_ACTION1   3030
#define IDS_INSTALL_ACTION1     3031
#define IDS_ASSIGN1_ACTION      3032
#define IDS_NO_LOCAL_APPS       3033
#define IDS_ASSIGN3_ACTION      3034
#define IDS_ASSIGN4_ACTION      3035
#define IDS_SCRIPT_COPY_FAIL    3036
#define IDS_ADVERTISE           3037
#define IDS_ADVERTISE_FAIL      3038
#define IDS_INSTALL             3039
#define IDS_UNMANAGE_ORPHAN     3040
#define IDS_UNDO4_ACTION        3041
#define IDS_LOCAL_APP_COUNT     3042
#define IDS_UNINSTALL           3043
#define IDS_UNMANAGE_UNINSTALL  3044
#define IDS_UNADVERTISE         3045
#define IDS_UNADVERTISE_FAIL    3046
#define IDS_UNMANAGE            3047
#define IDS_INSTALL_STATUS2     3048
#define IDS_MACHINEAPPS         3049
#define IDS_INSTALL_APPNAME     3050
#define IDS_INSTALL_FILEEXT     3051
#define IDS_INSTALL_PROGID      3052
#define IDS_INSTALL_COMCLASS    3053
#define IDS_GETAPPINFO_FAIL     3054
#define IDS_INSTALL_STATUS1     3055
#define IDS_APPINFO_FAIL        3056
#define IDS_LOCALAPPINFO_FAIL   3057
#define IDS_LOCALAPP_COUNT      3058
#define IDS_REMOVEAPP           3059
#define IDS_REMOVEAPP_STATUS    3060
#define IDS_REMOVEAPP_MATCH1    3061
#define IDS_REMOVEAPP_MATCH2    3062
#define IDS_UNDO5_ACTION        3063
#define IDS_ORPHAN_ACTION1      3064
#define IDS_NO_CLASSSTORE       3065
#define IDS_UNDO1_ACTION        3066
#define IDS_UNDO2_ACTION        3067
#define IDS_IGNORE_REMOVE       3068
#define IDS_LOCAL_APP_DUMP      3069
#define IDS_INSTALL_ACTION2     3070
#define IDS_USERAPPS_CAT        3071
#define IDS_INSTALL_DARWIN      3072
#define IDS_INSTALL_SETUP       3073
#define IDS_INSTALL_UNKNOWN     3074
#define IDS_GPOAPPS             3075
#define IDS_ORPHAN_ACTION3      3076
#define IDS_UNINSTALL_ACTION2   3077
#define IDS_NONE_ACTION1        3078
#define IDS_ENFORCE_SECURE_FAIL 3079
#define IDS_REINSTALL_ACTION1   3080
#define IDS_REINSTALL           3081
#define IDS_INSTALL_TRANSFORM   3082
#define IDS_POLICY_REMOVED      3083
#define IDS_POLICY_APPLY        3084
#define IDS_CHECK_APP           3085
#define IDS_CHECK_APP_FAIL      3086
#define IDS_ORPHAN_ACTION4      3087
#define IDS_NONE_ACTION2        3088
#define IDS_UPGRADE_INFO        3089
#define IDS_UNDO6_ACTION        3090
#define IDS_UPGRADE_REVERSE     3091
#define IDS_LOCALORPHAN_APP     3092
#define IDS_LOCALUNINSTALL_APP  3093
#define IDS_DEMAND_BLOCK1       3094
#define IDS_DEMAND_BLOCK2       3095
#define IDS_PROGID_FOUND        3096
#define IDS_CLSID_INPROC_FOUND  3097
#define IDS_CLSID_LOCAL_FOUND   3098
#define IDS_ENFORCE_SECURE_ON   3099
#define IDS_REINSTALL_ACTION2   3100
#define IDS_UNDO3_ACTION        3101
#define IDS_ERRORREASON_CSPATH  3102
#define IDS_ERRORREASON_ENUM    3103
#define IDS_ERRORREASON_LOCAL   3104
#define IDS_ERRORREASON_PROCESS 3105
#define IDS_RSOP_LOG_INIT_FAIL  3106
#define IDS_RSOP_LOG_WRITE_FAIL 3108
#define IDS_RSOP_LOG_WRITE_INFO 3109
#define IDS_RSOP_LOG_CLEAR_FAIL 3110
#define IDS_RSOP_CAT_INFO       3111
#define IDS_RSOP_CAT_WRITE_FAIL 3112
#define IDS_RSOP_SETVAL_FAIL    3113
#define IDS_RSOP_CONFLICTS_FAIL 3114
#define IDS_RSOP_SUPERSEDED     3115
#define IDS_UNMATCHED_SCRIPT    3116
#define IDS_SCRIPTINRSOP        3117
#define IDS_SCRIPTNOTINRSOP1    3118
#define IDS_SCRIPTNOTINRSOP2    3119
#define IDS_SCRIPTAPP_INDS      3120
#define IDS_SCRIPTAPP_NODS      3121
#define IDS_SCRIPTAPP_ERRORDS   3122
#define IDS_DETECTED_LOST_APPS  3123
#define IDS_SCRIPTAPP_INDS2     3124
#define IDS_CSTORE_DELETESCRIPT 3200
#define IDS_CSTORE_CLEANSCRIPTS 3201
#define IDS_CSTORE_DELPACKAGE   3202
#define IDS_CSTORE_CSCACHEPURGE 3203
#define IDS_CSTORE_CSCACHE_HIT  3204
#define IDS_CSTORE_BIND_FAIL    3205
#define IDS_CSTORE_PKG_DETAILS  3206
#define IDS_CSTORE_ENUMPACKAGE  3207
#define IDS_CSTORE_BESTFIT      3208
#define IDS_CSTORE_BESTFITSKIP  3209
#define IDS_CSTORE_BESTFIT_END  3210
#define IDS_CSTORE_CLASS_PURGE  3211
#define IDS_CSTORE_CLASS_HIT    3212
#define IDS_CSTORE_MERGEAPPINFO 3213
#define IDS_CSTORE_ONDEMAND     3214
#define IDS_CSTORE_APPINFO_END  3215
#define IDS_CSTORE_BIND         3216
#define IDS_CSTORE_BIND_STATUS  3217
#define IDS_CSTORE_CLASSSPEC    3218
#define IDS_CSTORE_MISSING_ATTR 3219
#define IDS_CSTORE_SKIP_FLAG    3220
#define IDS_CSTORE_SKIP_FILTER  3221
#define IDS_CSTORE_SKIP_INCLUDE 3222
#define IDS_CSTORE_MACHINE      3223
#define IDS_CSTORE_IMPERSONATED 3224
#define IDS_CSTORE_USER         3225
#define IDS_CSTORE_STORE_COUNT  3226
#define IDS_CSTORE_ROLLBACK_ADD 3227
#define IDS_CSTORE_EXAMINING    3228
#define IDS_CSTORE_SKIP_LANG    3229
#define IDS_CSTORE_SKIP_ARCH    3230 
#define IDS_CSTORE_SKIP_CLSID   3231
#define IDS_CSTORE_SKIP_FILE    3232
#define IDS_CSTORE_SKIP_MSI     3233
#define IDS_CSTORE_RSOPERROR    3234
#define IDS_CSTORE_REMAP_ERR    3235
#define IDS_CSTORE_BETA3_ERR    3236
#define IDS_CSTORE_CACHE_EXPIRE 3237
#define IDS_ABORT_SCOPELOSS     3238
#define IDS_ASSIGN5_ACTION      3239
#define IDS_ASYNC_REFRESH       3240
#define IDS_BACKGROUND_REFRESH  3241
#define IDS_ABORT_OPERATION     3242
#define IDS_SYNC_REFRESH        3243
#define IDS_CHANGES_DETECTED    3244
#define IDS_CHANGES_RSOP_CHANGE 3245
#define IDS_REINSTALL_ACTION3   3246
#define IDS_ERRORREASON_ASYNC_USER       3247
#define IDS_ERRORREASON_ASYNC_MACHINE    3248
#define IDS_ASSIGNED_NOUNINSTALL_ROAM    3249
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\common\list.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  list.cxx
//
//*************************************************************

#include "common.hxx"

//
// CListItem
//

void
CListItem::Remove()
{
    _pPrev->_pNext = _pNext;
    _pNext->_pPrev = _pPrev;
}

void
CListItem::InsertBefore(
    IN  CListItem * pItem
    )
{
    pItem->_pPrev = _pPrev;
    pItem->_pNext = this;
    _pPrev->_pNext = pItem;
    _pPrev = pItem;
}

//
// CList
//

CList::CList() :
    _pCurrent(NULL),
    _pCurrentSave(NULL)
{
    _Head._pNext = &_Head;
    _Head._pPrev = &_Head;
}

//
// CList::InsertLIFO()
//
// Inserts the given item at the front of the list.  Last in first out semantics.
//
void
CList::InsertLIFO(
    IN  CListItem * pItem
    )
{
    pItem->_pNext = _Head._pNext;
    pItem->_pPrev = &_Head;
    _Head._pNext->_pPrev = pItem;
    _Head._pNext = pItem;
}

//
// CList::InsertFIFO()
//
// Inserts the given item at the end of the list.  First in first out semantics.
//
void
CList::InsertFIFO(
    IN  CListItem * pItem
    )
{
    pItem->_pNext = &_Head;
    pItem->_pPrev = _Head._pPrev;
    _Head._pPrev->_pNext = pItem;
    _Head._pPrev = pItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\common\cs_guids.c ===
#include <cs_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\common\evt.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  events.cxx
//
//*************************************************************

#include "common.hxx"

CEvents * gpEvents = 0;

CEventsBase::CEventsBase()
{
    _hUserToken = 0;
}

void
CEventsBase::Report(
    DWORD       EventID,
    BOOL        bDowngradeErrors,
    WORD        Strings,
    ...
    )
{
    va_list     VAList;
    WCHAR *     ppwszStrings[10];
    WORD        Type;
    DWORD       DbgMsgLevel;

    if ( Strings > 10 )
        return;

    switch ( EventID / 100 )
    {
    case 1:
        Type = EVENTLOG_ERROR_TYPE;
        DbgMsgLevel = DM_WARNING;
        break;
    case 2:
        Type = EVENTLOG_WARNING_TYPE;
        DbgMsgLevel = DM_WARNING;
        break;
    case 3:
        Type = EVENTLOG_INFORMATION_TYPE;
        DbgMsgLevel = DM_VERBOSE;
        break;
    case 4:
        Type = EVENTLOG_INFORMATION_TYPE;
        DbgMsgLevel = DM_VERBOSE;
        break;
    default:
        return;
    }

    if ( bDowngradeErrors && ( EVENTLOG_ERROR_TYPE == Type ) )
    {
        Type = EVENTLOG_WARNING_TYPE;
        DbgMsgLevel = DM_WARNING;
    }

    if ( Strings > 0 )
    {
        va_start( VAList, Strings );
        for ( DWORD n = 0; n < Strings; n++ )
            ppwszStrings[n] = va_arg( VAList, WCHAR * );
        va_end( VAList );
    }

    if ( (EventID < 400) ||
         (gDebugLevel & (DL_VERBOSE | DL_EVENTLOG)) )
    {
        HANDLE  hEventLog;
        PSID    pSid;

        hEventLog = OpenEventLog( NULL, APPMGMT_EVENT_SOURCE );

        if ( ! hEventLog )
            return;

        pSid = AppmgmtGetUserSid( _hUserToken );

        (void) ReportEvent(
                        hEventLog,
                        Type,
                        0,
                        EventID,
                        pSid,
                        Strings,
                        0,
                        (LPCWCH *) ppwszStrings,
                        NULL );

        LocalFree( pSid );
        CloseEventLog( hEventLog );
    }

    //
    // Also make sure the event messages get sent to the debugger and log file.
    // Kind of hacky method, but makes it so every caller to ::Report doesn't
    // have to call _DebugMsg as well.
    // However, don't do this for the verbose messages otherwise it will be
    // dumped to the debugger twice.
    //
    if ( EVENT_APPMGMT_VERBOSE == EventID )
        return;

    switch ( Strings )
    {
    case 0 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID );
        break;
    case 1 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0] );
        break;
    case 2 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1] );
        break;
    case 3 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2] );
        break;
    case 4 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2], ppwszStrings[3] );
        break;
    case 5 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2], ppwszStrings[3], ppwszStrings[4] );
        break;
    default :
        VerboseDebugDump( L"CEvents::Report called with more params then expected!\n" );
        break;
    }
}

void
CEventsBase::Install(
    DWORD       ErrorStatus,
    WCHAR *     pwszDeploymentName,
    WCHAR *     pwszGPOName
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_INSTALL_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pwszDeploymentName,
            pwszGPOName,
            wszStatus );
    }
    else
    {
        Report(
            EVENT_APPMGMT_INSTALL,
            FALSE,
            2,
            pwszDeploymentName,
            pwszGPOName );
    }
}

void
CEventsBase::Uninstall(
    DWORD       ErrorStatus,
    WCHAR *     pwszDeploymentName,
    WCHAR *     pwszGPOName
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_UNINSTALL_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pwszDeploymentName,
            pwszGPOName,
            wszStatus );
    }
    else
    {
        Report(
            EVENT_APPMGMT_UNINSTALL,
            FALSE,
            2,
            pwszDeploymentName,
            pwszGPOName );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\common\dbg.cxx ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "common.hxx"

HINSTANCE ghDllInstance = 0;

//
// Global Variable containing the debugging level.  The debug level can be
// modified by both the debug init routine and the event logging init
// routine.  Debugging can be enabled even on retail systems through
// registry settings.
//

DWORD   gDebugLevel = DL_NONE;
DWORD   gDebugBreak = 0;

LOADSTRINGW *   pfnLoadStringW = 0;

//
// Debug strings
//

const WCHAR cwszAppMgmt[] = L"APPMGMT (%x.%x) %02d:%02d:%02d:%03d ";
const WCHAR cwszLogTime[] = L"%02d-%02d %02d:%02d:%02d:%03d ";
const WCHAR cwszLogfile[] = L"%SystemRoot%\\Debug\\UserMode\\appmgmt.log";
const WCHAR cwszOldLogfile[] = L"%SystemRoot%\\Debug\\UserMode\\appmgmt.bak";
const WCHAR cwszCRLF[] = L"\r\n";
const char cszCRLF[] = "\r\n";

//*************************************************************
//
//  InitDebugSupport()
//
//  Sets the debugging level.
//  Also checks the registry for a debugging level.
//
//*************************************************************
void InitDebugSupport( DWORD DebugMode )
{
    HKEY    hKey;
    DWORD   Size;
    DWORD   Type;
    BOOL    bVerbose;
    DWORD   Status;
    BOOL    bStatus;

#if DBG
    gDebugLevel = DL_NORMAL;
#else
    gDebugLevel = DL_NONE;
#endif

    gDebugBreak = 0;

    Status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    DIAGNOSTICS_KEY,
                    0,
                    KEY_READ,
                    &hKey );

    bVerbose = FALSE;

    if ( ERROR_SUCCESS == Status )
    {
        Size = sizeof(bVerbose);
        Status = RegQueryValueEx(
                        hKey,
                        DIAGNOSTICS_POLICY_VALUE,
                        NULL,
                        &Type,
                        (LPBYTE) &bVerbose,
                        &Size );

        if ( (ERROR_SUCCESS == Status) && (Type != REG_DWORD) )
            bVerbose = FALSE;

        Size = sizeof(gDebugLevel);
        Status = RegQueryValueEx(
            hKey,
            DEBUG_KEY_NAME,
            NULL,
            NULL,
            (LPBYTE) &gDebugLevel,
            &Size );
        if (ERROR_SUCCESS != Status) 
        {
            RegCloseKey(hKey);
            return;
        }

        Size = sizeof(gDebugBreak);
        Status = RegQueryValueEx(
            hKey,
            DEBUGBREAK_KEY_NAME,
            NULL,
            NULL,
            (LPBYTE) &gDebugBreak,
            &Size );

        RegCloseKey(hKey);
        
        if (ERROR_SUCCESS != Status) 
        {
            return;
        }
    }

    if ( bVerbose )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;

    if ( gDebugLevel & DL_LOGFILE )
    {
        WCHAR                       wszLogFile[MAX_PATH];
        WCHAR                       wszOldLogFile[MAX_PATH];
        WIN32_FILE_ATTRIBUTE_DATA   FileData;
        BOOL                        bStatusLog;

        bStatusLog = GetDebugLogFileName( wszLogFile, sizeof( wszLogFile ) / sizeof( WCHAR ) );

        if ( ! bStatusLog )
        {
            return;
        }

        if ( DebugMode != DEBUGMODE_POLICY )
            return;

        bStatusLog = GetFileAttributesEx( wszLogFile, GetFileExInfoStandard, &FileData );
        if ( ! bStatusLog )
            return;

        //
        // If the existing log file is more than 50K then we will rename it to a backup
        // copy to prevent huge bloating, otherwise we continue to use it.
        //
        if ( FileData.nFileSizeLow < (50 * 1024) )
            return;

        Status = ExpandEnvironmentStrings( cwszOldLogfile, wszOldLogFile, sizeof(wszOldLogFile) / sizeof(WCHAR) );

        if ( (0 == Status) || (Status > ( sizeof(wszOldLogFile) / sizeof(WCHAR) )) )
            return;

        DeleteFile( wszOldLogFile );
        MoveFile( wszLogFile, wszOldLogFile );
    }
}

BOOL DebugLevelOn( DWORD mask )
{
    BOOL bOutput = FALSE;

    if ( gDebugLevel & DL_VERBOSE )
        bOutput = TRUE;
    else if ( gDebugLevel & DL_NORMAL )
        bOutput = ! (mask & DM_VERBOSE);
#if DBG
    else // DL_NONE
        bOutput = (mask & DM_ASSERT);
#endif

    return bOutput;
}

//*************************************************************
//
//  _DebugMsg()
//
//  Displays debug messages based on the debug level
//  and type of debug message.
//
//  Parameters :
//      mask    -   debug message type
//      MsgID   -   debug message id from resource file
//      ...     -   variable number of parameters
//
//*************************************************************
void _DebugMsg(DWORD mask, DWORD MsgID, ...)
{
    if ( ! DebugLevelOn( mask ) )
        return;

    BOOL bEventLogOK;
    WCHAR wszDebugTitle[64];
    WCHAR wszDebugBuffer[2048]; // Hopefully this will be big enough!
    WCHAR wszMsg[MAX_PATH];
    va_list VAList;
    SYSTEMTIME systime;

    bEventLogOK = ! (mask & DM_NO_EVENTLOG);

    if ( ! LoadLoadString() )
        return;

    va_start(VAList, MsgID);

    if ( ! ghDllInstance )
        ghDllInstance = LoadLibrary( L"appmgmts.dll" );

    //
    // Event log message ids are in the 100s to 400s, verbose strings are in the
    // 1000s to 3000s.  For event log messages we must call FormatMessage.  For
    // other verbose debug output, we use LoadString to get the string resource.
    //
    if ( MsgID >= 1000 )
    {
        if ( ! (*pfnLoadStringW)( ghDllInstance, MsgID, wszMsg, MAX_PATH) )
            return;
        (void) StringCchVPrintf(wszDebugBuffer, sizeof(wszDebugBuffer)/sizeof(wszDebugBuffer[0]), wszMsg, VAList);
    }
    else
    {
        DWORD   CharsWritten;

        CharsWritten = FormatMessage(
                    FORMAT_MESSAGE_FROM_HMODULE,
                    ghDllInstance,
                    MsgID,
                    0,
                    wszDebugBuffer,
                    sizeof(wszDebugBuffer) / sizeof(WCHAR),
                    &VAList );

        if ( 0 == CharsWritten )
            return;
    }

    va_end(VAList);

    GetLocalTime( &systime );
    (void) StringCchPrintf( wszDebugTitle,
                           sizeof(wszDebugTitle)/sizeof(wszDebugTitle[0]),
                           cwszAppMgmt,
                           GetCurrentProcessId(),
                           GetCurrentThreadId(),
                           systime.wHour,
                           systime.wMinute,
                           systime.wSecond,
                           systime.wMilliseconds);

    if ( ! (gDebugLevel & DL_NODBGOUT) )
    {
        OutputDebugString( wszDebugTitle );
        OutputDebugString( wszDebugBuffer );
        OutputDebugString( cwszCRLF );
    }

    if ( gDebugLevel & DL_LOGFILE )
    {
        WCHAR*  wszLogFile;
        HANDLE  hFile;

        wszLogFile = new WCHAR[ MAX_PATH ];

        if ( wszLogFile && GetDebugLogFileName( wszLogFile, MAX_PATH ) )
        {
            hFile = OpenUnicodeLogFile(wszLogFile);

            if ( hFile != INVALID_HANDLE_VALUE )
            {
                if ( SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF )
                {
                    DWORD   Size;

                    WriteFile(
                        hFile,
                        (LPCVOID) wszDebugBuffer,
                        lstrlen(wszDebugBuffer) * sizeof(WCHAR),
                        &Size,
                        NULL );
                    
                    WriteFile(
                        hFile,
                        (LPCVOID) cwszCRLF,
                        lstrlen(cwszCRLF) * sizeof(WCHAR),
                        &Size,
                        NULL );
                }
            }

            CloseHandle (hFile);
            
            delete [] wszLogFile;
        }

    }

    if ( bEventLogOK && (gDebugLevel & DL_EVENTLOG) )
        ((CEventsBase *)gpEvents)->Report( EVENT_APPMGMT_VERBOSE, FALSE, 1, wszDebugBuffer );

#if DBG
    if ( mask & DM_ASSERT )
        DebugBreak();
#endif
}

void LogTime()
{
    if ( ! (gDebugLevel & DL_LOGFILE) ) 
        return;

    WCHAR wszDebugBuffer[64];
    SYSTEMTIME systime;
    HANDLE hFile;
    WCHAR wszLogFile[MAX_PATH];
    BOOL  bStatus;

    bStatus = GetDebugLogFileName( wszLogFile, sizeof( wszLogFile ) / sizeof( WCHAR ) );

    if ( ! bStatus )
    {
        return;
    }

    GetLocalTime( &systime );
    (void) StringCchPrintf( wszDebugBuffer,
                           sizeof(wszDebugBuffer)/sizeof(wszDebugBuffer[0]),
                           cwszLogTime,
                           systime.wMonth,
                           systime.wDay,
                           systime.wHour,
                           systime.wMinute,
                           systime.wSecond,
                           systime.wMilliseconds);

    hFile = OpenUnicodeLogFile(wszLogFile);

    if ( INVALID_HANDLE_VALUE == hFile )
        return;

    if ( SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF )
    {
        DWORD   Size;

        WriteFile(
                hFile,
                (LPCVOID) wszDebugBuffer,
                lstrlen(wszDebugBuffer) * sizeof(WCHAR),
                &Size,
                NULL );

        WriteFile(
                hFile,
                (LPCVOID) cwszCRLF,
                lstrlen(cwszCRLF) * sizeof(WCHAR),
                &Size,
                NULL );
    }

    CloseHandle (hFile);
}

HANDLE
OpenUnicodeLogFile (LPCTSTR lpszFilePath)
{
    HANDLE hFile;
    DWORD  Status;
    DWORD  dwWritten;

    Status = ERROR_SUCCESS;

    hFile = CreateFile(
        lpszFilePath,
        FILE_WRITE_DATA | FILE_APPEND_DATA,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        Status = GetLastError();
    }

    if ( ERROR_FILE_NOT_FOUND == Status )
    {
        //
        // The file doesn't exist, so we'll try to create it
        // with the byte order marker
        //

        hFile = CreateFile(
            lpszFilePath,
            FILE_WRITE_DATA | FILE_APPEND_DATA,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if ( INVALID_HANDLE_VALUE != hFile )
        {
            BOOL bWritten;

            //
            // Add the unicode byte order marker to the beginning of the file
            // so that APIs know for sure that it is a unicode file.
            //

            bWritten = WriteFile(
                hFile,
                L"\xfeff\r\n",
                4 * sizeof(WCHAR),
                &dwWritten, 
                NULL);

            if ( ! bWritten )
            {
                CloseHandle( hFile );
            }
        }
    }

    return hFile;
}

BOOL
GetDebugLogFileName( WCHAR* wszLogFile, LONG cchLogFile )
{
    LONG Status;

    Status = ExpandEnvironmentStrings( cwszLogfile, wszLogFile, MAX_PATH );

    if ( (0 == Status) || (Status > cchLogFile) )
    {
        return FALSE;
    }

    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\cache.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:       cache.cxx
//
//  Contents:   Class Store Binding cache
//
//  Author:     AdamEd
//
//-------------------------------------------------------------------------

#include "cstore.hxx"


CBinding::CBinding(
    CServerContext* pServerContext,
    WCHAR*          wszClassStorePath,
    PSID            pSid,
    IClassAccess*   pClassAccess,
    HRESULT         hrBind,
    HRESULT*        phr) 
{
    ULONG ulSize;

    *phr = E_OUTOFMEMORY;
    Hr = hrBind;
    ulSize = lstrlen( wszClassStorePath ) + 1;

    szStorePath = (WCHAR*) CsMemAlloc(
        ulSize * sizeof( *wszClassStorePath ) );

    if ( szStorePath )
    {
        UINT dwBytesRequired;

        *phr = StringCchCopy( szStorePath, ulSize, wszClassStorePath );

        if ( SUCCEEDED( *phr ) && pServerContext )
        {
            *phr =ServerContext.Initialize( pServerContext );
        }

        if (SUCCEEDED(*phr)) 
        { 
            dwBytesRequired = GetLengthSid(pSid);

            Sid = (PSID) CsMemAlloc( dwBytesRequired );

            if ( Sid )
            { 
                BOOL bStatus;
            
                bStatus = CopySid(
                    dwBytesRequired,
                    Sid,
                    pSid);

                if ( ! bStatus )
                {
                    LONG Status;

                    Status = GetLastError();

                    *phr = HRESULT_FROM_WIN32( Status );
                }
                else
                {
                    *phr = S_OK;
                }
            }
        }
    }

    if ( SUCCEEDED( *phr ) && pClassAccess )
    {
        pIClassAccess = pClassAccess;
        pIClassAccess->AddRef();
    }
}

CBinding::~CBinding()
{
    if ( pIClassAccess )
    {
        pIClassAccess->Release();
    }

    CsMemFree( Sid );
    
    CsMemFree( szStorePath );
}


BOOL
CBinding::Compare( 
    CServerContext* pServerContext,
    WCHAR*          wszClassStorePath,
    PSID            pSid)
{
    LONG lCompare;
    BOOL bStatus;

    bStatus = FALSE;

    lCompare = lstrcmp(
        szStorePath,
        wszClassStorePath);

    if ( 0 == lCompare )
    {
        if ( ServerContext.Compare( pServerContext ) )
        {
            lCompare = 0;
        }
        else
        {
            lCompare = -1;
        }
    }

    if ( 0 == lCompare )
    {
        bStatus = EqualSid(
            Sid,
            pSid);
    }

    return bStatus;
}

BOOL CBinding::IsExpired( FILETIME* pftCurrentTime )
{
 
    SYSTEMTIME SystemTimeCurrent;
    SYSTEMTIME SystemTimeExpiration;
    BOOL       bRetrievedTime;

    bRetrievedTime = FileTimeToSystemTime(
        pftCurrentTime,
        &SystemTimeCurrent);

    bRetrievedTime &= FileTimeToSystemTime(
        &Time,
        &SystemTimeExpiration);

    if ( bRetrievedTime )
    {
        CSDBGPrint((
            DM_VERBOSE,
            IDS_CSTORE_CACHE_EXPIRE,
            L"Current Time",
            SystemTimeCurrent.wMonth,
            SystemTimeCurrent.wDay,
            SystemTimeCurrent.wYear,
            SystemTimeCurrent.wHour,
            SystemTimeCurrent.wMinute,
            SystemTimeCurrent.wSecond));

        CSDBGPrint((
            DM_VERBOSE,
            IDS_CSTORE_CACHE_EXPIRE,
            L"Expire Time",
            SystemTimeExpiration.wMonth,
            SystemTimeExpiration.wDay,
            SystemTimeExpiration.wYear,
            SystemTimeExpiration.wHour,
            SystemTimeExpiration.wMinute,
            SystemTimeExpiration.wSecond));
    }

    //
    // Compare the current time to the expiration time
    //
    LONG CompareResult;

    CompareResult = CompareFileTime(
        pftCurrentTime,
        &Time);
        
    //
    // If the current time is later than the expired time,
    // then we have expired
    //
    if ( CompareResult > 0 )
    {
        return TRUE;
    }

    return FALSE;
}


CBindingList::CBindingList() :
    _cBindings( 0 )
{
    memset( &_ListLock, 0, sizeof( _ListLock ) );

    //
    // InitializeCriticalSection has no return value --
    // in extremely low memory situations, it may
    // throw an exception
    //

    (void) InitializeCriticalSection( &_ListLock );
}


CBindingList::~CBindingList()
{
    CBinding* pBinding;

    for (
        Reset();
        pBinding = (CBinding*) GetCurrentItem();
        )
    {
        //
        // We must perform the MoveNext before the Delete
        // since it alters the list and will render its
        // current pointer invalid
        //
        MoveNext();

        Delete( pBinding );
    }

    //
    // Clean up the critical section allocated in the constructor
    //
    DeleteCriticalSection( &_ListLock );
}

void
CBindingList::Lock()
{
    EnterCriticalSection( &_ListLock );
}

void
CBindingList::Unlock()
{
    LeaveCriticalSection( &_ListLock );
}

CBinding*
CBindingList::Find(
    CServerContext* pServerContext,
    FILETIME*       pCurrentTime,
    WCHAR*          wszClassStorePath,
    PSID            pSid)
{
    CBinding* pCurrent;
    CBinding* pExpired;

    pCurrent = NULL;

    for ( Reset(); 
          pCurrent = (CBinding*) GetCurrentItem();
          MoveNext(), Delete( pExpired ) )
    {
        BOOL bFound;

        if ( pCurrent->IsExpired( pCurrentTime ) )
        {
            pExpired = pCurrent;
            continue;
        }

        pExpired = NULL;

        bFound = pCurrent->Compare(
            pServerContext,
            wszClassStorePath,
            pSid);

        if ( bFound )
        {
            CSDBGPrint((DM_WARNING, 
                        IDS_CSTORE_CSCACHE_HIT,
                        wszClassStorePath));

            return pCurrent;
        }
    }

    return NULL;
}


CBinding*
CBindingList::AddBinding( 
    FILETIME* pCurrentTime,
    CBinding* pBinding)
{
    CBinding* pExisting;

    pExisting = Find(
        &(pBinding->ServerContext),
        pCurrentTime,
        pBinding->szStorePath,
        pBinding->Sid);

    if ( pExisting )
    {
        delete pBinding;

        return pExisting;
    }

    if ( _cBindings >= MAXCLASSSTORES )
    {
        Reset();

        Delete( (CBinding*) GetCurrentItem() );
    }
    
    GetExpiredTime(
        pCurrentTime,
        &(pBinding->Time));

    InsertFIFO( pBinding );

    _cBindings++;

    return pBinding;
}

void
CBindingList::Delete( CBinding* pBinding )
{
    if ( pBinding )
    {
        CSDBGPrint((DM_WARNING,
                    IDS_CSTORE_CSCACHEPURGE,
                    pBinding->szStorePath));

        pBinding->Remove();

        delete pBinding;

        _cBindings--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\common\cutil.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  util.cxx
//
//*************************************************************

#include "common.hxx"

MSGWAITFORMULTIPLEOBJECTS *     pfnMsgWaitForMultipleObjects = 0;
PEEKMESSAGEW *      pfnPeekMessageW = 0;
TRANSLATEMESSAGE *  pfnTranslateMessage = 0;
DISPATCHMESSAGEW *  pfnDispatchMessageW = 0;
GETPROCESSWINDOWSTATION *   pfnGetProcessWindowStation = 0;
CLOSEWINDOWSTATION *        pfnCloseWindowStation = 0;
GETUSEROBJECTINFORMATIONW * pfnGetUserObjectInformationW = 0;

MSISETINTERNALUI * gpfnMsiSetInternalUI = 0;
MSICONFIGUREPRODUCTEXW * gpfnMsiConfigureProductEx = 0;
MSIPROVIDECOMPONENTFROMDESCRIPTORW * gpfnMsiProvideComponentFromDescriptor = 0;
MSIDECOMPOSEDESCRIPTORW * gpfnMsiDecomposeDescriptor = 0;
MSIGETPRODUCTINFOW * gpfnMsiGetProductInfo = 0;
MSIADVERTISESCRIPTW * gpfnMsiAdvertiseScript = 0;
MSIQUERYPRODUCTSTATEW * gpfnMsiQueryProductState = 0;
MSIISPRODUCTELEVATEDW * gpfnMsiIsProductElevated = 0;
MSIREINSTALLPRODUCTW * gpfnMsiReinstallProduct = 0;

void
FreeApplicationInfo(
    APPLICATION_INFO * ApplicationInfo
    )
{
    if ( ! ApplicationInfo )
        return;

    LocalFree( ApplicationInfo->pwszDeploymentId );
    LocalFree( ApplicationInfo->pwszDeploymentName );
    LocalFree( ApplicationInfo->pwszGPOName );
    LocalFree( ApplicationInfo->pwszProductCode );
    LocalFree( ApplicationInfo->pwszDescriptor );
    LocalFree( ApplicationInfo->pwszSetupCommand );
}

PSID
AppmgmtGetUserSid(
    HANDLE  hUserToken // = 0
    )
{
    PSID        pSid;
    HANDLE      hToken;
    PTOKEN_USER pTokenUserData;
    UCHAR       Buffer[sizeof(TOKEN_USER) + sizeof(SID) + ((SID_MAX_SUB_AUTHORITIES-1) * sizeof(ULONG))];
    DWORD       Size;
    DWORD       Status;
    BOOL        bStatus;

    if ( ! hUserToken )
    {
        bStatus = OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken );

        if ( ! bStatus )
            bStatus = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken );

        if ( ! bStatus )
            return NULL;
    }
    else
    {
        hToken = hUserToken;
    }

    Size = sizeof(Buffer);
    pTokenUserData = (PTOKEN_USER) Buffer;

    bStatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    pTokenUserData,
                    Size,
                    &Size );

    if ( ! hUserToken )
        CloseHandle( hToken );

    if ( ! bStatus )
        return NULL;

    Size = GetLengthSid( pTokenUserData->User.Sid );

    pSid = (PSID) LocalAlloc( 0, Size );

    if ( pSid )
    {
        bStatus = CopySid( Size, pSid, pTokenUserData->User.Sid );

        if ( ! bStatus )
        {
            LocalFree( pSid );
            pSid = NULL;
        }
    }

    return pSid;
}

void
DwordToString(
    DWORD   Number,
    WCHAR * wszNumber
    )
{
    WCHAR * pwszString;
    WCHAR   c;
    DWORD   Length;
    DWORD   n;

    pwszString = wszNumber;
    Length = 0;

    do
    {
        *pwszString++ = (WCHAR) (L'0' + Number % 10);
        Number /= 10;
        Length++;
    } while ( Number );

    *pwszString = 0;

    for ( n = 0; n < Length / 2; n++ )
    {
        c = wszNumber[n];
        wszNumber[n] = wszNumber[Length-n-1];
        wszNumber[Length-n-1] = c;
    }
}

BOOL
LoadUser32Funcs()
{
    HINSTANCE hUser32 = 0;

    if ( pfnMsgWaitForMultipleObjects && pfnPeekMessageW && pfnTranslateMessage && pfnDispatchMessageW &&
         pfnGetProcessWindowStation && pfnCloseWindowStation && pfnGetUserObjectInformationW )
        return TRUE;

    hUser32 = LoadLibrary( L"user32.dll" );

    if ( ! hUser32 )
        return FALSE;

    pfnMsgWaitForMultipleObjects = (MSGWAITFORMULTIPLEOBJECTS *) GetProcAddress( hUser32, "MsgWaitForMultipleObjects" );
    pfnPeekMessageW = (PEEKMESSAGEW *) GetProcAddress( hUser32, "PeekMessageW" );
    pfnTranslateMessage = (TRANSLATEMESSAGE *) GetProcAddress( hUser32, "TranslateMessage" );
    pfnDispatchMessageW = (DISPATCHMESSAGEW *) GetProcAddress( hUser32, "DispatchMessageW" );
    pfnGetProcessWindowStation = (GETPROCESSWINDOWSTATION *) GetProcAddress( hUser32, "GetProcessWindowStation" );
    pfnCloseWindowStation = (CLOSEWINDOWSTATION *) GetProcAddress( hUser32, "CloseWindowStation" );
    pfnGetUserObjectInformationW = (GETUSEROBJECTINFORMATIONW *) GetProcAddress( hUser32, "GetUserObjectInformationW" );

    if ( ! pfnMsgWaitForMultipleObjects || ! pfnPeekMessageW || ! pfnTranslateMessage || ! pfnDispatchMessageW ||
         ! pfnGetProcessWindowStation || ! pfnCloseWindowStation || ! pfnGetUserObjectInformationW )
    {
        FreeLibrary( hUser32 );
        return FALSE;
    }

    // user32 remains loaded

    return TRUE;
}

BOOL
LoadLoadString()
{
    HINSTANCE hUser32 = 0;

    if ( pfnLoadStringW )
        return TRUE;

    hUser32 = LoadLibrary( L"user32.dll" );

    if ( ! hUser32 )
        return FALSE;

    pfnLoadStringW = (LOADSTRINGW *) GetProcAddress( hUser32, "LoadStringW" );

    if ( ! pfnLoadStringW )

    {
        FreeLibrary( hUser32 );
        return FALSE;
    }

    // user32 remains loaded

    return TRUE;
}

void
GuidToString(
    GUID &  Guid,
    PWCHAR  pwszGuid
    )
{
    *pwszGuid = 0;

    StringCchPrintf(
        pwszGuid,
        40,
        L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
        Guid.Data1,
        Guid.Data2,
        Guid.Data3,
        Guid.Data4[0],
        Guid.Data4[1],
        Guid.Data4[2],
        Guid.Data4[3],
        Guid.Data4[4],
        Guid.Data4[5],
        Guid.Data4[6],
        Guid.Data4[7]
        );
}

void
GuidToString(
    GUID &  Guid,
    PWCHAR *ppwszGuid
    )
{
    *ppwszGuid = new WCHAR[40];
    if ( *ppwszGuid )
        GuidToString( Guid, *ppwszGuid);
}

void
StringToGuid(
    PWCHAR pwszGuid,
    GUID * pGuid
    )
{
    UNICODE_STRING  String;
    DWORD           Data;

    // mimicking scanf of L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"

    if (lstrlen(pwszGuid) != GUID_LENGTH) 
    {
        memset(pGuid, 0, sizeof(GUID));
        return;
    }

    String.Buffer = pwszGuid + 1;

    String.Length = String.MaximumLength = 16;
    RtlUnicodeStringToInteger( &String, 16, &pGuid->Data1 );
    String.Buffer += 9;

    String.Length = String.MaximumLength = 8;
    RtlUnicodeStringToInteger( &String, 16, &Data );
    pGuid->Data2 = (USHORT) Data;
    String.Buffer += 5;
    RtlUnicodeStringToInteger( &String, 16, &Data );
    pGuid->Data3 = (USHORT) Data;
    String.Buffer += 5;

    String.Length = String.MaximumLength = 4;

    for ( DWORD n = 0; n <= 7; n++ )
    {
        RtlUnicodeStringToInteger( &String, 16, &Data );
        pGuid->Data4[n] = (UCHAR) Data;
        String.Buffer += 2;

        if ( 1 == n )
            String.Buffer++;
    }
}

HRESULT
CreateGuid(GUID *pGuid)
{
    int err;

    // We simply use the RPC system supplied API
    if ((err = UuidCreate(pGuid)) != RPC_S_UUID_LOCAL_ONLY)
    {
        return err ? HRESULT_FROM_WIN32(err) : S_OK;
    }

    return S_OK;
}

DWORD
ReadStringValue(
    HKEY        hKey,
    WCHAR *     pwszValueName,
    WCHAR **    ppwszValue
    )
{
    DWORD   Status;
    DWORD   Size;

    *ppwszValue = 0;

    Size = 0;

    Status = RegQueryValueEx(
                hKey,
                pwszValueName,
                0,
                NULL,
                (LPBYTE) *ppwszValue,
                &Size );

    //
    // Does not return ERROR_MORE_DATA when buffer is NULL.
    //
    if ( Status != ERROR_SUCCESS )
        return Status;

    *ppwszValue = new WCHAR[Size / 2];
    if ( ! *ppwszValue )
        return ERROR_OUTOFMEMORY;

    Status = RegQueryValueEx(
                hKey,
                pwszValueName,
                0,
                NULL,
                (LPBYTE) *ppwszValue,
                &Size );

    if ( Status != ERROR_SUCCESS )
    {
        delete *ppwszValue;
        *ppwszValue = 0;
    }

    return Status;
}

DWORD
GetSidString(
    HANDLE          hToken,
    UNICODE_STRING* pSidString
    )
{
    LONG         Status;
    BOOL         bStatus;
    DWORD        Size;
    UCHAR        Buffer[sizeof(TOKEN_USER) + sizeof(SID) + ((SID_MAX_SUB_AUTHORITIES-1) * sizeof(ULONG))];
    PTOKEN_USER  pTokenUser;

    Status = ERROR_SUCCESS;

    Size = sizeof(Buffer);

    pTokenUser = (PTOKEN_USER) Buffer;

    bStatus = GetTokenInformation(
        hToken,
        TokenUser,
        pTokenUser,
        Size,
        &Size );

    if ( ! bStatus )
        Status = GetLastError();
    
    if ( ERROR_SUCCESS == Status )
    {
        Status = RtlConvertSidToUnicodeString(
            pSidString,
            pTokenUser->User.Sid,
            TRUE );

        if ( ! NT_SUCCESS( Status ) )
        {
            Status = RtlNtStatusToDosError( Status );
        }
    }

    return Status;
}

CLoadMsi::CLoadMsi( DWORD &Status )
{
    hMsi = LoadLibrary( L"msi.dll" );

    if ( ! hMsi )
    {
        Status = GetLastError();
        return;
    }

    gpfnMsiSetInternalUI = (MSISETINTERNALUI *) GetProcAddress( hMsi, "MsiSetInternalUI" );
    gpfnMsiConfigureProductEx = (MSICONFIGUREPRODUCTEXW *) GetProcAddress( hMsi, "MsiConfigureProductExW" );
    gpfnMsiProvideComponentFromDescriptor = (MSIPROVIDECOMPONENTFROMDESCRIPTORW *) GetProcAddress( hMsi, "MsiProvideComponentFromDescriptorW" );
    gpfnMsiDecomposeDescriptor = (MSIDECOMPOSEDESCRIPTORW *) GetProcAddress( hMsi, "MsiDecomposeDescriptorW" );
    gpfnMsiGetProductInfo = (MSIGETPRODUCTINFOW *) GetProcAddress( hMsi, "MsiGetProductInfoW" );
    gpfnMsiAdvertiseScript = (MSIADVERTISESCRIPTW *) GetProcAddress( hMsi, "MsiAdvertiseScriptW" );
    gpfnMsiQueryProductState = (MSIQUERYPRODUCTSTATEW *) GetProcAddress( hMsi, "MsiQueryProductStateW" );
    gpfnMsiIsProductElevated = (MSIISPRODUCTELEVATEDW *) GetProcAddress( hMsi, "MsiIsProductElevatedW" );
    gpfnMsiReinstallProduct = (MSIREINSTALLPRODUCTW *) GetProcAddress( hMsi, "MsiReinstallProductW" );

    if ( ! gpfnMsiSetInternalUI ||
         ! gpfnMsiConfigureProductEx ||
         ! gpfnMsiProvideComponentFromDescriptor ||
         ! gpfnMsiDecomposeDescriptor ||
         ! gpfnMsiAdvertiseScript ||
         ! gpfnMsiQueryProductState ||
         ! gpfnMsiIsProductElevated ||
         ! gpfnMsiReinstallProduct )
    {
        Status = ERROR_PROC_NOT_FOUND;
        return;
    }

    Status = ERROR_SUCCESS;
}

CLoadMsi::~CLoadMsi()
{
    if ( hMsi )
        FreeLibrary( hMsi );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\admin.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:    admin.cxx
//
//  Contents:Class Factory and IUnknown methods for CClassContainer
//
//  Author:  DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"

//
// Constructor for Class Container Class factory
//
unsigned long gulcInstances = 0;

HRESULT GetConsistentPackageFlags(
    HANDLE         hADs,
    DWORD*         pdwPackageFlags,
    UINT*          pdwUpgrades,
    UINT*          pdwInstallUiLevel,
    CLASSPATHTYPE* pdwPathType,
    DWORD*         pdwNewPackageFlags,
    WCHAR*         wszSearchFlags)
{
    HRESULT         hr;
    LPOLESTR        PackageAttrName;
    ADS_ATTR_INFO*  pAttrsGot;
    DWORD           cgot;
    DWORD           posn;
    DWORD           dwOldPackageFlags;
    DWORD           dwNewPackageFlags;

    //
    // Init locals
    //
    dwOldPackageFlags = 0;
    PackageAttrName = PACKAGEFLAGS;
    pAttrsGot = NULL;
    hr = S_OK;

    if (hADs)
    {
        //
        // We need to find the old package flags -- we do this so we can preserve
        // certain properties.
        //
        hr = ADSIGetObjectAttributes(hADs, &PackageAttrName, 1, &pAttrsGot, &cgot);

        if (SUCCEEDED(hr))
        {
            posn = GetPropertyFromAttr(pAttrsGot, cgot, PACKAGEFLAGS);
            if (posn < cgot)
                UnpackDWFrom(pAttrsGot[posn], (DWORD *)&dwOldPackageFlags);
            else  
                hr=CS_E_OBJECT_NOTFOUND;
        }
    }

    if (SUCCEEDED(hr)) 
    {
        //
        // Decide whether to start with existing flags or caller supplied flags based
        // on whether the caller passed in desired flags
        //
        dwNewPackageFlags = pdwPackageFlags ? *pdwPackageFlags : dwOldPackageFlags;

        //
        // Make sure to preserve upgrades,
        // installui, and pathtype transparently
        //
        dwNewPackageFlags |= dwOldPackageFlags & 
            (ACTFLG_POSTBETA3 |
             ACTFLG_HasUpgrades |
             ACTFLG_FullInstallUI |
             PATHTYPEMASK);

        //
        // Now set the upgrade bit according to whether there are upgrades
        //
        if (pdwUpgrades) 
        {
            dwNewPackageFlags = *pdwUpgrades ?
                dwNewPackageFlags | ACTFLG_HasUpgrades :
                dwNewPackageFlags & ~(ACTFLG_HasUpgrades);
        }

        //
        // Set the install UI level
        //
        if (pdwInstallUiLevel)
        {
            dwNewPackageFlags &= ~(ACTFLG_FullInstallUI);
            dwNewPackageFlags |= (*pdwInstallUiLevel != INSTALLUILEVEL_FULL) ?
                ACTFLG_FullInstallUI : 0;
        }

        //
        // Now or in the pathtype by shifting it to the far left -- first clear those
        // bits out
        //
        if (pdwPathType) 
        {
            dwNewPackageFlags &= ~PATHTYPEMASK;
            dwNewPackageFlags |= *pdwPathType << PATHTYPESHIFT;
        }
     
        *pdwNewPackageFlags = dwNewPackageFlags;

        if (wszSearchFlags) 
        {
            memset(wszSearchFlags, 0, MAX_SEARCH_FLAGS * sizeof(*wszSearchFlags));

            //
            // Previously, we determined the search flags based
            // on whether the package was an NT 5.0 beta 3 deployment --
            // this backward compatibility with beta 3 will not
            // be supported in subsequent versions of Windows
            //
            *wszSearchFlags = SEARCHFLAG_REMOVED;
            
            if (dwNewPackageFlags & ACTFLG_Published)
            {
                *wszSearchFlags = SEARCHFLAG_PUBLISHED;
                wszSearchFlags++;
            }

            if (dwNewPackageFlags & ACTFLG_Assigned)
            {
                *wszSearchFlags = SEARCHFLAG_ASSIGNED;
            }
        }
    }

    if (pAttrsGot) 
    {
        FreeADsMem(pAttrsGot);
    }

    return hr;
}


CClassContainerCF::CClassContainerCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcInstances );
}

//
// Destructor
//
CClassContainerCF::~CClassContainerCF()
{
    InterlockedDecrement((long *) &gulcInstances );
}

HRESULT  __stdcall  CClassContainerCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    } else
    {
        sc = (E_NOINTERFACE);
    }
    
    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainerCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;
    
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateInstance
//
//  Synopsis:
//              This is the default create instance on the class factory.
//
//  Arguments:  pUnkOuter - Should be NULL
//              riid      - IID of interface wanted
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------
//
HRESULT  __stdcall  CClassContainerCF::CreateInstance(
                                                      IUnknown    *   pUnkOuter,
                                                      REFIID          riid,
                                                      void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE              sc = S_OK;
    
    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CClassContainer()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
            pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateConnectedInstance
//
//  Synopsis:
//              This method is called by the ParseDisplayName implementation
//              on the ClassFactory object.
//              When a display name is used to bind to a Class Store
//              an IClassAdmin is returned after binding to the container.
//              This method fails if the bind fails.
//
//  Arguments:  pszPath  - DisplayName of Class Store Container
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------

HRESULT  __stdcall  CClassContainerCF::CreateConnectedInstance(
                                                               CServerContext* pServerContext,
                                                               LPOLESTR        pszPath,
                                                               void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE              sc = S_OK;
    HRESULT            hr = S_OK;
    
    if ((pIUnk = new CClassContainer(pServerContext, pszPath, &sc)) != NULL)
    {
        if (SUCCEEDED(sc))
        {
            sc = pIUnk->QueryInterface( IID_IClassAdmin, ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
        }
        
        pIUnk->Release();
    }
    else
        sc = E_OUTOFMEMORY;
    
    return (sc);
}

HRESULT  __stdcall  CClassContainerCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcInstances ); }
    else
    { InterlockedDecrement((long *) &gulcInstances ); }
    return(S_OK);
}

//
// IUnknown methods for CClassContainer
//
//

HRESULT  __stdcall  CClassContainer::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE     sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else if( IsEqualIID( IID_IClassAdmin, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }
    
    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainer::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainer::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;
    
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}


// utility functions
HRESULT UpdateStoreUsn(HANDLE hADs, LPOLESTR szUsn)
{
    ADS_ATTR_INFO       pAttr[1];   
    DWORD               cModified = 0;
    HRESULT             hr = S_OK;
    
    PackStrToAttr(pAttr, STOREUSN, szUsn);
    hr = ADSISetObjectAttributes(hADs, pAttr, 1, &cModified);
    FreeAttr(pAttr[0]);
    return hr;
}


//----------------------------------------------------------
// Implementation for CClassContainer
//----------------------------------------------------------
//
CClassContainer::CClassContainer()

{
    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_szCategoryName = NULL;
    m_szPackageName = NULL;

    m_szPolicyName = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));
    
    m_uRefs = 1;
}


//---------------------------------------------------------------
//
//  Function:   Constructor
//
//  Synopsis:   Binds to the ClassStore given a class store path.
//
//  Arguments:
//  [in]    
//      szStoreName
//              Class Store Path without the leading ADCS:
//           
//  [out]
//      phr     
//              Sucess code.
//
//  Does an ADSI bind at the class store container and matches the
//  version numbers. if the version numbers match then it binds to the
//  class, package and category containers and keeps the bind handles.
//----------------------------------------------------------------

CClassContainer::CClassContainer(
                                 CServerContext* pServerContext,
                                 LPOLESTR        szStoreName,
                                 HRESULT*        phr)
                                 
{
    DWORD               dwStoreVersion = 0;
    LPOLESTR            AttrNames[] = {STOREVERSION, POLICYDN};
    ADS_ATTR_INFO     * pAttrsGot = NULL;
    DWORD               cgot = 0, posn = 0;
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    
    // set the search preference to one level search
    // and make the results come back in batches of size
    // 20 as default.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = SEARCHPAGESIZE;

    // initialising.
    *phr = S_OK;

    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_szCategoryName = NULL;
    m_szPackageName = NULL;
    
    m_szPolicyName = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));

    // Bind to a Class Store Container Object
    // Cache the interface pointer
    //

    *phr = StringCchCopy (m_szContainerName, _MAX_PATH, szStoreName);

    ERROR_ON_FAILURE(*phr);

    if ( pServerContext )
    {
        *phr = m_ServerContext.Initialize( pServerContext );        
    }

    ERROR_ON_FAILURE(*phr);

    *phr = DSServerOpenDSObject( &m_ServerContext, m_szContainerName, GetDsFlags(),
        &m_ADsContainer);
    
    ERROR_ON_FAILURE(*phr);
    
    //
    // Check the Schema Version of this container
    //
    
    *phr = ADSIGetObjectAttributes(m_ADsContainer, AttrNames, 2, &pAttrsGot, &cgot);
    
    if ((SUCCEEDED(*phr)) && (cgot))
    {
        posn = GetPropertyFromAttr(pAttrsGot, cgot, STOREVERSION);
        dwStoreVersion = 0;
        if (posn < cgot)
        {
            UnpackDWFrom(pAttrsGot[posn], &dwStoreVersion);

            //
            // Compare the schema with the expected version 
            //
            if (dwStoreVersion != SCHEMA_VERSION_NUMBER)
            {
                *phr = CS_E_INVALID_VERSION;
            }
        }

        if (SUCCEEDED(*phr))
        {
            LPOLESTR        szPolicyPath = NULL, szPolicyName = NULL;

            posn = GetPropertyFromAttr(pAttrsGot, cgot, POLICYDN);
            if (posn < cgot)
            {
                LPOLESTR        szParentPath = NULL, szPolicyGuid = NULL;
                
                UnpackStrFrom(pAttrsGot[posn], &szPolicyPath); 
                //

                BuildADsParentPath(szPolicyPath, &szParentPath, &szPolicyGuid);

                if (szPolicyGuid && szParentPath)
                {
                    if (wcslen(szPolicyGuid) == 41)
                    {
                        // valid GUID

                        GUIDFromString(&szPolicyGuid[4], &m_PolicyId);
                    }

                    *phr = GetGPOName( &szPolicyName );
                }
                else
                {
                    *phr = E_OUTOFMEMORY;
                }

                if (szParentPath)
                    FreeADsMem(szParentPath);

                if (szPolicyGuid)
                    FreeADsMem(szPolicyGuid);
            }

            m_szPolicyName = szPolicyName;
        }
    }
    
    if (pAttrsGot)
        FreeADsMem(pAttrsGot);

    ERROR_ON_FAILURE(*phr);
    
    //
    // Bind to the Package container Object
    // Cache the interface pointer
    //
    
    // get the package container name.
    BuildADsPathFromParent(m_szContainerName, PACKAGECONTAINERNAME, &m_szPackageName);
    
    m_ADsPackageContainer = NULL;
    
    // bind to the package container.
    *phr = DSServerOpenDSObject( &m_ServerContext, m_szPackageName, GetDsFlags(),
                            &m_ADsPackageContainer);
    
    ERROR_ON_FAILURE(*phr);
    
    // set the search preference.
    *phr = ADSISetSearchPreference(m_ADsPackageContainer, SearchPrefs, 2);
    ERROR_ON_FAILURE(*phr);
    
    m_fOpen = TRUE;
    m_uRefs = 1;
    
Error_Cleanup:
    *phr = RemapErrorCode(*phr, m_szContainerName);
    return;
}


CClassContainer::~CClassContainer(void)
{
    if (m_fOpen)
    {
        m_fOpen = FALSE;
    }
    
    if (m_ADsPackageContainer)
    {
        ADSICloseDSObject(m_ADsPackageContainer);
        m_ADsPackageContainer = NULL;
    }

    if (m_szPackageName)
        FreeADsMem(m_szPackageName);
    
    if (m_szCategoryName)
        FreeADsMem(m_szCategoryName);

    if (m_ADsContainer)
    {
        ADSICloseDSObject(m_ADsContainer);
        m_ADsContainer = NULL;
    }
}

// currently unused.
BOOL InvalidDSName(LPWSTR pName)
{

    if (wcslen(pName) >= 56)
        return TRUE;

    while (*pName)
    {
        if ((*pName == L':') ||
            (*pName == L',') ||
            (*pName == L';') ||
            (*pName == L'/') ||
            (*pName == L'<') ||
            (*pName == L'>') ||
            (*pName == L'\\')||
            (*pName == L'+'))
            return TRUE;
        ++pName;
    }

    return FALSE;
}

HRESULT  CClassContainer::GetGPOInfo(GUID *pGPOId, LPOLESTR *pszPolicyName)
{
    HRESULT hr;

    if ((!pGPOId) || (IsBadWritePtr(pGPOId, sizeof(GUID))))
        return E_INVALIDARG;

    if ((!pszPolicyName) || (IsBadWritePtr(pszPolicyName, sizeof(LPOLESTR))))
        return E_OUTOFMEMORY;

    memcpy(pGPOId, &m_PolicyId, sizeof(GUID));

    if (m_szPolicyName)
    {
        *pszPolicyName = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*(1+wcslen(m_szPolicyName)));
        if (!(*pszPolicyName))
            return E_INVALIDARG;
        hr = StringCchCopy(*pszPolicyName, wcslen(m_szPolicyName) + 1, m_szPolicyName);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        *pszPolicyName = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*2);
        if (!(*pszPolicyName))
            return E_OUTOFMEMORY;

        (*pszPolicyName)[0] = L'\0';
    }
    return S_OK;
}

//---------------------------------------------------------------
//
//  Function:   EnumPackages
//
//  Synopsis:   Returns an Enumerator for all the packages that satisfies
//              the query.
//
//  UsedBy      Add/Remove Programs
//
//  Arguments:
//  [in]    
//      pszFileExt
//              FileExt that has to be queried on. ignored if NULL.
//      pCategory
//              Category that has to be queried on. ignored if NULL.
//      dwAppFlags
//              One of the APPINFO_XXX. ignored if it is APPINFO_ALL.
//      pdwLocale
//              Locale that has to be queried on. Ignored if NULL.
//      pPlatform
//              Platform that has to be queried on. Ignored if NULL.
//              
//  [out]
//      ppIEnumPackage
//              Enumerator is returned. 
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Validates the inputs, Creates a EnumPackage object, makes up the
//  search string made up of file extension, category.
//----------------------------------------------------------------
HRESULT CClassContainer::EnumPackages(
                                      LPOLESTR           pszFileExt,
                                      GUID              *pCategory,
                                      DWORD              dwAppFlags,
                                      DWORD             *pdwLocale,
                                      CSPLATFORM        *pPlatform,
                                      IEnumPackage     **ppIEnumPackage
                                      )
{
    const DWORD                 dwMaxStrLen = 1000;
    HRESULT                     hr = S_OK;
    CEnumPackage               *pEnum = NULL;
    WCHAR                       szfilter[dwMaxStrLen], szQry[dwMaxStrLen]; 

    if (pszFileExt && IsBadStringPtr(pszFileExt, _MAX_PATH))
        return E_INVALIDARG;
    
    if (pCategory && IsBadReadPtr(pCategory, sizeof(GUID)))
        return E_INVALIDARG;
    
    if (IsBadWritePtr(ppIEnumPackage, sizeof(IEnumPackage *)))
        return E_INVALIDARG;
    
    *ppIEnumPackage = NULL;
    
    pEnum = new CEnumPackage(&m_ServerContext, m_PolicyId, m_szPolicyName, m_szContainerName, NULL);
    if(NULL == pEnum)
        return E_OUTOFMEMORY;
    
    //
    // Create a CommandText
    //

    hr = StringCchPrintf(szfilter, dwMaxStrLen, L"(& (objectClass=%s) ", CLASS_CS_PACKAGE);
    
    ERROR_ON_FAILURE(hr);
        
    if (pszFileExt)
    {
        hr = StringCchPrintf(szQry, dwMaxStrLen, L"(%s=%s*) ", PKGFILEEXTNLIST, pszFileExt);

        ERROR_ON_FAILURE(hr);

        hr = StringCchCat(szfilter, dwMaxStrLen, szQry);

        ERROR_ON_FAILURE(hr);
    }
    
    if (pCategory)
    {
        STRINGGUID szCat;
        StringFromGUID (*pCategory, szCat);
        hr = StringCchPrintf(szQry, dwMaxStrLen, L"(%s=%s) ", PKGCATEGORYLIST, szCat);
        
        ERROR_ON_FAILURE(hr);

        hr = StringCchCat(szfilter, dwMaxStrLen, szQry);
        
        ERROR_ON_FAILURE(hr);
    }
    
    hr = StringCchCat(szfilter, dwMaxStrLen, L")");
    
    ERROR_ON_FAILURE(hr);
    
    hr = pEnum->Initialize(m_szPackageName, szfilter,
        dwAppFlags, FALSE, pPlatform);
    
    ERROR_ON_FAILURE(hr);
    
    hr = pEnum->QueryInterface(IID_IEnumPackage, (void**)ppIEnumPackage);
    ERROR_ON_FAILURE(hr);
    
    return S_OK;
    
Error_Cleanup:
    if (pEnum)
        delete pEnum;
    *ppIEnumPackage = NULL;
    
    return RemapErrorCode(hr, m_szContainerName);
}

HRESULT CClassContainer::GetDNFromPackageName(LPOLESTR pszPackageName, LPOLESTR *szDN)
{
    HRESULT             hr = S_OK;
    WCHAR*              szfilter;
    WCHAR*              szEscapedName;
    LPOLESTR            AttrNames[] = {OBJECTCLASS, PACKAGEFLAGS, OBJECTDN};
    DWORD               cAttr = 3;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCH_COLUMN   column;
    DWORD               dwFlags = 0;

    *szDN = NULL;

    szfilter = NULL;

    //
    // To get the DN, we perform a search.  The search filter syntax requires that
    // the package name is properly escaped, so we retrieve such a filter below
    //
    hr = GetEscapedNameFilter( pszPackageName, &szfilter );

    if ( FAILED( hr ) )
    {
        RETURN_ON_FAILURE( hr );
    }

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szfilter, AttrNames, cAttr, &hADsSearchHandle);

    CsMemFree( szfilter );

    RETURN_ON_FAILURE(hr);    

    for (hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
                ((SUCCEEDED(hr)) && (hr != S_ADS_NOMORE_ROWS));
                hr = ADSIGetNextRow(m_ADsPackageContainer, hADsSearchHandle))
    {
        hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGEFLAGS, &column);
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &dwFlags);
            
            ADSIFreeColumn(m_ADsPackageContainer, &column);
        }
        else
            continue;

        if ((dwFlags & ACTFLG_Orphan) || (dwFlags & ACTFLG_Uninstall))
            continue;

        hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, OBJECTDN, &column);
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, szDN);
            
            ADSIFreeColumn(m_ADsPackageContainer, &column);
        }
        else
            continue;

        break;

    }
    
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);
    
    return hr;
}

// Gets the RDN of a package given the package Guid. 
HRESULT CClassContainer::BuildDNFromPackageGuid(GUID PackageGuid, LPOLESTR *szDN)
{
    HRESULT             hr = S_OK;
    LPOLESTR            AttrName = {OBJECTDN};
    WCHAR               szfilter[_MAX_PATH];
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCH_COLUMN   column;
    LPWSTR              EncodedGuid = NULL;

    hr = ADsEncodeBinaryData((PBYTE)&PackageGuid, sizeof(GUID), &EncodedGuid);

    hr = StringCchPrintf(szfilter, _MAX_PATH, L"(%s=%s)", OBJECTGUID, EncodedGuid);

    RETURN_ON_FAILURE(hr);

    FreeADsMem(EncodedGuid);

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szfilter, &AttrName, 1, &hADsSearchHandle);

    RETURN_ON_FAILURE(hr);

    hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
    if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
    {
        ERROR_ON_FAILURE(hr = CS_E_PACKAGE_NOTFOUND);
    }

    hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, AttrName, &column);
    ERROR_ON_FAILURE(hr);

    if (SUCCEEDED(hr))
    {
        UnpackStrAllocFrom(column, szDN);
    }

    ADSIFreeColumn(m_ADsPackageContainer, &column);

Error_Cleanup:
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);

    return hr;
}

HRESULT CClassContainer::GetPackageGuid(WCHAR *szRDN, GUID *pPackageGuid)
{
    HRESULT             hr = S_OK;
    LPOLESTR            AttrName = {OBJECTGUID};
    WCHAR               szfilter[_MAX_PATH];
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCH_COLUMN   column;

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szRDN, &AttrName, 1, &hADsSearchHandle);

    RETURN_ON_FAILURE(hr);

    hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
    if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
    {
        ERROR_ON_FAILURE(hr = CS_E_PACKAGE_NOTFOUND);
    }

    hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_OCTET_STRING, AttrName, &column);
    ERROR_ON_FAILURE(hr);

    if (SUCCEEDED(hr))
        UnpackGUIDFrom(column, pPackageGuid);

    ADSIFreeColumn(m_ADsPackageContainer, &column);

Error_Cleanup:
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);

    return hr;
}
//---------------------------------------------------------------
//
//  Function:   GetPackageDetails
//
//  Synopsis:   Returns the PackageDetail corresponding to the PackageName.
//
//  Arguments:
//  [in]    
//      pszPackageId
//              Id of the Package.
//  [out]
//      pPackageDetail
//              PackageDetail info that is returned.
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Binds to the Package object and calls GetPackageDetail with it.
//----------------------------------------------------------------
HRESULT CClassContainer::GetPackageDetails (
                                            LPOLESTR          pszPackageName,
                                            PACKAGEDETAIL   * pPackageDetail
                                            )
{
    HRESULT              hr = S_OK;
    HANDLE               hADs = NULL;
    WCHAR              * szFullName = NULL;
    ADS_ATTR_INFO      * pAttr = NULL;
    DWORD                cgot = 0;
    
    // this can be made into a search based API. Not required for the time being.
    // Should change it if perf is a big issue.
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
    
    // binding to the package object.    
    hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);
    
    // calling GetPackageDetail.
    hr = GetPackageDetail (hADs, NULL, pPackageDetail);
    
    ADSICloseDSObject(hADs);
    
    if (pAttr)
        FreeADsMem(pAttr);
    
    if (szFullName)
        CsMemFree(szFullName);
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//
//  Function:   GetPackageDetails
//
//  Synopsis:   Returns the PackageDetail corresponding to the PackageName.
//
//  Arguments:
//  [in]    
//      pszPackageId
//              Id of the Package.
//  [out]
//      pPackageDetail
//              PackageDetail info that is returned.
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Binds to the Package object and calls GetPackageDetail with it.
//----------------------------------------------------------------
HRESULT CClassContainer::GetPackageDetailsFromGuid (
                                                    GUID            PkgGuid,
                                                    PACKAGEDETAIL  *pPackageDetail
                                                   )
{
    HRESULT              hr = S_OK;
    HANDLE               hADs = NULL;
    WCHAR              * szFullName = NULL, szRDN[_MAX_PATH];
    ADS_ATTR_INFO      * pAttr = NULL;
    DWORD                cgot = 0;
    
    // this can be made into a search based API. Not required for the time being.
    // Should change it if perf is a big issue.
    if (IsNullGuid(PkgGuid))
        return E_INVALIDARG;

    BuildDNFromPackageGuid(PkgGuid, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
    
    // binding to the package object.
    
    hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);
    
    // calling GetPackageDetail.
    hr = GetPackageDetail (hADs, NULL, pPackageDetail);
    
    ADSICloseDSObject(hADs);
    
    if (pAttr)
        FreeADsMem(pAttr);
    
    if (szFullName)
        CsMemFree(szFullName);

Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}

#define FREEARR(ARR, SZ) {                                          \
                DWORD curIndex;                                     \
                for (curIndex = 0; curIndex < (SZ); curIndex++)     \
                    CsMemFree((ARR)[curIndex]);                 \
                CsMemFree(ARR);                                 \
                ARR = NULL;                                         \
        }                                                           \


//---------------------------------------------------------------
//
//  Function:   ChangePackageUpgradeInfoIncremental
//
//  Synopsis:   Mark the package as upgraded by another package
//
//  Arguments:
//  [in]    
//      PackageGuid
//              Package Guid to identify the package.
//      szUpgradedByClassStore
//              Class Store where the package that upgrades exists
//      UpgradedByPackageGuid
//              The Guid of the package that upgrades
//      Add     Add or remove the upgradedByrelation
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Otherwise it packs all the required attributes in the ATTR_INFO
//  structure and sends it to the Directory.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageUpgradeInfoIncremental(
                         GUID           PackageGuid,
                         UPGRADEINFO    UpgradeInfo,
                         DWORD          OpFlags
                      )
{
    HRESULT         hr = S_OK;
    HANDLE          hADs = NULL;
    WCHAR          *szFullName=NULL, szGuid[_MAX_PATH], szUsn[20];
    LPOLESTR        pProp = NULL;
    ADS_ATTR_INFO   pAttr[2];
    DWORD           cAttr = 0, cModified = 0, i=0;
    UINT            len=0;
    ULONG           ulSize;

    hr = BuildDNFromPackageGuid(PackageGuid, &szFullName);
    ERROR_ON_FAILURE(hr);
    
    // Bind to the Package Object.
    hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);

    StringFromGUID(UpgradeInfo.PackageGuid, szGuid);

    len = wcslen(UpgradeInfo.szClassStore);
    ulSize = 36+PKG_UPG_DELIM1_LEN+len+PKG_UPG_DELIM2_LEN+2+2+1;
    pProp = (LPOLESTR)CsMemAlloc(sizeof(WCHAR) * ulSize);
                    // Guid size+::+length++:+flagDigit+2 

    hr = StringCchPrintf(pProp, ulSize, L"%s%s%s%s%02x", UpgradeInfo.szClassStore, PKG_UPG_DELIMITER1, szGuid, PKG_UPG_DELIMITER2, UpgradeInfo.Flag%16);

    ERROR_ON_FAILURE(hr);

    PackStrArrToAttrEx(pAttr+cAttr, UPGRADESPACKAGES, &pProp, 1, OpFlags?TRUE:FALSE);
    cAttr++;

    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;

    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);

    if (hADs)
        ADSICloseDSObject(hADs);
    
    // ignore it if the property already exists.
    if (hr == HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS))
        hr = S_OK;

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    
Error_Cleanup:
    if (szFullName)
        CsMemFree(szFullName);

    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//
//  Function:   ChangePackageProperties
//
//  Synopsis:   Change Various (most commonly changed) properties 
//              for a given package.
//
//  Arguments:
//  [in]    
//      PackageId
//              Package Id to identify the package.
//      pszNewname
//              new Name for the Package. If it is being renamed
//              all other changes should be NULL.
//      pdwFlags
//              The Deployment Flags. Should be ACTFLG_XXX
//              Ignored if NULL.
//      pszUrl
//              Help Url for the Package. Ignored if NULL.
//      pszScriptPath
//              Script Path for the Package. Ignored if NULL.
//      pInstallUiLevel
//              The InstallationUiLevel. Ignored if NULL.
//      pdwRevision
//              REVISION. Ignored if NULL.
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Otherwise it packs all the required attributes in the ATTR_INFO
//  structure and sends it to the Directory.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageProperties(
                                                 LPOLESTR       pszPackageName,
                                                 LPOLESTR       pszNewName,
                                                 DWORD         *pdwFlags,
                                                 LPOLESTR       pszUrl,
                                                 LPOLESTR       pszScriptPath,
                                                 UINT          *pInstallUiLevel,
                                                 DWORD         *pdwRevision
                                                 )
{
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szRDN=NULL, *szFullName=NULL;
    WCHAR       szUsn[20];
    ADS_ATTR_INFO pAttr[9];
    DWORD       cAttr = 0, cModified = 0, i=0;
    DWORD       dwNewPackageFlags;
    WCHAR       wszSearchFlags[MAX_SEARCH_FLAGS];

    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;

    // if no properties have to be changed.
    if (!(pszScriptPath || pszUrl || pdwFlags || pInstallUiLevel || pdwRevision || pszNewName))
        return E_INVALIDARG;

    if (pszNewName)
    {
        // rename package

        WCHAR    szNewRDN[_MAX_PATH];
        BOOL     GenerateGuid = FALSE;
        GUID     PackageGuidId;
        WCHAR    pszPackageNewId[_MAX_PATH], *szJunk = NULL;   

        if (IsBadStringPtr(pszNewName, _MAX_PATH))
            return E_INVALIDARG;
        
        if (pszScriptPath || pszUrl || pdwFlags || pInstallUiLevel || pdwRevision)
            return E_INVALIDARG;

        // see whether the new name is valid.
        //        GenerateGuid = InvalidDSName(pszNewName);

        // see whether the newName already exists. Notice that if the same package name is 
        // entered it will return error.
        hr = GetDNFromPackageName(pszNewName, &szJunk);

        if (szJunk)
            CsMemFree(szJunk);
        szJunk = NULL;

        ERROR_ON_FAILURE(hr);

        if (hr == S_OK)
            return CS_E_OBJECT_ALREADY_EXISTS;

        // Bind to the Package Object.
        hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(),
                          &hADs);
        if (szFullName)
            CsMemFree(szFullName);
        szFullName = NULL;

        ERROR_ON_FAILURE(hr);
    }
    else 
    {
        // Bind to the Package Object.
        hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(),
            &hADs);
        ERROR_ON_FAILURE(hr);

        if (szFullName)
            CsMemFree(szFullName);
        szFullName = NULL;
    }
    
    // Just change some properties.
    //
    // Update the TimeStamp
    //
    
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    if (SUCCEEDED(hr))
    {
        hr = GetConsistentPackageFlags(
            hADs,
            pdwFlags,
            NULL,
            pInstallUiLevel,
            NULL,
            &dwNewPackageFlags,
            wszSearchFlags);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Set Package Flags
        //
        if (pdwFlags)
        {
            PackDWToAttr (pAttr+cAttr, PACKAGEFLAGS, dwNewPackageFlags);
            cAttr++;

            if (*wszSearchFlags) 
            {
                PackStrToAttr(pAttr+cAttr, SEARCHFLAGS, wszSearchFlags);
                cAttr++;
            }
        }
    
        //
        // Change Package Script
        //
        if (pszScriptPath) 
        {
            PackStrToAttr(pAttr+cAttr, SCRIPTPATH, pszScriptPath);
            cAttr++;
        }

        //
        // Change Package Help URL
        //
        if (pszUrl) 
        {
            if ( ! *pszUrl )
            {
                pszUrl = NULL;
            }
            
            PackStrToAttr(pAttr+cAttr, HELPURL, pszUrl);
            cAttr++;
        }
    
        //
        // Change Package UI Level.
        //
        if (pInstallUiLevel) 
        {
            PackDWToAttr (pAttr+cAttr, UILEVEL, *pInstallUiLevel);
            cAttr++;
        }

        //
        // Change Revision.
        //
        if (pdwRevision) 
        {
            PackDWToAttr (pAttr+cAttr, REVISION, *pdwRevision);
            cAttr++;
        }
    
        if (pszNewName)
        {
            PackStrToAttr(pAttr+cAttr, PACKAGENAME, pszNewName);
            cAttr++;

            // also set display name so outside tools can have a
            // friendly name
            PackStrToAttr(pAttr+cAttr, PKGDISPLAYNAME, pszNewName);
            cAttr++;
        }

        hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    }

    if (hADs)
        ADSICloseDSObject(hADs);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    if (SUCCEEDED(hr))
    {
        //
        // Update Class Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    if (szFullName)
        CsMemFree(szFullName);
    return RemapErrorCode(hr, m_szContainerName);
}
//---------------------------------------------------------------
//  Function:   ChangePackageCategories
//
//  Synopsis:   Change (Not Add) the Categories that a package
//              belongs to.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      cCategories
//              Number of Categories.
//      rpCategory
//              Array of categories.
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Converts all the categories to strings
//  Packs it and sends it to the DS.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageCategories(
                                                 LPOLESTR       pszPackageName,
                                                 UINT           cCategories,
                                                 GUID          *rpCategory
                                                 )
{
    //
    // Does not change USN
    //
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szFullName = NULL;
    LPOLESTR   *pszGuid = NULL;
    UINT        count;
    ADS_ATTR_INFO pAttr[1];
    DWORD       cAttr = 0, cModified = 0, i=0;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    if ((cCategories) && ((!rpCategory) ||
           (IsBadReadPtr(rpCategory, sizeof(GUID) * cCategories))))
        return E_INVALIDARG;

    // Construct the Name of the Package Object.

    GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
       
    hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(),
                          &hADs);
    ERROR_ON_FAILURE(hr);
    
    // fill in the categories
    pszGuid = (LPOLESTR *)CsMemAlloc(cCategories * sizeof(LPOLESTR));
    if (!pszGuid) 
    {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }
    
    // convert the GUIDs to Strings.
    for (count = 0; (count < cCategories); count++) 
    {
        pszGuid[count] = (LPOLESTR)CsMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
        
        if (!(pszGuid[count])) 
        {
            FREEARR(pszGuid, count);
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        }
        
        StringFromGUID(rpCategory[count], pszGuid[count]);
    }
    
    // Pack it into Attribute Structure.
    PackStrArrToAttr(pAttr+cAttr, PKGCATEGORYLIST, pszGuid, cCategories);
    cAttr++;
    
    // Set the Attribute
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    
Error_Cleanup:
    if (hADs)
        ADSICloseDSObject(hADs);
    
    if (pszGuid)
        for (count = 0; (count < cCategories); count++)
            CsMemFree(pszGuid[count]);
    
    CsMemFree(pszGuid);

    if (szFullName)
        CsMemFree(szFullName);

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//  Function:   SetPriorityByFileExt
//
//  Synopsis:   Changes the priority of a Package corresp. to
//              a file Extension.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      pszFileExt
//              File Extension for which the priority has to be changed.
//      Priority
//              Priority for the Package.
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Gets the file Extensions and changes
//  the priority corresponding to the File Extension.
//----------------------------------------------------------------
HRESULT CClassContainer::SetPriorityByFileExt(
                                              LPOLESTR pszPackageName,
                                              LPOLESTR pszFileExt,
                                              UINT     Priority
                                              )
{
    HRESULT       hr = S_OK;
    HANDLE        hADs = NULL;
    WCHAR        *szFullName=NULL;
    LPOLESTR     *prgFileExt = NULL;
    WCHAR         szUsn[20];
    ADS_ATTR_INFO pAttr[4], *pAttrGot = NULL;
    DWORD         cAttr = 0, cAttrGot = 0, cModified = 0, cShellFileExt = 0, i=0;
    LPOLESTR      pAttrNames[] = {PKGFILEEXTNLIST};
    
    // Construct the Package Name
    GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
        
    // Bind to the Package Object.
    hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(),
                          &hADs);
    ERROR_ON_FAILURE(hr);
    
    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    // get the file extensions.
    hr = ADSIGetObjectAttributes(hADs, pAttrNames, 1,  &pAttrGot,  &cAttrGot);    
    
    if  ((SUCCEEDED(hr)) && (cAttrGot))  
        UnpackStrArrFrom(pAttrGot[0], &prgFileExt, &cShellFileExt);
    
    // Look for the given file extension.
    for (i=0; i < cShellFileExt; ++i)
    {
        if (wcsncmp(prgFileExt[i], pszFileExt, wcslen(pszFileExt)) == 0)
        {
            // if the file extension is found, change the corresponding priority.
            if (wcslen(prgFileExt[i]) != (wcslen(pszFileExt)+3))
                continue;
            
            hr = StringCchPrintf(prgFileExt[i], wcslen(prgFileExt[i]) + 1, L"%s:%2d", pszFileExt, Priority%100);
            
            ERROR_ON_FAILURE(hr);
            
            break;
        }
    }
    
    if (i == cShellFileExt)
    {
        ERROR_ON_FAILURE(hr = CS_E_OBJECT_NOTFOUND);
    }
    
    if (cShellFileExt)
    {
        PackStrArrToAttr(pAttr+cAttr, PKGFILEEXTNLIST, prgFileExt, cShellFileExt);
        cAttr++;
    }
    
    hr = ADSISetObjectAttributes(hADs,  pAttr, cAttr,  &cModified);
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:    
    CsMemFree(prgFileExt);
    
    if (szFullName)
        CsMemFree(szFullName);

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    if (pAttrGot)
        FreeADsMem(pAttrGot);
    
    ADSICloseDSObject(hADs);
    
    return RemapErrorCode(hr, m_szContainerName);
}

//---------------------------------------------------------------
//  Function:   ChangePackageSourceList
//
//  Synopsis:   Changes the priority of a Package corresp. to
//              a file Extension.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      cSources
//              Number of sources
//      pszSourceList
//              List of sources
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Makes the new sourcelist with the order
// maintained.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageSourceList(
                                                LPOLESTR     pszPackageName,
                                                UINT         cSources,
                                                LPOLESTR    *pszSourceList
                                                )
{
    HRESULT     hr = S_OK;
    ULONG       ulSize;
    HANDLE      hADs = NULL;
    WCHAR      *szFullName = NULL;
    UINT        count;
    WCHAR       szUsn[20];
    LPOLESTR   *pszPrioritySourceList = NULL;
    ADS_ATTR_INFO pAttr[2];
    DWORD       cAttr = 0, cModified = 0, i=0;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    if ((!pszSourceList) ||
           (IsBadReadPtr(pszSourceList, sizeof(LPOLESTR) * cSources)))
        return E_INVALIDARG;
    
    for (count = 0; (count < cSources); count++) 
        if ((!pszSourceList[count]) || (IsBadStringPtr(pszSourceList[count], _MAX_PATH)))
            return E_INVALIDARG;

    // Construct the Name of the Package Object.
    GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
       
    hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(),
                          &hADs);
    ERROR_ON_FAILURE(hr);

    // Local variable for adding the order to the list.
    pszPrioritySourceList = (LPOLESTR *)CsMemAlloc(cSources * sizeof(LPOLESTR));
    if (!pszPrioritySourceList) 
    {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }

    // add the order to the list

    for (count = 0; (count < cSources); count++) 
    {
        ulSize = wcslen(pszSourceList[count])+1+1+1+NumDigits10(cSources);
        pszPrioritySourceList[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)* ulSize);
        
        if (!(pszPrioritySourceList[count])) 
        {
            FREEARR(pszPrioritySourceList, count);
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        }
        
        hr = StringCchPrintf(pszPrioritySourceList[count], ulSize, L"%d:%s", count, pszSourceList[count]);
        ERROR_ON_FAILURE(hr);
    }

    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;

    // Pack it into Attribute Structure.
    PackStrArrToAttr(pAttr+cAttr, MSIFILELIST, pszPrioritySourceList, cSources);
    cAttr++;
    
    // Set the Attribute
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    if (hADs)
        ADSICloseDSObject(hADs);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
   
    if (szFullName)
        CsMemFree(szFullName);

    return RemapErrorCode(hr, m_szContainerName);
}

//---------------------------------------------------------------
//  Function:   ChangePackageUpgradeList
//
//  Synopsis:   Changes the priority of a Package corresp. to
//              a file Extension.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      cSources
//              Number of sources
//      pszSourceList
//              List of sources
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Makes the new sourcelist with the order
// maintained.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageUpgradeList(
                                                LPOLESTR     pszPackageName,
                                                UINT         cUpgrades,
                                                UPGRADEINFO *prgUpgradeInfoList
                                                )
{
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szFullName = NULL;
    UINT        count = 0, count1 = 0, count2 = 0;
    LPOLESTR   *pProp = NULL, pAttrNames[] = {UPGRADESPACKAGES, OBJECTGUID, PACKAGEFLAGS}, *rpszUpgrades = NULL;
    ADS_ATTR_INFO pAttr[3], *pAttrGot = NULL;
    DWORD       cAttr = 0, cModified = 0, i=0, posn = 0, cUpgradeInfoStored = 0,
                cAddList = 0, cRemoveList = 0, cgot = 0;
    GUID        PkgGuid;
    WCHAR       szUsn[20];
    UPGRADEINFO *pUpgradeInfoStored = NULL, *pAddList = NULL, *pRemoveList = NULL;
    DWORD       dwPackageFlags;

    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    if ((cUpgrades) && ((!prgUpgradeInfoList) ||
           (IsBadReadPtr(prgUpgradeInfoList, sizeof(UPGRADEINFO) * cUpgrades))))
        return E_INVALIDARG;

    for (count = 0; (count < cUpgrades); count++)
    {
        if ((!(prgUpgradeInfoList[count].szClassStore)) || 
            IsBadStringPtr((prgUpgradeInfoList[count].szClassStore), _MAX_PATH))
            return E_INVALIDARG;

        if (IsNullGuid(prgUpgradeInfoList[count].PackageGuid))
            return E_INVALIDARG;

        if (((prgUpgradeInfoList[count].Flag & UPGFLG_Uninstall) == 0) &&
            ((prgUpgradeInfoList[count].Flag & UPGFLG_NoUninstall) == 0) &&
            ((prgUpgradeInfoList[count].Flag & UPGFLG_UpgradedBy) == 0))
            return E_INVALIDARG;      
    }    

    // Construct the Name of the Package Object.
    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);
    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
    
    hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(),
                          &hADs);
    ERROR_ON_FAILURE(hr);
   
    // get the guid and upgrade info
    hr = ADSIGetObjectAttributes(hADs, pAttrNames, 3,  &pAttrGot,  &cgot);    
    ERROR_ON_FAILURE(hr);
    
    // Package guid
    posn = GetPropertyFromAttr(pAttrGot, cgot, OBJECTGUID);
    if (posn < cgot)
        UnpackGUIDFrom(pAttrGot[posn], &PkgGuid);

    // Upgrade package
    posn = GetPropertyFromAttr(pAttrGot, cgot, UPGRADESPACKAGES);
    if (posn < cgot)
        UnpackStrArrFrom(pAttrGot[posn], &pProp, &cUpgradeInfoStored);

    // Package Flags
    posn = GetPropertyFromAttr(pAttrGot, cgot, PACKAGEFLAGS);
    if (posn < cgot)
        UnpackDWFrom(pAttrGot[posn], (DWORD *)&dwPackageFlags);

    // allocating the lists
    pUpgradeInfoStored = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*(cUpgradeInfoStored));
    pAddList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*(cUpgrades+cUpgradeInfoStored));
    pRemoveList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*(cUpgrades+cUpgradeInfoStored));

    if ((!pUpgradeInfoStored) || (!pAddList) || (!pRemoveList))
        ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);

    // convert the strings to upgradinfo structures.
    for (count = 0; count < (cUpgradeInfoStored); count++)
    {
        WCHAR *pStr = NULL;
        LPOLESTR ptr = pProp[count];
        UINT len = wcslen (ptr);
            
        pUpgradeInfoStored[count].szClassStore = pProp[count];

        if (len <= 41)
            continue;

        *(ptr + len - 3) = NULL;
        pUpgradeInfoStored[count].Flag = wcstoul(ptr+(len-2), &pStr, 16);

        *(ptr + len - 3 - 36 - 2) = L'\0';
        /*      -GUID-'::'*/
        GUIDFromString(ptr+len-3-36, &(pUpgradeInfoStored[count].PackageGuid));        
    }

    cUpgradeInfoStored = count; // we might have skipped some.

    // AddList formed.
    for (count = 0; count < cUpgrades; count++)
    {
        for (count1 = 0; count1 < cUpgradeInfoStored; count1++)
        {
            // ignore flag changes
            if ((wcscmp(pUpgradeInfoStored[count1].szClassStore, prgUpgradeInfoList[count].szClassStore) == 0) && 
                (memcmp(&pUpgradeInfoStored[count1].PackageGuid, &prgUpgradeInfoList[count].PackageGuid, sizeof(GUID)) == 0))
                break;
        }

        if (count1 == cUpgradeInfoStored)
            pAddList[cAddList++] = prgUpgradeInfoList[count];
    }

    // remove list formed.
    for (count1 = 0; count1 < cUpgradeInfoStored; count1++)
    {
        for (count = 0; count < cUpgrades; count++)
        {
            // ignore flag changes
            if ((wcscmp(pUpgradeInfoStored[count1].szClassStore, prgUpgradeInfoList[count].szClassStore) == 0) && 
                (memcmp(&pUpgradeInfoStored[count1].PackageGuid, &prgUpgradeInfoList[count].PackageGuid, sizeof(GUID)) == 0))
                break;
        }

        if (count == cUpgrades)
            pRemoveList[cRemoveList++] = pUpgradeInfoStored[count];
    }

    for (count = 0; count < cAddList; count++)
    {
        // in case of UpgradedBy do no try to fix up the links.
        if (!(pAddList[count].Flag & UPGFLG_UpgradedBy))
        {            
            DWORD   Flags = 0;
            if (pAddList[count].Flag & UPGFLG_Enforced)
                Flags = UPGFLG_Enforced;
        }
    }

    for (count = 0; count < cRemoveList; count++)
    {
        // in case of UpgradedBy do no try to fix up the links.
        if (!(pRemoveList[count].Flag  & UPGFLG_UpgradedBy))
        {            
            DWORD   Flags = 0;
            if (pRemoveList[count].Flag & UPGFLG_Enforced)
                Flags = UPGFLG_Enforced;
        }
    }

    rpszUpgrades = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*cUpgrades);
    if (!rpszUpgrades)
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

    for (count = 0; (count < cUpgrades); count++) 
    {
        WCHAR szPackageGuid[_MAX_PATH];
        UINT len = wcslen(prgUpgradeInfoList[count].szClassStore);
        ULONG ulSize = 36+PKG_UPG_DELIM1_LEN+len+PKG_UPG_DELIM2_LEN+2+2;

        rpszUpgrades[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR) *ulSize);
                                                           // Guid size+::+length++:+flagDigit+2 
        if (!rpszUpgrades[count])
        {
            FREEARR(rpszUpgrades, count);  
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        }

        StringFromGUID(prgUpgradeInfoList[count].PackageGuid, szPackageGuid);
        hr = StringCchPrintf(rpszUpgrades[count], ulSize, L"%s%s%s%s%02x", prgUpgradeInfoList[count].szClassStore, PKG_UPG_DELIMITER1, szPackageGuid,
                             PKG_UPG_DELIMITER2, prgUpgradeInfoList[count].Flag%16);
        ERROR_ON_FAILURE(hr);
    }

    PackStrArrToAttr(pAttr+cAttr, UPGRADESPACKAGES, rpszUpgrades, cUpgrades); 
    cAttr++;

    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;

    //
    // Update the package flags -- this call will make sure the
    // ugprade flag is set if there are upgrades, clear if not
    //
    hr = GetConsistentPackageFlags(
        NULL,
        &dwPackageFlags,
        &cUpgrades,
        NULL,
        NULL,
        &dwPackageFlags,
        NULL);

    ERROR_ON_FAILURE(hr);

    PackDWToAttr (pAttr+cAttr, PACKAGEFLAGS,
                  dwPackageFlags);
    cAttr++;

    // Set the Attribute
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    if (hADs)
        ADSICloseDSObject(hADs);

    if (szFullName)
        CsMemFree(szFullName);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);

    if (pAttrGot)
        FreeADsMem(pAttrGot);

    if (pProp)
        CsMemFree(pProp);

    if (pUpgradeInfoStored)
        CsMemFree(pUpgradeInfoStored);
    
    if (pAddList) 
        CsMemFree(pAddList);
    
    if (pRemoveList)
        CsMemFree(pRemoveList);

    return RemapErrorCode(hr, m_szContainerName);
}


extern LPOLESTR szAppCategoryColumns;

//---------------------------------------------------------------
//  Function:   GetAppCategories
//
//  Synopsis:   gets the list of Package Categories in the Domain.
//
//  Arguments:
//  [in]    
//      Locale
//              Locale for the categories. Used to get the description.
//  [out]
//      pAppCategoryList
//              the list of Application Categories in the domain
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Gets the FullName of the Domain, binds to the AppCategory container
//  below that. and gets all the categories with approp. types.
//----------------------------------------------------------------

HRESULT CClassContainer::GetAppCategories (
                                           LCID                  Locale,
                                           APPCATEGORYINFOLIST  *pAppCategoryList
                                           )
{
    HRESULT             hr = S_OK;
    WCHAR               szfilter[_MAX_PATH];
    WCHAR               szRootPath[_MAX_PATH], szAppCategoryContainer[_MAX_PATH];
    HANDLE              hADs = NULL;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    WCHAR*              szContainerNameForErrorReport;

    // set the search preference.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    // we do not expect too many categories
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = SEARCHPAGESIZE;
    
    if (IsBadWritePtr(pAppCategoryList, sizeof(APPCATEGORYINFOLIST)))
        return E_INVALIDARG;

    // If an error occurs here, we assume it occurred at the domain root
    szContainerNameForErrorReport = L"LDAP://rootdse";

    // get the name of the domain.
    hr = GetRootPath(NULL, szRootPath, _MAX_PATH);
    ERROR_ON_FAILURE(hr);

    // Names returned by GetRootPath are in only 1 format and we don't need to
    // use BuildADsPath.
    hr = StringCchPrintf(szAppCategoryContainer, _MAX_PATH, L"%s%s%s", LDAPPREFIX, APPCATEGORYCONTAINERNAME, 
                                                        szRootPath+LDAPPREFIXLENGTH);

    ERROR_ON_FAILURE(hr);

    // If an error occurs now, we use the name of the category container
    szContainerNameForErrorReport = szAppCategoryContainer;
    
    hr = StringCchPrintf(szfilter, _MAX_PATH, L"(objectClass=%s)", CLASS_CS_CATEGORY);
    ERROR_ON_FAILURE(hr);
    
    //
    // We use the secure option in the bind below because this can get called
    // in client policy context (outside of the admin tool)
    //

    //binds to the category container
    hr = DSServerOpenDSObject(&m_ServerContext, szAppCategoryContainer,
                                                GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);
    
    hr = ADSISetSearchPreference(hADs, SearchPrefs, 2);
    ERROR_ON_FAILURE(hr);
    
    // gets a search handle
    hr = ADSIExecuteSearch(hADs, szfilter, pszCategoryAttrNames, cCategoryAttr, &hADsSearchHandle);
    ERROR_ON_FAILURE(hr);
    
    //
    // Retrieve the list of categories from the search
    // if successful, memory will be allocated for the category list
    //
    hr = FetchCategory(hADs, hADsSearchHandle, pAppCategoryList, Locale);
    ERROR_ON_FAILURE(hr);
    
Error_Cleanup:
    
    if (hADsSearchHandle)
        ADSICloseSearchHandle(hADs, hADsSearchHandle);

    if (hADs)
        ADSICloseDSObject(hADs);
    return RemapErrorCode(hr, szAppCategoryContainer);
}

//---------------------------------------------------------------
//  Function:   RegisterAppCategory
//
//  Synopsis:   Adda category and assoc desc. for the whole Domain(This is per domain
//              and not per class store.)
//
//  Arguments:
//  [in]    
//      pAppCategory
//              Pointer to a APPCATEGORYINFO structure to be added.
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Finds the root path of the domain. binds to the category container
//  underneath it. deletes this particular AppCategory.
//----------------------------------------------------------------
HRESULT CClassContainer::RegisterAppCategory (
                                              APPCATEGORYINFO    *pAppCategory
                                              )
{
    WCHAR           szRootPath[_MAX_PATH], localedescription[128+16],
                    szAppCategoryContainer[_MAX_PATH], szRDN[_MAX_PATH],
                  * szFullName = NULL, szAppCatid[_MAX_PATH];

    HRESULT         hr = S_OK;
    HANDLE          hADsContainer = NULL, hADs = NULL;
    ULONG           i, j, cdesc = 0, posn = 0;
    LPOLESTR      * pszDescExisting = NULL, pszDesc = NULL;
    LPOLESTR        AttrName = LOCALEDESCRIPTION;
    ADS_ATTR_INFO * pAttrGot = NULL, pAttr[6];
    DWORD           cgot = 0, cAttr = 0;
    BOOL            fExists = TRUE;
    
    if ((!pAppCategory) || (IsBadReadPtr(pAppCategory, sizeof(APPCATEGORYINFO))))
        return E_INVALIDARG;
    
    if ((pAppCategory->pszDescription == NULL) || 
        (IsBadStringPtr(pAppCategory->pszDescription, _MAX_PATH)))
        return E_INVALIDARG;
    
    if (IsNullGuid(pAppCategory->AppCategoryId))
        return E_INVALIDARG;
    
    //
    // Enforce the maximum category description size
    //
    if ( wcslen(pAppCategory->pszDescription) > CAT_DESC_MAX_LEN )
    {
        return E_INVALIDARG;
    }

    // get the name of the root of the domain
    hr = GetRootPath(NULL, szRootPath, _MAX_PATH);
    ERROR_ON_FAILURE(hr);
    
    // Bind to a AppCategory container
    
    // Names returned by GetRootPath are in only 1 format and we don't need to
    // use BuildADsPath.
    
    hr = StringCchPrintf(szAppCategoryContainer, _MAX_PATH, L"%s%s%s", LDAPPREFIX, APPCATEGORYCONTAINERNAME, 
        szRootPath+LDAPPREFIXLENGTH);

    ERROR_ON_FAILURE(hr);
    
    // container is supposed to exist.
    hr = DSServerOpenDSObject(&m_ServerContext, szAppCategoryContainer, GetDsFlags(),
                          &hADsContainer);
    ERROR_ON_FAILURE(hr);


    RDNFromGUID(pAppCategory->AppCategoryId, szRDN);
    
    hr = StringCchPrintf(localedescription, 128+16, L"%x %s %s", pAppCategory->Locale, CAT_DESC_DELIMITER,
        pAppCategory->pszDescription);
    ERROR_ON_FAILURE(hr);

    
    BuildADsPathFromParent(szAppCategoryContainer, szRDN, &szFullName);
    
    hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(), &hADs);
    
    if (SUCCEEDED(hr))
        hr = ADSIGetObjectAttributes(hADs, &AttrName, 1, &pAttrGot, &cgot);

    if (SUCCEEDED(hr))
    {
        fExists = TRUE;
    }
    else 
    {
        fExists = FALSE;
        PackStrToAttr(pAttr, OBJECTCLASS, CLASS_CS_CATEGORY); cAttr++;
        
        PackGUIDToAttr(pAttr+cAttr, CATEGORYCATID, &(pAppCategory->AppCategoryId)); cAttr++;
        
        hr = ADSICreateDSObject(hADsContainer, szRDN, pAttr, cAttr);
        
        for (j = 0; j < cAttr; j++)
            FreeAttr(pAttr[j]);
        cAttr = 0;
        
        if (hADs)
        {
            ADSICloseDSObject(hADs);
            hADs = NULL;
        }
        hr = DSServerOpenDSObject(&m_ServerContext, szFullName, GetDsFlags(), &hADs);
    }
    
    if (szFullName)
        FreeADsMem(szFullName);
    
    ERROR_ON_FAILURE(hr);
    
    if (fExists) {
        if (cgot) 
        {
            UnpackStrArrFrom(pAttrGot[0], &pszDescExisting, &cdesc);
        }
        
        // Existing list of descriptions
        if (posn = FindDescription(pszDescExisting, cdesc, &(pAppCategory->Locale), NULL, 0))
        {   // Delete the old value
            PackStrArrToAttrEx(pAttr+cAttr, LOCALEDESCRIPTION, pszDescExisting+(posn-1), 1, FALSE); cAttr++;
        }
        CsMemFree(pszDescExisting);
    }
    
    pszDesc = localedescription;
    
    PackStrArrToAttrEx(pAttr+cAttr, LOCALEDESCRIPTION, &pszDesc, 1, TRUE);
    cAttr++;
    
    DWORD cModified;
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr, &cModified);
    
Error_Cleanup:
    
    if (pAttrGot)
        FreeADsMem(pAttrGot);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    if (hADs)
        ADSICloseDSObject(hADs);
    
    if (hADsContainer)
        ADSICloseDSObject(hADsContainer);
    
    return RemapErrorCode(hr, m_szContainerName);
}



//---------------------------------------------------------------
//  Function:   UnregisterAppCategory
//
//  Synopsis:   Removes a category from the whole Domain(This is per domain)
//              and not per class store.
//
//  Arguments:
//  [in]    
//      pAppCategoryId
//              Pointer to a GUID that has to be removed.
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Finds the root path of the domain. binds to the category container
//  underneath it. deletes this particular AppCategory.
//----------------------------------------------------------------
HRESULT CClassContainer::UnregisterAppCategory (
                                                GUID         *pAppCategoryId
                                                )
{
    WCHAR           szRootPath[_MAX_PATH], szRDN[_MAX_PATH],
                    szAppCategoryContainer[_MAX_PATH];
    HRESULT         hr = S_OK;
    HANDLE          hADs = NULL;
    
    if (IsBadReadPtr(pAppCategoryId, sizeof(GUID)))
        return E_INVALIDARG;
    
    hr = GetRootPath(NULL, szRootPath, _MAX_PATH);
    // Bind to a AppCategory container
    
    // Names returned by GetRootPath are in only 1 format and we don't need to
    // use BuildADsPath.
    
    hr = StringCchPrintf(szAppCategoryContainer, _MAX_PATH, L"%s%s%s", LDAPPREFIX, APPCATEGORYCONTAINERNAME, 
                         szRootPath+LDAPPREFIXLENGTH);

    ERROR_ON_FAILURE(hr);
    
    hr = DSServerOpenDSObject(&m_ServerContext, szAppCategoryContainer, GetDsFlags(),
                            &hADs);
    
    ERROR_ON_FAILURE(hr);
    
    RDNFromGUID(*pAppCategoryId, szRDN);
    
    hr = ADSIDeleteDSObject(hADs, szRDN);
    
    ADSICloseDSObject(hADs);
    
    // Delete this category
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//  Function:   DeletePackage
//
//  Synopsis:   Permanently remove a package and the associated Classes 
//              from class store
//
//  Arguments:
//  [in]    
//      PackageGuid
//              Guid of the package that has to be removed.
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Deletes the package.
//  Tries to delete all the upgrade relationships from this package.
//  Errors are ignored.
//----------------------------------------------------------------
HRESULT CClassContainer::DeletePackage (LPOLESTR    szFullName
                                        )
{
    HRESULT         hr = S_OK;
    DWORD           cStr = 0, count = 0, cgot = 0, posn = 0;
    LPOLESTR        szRDN = NULL, szJunk = NULL;
    LPOLESTR      * szStr = NULL;
    LPOLESTR        pAttrName[] = {UPGRADESPACKAGES, OBJECTGUID, SCRIPTPATH};
    LPOLESTR        szScriptPath;
    ADS_ATTR_INFO * pAttr = NULL;
    HANDLE          hADs = NULL;
    WCHAR           szUsn[20];
    GUID            PackageGuid;

    
    hr = DSServerOpenDSObject(&m_ServerContext, szFullName, GetDsFlags(),
                            &hADs);
    
    if (!SUCCEEDED(hr))
        return hr;
    
    GetCurrentUsn(szUsn);
    
    hr = ADSIGetObjectAttributes(
        hADs,
        pAttrName,
        sizeof(pAttrName) / sizeof(pAttrName[0]),
        &pAttr, &cgot);

    memset(&PackageGuid, 0, sizeof(GUID));
    posn = GetPropertyFromAttr(pAttr, cgot,  OBJECTGUID);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &PackageGuid);

    posn = GetPropertyFromAttr(pAttr, cgot,  SCRIPTPATH);
    if (posn < cgot)
    {
        UnpackStrFrom(pAttr[posn], &szScriptPath);
        
        if (szScriptPath)
        {
            BOOL fDeleted;

            fDeleted = DeleteFile(szScriptPath);
            
            CSDBGPrint((DM_WARNING,
                        IDS_CSTORE_DELETESCRIPT,
                        szScriptPath,
                        fDeleted ? ERROR_SUCCESS : GetLastError()));
        }
            
    }

    posn = GetPropertyFromAttr(pAttr, cgot, UPGRADESPACKAGES);
    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn],  &szStr, &cStr);

    for (count = 0; count < cStr; count++)
    {
        GUID        UpgradeeGuid;
        WCHAR      *pStr = NULL;
        LPOLESTR    ptr = szStr[count];
        UINT        len = wcslen (ptr);
        DWORD       UpgradeFlag, Flags = 0;

        if (len <= 41)
            continue;

        *(ptr + (len - 3)) = NULL;
                    
        UpgradeFlag = wcstoul(ptr+(len-2), &pStr, 16);

        *(ptr + (len - 3 - 36 - 2)) = L'\0';
                 /*      -GUID-'::'*/
        GUIDFromString(ptr+len-3-36, &UpgradeeGuid);
    
        if (UpgradeFlag & UPGFLG_Enforced)
            Flags = UPGFLG_Enforced;

    }
    
    if (szStr)
        CsMemFree(szStr);
    szStr = NULL;
    cStr = 0;

    // ignore errors
    if (pAttr)
        FreeADsMem(pAttr);
    
    ADSICloseDSObject(hADs);
    
    BuildADsParentPath(szFullName, &szJunk, &szRDN);
    
    if (szJunk)
        FreeADsMem(szJunk);

    hr = ADSIDeleteDSObject(m_ADsPackageContainer, szRDN);
    if (szRDN)
        FreeADsMem(szRDN);

    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    return hr;
}

//---------------------------------------------------------------
//  Function:   RemovePackage
//
//  Synopsis:   Mark a package as disabled or orphaned
//              Or permanently remove a package and the associated Classes 
//              from class store
//
//  Arguments:
//  [in]    
//      PackageGuid
//              Guid of the package that has to be removed.
//  [in]
//      dwFlags
//              The new flags for the package. To delete the package explicitly
//              use flag zero or orphan.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Calls Delete package if the flags is zero or Orphan.
//  Otherwise it sets the new flags and stamps the new time stamp.
//----------------------------------------------------------------
HRESULT CClassContainer::RemovePackage (
                                        LPOLESTR       pszPackageName,
                                        DWORD          dwFlags
                                        )
{
    HRESULT         hr = S_OK;
    WCHAR          *szRDN = NULL, *szFullName = NULL;
    HANDLE          hADs = NULL;
    WCHAR           szUsn[20];
    ADS_ATTR_INFO   pAttr[7];
    DWORD           cAttr = 0, cModified = 0, i=0;

    if ((dwFlags != 0) && !(dwFlags & ACTFLG_Orphan) && !(dwFlags & ACTFLG_Uninstall))
        return E_INVALIDARG;
    
    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;

    if (dwFlags == 0)
        // delete the package from the class store
    {
        hr = DeletePackage(szFullName);
    }
    else
    {
        GUID    NewPackageId;
        WCHAR   szNewRDN[_MAX_PATH], *szJunk = NULL;
        DWORD   dwPackageFlags;
        WCHAR   wszSearchFlags[MAX_SEARCH_FLAGS];
        //
        // PackageName is unchanged.
        //
        GetCurrentUsn(szUsn);

        // Bind to the Package Object.
        hr = DSServerOpenDSObject(&m_ServerContext, szFullName, GetDsFlags(), &hADs);
        ERROR_ON_FAILURE(hr);

        //
        // We use GetConsistentPackageFlags so that we can add in one flag without
        // resetting the existing flags in the attribute.
        //
        hr = GetConsistentPackageFlags(
            hADs,
            &dwFlags,
            NULL,
            NULL,
            NULL,
            &dwPackageFlags,
            wszSearchFlags);

        ERROR_ON_FAILURE(hr);

        // setting the flag as orphan/uninstall
        PackDWToAttr (pAttr+cAttr, PACKAGEFLAGS, dwPackageFlags);
        cAttr++;

        if (*wszSearchFlags) 
        {
            PackStrToAttr(pAttr+cAttr, SEARCHFLAGS, wszSearchFlags);
            cAttr++;
        }
        
        // stamping the modification time for cleanup later.
        PackStrToAttr (pAttr+cAttr, PKGUSN, szUsn);
        cAttr++;
        
        hr = ADSISetObjectAttributes(hADs, pAttr, cAttr, &cModified);
        
        if (hADs)
            ADSICloseDSObject(hADs);
        
        for (i = 0; i < cAttr; i++)
            FreeAttr(pAttr[i]);
        
        if (SUCCEEDED(hr))
        {
            //
            // Update Class Store Usn
            //
            UpdateStoreUsn(m_ADsContainer, szUsn);
        }
    }
        
Error_Cleanup:
    if (szFullName)
        CsMemFree(szFullName);

    return RemapErrorCode(hr, m_szContainerName);
}

// Merges list1 and List2 into ResList removing duplicates.
HRESULT MergePropList(LPOLESTR    *List1,  DWORD   cList1,
                   LPOLESTR    *List2,  DWORD   cList2,
                   LPOLESTR   **ResList,DWORD  *cResList)
{
    DWORD i, j;
    
    *cResList = 0;
    *ResList = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*(cList1+cList2));
    if (!*ResList)
        return E_OUTOFMEMORY;

    for (i = 0; i < cList1; i++)
        (*ResList)[i] = List1[i];
    
    for (i = 0; i < cList2; i++) {
        for (j = 0; j < cList1; j++)
            if (wcscmp((*ResList)[j], List2[i]) == 0)
                break;
            
            if (j == cList1)
                (*ResList)[(*cResList)++] = List2[i];
    }

    return S_OK;
}


#define SCRIPT_IN_DIRECTORY    256

//---------------------------------------------------------------
//  Function:   RedeployPackage
//
//  Synopsis:   Redeploys an package object in the DS with new
//              package detail information
//
//  Arguments:
//
//  [in] 
//      pPackageGuid
//              Points to a guid indicating the package we wish
//              to redeploy
//
//  [in]
//      pPackageDetail
//              Pointer to a PACKAGEDETAIL info for this package
//              The various validations that is done is documented
//              in associated class store doc.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Validates the packagedetail structure. Packs ADS_ATTR_INFO structure with
//  the values and sets those attributes on the existing object in the ds.
//  If this returns an error the existing package is unaffected.
//
//----------------------------------------------------------------
HRESULT CClassContainer::RedeployPackage (
    GUID* pPackageGuid,
    PACKAGEDETAIL *pPackageDetail
    )
{
    HANDLE  hExistingPackage;
    HRESULT hr;
    WCHAR*  szFullName;

    hExistingPackage = NULL;
    szFullName = NULL;

    //
    // First, get the dn for the existing package
    //
    hr = BuildDNFromPackageGuid(*pPackageGuid, &szFullName);
    ERROR_ON_FAILURE(hr);
    
    //
    // Bind to the existing package
    //
    hr = DSServerOpenDSObject( &m_ServerContext,
        szFullName,
        GetDsFlags(),
        &hExistingPackage);

    ERROR_ON_FAILURE(hr);

    //
    // Now we can redeploy it with the new package detail. We
    // pass in a NULL package guid param because we won't
    // be changing the package id.
    //
    hr = DeployPackage(
        hExistingPackage,
        pPackageDetail,
        NULL);

Error_Cleanup:

    if (szFullName)
    {
        CsMemFree(szFullName);
    }
    
    if (hExistingPackage)
    {
        ADSICloseDSObject(hExistingPackage);
    }

    return hr;
}

//---------------------------------------------------------------
//  Function:   AddPackage
//
//  Synopsis:   Adds a package object in the DS.
//
//  Arguments:
//  [out]    
//      pszPackageId
//              An Id that is returned corresponding to the package.
//  [in]
//      pPackageDetail
//              Pointer to a PACKAGEDETAIL info for this package
//              The various validations that is done is documented
//              in associated class store doc.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Validates the packagedetail structure. Packs ADS_ATTR_INFO structure with
//  the values and tries to create the object in the DS.
//  If this returns error
//                     the whole package is removed.
//----------------------------------------------------------------
HRESULT CClassContainer::AddPackage (
                                     PACKAGEDETAIL *pPackageDetail,
                                     GUID          *pPkgGuid
                                     )
{

    //
    // Validate parameters specific to AddPackage, then
    // let the DeployPackage function do the rest of the validation
    // common between this and other methods that use it
    //
    if (!pPkgGuid || IsBadReadPtr(pPkgGuid, sizeof(GUID)))
    {
        return E_INVALIDARG;
    }


    return DeployPackage(
        NULL,               // create a new package
        pPackageDetail,
        pPkgGuid);
}

//---------------------------------------------------------------
//  Function:   DeployPackage
//
//  Synopsis:   Deploys a package object in the DS.
//
//  Arguments:
//  [in]       
//      hExistingPackage 
//              Handle to an existing package to redeploy.  If NULL,
//              a new package is created 
//                
//  [out]    
//      pszPackageId
//              An Id that is returned corresponding to a new package.
//              Must be specified if hExistingPackage is NULL.  Not set
//              on return of hExistingPackage is non-NULL.
//
//  [in]
//      pPackageDetail
//              Pointer to a PACKAGEDETAIL info for this package
//              The various validations that is done is documented
//              in associated class store doc.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Validates the packagedetail structure. Packs ADS_ATTR_INFO structure with
//  the values and tries to create and / or set attributes
//  for the package the object in the DS.
//  If this returns error when creating a new package, the whole package is removed.
//  If this returns error when redeploying an existing package, the existing 
//  package is unaffected.
//----------------------------------------------------------------
HRESULT CClassContainer::DeployPackage(
    HANDLE        hExistingPackage,
    PACKAGEDETAIL *pPackageDetail,
    GUID          *pPkgGuid
    )
{
    HRESULT             hr = S_OK;
    WCHAR               szRDN [_MAX_PATH];
    LPOLESTR          * pszGuid1 = NULL, *pszGuid2 = NULL,
                      * pszGuid3 = NULL, *pszGuid4 = NULL,
                      * pszProgId = NULL, *pszFileExt = NULL,
                      * rpszUpgrades = NULL, *rpszSources = NULL,
                        szPackageId = NULL, szJunk = NULL;

    DWORD             * pdwArch=NULL, count = 0, cPackProgId = 0;
    ADS_ATTR_INFO       pAttr[30]; 
    DWORD               cAttr = 0;
    WCHAR               szUsn[20];
    BOOL                fPackageCreated = FALSE, GenerateGuid = FALSE;
    GUID                PackageGuidId;
    DWORD               dwPersistedPackageFlags;
    WCHAR               wszSearchFlags[MAX_SEARCH_FLAGS];
    BOOL                bCreateNewPackage;
    
    bCreateNewPackage = hExistingPackage ? FALSE : TRUE;

    if ((!(pPackageDetail->pszPackageName)) || 
                IsBadStringPtr((pPackageDetail->pszPackageName), _MAX_PATH))
        return E_INVALIDARG;


    if (!pPackageDetail)
        return E_INVALIDARG;
    
    if (IsBadReadPtr(pPackageDetail, sizeof(PACKAGEDETAIL)))
        return E_INVALIDARG;
    
    // validating ActivationInfo.
    if (pPackageDetail->pActInfo)
    {    
        if (IsBadReadPtr(pPackageDetail->pActInfo, sizeof(ACTIVATIONINFO)))
            return E_INVALIDARG;
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->pClasses,
            sizeof(CLASSDETAIL) * (pPackageDetail->pActInfo->cClasses)))
            return E_INVALIDARG;

        // validating classdetail
        for (count = 0; (count < (pPackageDetail->pActInfo->cClasses)); count++)
        {
            CLASSDETAIL *pClassDetail = (pPackageDetail->pActInfo->pClasses)+count;
            if (IsNullGuid(pClassDetail->Clsid))
               return E_INVALIDARG;

            for (DWORD count1 = 0; (count1 < (pClassDetail->cProgId)); count1++)
            {
                // if profid is NULL or an empty string.
                if ((!((pClassDetail->prgProgId)[count1])) || 
                    (!((pClassDetail->prgProgId)[count1][0])))
                    return E_INVALIDARG;
            }
        }
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->prgShellFileExt,
            sizeof(LPOLESTR) * (pPackageDetail->pActInfo->cShellFileExt)))
            return E_INVALIDARG;
        
        for (count = 0; count < (pPackageDetail->pActInfo->cShellFileExt); count++)
        {
            if (!pPackageDetail->pActInfo->prgShellFileExt[count])
                return E_INVALIDARG;
        }
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->prgPriority,
            sizeof(UINT) * (pPackageDetail->pActInfo->cShellFileExt)))
            return E_INVALIDARG;
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->prgInterfaceId,
            sizeof(IID) * (pPackageDetail->pActInfo->cInterfaces)))
            return E_INVALIDARG;
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->prgTlbId,
            sizeof(GUID) * (pPackageDetail->pActInfo->cTypeLib)))
            return E_INVALIDARG;
    }
    
    // Validating InstallInfo
    if ((pPackageDetail->pInstallInfo == NULL) || 
        (IsBadReadPtr(pPackageDetail->pInstallInfo, sizeof(INSTALLINFO)))
        )
        return E_INVALIDARG;

    //
    // Only validate the product code if we expect one to be
    // supplied -- this is only the case if this is a Windows
    // Installer package, other deployments will not have
    // a product code
    //
    if ( DrwFilePath == pPackageDetail->pInstallInfo->PathType )
    {
        if (IsNullGuid(pPackageDetail->pInstallInfo->ProductCode))
            return E_INVALIDARG;
    }

    if (IsBadReadPtr(pPackageDetail->pInstallInfo->prgUpgradeInfoList, 
        sizeof(UPGRADEINFO)*(pPackageDetail->pInstallInfo->cUpgrades)))
        return E_INVALIDARG;
    
    for (count = 0; count < (pPackageDetail->pInstallInfo->cUpgrades); count++)
    {
        if ((!(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore)) || 
            IsBadStringPtr((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore), _MAX_PATH))
            return E_INVALIDARG;

        if (IsNullGuid(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].PackageGuid))
            return E_INVALIDARG;

        if (((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_Uninstall) == 0) &&
            ((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_NoUninstall) == 0) &&
            ((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_UpgradedBy) == 0))
            return E_INVALIDARG;      
    }    
    
    // validating PlatformInfo    
    
    if ((pPackageDetail->pPlatformInfo == NULL) || 
        (IsBadReadPtr(pPackageDetail->pPlatformInfo, sizeof(PLATFORMINFO)))
        )
        return E_INVALIDARG;
    
    if (IsBadReadPtr(pPackageDetail->pPlatformInfo->prgPlatform,
        sizeof(CSPLATFORM) * (pPackageDetail->pPlatformInfo->cPlatforms)))
        return E_INVALIDARG;
    
    if ((pPackageDetail->pPlatformInfo->cLocales == 0) ||
        (pPackageDetail->pPlatformInfo->cPlatforms == 0))
        return E_INVALIDARG;
    
    if (IsBadReadPtr(pPackageDetail->pPlatformInfo->prgLocale,
        sizeof(LCID) * (pPackageDetail->pPlatformInfo->cLocales)))
        return E_INVALIDARG;
    
    // validating InstallInfo
    
    // Validating other fields in PackageDetail structure
    
    if ((pPackageDetail->pszSourceList == NULL) ||
        (IsBadReadPtr(pPackageDetail->pszSourceList,
        sizeof(LPOLESTR) * (pPackageDetail->cSources))))
        return E_INVALIDARG;
    
    for (count = 0; count < (pPackageDetail->cSources); count++)
    {
        if ((!pPackageDetail->pszSourceList[count]) || 
                        (IsBadStringPtr(pPackageDetail->pszSourceList[count], _MAX_PATH)))
            return E_INVALIDARG;
    }
    
    if (pPackageDetail->rpCategory)
    {
        if (IsBadReadPtr(pPackageDetail->rpCategory,
            sizeof(GUID) * (pPackageDetail->cCategories)))
            return E_INVALIDARG;
    }

    // If the restrictions are too constrictive then we should go to
    // the DS, to see whether it is a valid name or not. till then..

    hr = GetDNFromPackageName(pPackageDetail->pszPackageName, &szJunk);
    if (szJunk)
        CsMemFree(szJunk);

    if (FAILED(hr))
        return RemapErrorCode(hr, m_szContainerName);

    //
    // We expect this to return S_ADS_NOMORE_ROWS if the package doesn't
    // exist, otherwise it returns S_OK -- we can use this to determine
    // if the package exists already (we care only if we're trying to 
    // create a new package)
    //
    if ( bCreateNewPackage && (hr == S_OK))
    {
        return CS_E_OBJECT_ALREADY_EXISTS;
    }
    else
    {
        ASSERT( bCreateNewPackage || (S_ADS_NOMORE_ROWS == hr) || ( hExistingPackage && (hr == S_OK) ) );
    }

    szPackageId = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*41);

    if (!(szPackageId))
        return E_OUTOFMEMORY;

    memset(&PackageGuidId, 0, sizeof(GUID));

    //
    // generate guid if we are creating a new package -- otherwise, we don't
    // need it 
    //
    if (bCreateNewPackage) 
    {
        CreateGuid(&PackageGuidId);
        StringFromGUID(PackageGuidId, szPackageId);

        //
        // Create the RDN for the Package Object
        //

        hr = StringCchPrintf(szRDN, _MAX_PATH, L"CN=%s", szPackageId);

        ERROR_ON_FAILURE(hr);

        //
        // Only set this attribute when creating a new object -- 
        // Otherwise, a constraint violation will occur since it is
        // not permissible to change an object's class
        //
        PackStrToAttr(pAttr+cAttr, OBJECTCLASS, CLASS_CS_PACKAGE); cAttr++;
    }
    
    // fill in the activation info
    
    // add the class to the packagecontainer list

    //
    // Classes are not present during redeploy operations in a domain rename because
    // GetPackageDetails does not return the classes.  Normally, the ade regenerates
    // the classes during redeploy, so this is not an issue, but for domain rename,
    // class regeneration is time consuming and may generate different results
    // due to the class generation api's (in Darwin) dependency on local state.
    //
    // We check for a special flag, ACTFLG_PreserveClasses to see if we should
    // skip writing clsid's and progid's
    //

    BOOL bIgnoreClasses;

    bIgnoreClasses = pPackageDetail->pInstallInfo->dwActFlags & ACTFLG_PreserveClasses;    

    if (pPackageDetail->pActInfo)
    {
        BOOL bWriteClasses;
        BOOL bWriteEmptyValue;

        UINT cClasses;
        UINT cSourceClasses;
    
        bWriteClasses = pPackageDetail->pActInfo->bHasClasses && ! bIgnoreClasses;
        bWriteEmptyValue = ! pPackageDetail->pActInfo->bHasClasses;

        cClasses = 0;
        cSourceClasses = pPackageDetail->pActInfo->cClasses;

        cPackProgId = 0;

        if ( ! pPackageDetail->pActInfo->bHasClasses )
        {
            cSourceClasses = 0;
        }

        //
        // To be consistent with NT5, we will not set the clsid or progid properties when the user has specified
        // that we deploy classes but there are none.  If the user has not specified that we should deploy
        // classes, we will still set this property, but it will be zero-length
        //

        if ( bWriteClasses )
        {
            if ( cSourceClasses )
            {
                pszGuid1 = (LPOLESTR *)CsMemAlloc(cSourceClasses*sizeof(LPOLESTR));
                if (!pszGuid1) {
                    ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
            
                for (count = 0; count < cSourceClasses; count++) 
                {
                    WCHAR   szCtx[10];

                    pszGuid1[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*(STRINGGUIDLEN+9));
                    if (!pszGuid1[count]) {
                        FREEARR(pszGuid1, count);
                        ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);                                
                    }

                    StringFromGUID(pPackageDetail->pActInfo->pClasses[count].Clsid, pszGuid1[count]);
                    hr = StringCchPrintf(szCtx, sizeof(szCtx)/sizeof(szCtx[0]), L":%8x", pPackageDetail->pActInfo->pClasses[count].dwComClassContext);
                    
                    ERROR_ON_FAILURE(hr);                                
                    
                    hr = StringCchCat(pszGuid1[count], STRINGGUIDLEN+9, szCtx);

                    ERROR_ON_FAILURE(hr);
                    cPackProgId += pPackageDetail->pActInfo->pClasses[count].cProgId;
                }

                cClasses = cSourceClasses;
            }
        }

        //
        // This flag should not be persisted in the ds, only used as a hint for redeploy
        // to avoid overwriting the existing classes
        //
        pPackageDetail->pInstallInfo->dwActFlags &= ~ACTFLG_PreserveClasses;

        LPOLESTR  wszNullGuid; 
        LPOLESTR* ppszClsids;

        ppszClsids = pszGuid1;

        //
        // If required, write the blank clsid value so that
        // the NT 5.1 ADE can determine if this package has class information.  Note that
        // an NT 5.0 ADE will never see this because this uses a null guid -- both 
        // NT 5.0 and 5.1 ADE's will never accept a request from a caller to search
        // for a null guid.
        //
        if ( bWriteEmptyValue )
        {
            wszNullGuid = PKG_EMPTY_CLSID_VALUE;
            ppszClsids = &wszNullGuid;
            cClasses = 1;
        }
        
        //
        // If there are no clsids, this will cause the value to be cleared
        //
        if ( ( cClasses || ! bCreateNewPackage ) && ! bIgnoreClasses )
        {
            PackStrArrToAttr(pAttr+cAttr, PKGCLSIDLIST, ppszClsids,  cClasses); cAttr++; 
        }

        if ( bWriteClasses )
        {
            // collecting all the progids from the various clsids.
            pszProgId = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*cPackProgId);
            if (!pszProgId) {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
        
            //
            // Reset our count of progid's -- we need to check for duplicates, so we
            // do not assume that we will have as many progid's as we allocated space for above --
            // we will increment the count for each unique progid we encounter.
            //
            cPackProgId = 0;

            for (count = 0; count < cSourceClasses; count++) {
                // for each clsid
                DWORD cClassProgId, j = 0;
                for (cClassProgId = 0; cClassProgId < pPackageDetail->pActInfo->pClasses[count].cProgId;
                     cClassProgId++) 
                {
                    // for each progid within ClassDetail
                    for (j = 0; j < cPackProgId; j++)
                    {
                        if (_wcsicmp(pszProgId[j], 
                                     pPackageDetail->pActInfo->pClasses[count].prgProgId[cClassProgId]) == 0)
                            break;
                    }
                    // needs to be added if there are no dups.
                    if (j == cPackProgId)
                    {
                        pszProgId[cPackProgId] =
                            pPackageDetail->pActInfo->pClasses[count].prgProgId[cClassProgId];
                        _wcslwr(pszProgId[cPackProgId]);
                        cPackProgId++;
                    }
                }
            }
        }
        else
        {
            //
            // Reset this so that we clear out progid's if we are not writing any
            //
            cPackProgId = 0;
        }

        //
        // If there are no clsids, this will cause the value to be cleared
        //
        if ( ( cPackProgId || ! bCreateNewPackage ) && ! bIgnoreClasses )
        {
            PackStrArrToAttr(pAttr+cAttr, PROGIDLIST, pszProgId, cPackProgId); cAttr++;
        }

        CsMemFree(pszProgId);
        
        if (pPackageDetail->pActInfo->cShellFileExt) {

            ULONG ulSize;

            //
            // Store a tuple in the format <file ext>:<priority>
            //
            pszFileExt = (LPOLESTR *)CsMemAlloc((pPackageDetail->pActInfo->cShellFileExt) * sizeof(LPOLESTR));
            if (!pszFileExt)
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            for (count = 0; count < pPackageDetail->pActInfo->cShellFileExt; count++)
            {
                ulSize = wcslen(pPackageDetail->pActInfo->prgShellFileExt[count])+1+2+1;
                pszFileExt[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR) *ulSize);
                if (!pszFileExt[count]) 
                {
                    FREEARR(pszFileExt, count);
                    ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
                }
                // format is fileext+:+nn+NULL where nn = 2 digit priority
                hr = StringCchPrintf(pszFileExt[count], ulSize, L"%s:%2d",
                    pPackageDetail->pActInfo->prgShellFileExt[count],
                    pPackageDetail->pActInfo->prgPriority[count]%100);

                ERROR_ON_FAILURE(hr);

                _wcslwr(pszFileExt[count]);
            }
            PackStrArrToAttr(pAttr+cAttr, PKGFILEEXTNLIST, pszFileExt,
                pPackageDetail->pActInfo->cShellFileExt); cAttr++;
        }
        
        //
        // Note: we no longer persist interfaces in the ds as this information
        // is not used
        //
    }
   
    // fill in the platforminfo
    
    // 
    // Note that the os version contained in this structure is not referenced in the os
    //
    if (pPackageDetail->pPlatformInfo->cPlatforms) {
        pdwArch = (DWORD *)CsMemAlloc(sizeof(DWORD)*(pPackageDetail->pPlatformInfo->cPlatforms));
        if (!pdwArch)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; (count < (pPackageDetail->pPlatformInfo->cPlatforms)); count++)
            UnpackPlatform (pdwArch+count, (pPackageDetail->pPlatformInfo->prgPlatform)+count);
        
        PackDWArrToAttr(pAttr+cAttr, ARCHLIST, pdwArch, pPackageDetail->pPlatformInfo->cPlatforms);
        cAttr++;
    }
    
    if (pPackageDetail->pPlatformInfo->cLocales) {
        PackDWArrToAttr(pAttr+cAttr, LOCALEID, pPackageDetail->pPlatformInfo->prgLocale,
            pPackageDetail->pPlatformInfo->cLocales);
        cAttr++;
    }
    
    // fill in the installinfo
    
    PackStrToAttr(pAttr+cAttr, PACKAGENAME, pPackageDetail->pszPackageName);
    cAttr++;

    // also include display name so that outside tools can get a friendly description
    PackStrToAttr(pAttr+cAttr, PKGDISPLAYNAME, pPackageDetail->pszPackageName);
    cAttr++;

    PackDWToAttr(pAttr+cAttr, PACKAGETYPE, (DWORD)(pPackageDetail->pInstallInfo->PathType));
    cAttr++;
    
    if (pPackageDetail->pInstallInfo->pszScriptPath) {
        PackStrToAttr(pAttr+cAttr, SCRIPTPATH, pPackageDetail->pInstallInfo->pszScriptPath);
        cAttr++;
    }
    
    if (pPackageDetail->pInstallInfo->pszSetupCommand) {
        PackStrToAttr(pAttr+cAttr, SETUPCOMMAND, pPackageDetail->pInstallInfo->pszSetupCommand);
        cAttr++;
    }
    
    if (pPackageDetail->pInstallInfo->pszUrl) {
        PackStrToAttr(pAttr+cAttr, HELPURL, pPackageDetail->pInstallInfo->pszUrl);
        cAttr++;
    }
    
    //
    // Store the current USN
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    // package flags

    dwPersistedPackageFlags = pPackageDetail->pInstallInfo->dwActFlags |
        ACTFLG_POSTBETA3;

    //
    // Now set the flags so that they reflect the state of this package
    //
    hr = GetConsistentPackageFlags(
        NULL,
        &dwPersistedPackageFlags,
        &(pPackageDetail->pInstallInfo->cUpgrades),
        &(pPackageDetail->pInstallInfo->InstallUiLevel),
        &(pPackageDetail->pInstallInfo->PathType),
        &dwPersistedPackageFlags,
        wszSearchFlags);

    ERROR_ON_FAILURE(hr);

    //
    // Add in a flag indicating this is a post-Beta 3 deployment
    //
    PackDWToAttr(pAttr+cAttr, PACKAGEFLAGS, dwPersistedPackageFlags);
    cAttr++;

    if (*wszSearchFlags) 
    {
        PackStrToAttr(pAttr+cAttr, SEARCHFLAGS, wszSearchFlags);
        cAttr++;
    }
    
    // product code, different from pkg guid
    PackGUIDToAttr(pAttr+cAttr, PRODUCTCODE, &(pPackageDetail->pInstallInfo->ProductCode));
    cAttr++;
    
    // Mvipc
    PackGUIDToAttr(pAttr+cAttr, MVIPC, &(pPackageDetail->pInstallInfo->Mvipc));
    cAttr++;

    // Hi Version of the package
    PackDWToAttr(pAttr+cAttr, VERSIONHI, pPackageDetail->pInstallInfo->dwVersionHi);
    cAttr++;

    
    // Low Version of the package
    PackDWToAttr(pAttr+cAttr, VERSIONLO, pPackageDetail->pInstallInfo->dwVersionLo);
    cAttr++;
    
    // Revision
    PackDWToAttr(pAttr+cAttr, REVISION, pPackageDetail->pInstallInfo->dwRevision);
    cAttr++;

    // uilevel
    PackDWToAttr (pAttr+cAttr, UILEVEL, (DWORD)pPackageDetail->pInstallInfo->InstallUiLevel);
    cAttr++;
    
    // adding cUpgrade number of Classstore/PackageGuid combinations
    if (pPackageDetail->pInstallInfo->cUpgrades) 
    {
        WCHAR szPackageGuid[_MAX_PATH];

        rpszUpgrades = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*pPackageDetail->pInstallInfo->cUpgrades);
        if (!rpszUpgrades)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++) 
        {
            UINT  len = wcslen(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore);
            ULONG ulSize = 36+PKG_UPG_DELIM1_LEN+len+PKG_UPG_DELIM2_LEN+2+2;
            rpszUpgrades[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR) *ulSize);
                                                        // Guid size+::+length++:+flagDigit+2 
            if (!rpszUpgrades[count])
            {
                FREEARR(rpszUpgrades, count);  
                ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
            }

            StringFromGUID(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].PackageGuid, 
                            szPackageGuid);
            hr = StringCchPrintf(rpszUpgrades[count], ulSize, L"%s%s%s%s%02x",
                                 pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore,
                                 PKG_UPG_DELIMITER1,
                                 szPackageGuid,
                                 PKG_UPG_DELIMITER2, 
                                 pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag%16);

            ERROR_ON_FAILURE(hr);

        }
          
        PackStrArrToAttr(pAttr+cAttr, UPGRADESPACKAGES, rpszUpgrades,
            pPackageDetail->pInstallInfo->cUpgrades); 
        cAttr++;
    }
    
    // Fill in the source list 
    // Maintain the serial number associated with the sources. Order matters!!
    if (pPackageDetail->cSources) 
    {
        rpszSources = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*(pPackageDetail->cSources));
        if (!rpszSources)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; count < (pPackageDetail->cSources); count++) 
        {
            ULONG ulSize = wcslen(pPackageDetail->pszSourceList[count])+1+1+NumDigits10(pPackageDetail->cSources);
            rpszSources[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)* ulSize);
            if (!rpszSources[count])
            {
                FREEARR(rpszSources, count);
                ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
            }
            hr = StringCchPrintf(rpszSources[count], ulSize, L"%d:%s", count, pPackageDetail->pszSourceList[count]);

            ERROR_ON_FAILURE(hr);
        }
        
        PackStrArrToAttr(pAttr+cAttr, MSIFILELIST, rpszSources, pPackageDetail->cSources);
        cAttr++;
    }
    
    // fill in the categories
    // Add the package Categories
    if (pPackageDetail->cCategories)
    {
        pszGuid4 = (LPOLESTR *)CsMemAlloc((pPackageDetail->cCategories) * sizeof(LPOLESTR));
        if (!pszGuid4)
        {
            ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        for (count = 0; (count < pPackageDetail->cCategories); count++)
        {
            pszGuid4[count] = (LPOLESTR)CsMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
            if (!pszGuid4[count])
            {
                FREEARR(pszGuid4, count);
                ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            
            StringFromGUID((pPackageDetail->rpCategory)[count], pszGuid4[count]);
        }
        
        PackStrArrToAttr(pAttr+cAttr, PKGCATEGORYLIST, pszGuid4, pPackageDetail->cCategories);
        cAttr++;
    }
    
    // fill in the vendor
    
    // Publisher
    if (pPackageDetail->pszPublisher) 
    {
        PackStrToAttr(pAttr+cAttr, PUBLISHER, pPackageDetail->pszPublisher);
        cAttr++;
    }

    //
    // Create a new package if specified by the caller
    //
    if (bCreateNewPackage) 
    {
        hr = ADSICreateDSObject(m_ADsPackageContainer, szRDN, pAttr, cAttr);
        ERROR_ON_FAILURE(hr);

        memset(pPkgGuid, 0, sizeof(GUID));

        hr = GetPackageGuid(szRDN, pPkgGuid);
    }
    else
    {
        DWORD cModified;

        //
        // The caller specified us to use an existing package -- do not 
        // create a new one, just set the attributes for the existing package.
        // The ADSISetObjectAttributes call will either set all attributes or
        // none -- so if it fails, the package is just as it was 
        // before we attempted to redeploy.
        //
        hr = ADSISetObjectAttributes(hExistingPackage, pAttr, cAttr, &cModified);
    }

    ERROR_ON_FAILURE(hr);

    fPackageCreated = bCreateNewPackage ? TRUE : FALSE;

    if (!(pPackageDetail->pInstallInfo->dwActFlags & ACTFLG_Uninstall) &&
        !(pPackageDetail->pInstallInfo->dwActFlags & ACTFLG_Orphan))
    {
        if (pPackageDetail->pInstallInfo->cUpgrades)
        {
            for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++)
                CsMemFree(rpszUpgrades[count]);
            CsMemFree(rpszUpgrades);
        }
    }
    
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    for (count = 0; count < cAttr; count++)
        FreeAttr(pAttr[count]);
    
    if (pszGuid1) {
        for (count = 0; (count < pPackageDetail->pActInfo->cClasses); count++)
            CsMemFree(pszGuid1[count]);
        CsMemFree(pszGuid1);
    }
    
    if (pszGuid2) {
        for (count = 0; (count < (pPackageDetail->pActInfo->cInterfaces)); count++)
            CsMemFree(pszGuid2[count]);
        CsMemFree(pszGuid2);
    }
    
    if (pszGuid3) {
        for (count = 0; (count < (pPackageDetail->pActInfo->cTypeLib)); count++)
            CsMemFree(pszGuid3[count]);
        CsMemFree(pszGuid3);
    }
    
    if (pszGuid4) {
        for (count = 0; (count < pPackageDetail->cCategories); count++)
            CsMemFree(pszGuid4[count]);
        CsMemFree(pszGuid4);
    }
    
    if (pszFileExt) {
        for (count = 0; (count < pPackageDetail->pActInfo->cShellFileExt); count++)
            CsMemFree(pszFileExt[count]);
        CsMemFree(pszFileExt);
    }
    
    if (pdwArch) {
        CsMemFree(pdwArch);
    }
    
    if (rpszSources) 
    {
        for (count = 0; (count < pPackageDetail->cSources); count++)
            CsMemFree(rpszSources[count]);
        CsMemFree(rpszSources);
    }

    //
    // On failure, the package should be removed from the ds if we
    // created it there.
    //
    if (FAILED(hr) && (fPackageCreated))
    {
        HRESULT hrDeleted;
        LPWSTR  wszPackageFullPath;

        //
        // Need to get a full path to the package in order to delete it.
        //
        hrDeleted = BuildADsPathFromParent(m_szPackageName, szRDN, &wszPackageFullPath);

        ASSERT(SUCCEEDED(hrDeleted));

        CSDBGPrint((DM_WARNING, IDS_CSTORE_ROLLBACK_ADD, wszPackageFullPath));

        hrDeleted = DeletePackage(wszPackageFullPath);

        //
        // Free the full path
        //
        CsMemFree(wszPackageFullPath);
    }

    return RemapErrorCode(hr, m_szContainerName);
}

//+
//
// Cleanup old packages from Class Store based on lastChangeTime
//

HRESULT CClassContainer::Cleanup (
                                  FILETIME        *pTimeBefore
                                  )
{
    //
    // Delete all packages marked as "Uninstall"
    // OR "Orphan" and are older than the time given
    //
    
    ULONG               cRowsFetched = 0;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    WCHAR               szFilter[_MAX_PATH], szRDN[_MAX_PATH];
    HRESULT             hr = S_OK;
    ADS_ATTR_INFO       pAttr;
    SYSTEMTIME          SystemTime;
    ADS_SEARCH_COLUMN   column;
    DWORD               dwPackageFlags;
    LPOLESTR            pszPackageId = NULL;
    
    if ((!pTimeBefore) ||
        IsBadReadPtr(pTimeBefore, sizeof(FILETIME)))
        return E_INVALIDARG;

    FileTimeToSystemTime(
        (CONST FILETIME *) pTimeBefore, 
        &SystemTime);  
    
    hr = StringCchPrintf (szFilter,
                          _MAX_PATH,
                          L"(%s<=%04d%02d%02d%02d%02d%02d)", 
                          PKGUSN,
                          SystemTime.wYear,
                          SystemTime.wMonth,
                          SystemTime.wDay,
                          SystemTime.wHour,
                          SystemTime.wMinute,
                          SystemTime.wSecond);

    ERROR_ON_FAILURE(hr);

    CSDBGPrint((DM_VERBOSE, 
                IDS_CSTORE_CLEANSCRIPTS, 
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wYear,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond));
    
    // execute the search and keep the handle returned.
    hr = ADSIExecuteSearch(m_ADsPackageContainer, szFilter, pszDeleteAttrNames,
        cDeleteAttr, &hADsSearchHandle);
    
    hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
    
    while (TRUE)
    {
        if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
            break;
        
        dwPackageFlags = 0;
        
        // Get the Package State
        hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGEFLAGS, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &dwPackageFlags);
            ADSIFreeColumn(m_ADsPackageContainer, &column);
        }
        
        //
        // Check flag values to see if this package is Orphaned or Uninstalled
        //
        
        if ((dwPackageFlags & ACTFLG_Orphan) || (dwPackageFlags & ACTFLG_Uninstall)) 
        {
            
            hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, OBJECTDN, &column);
            
            if (SUCCEEDED(hr))
            {
                WCHAR    * szDN = NULL;

                UnpackStrFrom(column, &szDN);
                hr = DeletePackage(szDN);

                CSDBGPrint((DM_WARNING,
                            IDS_CSTORE_DELPACKAGE,
                            szDN,
                            dwPackageFlags,
                            hr));

                ADSIFreeColumn(m_ADsPackageContainer, &column);
                ERROR_ON_FAILURE(hr);
            }
        }
        hr = ADSIGetNextRow(m_ADsPackageContainer, hADsSearchHandle);  
    }
    
Error_Cleanup:
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);
    return RemapErrorCode(hr, m_szContainerName);
}

HRESULT CClassContainer::GetGPOName( WCHAR** ppszPolicyName )
{
    HRESULT        hr;

    HANDLE         hGpo;

    ADS_ATTR_INFO* pAttr;
    LPOLESTR       AttrNames[] = {GPNAME};

    DWORD          cgot;
    DWORD          posn;

    WCHAR*         wszGpoPath;

    pAttr = NULL;
    hGpo = NULL;

    //
    // This object contains the path to a class store container --
    // this path is of the form LDAP://CN=ClassStore,CN=User,<gpopath>.
    // This means that the gpo path is shorter than the class store path,
    // and we can allocate memory accordingly.
    //
    DWORD cbClassStorePath;

    cbClassStorePath = lstrlen( m_szContainerName ) * sizeof ( *m_szContainerName );

    wszGpoPath = (WCHAR*) CsMemAlloc( cbClassStorePath );

    if ( ! wszGpoPath )
    {
        hr = E_OUTOFMEMORY;
        goto GetGpoName_ExitAndCleanup;
    }

    WCHAR* wszGpoSubPath;

    //
    // Get past the prefix
    //
    wszGpoSubPath = StripLinkPrefix( m_szContainerName );

    //
    // Now get past the next two delimiters
    //
    wszGpoSubPath = wcschr( wszGpoSubPath, L',' ) + 1;
    wszGpoSubPath = wcschr( wszGpoSubPath, L',' );

    //
    // Move one past the last delimiter -- we are now at the gpo path
    //
    wszGpoSubPath++;

    //
    // Create the resultant path starting with the prefix
    //

    hr = StringCbCopy( wszGpoPath, cbClassStorePath, LDAPPREFIX );
    if (FAILED(hr)) 
    {
        goto GetGpoName_ExitAndCleanup;
    }

    //
    // Append the gpo path -- we now have a fully qualified
    // LDAP path to the GPO
    //

    hr = StringCbCat( wszGpoPath, cbClassStorePath, wszGpoSubPath );
    if (FAILED(hr)) 
    {
        goto GetGpoName_ExitAndCleanup;
    }
    
    hr = DSServerOpenDSObject(&m_ServerContext,
        wszGpoPath,
        GetDsFlags(),
        &hGpo);

    if (FAILED(hr))
    {
        goto GetGpoName_ExitAndCleanup;
    }

    //
    // Now get the friendly name of this gpo
    //
    hr = ADSIGetObjectAttributes(
        hGpo,
        AttrNames, 
        sizeof(AttrNames) / sizeof(*AttrNames),
        &pAttr,
        &cgot);
    
    if ( SUCCEEDED(hr) ) 
    {
        ASSERT( 1 == cgot );

        UnpackStrAllocFrom(pAttr[0], ppszPolicyName);

        if ( ! *ppszPolicyName )
        {
            hr = E_OUTOFMEMORY;
        }
    }

GetGpoName_ExitAndCleanup:
        
    if ( pAttr )
    {
        FreeADsMem( pAttr );
    }

    if (hGpo)
    {
        ADSICloseDSObject( hGpo );
    }

    if (wszGpoPath)
    {
        CsMemFree( wszGpoPath );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\appcont.cxx ===
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Author: DebiM
//  Date:   January 97
//  Revision History:
//          Made Changes for reimplementation with adsldpc interfaces.
//          UShaji, Mar 1998
//
//      Class Access Implementation
//
//      This source file contains implementations for IClassAccess
//      interface on CAppContainer object.
//
//      It uses ADs interfaces (over LDAP) to talk to an LDAP
//      provider such as NTDS.
//
//---------------------------------------------------------------------
//

#include "cstore.hxx"

CBindingList BindingCache;

//
// Critical Section for All Global Objects.
//
extern CRITICAL_SECTION ClassStoreBindList;


HRESULT
UsnGet(ADS_ATTR_INFO Attr, CSUSN *pUsn);

long CompareUsn(CSUSN *pUsn1, CSUSN *pUsn2)
{
    return CompareFileTime((FILETIME *)pUsn1, (FILETIME *)pUsn2);
}

void GetExpiredTime( FILETIME* pftCurrentTime, FILETIME* pftExpiredTime )
{
    //
    // Add the cache interval time to determine
    // the time this will expire
    //
    LARGE_INTEGER liTime;

    //
    // First copy the filetime to a large integer so
    // we can perform arithmetic
    //
    liTime.LowPart = pftCurrentTime->dwLowDateTime;
    liTime.HighPart = pftCurrentTime->dwHighDateTime;

    //
    // The compiler can perform 64 bit math -- use this
    // to perform the arithmetic for calculating the
    // time at which cache entries will expire
    //
    liTime.QuadPart += CACHE_PURGE_TIME_FILETIME_INTERVAL;

    //
    // Now copy the information back to the caller's structure
    //
    pftExpiredTime->dwLowDateTime = liTime.LowPart;
    pftExpiredTime->dwHighDateTime = liTime.HighPart;
}

BOOL IsExpired(
    FILETIME* pftCurrentTime,
    FILETIME* pftExpiredTime)
{
 
    SYSTEMTIME SystemTimeCurrent;
    SYSTEMTIME SystemTimeExpiration;
    BOOL       bRetrievedTime;

    bRetrievedTime = FileTimeToSystemTime(
        pftCurrentTime,
        &SystemTimeCurrent);

    bRetrievedTime &= FileTimeToSystemTime(
        pftExpiredTime,
        &SystemTimeExpiration);

    if ( bRetrievedTime )
    {
        CSDBGPrint((
            DM_VERBOSE,
            IDS_CSTORE_CACHE_EXPIRE,
            L"Current Time",
            SystemTimeCurrent.wMonth,
            SystemTimeCurrent.wDay,
            SystemTimeCurrent.wYear,
            SystemTimeCurrent.wHour,
            SystemTimeCurrent.wMinute,
            SystemTimeCurrent.wSecond));

        CSDBGPrint((
            DM_VERBOSE,
            IDS_CSTORE_CACHE_EXPIRE,
            L"Expire Time",
            SystemTimeExpiration.wMonth,
            SystemTimeExpiration.wDay,
            SystemTimeExpiration.wYear,
            SystemTimeExpiration.wHour,
            SystemTimeExpiration.wMinute,
            SystemTimeExpiration.wSecond));
    }

    //
    // Compare the current time to the expiration time
    //
    LONG CompareResult;

    CompareResult = CompareFileTime(
        pftCurrentTime,
        pftExpiredTime);
        
    //
    // If the current time is later than the expired time,
    // then we have expired
    //
    if ( CompareResult > 0 )
    {
        return TRUE;
    }

    return FALSE;
}

//
// CAppContainer implementation
//
CAppContainer::CAppContainer()

{
    m_fOpen = FALSE;

    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;

    m_szPackageName = NULL;

    memset (&m_PolicyId, 0, sizeof(GUID));

    m_KnownMissingClsidCache.sz = 0;
    m_KnownMissingClsidCache.start = 0;
    m_KnownMissingClsidCache.end = 0;

    m_uRefs = 1;

    m_szGpoPath = NULL;

    m_pRsopToken = NULL;
}


//
// CAppContainer implementation
//

/*----------------------------------------------------------------------*
CAppContainer Constructor:

  Parameters:
  [in]  szStoreName:    The Class Store Name without 'ADCS:' moniker
  [out] phr             The Error Code returned.

    Remarks: Tries to Bind to Base Class Store Container, get the version
    Number and Packages and Classes container underneath.

      Initializes members corresp. to their Names

        Return Codes:
        Success     S_OK
        Failures    CS_E_INVALID_VERSION
        Look at RemapErrorCodes

*----------------------------------------------------------------------*/
CAppContainer::CAppContainer(CServerContext* pServerContext,
                             LPOLESTR        szStoreName,
                             PRSOPTOKEN      pRsopToken,
                             HRESULT*        phr)

{
    LPOLESTR            pszName = NULL;
    DWORD               dwStoreVersion = 0;
    LPOLESTR            AttrNames[] = {STOREVERSION, POLICYDN};
    DWORD               posn = 0, cgot = 0;
    ADS_SEARCHPREF_INFO SearchPrefs[3];
    ADS_ATTR_INFO     * pAttrsGot = NULL;

    m_szGpoPath = NULL;

    m_pRsopToken = pRsopToken;

    *phr = S_OK;

    if ( pServerContext )
    {
        *phr = m_ServerContext.Initialize( pServerContext );

        if ( FAILED(*phr) )
        {
            return;
        }
    }    

    // set the search preference for the search Handle

    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = SEARCHPAGESIZE;

    SearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SECURITY_MASK;
    SearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;

    SearchPrefs[2].vValue.Integer =
            OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION;

    memset (&m_PolicyId, 0, sizeof(GUID));

    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_szPackageName = NULL;

    memset (&m_PolicyId, 0, sizeof(GUID));

    m_KnownMissingClsidCache.sz = 0;
    m_KnownMissingClsidCache.start = 0;
    m_KnownMissingClsidCache.end = 0;

    m_uRefs = 1;
    //
    // For every interface pointer, we create a separate session
    //


    // Bind to a Class Store Container Object
    // Cache the interface pointer
    //
    *phr = StringCchCopy (m_szContainerName, _MAX_PATH, szStoreName);

    ERROR_ON_FAILURE(*phr);

    *phr = DSServerOpenDSObject( &m_ServerContext, m_szContainerName, GetDsFlags(),
        &m_ADsContainer);

    ERROR_ON_FAILURE(*phr);
    //
    // Check the Schema Version of this container
    //

    *phr = ADSIGetObjectAttributes(m_ADsContainer, AttrNames, 2, &pAttrsGot, &cgot);

    if ((SUCCEEDED(*phr)) && (cgot))
    {

        posn = GetPropertyFromAttr(pAttrsGot, cgot, STOREVERSION);
        dwStoreVersion = 0;
        if (posn < cgot)
        {
            //
            // Ensure that we validate the type of the data return by the ds --
            // if the type is not valid (most often this occurs because adsi
            // could not create a schema cache on the local machine), we
            // will assume it to be invalid.  The version number will be 
            // initialized to 0, which is invalid, and we will abort.
            //
            if ( ADSTYPE_INTEGER == pAttrsGot[posn].dwADsType )
            {
                UnpackDWFrom(pAttrsGot[posn], &dwStoreVersion);
            }
        }

        if (dwStoreVersion != SCHEMA_VERSION_NUMBER)
        {
            *phr = CS_E_INVALID_VERSION;
        }


        if (SUCCEEDED(*phr))
        {
            LPOLESTR        szPolicyPath = NULL;

            posn = GetPropertyFromAttr(pAttrsGot, cgot, POLICYDN);
            if (posn < cgot)
            {
                LPOLESTR        szParentPath = NULL, szPolicyGuid = NULL;

                UnpackStrFrom(pAttrsGot[posn], &szPolicyPath);
                //

                BuildADsParentPath(szPolicyPath, &szParentPath, &szPolicyGuid);
                if (szParentPath)
                    FreeADsMem(szParentPath);

                if (szPolicyGuid)
                {
                    if (wcslen(szPolicyGuid) == 41)
                    {
                        // valid GUID

                        GUIDFromString(&szPolicyGuid[4], &m_PolicyId);
                    }
                    FreeADsMem(szPolicyGuid);
                }
            }
        }
    }
    else
    {
        if (SUCCEEDED(*phr))
        {
            *phr = CS_E_INVALID_VERSION;
        }
    }

    if (pAttrsGot)
        FreeADsMem(pAttrsGot);

    ERROR_ON_FAILURE(*phr);

    //
    // Bind to the Package container Object
    // Cache the interface pointer
    //

    BuildADsPathFromParent(m_szContainerName, PACKAGECONTAINERNAME, &m_szPackageName);

    m_ADsPackageContainer = NULL;


    *phr = DSServerOpenDSObject( &m_ServerContext, m_szPackageName, GetDsFlags(),
        &m_ADsPackageContainer);

    ERROR_ON_FAILURE(*phr);

    *phr = ADSISetSearchPreference(m_ADsPackageContainer, SearchPrefs, 3);
    ERROR_ON_FAILURE(*phr);

    m_fOpen = TRUE;

    m_uRefs = 1;

    m_szGpoPath = AllocGpoPathFromClassStorePath( m_szContainerName );

    if ( ! m_szGpoPath )
    {
        *phr = E_OUTOFMEMORY;
    }

Error_Cleanup:
    *phr = RemapErrorCode(*phr, m_szContainerName);
    return;
}


/*----------------------------------------------------------------------*
CAppContainer Destructor:


    Parameters:
      None

    Function:
      Destroys CAppContainer object.

    Remarks:
     Frees all the members.
     Return Codes
*----------------------------------------------------------------------*/


CAppContainer::~CAppContainer(void)
{
    UINT i;

    if (m_fOpen)
    {
        m_fOpen = FALSE;
    }

    if (m_ADsPackageContainer)
    {
        ADSICloseDSObject(m_ADsPackageContainer);
        m_ADsPackageContainer = NULL;
        FreeADsMem(m_szPackageName);
    }

    if (m_ADsContainer)
    {
        ADSICloseDSObject(m_ADsContainer);
        m_ADsContainer = NULL;
    }

    if (m_szGpoPath)
    {
        CsMemFree(m_szGpoPath);
    }
}


//
// Constructor for App Container Class factory
//
unsigned long gulcappcon = 0;

CAppContainerCF::CAppContainerCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcappcon );
}

//
// Destructor
//
CAppContainerCF::~CAppContainerCF()
{
    //
    // Cleanup the cache
    //
    InterlockedDecrement((long *) &gulcappcon );
}

HRESULT  __stdcall  CAppContainerCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else  if( IsEqualIID( IID_IParseDisplayName, riid ) )
    {
        pUnkTemp = (IUnknown *)(IParseDisplayName *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
        {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CAppContainerCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CAppContainerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


//
// IClassFactory Overide
//
HRESULT  __stdcall  CAppContainerCF::CreateInstance(IUnknown * pUnkOuter, REFIID riid,
                                                                    void  ** ppvObject)
{
    CAppContainer *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CAppContainer()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
             pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}


//---------------------------------------------------------------
//
//  Function:   CreateConnectedInstance
//
//  Synopsis:   Returns IClassAccess Pointer, given a class store
//              path.
//
//  Arguments:
//  [in]
//      pszPath Class Store Path without the leading ADCS:
//
//      pUserSid
//              Sid under which the calling thread is running.
//      fCache
//              Boolean that decides whether to use a cached pointer or
//              not.
//  [out]
//      ppvObject
//              IClassAccess Interface pointer
//
//  Returns:
//      S_OK, E_NOINTERFACE, E_OUTOFMEMORY, CS_E_XXX
//
//  if (fCache)
//      Looks in the cache to see if we have already tried to bind to the same
//      ClassStore Path under the same SID. If it finds it, then we just QI for
//      IClassAccess and return. o/w create a new class store pointer and caches it.
//  else
//      Just binds to a new ClassStore and returns.
//----------------------------------------------------------------
HRESULT  __stdcall
CAppContainerCF::CreateConnectedInstance(
    CServerContext* pServerContext,
    LPOLESTR        pszPath, 
    PSID            pUserSid,
    PRSOPTOKEN      pRsopToken,
    BOOL            fCache,
    void **         ppvObject)
{
    CAppContainer   *   pIUnk = NULL;
    SCODE               sc = S_OK;
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;
    FILETIME            ftCurrentTime;
    IClassAccess*       pNewClassAccess = NULL;

    CBinding*           pBinding;

    //
    // See if we have an existing connection in the cache
    //
    if (fCache)
    {
        GetSystemTimeAsFileTime( &ftCurrentTime );
        
        BindingCache.Lock();

        pBinding = BindingCache.Find(
            pServerContext,
            &ftCurrentTime,
            pszPath,
            pUserSid);

        if ( pBinding ) 
        {
            if ( FAILED( pBinding->Hr ) )
            {
                sc = pBinding->Hr;
            }
            else
            {
                sc = pBinding->pIClassAccess->
                    QueryInterface( IID_IClassAccess, ppvObject );
            }
        }

        BindingCache.Unlock();
    }

    if ( fCache && pBinding )
    {
        return sc;
    }

    //
    // Couldn't find anything in the cache -- we will have to create a new connection
    //

    //
    // If this is called in the context of policy, ipsec policy may not be enabled.
    // Therefore, our communications with the directory would not be secure.
    // We will pass TRUE for the secure channel argument of the CAppContainer
    // constructor since this code path is exercised during policy and we
    // want to ensure security.
    //

    //
    // Note that this object has a refcount of 1 when created
    //
    if ((pIUnk = new CAppContainer( pServerContext, pszPath, pRsopToken, &sc)) != NULL)
    {
        if (SUCCEEDED(sc))
        {
            sc = pIUnk->QueryInterface( IID_IClassAccess, (LPVOID*) &pNewClassAccess );
        }
        else
        {
            CSDBGPrint((DM_WARNING, 
                      IDS_CSTORE_BIND_FAIL,
                      pszPath,
                      sc));
        }

        pIUnk->Release();
    }
    else
    {
        return E_OUTOFMEMORY;
    }

    //
    // Store the result in the cache -- create a binding
    // descriptor so we can cache it
    //
    CBinding* pNewBinding;

    if (fCache)
    {
        //
        // Should not cache situations out of network failures
        // For now we are only caching successes OR CS does not exist cases
        //
        if ((sc == S_OK) || (sc == CS_E_OBJECT_NOTFOUND))
        {
            HRESULT   hrBinding;

            hrBinding = E_OUTOFMEMORY;

            pNewBinding = new CBinding(
                pServerContext,
                pszPath,
                pUserSid,
                pNewClassAccess,
                sc,
                &hrBinding);

            if ( FAILED( hrBinding ) )
            {
                sc = hrBinding;
                fCache = FALSE;
            }
        }
        else
        {
            fCache = FALSE;
        }
    }

    //
    // We have the binding descriptor, now cache it
    //
    if ( fCache )
    {
        CBinding* pBindingAdded;            

        BindingCache.Lock();

        //
        // Attempt to add the binding -- if one already
        // exists, it will destroy the one we pass in and
        // use the existing binding
        //
        pBindingAdded = BindingCache.AddBinding(
            &ftCurrentTime,
            pNewBinding);

        sc = pBindingAdded->Hr;
                
        if ( SUCCEEDED(sc) )
        {
            sc = pBindingAdded->pIClassAccess->
                QueryInterface( IID_IClassAccess, ppvObject );
        }

        BindingCache.Unlock();
    }
    else
    {
        if ( SUCCEEDED(sc) )
        {
            pNewClassAccess->AddRef();
            *ppvObject = pNewClassAccess;
        }
    }

    if ( pNewClassAccess )
    {
        pNewClassAccess->Release();
    }

    return (sc);
}


HRESULT  __stdcall  CAppContainerCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcappcon ); }
    else
    { InterlockedDecrement((long *) &gulcappcon ); }
    return(S_OK);
}

//
// IUnknown methods for CAppContainer
//
//

HRESULT  __stdcall  CAppContainer::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
     else  if( IsEqualIID( IID_IClassAccess, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    /*
    else  if( IsEqualIID( IID_IClassRefresh, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassRefresh *)this;
    }
    else  if( IsEqualIID( IID_ICatInformation, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatInformation *)this;
    }
    */
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CAppContainer::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CAppContainer::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


/*----------------------------------------------------------------------*
GetPackageDetails:

  Parameters:
  [in]  pszPackageName:    The Package Name
  [out] pPackageDetail     Package Detail Structure.

    Functionality:
    Returns the PackageDetail corresp. to a Package given
    by pszPackageName.

      Remarks:
      It constructs the Full Package Name
      and calls GetPackageDetail

        Return Codes:
        Success     S_OK
        Failures    Look at RemapErrorCodes

*----------------------------------------------------------------------*/

// This is not being called currently by anybody and hence is still using PackageId.
HRESULT CAppContainer::GetPackageDetails (
                                          LPOLESTR         pszPackageId,
                                          PACKAGEDETAIL   *pPackageDetail)
{
    HRESULT              hr = S_OK;
    HANDLE               hADs = NULL;
    WCHAR              * szFullName = NULL, szRDN[_MAX_PATH];
    ADS_ATTR_INFO      * pAttr = NULL;
    DWORD                cgot;

    if ((!pszPackageId))
        return E_INVALIDARG;

    hr = StringCchPrintf(szRDN, _MAX_PATH, L"CN=%s", pszPackageId);
    ERROR_ON_FAILURE(hr);
    
    CSDBGPrint((DM_WARNING, 
              IDS_CSTORE_PKG_DETAILS,
              szRDN));

    BuildADsPathFromParent(m_szPackageName, szRDN, &szFullName);

    //
    // We do not enforce packet integrity options here because
    // this is only called in the context of the admin tool and we
    // can rely on ipsec to have executed at that point
    //

    hr = DSServerOpenDSObject( &m_ServerContext, szFullName, GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);

    hr = GetPackageDetail (hADs, NULL, pPackageDetail);

    ADSICloseDSObject(hADs);

    if (pAttr)
        FreeADsMem(pAttr);

    if (szFullName)
        FreeADsMem(szFullName);

Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}


/*----------------------------------------------------------------------*
EnumPackages

  Parameters:
  [in] pszPackageName     Substring match for a package name
  [in] pCategory          Package Category.
  [in] pLastUsn           Last modification time.
  [in] dwAppFlags         Set the following bits to select specific ones
  Published Only  APPINFO_PUBLISHED
  Assigned Only   APPINFO_ASSIGNED
  Msi Only        APPINFO_MSI
  Visible         APPINFO_VISIBLE
  Auto-Install    APPINFO_AUTOINSTALL

    All Locale      APPINFO_ALLLOCALE
    All Platform    APPINFO_ALLPLATFORM

      [out] ppIEnumPackage   Returns the Enumerator

        Functionality
        Obtains an enumerator for packages in the app container.

          Remarks:

*----------------------------------------------------------------------*/

HRESULT CAppContainer::EnumPackages (
                                     LPOLESTR        pszPackageName,
                                     GUID            *pCategory,
                                     ULONGLONG       *pLastUsn,
                                     DWORD           dwQuerySpec,      // AppType options
                                     IEnumPackage    **ppIEnumPackage
                                     )
{
    const DWORD             dwMaxStrLen =  1000;
    HRESULT                 hr = S_OK;
    CEnumPackage           *pEnum = NULL;
    WCHAR                   szLdapFilter[dwMaxStrLen];
    WCHAR                   szLdapFilterFinal[1500];
    UINT                    len = 0;
    UINT                    fFilters = 0;
    CSPLATFORM              *pPlatform = NULL, Platform;
    DWORD                   dwAppFlags;

    //
    // Validate
    //

    switch ( dwQuerySpec )
    {
    case APPQUERY_ALL:
    case APPQUERY_ADMINISTRATIVE:
    case APPQUERY_POLICY:
    case APPQUERY_USERDISPLAY:
    case APPQUERY_RSOP_LOGGING:
    case APPQUERY_RSOP_ARP:
        break;
    default:
        return E_INVALIDARG;
    }

    *ppIEnumPackage = NULL;

    pEnum = new CEnumPackage( &m_ServerContext, m_PolicyId, NULL, m_szContainerName, m_pRsopToken );
    if(NULL == pEnum)
        return E_OUTOFMEMORY;

    //
    // Set client side filters
    //
    dwAppFlags = ClientSideFilterFromQuerySpec( dwQuerySpec, NULL != m_pRsopToken );

    //
    // Create a LDAP Search Filter based on input params
    //

    // Count Filters
    if (pszPackageName && (*pszPackageName))
        fFilters++;
    if ((pLastUsn) && (*pLastUsn))
        fFilters++;
    if (pCategory)
        fFilters++;

    if (fFilters == 0)
    {
        // No Conditionals
        hr = StringCchPrintf (szLdapFilter,
                  dwMaxStrLen,
                  L"(%s=%s)", OBJECTCLASS, CLASS_CS_PACKAGE);
        ERROR_ON_FAILURE(hr);


        len = wcslen (szLdapFilter);
    }
    else
    {

        if (fFilters > 1)
        {
            hr = StringCchPrintf (szLdapFilter, dwMaxStrLen, L"(&");
            ERROR_ON_FAILURE(hr);
            len = wcslen (szLdapFilter);
        }
        else
            len = 0;

        if (pszPackageName)
        {
            //
            // Validate
            //

            if (*pszPackageName)
            {
                hr = StringCchPrintf (&szLdapFilter[len],
                                      dwMaxStrLen - len,
                                      L"(%s=*%s*)",
                                      PACKAGENAME,
                                      pszPackageName);
                ERROR_ON_FAILURE(hr);

                len = wcslen (szLdapFilter);
            }
        }

        if ((pLastUsn) && (*pLastUsn))
        {
            SYSTEMTIME SystemTime;

            FileTimeToSystemTime(
                (CONST FILETIME *) pLastUsn,
                &SystemTime);

            hr = StringCchPrintf (&szLdapFilter[len],
                                  dwMaxStrLen - len,
                                  L"(%s>=%04d%02d%02d%02d%02d%02d)",
                                  PKGUSN,
                                  SystemTime.wYear,
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond+1);
            ERROR_ON_FAILURE(hr);

            len = wcslen (szLdapFilter);
        }

        if (pCategory)
        {
            STRINGGUID szCat;

            StringFromGUID (*pCategory, szCat);
            hr = StringCchPrintf (&szLdapFilter[len],
                                  dwMaxStrLen - len,
                                  L"(%s=%s)",
                                  PKGCATEGORYLIST,
                                  szCat);
            ERROR_ON_FAILURE(hr);

            len = wcslen (szLdapFilter);
        }

        if (fFilters > 1)
        {
            if (dwMaxStrLen - len < 2) 
            {
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                ERROR_ON_FAILURE(hr);
            }
            szLdapFilter[len] = L')';
            szLdapFilter[++len] = NULL;
        }
    }


    //
    // Finish setting the server side filter
    // based on the query type
    //
    ServerSideFilterFromQuerySpec(
        dwQuerySpec,
        NULL != m_pRsopToken,
        szLdapFilter,
        szLdapFilterFinal,
        sizeof(szLdapFilterFinal)/sizeof(szLdapFilterFinal[0]));

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_ENUMPACKAGE,
              szLdapFilterFinal,
              dwAppFlags));
        
    //
    // Check all local/platform flags
    //

    if (!(dwAppFlags & APPFILTER_REQUIRE_THIS_PLATFORM))
    {
        pPlatform = NULL;
    }
    else
    {
        pPlatform = &Platform;
        GetDefaultPlatform(pPlatform);
    }

    if (pLastUsn)
    {
        //
        // Find the current store USN and return it
        //
        LPOLESTR            AttrName = STOREUSN;
        ADS_ATTR_INFO     * pAttr = NULL;
        DWORD               cgot = 0;

        hr = ADSIGetObjectAttributes(m_ADsContainer, &AttrName, 1, &pAttr, &cgot);
        if ((SUCCEEDED(hr)) && (cgot))
        {
            UsnGet(*pAttr, (CSUSN *)pLastUsn);
            if (pAttr)
                FreeADsMem(pAttr);
        }
    }

    hr = pEnum->Initialize(m_szPackageName, szLdapFilterFinal, dwQuerySpec, NULL != m_pRsopToken, pPlatform);
    ERROR_ON_FAILURE(hr);

    hr = pEnum->QueryInterface(IID_IEnumPackage,(void**) ppIEnumPackage);
    ERROR_ON_FAILURE(hr);

    return S_OK;

Error_Cleanup:
    if (pEnum)
        delete pEnum;
    *ppIEnumPackage = NULL;

    return RemapErrorCode(hr, m_szContainerName);
}


// choosing the best package that can be returned after returning from the DS
DWORD CAppContainer::ChooseBestFit(PACKAGEDISPINFO *PackageInfo, UINT *rgPriority, DWORD cRowsFetched)
{
    DWORD i=0, k=0, j = 0, temp = 0;
    DWORD index[10];

    // initialising the indices
    for (i = 0; (i <  cRowsFetched); i++)
        index[i] = i;

    // sort the index based on priority and time stamp
    for (i = 0; (i < (cRowsFetched-1)); i++)
    {
        DWORD Pri = rgPriority[i];
        k = i;
        // max element's index is in k
        for (j=(i+1); (j < cRowsFetched); ++j)
        {
            // order first by weight and then by time stamp.
            if ((rgPriority[index[j]] > Pri) ||
                ((rgPriority[index[j]] == Pri) &&
                 (CompareUsn((FILETIME *)&PackageInfo[index[j]].Usn, (FILETIME *)&PackageInfo[index[k]].Usn) == 1)))
            {
                Pri = rgPriority[index[j]];
                k = j;
            }
        }

        if (k != i)
        {
            temp = index[k];
            index[k] = index[i];
            index[i] = temp;
        }
    }

    DWORD dwPackage;
    DWORD dwBestPackage;

    dwBestPackage = 0;

    //
    // Now the packages are sorted in order from highest precedence to lowest.
    // We will now check for upgrades for each package
    //
    for (dwPackage = 0; (dwPackage < cRowsFetched); dwPackage++)
    {
        DWORD            dwPossibleUpgrader;
        PACKAGEDISPINFO* pBestPackage;

        pBestPackage = PackageInfo+index[dwBestPackage];

        CSDBGPrint((DM_WARNING,
                  IDS_CSTORE_BESTFIT,
                  pBestPackage->pszPackageName));

        //
        // Now search for someone that upgrades the current choice -- look at all packages
        // after the current one since we've already determined that the packages before
        // this one got upgraded (otherwise we wouldn't be here).
        //
        for (dwPossibleUpgrader = dwPackage + 1; dwPossibleUpgrader < cRowsFetched; dwPossibleUpgrader ++)
        {
            PACKAGEDISPINFO* pUpgraderCandidate;

            //
            // Obviously, we don't need to check the current choice
            // to see if it upgrades itself, so skip it
            //
            if (dwPossibleUpgrader == dwBestPackage)
            {
                continue;
            }

            pUpgraderCandidate = PackageInfo + index[dwPossibleUpgrader];

            //
            // See if the upgrader candidate has any upgrades, if not, keep looking
            //
            if (0 == pUpgraderCandidate->cUpgrades)
            {
                continue;
            }

            //
            // Now we have to see if any of those upgrades apply to the package we have
            // currently selected as the best
            //
            DWORD dwUpgrade;
            BOOL  fFoundUpgrade;

            fFoundUpgrade = FALSE;

            for (dwUpgrade = 0; dwUpgrade < pUpgraderCandidate->cUpgrades; dwUpgrade++)
            {
                DWORD dwValidUpgradeMask;

                dwValidUpgradeMask = UPGFLG_Uninstall |
                    UPGFLG_NoUninstall |
                    UPGFLG_Enforced;

                //
                // If this is a valid upgrade
                //
                if (pUpgraderCandidate->prgUpgradeInfoList[dwUpgrade].Flag & dwValidUpgradeMask)
                {
                    //
                    // Does it upgrade the package we think is best at this point? We only
                    // consider upgrades in this container, as we no longer allow upgrades from lower
                    // precedence class stores -- the caller who iterates through each container from
                    // highest precedence to lowest will simply choose the app from the first container in which
                    // we have a match.
                    //
                    // We use memcmp to compare guids to see if the best choice package's guid is listed
                    // as being upgraded by this upgrade candidate
                    //
                    if (memcmp(&((pUpgraderCandidate->prgUpgradeInfoList)[dwUpgrade].PackageGuid),
                               &(pBestPackage->PackageGuid), sizeof(GUID) == 0))
                    {
                        //
                        // We have a match -- reset the current best choice to the upgrade candidate
                        //
                        dwBestPackage = dwPossibleUpgrader;

                        //
                        // another package upgrades this -- no need to look any further, so we quit
                        //
                        CSDBGPrint((DM_WARNING,
                                  IDS_CSTORE_BESTFITSKIP,
                                  pBestPackage->pszPackageName,
                                  pUpgraderCandidate->pszPackageName));

                        break;
                    }
                }
            }

            //
            // If we found an upgrade in the list above, we can stop abort the search for an upgrade now --
            // if we found another, it would just be a lower precedence app since we're iterating from highest to lowest,
            // and we want the highest predecence app that upgrades the currently chosen best app
            //
            if (fFoundUpgrade)
            {
                break;
            }
        }
    }

    DWORD dwChoice;

    dwChoice = index[dwBestPackage];

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_BESTFIT_END,
              PackageInfo[dwChoice].pszPackageName));

    return dwChoice;
}

//
// CAppContainer::GetAppInfo
// -----------------------------
//
//
//
//  Synopsis:       This is the most common access point to the Class Store.
//                  It receives a CLSID and a QUERYCONTEXT.
//                  It looks up the Class Store container for a matching set
//                  of packages with in the context of the QUERYCONTEXT.
//
//                  QUERYCONTEXT includes
//                      Execution Context
//                      Locale Id
//                      Platform/OS
//
//                  If i finds an app that matches the requirements, it returns
//                  an PACKAGEDISPINFO structure containing installation details.
//
//  Arguments:      [in]  clsid
//                  [in]  pQryContext
//                  [out] pPackageInfo
//
//  Returns:        CS_E_PACKAGE_NOTFOUND
//                  S_OK
//
//
//

HRESULT STDMETHODCALLTYPE
CAppContainer::GetAppInfo(
                          uCLSSPEC       *   pclsspec,          // Class Spec (GUID/Ext/MIME)
                          QUERYCONTEXT   *   pQryContext,       // Query Attributes
                          PACKAGEDISPINFO    *   pPackageInfo
                          )

                          //
                          // This is the most common method to access the Class Store.
                          // It queries the class store for implementations for a specific
                          // Class Id, or File Ext, or ProgID.
                          //
                          // If a matching implementation is available (for the object type,
                          // client architecture, locale and class context) then the installation
                          // parameters of the package is returned.
{
    const DWORD dwMaxStrLen = 1000;
    GUID        clsid;
    WCHAR       szfilterbuf[dwMaxStrLen];
    WCHAR*      szfilter = szfilterbuf;
    WCHAR*      szNameFilter;
    STRINGGUID  szClsid;
    UINT        i, iClsid = 0;
    ULONG       cRead;
    HRESULT     hr;
    ULONG       cSize = _MAX_PATH;
    BOOL        fFound = FALSE;
    PLATFORMINFO PlatformInfo;
    LPOLESTR    pFileExt = NULL;
    BOOL        OnDemandInstallOnly = TRUE;
    WCHAR       FileExtLower [10];
    FILETIME    ftCurrentTime;

    szNameFilter = NULL;

    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    if (!m_fOpen)
        return E_FAIL;

    //
    // Check if the TypeSpec is MIMEType
    // then map it to a CLSID
    //

    switch (pclsspec->tyspec)
    {
    case TYSPEC_CLSID:

        if (IsNullGuid(pclsspec->tagged_union.clsid))
            return E_INVALIDARG;
        //
        // Check against known missing ones
        //

        hr = S_OK;

        EnterCriticalSection (&ClassStoreBindList);

        //
        // Retrieve the current time so we can determine
        // if cache entries are expired
        //
        GetSystemTimeAsFileTime( &ftCurrentTime );


        for (iClsid=m_KnownMissingClsidCache.start; (iClsid  != m_KnownMissingClsidCache.end);
                        iClsid = (iClsid+1)%(CLSIDCACHESIZE))
        {
            if ( IsExpired( &ftCurrentTime, &(m_KnownMissingClsidCache.ElemArr[iClsid].Time) ) )
            {
                // all the prev. elems must have expired.

                // delete this element
                m_KnownMissingClsidCache.start = (m_KnownMissingClsidCache.start+1)%CLSIDCACHESIZE;
                m_KnownMissingClsidCache.sz--;

                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_CLASS_PURGE));
                          
                // iClsid will be moved automatically.
                continue;
            }

            if ((IsEqualGUID(pclsspec->tagged_union.clsid,
                            m_KnownMissingClsidCache.ElemArr[iClsid].Clsid)) &&
                ((pQryContext->dwContext) == m_KnownMissingClsidCache.ElemArr[iClsid].Ctx))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_CLASS_HIT));

                hr = CS_E_PACKAGE_NOTFOUND;
                break;
            }
        }

        LeaveCriticalSection (&ClassStoreBindList);

        if (hr == CS_E_PACKAGE_NOTFOUND)
            return hr;

        StringFromGUID (pclsspec->tagged_union.clsid, szClsid);
        hr = StringCchPrintf (szfilter, dwMaxStrLen, L"(%s=%s*)", PKGCLSIDLIST, szClsid);
        if (FAILED(hr)) 
        {
            return hr;
        }
        break;

    case TYSPEC_FILEEXT:

        if ((pclsspec->tagged_union.pFileExt == NULL) ||
            (*(pclsspec->tagged_union.pFileExt) == NULL))
            return E_INVALIDARG;


        if (wcslen(pclsspec->tagged_union.pFileExt) > 9)
            return E_INVALIDARG;

        hr = StringCbCopy (&FileExtLower[0], sizeof(FileExtLower), pclsspec->tagged_union.pFileExt);
        if (FAILED(hr)) 
        {
            return hr;
        }

        _wcslwr (&FileExtLower[0]);

        hr = StringCchPrintf (szfilter,
                              dwMaxStrLen,
                              L"(%s=%s*)",
                              PKGFILEEXTNLIST, &FileExtLower[0]);
        if (FAILED(hr)) 
        {
            return hr;
        }

        pFileExt = &FileExtLower[0];
        break;


    case TYSPEC_PROGID:

        if ((pclsspec->tagged_union.pProgId == NULL) ||
            (*(pclsspec->tagged_union.pProgId) == NULL))
            return E_INVALIDARG;

        hr = StringCchPrintf (szfilter,
                              dwMaxStrLen, 
                              L"(%s=%s)", PKGPROGIDLIST, pclsspec->tagged_union.pProgId);
        if (FAILED(hr)) 
        {
            return hr;
        }

        break;

    case TYSPEC_PACKAGENAME:
        //
        // Validate package name
        //

        if ((pclsspec->tagged_union.ByName.pPackageName == NULL) ||
            (*(pclsspec->tagged_union.ByName.pPackageName) == NULL))
            return E_INVALIDARG;

        //
        // The search filter syntax requires that the package name is
        // properly escaped, so we retrieve such a filter below
        //
        hr = GetEscapedNameFilter( pclsspec->tagged_union.ByName.pPackageName, &szNameFilter );

        if ( FAILED(hr) )
        {
            return hr;
        }

        szfilter = szNameFilter;

        OnDemandInstallOnly = FALSE;
        break;

    case TYSPEC_OBJECTID:
        //
        // Validate object id
        //
        if (IsNullGuid(pclsspec->tagged_union.ByObjectId.ObjectId))
            return E_INVALIDARG;

        LPWSTR EncodedGuid;

        EncodedGuid = NULL;
        hr = ADsEncodeBinaryData((PBYTE)&pclsspec->tagged_union.ByObjectId.ObjectId, sizeof(GUID), &EncodedGuid);
    
        hr = StringCchPrintf(szfilter, dwMaxStrLen, L"(%s=%s)", OBJECTGUID, EncodedGuid);    
        FreeADsMem(EncodedGuid);
        OnDemandInstallOnly = FALSE;
        if (FAILED(hr)) 
        {
            return hr;
        }

        break;

    default:
        return E_NOTIMPL;
    }

    //
    //
    ULONG              cRowsFetched;
    PACKAGEDISPINFO    PackageInfo[10];
    UINT               rgPriority [10];

    ADS_SEARCH_HANDLE  hADsSearchHandle = NULL;

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szfilter, pszInstallInfoAttrNames, cInstallInfoAttr, &hADsSearchHandle);

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_MERGEAPPINFO,
              szfilter));

    ERROR_ON_FAILURE(hr);

    //
    // We obtain the 10 best matches
    //
    hr = FetchInstallData(
        m_ADsPackageContainer,
        hADsSearchHandle,
        pQryContext,
        pclsspec,
        pFileExt,
        10,
        &cRowsFetched,
        &PackageInfo[0],
        &rgPriority[0],
        OnDemandInstallOnly,
        &m_PolicyId,
        m_szGpoPath
        );

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_ONDEMAND,
              cRowsFetched,
              hr));

    if (cRowsFetched == 0)
    {
        hr = CS_E_OBJECT_NOTFOUND;
        //
        // If CLSID was passed cache the miss
        //
        if (pclsspec->tyspec == TYSPEC_CLSID)
        {
            EnterCriticalSection (&ClassStoreBindList);

            if (m_KnownMissingClsidCache.sz < (CLSIDCACHESIZE-1))
            {
                memcpy (&m_KnownMissingClsidCache.ElemArr[m_KnownMissingClsidCache.end].Clsid,
                        &(pclsspec->tagged_union.clsid), sizeof(GUID));

                m_KnownMissingClsidCache.ElemArr[m_KnownMissingClsidCache.end].Ctx
                                    = pQryContext->dwContext;

                //
                // Set the time member to the current time -- this is retrieved
                // above for all clsid queries
                //
                GetExpiredTime( &ftCurrentTime,
                                &(m_KnownMissingClsidCache.ElemArr[m_KnownMissingClsidCache.end].Time) );


                m_KnownMissingClsidCache.sz++;

                m_KnownMissingClsidCache.end = (m_KnownMissingClsidCache.end+1) % CLSIDCACHESIZE;

            }
            LeaveCriticalSection (&ClassStoreBindList);
        }
    }
    else
    {
        DWORD dwChoice = 0;

        if (cRowsFetched > 1)
        {
            dwChoice = ChooseBestFit(PackageInfo, rgPriority, cRowsFetched);
        }


        memcpy (pPackageInfo, &PackageInfo[dwChoice], sizeof(PACKAGEDISPINFO));
        memset (&PackageInfo[dwChoice], NULL, sizeof(PACKAGEDISPINFO));

        // Clean up all allocations
        for (i=0; i < cRowsFetched; i++)
        {
            ReleasePackageInfo(&PackageInfo[i]);
        }
    }

    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);

    //
    // fill in PolicyID
    //
    if (SUCCEEDED(hr))
    {
        memcpy (&(pPackageInfo->GpoId), &m_PolicyId, sizeof(GUID));
    }

Error_Cleanup:

    if ( szNameFilter )
    {
        CsMemFree( szNameFilter );
    }
    
    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_APPINFO_END,
              hr));

    return RemapErrorCode(hr, m_szContainerName);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\cstore.h ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  File:    cstore.h
//
//  Header for class store
//-------------------------------------------------------------------------
#if _MSC_VER > 1000
#pragma once
#endif

#include "cs.h"

void GetDefaultPlatform(CSPLATFORM *pPlatform,
                        BOOL        fArchitectureOverride = FALSE ,
                        LONG        OverridingArchitecture = 0);

BOOL InitializeClassStore(BOOL fInit);
void Uninitialize();

STDAPI CsGetClassAccess(IClassAccess     **     ppIClassAccess);

STDAPI CsEnumApps(LPOLESTR        pszPackageName,
        GUID            *pCategory,
        ULONGLONG       *pLastUsn,
        DWORD           dwAppFlags,
        IEnumPackage    **ppIEnumPackage);

STDAPI CsGetAppInfo(uCLSSPEC       *   pclsspec,
         QUERYCONTEXT   *   pQueryContext,
         PACKAGEDISPINFO    *   pPackageInfo);

STDAPI CsCreateClassStore(LPWSTR szServerName, LPWSTR szPath);
STDAPI CsGetClassStore(LPWSTR szPath, void **ppIClassAdmin);
STDAPI CsServerGetClassStore(LPWSTR szServerName, LPWSTR szPath, void **ppIClassAdmin);
STDAPI CsDeleteClassStore(LPWSTR szPath);
STDAPI CsGetAppCategories(APPCATEGORYINFOLIST *pAppCategoryList);
STDAPI CsRegisterAppCategory(APPCATEGORYINFO *pAppCategory);
STDAPI CsUnregisterAppCategory (GUID *pAppCategoryId);
STDAPI CsGetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR *pCSPath);
STDAPI CsSetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR szCSPath);
STDAPI ReleasePackageInfo(PACKAGEDISPINFO *pPackageInfo);
STDAPI ReleaseInstallInfo(INSTALLINFO *pInstallInfo);
STDAPI ReleasePackageDetail(PACKAGEDETAIL *pPackageDetail);
STDAPI ReleaseAppCategoryInfoList(APPCATEGORYINFOLIST *pAppCategoryInfoList);
void   CsSetOptions( DWORD dwOptions );

const DWORD CsOption_AdminTool = 0x1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\dsapi.cxx ===
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2001
//
//  Author: AdamEd
//  Date:   January 2000
//
//      Abstractions for directory service layer
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

CServerContext::CServerContext() :
    _wszServerName( NULL )
{
}

CServerContext::~CServerContext()
{
    delete [] _wszServerName;
}

HRESULT
CServerContext::Initialize( 
    CServerContext* pServerContext )
{
    return Initialize(
        pServerContext->GetServerName() );       
}

HRESULT
CServerContext::Initialize(
    WCHAR* wszServerName )    
{
    if ( wszServerName )
    {
        _wszServerName = StringDuplicate( wszServerName );

        if ( ! _wszServerName )
        {
            return E_OUTOFMEMORY;
        }
    }
    
    return S_OK;
}

BOOL
CServerContext::Compare( CServerContext* pServerContext )
{
    //
    // If the caller doesn't specify a context, this is equivalent to the
    // case where our context has no state
    //
    if ( ! pServerContext )
    {
        if ( ! _wszServerName )
        {
            return TRUE;
        }

        return FALSE;
    }

    //
    // The caller specified the context, so we ensure they both have state
    // or they both don't -- if there is a difference, they are not equivalent
    //
    if ( ( NULL == _wszServerName ) != ( NULL == pServerContext->_wszServerName ) )         
    {
        return FALSE;
    }

    //
    // We now compare all state specified in this context and the specified context
    //
    if ( _wszServerName )
    {
        if ( CSTR_EQUAL != CompareString(
            LOCALE_INVARIANT,
            NORM_IGNORECASE,
            _wszServerName,
            wcslen( _wszServerName ),
            pServerContext->_wszServerName,
            wcslen( pServerContext->_wszServerName ) ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

WCHAR*
CServerContext::GetServerName()
{
    return _wszServerName;
}

//*************************************************************
//
//  DoesPathContainAServerName()
//
//  Purpose:    Checks the given ADSI path to see if it
//              contains a server name
//
//  Parameters: lpPath - ADSI path
//
//  Return:     True if the path contains a server name
//              FALSE if not
//
//*************************************************************

BOOL DoesPathContainAServerName (LPTSTR lpPath)
{
    BOOL bResult = FALSE;


    //
    // Skip over LDAP:// if found
    //

    if ( CompareString( LOCALE_INVARIANT, NORM_IGNORECASE,
                        lpPath, 7, L"LDAP://", 7 ) == CSTR_EQUAL )
    {
        lpPath += 7;
    }


    //
    // Check if the 3rd character in the path is an equal sign.
    // If so, this path does not contain a server name
    //

    if ((lstrlen(lpPath) > 2) && (*(lpPath + 2) != TEXT('=')))
    {
        bResult = TRUE;
    }

    return bResult;
}


HRESULT
DSGetAndValidateColumn(
    HANDLE             hDSObject,
    ADS_SEARCH_HANDLE  hSearchHandle,
    ADSTYPE            ADsType,
    LPWSTR             pszColumnName,
    PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr;

    //
    // First, instruct adsi to unmarshal the data into
    // the column
    //
    hr = ADSIGetColumn(
        hDSObject,
        hSearchHandle,
        pszColumnName,
        pColumn);

    //
    // Validate the returned data
    //
    if ( SUCCEEDED(hr) )
    {
        //
        // Verify that the type information is correct --
        // if it is not, we cannot safely interpret the data.
        // Incorrect type information is most likely to happen
        // when adsi is unable to download the schema, possibly
        // due to kerberos errors
        //
        if ( ADsType != pColumn->dwADsType )
        {
            //
            // We need to free the column, since the caller is not
            // expected to free it if we return a failure
            //
            ADSIFreeColumn( hDSObject, pColumn );

            hr = CS_E_SCHEMA_MISMATCH;
        }
    }

    return hr;
}


HRESULT DSAccessCheck(
    PSECURITY_DESCRIPTOR pSD,
    PRSOPTOKEN           pRsopUserToken,
    BOOL*                pbAccessAllowed
    )
{
    GENERIC_MAPPING DS_GENERIC_MAPPING = { 
        GENERIC_READ_MAPPING,
        GENERIC_WRITE_MAPPING,
        GENERIC_EXECUTE_MAPPING,
        GENERIC_ALL_MAPPING };

    DWORD   dwAccessMask;                               
    HRESULT hr;

    hr = S_OK;

    if ( pRsopUserToken )
    {
        hr = RsopAccessCheckByType(pSD,
                                   0,
                                   pRsopUserToken,
                                   GENERIC_READ,
                                   NULL,
                                   0,
                                   &DS_GENERIC_MAPPING,
                                   NULL,
                                   NULL,
                                   &dwAccessMask,
                                   pbAccessAllowed );
    }
    else
    {
        //
        // A null user token means we are running in
        // reporting mode where we are trying to dump the
        // contents of the gpo rather than simulate what
        // apps the target might receive,
        // so we should not try to perform
        // an access check (we are running as some user, not
        // as the system).  Instead, if we retrieved the app,
        // we have access, so we always return TRUE in this case
        //

        *pbAccessAllowed = TRUE;
    }

    return hr;
}

HRESULT
DSServerOpenDSObject(
    CServerContext* pServerContext,
    LPWSTR          pszDNName,
    LONG            lFlags,
    PHANDLE         phDSObject
    )
{
    WCHAR* wszServerBasedPath = NULL;
    WCHAR* wszServerName = pServerContext ? pServerContext->GetServerName() : NULL;
    WCHAR* wszPath = pszDNName;
    BOOL   bServerName = FALSE;

    //
    // Check to see if there's a server name in the path -- only do this
    // if the caller is specifying a server name -- otherwise, we assume
    // that there is no server name in the path (a domain name may be specified,
    // but that is not the same as a server).
    //
    if ( wszServerName && DoesPathContainAServerName( wszPath ) )
    {
        lFlags |= ADS_SERVER_BIND;  

        bServerName = TRUE;
    }

    //
    // If a server is specified and the path doesn't already have a server, we need to create a server based LDAP path
    // to pass to adsi
    //
    if ( ! bServerName && wszServerName )
    {
        //
        // The DN passed to this function is a serverless path of the form
        //
        // LDAP://<DN>
        //
        // We need to transform it to a path of the form
        //
        // LDAP://<Server>/<DN>
        
        //
        // We first allocate space for the transformation
        //
        DWORD cchServerBasedPath = wcslen( wszServerName ) + 1 + wcslen( pszDNName ) + 1;

        wszServerBasedPath = new WCHAR [ cchServerBasedPath ];

        if ( NULL == wszServerBasedPath )
        {
            return E_OUTOFMEMORY;
        }

        //
        // Perform the transformation
        //
        (void) StringCchCopy( wszServerBasedPath, cchServerBasedPath, LDAPPREFIX );
        (void) StringCchCat( wszServerBasedPath, cchServerBasedPath, wszServerName );
        (void) StringCchCat( wszServerBasedPath, cchServerBasedPath, L"/" );
        (void) StringCchCat( wszServerBasedPath, cchServerBasedPath, pszDNName + sizeof( LDAPPREFIX ) / sizeof(WCHAR) - 1 );

        wszPath = wszServerBasedPath;

        //
        // Since we are binding to a server, add the flag that gives
        // the hint to ldap to bind
        //
        lFlags |= ADS_SERVER_BIND; 
    }    

    HRESULT hr;

    hr = ADSIOpenDSObject(
        wszPath,
        NULL,
        NULL,
        lFlags,
        phDSObject);

    if ( wszServerBasedPath )
    {
        delete [] wszServerBasedPath;
    }

    return hr;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\cspath.cxx ===
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  Author: AdamEd
//  Date:   October 1998
//
//      Class Store path query / persistence
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"
#include "cspath.hxx"

HRESULT
GetAppmgmtIniFilePath(
    PSID        pSid,
    LPWSTR*     ppwszPath
    )
{
    UNICODE_STRING  SidString;
    PTOKEN_USER     pTokenUser;
    WCHAR           wszPath[MAX_PATH];
    WCHAR *         pwszSystemDir = NULL;
    DWORD           AllocLength;
    DWORD           Length;
    DWORD           Size;
    BOOL            bStatus;
    ULONG           ulSize;

    *ppwszPath = 0;

    pwszSystemDir = wszPath;
    AllocLength = sizeof(wszPath) / sizeof(WCHAR);

    for (;;)
    {
        Length = GetSystemDirectory(
                    pwszSystemDir,
                    AllocLength );

        if ( 0 == Length )
            return HRESULT_FROM_WIN32(GetLastError());

        if ( Length >= AllocLength )
        {
            AllocLength = Length + 1;
            if (pwszSystemDir != wszPath)
            {
                LocalFree(pwszSystemDir);
            }
        
            pwszSystemDir = (WCHAR *) LocalAlloc( LPTR, AllocLength * sizeof(WCHAR) );
            if (NULL == pwszSystemDir)
            {
                return E_OUTOFMEMORY;
            }

            continue;
        }

        break;
    }

    if ( pSid )
    {
        NTSTATUS ntStatus;
        DWORD dwStatus;

        ntStatus = RtlConvertSidToUnicodeString(
            &SidString,
            pSid,
            TRUE );
            
        if (!NT_SUCCESS(ntStatus)) 
        {
            if (pwszSystemDir != wszPath)
            {
                LocalFree(pwszSystemDir);
            }

            dwStatus = RtlNtStatusToDosError(ntStatus);
            return HRESULT_FROM_WIN32(dwStatus);
        }

    }
    else
    {
        RtlInitUnicodeString( &SidString, L"MACHINE" );
    }

    HRESULT         hr;

    // System dir + \appmgmt\ + Sid \ + inifilename \ + null 

    ulSize = Length + 11 + (SidString.Length / 2) + (sizeof(APPMGMT_INI_FILENAME) / sizeof(WCHAR));
    *ppwszPath = new WCHAR[ulSize];

    if ( *ppwszPath )
    {
        hr = StringCchCopy( *ppwszPath, ulSize, pwszSystemDir );
        if (SUCCEEDED(hr)) 
        {
            if ( pwszSystemDir[lstrlen(pwszSystemDir)-1] != L'\\' )
            {
                hr = StringCchCat( *ppwszPath, ulSize, L"\\" );
            }
            if (SUCCEEDED(hr)) 
            {
                hr = StringCchCat( *ppwszPath, ulSize, L"appmgmt\\" );
                if (SUCCEEDED(hr)) 
                {
                    hr = StringCchCat( *ppwszPath, ulSize, SidString.Buffer );
                    if (SUCCEEDED(hr)) 
                    {
                        hr = StringCchCat( *ppwszPath, ulSize, APPMGMT_INI_FILENAME );
                    }

                }
            }

        }        
        if (FAILED(hr))
        {
            if ( pSid )
                RtlFreeUnicodeString( &SidString );
            if (pwszSystemDir != wszPath)
            {
                LocalFree(pwszSystemDir);
            }
            return hr;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( pSid )
        RtlFreeUnicodeString( &SidString );
    
    if (pwszSystemDir != wszPath)
    {
        LocalFree(pwszSystemDir);
    }


    return hr;
}

LONG
GetClassStorePathSize(
    HANDLE hFile,
    DWORD* pdwSize)
{
    BOOL    bStatus;
    DWORD   cbSizeHigh;

    //
    // Initialize the size to the length of an empty path -- this way
    // if no file is passed in we will treat that as a class store path 
    // of zero length (excluding the terminator).  This length must include
    // the terminator, so we set our initial size to that of an empty string
    //
    *pdwSize = sizeof(L'\0');

    //
    // If we have an open file with data, determine the size of the data
    //
    if ( hFile )
    {
        //
        // GetFileSize returns the logical size of the file, regardless
        // of whether the logical size is the same as the physical 
        // size due to the vagaries of different file systems or compression
        //
        *pdwSize = GetFileSize(
            hFile,
            &cbSizeHigh);

        //
        // Check for a failure from the api
        //
        if ( -1 == *pdwSize )
        {
            return GetLastError();
        }

        //
        // Check the size for validity -- a file of ridiculous
        // size will be rejected
        //
        if ( cbSizeHigh )
        {
            //
            // If the high dword is set, clearly this file
            // contains an unreasonable amount of data
            //
            return ERROR_INSUFFICIENT_BUFFER;
        } 
        else if ( *pdwSize > MAX_CSPATH_SIZE )
        {
            //
            // Again, the size should be within reasonable limits
            //
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    return ERROR_SUCCESS;
}



LONG 
ReadClassStorePathFromFile(
    HANDLE hFile,
    WCHAR* wszDestination,
    DWORD  cbSize)
{
    DWORD  cbRead;
    BOOL   bStatus;

    //
    // The format of the file is simple -- it is simply the stream of bytes
    // that represent a unicode string terminated by a null unicode character -- 
    // we can just read the data directly and copy it to a buffer referenced by
    // a WCHAR* -- it will be legitimate unicode string once we read it in -- it includes
    // the null unicode char as the last byte read
    //
    
    //
    // Note that we've read nothing so far
    //
    cbRead = 0;

    //
    // If the file has data, read it
    //
    if ( cbSize )
    {
        //
        // Read the data from the file into the buffer
        //
        bStatus = ReadFile(
            hFile,
            wszDestination,
            cbSize,
            &cbRead,
            NULL);

        if (!bStatus)
        {
            return GetLastError();
        }

        //
        // Verify that the last character read was a null unicode character.
        // If it wasn't, the file is corrupt -- return an error so we don't
        // try to use the corrupt data and cause repeated errors or even crashes
        //
        if ( wszDestination[ cbRead / sizeof(*wszDestination) - 1 ] != L'\0' )
        {
            return ERROR_FILE_CORRUPT;
        }
    }
    else
    {
        //
        // For empty files, we simply return an empty unicode string
        //
        wszDestination[ 0 ] = L'\0';
    }

    return ERROR_SUCCESS;
}


HRESULT ReadClassStorePath(PSID pSid, LPWSTR* ppwszClassStorePath)
{
    HRESULT hr;
    LPWSTR  wszIniFilePath;
    DWORD   cbSize;
    WCHAR*  wszClassStorePath;
    LONG    Status;
    HANDLE  hFile;

    cbSize = 0;

    //
    // Notes: The file being read by this function was originally an
    // ini file as generated by the WritePrivateProfileSection api.
    // Unfortunately, the corresponding GetPrivateProfileString was horribly
    // broken in the sense that it had a 32k limit on the size of values.  This
    // was not acceptable for our design, so we read the file directly
    //

    hr = GetAppmgmtIniFilePath(
        pSid,
        &wszIniFilePath);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Initialize our reference to conditionally freed data
    //
    wszClassStorePath = NULL;

    //
    // First, attempt to open the file, which should already exist.  We
    // generally do not expect concurrent readers, as there
    // are only two processes from which this file is read: services
    // and winlogon.  Neither should be reading it at the same time, though
    // a terminal server case where the same user was logged in to the machine
    // twice could cause it
    //
    hFile = CreateFile(
        wszIniFilePath,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    //
    // Handle the failure cases
    //
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        //
        // We want to use NULL to indicate the absence of the file
        //
        hFile = NULL;

        Status = GetLastError();

        //
        // If the file did not exist, that's ok -- we interpret the
        // absence of the file as a blank class store path -- we
        // will not exit if the file didn't exist
        //
        if (ERROR_FILE_NOT_FOUND != Status) 
        {
            goto cleanup_and_exit;
        }
    }
    else
    {
        //
        // If we don't have a file in existence, this means a zero length
        // class store path
        //
        cbSize = 0;
    }

    //
    // Now that we have access to the file or know that the file does
    // not exist, we can calculate the size of the class store path
    // from the file's size, as they have a 1-1 relationship.  Note that if the
    // file does not exist, then hFile will be NULL
    //
    if ( hFile )
    {
        Status = GetClassStorePathSize(
            hFile,
            &cbSize);

        if ( ERROR_SUCCESS != Status )
        {
            goto cleanup_and_exit;
        }
    }

    //
    // We know the size, so allocate space, treating the size 
    // as the length (in bytes) of the string including the terminator --
    // to handle the case where cbSize is zero because of a nonexistent
    // cs path, we will also add a terminating NULL since zero length
    // strings are still 1 character in size
    //
    wszClassStorePath = new WCHAR [ cbSize / sizeof(*wszClassStorePath) + 1 ];

    if ( wszClassStorePath )
    {
        //
        // We have a buffer, so read the unicode string into
        // the buffer
        //
        Status = ReadClassStorePathFromFile(
            hFile,
            wszClassStorePath,
            cbSize);
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

cleanup_and_exit:

    //
    // We no longer need the path to the ini file -- free it
    //
    delete [] wszIniFilePath;

    //
    // Close the file if it's open
    //
    if ( hFile )
    {
        CloseHandle( hFile );
    }

    //
    // On success, set the out param.  On failure,
    // free any buffer we allocated for the class store path
    //
    if (ERROR_SUCCESS == Status)
    {
        *ppwszClassStorePath = wszClassStorePath;
    }
    else
    {
        delete [] wszClassStorePath;
    }

    return HRESULT_FROM_WIN32(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\dscon.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  Author: DebiM
//  Date:   September 1996
//
//
//      Class Store Schema creation and access using ADs
//
//      This source file contains implementations for IClassAccess,
//      interface for CClassAccess object.
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

HRESULT CreateContainer (HANDLE pParent,
                         LPOLESTR szName,
                         LPOLESTR szDesc
                         )
{
    
    HRESULT         hr;
    int             l;
    ADS_ATTR_INFO   Attr[2];
    
    //
    // Use the Parent Container interface to Create the child.
    //
    
    PackStrToAttr(Attr, OBJECTCLASS, CLASS_CS_CONTAINER);
    
    PackStrToAttr(Attr+1, DESCRIPTION, szDesc);

    hr = ADSICreateDSObject(pParent, szName, Attr, 2);

    //
    // Free the attributes used above
    //
    FreeAttr( Attr[0] );
    FreeAttr( Attr[1] );
    
    return hr;
    
}



HRESULT CreateRepository(CServerContext* pServerContext, LPOLESTR szParentPath, LPOLESTR szStoreName, LPOLESTR szPolicyDn)
{
    
    HRESULT         hr = S_OK;
    HANDLE          hADsParent = NULL;
    HANDLE          hADsContainer = NULL;
    HANDLE          hADsPolicy = NULL;
    LPOLESTR        szContainerName = NULL;
    LPOLESTR        szPolicyName = NULL;
    int             l;
    WCHAR           szPath [_MAX_PATH];
    WCHAR         * szFullName = NULL;
    WCHAR           szUsn[30];
    ADS_ATTR_INFO   pAttr[4];   
    DWORD           cGot = 0, cModified = 0;
    BOOL            fCreatedContainer = FALSE;

    LPOLESTR        AttrName = GPNAME;
    ADS_ATTR_INFO   * pGetAttr = NULL;
        
    if (!szParentPath)
    {
        hr = GetRootPath(pServerContext, szPath, _MAX_PATH);
        //
        // If failed go away
        //
        if (FAILED(hr))
        {
            return hr;
        }
        
        szParentPath = szPath;
    }
    
    //
    // First get the PolicyName
    //
    if (szPolicyDn)
    {        
        hr = DSServerOpenDSObject(pServerContext, szPolicyDn, GetDsFlags(),
            &hADsPolicy);
        RETURN_ON_FAILURE(hr);
        
        //
        // Get the PolicyName
        //
        
        hr = ADSIGetObjectAttributes(hADsPolicy, &AttrName, 1, &pGetAttr, &cGot);
        
        if (SUCCEEDED(hr) && (cGot))
            UnpackStrAllocFrom(pGetAttr[0], &szPolicyName);
    
        if (pGetAttr)
            FreeADsMem(pGetAttr);
        pGetAttr = NULL;

        ADSICloseDSObject(hADsPolicy);
    }

    hr = DSServerOpenDSObject(pServerContext, szParentPath, GetDsFlags(),
        &hADsParent);
    RETURN_ON_FAILURE(hr);
    
    hr = CreateContainer(hADsParent,
        szStoreName,
        L"Application Store");

    //
    // handle this error correctly
    // see if a broken class store is left behind
    // this could happen due to DS going down after incomplete creation etc.
    // from the class store container property you could tell
    //
    if ((hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) ||
        (hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)))
    {
        //
        // There is a Class Store already
        // See if it is a good one.

        DWORD dwStoreVersion = 0;
        hr = BuildADsPathFromParent(szParentPath, szStoreName, &szFullName);
        if (!SUCCEEDED(hr))
            return CS_E_OBJECT_ALREADY_EXISTS;
        
        hr = DSServerOpenDSObject(pServerContext, szFullName, GetDsFlags(),
            &hADsContainer);
        
        FreeADsMem(szFullName);
        if (!SUCCEEDED(hr))
            return CS_E_OBJECT_ALREADY_EXISTS;

        AttrName = STOREVERSION;
        //
        // Get the Store Version
        //
        
        hr = ADSIGetObjectAttributes(hADsContainer, &AttrName, 1, &pGetAttr, &cGot);
        
        if (SUCCEEDED(hr) && (cGot))
            UnpackDWFrom(pGetAttr[0], &dwStoreVersion);
        
        if (pGetAttr)
            FreeADsMem(pGetAttr);

        ADSICloseDSObject(hADsContainer);

        if (dwStoreVersion == SCHEMA_VERSION_NUMBER)
            return CS_E_OBJECT_ALREADY_EXISTS;

        // if it is zero, then it was aborted in the middle.
        if (dwStoreVersion != 0)
            return CS_E_SCHEMA_MISMATCH;

        // If it is a bad one try to delete it
        DeleteRepository(pServerContext, szParentPath, szStoreName);

        //
        // Then again try to create it and proceed if successful
        //
        
        hr = CreateContainer(hADsParent,
            szStoreName,
            L"Application Store");
        
    }

    ERROR_ON_FAILURE(hr);
    fCreatedContainer = TRUE;

    hr = BuildADsPathFromParent(szParentPath, szStoreName, &szFullName);
    ERROR_ON_FAILURE(hr);
    
    hr = DSServerOpenDSObject(pServerContext, szFullName, GetDsFlags(),
        &hADsContainer);
    
    ERROR_ON_FAILURE(hr);

    //
    // Create the package container
    //
    
    hr = CreateContainer (hADsContainer,
        PACKAGECONTAINERNAME,
        L"Application Packages");
    
    ERROR_ON_FAILURE(hr);
    
    //
    // Store the USN and PolicyID properties
    //

    GetCurrentUsn(szUsn);
    
    PackStrToAttr(&pAttr[0], STOREUSN, szUsn);
    PackStrToAttr(&pAttr[1], POLICYDN, szPolicyDn);
    PackStrToAttr(&pAttr[2], POLICYNAME, szPolicyName);
    PackDWToAttr(&pAttr[3], STOREVERSION, SCHEMA_VERSION_NUMBER);
    
    hr = ADSISetObjectAttributes(hADsContainer, pAttr, 4, &cModified);

    FreeAttr(pAttr[0]);
    FreeAttr(pAttr[1]);
    FreeAttr(pAttr[2]);
    FreeAttr(pAttr[3]);
    
    ADSICloseDSObject(hADsContainer);
    ADSICloseDSObject(hADsParent);
    
    FreeADsMem(szFullName);
    CsMemFree(szPolicyName);

    return RemapErrorCode(hr, szParentPath);

Error_Cleanup:
    
    if (hADsContainer)
        ADSICloseDSObject(hADsContainer);

    if (fCreatedContainer)
        ADSIDeleteDSObject(hADsParent, szStoreName);
    if (hADsParent)
        ADSICloseDSObject(hADsParent);

    if (szFullName)
        FreeADsMem(szFullName);
    if (szPolicyName)
        CsMemFree(szPolicyName);
    
    return RemapErrorCode(hr, szParentPath);
   
}

    
HRESULT DeleteRepository(CServerContext* pServerContext, LPOLESTR szParentPath, LPOLESTR szStoreName)
{
    HRESULT         hr = S_OK;
    HANDLE          hADsParent = NULL;
    HANDLE          hADsContainer = NULL;
    WCHAR         * szFullName = NULL;
        
    hr = DSServerOpenDSObject(pServerContext, szParentPath, GetDsFlags(),
        &hADsParent);
    RETURN_ON_FAILURE(hr);
    
    hr = BuildADsPathFromParent(szParentPath, szStoreName, &szFullName);
    
    hr = DSServerOpenDSObject(pServerContext, szFullName, GetDsFlags(),
        &hADsContainer);
    FreeADsMem(szFullName);
    ERROR_ON_FAILURE(hr);

    ADSIDeleteDSObject(hADsContainer, PACKAGECONTAINERNAME);
    ADSICloseDSObject(hADsContainer);
    
    ADSIDeleteDSObject(hADsParent, szStoreName);
    ADSICloseDSObject(hADsParent);
    
    return S_OK;

Error_Cleanup:
    if (hADsContainer)
        ADSICloseDSObject(hADsContainer);
    if (hADsParent)
        ADSICloseDSObject(hADsParent);
    return hr;
}



HRESULT GetRootPath(CServerContext* pServerContext, LPOLESTR szContainer, ULONG ulSize)
{
    HRESULT         hr = S_OK;
    ULONG           cGot = 0;
    HANDLE          hADs = NULL;
    LPOLESTR        AttrName = {L"defaultNamingContext"}, pDN = NULL;
    ADS_ATTR_INFO * pAttr = NULL;
    
    szContainer[0] = L'\0';

    //
    // Do a bind to the machine by a GetObject for the Path
    //
    hr = DSServerOpenDSObject(pServerContext, L"LDAP://rootdse", GetDsFlags(),
                            &hADs);
    RETURN_ON_FAILURE(hr);
    
    hr = ADSIGetObjectAttributes(hADs, &AttrName, 1, &pAttr, &cGot);
    
    if (SUCCEEDED(hr) && (cGot))
        UnpackStrFrom(pAttr[0], &pDN);
    else
        pDN = L"\0";

    hr = StringCchPrintf(szContainer, ulSize, L"%s%s", LDAPPREFIX, pDN);
    
    ADSICloseDSObject(hADs);

    if (pAttr)
        FreeADsMem(pAttr);

    return hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\cslang.cxx ===
//+--------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Author: AdamEd
//  Date:   October 1998
//
//  Implementation of language support
//  in the Class Store interface module
//
//
//---------------------------------------------------------------------


#include "cstore.hxx"

LANGID gSystemLangId;


//+--------------------------------------------------------------------
//
// InitializeLanguageSupport
//
// Routine Description: 
//
//     Called at dll init to initialize globals necessary for
//     language support
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     none
//---------------------------------------------------------------------
void InitializeLanguageSupport()
{
    gSystemLangId = GetSystemDefaultLangID();
}


DWORD GetLanguagePriority(LANGID PackageLangId, DWORD dwActFlags)
{
    //
    // If the activation flags indicate that we should always
    // match regardless of language, this package gets the highest
    // precedence
    //
    if (dwActFlags & ACTFLG_IgnoreLanguage) {
        return PRI_LANG_ALWAYSMATCH;
    }

    //
    // The ignore language flag was not specified by the admin,
    // so now we must examine the language id of the package to
    // determine its desirability.
    //

    //
    // First, match against the system locale's language --
    // exact matches get highest priority
    //
    if (gSystemLangId == PackageLangId)
    {
        return PRI_LANG_SYSTEMLOCALE;
    }

    //
    // Try English -- English should function on all systems
    //
    if (LANG_ENGLISH == PRIMARYLANGID(PackageLangId))
    {
        return PRI_LANG_ENGLISH;
    }

    //
    // If we couldn't get better matches, accept language neutral
    // packages as a last resort
    //
    if (LANG_NEUTRAL == PackageLangId) {
        return PRI_LANG_NEUTRAL;
    }

    //
    // We couldn't find a match -- return the smallest priority
    //

    return 0;
}








=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\clsacc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    cclsacc.cxx
//
//  Contents:    Class factory and IUnknown methods for CClassAccess
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"


HRESULT  __stdcall  CClassAccess::QueryInterface(REFIID riid, void  * * ppvObject)

{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    else  if( IsEqualIID( IID_IClassAccess, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);

}

ULONG __stdcall  CClassAccess::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassAccess::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


//
// Constructor
//
unsigned long gulcClassFactory = 0;

CClassAccessCF::CClassAccessCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcClassFactory );
}

//
// Destructor
//
CClassAccessCF::~CClassAccessCF()
{
    InterlockedDecrement((long *) &gulcClassFactory );
}

HRESULT  __stdcall  CClassAccessCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassAccessCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassAccessCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}

//
// IClassFactory Overide
//
HRESULT  __stdcall  CClassAccessCF::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void  * * ppvObject)
{
    CClassAccess *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CClassAccess()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
            pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}

HRESULT  __stdcall  CClassAccessCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcClassFactory ); }
    else
    { InterlockedDecrement((long *) &gulcClassFactory ); }
    return(S_OK);
}


CClassAccess::CClassAccess()

{
     m_uRefs = 1;
     m_cCalls = 0;
     pStoreList = NULL;
     cStores = 0;
     m_pszClassStorePath = NULL;
     m_pRsopUserToken = NULL;
}

CClassAccess::~CClassAccess()

{
    DWORD i;

    delete [] m_pszClassStorePath;

    for (i = 0; i < cStores; i++)
    {
        if (pStoreList[i]->pszClassStorePath)
        {
            CsMemFree (pStoreList[i]->pszClassStorePath);
            pStoreList[i]->pszClassStorePath = NULL;
        }
        CsMemFree(pStoreList[i]);
        pStoreList[i] = NULL;

    }
    CsMemFree(pStoreList);
    cStores = NULL;
}

//----------------------------------------------------------------------
//
//

void PrintClassSpec(
      uCLSSPEC       *   pclsspec         // Class Spec (GUID/Ext/MIME)
     )
{
    STRINGGUID szClsid;

    if (pclsspec->tyspec == TYSPEC_CLSID)
    {
        StringFromGUID (pclsspec->tagged_union.clsid, szClsid);

        CSDBGPrint((DM_WARNING,
                  IDS_CSTORE_CLASSSPEC,
                  TYSPEC_CLSID,
                  szClsid));
    }

    if (pclsspec->tyspec == TYSPEC_PROGID)
    {

        CSDBGPrint((DM_WARNING,
                  IDS_CSTORE_CLASSSPEC,
                  TYSPEC_PROGID,
                  pclsspec->tagged_union.pProgId));
    }

    if (pclsspec->tyspec == TYSPEC_FILEEXT)
    {
        CSDBGPrint((DM_WARNING,
                  IDS_CSTORE_CLASSSPEC,
                  TYSPEC_FILEEXT,
                  pclsspec->tagged_union.pFileExt));
    }
}

//----------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
CClassAccess::GetAppInfo(
         uCLSSPEC           *   pclsspec,            // Class Spec (GUID/Ext/MIME)
         QUERYCONTEXT       *   pQryContext,         // Query Attributes
         PACKAGEDISPINFO    *   pPackageInfo
        )

        //
        // This is the most common method to access the Class Store.
        // It queries the class store for implementations for a specific
        // Class Id, or File Ext, or ProgID or MIME type.
        //
        // If a matching implementation is available for the object type,
        // client architecture, locale and class context pointer to the
        // binary is returned.
{

    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //
    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr = S_OK;
    ULONG               i = 0, j = 0, k= 0;
    IClassAccess    *   pICA = NULL;
    BOOL                fCache = FALSE;
    PSID                pUserSid = NULL;
    BOOL                fFound = FALSE;
    QUERYCONTEXT        QueryContext;

    if ((!pPackageInfo))
            return E_INVALIDARG;

    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    if ( pQryContext )
    {
        QueryContext = *pQryContext;
    }
    else
    {
        // gets the default information.
        QueryContext.dwContext = CLSCTX_ALL;
        GetDefaultPlatform( &QueryContext.Platform );
        QueryContext.Locale = LANG_SYSTEM_DEFAULT;
        QueryContext.dwVersionHi = (DWORD) -1;
        QueryContext.dwVersionLo = (DWORD) -1;
    }

    if (gDebug)
        PrintClassSpec(pclsspec);

    if (!pStoreList)
        hr = GetUserClassStores(
                    m_pszClassStorePath,
                    &pStoreList,
                    &cStores,
                    &fCache,
                    &pUserSid);


    ERROR_ON_FAILURE(hr);

    for (i=0; i < cStores; i++)
    {

        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, pUserSid, NULL, pclsspec, fCache, &i, &hr)))
        {
            ASSERT(FAILED(hr));
            return hr;
        }

        //
        // Call method on this store
        //

        pICA->AddRef();

        hr = pICA->GetAppInfo(
            pclsspec,
            &QueryContext,
            pPackageInfo);

        // Release it after use.

        pICA->Release();

        if ( CS_E_OBJECT_NOTFOUND != hr )
        {
            ERROR_ON_FAILURE(hr);
        }

        //
        // We are iterating through the class stores from highest precedence to lowest --
        // thus, the first container to return success will be our choice.
        //
        if (SUCCEEDED(hr))
        {
            fFound = TRUE;
            break;
        }

        hr = S_OK;
    }

    if ( ! fFound )
    {
        hr = CS_E_PACKAGE_NOTFOUND;
    }

 Error_Cleanup:

    if (pUserSid)
        CsMemFree (pUserSid);

    if ( pICA )
    {
        pICA->Release();
    }

    if (fFound)
    {
        return S_OK;
    }

    return hr;
}

#define MAX_GUID_CCH 38
//
// IsClassStoreForPolicy
//

BOOL IsClassStoreForPolicy(CLASSCONTAINER* pClassStore,
                           LPWSTR          wszPolicyId)
{
    LPWSTR pszPolicyGuid;

    // Path looks like:
    // LDAP://CN=<Class Store Name>,CN=<user-or-machine>,CN=<{policy-guid}>,...

    //
    // Look for ',' first
    //
    pszPolicyGuid = wcschr(pClassStore->pszClassStorePath, L',');

    if (!pszPolicyGuid)
    {
        return FALSE;
    }

    //
    // Look for the second ','
    //
    pszPolicyGuid = wcschr(pszPolicyGuid + 1, L',');

    if (!pszPolicyGuid)
    {
        return FALSE;
    }

    //
    // Now get to '{' at start of guid -- it is 4 chars
    // past the ',' which we are currently at.  Use wcschr
    // to make sure we don't go past the end of the string
    // and that our assumptions about the structure of the
    // path are correct
    //
    if (wcschr(pszPolicyGuid, L'{') == (pszPolicyGuid + 4))
    {

        pszPolicyGuid += 4;

        //
        // Now that we have the '{', we are at the start of the guid
        // and can compare with the requested policy id
        //
        if (_wcsnicmp(pszPolicyGuid, wszPolicyId, MAX_GUID_CCH) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//
// GetNextValidClassStore
//
//

IClassAccess *GetNextValidClassStore(CLASSCONTAINER** pStoreList,
                                     DWORD            cStores,
                                     PSID             pUserSid,
                                     PRSOPTOKEN       pRsopToken,
                                     uCLSSPEC*        pClassSpec,
                                     BOOL             fCache,
                                     DWORD *          pcount,
                                     HRESULT*         phr)
{
    IClassAccess *pretICA = NULL;
    BOOL          bSpecificPolicy;
    LPWSTR        wszPolicyGuid;

    wszPolicyGuid = NULL;

    *phr = S_OK;

    bSpecificPolicy = pClassSpec ? TYSPEC_PACKAGENAME == pClassSpec->tyspec : FALSE;

    if (bSpecificPolicy)
    {
        GuidToString(pClassSpec->tagged_union.ByName.PolicyId, &wszPolicyGuid);

        if (!wszPolicyGuid) {
            *phr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(*phr))
    {
        for (pStoreList += (*pcount); (*pcount) < cStores; (*pcount)++, pStoreList++)
        {
            if (bSpecificPolicy &&
                !IsClassStoreForPolicy(*pStoreList, wszPolicyGuid))
            {
                continue;
            }

            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_BIND,
                          (*pcount),
                          (*pStoreList)->pszClassStorePath));
                //
                // Bind to this Class Store
                //

                if (wcsncmp((*pStoreList)->pszClassStorePath, L"LDAP:", 5) == 0)
                {
                    //
                    // If the Storename starts with ADCS or LDAP
                    // it is NTDS based implementation. Call directly.
                    //

                    IClassAccess *pCA = NULL;
                    LPOLESTR szClassStore = (*pStoreList)->pszClassStorePath;

                    *phr = pCF->CreateConnectedInstance(
                        NULL,
                        szClassStore,
                        pUserSid,
                        pRsopToken,
                        fCache,
                        (void **)&pCA);

                    if ( ! SUCCEEDED(*phr) )
                    {
                        break;
                    }

                    pretICA = pCA;
                }
                else
                {
                    *phr = CS_E_INVALID_PATH;
                }

                break;
            }
        }
    }

    if (wszPolicyGuid)
    {
        CsMemFree(wszPolicyGuid);
    }

    if (!pretICA)
    {
        ASSERT(FAILED(*phr));
    }

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_BIND_STATUS,
              *phr));

    return pretICA;
}


HRESULT STDMETHODCALLTYPE CClassAccess::EnumPackages(
        LPOLESTR        pszPackageName,
        GUID            *pCategory,
        ULONGLONG       *pLastUsn,
        DWORD           dwQuerySpec,
        IEnumPackage    **ppIEnumPackage)
{
    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr = S_OK;
    ULONG               i;
    IEnumPackage      **Enum;
    ULONG               cEnum = 0;
    CMergedEnumPackage *EnumMerged = NULL;
    IClassAccess       *pICA = NULL;
    ULONGLONG          LastUsn, CopyLastUsn, *pCopyLastUsn;
    BOOL               fCache = FALSE;
    PSID               pUserSid = NULL;

    switch ( dwQuerySpec )
    {
    case APPQUERY_ALL:
    case APPQUERY_ADMINISTRATIVE:
    case APPQUERY_POLICY:
    case APPQUERY_USERDISPLAY:
    case APPQUERY_RSOP_LOGGING:
    case APPQUERY_RSOP_ARP:
        break;
    default:
        return E_INVALIDARG;
    }

    LastUsn = 0;

    if (pLastUsn)
    {
        pCopyLastUsn = &CopyLastUsn;
        *pCopyLastUsn = *pLastUsn;
    }
    else
        pCopyLastUsn = NULL;

    //
    // Get the list of Class Stores for this user
    //
    if (!pStoreList)
        hr = GetUserClassStores(
                        m_pszClassStorePath,
                        &pStoreList,
                        &cStores,
                        &fCache,
                        &pUserSid);

    *ppIEnumPackage = NULL;


    if ((hr == S_OK) && (cStores == 0))
    {
        hr = CS_E_NO_CLASSSTORE;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Dynamically allocate a vector of interfaces (class stores).
        // Previously, this was a fixed size array, which, besides
        // only allowing for a small number of class stores, caused an
        // access violation because the rest of the code assumed that the
        // size of the fixed array could be arbitrarily large.
        //
        Enum = new IEnumPackage*[cStores];

        if (!Enum)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (!SUCCEEDED(hr))
    {
        //
        // Free the Sid
        //
        if (pUserSid)
            CsMemFree (pUserSid);
        return hr;
    }

    for (i=0; i < cStores; i++)
    {
        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, pUserSid, m_pRsopUserToken, NULL, fCache, &i, &hr)))
        {
            ASSERT(FAILED(hr));
            return hr;
        }

        //
        // Call method on this store
        //

        hr = pICA->EnumPackages (pszPackageName,
            pCategory,
            pCopyLastUsn,
            dwQuerySpec,
            &(Enum[cEnum]));

        if (FAILED(hr))
        {
            break;
        }

        if (pCopyLastUsn)
        {
            if (LastUsn < *pCopyLastUsn)
                LastUsn = *pCopyLastUsn;
            *pCopyLastUsn = *pLastUsn;
        }
        if (SUCCEEDED(hr))
            cEnum++;
    }

    if (SUCCEEDED(hr))
    {

        EnumMerged = new CMergedEnumPackage;
        hr = EnumMerged->Initialize(Enum, cEnum);

        if (FAILED(hr))
        {
            for (i = 0; i < cEnum; i++)
                Enum[i]->Release();
            delete EnumMerged;
        }
        else
        {
            hr = EnumMerged->QueryInterface(IID_IEnumPackage, (void **)ppIEnumPackage);
            if (FAILED(hr))
                delete EnumMerged;
        }

        if (pLastUsn)
        {
            if (LastUsn > *pLastUsn)
                *pLastUsn = LastUsn;
        }
    }

    if (pUserSid)
        CsMemFree (pUserSid);

    //
    // Free the dynamically allocated vector of interfaces
    //
    delete [] Enum;

    if ( pICA )
    {
        pICA->Release();
    }

    return hr;
}

HRESULT __stdcall CClassAccess::SetClassStorePath(
    LPOLESTR         pszClassStorePath,
    void*            pRsopUserToken)
{
    DWORD cchPath;

    //
    // We only allow this to be set once -- if it's already
    // set we return an error.
    //
    if (m_pszClassStorePath)
    {
        return E_INVALIDARG;
    }

    if ( ! pszClassStorePath )
    {
        return S_OK;
    }

    cchPath = lstrlen(pszClassStorePath) + 1;

    m_pszClassStorePath = new WCHAR[cchPath];

    if (!m_pszClassStorePath)
    {
        return E_OUTOFMEMORY;
    }
    
    (void) StringCchCopy(m_pszClassStorePath, cchPath, pszClassStorePath);
    
    m_pRsopUserToken = (PRSOPTOKEN) pRsopUserToken;

    return S_OK;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\csmain.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    csmain.cxx
//
//  Contents:    All the exposed APIs.
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"

//  Globals

DWORD   gCsOptions = 0;

//
// Class Factory Objects
//

CClassContainerCF   *   g_pCF       = NULL;
CAppContainerCF     *   pCF         = NULL; 
CClassAccessCF      *   pCSAccessCF = NULL;

// Debugging Output Global values.
DWORD                    gDebugLog = 0;
DWORD                    gDebugOut = 0;
DWORD                    gDebugEventLog = 0;
DWORD                    gDebug = 0;

//
//   Number of objects alive in cstore.dll
//

long ObjectCount = 0;

//
// Critical Section for All Global Objects.
//
CRITICAL_SECTION ClassStoreBindList;


//-------------------------------------------------------------------
//  Function        Uninitialize
//
//  Synopsis:       Class Store Server Uninitialization.
//                  Disconnects from all Class Containers in use.
//                  Flushes out all State information using ResetClassStoreState.
//                  Unregisters Server registrations etc..
//
//  Arguments:      None
//
//  Returns:        None
//
//-------------------------------------------------------------------
void Uninitialize()
{
    //
    // Cleanup all open containers
    //

    //ResetClassStoreState();
    //
    // release the Class Factory objects
    //
    if (pCF)
        pCF->Release();
    if (pCSAccessCF)
        pCSAccessCF->Release();

    if (g_pCF)
        g_pCF->Release();
    //
    // get rid of the critical section
    //

    DeleteCriticalSection(&ClassStoreBindList);

}


//+---------------------------------------------------------------
//
//  Function:   InitDebugValues
//
//  Synopsis:   Initializes the Debug Values for the class store.
//
//  Arguments:
//   
//  Returns:
//      S_OK
//
// Log will go into the Debugger if the first bit is 1.
// If second bit is set, log will go into a log file.
// If third bit is set, log will go into event log.
//
// Note that the above is only true of DL_CSTORE is specified --
// if not, there is no debug output for the cstore component
//
// The gDebugLevel variable is initialized by the InitDebugSupport
// call in the common static library
//
//----------------------------------------------------------------
void InitDebugValues()
{
    gDebugEventLog = gDebugLevel & DL_EVENTLOG;
    gDebugLog = gDebugLevel & DL_LOGFILE;
    gDebugOut = gDebugLevel & DL_NORMAL;

    gDebug = (gDebugLevel & DL_CSTORE) && (gDebugOut || gDebugLog || gDebugEventLog);
}

//---------------------------------------------------------------------------
//
//  Function:   InitializeClassStore
//
//  History:    7-25-96   DebiM   Created
//
//  This entry point is called at DLL attach
//----------------------------------------------------------------------------
BOOL InitializeClassStore(BOOL fInit)
{
    HRESULT     hr;
    BOOL        bStatus;
    
    ObjectCount = 1;

    InitDebugValues();

    InitializeLanguageSupport();

    pCF = new CAppContainerCF();
    pCSAccessCF = new CClassAccessCF();
    InitializeCriticalSection(&ClassStoreBindList);

    g_pCF = new CClassContainerCF;

    if (!pCF || !pCSAccessCF || !g_pCF)
    {
        return FALSE;
    }

    return TRUE;
}



void
GetDefaultPlatform(CSPLATFORM *pPlatform,
                   BOOL        fArchitectureOverride,
                   LONG        OverridingArchitecture)
{
    OSVERSIONINFO VersionInformation;

    VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VersionInformation);

    pPlatform->dwPlatformId = VersionInformation.dwPlatformId;
    pPlatform->dwVersionHi = VersionInformation.dwMajorVersion;
    pPlatform->dwVersionLo = VersionInformation.dwMinorVersion;
 
    //
    // Allow the caller to specify an overriding architecture for
    // cases where the default logic (use the current platform) is
    // not sufficient (demand install of inproc servers)
    //
    if ( fArchitectureOverride )
    {
        pPlatform->dwProcessorArch = OverridingArchitecture;
    }
    else
    {
        pPlatform->dwProcessorArch = DEFAULT_ARCHITECTURE;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CsGetClassAccess
//
//  Synopsis:   Returns an instantiated interface to the Class Store
//              Co-ordinator object in Rpcss.
//
//  Arguments:  [ppIClassAccess] - where to put class access interface pointer
//
//  Returns:    S_OK - Got a Class Access Successfully
//              E_FAIL
//
//--------------------------------------------------------------------------

STDAPI CsGetClassAccess(
    IClassAccess     **     ppIClassAccess)
{
    HRESULT     hr;
    *ppIClassAccess = NULL;

    hr = pCSAccessCF->CreateInstance( NULL, 
        IID_IClassAccess, 
        (void **)ppIClassAccess);

    return hr;

}

//+-------------------------------------------------------------------
//
// CsEnumApps (DebiM 11/7/97)
//
// Returns an enumerator for packages in the Class Store (s).
// The enumerator works across all class stores in the calling users profile.
//
//
// This is used by:
//    - Add/Remove programs to select Corporate Apps
//    - winlogon to obtain the list of assigned apps
//
// Arguments:
//  [in]
//        pszPackageName    :   Optional Wildcard string for PackageName
//        pLastUsn          :   Optional Time Stamp for new packages
//        pCategory         :   Optional CategoryId
//        dwAppFlags        :   Per APPINFO_xxx in objbase.h
//  [out]
//        ppIEnumPackage    :   Returned Interface Pointer
//
// Returns :
//      S_OK or E_NO_CLASSSTORE
//
//--------------------------------------------------------------------
STDAPI
CsEnumApps(
        LPOLESTR        pszPackageName,    // Wildcard string for PackageName
        GUID            *pCategory,        // CategoryId
        ULONGLONG       *pLastUsn,         // Time Stamp for new packages
        DWORD           dwAppFlags,        // Per APPINFO_xxx in objbase.h
        IEnumPackage    **ppIEnumPackage   // Returned Interface Pointer
        )
{
    HRESULT         hr;
    IClassAccess  * pIClassAccess = NULL;

    *ppIEnumPackage = NULL;

    //
    // Get an IClassAccess 
    //
    hr = CsGetClassAccess(&pIClassAccess);
    if (!SUCCEEDED(hr))
        return hr;

    //
    // Get the enumerator
    //
    hr = pIClassAccess->EnumPackages (
        pszPackageName,
        pCategory,
        pLastUsn,
        dwAppFlags,
        ppIEnumPackage
        );

    pIClassAccess->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetAppInfo
//  
//  Synopsis:   Gets Package Information for a package that matches
//              the query.
//
//  Used By:
//              services. CoCreateInstance (OLE)
//
//  Arguments:
//  [in]
//      pClassSpec: 
//              The query consisting of the name or clsid or ... 
//      pQueryContext:
//              Execution context, architecture/Platform/locale req'd, 
//              Default value is the ThreadLocale and the default Platform.
//
//  [out]
//      pPackageInfo
//              Neccessary Package Information.
//           
//  Returns :
//      S_OK, CS_E_XXX errors.
// 
//  Looks up the given class specification in the DS.  If an application for
//  this class specification is found, then the application details are returned.
//  Gets the IClassAccess Pointer and calls GetAppInfo on it.
//
//  Caller needs to FREE the pPackageInfo using the Release APIs.
//--------------------------------------------------------------------

STDAPI
CsGetAppInfo(
         uCLSSPEC          *   pClassSpec,            // Class Spec (GUID/Ext/MIME)
         QUERYCONTEXT      *   pQueryContext,
         PACKAGEDISPINFO   *   pPackageInfo
         )
{
    HRESULT         hr = S_OK;
    IClassAccess  * pIClassAccess = NULL;
    
    // Gets the IClassAccess pointer
    hr = CsGetClassAccess(&pIClassAccess);
    if (!SUCCEEDED(hr))
        return hr;

    // Calls the GetAppInfo method 
    hr = pIClassAccess->GetAppInfo(pClassSpec, pQueryContext, pPackageInfo );
    pIClassAccess->Release();
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CsCreateClassStore
//  
//  Synopsis:   Creates the class store.
//
//  Used By:
//              mmc snapin.
//
//  Arguments:
//  [in]
//      szCSPath: 
//              Path where a new class store has to be created.
//           
//  Returns :
//      S_OK, CS_E_XXX errors.
// 
//  Gets the parent containers Name (GPO)
//  and the name of the class store. Creates a Class Store with this name
//  Below the parent object. 
//--------------------------------------------------------------------

STDAPI
CsCreateClassStore(LPOLESTR szServerName, LPOLESTR szCSPath) 
{
    LPOLESTR szPath = NULL;
    LPOLESTR szParentPath=NULL, szStoreName=NULL;
    HRESULT  hr = S_OK;
    LPOLESTR szPolicyName = NULL, szUserMachine = NULL;
    CServerContext ServerContext;

    szPath = szCSPath;

    // Getting the path for the parent (Policy object) from the name.
    hr = BuildADsParentPath(szPath, &szParentPath, &szStoreName);

    ERROR_ON_FAILURE(hr);

    // Get the Policy Object
    hr = BuildADsParentPath(szParentPath, &szPolicyName, &szUserMachine);
    if (!SUCCEEDED(hr))
    {
        szPolicyName = NULL;
    }

    if (szUserMachine)
        FreeADsMem(szUserMachine);

    hr = ServerContext.Initialize( szServerName );

    ERROR_ON_FAILURE(hr);

    // creating class store. returns CS_E_XXX errors when it returns.
    hr = CreateRepository(&ServerContext, szParentPath, szStoreName, szPolicyName);
    
Error_Cleanup:

    if (szPolicyName)
        FreeADsMem(szPolicyName);

    if (szParentPath)
        FreeADsMem(szParentPath);

    if (szStoreName)
        FreeADsMem(szStoreName);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetClassStore
//  
//  Synopsis:   Gets the IClassAdmin interface pointer for the input class store.
//
//  Used By:
//              mmc snapin.
//
// Arguments:
//  [in]
//      szPath: 
//              Unicode Path For the Class Store.
//         
//  [out]
//      ppIClassAdmin: 
//              IClassAdmin interface pointer.
//              
//
// Returns :
//      S_OK, or CS_E_XXX error codes.
//--------------------------------------------------------------------
STDAPI
CsGetClassStore(LPOLESTR szPath, void **ppIClassAdmin)
{
    return CsServerGetClassStore(
        NULL,
        szPath,
        ppIClassAdmin );
}

STDAPI
CsServerGetClassStore(LPOLESTR szServerName, LPOLESTR szPath, void **ppIClassAdmin)
{
    CServerContext ServerContext;
    
    HRESULT hr = ServerContext.Initialize( szServerName );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return g_pCF->CreateConnectedInstance(
                  &ServerContext,
                  szPath, 
                  ppIClassAdmin);
}


//+---------------------------------------------------------------
//
//  Function:   CsDeleteClassStore
//
//  Synopsis:   Public entrypoint for deleting a class store container from DS.
//              Not implemented.
//
//----------------------------------------------------------------

STDAPI
CsDeleteClassStore(LPOLESTR szPath)
{
    return E_NOTIMPL;

}

//+-------------------------------------------------------------------
//
//  Function:   CsRegisterAppCategory
//  
//  Synopsis:   Registers a cetegory under the Domain.
//
//  Used By:
//              This is used by Add/Remove programs.
//
//  Arguments:
//  [in]
//      pAppCategory:   
//              Category and its details that have to be added.
//
//  Returns :
//      S_OK or CS_E_XXX error codes.
//--------------------------------------------------------------------
STDAPI
CsRegisterAppCategory(APPCATEGORYINFO *pAppCategory)
{
    HRESULT         hr = S_OK;
    IClassAdmin   * pIClassAdmin = NULL;

    // get the interface pointer
    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    // get the app categories list.
    hr = pIClassAdmin->RegisterAppCategory(pAppCategory);

    // release the interface pointer.
    pIClassAdmin->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsUnregisterAppCategory 
//  
//  Synopsis:   Unregister an AppCategory from the Domain.
//
//  Used By:
//              This is used by Add/Remove programs.
//
//  Arguments:
//  [in]
//      pAppCategoryId:   
//              Guid (category) that has to be unregistered.
//
//  Returns :
//      S_OK or CS_E_XXX error codes.
//--------------------------------------------------------------------
STDAPI
CsUnregisterAppCategory (GUID *pAppCategoryId)
{
    HRESULT         hr = S_OK;
    IClassAdmin   * pIClassAdmin = NULL;

    // get the interface pointer
    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    // get the app categories list.
    hr = pIClassAdmin->UnregisterAppCategory(pAppCategoryId);

    // release the interface pointer.
    pIClassAdmin->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetAppCategories 
//  
//  Synopsis:   get the definitive list of Application Categories and descriptions
//              based on default Locale.
//
//  Used By:
//              This is used by Add/Remove programs.
//
//  *Comments*:
//              The caller needs to free the memory allocated using CsMemFree().
//
//  Arguments:
//  [out]
//      AppCategoryList:   
//              Returned list of GUIDs and Unicode descriptions
//
//  Returns :
//      S_OK or CS_E_XXX error codes.
// 
//  Gets the list of Categories published in the Domain.
//  The CALLER needs to FREE the memory using Release API.
//--------------------------------------------------------------------
STDAPI
CsGetAppCategories (APPCATEGORYINFOLIST  *pAppCategoryList)
{
    HRESULT         hr = S_OK;
    IClassAdmin   * pIClassAdmin = NULL;

    // get the interface pointer
    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    // get the app categories list.
    hr = pIClassAdmin->GetAppCategories (
                                         GetUserDefaultLCID(), 
                                         pAppCategoryList);

    // release the interface pointer.
    pIClassAdmin->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetClassStorePath
//  
//  Synopsis:   Returns the class store path.
//
//  Used By:
//              Winlogon/mmc snapin.
//  Arguments:
//  [in]
//      DSProfilePath: 
//              Path For the DS Object given to winlogon.
//              This is validated here.
//         
//  [out]
//      pCSPath: 
//              Unicode Path to the class store.
//           
// Returns :
//      S_OK, or CS_E_XXX error codes.
// 
//  Looks at the profile object and gets the DEFAULTCLASSSTOREPATH Property.
//  The CALLER needs to FREE the memory allocated using CsMemFree().
//--------------------------------------------------------------------

STDAPI
CsGetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR *pCSPath)
{
    HRESULT        hr;
    ULONG          ulNoBytes;

    //
    // Initialize locals
    //
    hr = S_OK;

    //
    // Initialize out parameters
    //
    *pCSPath = NULL;

    //
    // Validate the ds path string -- make sure it's NULL terminated
    //
    if ((!DSProfilePath))
        ERROR_ON_FAILURE(hr = E_INVALIDARG);

    //
    // Make sure the ldap prefix is there
    //
    if (wcsncmp (DSProfilePath, LDAPPREFIX, LDAPPREFIXLENGTH) != 0)
        ERROR_ON_FAILURE(hr = E_INVALIDARG);

    //
    // Now build the class store path.  It would be nice if we could use
    // BuildADsPathFromParent to do this, but it does not allocate memory
    // with CoTaskMemalloc, and the interface to this function requires that
    // the returned cs path is freed by the caller with CoTaskMemfree -- thus
    // we have to do all the memory allocation and copying ourselfves.
    
    //
    // First, get memory -- length is just the length of the current ds path
    // in addition to the length for a path separator and the name of the class
    // store container
    //

    ulNoBytes = wcslen(DSProfilePath) * sizeof (WCHAR) + 
        sizeof (WCHAR) + 
        sizeof (CLASSSTORECONTAINERNAME);

    *pCSPath = (LPOLESTR) CsMemAlloc(ulNoBytes);

    if (!(*pCSPath))
        ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);

    //
    // Get the ds path past the prefix so we can use it
    // in creating the new path
    //
    LPOLESTR DSPathWithoutPrefix;
    
    DSPathWithoutPrefix = DSProfilePath + LDAPPREFIXLENGTH;

    //
    // currently, prefixing LDAP: at the beginning.
    //
    hr = StringCbPrintf(*pCSPath,
                        ulNoBytes,
                        L"%s%s", 
                        LDAPPREFIX CLASSSTORECONTAINERNAME LDAPPATHSEP,
                        DSPathWithoutPrefix);
    if (FAILED(hr)) 
    {
        LocalFree(*pCSPath);
        *pCSPath = NULL;
    }


Error_Cleanup:

    return RemapErrorCode(hr, DSProfilePath);
}

//----------------The release APIs-------------------------
STDAPI
ReleasePackageInfo(PACKAGEDISPINFO *pPackageInfo)
{
    DWORD i;

    if (pPackageInfo) 
    {
        CsMemFree(pPackageInfo->pszScriptPath);
        CsMemFree(pPackageInfo->pszPackageName);
        for (i = 0; i < (pPackageInfo->cUpgrades); i++) 
            CsMemFree(pPackageInfo->prgUpgradeInfoList[i].szClassStore);
        CsMemFree(pPackageInfo->prgUpgradeInfoList);
        CsMemFree(pPackageInfo->pszPublisher);
        CsMemFree(pPackageInfo->rgSecurityDescriptor);
        CsMemFree(pPackageInfo->pszGpoPath);
        CsMemFree(pPackageInfo->pszUrl);

        DWORD iCategory;

        for ( iCategory = 0; iCategory < pPackageInfo->cCategories; iCategory++ )
        {
            CsMemFree( pPackageInfo->prgCategories[iCategory] );
        }

        CsMemFree(pPackageInfo->prgCategories);

        DWORD iTransform;

        for ( iTransform = 0; iTransform < pPackageInfo->cTransforms; iTransform++ )
        {
            CsMemFree( pPackageInfo->prgTransforms[iTransform] );
        }

        CsMemFree( pPackageInfo->prgTransforms );

        //
        // Destroy all the references in this structure so that
        // if this function is called twice in a row on the same
        // structure, we do not access invalid memory the second time.
        //
        memset( pPackageInfo, 0, sizeof( *pPackageInfo ) );
    }

    return S_OK;
}

STDAPI
ReleaseAppCategoryInfoList(APPCATEGORYINFOLIST *pAppCategoryInfoList)
{
    DWORD i;
    if (pAppCategoryInfoList) 
    {
        for (i = 0; i < (pAppCategoryInfoList->cCategory); i++) 
            CsMemFree((pAppCategoryInfoList->pCategoryInfo)[i].pszDescription);
        CsMemFree(pAppCategoryInfoList->pCategoryInfo);

        memset( pAppCategoryInfoList, 0, sizeof( *pAppCategoryInfoList ) );
    }
    return S_OK;
}

STDAPI
ReleaseInstallInfo(INSTALLINFO *pInstallInfo)
{
    DWORD i;
    if (pInstallInfo)
    {
        CsMemFree(pInstallInfo->pszSetupCommand);
        CsMemFree(pInstallInfo->pszScriptPath);
        CsMemFree(pInstallInfo->pszUrl);
        CsMemFree(pInstallInfo->pClsid);
        for (i = 0; i < (pInstallInfo->cUpgrades); i++) 
            CsMemFree(pInstallInfo->prgUpgradeInfoList[i].szClassStore);
        CsMemFree(pInstallInfo->prgUpgradeInfoList);
    }
    return S_OK;
}

void
ReleaseClassDetail(CLASSDETAIL ClassDetail)
{
    DWORD i;
    for (i = 0; i < ClassDetail.cProgId; i++)
        CsMemFree(ClassDetail.prgProgId[i]);
    CsMemFree(ClassDetail.prgProgId);
}

STDAPI
ReleasePackageDetail(PACKAGEDETAIL *pPackageDetail)
{
   DWORD i;
   if (pPackageDetail) 
   {
       if (pPackageDetail->pActInfo)
       {   
           for (i = 0; i < pPackageDetail->pActInfo->cClasses; i++)
               ReleaseClassDetail((pPackageDetail->pActInfo->pClasses)[i]);
           CsMemFree(pPackageDetail->pActInfo->pClasses);
           
           for (i = 0; i < pPackageDetail->pActInfo->cShellFileExt; i++)
               CsMemFree((pPackageDetail->pActInfo->prgShellFileExt)[i]);
           CsMemFree(pPackageDetail->pActInfo->prgShellFileExt);

           CsMemFree(pPackageDetail->pActInfo->prgPriority);
           CsMemFree(pPackageDetail->pActInfo->prgInterfaceId);
           CsMemFree(pPackageDetail->pActInfo->prgTlbId);
           CsMemFree(pPackageDetail->pActInfo);
       }
       
       if (pPackageDetail->pPlatformInfo)
       {
           CsMemFree(pPackageDetail->pPlatformInfo->prgPlatform);
           CsMemFree(pPackageDetail->pPlatformInfo->prgLocale);
           CsMemFree(pPackageDetail->pPlatformInfo);
       }
       
       if (pPackageDetail->pInstallInfo)
       {
           ReleaseInstallInfo(pPackageDetail->pInstallInfo);
           CsMemFree(pPackageDetail->pInstallInfo);
       }
       
       for (i = 0; i < (pPackageDetail->cSources); i++)
           CsMemFree(pPackageDetail->pszSourceList[i]);
       CsMemFree(pPackageDetail->pszSourceList);

       CsMemFree(pPackageDetail->pszPackageName);
       CsMemFree(pPackageDetail->rpCategory);
   }
   return S_OK;
}

void CsSetOptions( DWORD dwOptions )
{
    gCsOptions = dwOptions;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\dsiface.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       dsiface.cxx
//
//  Contents:   ADs calls for Class Store Property Read/Write
//
//
//  History:    Sep-Oct 96.   DebiM
//
//----------------------------------------------------------------------------


#include "cstore.hxx"

#pragma warning ( disable : 4018 )
#pragma warning ( disable : 4244 )

//
// From CSPLATFORM to DS datatype
//
void
UnpackPlatform (DWORD *pdwArch,
                CSPLATFORM *pPlatform)
{
    unsigned char *pc = (unsigned char *)pdwArch;
    
    *(pc) = (unsigned char)pPlatform->dwPlatformId;
    *(++pc) = (unsigned char)pPlatform->dwVersionHi;
    *(++pc) = (unsigned char)pPlatform->dwVersionLo;
    *(++pc) = (unsigned char)pPlatform->dwProcessorArch;
}

//
// From DS datatype to CSPLATFORM
//
void
PackPlatform (DWORD dwArch,
              CSPLATFORM *pPlatform)
{
    unsigned char *pc = (unsigned char *)&dwArch;
    
    pPlatform->dwPlatformId = *(pc);
    pPlatform->dwVersionHi = *(++pc);
    pPlatform->dwVersionLo = *(++pc);
    pPlatform->dwProcessorArch = *(++pc);
}


//+-------------------------------------------------------------------------
//
//  Function:   StringFromGUID
//
//--------------------------------------------------------------------------
int  StringFromGUID(REFGUID rguid, LPOLESTR lptsz)
{
    (void) StringCchPrintf(lptsz, 
                    40,
                    L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                    rguid.Data1, rguid.Data2, rguid.Data3,
                    rguid.Data4[0], rguid.Data4[1],
                    rguid.Data4[2], rguid.Data4[3],
                    rguid.Data4[4], rguid.Data4[5],
                    rguid.Data4[6], rguid.Data4[7]);
    return 36;
}

//+-------------------------------------------------------------------------
//
//  Function:   RdnFromGUID
//
//--------------------------------------------------------------------------
int  RDNFromGUID(REFGUID rguid, LPOLESTR lptsz)
{
    (void) StringCchCopy (lptsz, 4, L"CN=");
    StringFromGUID(rguid, lptsz+3);
    return 3+36;
}

//
// This converts string guids to the guid structure -- note that
// the string guid does NOT contain brace chars ('{','}') at
// the beginning and end
//
void GUIDFromString(
                    LPOLESTR psz,
                    GUID *pclsguid)
                    //
                    // Converts a Stringified GUID to GUID structure
                    //
{
    WCHAR szC [40];
    LPOLESTR szClsId;
    LPOLESTR endptr;
    
    memset ((void *)pclsguid, NULL, sizeof (GUID));
    if ((!psz) ||
        (*psz == NULL))
        return;

    if (wcslen(psz) < 36)
        return;

    wcsncpy (&szC [0], psz, 36);
    szC[36] = L'\0';

    szClsId = &szC[0];
  
    *(szClsId+36) = NULL;
    pclsguid->Data4[7] = wcstoul (szClsId+34, &endptr, 16);

    *(szClsId+34) = NULL;
    pclsguid->Data4[6] = wcstoul (szClsId+32, &endptr, 16);

    *(szClsId+32) = NULL;
    pclsguid->Data4[5] = wcstoul (szClsId+30, &endptr, 16);

    *(szClsId+30) = NULL;
    pclsguid->Data4[4] = wcstoul (szClsId+28, &endptr, 16);

    *(szClsId+28) = NULL;
    pclsguid->Data4[3] = wcstoul (szClsId+26, &endptr, 16);

    *(szClsId+26) = NULL;
    pclsguid->Data4[2] = wcstoul (szClsId+24, &endptr, 16);
    
    *(szClsId+23) = NULL;
    pclsguid->Data4[1] = wcstoul (szClsId+21, &endptr, 16);

    *(szClsId+21) = NULL;
    pclsguid->Data4[0] = wcstoul (szClsId+19, &endptr, 16);
    
    *(szClsId+18) = NULL;
    pclsguid->Data3 = wcstoul (szClsId+14, &endptr, 16);

    *(szClsId+13) = NULL;
    pclsguid->Data2 = wcstoul (szClsId+9, &endptr, 16);

    *(szClsId+8) = NULL;
    pclsguid->Data1 = wcstoul (szClsId, &endptr, 16);
}

BOOL  IsNullGuid(REFGUID rguid)
{
    UINT i;
    
    if (rguid.Data1)
        return FALSE;
    if (rguid.Data2)
        return FALSE;
    if (rguid.Data3)
        return FALSE;
    for (i=0; i < 8; ++i)
    {
        if (rguid.Data4[i])
            return FALSE;
    }
    return TRUE;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\filter.cxx ===
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Author: adamed
//  Date:   4/30/1999
//
//      Class Store filter generator
//
//
//---------------------------------------------------------------------
//
#include "cstore.hxx"
//
// List of Attributes for Enumeration of Packages (with Filters)
//

LPOLESTR gpszEnumerationAttributes_All[] =
{
    PACKAGEFLAGS,
    PACKAGETYPE,
    SCRIPTPATH,
    PKGUSN,
    LOCALEID,
    ARCHLIST,
    PACKAGENAME,
    VERSIONHI,
    VERSIONLO,
    UPGRADESPACKAGES,
    UILEVEL,
    PUBLISHER,
    HELPURL,
    REVISION,
    PRODUCTCODE,
    OBJECTGUID,
    OBJECTDN,
    PKGCATEGORYLIST,
    MSIFILELIST,
    SECURITYDESCRIPTOR
};

LPOLESTR gpszEnumerationAttributes_Policy[] =
{
    PACKAGEFLAGS,
    PACKAGETYPE,
    SCRIPTPATH,
    PKGUSN,
    LOCALEID,
    ARCHLIST,
    PACKAGENAME,
    UPGRADESPACKAGES,
    UILEVEL,
    HELPURL,
    REVISION,
    PRODUCTCODE,
    OBJECTGUID,
    OBJECTDN
};

LPOLESTR gpszEnumerationAttributes_Administrative[] =
{
    PACKAGEFLAGS,
    PACKAGETYPE,
    SCRIPTPATH,
    PKGUSN,
    LOCALEID,
    ARCHLIST,
    PACKAGENAME,
    VERSIONHI,
    VERSIONLO,
    UPGRADESPACKAGES,
    UILEVEL,
    PUBLISHER,
    HELPURL,
    REVISION,
    PRODUCTCODE,
    PKGCLSIDLIST,
    OBJECTGUID,
    OBJECTDN
};

LPOLESTR gpszEnumerationAttributes_UserDisplay[] =
{
    PACKAGEFLAGS,
    PACKAGETYPE,
    LOCALEID,
    ARCHLIST,
    PACKAGENAME,
    UPGRADESPACKAGES,
    UILEVEL,
    HELPURL,
    REVISION,
    PRODUCTCODE,
    OBJECTGUID,
    OBJECTDN,
    PKGCATEGORYLIST
};



DWORD ClientSideFilterFromQuerySpec(
    DWORD dwQuerySpec,
    BOOL  bPlanning)
{
    DWORD dwFlags;

    dwFlags = 0;

    switch (dwQuerySpec)
    {
    case APPQUERY_ALL:
        dwFlags = CLIENTSIDE_FILTER_FLAGS_ALL;
        break;

    case APPQUERY_ADMINISTRATIVE:
        dwFlags = CLIENTSIDE_FILTER_FLAGS_ADMINISTRATIVE;
        break;

    case APPQUERY_POLICY:
        dwFlags = CLIENTSIDE_FILTER_FLAGS_POLICY;
        break;

    case APPQUERY_USERDISPLAY:
        dwFlags = CLIENTSIDE_FILTER_FLAGS_USER_DISPLAY;
        break;

    case APPQUERY_RSOP_LOGGING:
        if ( bPlanning )
        {
            dwFlags = CLIENTSIDE_FILTER_FLAGS_RSOP_PLANNING;
        }
        else
        {
            dwFlags = CLIENTSIDE_FILTER_FLAGS_RSOP_LOGGING;
        }
        break;

    case APPQUERY_RSOP_ARP:
        if ( bPlanning )
        {
            dwFlags = CLIENTSIDE_FILTER_FLAGS_RSOP_ARP_PLANNING;
        }
        else
        {
            dwFlags = CLIENTSIDE_FILTER_FLAGS_RSOP_ARP;
        }
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return dwFlags;
}

void  ServerSideFilterFromQuerySpec(DWORD  dwQuerySpec,
                                    BOOL   bPlanning,
                                    WCHAR* wszFilterIn,
                                    WCHAR* wszFilterOut,
                                    ULONG  ulSize)
{
    WCHAR* wszQueryFilter;

    switch (dwQuerySpec)
    {
    case APPQUERY_ALL:
        (void) StringCchCopy(wszFilterOut, ulSize, wszFilterIn);
        return;

    case APPQUERY_ADMINISTRATIVE:
        wszQueryFilter = SERVERSIDE_FILTER_ADMINISTRATIVE;
        break;

    case APPQUERY_POLICY:
        wszQueryFilter = SERVERSIDE_FILTER_POLICY;
        break;

    case APPQUERY_USERDISPLAY:
    case APPQUERY_RSOP_ARP:
        wszQueryFilter = SERVERSIDE_FILTER_USER_DISPLAY;
        break;

    case APPQUERY_RSOP_LOGGING:
        wszQueryFilter = SERVERSIDE_FILTER_RSOP_LOGGING;
        wszQueryFilter = bPlanning ? SERVERSIDE_FILTER_POLICY_PLANNING : SERVERSIDE_FILTER_RSOP_LOGGING;
        break;

    default: 
        ASSERT(FALSE);
        return;
    }

    //
    // Join the two expressions with &
    //

    (void) StringCchPrintf(wszFilterOut,
                    ulSize,
                    L"(&%s%s)",
                    wszFilterIn,
                    wszQueryFilter);

}


LPOLESTR* GetAttributesFromQuerySpec(
    DWORD      dwQuerySpec,
    DWORD*     pdwAttrs,
    PRSOPTOKEN pRsopToken )
{
    switch (dwQuerySpec)
    {
    case APPQUERY_ALL:

        *pdwAttrs = sizeof(gpszEnumerationAttributes_All) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_All;

    case APPQUERY_ADMINISTRATIVE:

        *pdwAttrs = sizeof(gpszEnumerationAttributes_Administrative) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_Administrative;

    case APPQUERY_POLICY:

        *pdwAttrs = sizeof(gpszEnumerationAttributes_Policy) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_Policy;

    case APPQUERY_USERDISPLAY:
        
        *pdwAttrs = sizeof(gpszEnumerationAttributes_UserDisplay) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_UserDisplay;

    case APPQUERY_RSOP_LOGGING:
    case APPQUERY_RSOP_ARP:

        *pdwAttrs = sizeof(gpszEnumerationAttributes_All) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_All;

    default:
        ASSERT(FALSE);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\dsprop.cxx ===
#include "cstore.hxx"



const WCHAR cwszCRLF[] = L"\r\n";


BOOL GetGpoIdFromClassStorePath(
    WCHAR* wszClassStorePath,
    GUID*  pGpoId)
{
    WCHAR* wszGuidStart;
    WCHAR  wszGpoId[MAX_GUIDSTR_LEN + 1];

    wszGuidStart = wcschr(wszClassStorePath, L'{');

    if (!wszGuidStart) 
    {
        return FALSE;
    }

    wcsncpy(wszGpoId, wszGuidStart, MAX_GUIDSTR_LEN);

    wszGpoId[MAX_GUIDSTR_LEN] = L'\0';

    StringToGuid(wszGpoId, pGpoId);

    return TRUE;
}


HRESULT GetUserSid(PSID *ppUserSid, UINT *pCallType);

// set property routines do not do any allocations.
// get properties have 2 different sets of routines
//             1. in which there is no allocation taking place
//                and the buffers are freed when the ds data structures
//                are freed.
//             2. Allocation takes place and these should be used for
//                data that needs to be returned back to the clients.


void FreeAttr(ADS_ATTR_INFO attr)
{
    CsMemFree(attr.pADsValues);
}

// Note: None of these APIs copies anything into their own buffers.
// It allocates a buffer for adsvalues though.

// packing a property's value into a attribute structure
// for sending in with a create/modify.

void PackStrArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty,
                      WCHAR **pszAttr, DWORD num)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;
    
    attr->dwADsType = ADSTYPE_DN_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    
    if (!(attr->pADsValues))
        return;             

    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_DN_STRING;
        attr->pADsValues[i].DNString = pszAttr[i];
    }
}

void PackDWArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, DWORD *pAttr, DWORD num)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;
    

    attr->dwADsType = ADSTYPE_INTEGER;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;            
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_INTEGER;
        attr->pADsValues[i].Integer = pAttr[i];
    }
}

void PackGUIDArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, GUID *pAttr, DWORD num)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;
    
    attr->dwADsType = ADSTYPE_OCTET_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;           
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_OCTET_STRING;
        attr->pADsValues[i].OctetString.dwLength = sizeof(GUID);
        attr->pADsValues[i].OctetString.lpValue = (unsigned char *)(pAttr+i);
    }
}

void PackBinToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, BYTE *pAttr, DWORD sz)
{
    attr->pszAttrName = szProperty;
    attr->dwNumValues = 1;
    
    attr->dwControlCode = ADS_ATTR_UPDATE;
    
    attr->dwADsType = ADSTYPE_OCTET_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE));
    if (!(attr->pADsValues))
        return;           
    
    attr->pADsValues[0].dwType = ADSTYPE_OCTET_STRING;
    attr->pADsValues[0].OctetString.dwLength = sz;
    attr->pADsValues[0].OctetString.lpValue = pAttr;
}

void PackStrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, WCHAR *szAttr)
{
    if (szAttr)
        PackStrArrToAttr(attr, szProperty, &szAttr, 1);
    else
        PackStrArrToAttr(attr, szProperty, &szAttr, 0);
}

void PackDWToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, DWORD Attr)
{
    PackDWArrToAttr(attr, szProperty, &Attr, 1);
}

// passing in a pointer to GUID which is passed down into the LDAP structure.

void PackGUIDToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, GUID *pAttr)
{
    PackGUIDArrToAttr(attr, szProperty, pAttr, 1);
}

// returns the attribute corresp. to a given property.
DWORD GetPropertyFromAttr(ADS_ATTR_INFO *pattr, DWORD cNum, WCHAR *szProperty)
{
    DWORD   i;
    for (i = 0; i < cNum; i++)
        if (_wcsicmp(pattr[i].pszAttrName, szProperty) == 0)
            break;
        return i;
}



HRESULT GetCategoryLocaleDesc(LPOLESTR *pdesc, ULONG cdesc, LCID *plcid,
                              LPOLESTR szDescription, ULONG ulSize)
{
    LCID     plgid;
    LPOLESTR ptr;

    szDescription[0] = L'\0';
    if (!cdesc)
        return E_FAIL; // CAT_E_NODESCRIPTION;
    
    // Try locale passed in
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get default sublang local
    plgid = PRIMARYLANGID((WORD)*plcid);
    *plcid = MAKELCID(MAKELANGID(plgid, SUBLANG_DEFAULT), SORT_DEFAULT);
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get matching lang id
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 1))
        return S_OK;
    
    // Get User Default
    *plcid = GetUserDefaultLCID();
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get System Default
    *plcid = GetUserDefaultLCID();
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get the first one
    *plcid = wcstoul(pdesc[0], &ptr, 16);
    if (szDescription)
    {
        if ((ptr) && (wcslen(ptr) >= (CAT_DESC_DELIM_LEN+2)))
        {
            HRESULT hr;

            hr = StringCchCopy(szDescription, ulSize, (ptr+CAT_DESC_DELIM_LEN+2));
            if (FAILED(hr)) 
            {
                return hr;
            }
        }
        else
            szDescription = L'\0';
    }
    return S_OK;
}

//-------------------------------------------
// Returns the description corresp. to a LCID
//  desc:         list of descs+lcid
//  cdesc:        number of elements.
//      plcid:        the lcid in/out
//  szDescription:description returned.
//  GetPrimary:   Match only the primary.
//---------------------------------------

ULONG FindDescription(LPOLESTR *desc, ULONG cdesc, LCID *plcid, LPOLESTR szDescription, BOOL GetPrimary)
{
    ULONG i;
    LCID  newlcid;
    LPOLESTR ptr;
    for (i = 0; i < cdesc; i++)
    {
        newlcid = wcstoul(desc[i], &ptr, 16); // to be changed
        // error to be checked.
        if ((newlcid == *plcid) || ((GetPrimary) &&
            (PRIMARYLANGID((WORD)*plcid) == PRIMARYLANGID(LANGIDFROMLCID(newlcid)))))
        {
            if (szDescription)
            {
                if ((ptr) && (wcslen(ptr) >= (CAT_DESC_DELIM_LEN+2)))
                {
                    //
                    // Copy the description, enforcing the maximum size
                    // so we don't overflow the buffer
                    //
                    wcsncpy(szDescription,
                            (ptr+CAT_DESC_DELIM_LEN+2),
                            CAT_DESC_MAX_LEN + 1
                            );

                    //
                    // We must null terminate in case the category
                    // was longer than the maximum.  We know the buffer
                    // is equal in size to the maximum, so we can
                    // just add the terminator there.  In all other cases,
                    // wcsncpy will have written the null terminator
                    //
                    szDescription[CAT_DESC_MAX_LEN] = L'\0';
                }
                else
                    szDescription = L'\0';
            }
            if (GetPrimary)
                *plcid = newlcid;
            return i+1;
        }
    }
    return 0;
}

DWORD NumDigits10(DWORD Value)
{
    if (0 == Value) {
        return 1;
    }

    DWORD ret = 0;

    for (ret = 0; Value != 0; ret++) 
        Value = Value/10;

    return ret;
}


void ReportEventCS(HRESULT ErrorCode, HRESULT ExtendedErrorCode, LPOLESTR szContainerName)
{

    WCHAR       szErrCode[16];
    HRESULT     hr;

    hr = StringCchPrintf(szErrCode, 16, L"0x%x", ExtendedErrorCode);
    ASSERT(SUCCEEDED(hr));

    CEventsBase* pEvents = (CEventsBase*) gpEvents;

    ASSERT(CS_E_NETWORK_ERROR == ErrorCode);

    pEvents->Report(
        EVENT_CS_NETWORK_ERROR,
        FALSE,
        2,
        szContainerName,
        szErrCode);
}

// remapping Error Codes returned by LDAP to reasonable class store errors.
//
HRESULT RemapErrorCode(HRESULT ErrorCode, LPOLESTR m_szContainerName)
{
    HRESULT RetCode;
    BOOL    fNetError;

    fNetError = FALSE;

    if (SUCCEEDED(ErrorCode))
        return S_OK;

    switch (ErrorCode) 
    {
        //            
        //  All kinds of failures due to ObjectNotFound
        //  due to non-existence of object OR 
        //         non-existent container OR
        //         invalid path specification
        //  Other than Access Denials
        //
        case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
        case HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED):    // understand what causes this
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_FOUND):   //  -do-
            
            RetCode = CS_E_OBJECT_NOTFOUND;                       // which object - specific error
            break;

        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS):
        case E_ADS_OBJECT_EXISTS:
            RetCode = CS_E_OBJECT_ALREADY_EXISTS;
            break;

        //            
        //  The following errors should not be expected normally.
        //  Class Store schema mismatched should be handled correctly.
        //  Errors below may ONLY occur for corrupted data OR out-of-band changes
        //  to a Class Store content.

        case E_ADS_CANT_CONVERT_DATATYPE:
        case E_ADS_SCHEMA_VIOLATION:
        case HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE):
        case HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION):
            RetCode = CS_E_SCHEMA_MISMATCH;
            break;

        //            
        //  Any kinds of Access or Auth Denial
        //      return ACCESS_DENIED
        //

        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED):
        case HRESULT_FROM_WIN32(ERROR_DS_STRONG_AUTH_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_DS_CONFIDENTIALITY_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN):

            RetCode = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            break;

        case E_ADS_BAD_PATHNAME:
        case HRESULT_FROM_WIN32(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX):  // this is wrong
            RetCode = CS_E_INVALID_PATH;
            break;
        
        //            
        //  Out of Memory
        //

        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY):
            
            RetCode = E_OUTOFMEMORY;
            break;

        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_RESOLVING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_UNIQUE):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NO_MAPPING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_DOMAIN_ONLY):
        case HRESULT_FROM_WIN32(ERROR_DS_TIMELIMIT_EXCEEDED):
        case HRESULT_FROM_WIN32(ERROR_DS_BUSY):
        case HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE):
        case HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM):
        case HRESULT_FROM_WIN32(ERROR_TIMEOUT):
        case HRESULT_FROM_WIN32(ERROR_CONNECTION_REFUSED):
        case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
        case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
            RetCode = ErrorCode;
            fNetError = TRUE;
            break;

        case HRESULT_FROM_WIN32(ERROR_DS_ADMIN_LIMIT_EXCEEDED):
             RetCode = CS_E_ADMIN_LIMIT_EXCEEDED;
             break;

        default:
            RetCode = ErrorCode;
    }
    
    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_REMAP_ERR,
              ErrorCode,
              RetCode));

    if (RetCode == CS_E_NETWORK_ERROR)
    {
        ReportEventCS(RetCode, ErrorCode, m_szContainerName);
    }

    return RetCode;
}

// These functions are used to delete a single value from a
// multivalued property or append to a multivalued property

void PackStrArrToAttrEx(ADS_ATTR_INFO *attr, WCHAR *szProperty, WCHAR **pszAttr, DWORD num,
                        BOOL APPEND)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (APPEND)
        attr->dwControlCode = ADS_ATTR_APPEND;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_DN_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;            
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_DN_STRING;
        attr->pADsValues[i].DNString = pszAttr[i];
    }
}

void PackDWArrToAttrEx(ADS_ATTR_INFO *attr, WCHAR *szProperty, DWORD *pAttr, DWORD num,
                       BOOL APPEND)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (APPEND)
        attr->dwControlCode = ADS_ATTR_APPEND;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_INTEGER;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;             
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_INTEGER;
        attr->pADsValues[i].Integer = pAttr[i];
    }
}

void PackGUIDArrToAttrEx(ADS_ATTR_INFO *attr, WCHAR *szProperty, GUID *pAttr, DWORD num,
                         BOOL APPEND)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (APPEND)
        attr->dwControlCode = ADS_ATTR_APPEND;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_OCTET_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;          
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_OCTET_STRING;
        attr->pADsValues[i].OctetString.dwLength = sizeof(GUID);
        attr->pADsValues[i].OctetString.lpValue = (unsigned char *)(pAttr+i);
    }
}

WCHAR* AllocGpoPathFromClassStorePath( WCHAR* pszClassStorePath )
{
    //
    // The class store path looks like CN=ClassStore,CN=[Machine | User],<gpopath>
    // So we will simply look for two "," starting at the beginning of the path.
    // In doing this, we will take care not to access violate due to an incorrect path,
    // Since there is the possiblity that an administrator could find the persisted
    // class store path and mangle it, giving us an incorrect path that would
    // not parse according to the structure above.
    //
    WCHAR* wszGpoPath;

    //
    // Check for the first ','
    //
    wszGpoPath = wcschr(pszClassStorePath, L',');

    //
    // If we get NULL here, that means there is no ',' and the path is corrupt
    //
    if ( ! wszGpoPath )
    {
        return NULL;
    }

    //
    // Now check for the second ','
    //
    wszGpoPath = wcschr(wszGpoPath + 1, L',');

    //
    // Again, if we don't find the second ',', 
    // The path is corrupt
    //
    if ( ! wszGpoPath )
    {
        return NULL;
    }

    //
    // Now move one past
    //
    wszGpoPath++;

    //
    // The caller desires their own copy, so we will allocate space for it
    //
    WCHAR* wszGpoPathResult;
    ULONG ulNoBytes;

    ulNoBytes = (wcslen( wszGpoPath ) + 1) * sizeof( *wszGpoPathResult );
    wszGpoPathResult = (WCHAR*) CsMemAlloc(ulNoBytes);

    if ( ! wszGpoPathResult )
    {
        return NULL;
    }

    //
    // Now copy the gpo path
    //

    HRESULT hr;

    hr = StringCbCopy( wszGpoPathResult, ulNoBytes, wszGpoPath );
    if (FAILED(hr)) 
    {
        CsMemFree(wszGpoPathResult);
        wszGpoPathResult = NULL;
    }

    return wszGpoPathResult;
}

HRESULT
GetEscapedNameFilter( WCHAR* wszName, WCHAR** ppwszEscapedName )
{
    DWORD   cbLen;
    WCHAR*  wszCurrent;
    HRESULT hr;
    ULONG   ulCurSizeLeft;

    //
    // This function escapes package names so that they can be used in
    // an ldap search filter.  Names containing certain characters must
    // be escaped since those characters are contained in the vocabulary
    // for the search filter grammar.
    //

    //
    // The set of characters that must be escaped and the appropriate
    // escape sequences are described in RFC 2254
    //

    //
    // Determine the maximum size needed for the filter.  We include for 3
    // times the length of the name since that is the upper bound on the
    // length of the escaped name
    //

    //
    // "(PackageAttr=\0" + "<*ppwszEscapedName>" + ")"
    //
    cbLen = sizeof( L"(" PACKAGENAME L"=" ) + ( lstrlen( wszName ) + 1 ) * sizeof( *wszName ) * 3;

    *ppwszEscapedName = (WCHAR*) CsMemAlloc( cbLen );

    if ( ! *ppwszEscapedName )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Add in the LHS of the filter expression
    //

    hr = StringCbCopy( *ppwszEscapedName, cbLen, L"(" PACKAGENAME L"=" );
    if (FAILED(hr)) 
    {
        CsMemFree(*ppwszEscapedName);
        *ppwszEscapedName = NULL;
        return hr;
    }

    //
    // We will escape the name -- move past the end of the filter expression LHS
    //
    wszCurrent = *ppwszEscapedName + ( sizeof(L"(" PACKAGENAME L"=") - 1 ) / sizeof( WCHAR );
    ulCurSizeLeft = (cbLen - (sizeof(L"(" PACKAGENAME L"=") - 1)) / sizeof(WCHAR);

    //
    // For each character that needs to be escaped, we will append that character's 
    // escape sequence to the string.  For characters that do not need to be escaped,
    // we simply simply append the character as-is (i.e. unescaped).
    //
    for ( ; *wszName; wszName++ )
    {
        WCHAR* EscapedChar;

        //
        // Detect characters that need to be escaped and
        // map each to its escape sequence
        //
        switch ( *wszName )
        {
        case L'*':

            EscapedChar = L"\\2a";
            break;

        case L'(':

            EscapedChar = L"\\28";
            break;

        case L')':

            EscapedChar = L"\\29";
            break;

        case L'\\':

            EscapedChar = L"\\5c";
            break;

        default:
            
            //
            // This character does not need to be escaped, just append it
            //
            *wszCurrent = *wszName;
            wszCurrent ++;
            ulCurSizeLeft--;

            continue;

            break;
        }
            
        //
        // We only get here if the character needed to be escaped --
        // we append the string for the escape sequence to the filter string, and
        // move our filter string location to the new end of string
        //

        hr = StringCchCopy( wszCurrent, ulCurSizeLeft, EscapedChar );
        wszCurrent += 3;
        ulCurSizeLeft-=3;
    }

    //
    // We need to add the closing parenthesis to the filter expression
    //
    *wszCurrent++ = L')';
    *wszCurrent   = L'\0';

    return S_OK;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\qry.cxx ===
//
//  Author: DebiM/UShaji
//  Date:   Jan 97 - Apr 98
//
//      Class Store Query and Fetch Implementation
//
//
//---------------------------------------------------------------------
//

#include "cstore.hxx"

//
// List of Attributes for On-Demand Package Lookup Query
//
LPOLESTR pszInstallInfoAttrNames[] =
{
    PKGFILEEXTNLIST,    LOCALEID,   ARCHLIST,   PACKAGEFLAGS,   SCRIPTPATH,         PKGCLSIDLIST,
    PACKAGETYPE,        PKGUSN,     VERSIONHI,  VERSIONLO,      UPGRADESPACKAGES,   UILEVEL,
    PACKAGENAME,        HELPURL,    PUBLISHER,  REVISION,       PRODUCTCODE,        OBJECTDN,
    OBJECTGUID,         MSIFILELIST,            SECURITYDESCRIPTOR
};
DWORD cInstallInfoAttr = sizeof(pszInstallInfoAttrNames) / sizeof(*pszInstallInfoAttrNames);

//
// List of Attributes for GetPackageDetail() method
//

LPOLESTR pszPackageDetailAttrNames[] =
{
    PACKAGEFLAGS,   PACKAGETYPE,    SCRIPTPATH,         SCRIPTSIZE,         SETUPCOMMAND,   HELPURL,        PKGUSN,
    VERSIONHI,      VERSIONLO,      UILEVEL,            UPGRADESPACKAGES,   ARCHLIST,       LOCALEID,       PKGCLSIDLIST,
    PKGFILEEXTNLIST,PACKAGENAME,    MSIFILELIST,        PKGCATEGORYLIST,    MVIPC,
    PRODUCTCODE,    REVISION,       OBJECTGUID
};
DWORD cPackageDetailAttr = sizeof(pszPackageDetailAttrNames) / sizeof(*pszPackageDetailAttrNames);


LPOLESTR pszDeleteAttrNames[] =
{
    PACKAGEFLAGS, OBJECTDN
};
DWORD cDeleteAttr = 2;

//
// List of Attributes for App Categories
//

LPOLESTR pszCategoryAttrNames[] =
{
    LOCALEDESCRIPTION, CATEGORYCATID
};
DWORD cCategoryAttr = 2;

void GetAttributesFromPackageFlags(
    DWORD          dwPackageFlags,
    UINT*          pUILevel,
    CLASSPATHTYPE* pClassType)
{
    *pUILevel = dwPackageFlags & ACTFLG_FullInstallUI ?
        INSTALLUILEVEL_BASIC :
        INSTALLUILEVEL_FULL;

    *pClassType = (CLASSPATHTYPE) (dwPackageFlags >>
                                   PATHTYPESHIFT);
}


BOOL MatchPlatform(
    CSPLATFORM *pReqPlatform,
    CSPLATFORM *pPkgPlatform,
    BOOL        fExcludeX86OnWin64,
    BOOL        fLegacy)
{
    //
    // Make sure this is the correct platform
    //
    if (pReqPlatform->dwPlatformId != pPkgPlatform->dwPlatformId)
    {
        return FALSE;
    }

    //
    // ProcessorArch must match
    //
    if (pReqPlatform->dwProcessorArch != pPkgPlatform->dwProcessorArch)
    {
        //
        // Reinterpret this flag based on whether this is a legacy deployment
        // or not -- we have the opposite semantics for this flag for
        // legacy deployments
        //
        if ( fLegacy )
        {
            fExcludeX86OnWin64 = ! fExcludeX86OnWin64;
        }

        //
        // If the caller is requesting to ignore  x86 on Win64, inequality between
        // architectures is automatic disqualification
        //
        if (fExcludeX86OnWin64)
        {
            return FALSE;
        }

        //
        // Caller specified that we should allow x86 packages on win64 --
        // see if we are in that situation, and only disqualify the package if not
        //
        if (!(((PROCESSOR_ARCHITECTURE_IA64 == pReqPlatform->dwProcessorArch) ||
               (PROCESSOR_ARCHITECTURE_AMD64 == pReqPlatform->dwProcessorArch)) &&
              (PROCESSOR_ARCHITECTURE_INTEL == pPkgPlatform->dwProcessorArch)) )
        {
            return FALSE;
        }
    }

    //
    // Check the OS version, hi part first -- this requested platform must be at least as
    // high as the package platform -- if not, it is disqualified
    //
    if (pReqPlatform->dwVersionHi < pPkgPlatform->dwVersionHi)
    {
        return FALSE;
    }

    //
    // If the hi version is the same, check the low part of the os version
    //
    if (pReqPlatform->dwVersionHi == pPkgPlatform->dwVersionHi)
    {

        //
        // If the requested platform is less than the package, it cannot
        // support that package, so the package is disqualified.
        //
        if (pReqPlatform->dwVersionLo < pPkgPlatform->dwVersionLo)
        {
            return FALSE;
        }
    }

    //
    // We passed all the tests -- the package matches the requested platform
    //

    return TRUE;
}


// this has to change if the Msi can give us a preferred list etc.
DWORD PlatformWt(
    CSPLATFORM *pReqPlatform,
    CSPLATFORM *pPkgPlatform,
    BOOL        fExcludeX86OnWin64,
    BOOL        fLegacy)
{
    //
    // See if we get an exact match
    //
    if (MatchPlatform(pReqPlatform,
                      pPkgPlatform,
                      TRUE,
                      FALSE))
    {
        return PRI_ARCH_PREF1;
    }

    //
    // If we don't match exactly, try matching
    // through by taking exclusion flag into account
    //
    if (MatchPlatform(pReqPlatform,
                      pPkgPlatform,
                      fExcludeX86OnWin64,
                      fLegacy))
    {
        return PRI_ARCH_PREF2;
    }


    return 0;
}


DWORD ClassContextWt(DWORD ClsCtx)
{
    if (ClsCtx & CLSCTX_INPROC_SERVER)
        return PRI_CLSID_INPSVR;

    if (ClsCtx & CLSCTX_LOCAL_SERVER)
        return PRI_CLSID_LCLSVR;

    if (ClsCtx & CLSCTX_REMOTE_SERVER)
        return PRI_CLSID_REMSVR;

    return 0;
}

//
//
void GetCurrentUsn(LPOLESTR pStoreUsn)
{
    //
    // Get the current time as USN for the Class Store container
    //

    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    (void) StringCchPrintf (pStoreUsn, 
                            15,
                            L"%04d%02d%02d%02d%02d%02d",
                            SystemTime.wYear,
                            SystemTime.wMonth,
                            SystemTime.wDay,
                            SystemTime.wHour,
                            SystemTime.wMinute,
                            SystemTime.wSecond);
}

void TimeToUsn (LPOLESTR szTimeStamp, CSUSN *pUsn)
{
    SYSTEMTIME SystemTime;

    if (szTimeStamp)
    {
        UINT l = wcslen(szTimeStamp) - 1;
        LPOLESTR pStr = szTimeStamp;

        for (UINT i=0; i < l; ++i)
        {
            if (*pStr == L' ')
                *pStr = L'0';
            ++pStr;
        }

        int iStatus;
        iStatus = swscanf (szTimeStamp, L"%4d%2d%2d%2d%2d%2d",
                     &SystemTime.wYear,
                     &SystemTime.wMonth,
                     &SystemTime.wDay,
                     &SystemTime.wHour,
                     &SystemTime.wMinute,
                     &SystemTime.wSecond);

        if (EOF == iStatus || 0 == iStatus)
        {
            memset(pUsn, 0, sizeof(FILETIME));
        }
        else
        {
            SystemTimeToFileTime(&SystemTime, (LPFILETIME) pUsn);
        }
    }
    else
        pUsn->dwHighDateTime = pUsn->dwLowDateTime = 0;
}


HRESULT UsnGet(ADS_ATTR_INFO Attr, CSUSN *pUsn)
{
    //
    // Read the USN for the Class Store container or Package
    //
    WCHAR *szTimeStamp=NULL;

    UnpackStrFrom(Attr, &szTimeStamp);

    TimeToUsn (szTimeStamp, pUsn);

    return S_OK;
}



// FetchInstallData
//-----------------
//
//
//  Gets the result set of the ondemand lookup query to locate an install package.
//  Returns the properties of the most likely Package in PackageInfo structure.
//
//  In case more than one package meets the criteria, their priorities are returned.
//

HRESULT FetchInstallData(HANDLE             hADs,
                         ADS_SEARCH_HANDLE  hADsSearchHandle,
                         QUERYCONTEXT      *pQryContext,
                         uCLSSPEC          *pclsspec,
                         LPOLESTR           pszFileExt,
                         ULONG              cRows,
                         ULONG             *pcRowsFetched,
                         PACKAGEDISPINFO   *pPackageInfo,
                         UINT              *pdwPriority,
                         BOOL               OnDemandInstallOnly,
                         GUID*              pGpoId,
                         WCHAR*             wszGpoPath
                         )
{
    HRESULT             hr = S_OK;
    LPOLESTR            szUsn = NULL;
    ULONG               cCount = 0;
    LPOLESTR          * pszList = NULL;
    DWORD             * pdwList = NULL;
    ADS_SEARCH_COLUMN   column;
    CSPLATFORM          PkgPlatform;

    //
    //  Get the rows
    //


    //
    // Clear the caller supplied buffer in case the call to
    // get the first row fails
    //
    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    *pcRowsFetched = 0;

    if (*pcRowsFetched == cRows)
        return S_OK;

    for (hr = ADSIGetFirstRow(hADs, hADsSearchHandle);
         ;
         hr = ADSIGetNextRow(hADs, hADsSearchHandle))
    {
        //
        // Get the data from each row
        //

        //
        // Clear the caller supplied buffer in case previous
        // trips through this loop have written data
        //
        ReleasePackageInfo(pPackageInfo);

        //
        // Stop iterating if there are no more rows
        //
        if (!((SUCCEEDED(hr)) && (hr != S_ADS_NOMORE_ROWS)))
        {
            break;
        }

        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PACKAGENAME, &column);

        if (SUCCEEDED(hr))
        {
            hr = UnpackStrAllocFrom(column, &(pPackageInfo->pszPackageName));

            ADSIFreeColumn(hADs, &column);

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_EXAMINING,
                      pPackageInfo->pszPackageName));
        }
        else {

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MISSING_ATTR,
                      PACKAGENAME,
                      hr));

            continue;
        }
        
        //
        // Determine the package flags -- this is used to interpret many
        // of the remaining attributes
        //
        if (SUCCEEDED(hr))
        {
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGEFLAGS, &column);
        }

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwActFlags));

            ADSIFreeColumn(hADs, &column);
        }
        else
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MISSING_ATTR,
                      PACKAGEFLAGS,
                      hr));
            continue;
        }

        //
        // Ignore the following checks when looking for a specific application
        // object.  The caller knows what he's doing in this case and may be
        // searching for a removed application specifically.
        //
        if ( pclsspec->tyspec != TYSPEC_OBJECTID )
        {
            //
            // Does it support AutoInstall?
            //
            if ((OnDemandInstallOnly) && (!(pPackageInfo->dwActFlags & ACTFLG_OnDemandInstall)))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_FLAG,
                          pPackageInfo->pszPackageName,
                          ACTFLG_OnDemandInstall));

                continue;
            }

            // If it is neither Published nor Assigned then skip it.

            if ((!(pPackageInfo->dwActFlags & ACTFLG_Published)) &&
                (!(pPackageInfo->dwActFlags & ACTFLG_Assigned)))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_FLAG,
                          pPackageInfo->pszPackageName,
                          ACTFLG_Assigned));

                continue;
            }

            // If it is an Orphaned App OR Uninstalled App do not return.

            if ((pPackageInfo->dwActFlags & ACTFLG_Orphan) ||
                (pPackageInfo->dwActFlags & ACTFLG_Uninstall))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_FLAG,
                          pPackageInfo->pszPackageName,
                          ACTFLG_Uninstall));

                continue;
            }
        }

        //
        // Packages using the NT 5.0 beta 3 schema are not 
        // supported in subsequent versions of Windows
        //
        if ( ! (pPackageInfo->dwActFlags & ACTFLG_POSTBETA3) )
        {
            CSDBGPrint((DM_WARNING,
                        IDS_CSTORE_BETA3_ERR));
            continue;
        }

        GetAttributesFromPackageFlags(
            pPackageInfo->dwActFlags,
            &(pPackageInfo->InstallUiLevel),
            &(pPackageInfo->PathType));

        //
        // If querying by file ext check match and priority
        // 
        *pdwPriority = 0;

        if (pszFileExt)
        {
            ULONG j;

            //Column = fileExtension

            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PKGFILEEXTNLIST, &column);

            cCount = 0;

            if (SUCCEEDED(hr))
            {
                hr = UnpackStrArrFrom(column, &pszList, &cCount);
            }

            if (SUCCEEDED(hr))
            {
                UINT cLen = wcslen(pszFileExt);

                for (j=0; j < cCount; ++j)
                {
                    LPOLESTR pStr = NULL;
                    
                    if (wcslen(pszList[j]) != (cLen+3))
                        continue;
                    if (wcsncmp(pszList[j], pszFileExt, wcslen(pszFileExt)) != 0)
                        continue;
                    *pdwPriority = (wcstoul(pszList[j]+(cLen+1), &pStr, 10))*PRI_EXTN_FACTOR;
                    break;
                }

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                break;
            }

            CsMemFree(pszList); pszList = NULL;

            //
            // If none matched skip this package
            //
            if (j == cCount) {

                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_FILE,
                          pPackageInfo->pszPackageName));

                continue;
            }
        }

        //
        // Now check Locale and Platform -- only do this
        // if a locale was specified
        //


        if (0 != pQryContext->Locale)
        {
            DWORD Wt = 0, MaxWt = 0;
            LANGID DesiredLang;

            DesiredLang = LANGIDFROMLCID(pQryContext->Locale);

            //Column = localeID
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, LOCALEID, &column);

            cCount = 0;

            if (SUCCEEDED(hr))
            {
                DWORD dwCount;

                cCount = 0;
                dwCount = 0;

                //
                // We pass dwCount instead of cCount to avoid
                // type conversion problems.  Note that we know the list
                // to always be of length 1 from the fact that
                // the deployment code will only use one language, so we
                // will not overflow this buffer
                //
                UnpackDWArrFrom(column, &pdwList, &dwCount);

                cCount = dwCount;

                ADSIFreeColumn(hADs, &column);
            }

            {
                //
                // If the caller specifies LANG_SYSTEM_DEFAULT, we interpret this
                // to mean that the caller wants us to choose apps according
                // to the language precedence in GetLanguagePriority.  If some
                // other langid was given, we then only accept exact matches and
                // give those matches the highest priority, PRI_LANG_ALWAYSMATCH
                //
                if (LANG_SYSTEM_DEFAULT == DesiredLang)
                {
                    Wt = GetLanguagePriority (
                        LANGIDFROMLCID(pdwList[0]),
                        pPackageInfo->dwActFlags);
                }
                else
                {
                    Wt = (DesiredLang == LANGIDFROMLCID(pdwList[0])) ?
                        PRI_LANG_ALWAYSMATCH :
                        0;
                }

                if (Wt > MaxWt)
                    MaxWt = Wt;
            }
            //
            // If none matched skip this package
            //
            DWORD dwLocale;
            BOOL  fHasLocale;

            fHasLocale = FALSE;

            if (pdwList)
            {
                dwLocale = LANGIDFROMLCID(pdwList[0]);
                CsMemFree(pdwList);
                fHasLocale = TRUE;
            }

            pdwList = NULL;

            // if nothing matched, quit
            if (MaxWt == 0)
            {
                if ( ! fHasLocale ) 
                {
                    CSDBGPrint((DM_WARNING,
                              IDS_CSTORE_MISSING_ATTR,
                              LOCALEID,
                              hr));
                }

                continue;
            }

            *pdwPriority += MaxWt;

            pPackageInfo->LangId = (LANGID) dwLocale;
        }

        hr = GetRsopSpecificAttributes(
            hADs,
            hADsSearchHandle,
            NULL,
            pPackageInfo,
            NULL);

        if (FAILED(hr))
        {
            CSDBGPrint((DM_WARNING,
                        IDS_CSTORE_RSOPERROR,
                        hr));
        }

        if (SUCCEEDED(hr))
        {
            DWORD dwCount;

            cCount = 0;
            dwCount = 0;

            DWORD Wt = 0, MaxWt = 0;

            dwCount = pPackageInfo->cArchitectures;

            pdwList = pPackageInfo->prgArchitectures;

            cCount = dwCount;

            pPackageInfo->MatchedArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;

            for (ULONG j=0; j < cCount; ++j)
            {
                PackPlatform (pdwList[j], &PkgPlatform);

                Wt = PlatformWt (&(pQryContext->Platform),
                                 &PkgPlatform,
                                 pPackageInfo->dwActFlags & ACTFLG_ExcludeX86OnWin64,
                                 SetupNamePath == pPackageInfo->PathType);

                if (Wt > MaxWt)
                {
                    pPackageInfo->MatchedArchitecture = pdwList[j];
                    MaxWt = Wt;
                }
            }

            pdwList = NULL;

            //
            // If none matched skip this package
            //
            if (MaxWt == 0)
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_ARCH,
                          pPackageInfo->pszPackageName));

                continue;
            }

            *pdwPriority += MaxWt;
        }
        else
        {
            continue;
        }

        // passed all the filters.

        //Column = OBJECTGUID
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, OBJECTGUID, &column);
        if (SUCCEEDED(hr))
        {
            LPOLESTR pStr = NULL;

            UnpackGUIDFrom(column, &(pPackageInfo->PackageGuid));

            ADSIFreeColumn(hADs, &column);
        }

        //Column = ScriptPath
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, SCRIPTPATH, &column);
        if (SUCCEEDED(hr))
        {
            hr = UnpackStrAllocFrom(column, &(pPackageInfo->pszScriptPath));

            ADSIFreeColumn(hADs, &column);

            if (FAILED(hr))
            {
                break;
            }
        }

        if (SUCCEEDED(hr) && (pclsspec->tyspec == TYSPEC_CLSID))
        {
            //Column = comClassID
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PKGCLSIDLIST, &column);
            cCount = 0;
            if (SUCCEEDED(hr))
            {
                hr = UnpackStrArrFrom(column, &pszList, &cCount);

                if (cCount)
                {
                    DWORD   i=0, Ctx = 0;
                    WCHAR   szClsid[STRINGGUIDLEN], *szPtr = NULL;

                    StringFromGUID(pclsspec->tagged_union.clsid, szClsid);
                    for (i = 0; i < cCount; i++)
                        if (wcsncmp(pszList[i], szClsid, STRINGGUIDLEN-1) == 0)
                            break;

                    //
                    // The below assert is only hit if there is bad data -- if we find the
                    // clsid, i will not be cCount, and cCount will never be 0.  Basically,
                    // we're asserting that the search should always succeed if the ds data
                    // is good.
                    //
                    ASSERT(i != cCount);

                    if (i == cCount)
                    {
                        CSDBGPrint((DM_WARNING,
                                  IDS_CSTORE_SKIP_CLSID,
                                  pPackageInfo->pszPackageName));

                        CsMemFree(pszList);
                        continue;
                    }

                    if (wcslen(pszList[i]) > (STRINGGUIDLEN-1))
                        Ctx = wcstoul(pszList[i]+STRINGGUIDLEN, &szPtr, 16);

                    if ( ( Ctx & pQryContext->dwContext ) == 0 )
                    {
                        CsMemFree(pszList);
                        ADSIFreeColumn(hADs, &column);

                        CSDBGPrint((DM_WARNING,
                                  IDS_CSTORE_SKIP_CLSID,
                                  pPackageInfo->pszPackageName));

                        // none of the class context matched.
                        continue;
                    }
                    else
                        *pdwPriority += ClassContextWt((Ctx & pQryContext->dwContext));

                    CsMemFree(pszList);
                }

                ADSIFreeColumn(hADs, &column);

                if (FAILED(hr))
                {
                    break;
                }
            }
        }

        //Column = lastUpdateSequence
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PKGUSN, &column);
        if (SUCCEEDED(hr))
        {
            hr = UnpackStrFrom(column, &szUsn);
            TimeToUsn (szUsn, (CSUSN *)(&(pPackageInfo->Usn)));
            ADSIFreeColumn(hADs, &column);

            if (FAILED(hr))
            {
                break;
            }
        }
        else {

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MISSING_ATTR,
                      PKGUSN,
                      hr));

            continue;
        }

        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, PRODUCTCODE, &column);
        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &(pPackageInfo->ProductCode));
            ADSIFreeColumn(hADs, &column);
        }

        //Column = versionNumberHi
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, VERSIONHI, &column);
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwVersionHi));

            ADSIFreeColumn(hADs, &column);
        }

        //Column = versionNumberLo
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, VERSIONLO, &column);

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwVersionLo));

            ADSIFreeColumn(hADs, &column);
        }

        //Column = revision
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, REVISION, &column);

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwRevision));

            ADSIFreeColumn(hADs, &column);
        }

        // Column = url
        // This one is optional and will be unset in most cases.
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, HELPURL, &column);

        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszUrl));

            ADSIFreeColumn(hADs, &column);
        }

        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, UPGRADESPACKAGES, &column);
        if (SUCCEEDED(hr))
        {
            LPOLESTR *pProp = NULL;
            hr = UnpackStrArrAllocFrom(column, &pProp, (DWORD *)&(pPackageInfo->cUpgrades));

            if (pPackageInfo->cUpgrades)
                pPackageInfo->prgUpgradeInfoList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*
                                                        (pPackageInfo->cUpgrades));

            if (pPackageInfo->prgUpgradeInfoList)
            {
                memset(pPackageInfo->prgUpgradeInfoList, 0, sizeof(UPGRADEINFO)*(pPackageInfo->cUpgrades));

                for (ULONG j=0; j < (pPackageInfo->cUpgrades); ++j)
                {
                    WCHAR *pStr = NULL;
                    LPOLESTR ptr = (pPackageInfo->prgUpgradeInfoList[j].szClassStore) = pProp[j];
                    UINT len = wcslen (ptr);
                    if (len <= 41)
                        continue;

                    *(ptr + len - 3) = NULL;
                    (pPackageInfo->prgUpgradeInfoList[j].Flag) = wcstoul(ptr+(len-2), &pStr, 16);

                    *(ptr + len - 3 - 36 - 2) = L'\0';
                            /*      -GUID-'::'*/
                    GUIDFromString(ptr+len-3-36, &(pPackageInfo->prgUpgradeInfoList[j].PackageGuid));
                }

                pPackageInfo->cUpgrades = j; // we might have skipped some.
            }

            ADSIFreeColumn(hADs, &column);

            if (FAILED(hr))
            {
                break;
            }
        }

        //
        // Now that we know we will use this package, 
        // copy the common gpo-related information
        //
        memcpy( &(pPackageInfo->GpoId), pGpoId, sizeof( *pGpoId ) );

        pPackageInfo->pszGpoPath = StringDuplicate( wszGpoPath );

        if ( ! pPackageInfo->pszGpoPath )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        ++pPackageInfo;
        ++pdwPriority;
        (*pcRowsFetched)++;

        if (*pcRowsFetched == cRows)
            break;

        memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));
    }

    //
    // If we couldn't even retrieve the first row, return the error
    //
    if ((0 == *pcRowsFetched) && FAILED(hr))
    {
        return hr;
    }

    //
    // Check if we found as many as asked for
    //
    if (*pcRowsFetched != cRows)
        return S_FALSE;
    return S_OK;

}

// FetchPackageInfo
//-----------------
//
//  Gets the result set of the query : List of Package objects.
//  Returns the properties in PackageInfo structure.
//
HRESULT FetchPackageInfo(HANDLE             hADs,
                         ADS_SEARCH_HANDLE  hADsSearchHandle,
                         DWORD              dwFlags,
                         DWORD              dwQuerySpec,
                         CSPLATFORM        *pPlatform,
                         ULONG              cRows,
                         ULONG             *pcRowsFetched,
                         PACKAGEDISPINFO   *pPackageInfo,
                         BOOL              *fFirst,
                         GUID*              pGpoId,
                         WCHAR*             wszGpoPath,
                         PRSOPTOKEN         pRsopUserToken
                         )

{
    HRESULT             hr = S_OK;
    UINT                i, j;
    ULONG               cPlatforms = 0;
    DWORD             * dwPlatformList=NULL;
    LCID              * dwLocaleList=NULL;
    DWORD               dwPackageFlags;
    ULONG               cFetched = 0;
    ULONG               cRowsLeft = 0;
    CSPLATFORM          PkgPlatform;
    ADS_SEARCH_COLUMN   column;
    LPOLESTR            szUsn = NULL;
    BOOL                fInclude;
    BOOL                bUserHasAccess;

    *pcRowsFetched = 0;
    cRowsLeft = cRows;

    if (!cRowsLeft)
        return S_OK;

    //
    // Clear the first package
    //
    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    // The LDAP filter performs a part of the selection
    // The flag filters are interpreted on the client after obtaining the result set

    for (;;)
    {
        //
        // Leave if there are no more rows to retrieve
        //
        if (!cRowsLeft)
        {
            break;
        }

        //
        // Free any resources from a previous iteration
        //
        ReleasePackageInfo(pPackageInfo);

        memset(pPackageInfo, 0, sizeof(*pPackageInfo));

        if ((*fFirst) && (!(*pcRowsFetched))) {
            *fFirst = FALSE;
            hr = ADSIGetFirstRow(hADs, hADsSearchHandle);
        }
        else
            hr = ADSIGetNextRow(hADs, hADsSearchHandle);

        if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
            break;

        fInclude = dwFlags & APPFILTER_INCLUDE_ALL ? TRUE : FALSE;

        //Column = packageName.

        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PACKAGENAME, &column);

        if (SUCCEEDED(hr))
        {
            hr = UnpackStrAllocFrom(column, &(pPackageInfo->pszPackageName));

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_EXAMINING,
                      pPackageInfo->pszPackageName));

            ADSIFreeColumn(hADs, &column);
        }

        if (FAILED(hr))
        {
            continue;
        }

        dwPackageFlags = 0;

        // Get the Flag Value: Column = packageFlags
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGEFLAGS, &column);

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &dwPackageFlags);

            ADSIFreeColumn(hADs, &column);
        }
        else
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MISSING_ATTR,
                      PACKAGEFLAGS,
                      hr));

            continue;
        }

        //
        // Check flag values to see if this package meets the filter
        //

        //
        // If it is an Orphaned App, we only return it for APPINFO_ALL.
        //
        if ((dwPackageFlags & ACTFLG_Orphan) && (dwFlags & APPFILTER_REQUIRE_NON_REMOVED))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_NON_REMOVED,
                      ACTFLG_Orphan));

            continue;
        }

        // If it is an Uninstalled App return it if asked for by APPINFO_ALL

        if ((dwPackageFlags & ACTFLG_Uninstall) && (dwFlags & APPFILTER_REQUIRE_NON_REMOVED))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_NON_REMOVED,
                      ACTFLG_Uninstall));

            continue;
        }

        if ((dwFlags & APPFILTER_REQUIRE_PUBLISHED) && (!(dwPackageFlags & ACTFLG_Published)))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_PUBLISHED,
                      ACTFLG_Published));

            continue;
        }

        if ((dwFlags & APPFILTER_INCLUDE_ASSIGNED) && (dwPackageFlags & ACTFLG_Assigned))
        {
            fInclude = TRUE;
        }

        if ((dwFlags & APPFILTER_INCLUDE_UPGRADES) && (dwPackageFlags & ACTFLG_HasUpgrades))
        {
            fInclude = TRUE;
        }

        if ((dwFlags & APPFILTER_REQUIRE_VISIBLE) && (!(dwPackageFlags & ACTFLG_UserInstall)))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_VISIBLE,
                      ACTFLG_UserInstall));

            continue;
        }

        if ((dwFlags & APPFILTER_REQUIRE_AUTOINSTALL) && (!(dwPackageFlags & ACTFLG_OnDemandInstall)))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_AUTOINSTALL,
                      ACTFLG_OnDemandInstall));

            continue;
        }

        //
        // Packages using the NT 5.0 beta 3 schema are not 
        // supported in subsequent versions of Windows
        //
        if ( ! (dwPackageFlags & ACTFLG_POSTBETA3) )
        {
            //
            // Only allow administrators to see beta 3 deployments for
            // administrative purposes (to delete the data).  In NT 6.0, we
            // should no longer support even this
            //
            if ( APPQUERY_ADMINISTRATIVE != dwQuerySpec )
            {
                CSDBGPrint((DM_WARNING,
                            IDS_CSTORE_BETA3_ERR));
                continue;
            }

            //Column = packageType
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGETYPE, &column);

            if (SUCCEEDED(hr))
            {
                UnpackDWFrom(column, (DWORD *)&(pPackageInfo->PathType));

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                continue;
            }

            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, UILEVEL, &column);

            if (SUCCEEDED(hr))
            {
                UnpackDWFrom(column, (DWORD *)&(pPackageInfo->InstallUiLevel));

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                continue;
            }
        }

        if ( dwPackageFlags & ACTFLG_POSTBETA3 )
        {
            GetAttributesFromPackageFlags(
                dwPackageFlags,
                &(pPackageInfo->InstallUiLevel),
                &(pPackageInfo->PathType));
        }

        if (( dwFlags & APPFILTER_REQUIRE_MSI) && (pPackageInfo->PathType != DrwFilePath))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_MSI,
                      pPackageInfo->pszPackageName,
                      pPackageInfo->PathType));

            continue;
        }

        pPackageInfo->LangId = LANG_NEUTRAL;

        //
        // If the package flags specify that we should ignore locale, or the
        // caller specified that all locale's are acceptable, skip the language
        // checks
        //
        {
            LANGID PackageLangId;
            DWORD  cLanguages;

            PackageLangId = LANG_NEUTRAL;

            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, LOCALEID, &column);

            dwLocaleList = NULL;

            if (SUCCEEDED(hr))
            {
                // type change. shouldn't affect anything.
                UnpackDWArrFrom(column, &dwLocaleList, &cLanguages);

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_MISSING_ATTR,
                          LOCALEID,
                          hr));

                continue;
            }

            //
            // We only care about the first language returned -- originally
            // the packages in the ds could support multiple locales, but
            // we now only support one language
            //
            if (cLanguages)
            {
                PackageLangId = LANGIDFROMLCID(dwLocaleList[0]);
            }

            CsMemFree(dwLocaleList);

            //
            // If the package flags specify that we should ignore locale, or the
            // caller specified that all locale's are acceptable, skip the language
            // checks
            //
            if ( (dwFlags & APPFILTER_REQUIRE_THIS_LANGUAGE) &&
                 ! ( dwPackageFlags & ACTFLG_IgnoreLanguage ) )
            {
                if (!cLanguages || !MatchLanguage(PackageLangId, dwPackageFlags))
                {
                    CSDBGPrint((DM_WARNING,
                              IDS_CSTORE_MISSING_ATTR,
                              LOCALEID,
                              hr));

                    continue;
                }
            }

            pPackageInfo->LangId = PackageLangId;
        }

        if (pPlatform != NULL)
        {

            //Column = machineArchitecture
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, ARCHLIST, &column);
            cPlatforms = 0;
            dwPlatformList = NULL;

            if (SUCCEEDED(hr))
            {
                UnpackDWArrFrom(column, &dwPlatformList, &cPlatforms);

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_MISSING_ATTR,
                          ARCHLIST,
                          hr));

                continue;
            }

            DWORD MaxPlatformWeight;

            MaxPlatformWeight = 0;

            pPackageInfo->MatchedArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;

            for (j=0; j < cPlatforms; ++j)
            {
                DWORD PlatformWeight;

                PackPlatform (dwPlatformList[j], &PkgPlatform);
                PlatformWeight = PlatformWt (pPlatform,
                                             &PkgPlatform,
                                             dwPackageFlags & ACTFLG_ExcludeX86OnWin64,
                                             SetupNamePath == pPackageInfo->PathType);

                if ( PlatformWeight > MaxPlatformWeight )
                {
                    pPackageInfo->MatchedArchitecture = dwPlatformList[j];
                    MaxPlatformWeight = PlatformWeight;
                }
            }

            if (dwPlatformList)
                CsMemFree(dwPlatformList);
            //
            // If none matched skip this package
            //
            if ( 0 == MaxPlatformWeight )
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_ARCH,
                          pPackageInfo->pszPackageName));

                continue;
            }
        }

        pPackageInfo->dwActFlags = dwPackageFlags;

        //Column = OBJECTGUID
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, OBJECTGUID, &column);

        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &(pPackageInfo->PackageGuid));

            ADSIFreeColumn(hADs, &column);
        }

        if ( ! (APPFILTER_CONTEXT_ARP & dwFlags) ||
            (APPFILTER_CONTEXT_RSOP & dwFlags) )
        {
            //Column = ScriptPath
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, SCRIPTPATH, &column);

            if (SUCCEEDED(hr))
            {
                UnpackStrAllocFrom(column, &(pPackageInfo->pszScriptPath));

                ADSIFreeColumn(hADs, &column);
            }
        }

        if ( ! (APPFILTER_CONTEXT_ARP & dwFlags) ||
            (APPFILTER_CONTEXT_RSOP & dwFlags) )
        {
            //Column = lastUpdateSequence,
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PKGUSN, &column);

            if (SUCCEEDED(hr))
            {
                UnpackStrFrom(column, &szUsn);
                TimeToUsn (szUsn, (CSUSN *)(&(pPackageInfo->Usn)));
                ADSIFreeColumn(hADs, &column);
            }
            else {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_MISSING_ATTR,
                          PKGUSN,
                          hr));

                continue;
            }
        }

        // ProductCode
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, PRODUCTCODE, &column);
        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &(pPackageInfo->ProductCode));
            ADSIFreeColumn(hADs, &column);
        }

        if ( ! (APPFILTER_CONTEXT_ARP & dwQuerySpec) ||
            (APPFILTER_CONTEXT_RSOP & dwFlags) )
        {
            //Column = revision
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, REVISION, &column);

            if (SUCCEEDED(hr))
            {
                UnpackDWFrom(column, &(pPackageInfo->dwRevision));

                ADSIFreeColumn(hADs, &column);
            }
        }

        // Column = url
        // This one is optional and will be unset in most cases.
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, HELPURL, &column);

        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszUrl));

            ADSIFreeColumn(hADs, &column);
        }

        //
        // We need to grab additional attributes for rsop logging
        //
        if ( APPFILTER_CONTEXT_RSOP & dwFlags )
        {
            hr = GetRsopSpecificAttributes(
                hADs,
                hADsSearchHandle,
                pRsopUserToken,
                pPackageInfo,
                &bUserHasAccess);

            if (FAILED(hr))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_RSOPERROR,
                          hr));
            }
            else
            {
                if ( pRsopUserToken && ( ! bUserHasAccess ) )
                {
                    continue;
                }
            }
        }

        if ( (APPFILTER_CONTEXT_RSOP & dwFlags) ||
             (APPFILTER_CONTEXT_ARP & dwFlags) )
        {
            hr = GetCategories(
                hADs,
                hADsSearchHandle,
                pPackageInfo);

            if ( FAILED(hr) )
            {
                CSDBGPrint((DM_WARNING,
                            IDS_CSTORE_MISSING_ATTR,
                            PKGCATEGORYLIST,
                            hr));

                continue;
            }

            // This one is optional and will be unset in most cases.
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, HELPURL, &column);

            if (SUCCEEDED(hr))
            {
                UnpackStrAllocFrom(column, &(pPackageInfo->pszUrl));

                ADSIFreeColumn(hADs, &column);
            }
            hr = S_OK;
        }

        if ( dwPackageFlags & ACTFLG_HasUpgrades )
        {

            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, UPGRADESPACKAGES, &column);
            if (SUCCEEDED(hr))
            {
                LPOLESTR *pProp = NULL;
                hr = UnpackStrArrAllocFrom(column, &pProp, (DWORD *)&(pPackageInfo->cUpgrades));

                ADSIFreeColumn(hADs, &column);

                if (pPackageInfo->cUpgrades)
                    pPackageInfo->prgUpgradeInfoList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*
                                                                                 (pPackageInfo->cUpgrades));

                if (pPackageInfo->prgUpgradeInfoList)
                {
                    memset(pPackageInfo->prgUpgradeInfoList, 0, sizeof(UPGRADEINFO)*(pPackageInfo->cUpgrades));

                    for (j=0; j < ( pPackageInfo->cUpgrades); ++j)
                    {
                        BOOL  fGotGPO;
                        WCHAR *pStr = NULL;
                        LPOLESTR ptr = (pPackageInfo->prgUpgradeInfoList[j].szClassStore) = pProp[j];
                        UINT len = wcslen (ptr);
                        if (len <= 41)
                            continue;

                        //
                        // Find the GPO for this upgrade
                        //
                        fGotGPO = GetGpoIdFromClassStorePath(
                            pPackageInfo->prgUpgradeInfoList[j].szClassStore,
                            &(pPackageInfo->prgUpgradeInfoList[j].GpoId));

                        if (!fGotGPO)
                        {
                            continue;
                        }


                        *(ptr + len - 3) = NULL;
                        (pPackageInfo->prgUpgradeInfoList[j].Flag) = wcstoul(ptr+(len-2), &pStr, 16);

                        *(ptr + len - 3 - 36 - 2) = L'\0';
                        /*      -GUID-'::'*/
                        GUIDFromString(ptr+len-3-36, &(pPackageInfo->prgUpgradeInfoList[j].PackageGuid));
                    }
                    pPackageInfo->cUpgrades = j; // we might have skipped some.

                    fInclude = TRUE;
                }
            }
        }

        if (!fInclude)
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_INCLUDE,
                      pPackageInfo->pszPackageName));

            continue;
        }

        //
        // Now that we know we will use this package, 
        // copy the common gpo-related information
        //
        memcpy( &(pPackageInfo->GpoId), pGpoId, sizeof( *pGpoId ) );

        pPackageInfo->pszGpoPath = StringDuplicate( wszGpoPath );

        if ( ! pPackageInfo->pszGpoPath )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        ++pPackageInfo;

        cRowsLeft--;

        (*pcRowsFetched)++;

        if (!cRowsLeft)
        {
            break;
        }

    }

    //
    // If we couldn't even retrieve the first row, return the error
    //
    if ((0 == *pcRowsFetched) && FAILED(hr))
    {
        return hr;
    }

    if (!cRowsLeft)
        return S_OK;
    return S_FALSE;
}

// FetchCategory
//--------------
//
// List of columns this routine fetches.
//

HRESULT FetchCategory(HANDLE                hADs,
                      ADS_SEARCH_HANDLE     hADsSearchHandle,
                      APPCATEGORYINFOLIST * pCategoryInfoList,
                      LCID                  Locale
                      )
{
    HRESULT                 hr = S_OK;
    ADS_SEARCH_COLUMN       column;
    LPOLESTR              * pszDesc = NULL;
    DWORD                   cdesc = 0, i = 0;
    LPOLESTR                szCatid = NULL;
    DWORD                   cMaxCategories;
    DWORD                   cCategories;

    cMaxCategories = 0;
    cCategories = 0;

    pCategoryInfoList->pCategoryInfo = NULL;

    for (hr = ADSIGetFirstRow(hADs, hADsSearchHandle), i = 0;
                   ((SUCCEEDED(hr)) && ((hr) != S_ADS_NOMORE_ROWS));
                   hr = ADSIGetNextRow(hADs, hADsSearchHandle), i++)
    {
        APPCATEGORYINFO*        pCurrentCategories;

        cCategories++;

        //
        // First, verify that we have enough space to store
        // the next category
        //
        if ( cCategories > cMaxCategories )
        {
            //
            // Get enough space for the current categories as well
            // as some extra since we still don't know how many more categories
            // we have
            //
            cMaxCategories += CATEGORY_RETRIEVAL_ALLOC_SIZE;
            
            pCurrentCategories = (APPCATEGORYINFO*) CsMemAlloc( cMaxCategories * sizeof(APPCATEGORYINFO) );

            if ( !pCurrentCategories )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if ( pCategoryInfoList->pCategoryInfo )
            {
                //
                // We have enough space, copy the existing entries -- 
                // note that the list engrties  are not self-referential, so we can
                // blindly copy them, but the list itself contains a pointer into itself,
                // so this must be adjusted after the copy
                //
                memcpy( pCurrentCategories, pCategoryInfoList->pCategoryInfo, i * sizeof(APPCATEGORYINFO) );

                //
                // Free the old list since it is no longer needed.  Note that
                // we do not user the ReleaseAppCategoryInfoList api to free 
                // the list since that would also free memory referenced by
                // members of elements of the category array -- we want to preserve
                // these references in the succeeding copy
                //
                if ( pCategoryInfoList->pCategoryInfo )
                {
                    CsMemFree( pCategoryInfoList->pCategoryInfo );

                    pCategoryInfoList->pCategoryInfo = NULL;
                }
            }

            //
            // Clear the newly added entries
            //
            memset( &(pCurrentCategories[i]), 0, sizeof(APPCATEGORYINFO) * CATEGORY_RETRIEVAL_ALLOC_SIZE );

            //
            // Set the list structure to refer to the successfully 
            // reallocated memory
            //
            pCategoryInfoList->pCategoryInfo = pCurrentCategories;
        }

        // Get the data from each row ignoring the error returned.

        //Column = description
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, LOCALEDESCRIPTION, &column);
        cdesc = 0; pszDesc = NULL;

        if (SUCCEEDED(hr))
            UnpackStrArrFrom(column, &pszDesc, &cdesc);

        (pCategoryInfoList->pCategoryInfo)[i].Locale = Locale;
        (pCategoryInfoList->pCategoryInfo)[i].pszDescription =
                            (LPOLESTR)CsMemAlloc( (CAT_DESC_MAX_LEN + 1) * sizeof(WCHAR));

        // The description has a maximum size.

        if ((pCategoryInfoList->pCategoryInfo)[i].pszDescription)
            GetCategoryLocaleDesc(pszDesc, cdesc, &((pCategoryInfoList->pCategoryInfo)[i].Locale),
                                        (pCategoryInfoList->pCategoryInfo)[i].pszDescription, CAT_DESC_MAX_LEN + 1);

        if (SUCCEEDED(hr))
            ADSIFreeColumn(hADs, &column);

        if (pszDesc)
            CsMemFree(pszDesc);

        // catid
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, CATEGORYCATID, &column);

        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &((pCategoryInfoList->pCategoryInfo)[i].AppCategoryId));

            ADSIFreeColumn(hADs, &column);
        }
    }

    pCategoryInfoList->cCategory = i;

    //
    // On failure, clean up the category list so the caller
    // will not attempt to use invalid data
    //
    if (FAILED(hr))
    {
        ReleaseAppCategoryInfoList( pCategoryInfoList );
    }

    return hr;
}

HRESULT GetPackageDetail (HANDLE           hPackageADs, WCHAR *szClassContainerPath,
                          PACKAGEDETAIL   *pPackageDetail)
{
    HRESULT             hr = S_OK;
    GUID                PkgGuid;
    DWORD              *pdwArch = NULL, count = 0;
    PLATFORMINFO       *pPlatformInfo = NULL;
    INSTALLINFO        *pInstallInfo = NULL;
    ACTIVATIONINFO     *pActInfo = NULL;
    ADS_ATTR_INFO      *pAttr = NULL;
    DWORD               posn, cgot = 0;
    DWORD               cClasses = 0;
    LPOLESTR           *szClasses = NULL;
        DWORD                           dwUiLevel = 0;
    DWORD               cProgId = 0;
    LPOLESTR           *pszProgId = NULL;

    memset (pPackageDetail, 0, sizeof (PACKAGEDETAIL));

    hr = ADSIGetObjectAttributes(hPackageADs, pszPackageDetailAttrNames, cPackageDetailAttr,
                &pAttr, &cgot);
    RETURN_ON_FAILURE(hr);

    pInstallInfo = pPackageDetail->pInstallInfo = (INSTALLINFO *) CsMemAlloc(sizeof (INSTALLINFO));

    if (!pInstallInfo)
        ERROR_ON_FAILURE((hr=E_OUTOFMEMORY));

    memset(pInstallInfo, NULL, sizeof(INSTALLINFO));

    posn = GetPropertyFromAttr(pAttr, cgot,  PACKAGEFLAGS);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn], (DWORD *)&(pInstallInfo->dwActFlags));
    else
        ERROR_ON_FAILURE((hr=CS_E_OBJECT_NOTFOUND));

    posn = GetPropertyFromAttr(pAttr, cgot, SCRIPTPATH);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn], &(pInstallInfo->pszScriptPath));

    posn = GetPropertyFromAttr(pAttr, cgot, SCRIPTSIZE);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn], &(pInstallInfo->cScriptLen));

    posn = GetPropertyFromAttr(pAttr, cgot, SETUPCOMMAND);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn], &(pInstallInfo->pszSetupCommand));

    posn = GetPropertyFromAttr(pAttr, cgot, HELPURL);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn], &(pInstallInfo->pszUrl));

    posn = GetPropertyFromAttr(pAttr, cgot, PKGUSN);
    if (posn < cgot)
        UsnGet(pAttr[posn], (CSUSN *)&(pInstallInfo->Usn));
    else
        ERROR_ON_FAILURE((hr=CS_E_OBJECT_NOTFOUND));

    posn = GetPropertyFromAttr(pAttr, cgot, PRODUCTCODE);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &(pInstallInfo->ProductCode));

    //
    // Obtain the MVIPC, which is really just an upgrade code used on the server side UI
    // only to detect whether the ds contains upgrades that are mandated by a package
    //
    posn = GetPropertyFromAttr(pAttr, cgot, MVIPC);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &(pInstallInfo->Mvipc));

    // doesn't matter if the property itself is multivalued.

    posn = GetPropertyFromAttr(pAttr, cgot, OBJECTGUID);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &(pInstallInfo->PackageGuid));

    posn = GetPropertyFromAttr(pAttr, cgot, VERSIONHI);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn],   &(pInstallInfo->dwVersionHi));

    posn = GetPropertyFromAttr(pAttr, cgot, VERSIONLO);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn],   &(pInstallInfo->dwVersionLo));

    posn = GetPropertyFromAttr(pAttr, cgot, REVISION);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn],   &(pInstallInfo->dwRevision));

    //
    // Packages deployed before NT 5.0 beta 3 are in a
    // format that will not be supported for subsequent versions
    // of Windows.  However, we must support it for NT 5.1 at least
    // from the admin UI so that the they can be un-deployed.  This
    // function is called in the context of the admin UI, so we
    // will interpret the beta 3 schema
    //
    if (pInstallInfo->dwActFlags & ACTFLG_POSTBETA3)
    {
        GetAttributesFromPackageFlags(
            pInstallInfo->dwActFlags,
            (UINT*) &dwUiLevel,
            &(pInstallInfo->PathType));
    }
    else
    {
        posn = GetPropertyFromAttr(pAttr, cgot, UILEVEL);
        if (posn < cgot)
            UnpackDWFrom(pAttr[posn], &dwUiLevel);

        posn = GetPropertyFromAttr(pAttr, cgot, PACKAGETYPE);
        if (posn < cgot)
            UnpackDWFrom(pAttr[posn], (DWORD *)&(pInstallInfo->PathType));
        else
            ERROR_ON_FAILURE((hr=CS_E_OBJECT_NOTFOUND));
    }

    pInstallInfo->InstallUiLevel = dwUiLevel;

    posn = GetPropertyFromAttr(pAttr, cgot, UPGRADESPACKAGES);
    if (posn < cgot)
    {
        LPOLESTR *pProp = NULL;
        UnpackStrArrAllocFrom(pAttr[posn], &pProp, (DWORD *)&(pInstallInfo->cUpgrades));

        if (pInstallInfo->cUpgrades)
            pInstallInfo->prgUpgradeInfoList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*
                                                                             pInstallInfo->cUpgrades);

        if (!(pInstallInfo->prgUpgradeInfoList))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        memset(pInstallInfo->prgUpgradeInfoList, 0, sizeof(UPGRADEINFO)*(pInstallInfo->cUpgrades));

        for (count = 0; (count < (pInstallInfo->cUpgrades)); count++)
        {
            WCHAR *pStr = NULL;
            LPOLESTR ptr = (pInstallInfo->prgUpgradeInfoList[count].szClassStore) = pProp[count];
            UINT len = wcslen (ptr);

            if (len <= 41)
                continue;

            *(ptr + len - 3) = NULL;
            pInstallInfo->prgUpgradeInfoList[count].Flag = wcstoul(ptr+(len-2), &pStr, 16);

            *(ptr + len - 3 - 36 - 2) = L'\0';
                    /*      -GUID-'::'*/
            GUIDFromString(ptr+len-3-36, &(pInstallInfo->prgUpgradeInfoList[count].PackageGuid));
        }
        pInstallInfo->cUpgrades = count; // we might have skipped some.
    }


    pPlatformInfo = pPackageDetail->pPlatformInfo =
        (PLATFORMINFO *) CsMemAlloc(sizeof (PLATFORMINFO));
    if (!pPlatformInfo)
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

    memset(pPlatformInfo, NULL, sizeof(PLATFORMINFO));

    posn = GetPropertyFromAttr(pAttr, cgot, ARCHLIST);

    if (posn < cgot)
    {
        DWORD dwPlatforms;

        //
        // Note that since the UnpackDWArrFrom takes a DWORD*, we should
        // avoid passing the int directly and instead pass a DWORD
        //
        UnpackDWArrFrom(pAttr[posn], &pdwArch, &dwPlatforms);

        pPlatformInfo->cPlatforms = dwPlatforms;
    }

    pPlatformInfo->prgPlatform = (CSPLATFORM *)CsMemAlloc(sizeof(CSPLATFORM)*
        (pPlatformInfo->cPlatforms));

    if (!(pPlatformInfo->prgPlatform))
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

    for (count = 0; (count < (pPlatformInfo->cPlatforms)); count++)
        PackPlatform (pdwArch[count], (pPlatformInfo->prgPlatform)+count);

    CsMemFree(pdwArch);

    posn = GetPropertyFromAttr(pAttr, cgot, LOCALEID);
    if (posn < cgot)
    {
        DWORD dwLocales;

        //
        // Again, we typecast before getting the address that we
        // need to pass the count to the unpack function
        //

        UnpackDWArrFrom(pAttr[posn], &(pPlatformInfo->prgLocale),
                        &dwLocales);

        pPlatformInfo->cLocales = dwLocales;
    }

    //
    // fill in ActivationInfo.
    //

    pActInfo = pPackageDetail->pActInfo =
        (ACTIVATIONINFO *) CsMemAlloc(sizeof (ACTIVATIONINFO));

    if (!pActInfo) {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }

    memset(pActInfo, NULL, sizeof(ACTIVATIONINFO));

    //
    // Do not obtain clsid's, typelibid's, iid's  & progid's -- this data is never used.
    // However, we do check to see if there is any clsid data so that we can set the
    // member of the packagedetails which indicates that the package has com class information
    //
    posn = GetPropertyFromAttr(pAttr, cgot, PKGCLSIDLIST);

    //
    // In order to be consistent with NT5, We assume that if we do not find the classes
    // attribute, that the administrator wanted the package to be deployed with classes,
    // but the package had no classes.  
    //
    pActInfo->bHasClasses = TRUE;

    //
    // If we searched the returned attribute list and found it before passing
    // the last attribute, this package has classes
    //
    if ( posn < cgot )
    {
        //
        // We have the attribute, but if it is set to an "empty" value,
        // this means that an NT 5.1 or higher system deployed this package without classes
        //
        if ( 1 == pAttr->dwNumValues )
        {
            LPOLESTR* ppwszClsid;
 
            hr = UnpackStrArrFrom(pAttr[posn], &ppwszClsid, &cClasses);

            ERROR_ON_FAILURE(hr);

            //
            // Check for the "empty" value
            //
            if ( 0 == lstrcmp( *ppwszClsid, PKG_EMPTY_CLSID_VALUE ) )
            {
                pActInfo->bHasClasses = FALSE;
            }
        }
    }

    //
    // Do obtain file extensions
    //
    posn = GetPropertyFromAttr(pAttr, cgot, PKGFILEEXTNLIST);
    cClasses = 0;

    if (posn < cgot)
        UnpackStrArrAllocFrom(pAttr[posn], &(pActInfo->prgShellFileExt), &cClasses);
    pActInfo->cShellFileExt = cClasses;

    if (cClasses)
    {
        pActInfo->prgPriority = (UINT *)CsMemAlloc(cClasses * sizeof(UINT));
        if (!(pActInfo->prgPriority))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; count < cClasses; count++)
        {
            LPOLESTR pStr=NULL;
            UINT cLen = wcslen((pActInfo->prgShellFileExt)[count]);
            *((pActInfo->prgShellFileExt)[count] + (cLen - 3)) = NULL;
            (pActInfo->prgPriority)[count] =
                wcstoul((pActInfo->prgShellFileExt)[count]+(cLen-2), &pStr, 10);
        }
    }

    //
    // fill in package misc info
    //
    posn = GetPropertyFromAttr(pAttr, cgot, PACKAGENAME);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn],   &(pPackageDetail->pszPackageName));
    else
        ERROR_ON_FAILURE(hr=CS_E_OBJECT_NOTFOUND);

    posn = GetPropertyFromAttr(pAttr, cgot, MSIFILELIST);
    if (posn < cgot) {
        LPOLESTR *rpszSourceList = NULL, psz = NULL, pStr = NULL;
        DWORD     Loc = 0;

        UnpackStrArrFrom(pAttr[posn], &(rpszSourceList),
                                                         (DWORD *)&(pPackageDetail->cSources));

        // reorder and allocate spaces.
        if (pPackageDetail->cSources)
        {
            pPackageDetail->pszSourceList = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*
                                                                        (pPackageDetail->cSources));
            if (!(pPackageDetail->pszSourceList))
                ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

            for (count = 0; count < (pPackageDetail->cSources); count++)
            {
                psz = wcschr(rpszSourceList[count], L':');
                *psz = L'\0';
                Loc = wcstoul(rpszSourceList[count], &pStr, 10);
                pPackageDetail->pszSourceList[Loc] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*(wcslen(psz+1)+1));
                if (!(pPackageDetail->pszSourceList[Loc]))
                    ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

                hr = StringCchCopy(pPackageDetail->pszSourceList[Loc], 
                                   wcslen(psz+1)+1,
                                   psz+1);
                if (FAILED(hr))
                {
                    ERROR_ON_FAILURE(hr);
                }
            }
        }

        CsMemFree(rpszSourceList);
    }

    posn = GetPropertyFromAttr(pAttr, cgot, PKGCATEGORYLIST);
    cClasses = 0; szClasses = NULL;

    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn], &szClasses, &cClasses);

    if (cClasses)
    {
        pPackageDetail->rpCategory = (GUID *)CsMemAlloc (sizeof(GUID) * cClasses);
        if (!(pPackageDetail->rpCategory))
            ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
        pPackageDetail->cCategories = cClasses;
        for (count = 0; count < cClasses; count++)
        {
            GUIDFromString(szClasses[count], (pPackageDetail->rpCategory + count));
        }
        CsMemFree(szClasses);
    }

    return S_OK;

Error_Cleanup:
    ReleasePackageDetail(pPackageDetail);
    memset(pPackageDetail, 0, sizeof(PACKAGEDETAIL));

    if (pAttr)
        FreeADsMem(pAttr);

    return hr;
}


// GetRsopSpecificAttributes
//--------------------------
//
// Retrieves attributes not normally gathered except for when
// diagnostic rsop logging is enabled.

HRESULT GetRsopSpecificAttributes(
    HANDLE            hAds,
    ADS_SEARCH_HANDLE hSearchHandle,
    PRSOPTOKEN        pRsopUserToken,
    PACKAGEDISPINFO*  pPackageInfo,
    BOOL*             pbUserHasAccess )
{
    HRESULT           hr;
    ADS_SEARCH_COLUMN ResultColumn;

    if ( pbUserHasAccess )
    {
        *pbUserHasAccess = TRUE;
    }

    pPackageInfo->rgSecurityDescriptor = NULL;
    pPackageInfo->cbSecurityDescriptor = 0;
    pPackageInfo->prgTransforms = NULL;
    pPackageInfo->prgArchitectures = NULL;

    pPackageInfo->cTransforms = 0;
    pPackageInfo->cArchitectures = 0;

    hr = DSGetAndValidateColumn(
        hAds,
        hSearchHandle,
        ADSTYPE_CASE_IGNORE_STRING,
        PUBLISHER,
        &ResultColumn);

    if (SUCCEEDED(hr))
    {
        UnpackStrAllocFrom(ResultColumn, &(pPackageInfo->pszPublisher));

        ADSIFreeColumn(hAds, &ResultColumn);
    }

    //
    // Obtain the list of machine architectures
    //
    hr = DSGetAndValidateColumn(
        hAds,
        hSearchHandle,
        ADSTYPE_INTEGER,
        ARCHLIST,
        &ResultColumn);

    if (SUCCEEDED(hr))
    {
        DWORD dwArchitectures;

        UnpackDWArrFrom(
            ResultColumn,
            &(pPackageInfo->prgArchitectures),
            &dwArchitectures);

        pPackageInfo->cArchitectures = dwArchitectures;

        ADSIFreeColumn(hAds, &ResultColumn);
    }

    //
    // Attempt to unmarshal the transform list
    //
    hr = DSGetAndValidateColumn(
        hAds,
        hSearchHandle,
        ADSTYPE_CASE_IGNORE_STRING,
        MSIFILELIST,
        &ResultColumn);

    if (SUCCEEDED(hr))
    {
        //
        // Copy the transform list into a string -- note that this call
        // also allocates the array so we must free it later.
        //
        DWORD cTransforms;

        UnpackStrArrAllocFrom(ResultColumn,
                              &(pPackageInfo->prgTransforms),
                              &cTransforms);

        pPackageInfo->cTransforms = cTransforms;

        ADSIFreeColumn(hAds, &ResultColumn);
    }

    if ( SUCCEEDED(hr) )
    {
        //
        // Get the app's major version number
        //
        hr = DSGetAndValidateColumn(
            hAds, 
            hSearchHandle,
            ADSTYPE_INTEGER,
            VERSIONHI,
            &ResultColumn);
        

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(ResultColumn, &(pPackageInfo->dwVersionHi));
            
            ADSIFreeColumn(hAds, &ResultColumn);
        }
    }

    if ( SUCCEEDED(hr) )
    {
        //
        // Get the app's minor version number
        //
        hr = DSGetAndValidateColumn(
            hAds,
            hSearchHandle,
            ADSTYPE_INTEGER,
            VERSIONLO,
            &ResultColumn);
    
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(ResultColumn, &(pPackageInfo->dwVersionLo));
            
            ADSIFreeColumn(hAds, &ResultColumn);
        }
    }
     
    if ( SUCCEEDED(hr) )
    {
        //
        // Grab the security descriptor
        //
        (void) GetSecurityDescriptor(
            hAds,
            hSearchHandle,
            pRsopUserToken,
            pPackageInfo,
            pbUserHasAccess);
    }

    return hr;
}

HRESULT GetSecurityDescriptor(
    HANDLE            hAds,
    ADS_SEARCH_HANDLE hSearchHandle,
    PRSOPTOKEN        pRsopUserToken,
    PACKAGEDISPINFO*  pPackageInfo,
    BOOL*             pbUserHasAccess)
{
    HRESULT              hr;
    ADS_SEARCH_COLUMN    SecurityColumn;
    BOOL                 bFreeSecurityColumn;

    bFreeSecurityColumn = FALSE;

    //
    // Now unmarshal the security descriptor
    //
    hr = DSGetAndValidateColumn(hAds, hSearchHandle, ADSTYPE_NT_SECURITY_DESCRIPTOR, SECURITYDESCRIPTOR, &SecurityColumn);

    if (SUCCEEDED(hr))
    {
        //
        // Allocate the security descriptor
        //
        hr = UnpackByteAllocFrom(
            SecurityColumn,
            (BYTE**) &(pPackageInfo->rgSecurityDescriptor),
            &(pPackageInfo->cbSecurityDescriptor));

        bFreeSecurityColumn = TRUE;
    }

    //
    // In planning mode, we must perform the access check ourselves
    //
    if ( SUCCEEDED(hr) && pbUserHasAccess && pRsopUserToken )
    {
        hr = DSAccessCheck(
            pPackageInfo->rgSecurityDescriptor,
            pRsopUserToken,
            pbUserHasAccess);
    }

    if ( bFreeSecurityColumn )
    {
        ADSIFreeColumn(hAds, &SecurityColumn);
    }

    return hr;
}


// GetCategories
//--------------------------
//
// Retrieves the categories attribute for an application
// in bracketed guid string format

HRESULT GetCategories(
    HANDLE            hAds,
    ADS_SEARCH_HANDLE hSearchHandle,
    PACKAGEDISPINFO*  pPackageInfo)
{
    HRESULT           hr;
    ADS_SEARCH_COLUMN ResultColumn;
    BOOL              bFreeCategoriesColumn;

    pPackageInfo->prgCategories = NULL;

    pPackageInfo->cCategories = 0;

    bFreeCategoriesColumn = FALSE;

    //
    // Unmarshal the category list -- this package may have no catgories,
    // in which case this call will return a failure
    //
    hr = DSGetAndValidateColumn(
        hAds,
        hSearchHandle,
        ADSTYPE_CASE_IGNORE_STRING,
        PKGCATEGORYLIST,
        &ResultColumn);

    if (SUCCEEDED(hr))
    {  
        DWORD cCategories;

        //
        // Convert this to an array of guids -- note that the array
        // is allocated and should be freed.
        //
        UnpackStrArrFrom(ResultColumn,
                         &(pPackageInfo->prgCategories),
                         &cCategories);

        pPackageInfo->cCategories = cCategories;

        bFreeCategoriesColumn = TRUE;
    } 

    //
    // Since the category guids stored in the ds lack the begin and end
    // braces, we must add them so that our callers, who expect such guids,
    // will get the correct information
    //
    DWORD iCategoryGuid;

    hr = S_OK;

    for ( iCategoryGuid = 0; iCategoryGuid < pPackageInfo->cCategories; iCategoryGuid++ )
    {
        WCHAR* wszNewGuid;

        wszNewGuid = (WCHAR*) CsMemAlloc( ( MAX_GUIDSTR_LEN + 1 ) * sizeof(WCHAR) );

        if ( ! wszNewGuid )
        {
            hr = E_OUTOFMEMORY;
            pPackageInfo->cCategories = iCategoryGuid;
            break;
        }

        wszNewGuid[0] = L'{';

        wszNewGuid++;

        hr = StringCchCopy(wszNewGuid, MAX_GUIDSTR_LEN + 1, pPackageInfo->prgCategories[iCategoryGuid]);
        if (FAILED(hr)) 
        {
            pPackageInfo->cCategories = iCategoryGuid;
            CsMemFree(wszNewGuid);
            break;
        }
        wszNewGuid--;

        wszNewGuid[ MAX_GUIDSTR_LEN - 1 ] = L'}';
        wszNewGuid[ MAX_GUIDSTR_LEN ] = L'\0';

        pPackageInfo->prgCategories[iCategoryGuid] = wszNewGuid;
    }

    if ( bFreeCategoriesColumn )
    {
        ADSIFreeColumn(hAds, &ResultColumn);
    }

    if (FAILED(hr))
    {
        //
        // On failure, we must free all allocated memory
        //
        DWORD iCategory;

        for ( iCategory = 0; iCategory < pPackageInfo->cCategories; iCategory++ )
        {
            CsMemFree(pPackageInfo->prgCategories[iCategory]);
        }

        CsMemFree(pPackageInfo->prgCategories);

        pPackageInfo->prgCategories = NULL;
        pPackageInfo->cCategories = 0;
    }

    if ( E_ADS_COLUMN_NOT_SET == hr )
    {
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\enumapp.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  File:       enumapp.cxx
//
//  Contents:   Per Class Container Package Enumeration
//
//
//  History:    09-09-96  DebiM   created
//              11-01-97  DebiM   modified, moved to cstore
//
//----------------------------------------------------------------------------

#include "cstore.hxx"

//IEnumPackage implementation.

HRESULT CEnumPackage::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumPackage)
    {
        *ppObject=(IEnumPackage *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CEnumPackage::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CEnumPackage::Release()
{
    ULONG dwRefCount=m_dwRefCount-1;
    if (InterlockedDecrement((long*) &m_dwRefCount)==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}


//
// CEnumPackage::Next
// ------------------
//
//
//
//  Synopsis:       This method returns the next celt number of packages
//                  within the scope of the enumeration.
//                  Packages are returned in the alphabetical name order.
//
//  Arguments:      [in]  celt - Number of package details to fetch
//                  INSTALLINFO *rgelt - Package detail structure
//                  ULONG *pceltFetched - Number of packages returned
//
//  Returns:        S_OK or S_FALSE if short of packages
//
//
//

HRESULT CEnumPackage::Next(ULONG               celt,
                           PACKAGEDISPINFO    *rgelt,
                           ULONG              *pceltFetched)
                           
{
    ULONG          cgot = 0, i, j;
    HRESULT        hr = S_OK;
    
    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;
    
    if (pceltFetched)
        (*pceltFetched) = 0;
    
    //
    // Clear up this structure in case our fetch fails --
    // we don't want callers freeing invalid memory
    //
    memset(rgelt, 0, sizeof(*rgelt) * celt);
    
    hr = FetchPackageInfo (
        m_hADs,
        m_hADsSearchHandle,
        m_dwAppFlags,
        m_dwQuerySpec,                   
        m_pPlatform,
        celt,
        &cgot,
        rgelt,
        &m_fFirst,
        &m_PolicyId,
        m_szGpoPath,
        m_pRsopUserToken);

    if (FAILED(hr)) 
    {
        //
        // Clear up this structure so that callers don't
        // try to free invalid memory when this fails
        //
        memset(rgelt, 0, sizeof(*rgelt) * celt);
        cgot = 0;

        if ( ( ( APPQUERY_RSOP_ARP == m_dwQuerySpec ) || ( APPQUERY_USERDISPLAY == m_dwQuerySpec ) ) &&
             ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) ) )
        {
            hr = S_FALSE;
        }
    }

    ERROR_ON_FAILURE(hr);

    m_dwPosition += cgot;
    
    if (pceltFetched)
        *pceltFetched = cgot;

    if (cgot != celt)
        hr = S_FALSE;
    else
        hr = S_OK;

    return hr;
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szPackageName);
}


HRESULT CEnumPackage::Skip(ULONG celt)
{
    ULONG               celtFetched = NULL, i;
    HRESULT             hr = S_OK;
    PACKAGEDISPINFO    *pIf = NULL;
    
    pIf = new PACKAGEDISPINFO[celt];
    hr = Next(celt, pIf, &celtFetched);
    for (i = 0; i < celtFetched; i++)
        ReleasePackageInfo(pIf+i);
    delete [] pIf;
    
    return hr;
}

HRESULT CEnumPackage::Reset()
{
    HRESULT    hr = S_OK;
    LPOLESTR*  ppszAttrs;
    DWORD      cAttrs;

    m_dwPosition = 0;
    m_fFirst = TRUE;

    // execute the search and keep the handle returned.

    if (m_hADsSearchHandle)
    {
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
        m_hADsSearchHandle = NULL;
    }

    ppszAttrs = GetAttributesFromQuerySpec(
        m_dwQuerySpec,
        &cAttrs);

    if ( ppszAttrs )
    {
        hr = ADSIExecuteSearch(
            m_hADs,
            m_szfilter,
            ppszAttrs,
            cAttrs,
            &m_hADsSearchHandle);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return RemapErrorCode(hr, m_szPackageName);
}

CEnumPackage::CEnumPackage(CServerContext* pServerContext, GUID PolicyId, LPOLESTR pszPolicyName, LPOLESTR pszClassStorePath, PRSOPTOKEN pRsopToken )
{
    m_dwRefCount = 0;
    m_fFirst = TRUE;
    m_szfilter = NULL;
    m_dwPosition = 0;
    m_dwAppFlags = 0;
    m_pPlatform = NULL;
    m_hADs = NULL;
    m_hADsSearchHandle = NULL;
    memcpy (&m_PolicyId, &PolicyId, sizeof(GUID));
    m_szPolicyName[0] = NULL;
    m_pRsopUserToken = pRsopToken;
    m_szPackageName[0] = L'\0';

    if (pszPolicyName)
    {
       (void) StringCchCopy (m_szPolicyName, _MAX_PATH, pszPolicyName);
    }

    if ( pServerContext )
    {
        HRESULT hrContext;

        hrContext = m_ServerContext.Initialize( pServerContext );

        //
        // If this fails, we will skip subsequent initialization as well,
        // and any operations with this object will fail because those
        // intiailziations are not complete
        //
        if ( FAILED(hrContext) )
        {
            return;
        }
    }

    //
    // Remember the path of the gpo from which we are originating
    // This information is needed for RSOP to determine where 
    // the package came from
    //
    // Note that if this fails, no operations on this object will succeed
    //
    m_szGpoPath = AllocGpoPathFromClassStorePath( pszClassStorePath );
}


HRESULT CEnumPackage::Initialize(
                                 WCHAR      *szPackageName,
                                 WCHAR      *szfilter,
                                 DWORD       dwAppFlags,
                                 BOOL        bPlanning,
                                 CSPLATFORM *pPlatform)
{
    HRESULT             hr = S_OK;
    ADS_SEARCHPREF_INFO SearchPrefs[3];
    LPOLESTR*           ppszAttrs;
    DWORD               cAttrs;
    LONG                lSecurityFlags;
    DWORD               cPrefs;

    cPrefs = 2;

    //
    // Be sure we're properly initialized
    //
    if ( ! m_szGpoPath )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Set the security of our communications based on the preference
    // of the caller
    //
    lSecurityFlags = GetDsFlags();

    m_szfilter = (LPOLESTR)CsMemAlloc (sizeof(WCHAR) * (wcslen(szfilter)+1));
    if (!m_szfilter)
        return E_OUTOFMEMORY;
    
    // copy the filters, package name, flags and locale.

    hr = StringCchCopy(m_szfilter, wcslen(szfilter)+1, szfilter);
    ERROR_ON_FAILURE(hr);
    
    hr = StringCchCopy(m_szPackageName, _MAX_PATH, szPackageName);
    ERROR_ON_FAILURE(hr);
    
    m_dwAppFlags = ClientSideFilterFromQuerySpec( dwAppFlags, bPlanning );
    m_dwQuerySpec = dwAppFlags;
        
    // open the package container.
    hr = DSServerOpenDSObject(&m_ServerContext, szPackageName, lSecurityFlags,
        &m_hADs);
    ERROR_ON_FAILURE(hr);
    
    // set the search preference.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = SEARCHPAGESIZE;

    //
    // For RSOP, we need to add an extra search pref to obtain the security
    // descriptor
    //
    if ( ( APPQUERY_RSOP_ARP == dwAppFlags ) ||
         ( APPQUERY_RSOP_LOGGING == dwAppFlags ) )
    {
        SearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SECURITY_MASK;
        SearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;

        //
        // Request everything but the SACL
        //
        SearchPrefs[2].vValue.Integer =
            OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION;

        cPrefs ++;
    }
    
    hr = ADSISetSearchPreference(m_hADs, SearchPrefs, cPrefs);
    ERROR_ON_FAILURE(hr);
    
    // copy platform
    if (pPlatform)
    {
        m_pPlatform = (CSPLATFORM *) CsMemAlloc(sizeof(CSPLATFORM));
        if (!m_pPlatform)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        memcpy (m_pPlatform, pPlatform, sizeof(CSPLATFORM));
    }

    ppszAttrs = GetAttributesFromQuerySpec(
        m_dwQuerySpec,
        &cAttrs);    

    // execute the search and keep the handle returned.
    hr = ADSIExecuteSearch(
        m_hADs,
        szfilter,
        ppszAttrs,
        cAttrs,
        &m_hADsSearchHandle);

Error_Cleanup:
    return RemapErrorCode(hr, m_szPackageName);
}

CEnumPackage::~CEnumPackage()
{
    if (m_hADsSearchHandle)
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
    
    if (m_hADs)
        ADSICloseDSObject(m_hADs);
    
    if (m_szfilter)
        CsMemFree(m_szfilter);
    
    if (m_pPlatform)
        CsMemFree(m_pPlatform);
    
    if (m_szGpoPath)
        CsMemFree(m_szGpoPath);
}

//--------------------------------------------------------------

CMergedEnumPackage::CMergedEnumPackage()
{
    m_pcsEnum = NULL;
    m_cEnum = 0;
    m_csnum = 0;
    m_dwRefCount = 0;
}

CMergedEnumPackage::~CMergedEnumPackage()
{
    ULONG    i;
    for (i = 0; i < m_cEnum; i++)
        m_pcsEnum[i]->Release();
    CsMemFree(m_pcsEnum);
}

HRESULT  __stdcall  CMergedEnumPackage::QueryInterface(REFIID riid,
                                            void  * * ppObject)
{
    *ppObject = NULL; //gd
    if ((riid==IID_IUnknown) || (riid==IID_IEnumPackage))
    {
        *ppObject=(IEnumPackage *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG  __stdcall  CMergedEnumPackage::AddRef()

{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}



ULONG  __stdcall  CMergedEnumPackage::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}


HRESULT  __stdcall CMergedEnumPackage::Next(
            ULONG             celt,
            PACKAGEDISPINFO   *rgelt,
            ULONG             *pceltFetched)
{
    ULONG count=0, total = 0;
    HRESULT hr;

    //
    // Clear everything
    //
    memset( rgelt, 0, sizeof(*rgelt) * celt );

    for (; m_csnum < m_cEnum; m_csnum++)
    {
        count = 0;
        
        hr = m_pcsEnum[m_csnum]->Next(celt, rgelt+total, &count);

        if (FAILED(hr))
        {
            //
            // Release everything on failure
            //
            ULONG iAllocated;

            for ( iAllocated = 0; iAllocated < total; iAllocated++ )
            {
                ReleasePackageInfo( rgelt+iAllocated );
            }

            return hr;
        }

        total += count;
        celt -= count;

        if (!celt)
            break;
    }
    if (pceltFetched)
        *pceltFetched = total;
    if (!celt)
        return S_OK;
    return S_FALSE;
}

HRESULT  __stdcall CMergedEnumPackage::Skip(
            ULONG             celt)
{
    PACKAGEDISPINFO *pPackageInfo = NULL;
    HRESULT          hr = S_OK;
    ULONG            cgot = 0, i;

    pPackageInfo = (PACKAGEDISPINFO *)CsMemAlloc(sizeof(PACKAGEDISPINFO)*celt);
    if (!pPackageInfo)
        return E_OUTOFMEMORY;

    hr = Next(celt, pPackageInfo, &cgot);

    for (i = 0; i < cgot; i++)
        ReleasePackageInfo(pPackageInfo+i);
    CsMemFree(pPackageInfo);
    
    return hr;
}

HRESULT  __stdcall CMergedEnumPackage::Reset()
{
    ULONG i;
    for (i = 0; ((i <= m_csnum) && (i < m_cEnum)); i++)
        m_pcsEnum[i]->Reset(); // ignoring all error values
    m_csnum = 0;
    return S_OK;
}

HRESULT  CMergedEnumPackage::Initialize(IEnumPackage **pcsEnum, ULONG cEnum)
{
    ULONG i;
    m_csnum = 0;
    m_pcsEnum = (IEnumPackage **)CsMemAlloc(sizeof(IEnumPackage *) * cEnum);
    if (!m_pcsEnum)
        return E_OUTOFMEMORY;
    for (i = 0; i < cEnum; i++)
        m_pcsEnum[i] = pcsEnum[i];
    m_cEnum = cEnum;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\cstore\user.cxx ===
//
//  Author: DebiM
//  Date:   September 1996
//
//  File:   csuser.cxx
//
//      Maintains a list of class containers per User SID.
//      Looks up this list for every IClassAccess call from OLE32/SCM.
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"
#include "cspath.hxx"
//
// Link list pointer for Class Containers Seen
//
extern CLASSCONTAINER *gpContainerHead;

//
// Link list pointer for User Profiles Seen
//
extern USERPROFILE *gpUserHead;


// Initialzed in InitializeClassStore at startup

extern CRITICAL_SECTION    ClassStoreBindList;

//-------------------------------------------------------------------------
//
// OpenUserRegKey
//
//  Opens a key under a user's HKEY_CLASSES_ROOT registry key.  On NT5
//  HKCR is equivalent to HKEY_USERS\{sid string}\Software\Classes.
//
//  A SID string is used to create
//  the proper registry key name to open.
//
//-------------------------------------------------------------------------
DWORD
OpenUserRegKey(
               IN  PSID        pSid,
               IN  WCHAR *     pwszSubKey,
               OUT HKEY *      phKey
               )
{
    UNICODE_STRING  UnicodeString;
    WCHAR *         pwszKey = NULL;
    DWORD           AllocSize;
    NTSTATUS        Status;
    
    UnicodeString.Length = UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = 0;
    
    Status = RtlConvertSidToUnicodeString(
        &UnicodeString,
        pSid,
        (BOOLEAN)TRUE // Allocate
        );
    
    //
    // Don't return a raw NT status code.  This is the only possible error
    // condition presuming our sid is valid.
    //
    if ( Status != STATUS_SUCCESS )
        return ERROR_OUTOFMEMORY;
    
    //
    // Your friendly reminder, unicode string length is in bytes and doesn't include
    // null terminator, if any.
    // Add byte for '\\' and end null.
    //
    AllocSize = UnicodeString.Length + ((1 + lstrlen(pwszSubKey) + 1) * sizeof(WCHAR));
    pwszKey = (WCHAR *) LocalAlloc( LPTR, AllocSize );
    if (NULL == pwszKey) 
    {
        RtlFreeUnicodeString( &UnicodeString );
        return ERROR_OUTOFMEMORY;
    }

    memcpy( pwszKey, UnicodeString.Buffer, UnicodeString.Length );
    pwszKey[UnicodeString.Length / 2] = L'\\';
    
    HRESULT hr ;

    hr = StringCchCopyW( &pwszKey[(UnicodeString.Length / 2) + 1], 
                         AllocSize - ((UnicodeString.Length / 2) + 1),
                         pwszSubKey );

    RtlFreeUnicodeString( &UnicodeString );

    if (FAILED(hr)) 
    {
        LocalFree(pwszKey);
        return HRESULT_CODE(hr);
    }
    
    Status = RegOpenKeyEx(
        HKEY_USERS,
        pwszKey,
        0,
        KEY_READ,
        phKey );

    LocalFree(pwszKey);
        
    return Status;
}

//
// GetUserSid
// ----------
//
//  Synopsis:       return the user SID of the caller.
//
//  Arguments:      &PSID       -       Where to store the caller's PSID
//
//  Returns:        HRESULT     -       S_OK if successful
//                                      E_FAIL otherwise
//
SID     LocalSystemSid = { SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };


HRESULT GetUserSid(PSID *ppUserSid, UINT *pCallType)
{
    BYTE            achBuffer[100];
    PTOKEN_USER     pUser = (PTOKEN_USER) &(achBuffer[0]);
    PSID            pSid;
    DWORD           dwBytesRequired;
    BOOL            fAllocatedBuffer = FALSE;
    HRESULT         hr = S_OK;
    HANDLE          hUserToken = NULL;
    BOOL            fImpersonated = TRUE;
    
    
    *pCallType = CS_CALL_USERPROCESS;
    
    // Initialize
    *ppUserSid = NULL;
    
    dwBytesRequired = 0;

    // Get caller's token while impersonating
    
    if (!OpenThreadToken(GetCurrentThread(),
        TOKEN_DUPLICATE | TOKEN_QUERY,
        TRUE,
        &hUserToken))
    {
        fImpersonated = FALSE;
        if (ERROR_NO_TOKEN != GetLastError())
            return HRESULT_FROM_WIN32(GetLastError());
        
        if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_DUPLICATE | TOKEN_QUERY,
            &hUserToken))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    
    if (SUCCEEDED(hr))
    {
        if (!GetTokenInformation(
            hUserToken,                // Handle
            TokenUser,                 // TokenInformationClass
            pUser,                     // TokenInformation
            sizeof(achBuffer),         // TokenInformationLength
            &dwBytesRequired           // ReturnLength
            ))
        {
            
            //
            // Need to handle the case of insufficient buffer size.
            //
            
            if (sizeof(achBuffer) >= dwBytesRequired)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            
            
            if (SUCCEEDED(hr))
            {
                //
                // Allocate space for the user info
                //
                
                pUser = (PTOKEN_USER) CsMemAlloc(dwBytesRequired);
                if (pUser == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            
            if (SUCCEEDED(hr))
            {
                fAllocatedBuffer = TRUE;
                
                //
                // Read in the UserInfo
                //
                
                
                if (!GetTokenInformation(
                    hUserToken,                // Handle
                    TokenUser,                 // TokenInformationClass
                    pUser,                     // TokenInformation
                    dwBytesRequired,           // TokenInformationLength
                    &dwBytesRequired           // ReturnLength
                    ))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
        
    }
    
    if (hUserToken)
    {
        CloseHandle( hUserToken );
        hUserToken = NULL;
    }
    
    if (SUCCEEDED(hr))
    {
        
        //
        // Distinguish between
        //            a) LOCAL_SYSTEM,
        //            b) Impersonated Call from a LOCAL_SYSTEM
        // and        c) In_proc call from a user process
        //
        // For case (c) make the SID null.
        //
        
        if (EqualSid(pUser->User.Sid, &LocalSystemSid))
        {
            *pCallType = CS_CALL_LOCALSYSTEM;
        }
        else
        {
            if (fImpersonated)
            {
                *pCallType = CS_CALL_IMPERSONATED;
            }
            else
            {
                *pCallType = CS_CALL_USERPROCESS;
            }
        }
        
        // Alloc buffer for copy of SID
        
        dwBytesRequired = GetLengthSid(pUser->User.Sid);
        *ppUserSid = CsMemAlloc(dwBytesRequired);
        if (*ppUserSid == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // Copy SID
            
            if (!CopySid(dwBytesRequired, *ppUserSid, pUser->User.Sid))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CsMemFree(*ppUserSid);
                *ppUserSid = NULL;
            }
        }
    }
    
    if (fAllocatedBuffer == TRUE)
    {
        CsMemFree(pUser);
    }
    
    return hr;
}

PCLASSCONTAINER
GetClassStore (LPOLESTR pszPath)
{
    
    PCLASSCONTAINER pCS = NULL;
    HRESULT hr;
    
    pCS = (CLASSCONTAINER *) CsMemAlloc (sizeof(CLASSCONTAINER));
    if (!pCS)
        return NULL;

    pCS->pszClassStorePath = (LPOLESTR)CsMemAlloc
        (sizeof(WCHAR) * (wcslen(pszPath)+1));
    if (!(pCS->pszClassStorePath))
    {
        CsMemFree(pCS);
        return NULL;
    }

    hr = StringCchCopy (pCS->pszClassStorePath, wcslen(pszPath)+1, pszPath);
    if (FAILED(hr)) 
    {
        CsMemFree(pCS->pszClassStorePath);
        CsMemFree(pCS);
        return NULL;
    }
    
    return pCS;
}


extern WCHAR pwszDebugPath [];
extern BOOL  fDebugPath;

//
// GetPerUserClassStore
// ---------------------
//
//  Synopsis:       Gets the ADT Class Store List from the
//                  per-user Registry.
//                  Returns error if none defined,
//
//  Arguments:
//                  [out] ppStoreList : where to store list of class container
//                                      serial numbers
//                  [out] pcStores    : where to store number of class containers
//
//  Returns:        S_OK,
//
//  History:        Changed by (DebiM)
//                  2/24/97
//                  return a NULL list of Class Stores when none defined.
//

HRESULT GetPerUserClassStore(
                             LPOLESTR  pszClassStorePath,
                             PSID      pSid,
                             UINT      CallType,
                             LPOLESTR  **ppStoreList,
                             DWORD     *pcStores)
                             
{
    LONG    lErrorCode;
    DWORD    dwDataLen = 0;
    DWORD    dwType;
    HKEY    hKey = NULL;
    HRESULT hr = S_OK;
    LPOLESTR pszPath, pszStart;
    LPOLESTR *ppszPath;
    LPWSTR pszPathList=NULL;
    
    *pcStores = 0;
    *ppStoreList = NULL;
    
    {
        switch (CallType)
        {
        case CS_CALL_LOCALSYSTEM :

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MACHINE));
            break;
            
        case CS_CALL_IMPERSONATED :
            
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_IMPERSONATED));
            break;
            
        case CS_CALL_USERPROCESS :

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_USER));
            break;

        default:
            return E_FAIL;
        }
        
        HRESULT hrCSPath;

        if ( ! pszClassStorePath )
        {
            hrCSPath = ReadClassStorePath(
                CallType != CS_CALL_LOCALSYSTEM ? pSid : NULL,
                &pszPathList);
        }
        else
        {
            hrCSPath = S_OK;

            pszPathList = pszClassStorePath;

            if ( ! *pszPathList )
            {
                hrCSPath = E_FAIL;
            }
        }

        if ( FAILED(hrCSPath) )
        {
            // treat as NULL list of Class Stores
            if ( ! pszClassStorePath )
            {
                delete [] pszPathList;
            }

            return S_OK;
        }
    }
 
    // counting the number of ';'s and the number of class stores.
    // assuming that it ends with a ;

    DWORD cTentativeStores = 0;

    for (pszPath = pszPathList, cTentativeStores = 0;
            (pszPath = wcschr(pszPath, L';'));)
    {
        ++(cTentativeStores); pszPath++;
    }
    
    ++(cTentativeStores);

    pszPath = pszPathList;
    
    ppszPath = *ppStoreList = (LPOLESTR *) CsMemAlloc
        (sizeof(LPOLESTR) * (cTentativeStores));
    
    if (*ppStoreList == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    memset (*ppStoreList, 0, sizeof(LPOLESTR) * (cTentativeStores));

    //
    // Parse the list to separate different class containers
    //

    while (*pszPath)
    {
        while (*pszPath == L' ')
            ++pszPath;
        pszStart = pszPath;
        
        if (!*pszPath)
            break;
        if (*pszPath == L';')
        {
            ++pszPath;
            continue;
        }
        
        while (*pszPath && (*pszPath != L';'))
            ++pszPath;
        
        //
        // got one. save it.
        //
        *ppszPath = (LPOLESTR) CsMemAlloc (sizeof(WCHAR) * (ULONG) (pszPath - pszStart + 1));

        if (!(*ppszPath))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        memcpy (*ppszPath, pszStart, sizeof (WCHAR) * (ULONG) (pszPath - pszStart));
        *((*ppszPath)+(pszPath - pszStart)) = NULL;

        (ppszPath)++;
        
        if (*pszPath == L';')
        {
            ++pszPath;
        }

        (*pcStores)++;

        if ((*pcStores) == cTentativeStores)
            break;
    }
    
    if (!pszClassStorePath)
    {
        delete [] pszPathList;
    }

    return S_OK;

Error_Cleanup:
    DWORD i;
    for (i = 0; i < (*pcStores); i++) 
    {
        if (ppszPath[i])
            CsMemFree(ppszPath[i]);
    }
    CsMemFree(ppszPath);
        
    ppStoreList = NULL;

    (*pcStores) = 0;
    if (pszPathList && !pszClassStorePath)
        CsMemFree(pszPathList);

    return hr;
}


//
// GetUserClassStores
// ------------------
//
//  Synopsis:       This routine reads the Class Store list and parses it.
//                  If it has prior knowledge it reurns the parsed list.
//  Arguments:
//                  [out]  pcStores: Number of Class Stores
//                  [out]  ppStoreIdList: Class Store Id List,
//
//  Returns:        S_OK
//                  May return a NULL list of Class Stores.
//
//


HRESULT GetUserClassStores(
                           LPOLESTR              pszClassStorePath,
                           PCLASSCONTAINER     **ppStoreList,
                           DWORD                *pcStores,
                           BOOL                 *pfCache,
                           PSID                 *ppUserSid)
{
    HRESULT          hr = S_OK;
    UINT             CallType;
    PCLASSCONTAINER *pList = NULL;
    DWORD            i;

    //
    // Get the SID of the calling process
    //
    
    hr = GetUserSid(ppUserSid, &CallType);

    if (FAILED(hr))
    {
        *ppUserSid = NULL;
        hr = S_OK;
    }

    *pfCache = (CallType == CS_CALL_IMPERSONATED);

    EnterCriticalSection (&ClassStoreBindList);
    
    //
    // Get the Class Store List
    //
    LPOLESTR *ppStoreNameList = NULL;
    
    hr = GetPerUserClassStore(
        pszClassStorePath,
        *ppUserSid, CallType, &ppStoreNameList, pcStores);
    
    //
    // Note that the above may return a NULL list of Class Stores
    //

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_STORE_COUNT,
              (*pcStores)));
    
    if (SUCCEEDED(hr)) 
    {
        *ppStoreList = pList = (PCLASSCONTAINER *)
                        CsMemAlloc (sizeof(PCLASSCONTAINER) * (*pcStores));

        if (!(*ppStoreList))
            hr = E_OUTOFMEMORY;
        else
            memset(pList, 0, sizeof(PCLASSCONTAINER) * (*pcStores));
    }

    if (SUCCEEDED(hr))
    {    
        for (i=0; i < (*pcStores); i++)
        {
            *pList = GetClassStore (ppStoreNameList[i]);
            if (!(*pList))
            {
                // free all the ones that have been allocated.
                DWORD j;
                for (j = 0; j < (*pcStores); j++)
                    if (*pList)
                    {
                        if ((*pList)->pszClassStorePath)
                            CsMemFree((*pList)->pszClassStorePath);
                        CsMemFree(*pList);    
                    }

                hr = E_OUTOFMEMORY;
                (*pcStores) = 0;
                break;
            }

            pList++;
        }
    }

    if (ppStoreNameList)
    {
        for (i=0; i < (*pcStores); ++i)
        {
            if (ppStoreNameList[i])
                CsMemFree (ppStoreNameList[i]);
        }
    }
    
    if (ppStoreNameList)
        CsMemFree (ppStoreNameList);
    
    LeaveCriticalSection (&ClassStoreBindList);
    
    return hr;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\idl\makefile.inc ===
#
# Build idl files.
#

!INCLUDE $(NTMAKEENV)\makefile.plt

APP= $(O)\app.h $(O)\app_c.c $(O)\app_s.c
CS= $(O)\cs.h

TARGETS= $(APP) $(CS)

INCLUDE= -I$(SDK_INC_PATH) -I$(CRT_INC_PATH)
CPP= -cpp_cmd "$(MIDL_CPP)" $(C_DEFINES) $(INCLUDE) -DMIDL_PASS -DUNICODE
MIDL_FLAGS= $(MIDL_FLAGS) -no_stamp -Oicf -oldnames -error all -robust -c_ext -ms_ext -out .\$(O)


$(APP) : app.idl app.acf
        midl $(CPP) $(MIDL_FLAGS) -cstub app_c.c -sstub app_s.c app.idl

$(CS) : cs.idl
        midl $(CPP) $(MIDL_FLAGS) -client none -server none -h cs.h -iid cs_i.c cs.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\sample\appapi.cxx ===
#include <windows.h>
#include <ole2.h>
#include <appmgmt.h>
#include <stdlib.h>
#include <stdio.h>


void
GuidToString(
    GUID &  Guid,
    PWCHAR  pwszGuid
    )
{
    wsprintf(
        pwszGuid,
        L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
        Guid.Data1,
        Guid.Data2,
        Guid.Data3,
        Guid.Data4[0],
        Guid.Data4[1],
        Guid.Data4[2],
        Guid.Data4[3],
        Guid.Data4[4],
        Guid.Data4[5],
        Guid.Data4[6],
        Guid.Data4[7]
        );
}

void
StringToGuid(
    PCHAR  pszGuid,
    GUID * pGuid
    )
{
    WCHAR wszGuid[256];

    wsprintf((WCHAR*)wszGuid, L"%S", pszGuid);
    CLSIDFromString(wszGuid, pGuid);
}


void __cdecl main(int argc, char** argv)
{
    LONG Error;
    PMANAGEDAPPLICATION rgApps;
    DWORD               dwApps;
    GUID                CategoryGuid;
    GUID*               pCategory = NULL;

    if (argc >= 2) {
        
        StringToGuid(argv[1], &CategoryGuid);

        pCategory = &CategoryGuid;

        printf("Listed apps will come from category %s\n", argv[1]);
        
    }

    Error = GetManagedApplications(
        pCategory,
        pCategory ? MANAGED_APPS_FROMCATEGORY : MANAGED_APPS_USERAPPLICATIONS,
        MANAGED_APPS_INFOLEVEL_DEFAULT,
        &dwApps,
        &rgApps);

    if (ERROR_SUCCESS == Error) {

        printf("GetManagedApplications SUCCEEDED\n");

        printf("Returned %d Apps\n", dwApps);

        for (DWORD dwApp = 0; dwApp < dwApps; dwApp ++)
        {
            WCHAR wszGuid[256];
            PMANAGEDAPPLICATION pApp;

            pApp = &(rgApps[dwApp]);

            printf("\nApp: %ls\n", rgApps[dwApp].pszPackageName);

            printf("Publisher: %ls\n", pApp->pszPublisher);

            printf("Revison: %d.%d build %d\n", pApp->dwVersionHi, pApp->dwVersionLo, pApp->dwRevision);

            printf("Support URL: %ls\n", rgApps[dwApp].pszSupportUrl);
            
            printf("GPO Name: %ls\n", rgApps[dwApp].pszPolicyName);

            GuidToString(rgApps[dwApp].GpoId, wszGuid);
            printf("GPO: %ls\n", wszGuid);
            fflush(stdin);

            GuidToString(rgApps[dwApp].ProductId, wszGuid);
            printf("Product: %ls\n", wszGuid);
            fflush(stdin);

            printf("App Path Type ");

            switch (rgApps[dwApp].dwPathType)
            {
            case MANAGED_APPTYPE_WINDOWSINSTALLER:
                printf("Darwin\n");
                break;
            case MANAGED_APPTYPE_SETUPEXE:
                printf("Crappy ZAW\n");
                break;
            case MANAGED_APPTYPE_UNSUPPORTED:
                printf("Unsupported\n");
                break;
            default:
                printf("INVALID\n");
            }

            fflush(stdin);
        }

        LocalFree(rgApps);

    } else {
        printf("GetManagedApplications returned %x\n", Error);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\app_server.c ===
#include <app_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\applist.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Applist.cxx
//
//*************************************************************

#include "appmgext.hxx"


//
// CAppList
//

CAppList::CAppList(
    CManagedAppProcessor * pManApp,
    CRsopAppContext *      pRsopContext ) :
    _pManApp( pManApp ),
    _bRsopInitialized( FALSE ),
    _hrRsopInit( E_FAIL ),
    _pRsopContext( pRsopContext )
{}


CAppList::~CAppList()
{
    CAppInfo * pAppInfo;

    Reset();

    while ( pAppInfo = (CAppInfo *) GetCurrentItem() )
    {
        MoveNext();

        pAppInfo->Remove();
        delete pAppInfo;
    }

    ResetEnd();
}

DWORD
CAppList::SetAppActions()
{
    CAppInfo *  pAppInfo;
    DWORD       Pass;
    DWORD       Status;

    for ( Pass = 0; Pass <= 5; Pass++ )
    {
        Reset();

        for (;;)
        {
            pAppInfo = (CAppInfo *) GetCurrentItem();

            if ( ! pAppInfo )
                break;

            //
            // Apps get applied from lowest priority to highest priority.
            // Thus if one app fails to apply there is nothing of interest that
            // we can really do.  We don't know which lower priority apps
            // may need to be "undone", and we shouldn't abort and thereby
            // prevent higher priority apps from being processed.
            //
            // Therefore, other than logging events, we ignore any errors in
            // the processing and continuing applying all apps.
            //

            switch ( Pass )
            {
            case 0 :
                Status = pAppInfo->InitializePass0();
                if ( Status != ERROR_SUCCESS )
                    return Status;
                break;
            case 1 :
                pAppInfo->SetActionPass1();
                break;
            case 2 :
                pAppInfo->SetActionPass2();
                break;
            case 3 :
                pAppInfo->SetActionPass3();
                break;
            case 4 :
                pAppInfo->SetActionPass4();
                break;
            case 5 :
                if ( pAppInfo->_Status != ERROR_SUCCESS )
                    return pAppInfo->_Status;
                break;
            }

            MoveNext();
        }

        ResetEnd();
    }

    return ERROR_SUCCESS;
}

DWORD
CAppList::ProcessPolicy()
{
    CAppInfo *  pAppInfo;
    DWORD       Pass;
    DWORD       Status;
    DWORD       FinalStatus;
    HRESULT     hr;

    FinalStatus = ERROR_SUCCESS;

    Status = _pManApp->Impersonate();

    if ( ERROR_SUCCESS == Status )
        Status = SetAppActions();

    if ( Status != ERROR_SUCCESS )
    {
        //
        // Ensure that we log an event in this case so that RSoP
        // failed view at the extension level has enough information
        // to allow the administrator to diagnose the problem
        //
        gpEvents->PolicyAbort();

        _pManApp->Revert();

        _pManApp->GetRsopContext()->SetPolicyAborted( Status );

        return Status;
    }

    if ( _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
    {
        return Status;
    }

    for ( Pass = 0; Pass <= 2; Pass++ )
    {
        for ( Reset();;MoveNext() )
        {
            pAppInfo = (CAppInfo *) GetCurrentItem();

            if ( ! pAppInfo )
                break;

            switch ( Pass )
            {
            case 0 :
                Status = pAppInfo->ProcessUnapplyActions();
                break;
            case 1 :
                Status = pAppInfo->ProcessApplyActions();
                break;
            case 2 :
                if ( _pRsopContext->IsRsopEnabled() && _pRsopContext->IsDiagnosticModeEnabled() )
                    Status = pAppInfo->ProcessTransformConflicts();
                break;
            }

            if ( (FinalStatus == ERROR_SUCCESS) && (Status != ERROR_SUCCESS) )
                FinalStatus = Status;

            //
            // If we are returning an error of some sort, we should force a synchronous
            // refresh if we are not already returning the error to request one.  This is 
            // needed because some errors require a sync refresh to fix (such as
            // install / uninstall errors), and gp will not give us a sync refresh
            // unless we ask for it. 
            //
            if ( ! _pManApp->NoChanges() &&
                 ( ERROR_SUCCESS != FinalStatus ) &&
                 ( ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED != FinalStatus ) )
            {
                _pManApp->Revert();

                (void) ForceSynchronousRefresh( _pManApp->UserToken() );

                _pManApp->Impersonate();
            }
        }

        ResetEnd();
    }

    _pManApp->Revert();

    return FinalStatus;
}

DWORD
CAppList::ProcessARPList()
{
    DWORD   Status;

    Status = _pManApp->Impersonate();

    if ( ERROR_SUCCESS == Status )
        Status = SetAppActions();

    _pManApp->Revert();

    return Status;
}

DWORD
CAppList::Count(
    DWORD   Flags
    )
{
    CAppInfo *  pAppInfo;
    DWORD       Count;

    Count = 0;

    Reset();

    for ( ;; )
    {
        pAppInfo = (CAppInfo *) GetCurrentItem();

        if ( ! pAppInfo )
            break;

        if ( pAppInfo->_ActFlags & Flags )
            Count++;

        MoveNext();
    }

    ResetEnd();

    return Count;
}

CAppInfo *
CAppList::Find(
    GUID    DeploymentId
    )
{
    CAppInfo *  pAppInfo;

    Reset();

    for (;;)
    {
        pAppInfo = (CAppInfo *) GetCurrentItem();

        if ( ! pAppInfo )
            break;

        if ( memcmp( &pAppInfo->_DeploymentId, &DeploymentId, sizeof(GUID) ) == 0 )
            break;

        MoveNext();
    }

    ResetEnd();

    return pAppInfo;
}

HRESULT
CAppList::WriteLog( DWORD dwFilter )
{
    CAppInfo *  pAppInfo;
    DWORD       Status;
    HRESULT     hr;

    hr = InitRsopLog();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( ( CRsopAppContext::POLICY_REFRESH == _pRsopContext->GetContext() ) &&
         _pRsopContext->IsDiagnosticModeEnabled() && ! _pManApp->IsRemovingPolicies() )
    {
        hr = PurgeEntries();
    }

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    Reset();

    for (;;)
    {
        BOOL bLogApp;

        pAppInfo = (CAppInfo *) GetCurrentItem();

        if ( ! pAppInfo )
            break;

        //
        // Check to see if this app is applied to the user and should be logged
        //
        bLogApp = ( RSOP_FILTER_ALL == dwFilter ) ||
          ( ( ACTION_UNINSTALL == pAppInfo->Action() ) || ( ACTION_ORPHAN == pAppInfo->Action() ) );

        //
        // Check to see if this app would have been in the ARP list if not for the
        // fact that the administrator chose to conceal it
        //
        if ( CRsopAppContext::ARPLIST == _pRsopContext->GetContext() )
        {
            if ( ( ACTION_NONE == pAppInfo->Action() ) &&
                 ( (pAppInfo->_ActFlags & (ACTFLG_Assigned | ACTFLG_Published) ) && 
                   !(pAppInfo->_ActFlags & ACTFLG_UserInstall) ) )
            {
                bLogApp = TRUE;

                pAppInfo->SetAction(
                    ACTION_INSTALL,
                    0,
                    NULL);
            }
        }

        if ( bLogApp )
        {
            hr = WriteAppToRsopLog( pAppInfo );

            if (FAILED(hr))
            {
                break;
            }
        }

        MoveNext();
    }

    ResetEnd();

    return hr;
}

HRESULT
CAppList::WriteAppToRsopLog( CAppInfo* pAppInfo )
{
    HRESULT   hr;
    CConflict WinningConflict( pAppInfo );

    //
    // If this is a rolled-back upgrade, the instance
    // is already written and we do not need to do anything
    //
    if ( pAppInfo->_bRollback )
    {
        return S_OK;
    }

    //
    // Do not log entries for applications that will be removed
    // in the next sync refresh
    //
    if ( ( ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == pAppInfo->_Status ) &&
         ( ACTION_APPLY != pAppInfo->_Action ) && ( ACTION_INSTALL != pAppInfo->_Action ) &&
         ( ACTION_REINSTALL != pAppInfo->_Action ) )
    {
        return S_OK;
    }

    hr = InitRsopLog();

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // If this app failed to be applied, we must log it anyway
    //
    if ( pAppInfo->_StatusList.GetCurrentItem() )
    {
        if ( ACTION_NONE == pAppInfo->Action() )
        {
            pAppInfo->SetAction(
                ACTION_APPLY,
                pAppInfo->_dwApplyCause,
                NULL);
        }
    }
    else if ( _pRsopContext->HasPolicyAborted() )
    {
        //
        // If policy aborted before even trying to apply the app
        // then we shouldn't log this setting unless it has a failure -- 
        // apps without failures haven't been applied, and apps with
        // failures are known to not apply, so we can safely log those
        //
        return S_OK;
    }

    switch ( pAppInfo->GetRsopEntryType() )
    {
    case APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE:

        WCHAR* wszCriteria;
       
        wszCriteria = pAppInfo->GetRsopAppCriteria();

        hr = ClearLog( wszCriteria, TRUE );

        delete [] wszCriteria;

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // In planning mode, we only apply published apps if they upgrade
        // an assigned app
        //
        if ( _pRsopContext->IsPlanningModeEnabled() )
        {
            if ( ( ACTFLG_Published & pAppInfo->_ActFlags ) && ! pAppInfo->_bSupersedesAssigned )
            {
                break;
            }
        }
        
        //
        // Fall through to the next case
        //

    case APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM:

        //
        // In the arplist case, we require the action
        // set to ACTION_INSTALL in order to log the app
        //
        if ( _pManApp->ARPList() && 
             ( ACTION_INSTALL != pAppInfo->Action() ) )
        {
            break;
        }

        //
        // If this is a winning application, create a new entry for the winner
        // and then log its conflicts
        //
        if ( ! pAppInfo->IsSuperseded() )
        {
            WCHAR wszDeploymentId[ MAX_SZGUID_LEN ];

            pAppInfo->GetDeploymentId( wszDeploymentId);

            hr = WinningConflict.SetConflictId( wszDeploymentId );

            if ( SUCCEEDED(hr) )
            {
                hr = WriteNewRecord ( &WinningConflict );
            }

            if (FAILED(hr))
            {
                DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_WRITE_FAIL, hr));
                hr = S_OK;
            }

            if (SUCCEEDED(hr))
            {
                (void) WinningConflict.LogFailure();
            }

            (void) WriteConflicts ( pAppInfo );
        }
        break;

    case APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE:

        BOOL        bDeleteInstalledEntry;
        CAppStatus* pCurrentStatus;

        bDeleteInstalledEntry = TRUE;

        pCurrentStatus = (CAppStatus*) pAppInfo->_StatusList.GetCurrentItem();

        //
        // Do not delete the installed entry if it was never 
        // successfully removed
        //
        if ( pCurrentStatus && 
             ( RSOPFailed == pCurrentStatus->_SettingStatus ) )
        {
            bDeleteInstalledEntry = FALSE;
        }
        
        //
        // For removed applications, we do not create a new entry,
        // just change the existing entry to indicate that
        // it has been removed
        //
        hr = MarkRSOPEntryAsRemoved(
            pAppInfo,
            bDeleteInstalledEntry);

        if ( SUCCEEDED( hr ) )
        {
            pAppInfo->_bRemovalLogged = TRUE;
        }

        break;

    default:
        break;
    }

    return hr;
}


HRESULT
CAppList::WriteConflicts( CAppInfo* pAppInfo )
{
    HRESULT       hr;
    CConflictList Conflicts;
    CConflict*    pCurrentConflict;

    hr = pAppInfo->GetConflictTable()->GenerateResultantConflictList( &Conflicts );

    if (SUCCEEDED(hr))
    {
        Conflicts.Reset();

        while ( pCurrentConflict = (CConflict*) Conflicts.GetCurrentItem() )
        {
            WCHAR wszDeploymentId[ MAX_SZGUID_LEN ];

            pAppInfo->GetDeploymentId( wszDeploymentId);

            hr = pCurrentConflict->SetConflictId( wszDeploymentId );

            if ( FAILED(hr) )
            {
                break;
            }

            HRESULT hrWrite;

            if ( ! pCurrentConflict->GetApp()->IsLocal() )
            {
                hrWrite = WriteNewRecord( pCurrentConflict );
            }
            else
            {
                hrWrite = OpenExistingRecord( pCurrentConflict );

                if ( SUCCEEDED( hrWrite ) )
                {
                    hrWrite = pCurrentConflict->Write();
                }

                if ( SUCCEEDED( hrWrite ) )
                {
                    hrWrite = pCurrentConflict->GetApp()->ClearRemovalProperties( pCurrentConflict );
                }

                if ( SUCCEEDED( hrWrite ) )
                {
                    hrWrite = CommitRecord( pCurrentConflict );
                }
            }

            if ( SUCCEEDED( hrWrite ) )
            {
                (void) DeleteStatusRecords( pCurrentConflict );
            }

            if (FAILED(hrWrite))
            {
                DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_WRITE_FAIL, hrWrite));
            }

            Conflicts.MoveNext();
        }
    }

    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, IDS_RSOP_CONFLICTS_FAIL, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, hr));
    }

    return hr;
}


HRESULT CAppList::InitRsopLog()
{
    if ( _bRsopInitialized )
    {
        return _hrRsopInit;
    }

    _bRsopInitialized = TRUE;

    _hrRsopInit = InitLog(
        _pRsopContext,
        RSOP_MANAGED_SOFTWARE_APPLICATION);

    if (FAILED(_hrRsopInit))
    {
        DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_INIT_FAIL, _hrRsopInit));
        return _hrRsopInit;
    }

    if ( _pRsopContext->Transition() )
    {
        _hrRsopInit = ClearLog( NULL, TRUE );
    }
    else if ( ! _pRsopContext->ForcedRefresh() )
    {
        BOOL bPolicy;

        bPolicy = FALSE;

        //
        // In the forced refresh case, we need to preserve the
        // state of policy since it actually has not changed,
        // so we skip the purge below
        //

        //
        // In the policy refresh case, we need to clear everything
        // that does not apply to the user as well as removal entries
        //
        switch ( _pRsopContext->GetContext() )
        {
        case CRsopAppContext::POLICY_REFRESH:

            bPolicy = TRUE;

            if ( ! _pRsopContext->PurgeRemovalEntries() )
            {
                break;
            }

            _pRsopContext->ResetRemovalPurge();

            //
            // Purposefully fall through
            //

        case CRsopAppContext::ARPLIST:

            _hrRsopInit = ClearLog( GetRsopListCriteria(), bPolicy );

            if ( FAILED( _hrRsopInit ) )
            {
                DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_INIT_FAIL, _hrRsopInit));
            }
            break;
            
        default:
            break;
        }
    }

    return _hrRsopInit;
}

HRESULT
CAppList::PurgeEntries()
{
    HRESULT hr;

    hr = GetEnum( RSOP_PURGE_QUERY );

    if ( SUCCEEDED(hr) )
    {
        HRESULT       hrEnum;

        hrEnum = S_OK;

        for (;;)
        {
            CPolicyRecord CurrentApplication;
            LONG          EntryType;

            hrEnum = GetNextRecord( &CurrentApplication );

            if ( S_OK != hrEnum )
            {
                if ( FAILED(hrEnum) )
                {
                    hr = hrEnum;
                }

                break;
            }

            GUID      DeploymentId;
            WCHAR     wszDeploymentId[ MAX_SZGUID_LEN ];
            LONG      cchSize;
            CAppInfo* pAppliedApp;

            cchSize = sizeof( wszDeploymentId ) / sizeof( *wszDeploymentId );

            hrEnum = CurrentApplication.GetValue(
                RSOP_ATTRIBUTE_ID,
                wszDeploymentId,
                &cchSize);

            if ( FAILED( hrEnum ) )
            {
                break;
            }

            if ( S_OK != hrEnum )
            {
                break;
            }

            StringToGuid( wszDeploymentId, &DeploymentId );
            
            pAppliedApp = Find( DeploymentId );
            
            if ( pAppliedApp )
            {
                if ( pAppliedApp->_State & ( APPSTATE_ASSIGNED | APPSTATE_PUBLISHED ) )
                {
                    if ( ACTFLG_Published & pAppliedApp->_ActFlags )
                    {
                        (void) GetUserApplyCause(
                            &CurrentApplication,
                            pAppliedApp);
                    }

                    continue;
                }
                     
                if ( ( ACTION_NONE != pAppliedApp->Action() ) ||
                     pAppliedApp->_bRollback )
                {
                    continue;
                }
            }

            hrEnum = DeleteRecord( &CurrentApplication, TRUE );
            
            if ( FAILED( hrEnum ) )
            {
                hr = hrEnum;
            }
        }

        FreeEnum();
    }

    return hr;
}

HRESULT
CAppList::GetUserApplyCause(
    CPolicyRecord* pRecord,
    CAppInfo*      pAppInfo
    )
{
    HRESULT hr;
    LONG    ApplyCause;

    hr = pRecord->GetValue( 
        APP_ATTRIBUTE_APPLY_CAUSE,
        &ApplyCause);

    if ( SUCCEEDED( hr) && 
         ( APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE != ApplyCause ) &&
         ! pAppInfo->_wszDemandProp )
    {
        pAppInfo->_dwUserApplyCause = ApplyCause;

        switch ( ApplyCause )
        {
        case APP_ATTRIBUTE_APPLYCAUSE_VALUE_FILEEXT:
            pAppInfo->_wszDemandProp = APP_ATTRIBUTE_ONDEMAND_FILEEXT;
            break;

        case APP_ATTRIBUTE_APPLYCAUSE_VALUE_CLSID:
            pAppInfo->_wszDemandProp = APP_ATTRIBUTE_ONDEMAND_CLSID;
            break;

        case APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROGID:
            pAppInfo->_wszDemandProp = APP_ATTRIBUTE_ONDEMAND_PROGID;
            break;

        default:
            pAppInfo->_wszDemandProp = NULL;
            break;
        }

        if ( pAppInfo->_wszDemandProp && ! pAppInfo->_wszDemandSpec )
        {
            LONG cchSize;

            cchSize = 0;

            hr = pRecord->GetValue(
                pAppInfo->_wszDemandProp,
                pAppInfo->_wszDemandSpec,
                &cchSize);

            if ( S_FALSE == hr )
            {
                pAppInfo->_wszDemandSpec = new WCHAR [ cchSize ];

                if ( pAppInfo->_wszDemandSpec )
                {
                    hr = pRecord->GetValue(
                        pAppInfo->_wszDemandProp,
                        pAppInfo->_wszDemandSpec,
                        &cchSize);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

    }

    return hr;
}


HRESULT CAppList::MarkRSOPEntryAsRemoved(
    CAppInfo* pAppInfo,
    BOOL      bRemoveInstances)
{
    HRESULT hr;
    WCHAR*  wszRemovalCriteria;

    wszRemovalCriteria = NULL;

    DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_WRITE_INFO, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));

    //
    // If this is a removed app that was reapplied as part of upgrade rollback,
    // we do not want to remove the instances
    //
    if ( pAppInfo->_bRollback )
    {
        bRemoveInstances = FALSE;
    }

    //
    // Set up this list's rsop enumerator to enumerate instances of this application
    //
    hr = FindRsopAppEntry( 
        pAppInfo,
        &wszRemovalCriteria );

    if ( SUCCEEDED( hr ) )
    {
        for (;;)
        {
            CConflict RemovedApplication( pAppInfo );
            LONG      Precedence;

            hr = GetNextRecord( &RemovedApplication );
            
            if ( S_OK != hr )
            {
                break;
            }

            hr = RemovedApplication.GetValue( 
                RSOP_ATTRIBUTE_PRECEDENCE,
                &Precedence);

            if ( FAILED (hr) )
            {
                break;
            }

            //
            // If this is a removal of an assigned application, then we should
            // change the apply cause of the installed application to assigned
            // rather than user
            //
            if ( 1 == Precedence )
            {
                if ( ( pAppInfo->_State & APPSTATE_ASSIGNED ) &&
                     ( CRsopAppContext::REMOVAL == _pRsopContext->GetContext() ) )
                {
                    LONG CurrentApplyCause;
                    LONG CurrentEligibility;

                    //
                    // First, we must find out the current apply cause so
                    // that we can propagate that to the removal entry
                    //
                    hr = RemovedApplication.GetValue( 
                        APP_ATTRIBUTE_APPLY_CAUSE,
                        &CurrentApplyCause);

                    if ( SUCCEEDED(hr) )
                    {
                        hr = RemovedApplication.GetValue( 
                            APP_ATTRIBUTE_ELIGIBILITY,
                            &CurrentEligibility);
                    }
                
                    if ( SUCCEEDED(hr) ) 
                    {
                        //
                        // Now set the current apply cause to assigned
                        //
                        hr = RemovedApplication.SetValue(
                            APP_ATTRIBUTE_APPLY_CAUSE,
                            APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPLY_CAUSE, hr );

                        if ( SUCCEEDED(hr) )
                        {
                            //
                            // Also set the eligibility to assigned
                            //
                            hr = RemovedApplication.SetValue(
                                APP_ATTRIBUTE_ELIGIBILITY,
                                APP_ATTRIBUTE_ELIGIBILITY_VALUE_ASSIGNED);

                            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ELIGIBILITY, hr );
                        }

                        //
                        // Clear out any attributes that should not be set for applications
                        // applied due to assignment
                        //
                        hr = RemovedApplication.ClearValue(
                            APP_ATTRIBUTE_ONDEMAND_FILEEXT);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_FILEEXT, hr )

                        hr = RemovedApplication.ClearValue(
                            APP_ATTRIBUTE_ONDEMAND_CLSID);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_CLSID, hr )

                        hr = RemovedApplication.ClearValue(
                            APP_ATTRIBUTE_ONDEMAND_PROGID);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_PROGID, hr )
                    }

                    //
                    // Commit the record for the installed application
                    //
                    if ( SUCCEEDED(hr) )
                    {
                        hr = CommitRecord( &RemovedApplication );
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Now set the removal entry's install cause to
                        // that of the original install
                        //
                        hr = RemovedApplication.SetValue(
                            APP_ATTRIBUTE_APPLY_CAUSE,
                            CurrentApplyCause);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPLY_CAUSE, hr );

                        if ( SUCCEEDED(hr) )
                        {
                            //
                            // Also set the eligibility to assigned
                            //
                            hr = RemovedApplication.SetValue(
                                APP_ATTRIBUTE_ELIGIBILITY,
                                CurrentEligibility);
                            
                            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ELIGIBILITY, hr );
                        }
                    }
                }

                //
                // We must mark the highest precedence entry
                // (the currently applied entry) as removed --
                // see if this has the highest precedence (1)
                //
                if ( bRemoveInstances &&
                     ( ( pAppInfo->_State & APPSTATE_PUBLISHED ) || 
                       ( CRsopAppContext::POLICY_REFRESH != _pRsopContext->GetContext() ) ) )
                {
                    hr = DeleteRecord ( &RemovedApplication, TRUE );
                }
                else 
                {
                    hr = DeleteStatusRecords( &RemovedApplication );
                }
                
                if ( SUCCEEDED( hr ) )
                {
                    hr = RemovedApplication.SetValue(
                        APP_ATTRIBUTE_ENTRYTYPE,
                        APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE);

                    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ENTRYTYPE, hr );
                }

                if ( SUCCEEDED( hr ) )
                {
                    hr = RemovedApplication.SetValue(
                        RSOP_ATTRIBUTE_PRECEDENCE, 
                        0L);

                    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_PRECEDENCE, hr );
                }
                
                if ( SUCCEEDED( hr ) )
                {
                    hr = pAppInfo->WriteRemovalProperties( &RemovedApplication );
                }

                if ( SUCCEEDED( hr ) )
                {
                    hr = CommitRecord( &RemovedApplication );

                    if ( SUCCEEDED(hr) )
                    {
                        (void) DeleteStatusRecords( &RemovedApplication );
                        (void) RemovedApplication.LogFailure();
                    }
                }
            }
            else
            {
                hr = DeleteRecord ( &RemovedApplication, TRUE );
            }

            if ( FAILED(hr) )
            {
                break;
            }
        }
    }

    FreeEnum();

    if ( bRemoveInstances &&
         SUCCEEDED(hr) )
    {
        //
        // We've already found the highest precedence entry
        // and copied it as a removal entry --
        // if the caller specified to remove the original
        // instances for this app's conflict id, do so
        //
        hr = ClearLog( wszRemovalCriteria, TRUE );
    }

    delete [] wszRemovalCriteria;

    return hr;
}


HRESULT
CAppList::FindRsopAppEntry( 
    CAppInfo* pAppInfo,
    WCHAR**   ppwszAppCriteria )
{
    HRESULT hr;

    hr = InitRsopLog();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = E_OUTOFMEMORY;

    *ppwszAppCriteria = pAppInfo->GetRsopAppCriteria();

    if ( *ppwszAppCriteria )
    {
        hr = GetEnum( *ppwszAppCriteria );
    }

    if ( FAILED(hr) )
    {
        delete [] *ppwszAppCriteria;
        *ppwszAppCriteria = NULL;
    }

    return hr;
}

WCHAR*
CAppList::GetRsopListCriteria()
{
    WCHAR* wszCriteria;

    switch ( _pRsopContext->GetContext() )
    {
    case CRsopAppContext::ARPLIST:
        wszCriteria = RSOP_ARP_CONTEXT_QUERY;
        break;

    case CRsopAppContext::POLICY_REFRESH:
        wszCriteria = RSOP_POLICY_CONTEXT_QUERY;
        break;

    default:
        ASSERT(FALSE);
        return NULL;
    }

    return wszCriteria;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\appschem.h ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998 - 2000
//  All rights reserved
//
//  appschem.h
//
//  This file contains declarations related to the wmi schema
//  for software management policy objects
//
//*************************************************************

//
// WMI class names for the software management classes
//

#define RSOP_MANAGED_SOFTWARE_APPLICATION L"RSOP_ApplicationManagementPolicySetting"
#define RSOP_MANAGED_SOFTWARE_CATEGORY    L"RSOP_ApplicationManagementCategory"


//
// Attribute names for the RSOP_ApplicationManagementPolicyObject class
//


// Describes the contents of the instance
#define APP_ATTRIBUTE_ENTRYTYPE                   L"EntryType"
//
// Enumerated values for EntryType
//
#define APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE 1L
#define APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE   2L
#define APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM      3L


// A unique id for this deployed package
#define APP_ATTRIBUTE_APPID                       L"ApplicationId"

// This describes the type of the package to be installed
#define APP_ATTRIBUTE_PACKAGETYPE                 L"PackageType"
//
// Enumerated values for PackageType
//
#define APP_ATTRIBUTE_PACKAGETYPE_VALUE_WIN_INSTALLER   1L
#define APP_ATTRIBUTE_PACKAGETYPE_VALUE_ZAP             2L

// Windows Installer Product ID.
#define APP_ATTRIBUTE_PRODUCT_ID                  L"ProductId"

// Name of the vendor of the software    
#define APP_ATTRIBUTE_PUBLISHER                   L"Publisher"

// PackageLocation
#define APP_ATTRIBUTE_PACKAGELOCATION             L"PackageLocation"

// Script File.
#define APP_ATTRIBUTE_SCRIPTFILE                  L"ScriptFile"

// SupportUrl
#define APP_ATTRIBUTE_SUPPORTURL                  L"SupportURL"

// Categories of applications in Add/Remove Programs
#define APP_ATTRIBUTE_CATEGORYLIST                L"Categories"

// The reason this application defeated another 
#define APP_ATTRIBUTE_PRECEDENCE_REASON           L"PrecedenceReason"
//
// Enumerated values for PrecedenceReason
//
#define APP_ATTRIBUTE_REASON_VALUE_LANGUAGE         1L
#define APP_ATTRIBUTE_REASON_VALUE_PRODUCT          2L
#define APP_ATTRIBUTE_REASON_VALUE_UPGRADE          4L
#define APP_ATTRIBUTE_REASON_VALUE_WINNING          5L
#define APP_ATTRIBUTE_REASON_VALUE_NONFORCEDUPGRADE 6L

// Minor version number of the application
#define APP_ATTRIBUTE_VERSIONLO                   L"VersionNumberLo"

// Major version number of the application
#define APP_ATTRIBUTE_VERSIONHI                   L"VersionNumberHi"

// The number of times the app has been redeployed
#define APP_ATTRIBUTE_REDEPLOYCOUNT               L"RedeployCount"

// The last modification time of this application by the administrator
#define APP_ATTRIBUTE_MODIFYTIME                  L"DeploymentLastModifyTime"


// Security Descriptor
#define APP_ATTRIBUTE_SECURITY_DESCRIPTOR         L"SecurityDescriptor"

// Machine architectures
#define APP_ATTRIBUTE_ARCHITECTURES               L"MachineArchitectures"

// language id from the package
#define APP_ATTRIBUTE_LANGUAGEID                  L"LanguageId"


// Package Deployment Type
#define APP_ATTRIBUTE_DEPLOY_TYPE                 L"DeploymentType"
//
// Enumerated values for the DeploymentType attribute
//
#define APP_ATTRIBUTE_DEPLOY_VALUE_ASSIGNED  1L
#define APP_ATTRIBUTE_DEPLOY_VALUE_PUBLISHED 2L

// Type of assignment: none, advertised, or default install
#define APP_ATTRIBUTE_ASSIGNMENT_TYPE             L"AssignmentType"
//
// Enumerated values for the AssignmentType attribute
//
#define APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_NOTASSIGNED  1L
#define APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_STANDARD     2L
#define APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_INSTALL      3L

// Installation UI
#define APP_ATTRIBUTE_INSTALLATIONUI              L"InstallationUI"
//
// Enumerated values for the InstallatuionUI attribute
//
#define APP_ATTRIBUTE_INSTALLATIONUI_VALUE_BASIC   1L
#define APP_ATTRIBUTE_INSTALLATIONUI_VALUE_MAXIMUM 2L

// Installable on demand
#define APP_ATTRIBUTE_ONDEMAND                    L"DemandInstallable"

// Behavior to take on loss of scope
#define APP_ATTRIBUTE_LOSSOFSCOPEACTION           L"LossOfScopeAction"
//
// Enumerated values for the LossOfScopeAction
//
#define APP_ATTRIBUTE_SCOPELOSS_UNINSTALL 1L
#define APP_ATTRIBUTE_SCOPELOSS_ORPHAN    2L

// Whether this application uninstalls unmanaged versions
#define APP_ATTRIBUTE_UNINSTALL_UNMANAGED         L"UninstallUnmanaged"

// Whethier this x86 package is available on Win64
#define APP_ATTRIBUTE_X86OnWin64                  L"AllowX86OnIA64"

// If TRUE, this application may be displayed in ARP
#define APP_ATTRIBUTE_DISPLAYINARP                L"DisplayInARP"

// Ignore language when deploying this package
#define APP_ATTRIBUTE_IGNORELANGUAGE              L"IgnoreLanguage"

// Chained list of applications that were upgraded
#define APP_ATTRIBUTE_TRANSFORMLIST               L"Transforms"


// Packages that this package will upgrade
#define APP_ATTRIBUTE_UPGRADEABLE_APPLICATIONS    L"UpgradeableApplications"
// Packages that are upgrading this package
#define APP_ATTRIBUTE_REPLACEABLE_APPLICATIONS    L"ReplaceableApplications"

// Whether this application is a required upgrade
#define APP_ATTRIBUTE_UPGRADE_SETTINGS_MANDATORY  L"UpgradeSettingsMandatory"


// Apply Cause
#define APP_ATTRIBUTE_APPLY_CAUSE                 L"ApplyCause"
//
// Enumerated Values for ApplyCause
//
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE     0L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED 1L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_USER     2L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE  3L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_FILEEXT  4L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_CLSID    5L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_UPGRADE  6L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROGID   7L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_REDEPLOY 8L

// Eligibility
#define APP_ATTRIBUTE_ELIGIBILITY                 L"Eligibility"
//
// Enumerated values for Eligibility
//
#define APP_ATTRIBUTE_ELIGIBILITY_VALUE_ASSIGNED 1L
#define APP_ATTRIBUTE_ELIGIBILITY_VALUE_APPLIED  2L
#define APP_ATTRIBUTE_ELIGIBILITY_VALUE_UPGRADES 3L
#define APP_ATTRIBUTE_ELIGIBILITY_VALUE_PLANNING 4L


// An enumerated type that describes the rule used to choose package
#define APP_ATTRIBUTE_LANGMATCH                   L"LanguageMatch"
//
// Enumerated values for the LanguageMatch attribute
//
#define APP_ATTRIBUTE_LANGMATCH_VALUE_SYSLOCALE 1L
#define APP_ATTRIBUTE_LANGMATCH_VALUE_ENGLISH   2L
#define APP_ATTRIBUTE_LANGMATCH_VALUE_IGNORE    3L
#define APP_ATTRIBUTE_LANGMATCH_VALUE_NEUTRAL   4L
#define APP_ATTRIBUTE_LANGMATCH_VALUE_NOMATCH   5L

// File extension used for on-demand install
#define APP_ATTRIBUTE_ONDEMAND_FILEEXT            L"OnDemandFileExtension"

// Clsid used for on-demand install
#define APP_ATTRIBUTE_ONDEMAND_CLSID              L"OnDemandClsid"

// ProgId used for on-demand install
#define APP_ATTRIBUTE_ONDEMAND_PROGID             L"OnDemandProgid"


// Removal Cause
#define APP_ATTRIBUTE_REMOVAL_CAUSE               L"RemovalCause"
//
// Enumerated values for RemovalCause
//
#define APP_ATTRIBUTE_REMOVALCAUSE_NONE           1L
#define APP_ATTRIBUTE_REMOVALCAUSE_UPGRADE        2L
#define APP_ATTRIBUTE_REMOVALCAUSE_ADMIN          3L
#define APP_ATTRIBUTE_REMOVALCAUSE_USER           4L
#define APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS      5L
#define APP_ATTRIBUTE_REMOVALCAUSE_TRANSFORM      6L
#define APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT        7L
#define APP_ATTRIBUTE_REMOVALCAUSE_PROFILE        8L

// Removal Type
#define APP_ATTRIBUTE_REMOVAL_TYPE                L"RemovalType"
//
// Enumerated values for Removal type
//
#define APP_ATTRIBUTE_REMOVALTYPE_NONE            1L
#define APP_ATTRIBUTE_REMOVALTYPE_UPGRADED        2L
#define APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED     3L
#define APP_ATTRIBUTE_REMOVALTYPE_ORPHAN          4L

// The application that caused this application to be removed
#define APP_ATTRIBUTE_REMOVING_APP                L"RemovingApplication"


//
// Attribute names for the RSOP_ARPCategories class
//

// Category id
#define CAT_ATTRIBUTE_ID                          L"CategoryId"

// Category name.
#define CAT_ATTRIBUTE_NAME                        L"Name"

// Time this instance was created
#define CAT_ATTRIBUTE_CREATIONTIME                L"CreationTime"


//
// Miscellaneous definitions
//
#define MAX_SZGUID_LEN      39
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\apis.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  apis.cxx
//
//*************************************************************

#include "appmgext.hxx"

typedef struct
{
    CManagedAppProcessor *  pManApp;
    CAppInfo *              pAppInfo;
    BOOL                    bUninstallsCompleted;
    CLoadMsi *              pLoadMsi;
    CLoadSfc *              pLoadSfc;
    boolean                 bStatus;
    INT64                   SRSequence;
} APPCONTEXT, * PAPPCONTEXT;

CRITICAL_SECTION  gAppCS;

static BOOL
SetSystemRestorePoint(
    IN  WCHAR * pwszApplicationName,
    IN OUT  PAPPCONTEXT pAppContext
    );

static void
CheckLocalCall(
    IN  handle_t hRpc
    );

WCHAR*
GetGpoNameFromGuid( 
    IN PGROUP_POLICY_OBJECT pGpoList,
    IN GUID* pGpoGuid
    );

DWORD
GetPlatformCompatibleCOMClsCtx( 
    DWORD Architecture,
    DWORD dwClsCtx
    );

void
LogRsopInstallData(
    CManagedAppProcessor* pManApp,
    CAppInfo*             pAppInfo
    );

DWORD
WINAPI
GetManagedAppsProc(
    LPVOID pvArpContext
    );

error_status_t
InstallBegin(
    IN  handle_t            hRpc,
    IN  APPKEY *            pAppType,
    OUT PINSTALLCONTEXT *   ppInstallContext,
    OUT APPLICATION_INFO *  pInstallInfo,
    OUT UNINSTALL_APPS *    pUninstallApps
    )
{
    CManagedAppProcessor * pManApp;
    CAppList        LocalApps( NULL );
    HANDLE          hUserToken;
    HKEY            hkRoot;
    uCLSSPEC        ClassSpec;
    QUERYCONTEXT    QueryContext;
    PACKAGEDISPINFO PackageInfo;
    PAPPCONTEXT     pAppContext;
    GUID            DeploymentId;
    CAppInfo *      pAppInfo;
    CAppInfo *      pUpgradedApp;
    CAppInfo *      pLocalApp;
    WCHAR           wszGuid[40];
    WCHAR           wszProductId[40];
    WCHAR *         pwszDeploymentId;
    DWORD           Size;
    DWORD           UninstallApps;
    DWORD           n;
    DWORD           Status;
    HRESULT         hr;
    BOOL            bEnterCritSec;
    BOOL            bStatus;

    CRsopAppContext RsopContext( CRsopAppContext::INSTALL, NULL, pAppType );
    
    PGROUP_POLICY_OBJECT pGPOList;

    *ppInstallContext = 0;
    memset( pInstallInfo, 0, sizeof(APPLICATION_INFO) );
    memset( pUninstallApps, 0, sizeof(UNINSTALL_APPS) );

    CheckLocalCall( hRpc );

    pManApp = 0;
    pAppInfo = 0;
    hUserToken = 0;
    hkRoot = 0;
    pAppContext = 0;

    bEnterCritSec = FALSE;

    pGPOList = NULL;

    Status = RpcImpersonateClient( NULL );

    if ( Status != ERROR_SUCCESS )
        return Status;

    if ( ERROR_SUCCESS == Status )
    {
        bStatus = OpenThreadToken(
                        GetCurrentThread(),
                        TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                        TRUE,
                        &hUserToken );

        if ( ! bStatus )
            Status = GetLastError();
    }

    if ( ERROR_SUCCESS == Status )
        Status = RegOpenCurrentUser( GENERIC_ALL, &hkRoot );

    if ( Status != ERROR_SUCCESS )
    {
        CloseHandle( hUserToken );
        RevertToSelf();
        return Status;
    }

    gpEvents->SetToken( hUserToken );

    LogTime();

    //
    // Set the query context -- the LANG_SYSTEM_DEFAULT value
    // tells CsGetAppInfo that we should use our built-in language precedence
    // algorithm in filtering packages -- otherwise, it will only consider
    // packages that match exactly the locale specified in the .Locale member
    //
    QueryContext.Locale = LANG_SYSTEM_DEFAULT;

    //
    // For architecture, we use the architecture of the calling process to override
    // the architecture of this process
    //
    GetDefaultPlatform( &QueryContext.Platform, TRUE, pAppType->ProcessorArchitecture );

    QueryContext.dwContext = CLSCTX_ALL;

    QueryContext.dwVersionHi = -1;
    QueryContext.dwVersionLo = -1;

    switch ( pAppType->Type )
    {
    case APPNAME :
        ClassSpec.tyspec = TYSPEC_PACKAGENAME;
        ClassSpec.tagged_union.ByName.pPackageName = pAppType->uType.AppName.Name;
        ClassSpec.tagged_union.ByName.PolicyId = pAppType->uType.AppName.PolicyId;
        DebugMsg((DM_VERBOSE, IDS_INSTALL_APPNAME, pAppType->uType.AppName.Name));
        break;
    case FILEEXT :
        ClassSpec.tyspec = TYSPEC_FILEEXT;
        ClassSpec.tagged_union.pFileExt = pAppType->uType.FileExt;
        DebugMsg((DM_VERBOSE, IDS_INSTALL_FILEEXT, pAppType->uType.FileExt));
        break;
    case PROGID :
        ClassSpec.tyspec = TYSPEC_PROGID;
        ClassSpec.tagged_union.pProgId = pAppType->uType.ProgId;
        DebugMsg((DM_VERBOSE, IDS_INSTALL_PROGID, pAppType->uType.ProgId));
        break;
    case COMCLASS :
        ClassSpec.tyspec = TYSPEC_CLSID;
        ClassSpec.tagged_union.clsid = pAppType->uType.COMClass.Clsid;
        QueryContext.dwContext = GetPlatformCompatibleCOMClsCtx( pAppType->ProcessorArchitecture, pAppType->uType.COMClass.ClsCtx );
        GuidToString( pAppType->uType.COMClass.Clsid, wszGuid );
        DebugMsg((DM_VERBOSE, IDS_INSTALL_COMCLASS, wszGuid, QueryContext.dwContext));
        break;
    }

    hr = CsGetAppInfo( &ClassSpec, &QueryContext, &PackageInfo );

    RevertToSelf();

    if ( S_OK == hr )
    {
        WCHAR* pszPolicyName;

        Status = RpcImpersonateClient( NULL );

        if ( ERROR_SUCCESS == Status )
        {
            Status = GetCurrentUserGPOList( &pGPOList );

            RevertToSelf();
        }

        if ( ERROR_SUCCESS != Status )
            goto InstallAppExit;

        pszPolicyName = GetGpoNameFromGuid( 
            pGPOList,
            &(PackageInfo.GpoId) );

        //
        // We've seen instance where getting the policy names fails because the gpo
        // history key for appmgmt in hklm was missing.  This is remotely possible 
        // if some registry api fails.  In this instance we can't just let every
        // install from ARP fail, so we'll just have to chug along with an empty
        // policy name.
        //
        if ( ! pszPolicyName )
            pszPolicyName = L"";

        switch ( PackageInfo.PathType )
        {
        case DrwFilePath :
            DebugMsg((DM_VERBOSE, IDS_INSTALL_DARWIN, PackageInfo.pszPackageName, pszPolicyName));
            break;
        case SetupNamePath :
            DebugMsg((DM_VERBOSE, IDS_INSTALL_SETUP, PackageInfo.pszPackageName, pszPolicyName));
            pInstallInfo->pwszDeploymentName = StringDuplicate( PackageInfo.pszPackageName );
            pInstallInfo->pwszGPOName = StringDuplicate( pszPolicyName );
            pInstallInfo->pwszSetupCommand = StringDuplicate( PackageInfo.pszScriptPath );
            goto InstallAppExit;
        default :
            DebugMsg((DM_VERBOSE, IDS_INSTALL_UNKNOWN, PackageInfo.PathType, PackageInfo.pszPackageName, pszPolicyName));
            Status = CS_E_PACKAGE_NOTFOUND;
            goto InstallAppExit;
        }
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_GETAPPINFO_FAIL, hr));
        memset( &PackageInfo, 0, sizeof(PackageInfo) );
        Status = (DWORD) hr;
    }

    if ( ERROR_SUCCESS == Status )
    {
        pAppContext = new APPCONTEXT;
        if ( pAppContext )
        {
            pAppContext->pManApp = 0;
            pAppContext->pAppInfo = 0;
            pAppContext->bUninstallsCompleted = FALSE;
            pAppContext->pLoadMsi = new CLoadMsi( Status );
            pAppContext->pLoadSfc = 0;
            pAppContext->bStatus = FALSE;
            pAppContext->SRSequence = 0;

            if ( Status != ERROR_SUCCESS )
            {
                delete pAppContext->pLoadMsi;
                pAppContext->pLoadMsi = 0;
            }

            if ( ! pAppContext->pLoadMsi )
            {
                delete pAppContext;
                pAppContext = 0;
            }
        }

        if ( ! pAppContext )
        {
            Status = ERROR_OUTOFMEMORY;
        }
    }

    if ( Status != ERROR_SUCCESS )
        goto InstallAppExit;

    RtlEnterCriticalSection( &gAppCS );
    bEnterCritSec = TRUE;

    pManApp = new CManagedAppProcessor( 0, hUserToken, hkRoot, NULL, TRUE, FALSE, &RsopContext, Status );

    if ( ! pManApp )
        Status = ERROR_OUTOFMEMORY;

    if ( ERROR_SUCCESS == Status )
        Status = pManApp->SetPolicyListFromGPOList( pGPOList );

    if ( ERROR_SUCCESS == Status )
    {
        pAppInfo = new CAppInfo( pManApp, &PackageInfo, TRUE, bStatus );

        if ( ! pAppInfo || ! bStatus )
            Status = ERROR_OUTOFMEMORY;
    }

    if ( ERROR_SUCCESS == Status )
    {
        GuidToString( PackageInfo.ProductCode, wszProductId);

        Status = pManApp->GetOrderedLocalAppList( LocalApps );
    }

    if ( ERROR_SUCCESS == Status )
        Status = pManApp->Impersonate();

    if ( Status != ERROR_SUCCESS )
        goto InstallAppExit;

    pAppContext->pManApp = pManApp;
    pAppContext->pAppInfo = pAppInfo;

    //
    // When servicing a demand install outside of ARP we prevent faulting in
    // any deployment of a particular product different from what is already
    // on the machine (if any) and we also prevent faulting in any app which
    // upgrades another app already on the machine.  This is to prevent a
    // subsequent upgrade, transform conflict, or language mismatch from
    // occuring while the app is likely in use.
    //
    // So below we are checking these cases plus, in the case of an ARP install,
    // adding any such apps to an additional list for processing of orphan and
    // uninstall actions.
    //

    for ( LocalApps.Reset(), pLocalApp = (CAppInfo *) LocalApps.GetCurrentItem();
          pLocalApp;
          pLocalApp = (CAppInfo *) LocalApps.GetCurrentItem() )
    {
        if ( ! (pLocalApp->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        {
            LocalApps.MoveNext();
            continue;
        }

        //
        // This is the check for a similar product id but a different
        // deployment instance.
        //
        if ( (0 == lstrcmpi( pLocalApp->_pwszProductId, wszProductId )) &&
             (memcmp( &pLocalApp->_DeploymentId, &PackageInfo.PackageGuid, sizeof(GUID) ) != 0) )
        {
            if ( pAppType->Type != APPNAME )
            {
                // Abort if not doing an ARP install.
                Status = CS_E_PACKAGE_NOTFOUND;
                DebugMsg((DM_VERBOSE, IDS_DEMAND_BLOCK1, pAppInfo->_pwszDeploymentName));
                break;
            }
            else
            {
                LocalApps.MoveNext();
                pLocalApp->Remove();
                pManApp->AppList().InsertFIFO( pLocalApp );
                continue;
            }
        }

        //
        // This is the check to see if this new package is set to upgrade any
        // existing app we have.
        //
        for ( n = 0; n < PackageInfo.cUpgrades; n++ )
        {
            if ( (PackageInfo.prgUpgradeInfoList[n].Flag & (UPGFLG_Uninstall | UPGFLG_NoUninstall)) &&
                 (0 == memcmp( &pLocalApp->_DeploymentId, &PackageInfo.prgUpgradeInfoList[n].PackageGuid, sizeof(GUID) )) )
            {
                if ( pAppType->Type != APPNAME )
                {
                    // Abort if not doing an ARP install.
                    Status = CS_E_PACKAGE_NOTFOUND;
                    DebugMsg((DM_VERBOSE, IDS_DEMAND_BLOCK2, pAppInfo->_pwszDeploymentName));
                }
                else
                {
                    LocalApps.MoveNext();
                    pLocalApp->Remove();
                    pManApp->AppList().InsertFIFO( pLocalApp );
                }
                break;
            }
        }

        if ( CS_E_PACKAGE_NOTFOUND == Status )
            break;

        if ( n < PackageInfo.cUpgrades )
            continue;

        //
        // This is the check to see if this app is superceded by an app which is
        // already installed.  Note that in some instances this may actually be
        // a case where the new app upgrades the local app because of
        // policy precedence upgrade reversal.  The result is the same for demand
        // installs, but slightly different for ARP installs where we must ensure
        // that the upgrade logic is invoked.
        //
        for ( pwszDeploymentId = pLocalApp->_pwszSupercededIds;
              pwszDeploymentId && *pwszDeploymentId;
              pwszDeploymentId += GUIDSTRLEN + 1 )
        {
            StringToGuid( pwszDeploymentId, &DeploymentId );
            if ( 0 == memcmp( &DeploymentId, &PackageInfo.PackageGuid, sizeof(GUID) ) )
            {
                if ( pAppType->Type != APPNAME )
                {
                    // Abort if not doing an ARP install.
                    Status = CS_E_PACKAGE_NOTFOUND;
                    DebugMsg((DM_VERBOSE, IDS_DEMAND_BLOCK2, pAppInfo->_pwszDeploymentName));
                }
                else
                {
                    //
                    // There is an app already installed which has the new package
                    // in it's override list.  Either a previous upgrade setting is no
                    // longer set or this is a policy precedence violation case where
                    // the upgrade needs to be reversed.
                    // Not the prettiest solution, trading a late product change for least
                    // invasive code change.
                    //
                    if ( pManApp->GPOList().Compare( pLocalApp->_pwszGPOId, pAppInfo->_pwszGPOId ) < 0 )
                    {
                        PACKAGEDISPINFO LocalAppPackageInfo;
                        CAppInfo *      pNewApp = 0;

                        memset( &LocalAppPackageInfo, 0, sizeof(LocalAppPackageInfo) );

                        ClassSpec.tyspec = TYSPEC_OBJECTID;
                        memcpy( &ClassSpec.tagged_union.ByObjectId.ObjectId, &pLocalApp->_DeploymentId, sizeof(GUID) );
                        StringToGuid( pLocalApp->_pwszGPOId, &ClassSpec.tagged_union.ByObjectId.PolicyId );

                        hr = CsGetAppInfo( &ClassSpec, NULL, &LocalAppPackageInfo );

                        if ( S_OK == hr )
                        {
                            pNewApp = new CAppInfo( pManApp, &LocalAppPackageInfo, FALSE, bStatus );
                            if ( ! bStatus )
                            {
                                delete pNewApp;
                                pNewApp = 0;
                            }
                            ReleasePackageInfo( &LocalAppPackageInfo );
                        }

                        if ( pNewApp )
                        {
                            pManApp->AppList().InsertFIFO( pAppInfo );
                            Status = pNewApp->InitializePass0();
                            pAppInfo->Remove();
                            pManApp->AppList().InsertFIFO( pNewApp );
                        }

                        if ( ! pNewApp || (Status != ERROR_SUCCESS) )
                            Status = CS_E_PACKAGE_NOTFOUND;
                    }
                }
                break;
            }
        }

        if ( CS_E_PACKAGE_NOTFOUND == Status )
            break;

        LocalApps.MoveNext();
    }

    LocalApps.ResetEnd();

    if ( ERROR_SUCCESS == Status )
    {
        // 
        // When doing a fileext/progid/clsid demand install, we don't want to 
        // set the full install state bit for the first time.  This will enable 
        // the full install option to still be applied at the next foreground 
        // policy processing.
        //
        if ( (pAppType->Type != APPNAME) && ! (pAppInfo->_State & APPSTATE_INSTALL) )
            pAppInfo->_ActFlags &= ~ACTFLG_InstallUserAssign;

        pAppInfo->InitializePass0();
        pAppInfo->SetActionPass1();
        pAppInfo->SetActionPass2();
        pAppInfo->SetActionPass3();
        pAppInfo->SetActionPass4();

        Status = pAppInfo->_Status;
    }

    pManApp->Revert();

    if ( ERROR_SUCCESS == Status )
    {
        bStatus = pAppInfo->CopyToApplicationInfo( pInstallInfo );
        if ( ! bStatus )
            Status = ERROR_OUTOFMEMORY;
    }

    if ( Status != ERROR_SUCCESS )
        goto InstallAppExit;

    for ( pManApp->AppList().Reset(), pUpgradedApp = (CAppInfo *) pManApp->AppList().GetCurrentItem();
          pUpgradedApp;
          pManApp->AppList().MoveNext(), pUpgradedApp = (CAppInfo *) pManApp->AppList().GetCurrentItem() )
    {
        APPLICATION_INFO * pOldApplicationInfo;

        bStatus = FALSE;

        if ( (pUpgradedApp->_Action != ACTION_UNINSTALL) && (pUpgradedApp->_Action != ACTION_ORPHAN) )
            continue;

        pOldApplicationInfo = pUninstallApps->ApplicationInfo;
        pUninstallApps->ApplicationInfo = (APPLICATION_INFO *) LocalAlloc( 0, (pUninstallApps->Products + 1) * sizeof(APPLICATION_INFO) );

        if ( pUninstallApps->ApplicationInfo )
        {
            if ( pOldApplicationInfo )
                memcpy( pUninstallApps->ApplicationInfo, pOldApplicationInfo, pUninstallApps->Products * sizeof(APPLICATION_INFO) );
            bStatus = pUpgradedApp->CopyToApplicationInfo( &pUninstallApps->ApplicationInfo[pUninstallApps->Products] );
        }

        LocalFree( pOldApplicationInfo );

        if ( ! bStatus )
        {
            pUninstallApps->Products = 0;
            Status = ERROR_OUTOFMEMORY;
            goto InstallAppExit;
        }
        else
        {
            pUninstallApps->Products++;
        }
    }

    pManApp->AppList().ResetEnd();

    //
    // If we're doing a progid, file extension, or clsid based activation, we search
    // for the specific Darwin identifier.
    //
    if ( pAppType->Type != APPNAME )
    {
        const DWORD dwMaxStrLen = 128;
        HKEY        hkPolicy;
        HKEY        hkClasses;
        HKEY        hkProgId;
        HKEY        hkScratch;
        WCHAR       wszScratch[dwMaxStrLen];
        WCHAR       wszDarwinId[128];
        WCHAR *     pwszProgId;
        DWORD       ScriptFlags;

        hkPolicy = 0;
        hkClasses = 0;

        wszDarwinId[0] = 0;

        Status = RegOpenKeyEx(
                        hkRoot,
                        POLICYKEY,
                        0,
                        KEY_ALL_ACCESS,
                        &hkPolicy );

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We can use a fixed temp name since we are in a crit sec here.  This
            // key must be non volatile since that is how Darwin will do all of
            // their creates under this key.
            //
            Status = RegCreateKeyEx(
                            hkPolicy,
                            L"TempClasses",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hkClasses,
                            NULL );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = pManApp->Impersonate();
            if ( ERROR_SUCCESS == Status )
            {
                Status = pAppInfo->CopyScriptIfNeeded();
                pManApp->Revert();
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            //
            // Must include the MACHINEASSIGN flag since we are not impersonating.
            // That's a little quirk in the semantics of the Msi API.
            //
            ScriptFlags = SCRIPTFLAGS_MACHINEASSIGN;

            //
            // In the progid case we need to advertise both extension and class data.
            // This is because different progids are registered in these two
            // cases and we want to catch both.  In the former case they are progids
            // associated with file extensions and in the latter case with clsids.
            //
            if ( (FILEEXT == pAppType->Type) || (PROGID == pAppType->Type) )
                ScriptFlags |= SCRIPTFLAGS_REGDATA_EXTENSIONINFO;

            if ( (PROGID == pAppType->Type) || (COMCLASS == pAppType->Type) )
                ScriptFlags |= SCRIPTFLAGS_REGDATA_CLASSINFO;

            Status = (*gpfnMsiAdvertiseScript)(
                        pAppInfo->LocalScriptPath(),
                        ScriptFlags,
                        &hkClasses,
                        FALSE );
        }

        if ( Status != ERROR_SUCCESS )
        {
            gpEvents->Install(
                Status,
                pAppInfo);

            goto InstallAppDescriptorAbort;
        }

        //
        // Now we grovel our temporary registry dump for a darwin id under the
        // class info that was requested.
        //

        if ( pAppType->Type != COMCLASS )
        {
            //
            // Looking for a shell-open command verb.  First figure out the
            // ProgID.
            //
            if ( FILEEXT == pAppType->Type )
            {
                Status = RegOpenKeyEx(
                            hkClasses,
                            pAppType->uType.FileExt,
                            0,
                            KEY_ALL_ACCESS,
                            &hkScratch );

                Size = sizeof(wszScratch);

                if ( ERROR_SUCCESS == Status )
                {
                    Status = RegQueryValueEx(
                                hkScratch,
                                L"",
                                NULL,
                                NULL,
                                (PBYTE) wszScratch,
                                &Size );

                    RegCloseKey( hkScratch );
                }

                pwszProgId = wszScratch;
            }
            else
            {
                pwszProgId = pAppType->uType.ProgId;
            }

            if ( ERROR_SUCCESS == Status )
            {
                Status = RegOpenKeyEx(
                            hkClasses,
                            pwszProgId,
                            0,
                            KEY_ALL_ACCESS,
                            &hkProgId );
            }

            if ( ERROR_SUCCESS == Status )
            {
                Status = RegOpenKeyEx(
                            hkProgId,
                            L"shell\\open\\command",
                            0,
                            KEY_ALL_ACCESS,
                            &hkScratch );

                RegCloseKey( hkProgId );
            }

            Size = sizeof(wszDarwinId);

            if ( ERROR_SUCCESS == Status )
            {
                Status = RegQueryValueEx(
                            hkScratch,
                            L"command",
                            NULL,
                            NULL,
                            (PBYTE) wszDarwinId,
                            &Size );

                if ( (ERROR_SUCCESS == Status) && DebugLevelOn( DM_VERBOSE ) )
                {
                    DebugMsg((DM_VERBOSE, IDS_PROGID_FOUND, pwszProgId));
                }

                RegCloseKey( hkScratch );
            }
        }
        else // COMCLASS == pAppType->Type
        {
            //
            // Looking for a com clsid.  We check both the inproc & localserver
            // keys if those clsctx bits are set.
            //

            hr = StringCchCopy( wszScratch, dwMaxStrLen, L"CLSID\\" );
            if (FAILED(hr))
            {
                Status = HRESULT_CODE(hr);
                goto InstallAppDescriptorAbort; 
            }
            hr = StringCchCopy( &wszScratch[6], dwMaxStrLen-6, wszGuid );            
            if (FAILED(hr))
            {
                Status = HRESULT_CODE(hr);
                goto InstallAppDescriptorAbort; 
            }
            
            if ( pAppType->uType.COMClass.ClsCtx & CLSCTX_INPROC_SERVER )
            {
                hr = StringCchCopy( &wszScratch[6+GUIDSTRLEN], dwMaxStrLen-(6+GUIDSTRLEN),L"\\InprocServer32" );

                if (FAILED(hr))
                {
                    Status = HRESULT_CODE(hr);
                    goto InstallAppDescriptorAbort; 
                }

                Status = RegOpenKeyEx(
                            hkClasses,
                            wszScratch,
                            0,
                            KEY_ALL_ACCESS,
                            &hkScratch );

                Size = sizeof(wszDarwinId);

                if ( ERROR_SUCCESS == Status )
                {
                    Status = RegQueryValueEx(
                                hkScratch,
                                L"InprocServer32",
                                NULL,
                                NULL,
                                (PBYTE) wszDarwinId,
                                &Size );

                    if ( ERROR_SUCCESS == Status )
                        DebugMsg((DM_VERBOSE, IDS_CLSID_INPROC_FOUND));

                    RegCloseKey( hkScratch );
                }
            }

            if ( (0 == wszDarwinId[0]) && (pAppType->uType.COMClass.ClsCtx & CLSCTX_LOCAL_SERVER) )
            {
                hr = StringCchCopy( &wszScratch[6+GUIDSTRLEN], dwMaxStrLen-(6+GUIDSTRLEN),L"\\LocalServer32" );
                if (FAILED(hr))
                {
                    Status = HRESULT_CODE(hr);
                    goto InstallAppDescriptorAbort; 
                }
                
                Status = RegOpenKeyEx(
                            hkClasses,
                            wszScratch,
                            0,
                            KEY_ALL_ACCESS,
                            &hkScratch );

                Size = sizeof(wszDarwinId);

                if ( ERROR_SUCCESS == Status )
                {
                    Status = RegQueryValueEx(
                                hkScratch,
                                L"LocalServer32",
                                NULL,
                                NULL,
                                (PBYTE) wszDarwinId,
                                &Size );

                    if ( ERROR_SUCCESS == Status )
                        DebugMsg((DM_VERBOSE, IDS_CLSID_LOCAL_FOUND));

                    RegCloseKey( hkScratch );
                }
            }
        }

        //
        // We're done with the temp reg data, so blow it away now.
        //
        // Must include the MACHINEASSIGN flag since we are not impersonating.
        //
        (void) (*gpfnMsiAdvertiseScript)(
                    pAppInfo->LocalScriptPath(),
                    ScriptFlags,
                    &hkClasses,
                    TRUE );

InstallAppDescriptorAbort:

        if ( hkClasses )
        {
            RegCloseKey( hkClasses );
            RegDeleteKey( hkPolicy, L"TempClasses" );
        }

        if ( hkPolicy )
            RegCloseKey( hkPolicy );

        if ( ERROR_SUCCESS == Status )
        {
            pInstallInfo->pwszDescriptor = (PWCHAR) LocalAlloc( 0, (lstrlen(wszDarwinId) + 1) * sizeof(WCHAR) );
            if ( pInstallInfo->pwszDescriptor )
            {                
                hr = StringCchCopy( pInstallInfo->pwszDescriptor,lstrlen(wszDarwinId) + 1, wszDarwinId );

                if (FAILED(hr))
                {
                    Status = HRESULT_CODE(hr);
                }
            }
            else
                Status = ERROR_OUTOFMEMORY;
        }

        //
        // If we fail to find a darwin id under the specific class data that
        // was requested, then we fall back to doing a full product based
        // install.  Since the DS query succeeded, we have a valid app, but
        // there just isn't any darwin id registered for the specific class
        // data in the advertisement data.
        //
        // This could be a packaging problem, limitation, or design.
        //
    } // if ( pAppType->Type != APPNAME )

    if ( (ERROR_SUCCESS == Status) && (pAppInfo->_State & APPSTATE_SCRIPT_NOT_EXISTED) )
    {
        SetSystemRestorePoint( pAppInfo->_pwszDeploymentName, pAppContext );
    }

InstallAppExit:

    if ( bEnterCritSec )
        RtlLeaveCriticalSection( &gAppCS );

    if ( Status != ERROR_SUCCESS )
    {
        for ( ; pUninstallApps->Products; )
            FreeApplicationInfo( &pUninstallApps->ApplicationInfo[--pUninstallApps->Products] );
        LocalFree( pUninstallApps->ApplicationInfo );
        pUninstallApps->Products = 0;
        pUninstallApps->ApplicationInfo = 0;

        FreeApplicationInfo( pInstallInfo );
        memset( pInstallInfo, 0, sizeof(APPLICATION_INFO) );

        if ( pManApp )
        {
            if ( pAppInfo )
            {
                //
                // Since this call has failed, the client will not call
                // the InstallEnd method to log the failure, so we must
                // log the failure in this call
                //
                (void) LogRsopInstallData( pManApp, pAppInfo );
            }
            delete pManApp;
        }

        if ( pAppInfo )
            delete pAppInfo;

        if ( pAppContext )
        {
            delete pAppContext->pLoadMsi;
            delete pAppContext;
        }
    }
    else
    {
        *ppInstallContext = pAppContext;
    }

    if ( ((long)Status) > 0 )
        DebugMsg((DM_VERBOSE, IDS_INSTALL_STATUS1, Status));
    else
        DebugMsg((DM_VERBOSE, IDS_INSTALL_STATUS2, Status));

    gpEvents->ClearToken();

    if ( hUserToken )
        CloseHandle( hUserToken );

    if ( hkRoot )
        RegCloseKey( hkRoot );

    if ( pGPOList )
        FreeGPOList( pGPOList );

    ReleasePackageInfo( &PackageInfo );

    return Status;
}

error_status_t
InstallManageApp(
    IN  PINSTALLCONTEXT     pInstallContext,
    IN  PWSTR               pwszDeploymentId,
    IN  DWORD               RollbackStatus,
    OUT boolean *           pbInstall
    )
{
    PAPPCONTEXT pAppContext;
    CAppInfo *  pAppInfo;
    GUID        DeploymentId;
    DWORD       Status;

    *pbInstall = FALSE;

    pAppContext = (PAPPCONTEXT) pInstallContext;
    StringToGuid( pwszDeploymentId, &DeploymentId );

    Status = pAppContext->pManApp->Impersonate();
    if ( Status != ERROR_SUCCESS )
        return Status;

    gpEvents->SetToken( pAppContext->pManApp->UserToken() );

    if ( memcmp( &DeploymentId, &pAppContext->pAppInfo->_DeploymentId, sizeof(GUID) ) == 0 )
    {
        pAppContext->bUninstallsCompleted = TRUE;
        Status = pAppContext->pAppInfo->ProcessApplyActions();

        if ( ERROR_SUCCESS == Status )
        {
            if ( pAppContext->pManApp->GetRsopContext()->IsRsopEnabled() && pAppContext->pManApp->GetRsopContext()->IsDiagnosticModeEnabled() )
                Status = pAppContext->pAppInfo->ProcessTransformConflicts();
        }

        goto InstallManageAppEnd;
    }

    for ( pAppContext->pManApp->AppList().Reset();
          pAppInfo = (CAppInfo *) pAppContext->pManApp->AppList().GetCurrentItem();
          pAppContext->pManApp->AppList().MoveNext() )
    {
        if ( memcmp( &DeploymentId, &pAppInfo->_DeploymentId, sizeof(GUID) ) == 0 )
            break;
    }

    if ( ! pAppInfo )
    {
        Status = ERROR_NOT_FOUND;
        goto InstallManageAppEnd;
    }

    //
    // Re-assigning one of the upgraded apps because of a failed upgrade.  Not needed for
    // apps orphaned during the upgrade.
    //
    if ( ACTION_UNINSTALL == pAppInfo->_Action )
    {
        DWORD ScriptFlags = SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS;

        *pbInstall = (pAppInfo->_State & APPSTATE_INSTALL) ? 1 : 0;

        if ( pAppInfo->_State & APPSTATE_ASSIGNED )
            ScriptFlags |= SCRIPTFLAGS_REGDATA_EXTENSIONINFO;
        Status = pAppInfo->Assign( ScriptFlags, TRUE, FALSE );

        //
        // Record an event so that we can track this as an RSoP failed setting if
        // necessary
        //
        if ( ERROR_SUCCESS != Status )
        {
            gpEvents->Assign( Status, pAppInfo );
        }
    }

    //
    // Remember that this application was rolled back
    //
    pAppInfo->_bRollback = TRUE;

    gpEvents->UpgradeAbort( RollbackStatus, pAppContext->pAppInfo, pAppInfo, ! pAppContext->bUninstallsCompleted );

InstallManageAppEnd:

    gpEvents->ClearToken();
    pAppContext->pManApp->Revert();
    return Status;
}

error_status_t
InstallUnmanageApp(
    IN  PINSTALLCONTEXT     pInstallContext,
    IN  PWSTR               pwszDeploymentId,
    IN  boolean             bUnadvertiseOnly
    )
{
    PAPPCONTEXT pAppContext;
    CAppInfo *  pAppInfo;
    GUID        DeploymentId;
    DWORD       Status;

    pAppContext = (PAPPCONTEXT) pInstallContext;
    StringToGuid( pwszDeploymentId, &DeploymentId );

    Status = pAppContext->pManApp->Impersonate();
    if ( Status != ERROR_SUCCESS )
        goto InstallUnmanageAppRemoveScript;

    gpEvents->SetToken( pAppContext->pManApp->UserToken() );

    if ( memcmp( &DeploymentId, &pAppContext->pAppInfo->_DeploymentId, sizeof(GUID) ) == 0 )
    {
        Status = pAppContext->pAppInfo->Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO, TRUE );

        //
        // Record an event so that we can track this as an RSoP failed setting if
        // necessary
        //
        if ( ERROR_SUCCESS != Status )
        {
            gpEvents->Unassign( Status, pAppContext->pAppInfo );
        }

        goto InstallUnmanageAppEnd;
    }

    for ( pAppContext->pManApp->AppList().Reset();
          pAppInfo = (CAppInfo *) pAppContext->pManApp->AppList().GetCurrentItem();
          pAppContext->pManApp->AppList().MoveNext() )
    {
        if ( memcmp( &DeploymentId, &pAppInfo->_DeploymentId, sizeof(GUID) ) == 0 )
            break;
    }

    if ( ! pAppInfo )
    {
        Status = ERROR_NOT_FOUND;
        goto InstallUnmanageAppEnd;
    }

    //
    // Unassigning one of the upgraded apps.
    //
    if ( bUnadvertiseOnly )
    {
        Status = pAppInfo->Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO, FALSE );
    }
    else
    {
        Status = pAppInfo->Unassign( 0, TRUE );

        //
        // Record an event so that we can track this as an RSoP failed setting if
        // necessary
        //
        if ( ERROR_SUCCESS != Status )
        {
            gpEvents->Unassign( Status, pAppInfo );
        }
    
        gpEvents->UpgradeComplete( pAppContext->pAppInfo, pAppInfo );
    }

InstallUnmanageAppEnd:

    gpEvents->ClearToken();
    pAppContext->pManApp->Revert();

InstallUnmanageAppRemoveScript:

    //
    // Be sure to remove the script for a failed upgrade app
    //

    if ( ( ERROR_SUCCESS != Status ) && ! bUnadvertiseOnly )
    {
        DeleteFile( pAppContext->pAppInfo->_pwszLocalScriptPath );
    }

    return Status;
}

error_status_t
InstallEnd(
    IN  boolean   bStatus,
    IN OUT PINSTALLCONTEXT * ppInstallContext
    )
{
    //
    // We are done installing -- now log the results
    //
    if ( ppInstallContext && *ppInstallContext )
    {
        PAPPCONTEXT           pAppContext;
        CManagedAppProcessor* pManApp;
    
        pAppContext = (PAPPCONTEXT) *ppInstallContext;
        if ( pAppContext )
            pAppContext->bStatus = (boolean) bStatus;

        pManApp = pAppContext->pManApp;

        if ( pManApp && pAppContext )
        {
            (void) LogRsopInstallData( pManApp, pAppContext->pAppInfo );
        }
    }

    if ( ppInstallContext )
    {
        PINSTALLCONTEXT_rundown( *ppInstallContext );
        *ppInstallContext = 0;
    }

    return ERROR_SUCCESS;
}

void
PINSTALLCONTEXT_rundown(
    IN  PINSTALLCONTEXT pInstallContext
    )
{
    PAPPCONTEXT pAppContext;

    pAppContext = (PAPPCONTEXT) pInstallContext;

    if ( pAppContext && (pAppContext->SRSequence != 0) )
    {
        RESTOREPOINTINFO    RestoreInfo;
        STATEMGRSTATUS      SRStatus;

        RestoreInfo.dwEventType = END_NESTED_SYSTEM_CHANGE;
        RestoreInfo.dwRestorePtType = pAppContext->bStatus ? 0 : CANCELLED_OPERATION;
        RestoreInfo.llSequenceNumber = pAppContext->SRSequence;
        RestoreInfo.szDescription[0] = 0;

        (void) (*gpfnSRSetRetorePointW)( &RestoreInfo, &SRStatus );
    }

    //
    // If this app failed to be installed, ensure that the status is
    // set properly (in upgrade cases, the status for the application may
    // not be set.  If this status is not set as a failure, the 
    // application's state (such as the script) may not be set
    //
    if ( pAppContext && pAppContext->pAppInfo && ! pAppContext->bStatus )
    {
        pAppContext->pAppInfo->ForceFailureStatus();
    }

    if (pAppContext)
    {
        delete pAppContext->pManApp;
        delete pAppContext->pAppInfo;
        delete pAppContext->pLoadMsi;
        if ( pAppContext->pLoadSfc )
            delete pAppContext->pLoadSfc;
        delete pAppContext;
    }
}

DWORD
RemoveAppHelper(
    IN  WCHAR * ProductCode,
    IN  HANDLE  hUserToken,
    IN  HKEY    hKeyRoot,
    IN  DWORD   ARPStatus,
    OUT BOOL *  pbProductFound
    )
{
    CAppInfo *  pAppInfo;
    CAppInfo *  pHighestAssignedApp;
    CAppInfo *  pRemovedApp;
    DWORD       Status;

    *pbProductFound = FALSE;

    CRsopAppContext RsopContext( CRsopAppContext::REMOVAL );

    CManagedAppProcessor ManApps( hUserToken ? 0 : GPO_INFO_FLAG_MACHINE,
                                  hUserToken,
                                  hKeyRoot,
                                  NULL,
                                  FALSE,
                                  FALSE,
                                  &RsopContext,
                                  Status );

    if ( ERROR_SUCCESS != Status )
        return Status;

    CAppList    LocalApps( NULL, ManApps.GetRsopContext() );

    Status = ManApps.LoadPolicyList();

    if ( ERROR_SUCCESS != Status )
        return Status;

    Status = ManApps.GetOrderedLocalAppList( LocalApps );

    if ( ERROR_SUCCESS == Status )
        Status = ManApps.Impersonate();

    if ( Status != ERROR_SUCCESS )
        return Status;

    pHighestAssignedApp = 0;
    pRemovedApp = 0;

    LocalApps.Reset();

    for ( pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem();
          pAppInfo;
          LocalApps.MoveNext(), pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem() )
    {
        if ( (lstrcmpi( pAppInfo->_pwszProductId, ProductCode ) != 0) ||
             ! (pAppInfo->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        {
            continue;
        }

        pRemovedApp = pAppInfo;

        *pbProductFound = TRUE;

        if ( pAppInfo->_State & APPSTATE_PUBLISHED ) 
        {
            //
            // We perform no actual unassignments unless ARP actually uninstalled the app
            //

            //
            // We unassign using the same scriptflags we do during assignment
            // to handle cases where the initial install action fails and
            // we are called to undo the original assigment.  In normal success
            // cases this is redundant.
            //
            if ( ERROR_SUCCESS == ARPStatus )
            {
                DebugMsg((DM_VERBOSE, IDS_REMOVEAPP_MATCH1, pAppInfo->_pwszDeploymentName, ProductCode));
                pAppInfo->Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO, TRUE );
            }

            //
            // Set this action for RSOP as a way to remember to log a removal entry for this app
            //
            pAppInfo->SetAction( 
                ACTION_UNINSTALL,
                APP_ATTRIBUTE_REMOVALCAUSE_USER,
                NULL);
        }
        else
        {
            //
            // We only reassign if ARP was able to uninstall the app
            //
            if ( ERROR_SUCCESS == ARPStatus )
            {
                DebugMsg((DM_VERBOSE, IDS_REMOVEAPP_MATCH2, pAppInfo->_pwszDeploymentName, ProductCode));
            }

            pHighestAssignedApp = pAppInfo;
        }
    }
     
    if ( ( ERROR_SUCCESS != ARPStatus ) && 
         pRemovedApp )
    {
        //
        // If ARP failed to uninstall the highest app, log a failure status
        //
        gpEvents->Uninstall(
            ARPStatus,
            pRemovedApp);
    }

    //
    // Reassign the highest priority assigned app with this product id if
    // one exists.
    //
    BOOL bRsopLogReassign;

    bRsopLogReassign = FALSE;

    if ( pHighestAssignedApp )
    {
        //
        // We only reassign the app if it was successfully uninstalled
        //
        if ( ERROR_SUCCESS == ARPStatus )
        {
            Status = pHighestAssignedApp->Assign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO, TRUE, FALSE );
            if ( Status != ERROR_SUCCESS )
                gpEvents->Assign( Status, pHighestAssignedApp );
        }

        if ( ManApps.GetRsopContext()->IsRsopEnabled() )
        {
            //
            // Remember to write a removal entry for this reassigned app if it 
            // was the app that was removed
            //
            bRsopLogReassign = ( pHighestAssignedApp == pRemovedApp );
        }
    }

    ManApps.Revert();

    //
    // We must log rsop data after we revert because the user may not have
    // access to her own rsop namespace
    //

    //
    // Obtain exclusive access to log data -- this will disable rsop
    // if implicit access cannot be obtained
    //
    (void) ManApps.GetRsopContext()->GetExclusiveLoggingAccess( NULL == hUserToken );

    if ( ManApps.GetRsopContext()->IsRsopEnabled() )
    {  
        //
        // Now log all the uninstalled published apps which would have been marked above
        // as having the action to uninstall
        //
        (void) LocalApps.WriteLog( CAppList::RSOP_FILTER_REMOVALSONLY );
    
        //
        // Now log the highest reassigned app
        //
        if ( bRsopLogReassign )
        {
            //
            // Log the actual uninstall entry
            //
            (void) LocalApps.MarkRSOPEntryAsRemoved( pHighestAssignedApp, FALSE );
        }
        else if ( pHighestAssignedApp )
        {
            //
            // We need to write a new entry for the assigned app that was not previously
            // applied but is now due to the fact that the higher precedence application
            // was removed
            //
            (void) LocalApps.WriteAppToRsopLog( pHighestAssignedApp );
        }
    }

    (void) ManApps.GetRsopContext()->ReleaseExclusiveLoggingAccess();
     
    //
    // Whenever the user does an app uninstall, we force a full run of policy
    // during the next logon to pick up any app that should now apply.  Note that
    // later we use a gp engine api to do this due to the NT 5.1 foreground async 
    // gp refresh feature, but for compatibility with NT 5.0 (roaming), we must
    // continue to set our own registry value
    //
    if ( *pbProductFound && hUserToken )
    {
        Status = RegSetValueEx(
            ManApps.AppmgmtKey(),
            FULLPOLICY,
            0,
            REG_DWORD,
            (LPBYTE) pbProductFound,
            sizeof(*pbProductFound) );

        //
        // Ensure that if async policy is enabled, we get a synchronous refresh at
        // the next logon 
        //
        if ( ERROR_SUCCESS == Status )
        {
            Status = ForceSynchronousRefresh( ManApps.UserToken() );
        }
    }

    return Status;
}

error_status_t
ARPRemoveApp(
    IN  handle_t   hRpc,
    IN  WCHAR *    pwszProductCode,
    IN  DWORD      ARPStatus
    )
{
    HANDLE      hUserToken;
    HKEY        hKeyRoot;
    DWORD       Status;
    BOOL        bStatus;
    BOOL        bProductFound;

    CheckLocalCall( hRpc );

    hUserToken = NULL;
    hKeyRoot = NULL;

    bProductFound = FALSE;

    CLoadMsi    LoadMsi( Status );

    if ( ERROR_SUCCESS == Status )
        Status = RpcImpersonateClient( NULL );

    if ( ERROR_SUCCESS == Status )
    {
        Status = RegOpenCurrentUser( GENERIC_ALL, &hKeyRoot );

        if ( ERROR_SUCCESS == Status )
        {
            bStatus = OpenThreadToken(
                            GetCurrentThread(),
                            TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                            TRUE,
                            &hUserToken );

            if ( ! bStatus )
            {
                Status = GetLastError();
                RegCloseKey( hKeyRoot );
            }
        }

        RevertToSelf();
    }

    if ( Status != ERROR_SUCCESS )
        return Status;

    gpEvents->SetToken( hUserToken );

    LogTime();

    DebugMsg((DM_VERBOSE, IDS_REMOVEAPP, pwszProductCode));

    Status = RemoveAppHelper( pwszProductCode, hUserToken, hKeyRoot, ARPStatus, &bProductFound );

    if ( ! bProductFound )
    {
        if ( IsMemberOfAdminGroup( hUserToken ) )
            Status = RemoveAppHelper( pwszProductCode, NULL, HKEY_LOCAL_MACHINE, ARPStatus, &bProductFound );
    }

    DebugMsg((DM_VERBOSE, IDS_REMOVEAPP_STATUS, Status));
    gpEvents->ClearToken();

    if ( hUserToken )
        CloseHandle( hUserToken );

    if ( hKeyRoot )
        RegCloseKey( hKeyRoot );

    return Status;
}

error_status_t
GetManagedApps(
    IN  handle_t            hRpc,
    IN  GUID *              pCategory,
    IN  DWORD               dwQueryFlags,
    IN  DWORD               dwInfoLevel,
    OUT MANAGED_APPLIST *   pAppList
    )
{
    HANDLE          hUserToken;
    HANDLE          hEventAppsEnumerated;
    error_status_t  Status;
    BOOL            bStatus;

    CheckLocalCall( hRpc );

    hUserToken = NULL;
    hEventAppsEnumerated = NULL;

    if ( ! pAppList )
        return ERROR_INVALID_PARAMETER;

    //
    // Clear this structure so that random
    // garbage doesn't get marshalled back.
    //
    memset(pAppList, 0, sizeof(*pAppList));

    //
    // Validate the parameters passed in by the client.
    //
    if ( dwInfoLevel != MANAGED_APPS_INFOLEVEL_DEFAULT )
        return ERROR_INVALID_PARAMETER;

    switch (dwQueryFlags)
    {

    case MANAGED_APPS_USERAPPLICATIONS:
        if (pCategory)
            return ERROR_INVALID_PARAMETER;
        break;

    case MANAGED_APPS_FROMCATEGORY:
        if (!pCategory)
            return ERROR_INVALID_PARAMETER;
        break;

    default:
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Now prepare to initiate the query -- first
    // we need to get some user specific information
    // to build the object which performs the query,
    // so we impersonate.
    //
    Status = RpcImpersonateClient( NULL );
    if ( Status != ERROR_SUCCESS )
        return Status;

    bStatus = OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                    TRUE,
                    &hUserToken );

    if ( ! bStatus )
        Status = GetLastError();

    RevertToSelf();

    if ( Status != ERROR_SUCCESS )
        goto GetManagedAppsExit;

    //
    // We will create a separate thread to retrieve the ARP apps -- this allows
    // this thread to wait for a signal from the ARP thread that app enumeration is done,
    // and we can return the list at that point.  The second thread will continue to
    // execute since it needs to log rsop data -- this approach frees us from having to
    // wait for rsop logging, which can take 10 times longer than it took us to retrieve
    // the apps from the ds
    //

    //
    // Below we create the event that the enumeration thread will use to signal this
    // thread that enumeration is finished.
    //

    hEventAppsEnumerated = CreateEvent(
        NULL,
        TRUE,  // manual reset
        FALSE, // initially nonsignaled
        NULL);

    if ( ! hEventAppsEnumerated )
    {
        Status = GetLastError();
        goto GetManagedAppsExit;
    }

    //
    // We allocate a structure to pass to the enumeration thread containing all the
    // context it needs to enumerate apps.  Note that this structure is stack allocated,
    // so the enumeration thread may only access it as long as this thread lives -- once
    // it signals us that enumeration is complete, it may no longer access this structure
    //

    ARPCONTEXT ArpContext;

    ArpContext.pCategory = pCategory;
    ArpContext.pAppList = pAppList;
    ArpContext.hUserToken = hUserToken;
    ArpContext.hEventAppsEnumerated = hEventAppsEnumerated;
    ArpContext.Status = ERROR_SUCCESS; // out parameter for the second thread to indicate status

    HANDLE hThread;

    hThread = CreateThread(
        NULL,
        0,
        GetManagedAppsProc,
        &ArpContext,
        0,
        NULL);

    if ( ! hThread )
        Status = GetLastError();

    if ( ERROR_SUCCESS != Status )
        goto GetManagedAppsExit;

    //
    // Wait for enumeration in the second thread to complete, or
    // for the second thread itself to complete
    //
    HANDLE rgTasks[] = { hEventAppsEnumerated, hThread };

    (void) WaitForMultipleObjects(
        sizeof(rgTasks) / sizeof(*rgTasks),
        rgTasks,
        FALSE,
        INFINITE);

    //
    // Retrieve the enumeration thread's status
    //
    Status = ArpContext.Status;

    //
    // Because tests assume they can check RSoP data as soon as
    // the api has completed, if the tests are waiting for policy 
    // events to be signaled already, we'll also wait for rsop to finish
    //
    if ( gDebugLevel & DL_EVENT )
    {
        (void) WaitForSingleObject( hThread, INFINITE );
    }

    CloseHandle( hThread );

GetManagedAppsExit:

    if ( hUserToken )
        CloseHandle( hUserToken );

    if ( hEventAppsEnumerated )
        CloseHandle( hEventAppsEnumerated );

    return Status;
}

error_status_t
RsopReportInstallFailure(
    IN PINSTALLCONTEXT pInstallContext,
    IN PWSTR           pwszDeploymentId,
    IN DWORD           dwEventId
    )
{
    GUID                  DeploymentId;
    PAPPCONTEXT           pAppContext;
    CManagedAppProcessor* pManApp;
    CAppInfo*             pAppInfo;

    pAppContext = (PAPPCONTEXT) pInstallContext;

    pManApp = pAppContext->pManApp;

    if ( ! pManApp || ! pManApp->GetRsopContext()->IsDiagnosticModeEnabled() )
    {
        return ERROR_SUCCESS;
    }

    //
    // Assume that the failure happened in the app that
    // we're trying to install
    //
    pAppInfo = pAppContext->pAppInfo;

    if ( ! pAppInfo )
    {
        return ERROR_SUCCESS;
    }

    StringToGuid( pwszDeploymentId, &DeploymentId );

    //
    // Check to see if the failure was in the app that we're
    // trying to install
    //
    if ( ! IsEqualGUID( pAppInfo->DeploymentId(), DeploymentId ) )
    {
        //
        // If not, see if the requested app is one of the apps
        // that was uninstalled before trying to apply the
        // target app, or was reinstalled as part of a rollback
        // from failure
        //
        pAppInfo = pManApp->AppList().Find( DeploymentId );

        if ( pAppInfo )
        {
            //
            // The failure happened during an uninstall for
            // a rip and replace upgrade, so we need to
            // log a failure for the upgrade as well
            //
            pAppContext->pAppInfo->SetRsopFailureStatus(
                ERROR_GEN_FAILURE,
                dwEventId);
        }
    }
    
    //
    // If we found the app requested by the caller, log a failure
    // status for it -- the error we pass to the method is only
    // used as a check against ERROR_SUCCESS, so we do not
    // need to pass the actual error that occurred
    //
    if ( pAppInfo ) 
    {
        pAppInfo->SetRsopFailureStatus(
            ERROR_GEN_FAILURE,
            dwEventId);
    }

    return ERROR_SUCCESS;
}


error_status_t
GetManagedAppCategories(
    IN        handle_t          hRpc,
    IN OUT    APPCATEGORYLIST*  pCategoryList
    )
{
    DWORD               Status;
    HRESULT             hr;
    APPCATEGORYINFOLIST AppCategories;
    HANDLE              hUserToken;
    HKEY                hkRoot;
    
    CheckLocalCall( hRpc );

    hr = S_OK;

    hUserToken = NULL;

    hkRoot = NULL;

    memset( pCategoryList, 0, sizeof( *pCategoryList ) );
    memset( &AppCategories, 0, sizeof( AppCategories ) );

    //
    // Now prepare to initiate the query -- first
    // we need to get some user specific information
    // to build the object which performs the query,
    // so we impersonate.
    //
    Status = RpcImpersonateClient( NULL );
    if ( ERROR_SUCCESS != Status )
        return Status;

    BOOL bStatus;

    bStatus = OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                    TRUE,
                    &hUserToken );

    if ( ! bStatus )
        Status = GetLastError();

    if ( ERROR_SUCCESS == Status )
        Status = RegOpenCurrentUser( GENERIC_ALL, &hkRoot );

    if ( ERROR_SUCCESS == Status )
        hr = CsGetAppCategories( &AppCategories );

    RevertToSelf();

    if ( ( ERROR_SUCCESS != Status ) || FAILED( hr ) )
        goto GetManagedAppCategoriesExit;

    gpEvents->SetToken( hUserToken );

    //
    // The rpc interface is such that our out parameter is just
    // one allocation -- references within each array element are allocated
    // within the block, so we must first calculate how big the block is
    //
    if ( SUCCEEDED( hr ) )
    {
        DWORD        cbSize;
        DWORD        iCat;

        cbSize = sizeof( APPCATEGORY ) *  AppCategories.cCategory;

        for (iCat = 0; iCat < AppCategories.cCategory; iCat++)
        {
            cbSize += ( lstrlen( AppCategories.pCategoryInfo[iCat].pszDescription ) + 1 ) * 
                sizeof( WCHAR );
        }

        pCategoryList->pCategoryInfo = (APPCATEGORY*) midl_user_allocate( cbSize );

        if ( ! pCategoryList->pCategoryInfo )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Now that we have sufficient memory, we can copy the data
    //
    if ( SUCCEEDED( hr ) )
    {
        WCHAR* wszDescriptions;
        DWORD  iCat;

        wszDescriptions = (WCHAR*) &( pCategoryList->pCategoryInfo[ AppCategories.cCategory ] );

        pCategoryList->cCategory = AppCategories.cCategory;

        for (iCat = 0; iCat < AppCategories.cCategory; iCat++)
        {
            pCategoryList->pCategoryInfo[ iCat ].Locale = AppCategories.pCategoryInfo[iCat].Locale;
            pCategoryList->pCategoryInfo[ iCat ].AppCategoryId = AppCategories.pCategoryInfo[iCat].AppCategoryId;
            pCategoryList->pCategoryInfo[ iCat ].pszDescription = wszDescriptions;

            hr = StringCchCopy( wszDescriptions, 
                                lstrlen(AppCategories.pCategoryInfo[iCat].pszDescription)+1,
                                AppCategories.pCategoryInfo[iCat].pszDescription );
            if (FAILED(hr)) 
            {
                break;
            }
            wszDescriptions += lstrlen( wszDescriptions ) + 1;
        }
    }

    //
    // If we have successfully generated results to return to the caller, log
    // those results
    //
    if ( SUCCEEDED( hr ) )
    {
        HRESULT              hrLog;
        DWORD                StatusLog;

        CRsopAppContext      RsopContext( CRsopAppContext::ARPLIST );

        CManagedAppProcessor AppProcessor(
            0,
            hUserToken,
            hkRoot,
            NULL,
            TRUE,
            FALSE,
            &RsopContext,
            StatusLog );

        if ( ERROR_SUCCESS == StatusLog )
        {
            CCategoryInfoLog CategoryLog( AppProcessor.GetRsopContext(), &AppCategories );

            Status = AppProcessor.GetRsopContext()->GetExclusiveLoggingAccess( NULL == hUserToken );

            if ( ERROR_SUCCESS == Status )
            {
                hrLog = CategoryLog.WriteLog();
            }

            AppProcessor.GetRsopContext()->ReleaseExclusiveLoggingAccess();
        }
        else
        {
            hrLog = HRESULT_FROM_WIN32( StatusLog );
        }

        if ( FAILED(hrLog) )
        {
            RsopContext.DisableRsop( hrLog );
        }
    }

    Status = GetWin32ErrFromHResult( hr );

    //
    // Free the internal version of the category list
    //
    ReleaseAppCategoryInfoList( &AppCategories );

 GetManagedAppCategoriesExit:

    if ( hUserToken )
    {
        CloseHandle( hUserToken );
    }

    if ( hkRoot )
    {
        RegCloseKey( hkRoot );
    }

    return Status;
}

DWORD
WINAPI
GetManagedAppsProc(
    LPVOID pvArpContext
    )
{
    ARPCONTEXT* pArpContext;

    pArpContext = (ARPCONTEXT*) pvArpContext;

    HANDLE          hUserToken;
    error_status_t  Status;
    BOOL            bStatus;
    HKEY            hkRoot;

    hUserToken = NULL;
    hkRoot = NULL;

    Status = ERROR_SUCCESS;

    bStatus = DuplicateTokenEx(
        pArpContext->hUserToken,
        TOKEN_DUPLICATE | TOKEN_QUERY | TOKEN_IMPERSONATE,
        NULL,
        SecurityImpersonation,
        TokenImpersonation,
        &hUserToken);

    if ( ! bStatus )
        Status = GetLastError();

    if ( bStatus )
    {
        bStatus = ImpersonateLoggedOnUser( hUserToken );
        
        if ( ! bStatus )
            Status = GetLastError();
    }

    if ( ERROR_SUCCESS == Status )
        Status = RegOpenCurrentUser( GENERIC_ALL, &hkRoot );

    RevertToSelf();

    if ( Status != ERROR_SUCCESS )
    {
        pArpContext->Status = Status;

        goto GetManagedAppsProcExit;
    }

    gpEvents->SetToken( hUserToken );

    LogTime();

    //
    // Now that we have a valid GPOInfo object, we can construct
    // an app processor object to do the query
    //
    {
        CRsopAppContext RsopContext( CRsopAppContext::ARPLIST, pArpContext->hEventAppsEnumerated );

        CManagedAppProcessor AppProcessor( 0,
                                           hUserToken,
                                           hkRoot,
                                           NULL,
                                           TRUE,
                                           FALSE,
                                           &RsopContext,
                                           Status );

        if ( ERROR_SUCCESS == Status )
        {
            Status = AppProcessor.GetManagedApplications( pArpContext->pCategory, pArpContext );
        }
    }

GetManagedAppsProcExit:

    gpEvents->ClearToken();

    if ( hkRoot )
        RegCloseKey( hkRoot );

    if ( hUserToken )
        CloseHandle( hUserToken );

    return 0;
}

BOOL
SetSystemRestorePoint(
    IN  WCHAR * pwszApplicationName,
    IN OUT  PAPPCONTEXT pAppContext
    )
{
    RESTOREPOINTINFO    RestoreInfo;
    STATEMGRSTATUS      SRStatus;
    HKEY    hkInstallerPolicy;
    DWORD   CheckpointPolicy;
    DWORD   CheckpointPolicySize;
    DWORD   InstallLen, NameLen;
    DWORD   Status;
    BOOL    bStatus;

    Status = RegOpenKeyEx( 
                HKEY_LOCAL_MACHINE, 
                L"Software\\Policies\\Microsoft\\Windows\\Installer",
                0, 
                KEY_READ,
                &hkInstallerPolicy );

    if ( Status != ERROR_SUCCESS )
        return FALSE;

    CheckpointPolicy = 0;
    CheckpointPolicySize = sizeof(CheckpointPolicy);

    (void) RegQueryValueEx( 
                hkInstallerPolicy,
                L"LimitSystemRestoreCheckpointing",
                NULL, 
                NULL,
                (LPBYTE) &CheckpointPolicy,
                &CheckpointPolicySize );

    RegCloseKey( hkInstallerPolicy );

    if ( CheckpointPolicy != 0 )
        return FALSE;

    if ( ! LoadLoadString() )
        return FALSE;

    Status = (*pfnLoadStringW)( ghDllInstance, IDS_INSTALLED, RestoreInfo.szDescription, sizeof(RestoreInfo.szDescription) / sizeof(WCHAR) );
    if ( 0 == Status )
        return FALSE;

    pAppContext->pLoadSfc = new CLoadSfc( Status );

    if ( Status != ERROR_SUCCESS )
    {
        delete pAppContext->pLoadSfc;
        pAppContext->pLoadSfc = 0;
    }

    if ( ! pAppContext->pLoadSfc )
        return FALSE;

    RestoreInfo.dwEventType = BEGIN_NESTED_SYSTEM_CHANGE;
    RestoreInfo.dwRestorePtType = APPLICATION_INSTALL;
    RestoreInfo.llSequenceNumber = 0;

    InstallLen = lstrlen(RestoreInfo.szDescription);
    NameLen = lstrlen(pwszApplicationName);

    if ( InstallLen + NameLen >= MAX_DESC_W )
    {
        lstrcpyn( &RestoreInfo.szDescription[InstallLen], pwszApplicationName, MAX_DESC_W - InstallLen - 1 );
        RestoreInfo.szDescription[MAX_DESC_W - 1] = 0;
    }
    else 
    {
        HRESULT hr;
        hr = StringCchCopy( &RestoreInfo.szDescription[InstallLen], MAX_DESC_W,pwszApplicationName );
        if (FAILED(hr)) 
        {
            return FALSE;
        }
    }

    bStatus = (*gpfnSRSetRetorePointW)( &RestoreInfo, &SRStatus );

    if ( bStatus )
        pAppContext->SRSequence = SRStatus.llSequenceNumber;

    return bStatus;
}

void
CheckLocalCall(
    IN  handle_t hRpc
    )
{
    UINT    Type;
    DWORD   Status;

    Status = I_RpcBindingInqTransportType( hRpc, &Type);

    if ( (Status != RPC_S_OK) ||
         (Type != TRANSPORT_TYPE_LPC) )
        RpcRaiseException( ERROR_ACCESS_DENIED );
}


WCHAR*
GetGpoNameFromGuid( 
    IN PGROUP_POLICY_OBJECT pGpoList,
    IN GUID* pGpoGuid
    )
{
    PGROUP_POLICY_OBJECT pNextGpo;
    WCHAR                wszTargetGuid[MAX_SZGUID_LEN];
    WCHAR*               pszPolicyName;
    
    pszPolicyName = NULL;

    (void) GuidToString(
        *pGpoGuid,
        wszTargetGuid);

    while (pGpoList) 
    {
        pNextGpo = pGpoList->pNext;
    
        if ( lstrcmpi(
            pGpoList->szGPOName,
            wszTargetGuid) == 0 )
        {
            pszPolicyName = pGpoList->lpDisplayName;
            break;
        }

        pGpoList = pNextGpo;
    }

    return pszPolicyName;
}

DWORD
GetPlatformCompatibleCOMClsCtx( 
    DWORD Architecture,
    DWORD dwClsCtx
    )
{
    if ( (PROCESSOR_ARCHITECTURE_AMD64 == Architecture) ||
         (PROCESSOR_ARCHITECTURE_IA64 == Architecture) )
    {
        //
        // On 64-bit, if we have any inproc server contexts, we need to
        // ensure that we specifically ask for 64-bit inproc servers
        //
        if ( dwClsCtx & CLSCTX_INPROC )
        {
            DWORD dwInproc64;

            dwInproc64 = 0;
                
            if ( dwClsCtx & CLSCTX_INPROC_SERVER )
            {
                dwInproc64 |= CLSCTX64_INPROC_SERVER;
            }

            if ( dwClsCtx & CLSCTX_INPROC_HANDLER )
            {
                dwInproc64 |= CLSCTX64_INPROC_HANDLER;
            }

            //
            // Now remove the standard inproc bits, which are interpreted
            // as 32-bit inproc
            //
            dwClsCtx &= ~CLSCTX_INPROC;

            //
            // Add in the 64-bit inproc bits that we support
            //
            dwClsCtx |= dwInproc64;
        }
    }
    
    return dwClsCtx;
}

    
void
LogRsopInstallData( 
    CManagedAppProcessor* pManApp,
    CAppInfo*             pAppInfo
    )
{
    HRESULT hr;

    if ( ! pManApp->GetRsopContext()->IsRsopEnabled() )
    {
        return;
    }

    hr = pManApp->GetRsopContext()->GetExclusiveLoggingAccess( NULL == pManApp->UserToken() );

    //
    // If the call above failed, rsop will be disabled so we have nothing to do
    //
    if ( FAILED(hr) )
    {
        return;
    }

    //
    // First log the installed application
    //
    pManApp->AppList().WriteAppToRsopLog( pAppInfo );

    //
    // Now write all the removal entries
    //
    pManApp->AppList().WriteLog( CAppList::RSOP_FILTER_REMOVALSONLY );

    //
    // Since we have installed an app, the resultant set has changed, so
    // update the RSoP version to ensure that we detect the change if 
    // we roam to another machine
    //
    (void) pManApp->GetRsopContext()->WriteCurrentRsopVersion( pManApp->AppmgmtKey() );

    (void) pManApp->GetRsopContext()->ReleaseExclusiveLoggingAccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\appinfo.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Appinfo.cxx
//
//*************************************************************

#include "appmgext.hxx"


//
// CAppInfo
//

// Initialization from the Directory.
CAppInfo::CAppInfo(
    CManagedAppProcessor * pManApp,
    PACKAGEDISPINFO *   pPackageInfo,
    BOOL                bDemandInstall,
    BOOL &              bStatus
    ) 
{
    _pManApp = pManApp;
    _DemandInstall = bDemandInstall;

    _DeploymentId = pPackageInfo->PackageGuid;

    bStatus = Initialize( pPackageInfo );

    if ( ! bStatus )
        DebugMsg((DM_WARNING, IDS_APPINFO_FAIL, pPackageInfo->pszPackageName));
}

// Initialization from the registry.
CAppInfo::CAppInfo(
    CManagedAppProcessor * pManApp,
    WCHAR *             pwszDeploymentId,
    BOOL &              bStatus
    )
{
    _pManApp = pManApp;
    _DemandInstall = FALSE;

    StringToGuid( pwszDeploymentId, &_DeploymentId );

    _StatusList.Reset();

    bStatus = Initialize( NULL );

    if ( ! bStatus )
        DebugMsg((DM_WARNING, IDS_LOCALAPPINFO_FAIL, pwszDeploymentId));
}

// Initialization from a local script file.
CAppInfo::CAppInfo(
     WCHAR *             pwszDeploymentId
    )
{
    _pManApp = 0;
    StringToGuid( pwszDeploymentId, &_DeploymentId );
    (void) Initialize( NULL );
}

BOOL
CAppInfo::Initialize(
    PACKAGEDISPINFO *   pPackageInfo
    )
{
    HKEY    hkApp;
    WCHAR   wszDeploymentId[44];
    DWORD   Length;
    DWORD   Size;
    DWORD   n, i;
    DWORD   Status;
    WCHAR*  wszSomId;
    HRESULT hr;

    _pwszDeploymentName = 0;
    _pwszGPOId = 0;
    _pwszGPOName = 0;
    _pwszSOMId = 0;
    _pwszGPODSPath = 0;
    _pwszProductId = 0;
    _pwszLocalScriptPath = 0;
    _pwszGPTScriptPath = 0;
    _Upgrades = 0;
    _pUpgrades = 0;
    _Overrides = 0;
    _pOverrides = 0;
    _pwszSupercededIds = 0;
    _pwszPublisher = 0;
    _pwszSupportURL = 0;
    _VersionHi = 0;
    _VersionLo = 0;
    _PathType = DrwFilePath;
    memset( &_USN, 0, sizeof(_USN) );
    _LangId = LANG_NEUTRAL;
    _LanguageWeight = 0;
    _AssignCount = 0;
    _LocalRevision = 0;
    memset( &_ScriptTime, 0, sizeof(_ScriptTime) );
    _DirectoryRevision = 0;
    _InstallUILevel = INSTALLUILEVEL_DEFAULT;
    _ActFlags = 0;
    _InstallState = INSTALLSTATE_UNKNOWN;
    _State = 0;
    _Action = ACTION_NONE;
    _Status = ERROR_SUCCESS;
    _bNeedsUnmanagedRemove = FALSE;
    _rgSecurityDescriptor = 0;
    _cbSecurityDescriptor = 0;
    _bSuperseded = FALSE;
    _bRollback = FALSE;
    _bRemovalLogged = FALSE;
    _bTransformConflict = FALSE;
    _bRestored = FALSE;
    _rgwszTransforms = NULL;
    _rgwszCategories = NULL;
    _cTransforms = 0;
    _cCategories = 0;
    _pwszPackageLocation = 0;
    _pwszRemovingDeploymentId = 0;
    _cArchitectures = 0;
    _rgArchitectures = NULL;
    _PrimaryArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
    _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE;
    _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_NONE;
    _bSupersedesAssigned = FALSE;
    _dwUserApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE;
    _wszDemandSpec = NULL;
    _wszDemandProp = NULL;

    if ( ! _pManApp )
        return FALSE;

    Status = ERROR_SUCCESS;

    Length = lstrlen( _pManApp->LocalScriptDir() );

    _pwszLocalScriptPath = new WCHAR[Length + 44];
    if ( ! _pwszLocalScriptPath )
        return FALSE;

    hr = StringCchCopy( _pwszLocalScriptPath, Length+44, _pManApp->LocalScriptDir() );
    if (FAILED(hr)) 
    {
        delete [] _pwszLocalScriptPath;
        return FALSE;
    }
    GuidToString( _DeploymentId, &_pwszLocalScriptPath[Length] );
    hr = StringCchCopy( &_pwszLocalScriptPath[Length+GUIDSTRLEN], 44-GUIDSTRLEN,L".aas" );
    if (FAILED(hr)) 
    {
        delete [] _pwszLocalScriptPath;
        return FALSE;
    }

    if ( CRsopAppContext::REMOVAL == _pManApp->GetRsopContext()->GetContext() )
    {
        _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_USER;
    }
    else if ( _pManApp->GetRsopContext()->RemoveGPOApps() )
    {
        _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS;
    }

    if ( pPackageInfo )
    {
        CGPOInfo*     pGpoInfo;
        CGPOInfoList& GpoInfoList = _pManApp->GPOList();

        _VersionHi = pPackageInfo->dwVersionHi;
        _VersionLo = pPackageInfo->dwVersionLo;

        _LangId = pPackageInfo->LangId;
        _LanguageWeight = GetLanguagePriority(LANGIDFROMLCID(pPackageInfo->LangId),pPackageInfo->dwActFlags);

        _pwszGPTScriptPath = StringDuplicate( pPackageInfo->pszScriptPath );
        if ( ! _pwszGPTScriptPath && !(_pManApp->ARPList()))
            return FALSE;

        _pwszDeploymentName = StringDuplicate( pPackageInfo->pszPackageName );

        GuidToString( pPackageInfo->ProductCode, &_pwszProductId );
        GuidToString( pPackageInfo->GpoId, &_pwszGPOId );

        if ( _pwszGPOId )
        {
            pGpoInfo = GpoInfoList.Find( _pwszGPOId );

            _pwszGPOName = StringDuplicate( pGpoInfo ? pGpoInfo->GetGPOName() : L"" );
        }

        _pwszPublisher = StringDuplicate( pPackageInfo->pszPublisher );
        _pwszSupportURL = StringDuplicate( pPackageInfo->pszUrl );

        if ( _pManApp->GetRsopContext()->IsRsopEnabled() || _pManApp->ARPList() )
            Status = InitializeCategoriesList( pPackageInfo );

        if ( (ERROR_SUCCESS == Status ) &&
             _pManApp->GetRsopContext()->IsRsopEnabled() )
        {
            //
            // We perform RSoP specific initialization here.  Note that if
            // any of these fails, we disable RSoP, but continue policy
            // application.  Any partial initialization due to an
            // error will be cleaned up by the destructor
            //
            _pwszSOMId = StringDuplicate( pGpoInfo ? pGpoInfo->GetSOMPath() : L"" );

            //
            // Make copies of RSoP specific simple string data
            //

            if ( pPackageInfo->cbSecurityDescriptor )
            {
                _rgSecurityDescriptor = new BYTE[ pPackageInfo->cbSecurityDescriptor ];

                if ( _rgSecurityDescriptor && pPackageInfo->rgSecurityDescriptor )
                {
                    _cbSecurityDescriptor = pPackageInfo->cbSecurityDescriptor;
                    memcpy( _rgSecurityDescriptor, pPackageInfo->rgSecurityDescriptor, pPackageInfo->cbSecurityDescriptor );
                }
            }

            _pwszGPODSPath = StringDuplicate( pPackageInfo->pszGpoPath );

            //
            // Check for memory allocation failures
            //
            if ( ! _pwszSOMId || ! _pwszGPODSPath )
            {
                Status = ERROR_OUTOFMEMORY;
            }

            //
            // Now make copies of the more complex RSoP information
            //
            if ( ERROR_SUCCESS == Status )
                Status = InitializeRSOPTransformsList( pPackageInfo );

            if ( ERROR_SUCCESS == Status )
                Status = InitializeRSOPArchitectureInfo( pPackageInfo );

            if ( ERROR_SUCCESS != Status )
            {
                hr = HRESULT_FROM_WIN32( Status );

                _pManApp->GetRsopContext()->DisableRsop( hr );                
            }
        }

        for ( n = 0; n < pPackageInfo->cUpgrades; n++ )
        {
            if ( pPackageInfo->prgUpgradeInfoList[n].Flag & (UPGFLG_Uninstall | UPGFLG_NoUninstall) )
                _Upgrades++;
        }

        if ( _Upgrades > 0 )
        {
            _pUpgrades = new UPGRADE_INFO[_Upgrades];

            if ( ! _pUpgrades )
                return FALSE;

            memset( _pUpgrades, 0, sizeof(UPGRADE_INFO) * _Upgrades );

            for ( n = 0, i = 0; n < pPackageInfo->cUpgrades; n++ )
            {
                if ( ! (pPackageInfo->prgUpgradeInfoList[n].Flag & (UPGFLG_Uninstall | UPGFLG_NoUninstall)) )
                    continue;

                _pUpgrades[i].DeploymentId = pPackageInfo->prgUpgradeInfoList[n].PackageGuid;
                _pUpgrades[i].Flags = UPGRADE_OVER;
                if ( pPackageInfo->prgUpgradeInfoList[n].Flag & UPGFLG_Uninstall )
                    _pUpgrades[i].Flags |= UPGRADE_UNINSTALL;
                else
                    _pUpgrades[i].Flags |= UPGRADE_NOUNINSTALL;
                i++;
            }
        }

        memcpy( &_USN, &pPackageInfo->Usn, sizeof(_USN) );
        _DirectoryRevision = pPackageInfo->dwRevision;
        _InstallUILevel = pPackageInfo->InstallUiLevel;
        _PathType = pPackageInfo->PathType;
        _ActFlags = pPackageInfo->dwActFlags;
    }

    GuidToString( _DeploymentId, wszDeploymentId);

    if ( ERROR_SUCCESS == Status )
    {
        if ( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            //
            // Need to request set value access so that we may
            // delete the RemovedGPOState value if it exists -- because of this
            // we must revert since the user may not have write access
            // 
            (void) _pManApp->Revert();

            Status = RegOpenKeyEx(
                _pManApp->AppmgmtKey(),
                wszDeploymentId,
                0,
                KEY_READ | KEY_SET_VALUE, 
                &hkApp );

            DWORD impStatus = _pManApp->Impersonate();
            if ( impStatus != ERROR_SUCCESS )
            {
                Status = impStatus;
            }
        }
        else
        {
            Status = ERROR_FILE_NOT_FOUND;
        }
    }

    if (  ERROR_SUCCESS == Status )
    {
        Size = sizeof(DWORD);

        _State = APPSTATE_PUBLISHED | APPSTATE_POLICYREMOVE_ORPHAN;

        (void) RegQueryValueEx(
                    hkApp,
                    APPSTATEVALUE,
                    0,
                    NULL,
                    (LPBYTE) &_State,
                    &Size );

        Size = sizeof(DWORD);

        //
        // This is used to track the best case time when we could completely
        // delete an appmgmt key after an app is unassigned.
        //
        (void) RegQueryValueEx(
                    hkApp,
                    ASSIGNCOUNTVALUE,
                    0,
                    NULL,
                    (LPBYTE) &_AssignCount,
                    &Size );

        Size = sizeof(DWORD);

        //
        // Beta2 systems didn't write this value.  If it is not found we
        // just use the default value of 0.
        //
        (void) RegQueryValueEx(
                    hkApp,
                    REVISIONVALUE,
                    0,
                    NULL,
                    (LPBYTE) &_LocalRevision,
                    &Size );

        if ( _LocalRevision > 0 )
        {
            Size = sizeof(_ScriptTime);

            (void) RegQueryValueEx(
                        hkApp,
                        SCRIPTTIMEVALUE,
                        0,
                        NULL,
                        (LPBYTE) &_ScriptTime,
                        &Size );
        }

        if ( ! pPackageInfo )
        {
            //
            // This is needed so that if we are in a RemoveApp call in the service
            // we will get the proper UI level to write back for an assigned app.
            //
            Size = sizeof(DWORD);
            (void) RegQueryValueEx(
                        hkApp,
                        INSTALLUI,
                        0,
                        NULL,
                        (LPBYTE) &_InstallUILevel,
                        &Size );

            ReadStringValue( hkApp, DEPLOYMENTNAMEVALUE, &_pwszDeploymentName );
            ReadStringValue( hkApp, GPONAMEVALUE, &_pwszGPOName );
            ReadStringValue( hkApp, GPOIDVALUE, &_pwszGPOId );
            ReadStringValue( hkApp, PRODUCTIDVALUE, &_pwszProductId );
        }

        //
        // During policy refresh, we need to ensure that apps that went out of
        // scope on one machine don't come back on another
        //
        if ( (ERROR_SUCCESS == Status ) &&
             _pManApp->RegularPolicyRun() )
        {
            DWORD dwRemovedState;
            LONG  StatusRemovedState;

            Size = sizeof(DWORD);

            //
            // Check for an appstate saved if the app went out of scope
            //
            StatusRemovedState = RegQueryValueEx(
                hkApp,
                REMOVEDGPOSTATE,
                0,
                NULL,
                (LPBYTE) &dwRemovedState,
                &Size );

            if ( ERROR_SUCCESS == StatusRemovedState )
            {
                BOOL bDeleteRemovedState;

                bDeleteRemovedState = FALSE;

                //
                // We only restore the old app state if this app is currently
                // set to be uninstalled or orphaned -- if not, this removed state is invalid
                // so we will delete it
                //
                if ( ! ( ( APPSTATE_UNINSTALLED & _State ) || ( APPSTATE_ORPHANED & _State ) ) )
                {
                    bDeleteRemovedState = TRUE;
                }
                else if ( pPackageInfo || IsGpoInScope() )
                {
                    //
                    // The gpo for this app is back in scope, we will restore the state
                    // to the previous state before it went out of scope on the other machine
                    //
                    _State = dwRemovedState;

                    bDeleteRemovedState = TRUE;

                    Size = sizeof(DWORD);

                    //
                    // Set the state value back to the original state
                    //
                    (void) RegSetValueEx(
                        hkApp,
                        APPSTATEVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &dwRemovedState,
                        sizeof(DWORD) );

                    _bRestored = TRUE;

                    DebugMsg((DM_VERBOSE, IDS_ABORT_SCOPELOSS, _pwszDeploymentName ? _pwszDeploymentName : L"" , _pwszGPOName ? _pwszGPOName : L"", _State ));
                }
            
                if ( bDeleteRemovedState )
                {
                    (void) RegDeleteValue( hkApp, REMOVEDGPOSTATE );
                }
            }
        }

        //
        // If the app is currently assigned, treat that as the reason for it being applied.
        // This may be overridden later if this app upgrades another
        //
        if ( ! ( APPSTATE_UNINSTALLED & _State ) && ( APPSTATE_ASSIGNED & _State ) )
        {
            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED;
        }

        ReadStringValue( hkApp, SUPERCEDEDIDS, &_pwszSupercededIds );

        RegCloseKey( hkApp );
    }

    CheckScriptExistence();

    if ( ! _pwszDeploymentName ||
         ! _pwszGPOId ||
         ! _pwszGPOName ||
         ! _pwszProductId )
        return FALSE;

    return TRUE;
}

CAppInfo::~CAppInfo()
{

    //
    // There are cases, like handling upgrades, where we copy the script
    // early on to ensure that we can access it.  Later however, the same
    // app may be reset to do nothing or may fail to apply.  This check here
    // deletes any script we copied which we don't need now.
    //
    if ( ((_Status != ERROR_SUCCESS) || (ACTION_NONE == _Action)) &&
         ! (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) &&
         ((_State & APPSTATE_SCRIPT_NOT_EXISTED) && (_State & APPSTATE_SCRIPT_PRESENT)) )
    {
        if ( _pwszLocalScriptPath )
            DeleteFile( _pwszLocalScriptPath );
    }

    DWORD iCategory;

    for ( iCategory = 0; iCategory < _cCategories; iCategory++ )
    {
        delete [] _rgwszCategories[ iCategory ];
    }

    DWORD iTransform;

    for ( iTransform = 0; iTransform < _cTransforms; iTransform++ )
    {
        delete [] _rgwszTransforms[ iTransform ];
    }

    CAppStatus* pAppStatus;

    //
    // Clean up failure statuses
    //
    for ( 
        _StatusList.Reset();
        pAppStatus = (CAppStatus*) _StatusList.GetCurrentItem();
        )
    {
        _StatusList.MoveNext();
        delete pAppStatus;
    }

    delete [] _pwszDeploymentName;
    delete [] _pwszGPOName;
    delete [] _pwszGPOId;
    delete [] _pwszSOMId;
    delete [] _pwszGPODSPath;
    delete [] _pwszProductId;
    delete [] _pwszLocalScriptPath;
    delete [] _pwszGPTScriptPath;
    delete [] _pUpgrades;
    delete [] _pOverrides;
    delete [] _pwszSupercededIds;
    delete [] _pwszPublisher;
    delete [] _pwszSupportURL;
    delete [] _rgSecurityDescriptor;
    delete [] _rgwszCategories;
    delete [] _rgwszTransforms;
    delete [] _pwszPackageLocation;
    delete [] _pwszRemovingDeploymentId;
    delete [] _rgArchitectures;
    delete [] _wszDemandSpec;
}

DWORD
CAppInfo::InitializePass0()
{
    UPGRADE_INFO *  pUpgradeInfo;

    if ( ! (_ActFlags & (ACTFLG_Assigned | ACTFLG_Published)) &&
         ! (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        return ERROR_SUCCESS;

    if ( ! _pManApp->ARPList() && (_State & APPSTATE_SCRIPT_EXISTED) )
        _InstallState = (*gpfnMsiQueryProductState)( _pwszProductId );

    for ( DWORD n = 0; n < _Upgrades; n++ )
    {
        CAppInfo *  pBaseApp;

        if ( ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
            continue;

        //
        // Note that an apps' override list will include apps it really will not
        // upgrade because of policy precedence violation.  However, we keep these
        // in the list for our detection of upgrade relationships when doing
        // demand installs.
        //
        AddToOverrideList( &_pUpgrades[n].DeploymentId );

        pBaseApp = _pManApp->AppList().Find( _pUpgrades[n].DeploymentId );

        if ( ! pBaseApp )
            continue;

        pUpgradeInfo = new UPGRADE_INFO[pBaseApp->_Upgrades + 1];
        if ( ! pUpgradeInfo )
        {
            _Status = ERROR_OUTOFMEMORY;
            return ERROR_OUTOFMEMORY;
        }
        memcpy( pUpgradeInfo, pBaseApp->_pUpgrades, pBaseApp->_Upgrades * sizeof(UPGRADE_INFO) );

        _pUpgrades[n].pBaseApp = pBaseApp;

        if ( _pManApp->GPOList().Compare( _pwszGPOId, pBaseApp->_pwszGPOId ) >= 0 )
        {
            //
            // A valid upgrade of the base app.  We set a backlink upgrade entry
            // for the base app.
            //
            pUpgradeInfo[pBaseApp->_Upgrades].DeploymentId = _DeploymentId;
            pUpgradeInfo[pBaseApp->_Upgrades].Flags = (_pUpgrades[n].Flags & ~UPGRADE_OVER) | UPGRADE_BY;
            pUpgradeInfo[pBaseApp->_Upgrades].pBaseApp = this;
        }
        else
        {
            //
            // An invalid upgrade of the base app because it reverses policy
            // precedence.  We null out this' upgrade link and set a new
            // upgrade link for the base app.  The base app becomes the upgrade
            // app.  The upgrade is forced only if the base app is assigned.
            //
            // Note that the base app will set a backlink for 'this' in it's own
            // InitializePass0 since we process apps from least to highest
            // precedence.
            //
            
            //
            // We preserve the upgrade data for 'this', but remove the forward link flag
            // so that it will not be considered to upgrade anything else. We need to
            // preserve it so that RSoP logging will be able to log the fact that this
            // application upgrades another app
            //
            _pUpgrades[n].Flags &= ~UPGRADE_OVER;
            _pUpgrades[n].pBaseApp = NULL;

            pUpgradeInfo[pBaseApp->_Upgrades].DeploymentId = _DeploymentId;
            pUpgradeInfo[pBaseApp->_Upgrades].Flags = UPGRADE_UNINSTALL | UPGRADE_OVER | UPGRADE_REVERSED;
            if ( pBaseApp->_ActFlags & ACTFLG_Assigned )
                pUpgradeInfo[pBaseApp->_Upgrades].Flags |= UPGRADE_FORCE;
            pUpgradeInfo[pBaseApp->_Upgrades].pBaseApp = this;

            DebugMsg((DM_VERBOSE, IDS_UPGRADE_REVERSE, _pwszDeploymentName, _pwszGPOName, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName));
        }

        delete pBaseApp->_pUpgrades;
        pBaseApp->_pUpgrades = pUpgradeInfo;
        pBaseApp->_Upgrades++;
    }

    return ERROR_SUCCESS;
}

void
CAppInfo::SetActionPass1()
{
    //
    // First pass for setting this app's processing actions.  In pass1 we set
    // an initial state based solely on the individual app, disregarding at this
    // time any interaction with other apps being applied as part of the policy
    // run.
    //

    if ( _pManApp->ARPList() )
    {
        if ( (_ActFlags & (ACTFLG_Assigned | ACTFLG_Published)) && (_ActFlags & ACTFLG_UserInstall) )
        {        
            SetAction(
                ACTION_INSTALL,
                APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                NULL);
        }
        return;
    }

    if ( _DemandInstall )
    {
        SetAction(
            ACTION_APPLY,
            APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
            NULL);
    }

    if ( _pManApp->NoChanges() )
    {
        if ( _State & APPSTATE_ASSIGNED )
        {
            //
            // User assigned apps are always readvertised.
            // Machine assigned apps get readvertised if uninstalled outside of the scope
            // of appmgmt (policy/ARP).
            //
            if ( _pManApp->IsUserPolicy() || ! AppPresent(_InstallState) )
            {
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED,
                    NULL);

                _State |= APPSTATE_FULL_ADVERTISE;
            }
        }
        else if ( _State & APPSTATE_PUBLISHED )
        {
            if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
            {
                //
                // This is the roaming case where the app was installed on another
                // machine and the user is now logging onto a new machine.
                //
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE,
                    NULL);
            }
            else
            {
                if ( ( (INSTALLSTATE_UNKNOWN == _InstallState) || (INSTALLSTATE_ABSENT == _InstallState) ) && 
                     ! _bRestored )
                {
                    //
                    // This is the case where a published app was uninstalled via some
                    // non-mgmt mechanism like msiexec command line or the app's own
                    // configuration via ARP.  We respect this type of uninstall.
                    //
                    SetAction(
                        ACTION_ORPHAN,
                        APP_ATTRIBUTE_REMOVALCAUSE_PROFILE,
                        NULL);

                    DebugMsg((DM_VERBOSE, IDS_ORPHAN_ACTION4, _pwszDeploymentName, _pwszGPOName));
                }
            }
        }
        return;
    }

    BOOL  bUninstalled;
    DWORD dwRemovalCause;

    bUninstalled = (_ActFlags & ACTFLG_Uninstall) && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_SCRIPT_EXISTED));

    if ( bUninstalled )
    {
        dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_ADMIN;
    }
    else 
    {
        bUninstalled = (_State & APPSTATE_UNINSTALLED) && (_State & APPSTATE_SCRIPT_EXISTED);

        //
        // We now know that the app is in the uninstalled state, but the script is here, which means
        // that it was uninstalled on another machine if this is user policy.  If this app is currently 
        // assigned in the directory but uninstalled here, that means it was probably upgraded by an app 
        // on the other machine by an application that no longer applies.  In order to get this assigned 
        // base app to return, we should prevent it from being marked as uninstalled.
        //
        if ( bUninstalled && _pManApp->IsUserPolicy() && ( _ActFlags & ACTFLG_Assigned ) )
        {
            bUninstalled = FALSE;

            DebugMsg((DM_VERBOSE, IDS_ASSIGNED_NOUNINSTALL_ROAM, _pwszDeploymentName, _pwszGPOName));
        }

        if ( bUninstalled )
        {
            dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_PROFILE;
        }
    }

    if ( bUninstalled )
    {
        SetAction(
            ACTION_UNINSTALL,
            dwRemovalCause,
            NULL);
        DebugMsg((DM_VERBOSE, IDS_UNINSTALL_ACTION1, _pwszDeploymentName, _pwszGPOName));
    }

    if ( ACTION_UNINSTALL == _Action )
        return;

    if ( ((_ActFlags & ACTFLG_Orphan) && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_SCRIPT_EXISTED))) ||
         ((_State & APPSTATE_ORPHANED) && (_State & APPSTATE_SCRIPT_EXISTED)) )
    {
        SetAction(
            ACTION_ORPHAN,
            APP_ATTRIBUTE_REMOVALCAUSE_ADMIN,
            NULL);

        DebugMsg((DM_VERBOSE, IDS_ORPHAN_ACTION1, _pwszDeploymentName, _pwszGPOName));
    }

    if ( ACTION_ORPHAN == _Action )
        return;

    //
    // Only look for apply actions if no one else has yet set our status
    // explicitly through an upgrade relationship or through the service.
    //
    // Our first check is for actions to take based on information coming
    // down from the directory.
    //
    if ( ACTION_NONE == _Action )
    {
        if ( _ActFlags & ACTFLG_Assigned )
        {
            if ( (_ActFlags & ACTFLG_InstallUserAssign) && 
                 ((_State & APPSTATE_SCRIPT_NOT_EXISTED) || ! (_State & APPSTATE_INSTALL)) )
            {
                 //
                 // This is the new user assigned install option added after Windows2000.
                 // We do an install just once at each computer.  Thereafter it is treated
                 // as a regular user assignment.
                 //
                SetAction(
                    ACTION_INSTALL,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_INSTALL_ACTION2, _pwszDeploymentName, _pwszGPOName));
            }
            else if ( _pManApp->IsUserPolicy() ||
                      ((_State & APPSTATE_ASSIGNED) && ! AppPresent(_InstallState)) )
            {
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED,
                    NULL);
                _State |= APPSTATE_FULL_ADVERTISE;
                DebugMsg((DM_VERBOSE, IDS_ASSIGN1_ACTION, _pwszDeploymentName, _pwszGPOName));
            }
            else
            {
                //
                // We only do an install for a machine assigned app once.  After that
                // only a redeploy will cause any action.
                //
                if ( ! (_State & APPSTATE_ASSIGNED) )
                {
                    SetAction(
                        ACTION_INSTALL,
                        APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED,
                        NULL);

                    DebugMsg((DM_VERBOSE, IDS_INSTALL_ACTION1, _pwszDeploymentName, _pwszGPOName));
                }
            }
        }

        //
        // We only apply published apps if we're logging onto a machine where
        // the published app has not yet been applied.
        //
        // If the script for the published app exists on the machine then it
        // was likely uninstalled via a means we do not detect, so we now
        // orphan it.
        //
        if ( (_ActFlags & ACTFLG_Published) && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        {
            if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
            {
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_ASSIGN3_ACTION, _pwszDeploymentName, _pwszGPOName));
            }
            else if ( _bRestored )
            {
                //
                // This is the roaming case where the app was uninstalled on another
                // machine because its gpo went out of scope, but on this machine
                // that gpo is in scope, so it needs to be readvertised since the
                // advertise data was removed on the other machine
                //
                
                //
                // Note that We set the apply cause value to none which will later force us
                // to generate an apply cause that takes into account the apply cause
                // currently in the rsop database.  Since we do not know at this time what is
                // stored in RSoP, we cannot know the correct apply cause so we defer this
                // to the time at which we're accessing the database for logging.
                //
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_ASSIGN5_ACTION, _pwszDeploymentName, _pwszGPOName));
            }
            else
            {
                if ( (INSTALLSTATE_UNKNOWN == _InstallState) || (INSTALLSTATE_ABSENT == _InstallState) )
                {
                    //
                    // This is the case where a published app was uninstalled via some
                    // non-mgmt mechanism like msiexec command line or the app's own
                    // configuration via ARP.  We respect this type of uninstall.
                    //
                    SetAction(
                        ACTION_ORPHAN,
                        APP_ATTRIBUTE_REMOVALCAUSE_USER,
                        NULL);

                    DebugMsg((DM_VERBOSE, IDS_ORPHAN_ACTION4, _pwszDeploymentName, _pwszGPOName));
                }
                else
                {
                    DebugMsg((DM_VERBOSE, IDS_NONE_ACTION1, _pwszDeploymentName, _pwszGPOName));
                }
            }
        }
    }

    if ( ACTION_NONE == _Action )
    {
        //
        // Three types of apps will still be at ACTION_NONE here :
        //   + Published apps we already have on the machine
        //   + Disabled apps -> (ACTFLG_Assigned | ACTFLG_Published) is not set
        //   + Apps which "disappear" from our policy set because of ACLs
        //     on the app's deployment properties (not GPO ACLs, that would
        //     cause a removal of the entire GPO)
        //
        // We want to do appropriate orphaning actions only for the last
        // case.  The first two classes of apps are simply left alone.  Note
        // that if an app is explicitly removed-orphan, we know this
        // because it still comes down from the Directory with the
        // ACTFLG_Orphan flag set.
        //
        // We detect the third case with a zero _ActFlag, which means the app
        // was not found in the Directory.
        //
        if ( (0 == _ActFlags) && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        {
            if ( _State & APPSTATE_POLICYREMOVE_UNINSTALL )
            {
                SetAction(
                    ACTION_UNINSTALL,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_UNINSTALL_ACTION2, _pwszDeploymentName, _pwszGPOName));
            }
            else
            {
                SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    NULL);
                
                DebugMsg((DM_VERBOSE, IDS_ORPHAN_ACTION3, _pwszDeploymentName, _pwszGPOName));
            }

            _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS;

            return;
        }
    }

    //
    // Check if we have to do a reinstall because of a patch on the install
    // image.  Note, we only go to this state if the app is already
    // installed on this machine.
    //
    // Note, the Darwin msi database is only cached at install time, so
    // if the app is only advertised, we will always pull down the most recent
    // msi when the install is invoked.
    //
    // Also, the INSTALLSTATE_DEFAULT covers both the INSTALLSTATE_LOCAL and
    // INSTALLSTATE_SOURCE.
    //
    if ( (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) &&
         (_State & APPSTATE_SCRIPT_EXISTED) &&
         (_DirectoryRevision > 0) )
    {
        CAppInfo *      pScriptInfo;

        if ( _LocalRevision < _DirectoryRevision )
        {
            SetAction(
                ACTION_REINSTALL,
                APP_ATTRIBUTE_APPLYCAUSE_VALUE_REDEPLOY,
                NULL);

            DebugMsg((DM_VERBOSE, IDS_REINSTALL_ACTION1, _pwszDeploymentName, _pwszGPOName));
        }
        else
        {
            pScriptInfo = _pManApp->ScriptList().Find( _DeploymentId );

            if ( CompareFileTime( &pScriptInfo->_ScriptTime, &_ScriptTime ) < 0 )
            {
                SetAction(
                    ACTION_REINSTALL,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_REDEPLOY,
                    NULL);

                if ( DebugLevelOn(DM_VERBOSE) )
                {
                    SYSTEMTIME  LocalTime;
                    SYSTEMTIME  SysvolTime;
                    WCHAR       wszLocalTime[32];
                    WCHAR       wszSysvolTime[32];

                    FileTimeToSystemTime( &pScriptInfo->_ScriptTime, &LocalTime );
                    FileTimeToSystemTime( &_ScriptTime, &SysvolTime );

                    (void) StringCchPrintf(
                        wszLocalTime,
                        sizeof(wszLocalTime)/sizeof(wszLocalTime[0]),
                        L"%02d-%02d %02d:%02d:%02d:%03d",
                        LocalTime.wMonth,
                        LocalTime.wDay,
                        LocalTime.wHour,
                        LocalTime.wMinute,
                        LocalTime.wSecond,
                        LocalTime.wMilliseconds );

                    (void) StringCchPrintf(
                        wszSysvolTime,
                        sizeof(wszSysvolTime)/sizeof(wszSysvolTime[0]),
                        L"%02d-%02d %02d:%02d:%02d:%03d",
                        SysvolTime.wMonth,
                        SysvolTime.wDay,
                        SysvolTime.wHour,
                        SysvolTime.wMinute,
                        SysvolTime.wSecond,
                            SysvolTime.wMilliseconds );

                    DebugMsg((DM_VERBOSE, IDS_REINSTALL_ACTION2, _pwszDeploymentName, _pwszGPOName, wszLocalTime, wszSysvolTime));
                }
            }
        }
    }
}

void
CAppInfo::SetActionPass2()
{
    //
    // In pass two we do product id filtering based on language and policy
    // precedence.
    //

    //
    // In reporting mode, we perform no processing, all apps that currently
    // apply (i.e. all apps in the gpo)  will be logged
    //
    if ( _pManApp->GetRsopContext()->IsReportingModeEnabled() )
    {
        return;
    }

    if ( (ACTION_UNINSTALL == _Action) || (ACTION_ORPHAN == _Action) )
        return;

    //
    // When creating the list of apps to show in ARP we want to include
    // the highest precedence assigned app (if one exists) and all
    // published apps from higher precedence policies then the one that
    // the (optional) assigned app has come from.  Thus if there are no
    // assigned apps with the product code, we would show the published
    // apps from all policies.
    //
    // This is done simply by not allowing published apps to filter out
    // any lower precedence apps.
    //
    if ( _pManApp->ARPList() && (_ActFlags & ACTFLG_Published) )
        return;

    //
    // Published apps which we already have on the machine will never be
    // set to apply again.  However, we still want them to override lower
    // precedence products (even assigned) that have the same product id.
    // So the below check causes the logic to continue as long as 'this'
    // app has already been applied on this machine.
    //
    // Note that we check for the assigned state as well because it could
    // be getting changed to published in this run of policy.
    //
    if ( (ACTION_NONE == _Action) && ! (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        return;

    //
    // If multiple apps of the same product id are set to be assigned or
    // installed, only assign/install the one in the closest GPO.  This is
    // usefull when the app is deployed with a different set of transforms
    // in the different GPOs.  Darwin will only honor one set of transforms.
    //

    //
    // We do this pass in the NoChanges case to enforce the product code
    // filtering logic.
    //

    CAppInfo *  pAppInfo;
    DWORD       n;
    BOOL        bPastThis;
    BOOL        bAnalyzeForRsopOnly;

    bPastThis = FALSE;
    bAnalyzeForRsopOnly = FALSE;

    for ( _pManApp->AppList().Reset(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem();
          pAppInfo;
          _pManApp->AppList().MoveNext(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem() )
    {
        if ( pAppInfo == this )
        {
            bPastThis = TRUE;
            continue;
        }


        //
        // Once we're past 'this' we need to start checking if we should
        // stop processing.  We don't want to supercede an app with the
        // same product id which is of higher precedence.
        //
        // When not constructing the ARP list of apps, we stop once
        // past 'this'.  The most recently deployed app will win ties in
        // that case.
        //
        // When constructing the ARP list of apps, we keep on looking at other
        // apps until we encounter a new policy or an assigned app.  That is
        // because we want to treat all published apps in a policy equally,
        // but an assigned app acts as a blocking point.
        //
        if ( bPastThis )
        {
            if ( lstrcmpi( pAppInfo->_pwszGPOId, _pwszGPOId ) != 0 )
                break;

            if ( ! _pManApp->ARPList() )
                break;
            else if ( pAppInfo->_ActFlags & ACTFLG_Assigned )
                bAnalyzeForRsopOnly = TRUE;
        }

        if ( (ACTION_ORPHAN == pAppInfo->_Action) || (ACTION_UNINSTALL == pAppInfo->_Action) )
            continue;

        if ( (ACTION_NONE == pAppInfo->_Action) &&
             ! (pAppInfo->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) &&
             ! (pAppInfo->_ActFlags & (ACTFLG_Assigned | ACTFLG_Published)) )
            continue;

        if ( lstrcmpi( pAppInfo->_pwszProductId, _pwszProductId ) != 0 )
            continue;

        //
        // One important exception to product code filtering is when there are
        // upgrades.  We don't do any filtering in that case.  It doesn't matter
        // whether this is an "upgrade by" or "upgrade over" upgrade.
        //
        for ( n = 0; n < _Upgrades; n++ )
        {
            if ( _pUpgrades[n].pBaseApp == pAppInfo )
                break;
        }

        if ( n < _Upgrades )
            continue;

        //
        // Now we know we want to override the lower precedence app so we
        // set it to orphan.  We don't want to do an uninstall, if a
        // tranform conflict requires this, that will be detected later.
        // Note that if the lower precedence app is not already present on
        // the machine then it's action will be changed to ACTION_NONE in
        // Pass4.  But we still set it to ACTION_ORPHAN here so that none of
        // it's upgrade settings will be applied in it's Pass3.
        //
        // Within a single GPO, language match takes precedence over last
        // modified time.
        //
        if ( (pAppInfo->_LanguageWeight > _LanguageWeight) && (0 == lstrcmpi( pAppInfo->_pwszGPOId, _pwszGPOId )) )
        {
            if ( ! bAnalyzeForRsopOnly )
            {
                SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    pAppInfo);
                DebugMsg((DM_VERBOSE, IDS_UNDO3_ACTION, _pwszDeploymentName, _pwszGPOName, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
            }                

            (void) pAppInfo->UpdatePrecedence( this, APP_ATTRIBUTE_REASON_VALUE_LANGUAGE );

            bAnalyzeForRsopOnly = TRUE;
        }
        else
        {
            if ( ! bAnalyzeForRsopOnly )
            {
                pAppInfo->SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT,
                    this);

                DebugMsg((DM_VERBOSE, IDS_UNDO6_ACTION, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));
            }

            (void) UpdatePrecedence( pAppInfo, APP_ATTRIBUTE_REASON_VALUE_PRODUCT );
        }
    }

    _pManApp->AppList().ResetEnd();
}

void
CAppInfo::SetActionPass3()
{
    static const UCHAR PolicyForceBaseNone[BASE_STATE_CHOICES][UPGRADE_STATE_CHOICES] =
        {
        {  NO,  NO,  NO,  NO },
        { SPECIAL1, SPECIAL1,  NO,  NO },
        {  NO,  NO,  NO,  NO },
        {  NO,  NO,  NO,  NO }
        };
    static const UCHAR PolicyForceUpgradeNone[BASE_STATE_CHOICES][UPGRADE_STATE_CHOICES] =
        {
        {  NO,  NO,  NO,  NO },
        { SPECIAL2, SPECIAL2,  NO,  NO },
        { YES, SPECIAL2,  NO,  NO },
        { YES, SPECIAL2,  NO,  NO }         };
    static const UCHAR PolicyApplyUpgrade[BASE_STATE_CHOICES][UPGRADE_STATE_CHOICES] =
        {
        {  NO,  NO,  NO,  NO },
        {  NO,  NO, YES, YES },
        {  NO,  SPECIAL1, YES, YES },
        {  NO,  SPECIAL1, YES, YES }
        };
    static const UCHAR ARPForceBaseNone[BASE_STATE_CHOICES][UPGRADE_STATE_CHOICES] =
        {
        { SPECIAL1, SPECIAL1, YES, YES },
        {  NO,  NO, YES, YES },
        {  NO,  NO, YES, YES },
        {  NO,  NO, YES, YES }
        };

    //
    // In pass three, we may modify this app's or other app's action based upon
    // upgrade relationships between the set of apps in a policy run.
    //

    //
    // In reporting mode, we perform no processing, all apps that currently
    // apply (i.e. all apps in the gpo)  will be logged
    //
    if ( _pManApp->GetRsopContext()->IsReportingModeEnabled() )
    {
        return;
    }

    if ( _pManApp->NoChanges() )
        return;

    if ( ! _Upgrades )
        return;

    BOOL bAnalyzeForRsopOnly;

    bAnalyzeForRsopOnly = FALSE;

    if ( (ACTION_UNINSTALL == _Action) || (ACTION_ORPHAN == _Action) )
    {
        //
        // Even if this app is not applied, we want to be sure that
        // it doesn't have some upgrades
        //
        if ( _pManApp->GetRsopContext()->IsRsopEnabled() )
        {
            bAnalyzeForRsopOnly = TRUE;
        }
        else
        {
            return;
        }
    }

    if ( ! (_ActFlags & (ACTFLG_Assigned | ACTFLG_Published)) )
        return;

    for ( DWORD n = 0; n < _Upgrades; n++ )
    {
        CAppInfo *  pBaseApp;
        DWORD       BaseIndex;
        DWORD       UpgradeIndex;
        BOOL        bBasePresent;
        BOOL        bBaseToApply;
        BOOL        bUpgradePresent;
        BOOL        bUpgradeForced;
        BOOL        bUpgradeToApply;
        BOOL        bApplyUpgrade;

        if ( ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
            continue;

        pBaseApp = _pUpgrades[n].pBaseApp;

        if ( ! pBaseApp )
            continue;

        //
        // Notes about the state settings :
        //
        // BasePresent should be set to FALSE if the app is set to be unmanaged and the
        // upgrade is not forced.  This is to ensure the if the upgrade app is assigned
        // it will be applied.  Likewise, if the upgrade is forced then we want to treat
        // the base app as present if it was currently managed.  That is to ensure that
        // the upgrade will apply even if the base app is already set to be removed.
        //

        // 
        // Four conditions under which an upgrade is forced :
        // 1. During an install from ARP or fileext/clsid activation.
        // 2. If the app is configured to force it's upgrades.
        // 3. If the upgrade link was reversed because of policy precedence (see InitializePass0)
        // 4. Whenever an app is restored after a profile sync problem (see CManagedAppProcessor::GetLostApps)
        //
        bUpgradeForced = _DemandInstall || 
                         (_ActFlags & ACTFLG_ForceUpgrade) || 
                         (_pUpgrades[n].Flags & UPGRADE_FORCE) ||
                         (_State & APPSTATE_RESTORED);

        bBasePresent = ( pBaseApp->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED) );

        if ( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            if ( ! bUpgradeForced && ((ACTION_ORPHAN == pBaseApp->_Action) || (ACTION_UNINSTALL == pBaseApp->_Action)) )
                bBasePresent = FALSE;
        }
        else if ( CRsopAppContext::POLICY_REFRESH == _pManApp->GetRsopContext()->GetContext() ) 
        {
            if ( ! ( ( _ActFlags & ACTFLG_Assigned ) && ! ( pBaseApp->_ActFlags & ACTFLG_Assigned ) ) )
            {
                bBasePresent = TRUE;
            }
            else
            {
                bBasePresent = FALSE;
            }
        }

        if ( _pManApp->ARPList() )
            bBaseToApply = pBaseApp->_State & APPSTATE_ASSIGNED;
        else
            bBaseToApply = (ACTION_APPLY == pBaseApp->_Action) || (ACTION_INSTALL == pBaseApp->_Action);

        bUpgradePresent = _State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED);

        if ( _pManApp->ARPList() )
            bUpgradeToApply = _State & APPSTATE_ASSIGNED;
        else
            bUpgradeToApply = (ACTION_APPLY == _Action) || (ACTION_INSTALL == _Action);

        if ( _pManApp->GetRsopContext()->IsPlanningModeEnabled() &&
             ( CRsopAppContext::ARPLIST == _pManApp->GetRsopContext()->GetContext() ) )
        {
            if ( ( _ActFlags & ACTFLG_Assigned ) && ! ( pBaseApp->_ActFlags & ACTFLG_Assigned ) )
            {
                bUpgradeToApply = TRUE;
                bUpgradePresent = TRUE;
            }
        }

        DebugMsg((DM_VERBOSE, IDS_UPGRADE_INFO, _pwszDeploymentName, _pwszGPOName, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName, bBasePresent, bBaseToApply, bUpgradePresent, bUpgradeToApply, bUpgradeForced));

        if ( bBasePresent )
            BaseIndex = bBaseToApply ? BASE_STATE_PRESENT_APPLY : BASE_STATE_PRESENT_NOTAPPLY;
        else
            BaseIndex = bBaseToApply ? BASE_STATE_ABSENT_APPLY : BASE_STATE_ABSENT_NOTAPPLY;

        if ( bUpgradeForced )
            UpgradeIndex = bUpgradeToApply ? UPGRADE_STATE_FORCED_APPLY : UPGRADE_STATE_FORCED_NOTAPPLY;
        else
            UpgradeIndex = bUpgradeToApply ? UPGRADE_STATE_NOTFORCED_APPLY : UPGRADE_STATE_NOTFORCED_NOTAPPLY;

        //
        // In the case where we are constructing the list to show in ARP, the
        // only decision is whether to hide the base app.
        //
        if ( _pManApp->ARPList() )
        {
            if ( (YES == ARPForceBaseNone[BaseIndex][UpgradeIndex]) ||
                 ((SPECIAL1 == ARPForceBaseNone[BaseIndex][UpgradeIndex]) && bUpgradePresent) )
            {
                if ( ! bAnalyzeForRsopOnly )
                {
                    DebugMsg((DM_VERBOSE, IDS_UNDO4_ACTION, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));

                    pBaseApp->SetAction(
                        ACTION_NONE,
                        APP_ATTRIBUTE_REMOVALCAUSE_NONE,
                        this);
                }

                (void) UpdatePrecedence( pBaseApp, APP_ATTRIBUTE_REASON_VALUE_UPGRADE );
            }
            continue;
        }

        //
        // The rest of this code executes when we are running policy in winlogon
        // or when doing a demand install.
        //

        if ( (YES == PolicyForceBaseNone[BaseIndex][UpgradeIndex]) ||
             ((SPECIAL1 == PolicyForceBaseNone[BaseIndex][UpgradeIndex]) && bUpgradePresent) )
        {
            if ( ! bAnalyzeForRsopOnly )
            {
                DebugMsg((DM_VERBOSE, IDS_UNDO1_ACTION, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));
                
                pBaseApp->SetAction(
                    ACTION_NONE,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                    this);
            }
        }

        if ( (YES == PolicyForceUpgradeNone[BaseIndex][UpgradeIndex]) ||
             ((SPECIAL2 == PolicyForceUpgradeNone[BaseIndex][UpgradeIndex]) && ! bUpgradePresent) )
        {
            if ( ! bAnalyzeForRsopOnly )
            {
                DebugMsg((DM_VERBOSE, IDS_UNDO2_ACTION, _pwszDeploymentName, _pwszGPOName, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName));
                SetAction(
                    ACTION_NONE,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                    pBaseApp);
            }

            (void) pBaseApp->UpdatePrecedence( this, APP_ATTRIBUTE_REASON_VALUE_NONFORCEDUPGRADE );
        }

        bApplyUpgrade = (YES == PolicyApplyUpgrade[BaseIndex][UpgradeIndex]) ||
                        ((SPECIAL1 == PolicyApplyUpgrade[BaseIndex][UpgradeIndex]) && bUpgradePresent);

        if ( ! bApplyUpgrade )
        {
            if ( _pManApp->GetRsopContext()->IsPlanningModeEnabled() && 
                 ( CRsopAppContext::POLICY_REFRESH == _pManApp->GetRsopContext()->GetContext() ) &&
                 ( ( ACTION_APPLY == _Action ) || ( ACTION_INSTALL == _Action ) ) )
            {
                UpdatePrecedence( pBaseApp, APP_ATTRIBUTE_REASON_VALUE_UPGRADE );
            }

            continue;
        }

        //
        // At this point we know that this upgrade relationship is set to be
        // applied.
        //
        (void) UpdatePrecedence( pBaseApp, APP_ATTRIBUTE_REASON_VALUE_UPGRADE );

        if ( _pManApp->GetRsopContext()->IsRsopEnabled() )
        {
            if ( bBasePresent )
            {
                _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_UPGRADE;
            }
        }

        //
        // If we are only here to ensure that we get all the upgrades for RSoP,
        // we should leave now since we know that the upgrade is enforced
        //
        if ( bAnalyzeForRsopOnly )
        {
            return;
        }

        //
        // Make sure a full advertise is done for the new app during user policy
        // processing.  
        // We don't want this for machine policy, user assign full install option
        // nor ARP since the install action will follow in that case.
        //
        if ( _pManApp->IsUserPolicy() && ! (_ActFlags & ACTFLG_InstallUserAssign) && ! _DemandInstall )
            _State |= APPSTATE_FULL_ADVERTISE;

        //
        // This is for the case when the new upgrade app is published.
        //
        if ( ACTION_NONE == _Action )
        {
            SetAction(
                ACTION_APPLY,
                APP_ATTRIBUTE_APPLYCAUSE_VALUE_UPGRADE,
                NULL);

            DebugMsg((DM_VERBOSE, IDS_ASSIGN4_ACTION, _pwszDeploymentName, _pwszGPOName));
        }

        if ( ! bBasePresent )
        {

            DebugMsg((DM_VERBOSE, IDS_UNDO4_ACTION, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));
            pBaseApp->_Action = ACTION_NONE;
            continue;
        }

        if ( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            //
            // Before we start setting the upgrade apps' states, we need to make
            // sure that we can get the new app's script from the sysvol.  Because
            // of replication issues, it's possible the script may not be available
            // on the DC we bind to.  We don't want to undo the upgraded apps until
            // we know we'll be able to apply the new one.
            //
            _Status = CopyScriptIfNeeded();
            
            if ( _Status != ERROR_SUCCESS )
            {
                //
                // This may seem strange, but logging all three of these events provides
                // the proper context of the error.  This is how a failed upgrade would
                // normally be logged, but in this case the error occurs so early we
                // abort before the normal set of processing is performed that would log
                // the other events.  We want to stop early to prevent doing unnecessary
                // uninstalls.
                //
                gpEvents->Upgrade( this, pBaseApp, _pUpgrades[n].Flags & UPGRADE_UNINSTALL );
                gpEvents->Assign( _Status, this );
                gpEvents->UpgradeAbort( _Status, this, pBaseApp, FALSE );
            
                SetAction(
                    ACTION_NONE,
                    _dwApplyCause,
                    NULL);

                pBaseApp->_bRollback = TRUE;

                return;
            }
        }

        _pUpgrades[n].Flags |= UPGRADE_APPLIED;

        if ( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            if ( _pUpgrades[n].Flags & UPGRADE_UNINSTALL )
            {
                pBaseApp->SetAction(
                    ACTION_UNINSTALL,
                    APP_ATTRIBUTE_REMOVALCAUSE_UPGRADE,
                    this);

                gpEvents->Upgrade( this, pBaseApp, TRUE );
            }
            else // _pUpgrades[n].Flags & UPGRADE_NOUNINSTALL
            {
                pBaseApp->SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_UPGRADE,
                    this);

                gpEvents->Upgrade( this, pBaseApp, FALSE );
            }
        }
    }
}

void
CAppInfo::SetActionPass4()
{
    //
    // In pass four we look for various cases of simultaneous advertise and
    // unadvertise of the same product or other action states that need
    // slight changes based on all of the inter-deployment processing we've
    // finished.
    //

    //
    // In reporting mode, we perform no processing, all apps that currently
    // apply (i.e. all apps in the gpo)  will be logged
    //
    if ( _pManApp->GetRsopContext()->IsReportingModeEnabled() )
    {
        return;
    }

    //
    // If this product is to be assigned, check if the same product is being
    // uninstalled now as well.  If so, we switch this app to be applied async,
    // so that it will get assigned again after the uninstall action.
    //

    CAppInfo *  pAppInfo;

    //
    // If an app is set to orphan, but we don't even have it in the registry,
    // then we can just fall back to do nothing.
    // This can happen for upgrades of assigned apps that were previously
    // applied.
    //
    if ( ACTION_ORPHAN == _Action )
    {
        if ( ! (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_SCRIPT_EXISTED)) )
        {
            SetAction(
                ACTION_NONE,
                APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                NULL);

            DebugMsg((DM_VERBOSE, IDS_NONE_ACTION2, _pwszDeploymentName, _pwszGPOName));
        }
    }

    for ( _pManApp->AppList().Reset(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem();
          pAppInfo;
          _pManApp->AppList().MoveNext(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem() )
    {
        if ( pAppInfo == this )
            break;

        if ( lstrcmpi( pAppInfo->_pwszProductId, _pwszProductId ) != 0 )
            continue;

        //
        // When the lower precedent app is set to be uninstalled, we switch it
        // to orphan if the higher precedent app is already on the machine.
        // This holds even if the higher precedent app is set to be orphaned
        // or uninstalled.
        //
        if ( ACTION_UNINSTALL == pAppInfo->_Action )
        {
            if ( _State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED) )
            {
                DebugMsg((DM_VERBOSE, IDS_UNDO5_ACTION, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));

                pAppInfo->SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT,
                    this);
            }
        }
    }

    _pManApp->AppList().ResetEnd();
}


void
CAppInfo::SetAction(
    APPACTION AppAction,
    DWORD     Reason,
    CAppInfo* pAppCause
    )
{
    _Action = AppAction;

    if ( ( _Action == ACTION_APPLY ) ||
         ( _Action == ACTION_INSTALL ) ||
         ( _Action == ACTION_REINSTALL) )
    {
        _dwApplyCause = Reason;

    }
    else if ( ( _Action == ACTION_ORPHAN ) ||
              ( _Action == ACTION_UNINSTALL ) )
    {
        _dwRemovalCause = Reason;

        if ( pAppCause )
        {
            HRESULT hr;

            hr = SetRemovingDeploymentId( &(pAppCause->_DeploymentId) );

            if ( FAILED( hr ) )
            {
                _pManApp->GetRsopContext()->DisableRsop( hr );
            }
        }
    }
    else
    {
        _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_NONE;
        _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE;
    }
}

DWORD
CAppInfo::ProcessApplyActions()
{
    DWORD   n;
    DWORD   ScriptFlags;

    if ( _Status != ERROR_SUCCESS )
        return _Status;

    switch ( _Action )
    {
    case ACTION_NONE :
        //
        // If policy has changed, then we want to rewrite our state even for apps
        // which we have but which are not set to apply.  This is to update any
        // settings like UI level or orphan/uninstall at policy removal.
        //
        if ( ! _pManApp->NoChanges() && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
            (void) Assign( 0, FALSE, TRUE );
        break;
    case ACTION_APPLY :
        //
        // Note that apply actions can be processed during an async refresh, as long as they
        // do not lead to an install
        //
    case ACTION_INSTALL :
    case ACTION_REINSTALL :
        BOOL bUpgradeComplete;

        bUpgradeComplete = FALSE;

        if ( ! _DemandInstall )
        {
            //
            // Before applying an app which is an upgrade of something
            // already on the machine, we make sure that all necessary actions
            // on the old apps completed successfully.  If there were any errors in
            // the uninstalls, then the upgrade app is not applied.
            // Upgrade processed through ARP actions are transacted differently
            // since they involve an install of the new app, so this does not
            // apply in that case.
            //
            for ( n = 0; n < _Upgrades; n++ )
            {
                if ( ! _pUpgrades[n].pBaseApp || ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
                    continue;

                // Abort and fail if any of the upgraded app removals failed.
                if ( _pUpgrades[n].pBaseApp->_Status != ERROR_SUCCESS )
                {
                    DWORD retStatus = RollbackUpgrades();
                    if ( retStatus == ERROR_SUCCESS )
                    {
                        retStatus = _pUpgrades[n].pBaseApp->_Status;
                    }
                    return retStatus;
                }

                // Remember if any of the base apps were actually present.
                if ( _pUpgrades[n].pBaseApp->_State & (APPSTATE_PUBLISHED | APPSTATE_ASSIGNED) )
                    bUpgradeComplete = TRUE;
            }
        }

        ScriptFlags = 0;

        //
        // Reinstalls require recopying the script file because the msi
        // data may have been modified in a way which changes the script
        // data.
        // Also check for a first time advertise where we need to update
        // the registry stored script time.
        //
        if ( (ACTION_REINSTALL == _Action) ||
             ((_DirectoryRevision > 0) && (0 == _ScriptTime.dwLowDateTime) && (0 == _ScriptTime.dwHighDateTime)) )
        {
            WIN32_FIND_DATA FindData;
            HANDLE  hFind;

            hFind = FindFirstFile( _pwszGPTScriptPath, &FindData );
            if ( INVALID_HANDLE_VALUE == hFind )
            {
                _Status = GetLastError();
                gpEvents->Reinstall( _Status, this );
                return _Status;
            }

            FindClose( hFind );
            _ScriptTime = FindData.ftLastWriteTime;

            if ( ACTION_REINSTALL == _Action )
            {
                // This will force the script to be recopied.
                _State &= ~APPSTATE_SCRIPT_PRESENT;

                //
                // Force a full readvertise for assigned apps.  This catches handles cases where the app
                // is only in an advertised state.
                //
                if ( _ActFlags & ACTFLG_Assigned )
                    ScriptFlags = SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO;
            }
        }

        //
        // Determine whether this app will require uninstall of an
        // existing unmanaged version of the same application -- note that
        // this call must be made while impersonating
        //
        _bNeedsUnmanagedRemove = RequiresUnmanagedRemoval();

        if ( _Action != ACTION_REINSTALL )
            _Status = Assign( ScriptFlags, TRUE, TRUE );
        else
            _Status = Assign( ScriptFlags, TRUE, FALSE );

        if ( ERROR_INSTALL_TRANSFORM_FAILURE == _Status )
        {
            DebugMsg((DM_VERBOSE, IDS_INSTALL_TRANSFORM, _pwszDeploymentName, _pwszGPOName));
            _State |= APPSTATE_TRANSFORM_CONFLICT;

            _bTransformConflict = TRUE;

            //
            // Though we are not really doing an install, the uninstall is an operation
            // we are performing in order to apply this new deployment of the app.  We
            // don't want to scare the user into thinking their app is being
            // totally nuked. So in this case we actually put up the install message.
            //
            _pManApp->LogonMsgInstall( _pwszDeploymentName );
            _Status = Uninstall();

            if ( ERROR_SUCCESS == _Status )
            {
                _Status = Assign();
            }

            _pManApp->LogonMsgApplying();
        }
        else if ( ERROR_SUCCESS != _Status )
        {
            //
            // Ensure that we record an event in this case
            // so RSoP will associate an error with this application
            //
            if ( _Action == ACTION_REINSTALL )
            {
                gpEvents->Assign( _Status, this );
            }
        }

        //
        // If a script is not present, we should check for an unmanaged version of the app if it's going to be applied,
        // since we will want to reinstall if this app is not configured to remove unmanaged installs
        // of the same app.
        //
        // This can also happen if the application temporarily goes out of scope on this machine
        // due to wql filtering or security group filtering, and then comes back into scope.
        //

        //
        // Note that we do this now rather than in SetActions because we want to wait until
        // all unapply actions have taken place before we make this decision
        //
        if ( ! _DemandInstall &&
             ( ACTION_APPLY == _Action || ACTION_INSTALL == _Action ) &&
             ( _State & APPSTATE_SCRIPT_NOT_EXISTED ) && 
             ! _bNeedsUnmanagedRemove )
        {
            DWORD InstallState;

            //
            // We must query the install state since we normally only query
            // the install state when the script exists
            //
            InstallState = gpfnMsiQueryProductState( _pwszProductId );

            if ( ( INSTALLSTATE_DEFAULT == InstallState )  || 
                 ( INSTALLSTATE_LOCAL == InstallState ) ) 
            {
                SetAction(
                    ACTION_REINSTALL,
                    _dwApplyCause,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_REINSTALL_ACTION3, _pwszDeploymentName, _pwszGPOName));
            }
        }

        if ( ERROR_SUCCESS == _Status )
        {
            if ( ACTION_INSTALL == _Action )
            {
                _pManApp->LogonMsgInstall( _pwszDeploymentName );
                _Status = Install();
                _pManApp->LogonMsgApplying();
            }
            else if ( ACTION_REINSTALL == _Action )
            {
                //
                // Note that in the redeploy case, the full reinstall is needed only if the app
                // has already been installed once on this machine.
                // We want to check for any unmanaged install instance, so don't use
                // _InstallState here.
                //
                if ( INSTALLSTATE_DEFAULT == (*gpfnMsiQueryProductState)( _pwszProductId ) )
                {
                    _pManApp->LogonMsgInstall( _pwszDeploymentName );
                    _Status = Reinstall();
                    _pManApp->LogonMsgApplying();
                }

                // 
                // Make sure to do this even if we didn't attempt a reinstall so that 
                // any new properites of the app get written to our local key.
                //
                if ( ERROR_SUCCESS == _Status )
                    _Status = Assign( 0, FALSE, TRUE );
            }
        }

        if ( (ACTION_INSTALL == _Action) && 
             (_Status != ERROR_SUCCESS) && 
             (_State & APPSTATE_SCRIPT_NOT_EXISTED) )
        {
            //
            // Try to rollback the failed install
            //
            Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO, TRUE );
        }

        if ( bUpgradeComplete )
        {
            if ( _Status != ERROR_SUCCESS )
            {
                // Ignoring result from RollbackUpgrades since it does not modify _Status, which 
                //  will be returned by this function and is not equal to ERROR_SUCCESS to begin with.
                (void) RollbackUpgrades();
                break;
            }

            for ( n = 0; n < _Upgrades; n++ )
            {
                if ( ! _pUpgrades[n].pBaseApp || ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
                    continue;

                if ( _pUpgrades[n].pBaseApp->_State & (APPSTATE_PUBLISHED | APPSTATE_ASSIGNED) )
                    gpEvents->UpgradeComplete( this, _pUpgrades[n].pBaseApp );
            }
        }
        break;
    case ACTION_UNINSTALL :
    case ACTION_ORPHAN :
        break;
    }

    return _Status;
}

DWORD
CAppInfo::ProcessUnapplyActions()
{
    if ( _Status != ERROR_SUCCESS )
        return _Status;

    switch ( _Action )
    {
    case ACTION_NONE :
    case ACTION_APPLY :
    case ACTION_INSTALL :
    case ACTION_REINSTALL :
        break;
    case ACTION_UNINSTALL :

        //
        // During async refreshes, we will not process any unapply actions as that
        // would be disruptive to the user.  This also prevents rip n replace upgrades,
        // since an unapply action is required for the base app and this will set the error
        // for the base app so that the upgrade app is not assigned.
        //
        if ( _pManApp->Async() )
        {
            DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));
        
            _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
            
            break;
        }

        if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
        {
            INSTALLSTATE InstallState;

            //
            // This is a bizarre scenario possible with a roaming profile.
            // It's possible we may be getting the uninstall action for the
            // first time while logging onto a machine where an assignment of
            // the app has never been done.
            // In that case we make our best effort to remove advertise data that
            // may be in the profile.  We don't want to do any uninstall action
            // here since we never performed an install action.  Note we don't
            // use SCRIPTFLAG_REGDATA_APPINFO because class registrations don't
            // roam.  If we can't get the script to do the unadvertise, we continue
            // and unmanage the app.
            //

            //
            // Note that we only want to unadvertise if the app is in the
            // advertised state or not present -- otherwise, we may trash
            // an unmanaged version of the app, or a managed version of the application
            // with the same product id.  We check the install state below -- we must 
            // call the api to do this since our _InstallState member is only initialized
            // when the script exists, and in this case we know it does not
            //
            InstallState = (*gpfnMsiQueryProductState)( _pwszProductId );

            if ( ( INSTALLSTATE_ADVERTISED == InstallState ) ||
                 ( INSTALLSTATE_ABSENT == InstallState ) )
            {
                //
                // Artifically bump up the ref count since an assignment was never done
                // on this machine.
                //
                if ( _pManApp->IsUserPolicy() )
                    _AssignCount++;

                if ( ERROR_SUCCESS == CopyScriptIfNeeded() )
                    _Status = Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS, FALSE );
            }
        }
        else
        {
            _pManApp->LogonMsgUninstall( _pwszDeploymentName );
            _Status = Uninstall( FALSE );
            _pManApp->LogonMsgApplying();

            //
            // If an app is only advertised, then an uninstall will fail with
            // ERROR_INSTALL_SOURCE_ABSENT if the original package source (msi)
            // can not be accessed.  This is because the msi is not cached until
            // install time.
            // Uninstall will also fail if the package has been disallowed through
            // software restriction policies.
            // In these cases, we just need to undo the rest of the advertise that
            // we did originally.
            //
            if ( (INSTALLSTATE_ADVERTISED == _InstallState) && 
                 ((ERROR_INSTALL_SOURCE_ABSENT == _Status) ||
                  (ERROR_INSTALL_PACKAGE_REJECTED == _Status) ||
                  (ERROR_INSTALL_TRANSFORM_REJECTED == _Status) ||
                  (ERROR_INSTALL_TRANSFORM_FAILURE == _Status)) )
            {
                _Status = Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO, FALSE );
            }

            if ( ERROR_SUCCESS != _Status )
            {
                gpEvents->Uninstall( _Status, this );
            }
        }

        //
        // On success we can finally remove our own internal state info
        // about this apps.
        //
        if ( ERROR_SUCCESS == _Status )
            _Status = Unassign();
        break;
    case ACTION_ORPHAN :

        //
        // Artifically bump up the ref count since an assignment was never done
        // on this machine.
        //
        if ( (_State & APPSTATE_SCRIPT_NOT_EXISTED) && _pManApp->IsUserPolicy() )
            _AssignCount++;

        _Status = Unassign();

        break;
    }

    return _Status;
}

DWORD
CAppInfo::ProcessTransformConflicts()
{
    //
    // For RSoP, we need to say which apps were uninstalled due
    // to transform conflicts
    //

    //
    // Since the uninstall was performed as part of installing an app
    // in PRocessApplyActions (upon receiving ERROR_INSTALL_TRANSFORM_FAILURE 
    // from MsiAdvertiseScript), any installed apps would have had the same
    // product id and therefore would have been marked to uninstall in a
    // previous pass
    //

    //
    // So first we check to see if this app encountered a transform
    // conflict when it was installed
    //
    if ( _bTransformConflict )
    {
        //
        // Now look for any application with the same product id marked
        // as being removed due to product conflict:
        //
        CAppInfo* pAppInfo;

        for ( _pManApp->AppList().Reset(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem();
              pAppInfo;
              _pManApp->AppList().MoveNext(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem() )
        {
            //
            // Check to see if the current app was removed due to product conflict
            //
            if ( APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT != pAppInfo->_dwRemovalCause )
                continue;

            //
            // See if the current app's product id matches
            //
            if ( lstrcmpi( pAppInfo->_pwszProductId, _pwszProductId ) != 0 )
                continue;

            //
            // Since this app had a product conflict with the current app,
            // it had to have been uninstalled as part of installing this app,
            // so we note this
            //
            pAppInfo->_dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_TRANSFORM;
        }

        _pManApp->AppList().ResetEnd();
    }

    return ERROR_SUCCESS;
}

DWORD
CAppInfo::CopyToManagedApplication(
    MANAGED_APP * pManagedApp
    )
{
    DWORD cbApplication;

    LONG Error;

    Error = ERROR_SUCCESS;

    //
    // Copy guid data
    //
    StringToGuid(_pwszGPOId, &(pManagedApp->GpoId));
    StringToGuid(_pwszProductId, &(pManagedApp->ProductId));

    //
    // Copy simple data
    //
    pManagedApp->dwVersionHi = _VersionHi;
    pManagedApp->dwVersionLo = _VersionLo;
    pManagedApp->dwRevision = _LocalRevision;
    pManagedApp->Language = _LangId;
    pManagedApp->pszOwner = NULL;
    pManagedApp->pszCompany = NULL;
    pManagedApp->pszComments = NULL;
    pManagedApp->pszContact = NULL;

    //
    // Copy information about the application type -- do
    // a translation from com pathtype constants to Win32
    // constants.
    //
    switch ( _PathType )
    {
    case DrwFilePath:
        pManagedApp->dwPathType = MANAGED_APPTYPE_WINDOWSINSTALLER;
        break;

    case SetupNamePath:
        pManagedApp->dwPathType = MANAGED_APPTYPE_SETUPEXE;
        break;

    default:
        pManagedApp->dwPathType = MANAGED_APPTYPE_UNSUPPORTED;
    }

    pManagedApp->bInstalled = ((_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) != 0);

    //
    // Copy string data
    //

    if (_pwszDeploymentName)
    {
        pManagedApp->pszPackageName = MidlStringDuplicate(_pwszDeploymentName);

        if (!(pManagedApp->pszPackageName))
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (_pwszGPOName)
    {
        pManagedApp->pszPolicyName = MidlStringDuplicate(_pwszGPOName);

        if (!(pManagedApp->pszPolicyName))
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (_pwszPublisher)
    {
        pManagedApp->pszPublisher = MidlStringDuplicate(_pwszPublisher);

        if (!(pManagedApp->pszPublisher))
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (_pwszSupportURL)
    {
        pManagedApp->pszSupportUrl = MidlStringDuplicate(_pwszSupportURL);

        if (!(pManagedApp->pszSupportUrl))
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

cleanup:

    if (ERROR_SUCCESS != Error)
    {
        ClearManagedApp( pManagedApp );
    }

    return Error;
}

BOOL
CAppInfo::HasCategory(
    WCHAR * pwszCategory
    )
{
    for ( DWORD n = 0; n < _cCategories; n++ )
    {
        if ( 0 == lstrcmp( _rgwszCategories[n], pwszCategory ) )
            return TRUE;
    }

    return FALSE;
}

DWORD
CAppInfo::Assign(
    DWORD   ScriptFlags,    // = 0
    BOOL    bDoAdvertise,   // = TRUE
    BOOL    bAddAppData    // = TRUE
    )
{
    HKEY    hkApp;
    WCHAR   wszDeploymentId[40];
    DWORD   AppState;
    DWORD   Status;
    BOOL    bAdvertised;
    BOOL    bUnmanageUninstall;

    //
    // For async refreshes, We do not want to perform any assignments that are destined to
    // lead to installs since that would disrupt the user.  However, pure advertisements
    // are ok -- they cause minimal disruption and no loss of user functionality
    //
    if ( _pManApp->Async() )
    {
        if ( ( ACTION_INSTALL == _Action ) ||
             ( ACTION_REINSTALL == _Action ) )
        {
            DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

            _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
            
            Status = _Status;

            goto ReportStatus;
        }
    }

    Status = ERROR_SUCCESS;

    bAdvertised = FALSE;
    bUnmanageUninstall = FALSE;

    GuidToString( _DeploymentId, wszDeploymentId );

    if ( ! bDoAdvertise )
        goto SaveAppData;

    DebugMsg((DM_VERBOSE, IDS_ASSIGN, _pwszDeploymentName, _pwszGPOName));

    Status = CopyScriptIfNeeded();

    if ( (Status != ERROR_SUCCESS) && bDoAdvertise && bAddAppData )
    {
        gpEvents->Assign( Status, this );
        return Status;
    }

    //
    // Do this before determining script flags because an uninstall will cause
    // the app state to change.
    //
    Status = EnforceAssignmentSecurity( &bUnmanageUninstall );

    //
    // Note that we check the error status for the call above below -- we
    // do not overwrite the status if it is an error.  Better code arrangement
    // is called for here, but we are making the smallest change since an
    // issue with this was found at the end of xpsp1
    //

    if ( 0 == ScriptFlags )
    {
        //
        // Apps which are installed on demand (ARP, shell/com activation) only
        // have the Darwin product registry keys advertised.
        // This is all we need to make the MsiConfigureProduct call in the
        // client work and ensure that if the install must be rolled back, we
        // get back to the true previous state of the machine.
        //
        // The icons/transforms have to be included in any first time advertise
        // because of some bizarre design in Darwin.  If we don't advertise
        // it then the app's shorcuts will not have icons even after the install.
        // For subsequent advertises we don't include the icons/transforms because
        // this is a very expensive part of advertisement because it extracts and
        // re-creates icons from the script file.  [Removed 12/23/98, we'll see
        // if Darwin handles this correctly now].
        //
        // During policy runs we advertise shortcuts for previously advertised
        // assigned apps.
        //
        // For published apps which we're applying for the first time on a machine
        // we just advertise the config data.  Note that the only time a published
        // app is advertised as part of a policy run is for the roaming profile
        // scenario where the app has never been applied to the machine we're now on.
        // We don't want to advertise shorcuts nor class data in this case because
        // only a subset of the product's features may have been installed on the
        // original machine.  We want to preserve this feature state.
        //
        // The very first time an assigned app is assigned to a machine we will also
        // advertise the shell class data.  But since this is quite heavy
        // weight, we only do it the first time.  If it is ever lost somehow,
        // a miss on this info will result in a DS query and install anyway.
        //

        ScriptFlags = SCRIPTFLAGS_REGDATA_CNFGINFO;

        if ( (_State & APPSTATE_SCRIPT_NOT_EXISTED) || ! AppPresent(_InstallState) )
        {
            ScriptFlags |= SCRIPTFLAGS_CACHEINFO;

            //
            // Now we decide whether or not to validate the transform list
            //
            // MsiAdvertiseScript incorrectly detects transform conflicts between a user
            // and machine installed version of the same application, so we
            // only validate transforms for user policy if the application is already 
            // in a non absent state per-user.  A transform conflict cannot
            // be possible in that case despite what MsiAdvertiseScript claims.
            //
            // We check for the application's presence below -- note that we can't use
            // the _InstallState member since it is not guaranteed to be set when
            // we reach this point.
            //
            // Note : all this code was also added for a win2k-sp3, and xpsp1 fix.
            //
            BOOL    bValidateTransforms = TRUE;

            if ( _pManApp->IsUserPolicy() )
            {
                INSTALLSTATE    InstallState = (*gpfnMsiQueryProductState)( _pwszProductId );
                WCHAR           wszBuffer[8];
                DWORD           Size = sizeof(wszBuffer) / sizeof(WCHAR);

                if ( AppPresent(InstallState) )
                {
                    //
                    // Be sure to use a new error status here so we don't
                    // overwrite the existing status which should be checked later
                    //

                    DWORD ProductInfoStatus;

                    ProductInfoStatus = (*gpfnMsiGetProductInfo)(
                                _pwszProductId,
                                INSTALLPROPERTY_ASSIGNMENTTYPE,
                                wszBuffer,
                                &Size );
                    
                    //
                    // Only if we don't already have a failure status should we overwrite
                    // the existing status -- otherwise, we will miss the failure in the
                    // call to EnforceAssignmentSecurity, which can happen when we need
                    // to uninstall an unmanaged app but we're in async refresh.  This issue
                    // was found at the end of xpsp1 and was caused when this new code was
                    // added to properly detect transform conflicts in xpsp1.  We are making
                    // the smallest change here to restore the failure path to what it was
                    // before the transform fix for xpsp1 was made.
                    //

                    if ( ERROR_SUCCESS == Status )
                    {
                        Status = ProductInfoStatus;
                    }

                    // '1' means installed per-machine
                    if ( (ERROR_SUCCESS == ProductInfoStatus) && (L'1' == wszBuffer[0]) )
                        bValidateTransforms = FALSE;                }
            }

            //
            // The application is present, so we must tell Msi to guard against transform 
            // conflicts between the existing application and the one we are trying to install
            //
            if ( ! (_State & APPSTATE_TRANSFORM_CONFLICT) && bValidateTransforms )
                ScriptFlags |= SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST;
        }

        //
        // When an unmanaged instance of the product is uninstall we need to ensure
        // that shortcuts are always added back for the managed product.
        //
        if ( bUnmanageUninstall )
            ScriptFlags |= SCRIPTFLAGS_SHORTCUTS;

        if ( ( _State & APPSTATE_FULL_ADVERTISE ) || _bRestored )
        {
            //
            // This part here means we are in a policy run in winlogon, not
            // in the service doing a demand install.  We are advertising
            // an assigned app, a published app which is an upgrade,
            // or a published app which was removed on another logon (possibly
            // another machine) because its gpo went out of scope but has
            // now come back into scope.
            //
            ScriptFlags |= SCRIPTFLAGS_SHORTCUTS;

            //
            // The first time we apply an assigned app on a machine, we do a
            // full advertise.  Otherwise, we don't advertise shell class
            // registry data and icon/transform data.
            //
            if ( (_State & APPSTATE_SCRIPT_NOT_EXISTED) || ! AppPresent(_InstallState) )
                ScriptFlags |= SCRIPTFLAGS_REGDATA_EXTENSIONINFO;
        }
    }

    if ( ! _pManApp->IsUserPolicy() )
        ScriptFlags |= SCRIPTFLAGS_MACHINEASSIGN;

    if ( ERROR_SUCCESS == Status )
    {
        DebugMsg((DM_VERBOSE, IDS_ADVERTISE, _pwszDeploymentName, _pwszLocalScriptPath, ScriptFlags));

        Status = CallMsiAdvertiseScript(
                    _pwszLocalScriptPath,
                    ScriptFlags,
                    NULL,
                    FALSE );
    }

    if ( ERROR_SUCCESS == Status )
    {
        bAdvertised = TRUE;

        if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
            _AssignCount++;
    }
    else
    {
        DebugMsg((DM_WARNING, IDS_ADVERTISE_FAIL, _pwszDeploymentName, _pwszLocalScriptPath, Status));
    }

    //
    // Abort early in this case without deleting any management data.
    // The app will be reapplied asynchronously in this case.
    //
    if ( (ACTION_APPLY == _Action) &&
         (ERROR_INSTALL_ALREADY_RUNNING == Status) )
        return Status;

    //
    // If we have a transform conflict with this app, then abort the assign
    // now without removing the app.  Callers of this routine will fix up
    // the app state and retry if appropriate.
    //
    if ( ERROR_INSTALL_TRANSFORM_FAILURE == Status )
        return Status;

SaveAppData:

    //
    // Always set this, even when bAddAppData is FALSE.  This controls the
    // UI level used for descriptor based installs from shell & com.  The
    // last writer (highest precedence app for a product id) wins.
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = RegSetValueEx(
                    _pManApp->AppmgmtKey(),
                    _pwszProductId,
                    0,
                    REG_DWORD,
                    (LPBYTE) &_InstallUILevel,
                    sizeof(DWORD) );
    }

    //
    // We only write/update our registry state if we've gotten info back down
    // from the Directory.
    //
    if ( (ERROR_SUCCESS == Status) && bAddAppData && (_ActFlags != 0) )
    {
        _pManApp->Revert();

        hkApp = 0;

        Status = RegCreateKeyEx(
                    _pManApp->AppmgmtKey(),
                    wszDeploymentId,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE,
                    NULL,
                    &hkApp,
                    NULL );

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        DEPLOYMENTNAMEVALUE,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszDeploymentName,
                        lstrlen( _pwszDeploymentName ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        GPONAMEVALUE,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszGPOName,
                        lstrlen( _pwszGPOName ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        GPOIDVALUE,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszGPOId,
                        lstrlen( _pwszGPOId ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        PRODUCTIDVALUE,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszProductId,
                        lstrlen( _pwszProductId ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( _pwszSupportURL && (ERROR_SUCCESS == Status) )
        {
            Status = RegSetValueEx(
                        hkApp,
                        SUPPORTURL,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszSupportURL,
                        lstrlen( _pwszSupportURL ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( (ERROR_SUCCESS == Status) && (_Overrides > 0) )
        {
            WCHAR * pwszSupercededIds;
            WCHAR * pwszString;

            pwszSupercededIds = new WCHAR[(_Overrides * (GUIDSTRLEN + 1)) + 1];

            if ( pwszSupercededIds )
            {
                pwszString = pwszSupercededIds;
                
                for ( DWORD n = 0; n < _Overrides; n++ )
                {
                    GuidToString( _pOverrides[n], pwszString );
                    pwszString += GUIDSTRLEN + 1;
                }
                *pwszString = 0;

                Status = RegSetValueEx(
                            hkApp,
                            SUPERCEDEDIDS,
                            0,
                            REG_MULTI_SZ,
                            (LPBYTE) pwszSupercededIds,
                            (_Overrides * (GUIDSTRLEN + 1) + 1) * sizeof(WCHAR) );

                delete [] pwszSupercededIds;
            }
            else
            {
                Status = ERROR_OUTOFMEMORY;
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        ASSIGNCOUNTVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &_AssignCount,
                        sizeof(DWORD) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        REVISIONVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &_DirectoryRevision,
                        sizeof(DWORD) );

            if ( (ERROR_SUCCESS == Status) && (_DirectoryRevision > 0) )
            {
                Status = RegSetValueEx(
                            hkApp,
                            SCRIPTTIMEVALUE,
                            0,
                            REG_BINARY,
                            (LPBYTE) &_ScriptTime,
                            sizeof(_ScriptTime) );
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        INSTALLUI,
                        0,
                        REG_DWORD,
                        (LPBYTE) &_InstallUILevel,
                        sizeof(DWORD) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            if ( _ActFlags )
            {
                AppState = 0;

                //
                // If an app becomes disabled then it gets neither the assigned
                // nor the published state bit.
                //
                if ( _ActFlags & ACTFLG_Assigned )
                    AppState |= APPSTATE_ASSIGNED;
                else if ( _ActFlags & ACTFLG_Published )
                    AppState |= APPSTATE_PUBLISHED;

                AppState |= (_ActFlags & ACTFLG_UninstallOnPolicyRemoval) ? APPSTATE_POLICYREMOVE_UNINSTALL : APPSTATE_POLICYREMOVE_ORPHAN;
                if ( _bNeedsUnmanagedRemove )
                    AppState |= APPSTATE_UNINSTALL_UNMANAGED;
                if ( _ActFlags & ACTFLG_InstallUserAssign )
                    AppState |= APPSTATE_INSTALL;
            }
            else
            {
                AppState = _State;
            }

            AppState &= APPSTATE_PERSIST_MASK;

            Status = RegSetValueEx(
                        hkApp,
                        APPSTATEVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &AppState,
                        sizeof(DWORD) );
        }

        if ( hkApp )
            RegCloseKey( hkApp );

        DWORD impStatus = _pManApp->Impersonate();
        if ( (impStatus != ERROR_SUCCESS) && (Status == ERROR_SUCCESS) )
        {
            Status = impStatus;
        }
    }

ReportStatus:

    if ( bDoAdvertise && bAddAppData )
        gpEvents->Assign( Status, this );

    //
    // If we hit an error then the destructor of this object will make sure we delete the script file so a full
    // advertise will be tried next time.
    //

    return Status;
}

DWORD
CAppInfo::Install()
{
    DWORD   Status;

    //
    // During async refreshes, we will not install an application as that
    // would be disruptive to the user
    //
    if ( ! _pManApp->Async() )
    {
        //
        // Installs can happen for machine assign apps or for user apps when there
        // are transform conflicts.
        //
        // Always set UI to NONE.
        //
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NONE, NULL );

        DebugMsg((DM_VERBOSE, IDS_INSTALL, _pwszDeploymentName, _pwszGPOName));

        Status = CallMsiConfigureProduct(
            _pwszProductId,
            INSTALLLEVEL_DEFAULT,
            INSTALLSTATE_DEFAULT,
            NULL );
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
        
        Status = _Status;
    }

    gpEvents->Install( Status, this );

    return Status;
}

DWORD
CAppInfo::Reinstall()
{
    DWORD   Status;

    //
    // For async refreshes, We do not want to reinstall an application
    // since that would disrupt the user
    //
    if ( ! _pManApp->Async() )
    {
        //
        // Reinstalls can happen when a redeploy action is specified in the SI UI.
        // This is normally done when a binary patch is applied to an application.
        //
        // Always set UI to NONE.
        //
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NONE, NULL );

        DebugMsg((DM_VERBOSE, IDS_REINSTALL, _pwszDeploymentName));

        Status = CallMsiReinstallProduct( _pwszProductId );
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
        
        Status = _Status;
    }

    gpEvents->Reinstall( Status, this );

    return Status;
}

DWORD
CAppInfo::Unassign(
    DWORD   ScriptFlags, // = 0
    BOOL    bRemoveAppData // = TRUE
    )
{
    HKEY    hkApp;
    WCHAR   wszDeploymentId[40];
    DWORD   AppState;
    DWORD   Status;

    ASSERT( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() );

    //
    // For async refreshes, We do not want to unassign an application
    // since that would disrupt the user
    //
    if ( _pManApp->Async() )
    {
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;

        if ( bRemoveAppData )
            gpEvents->Unassign( _Status, this );
        
        return _Status;
    }

    GuidToString( _DeploymentId, wszDeploymentId);

    if ( bRemoveAppData )
        DebugMsg((DM_VERBOSE, IDS_UNMANAGE, _pwszDeploymentName));

    Status = STATUS_SUCCESS;

    if ( ScriptFlags != 0 )
    {
        if ( ! _pManApp->IsUserPolicy() )
            ScriptFlags |= SCRIPTFLAGS_MACHINEASSIGN;

        DebugMsg((DM_VERBOSE, IDS_UNADVERTISE, _pwszDeploymentName, _pwszLocalScriptPath));

        Status = CallMsiAdvertiseScript(
                    _pwszLocalScriptPath,
                    ScriptFlags,
                    NULL,
                    TRUE );

        // It's possible for the product to be uninstalled without us knowing.
        if ( ERROR_UNKNOWN_PRODUCT == Status )
            Status = ERROR_SUCCESS;

        if ( Status != ERROR_SUCCESS )
            DebugMsg((DM_WARNING, IDS_UNADVERTISE_FAIL, _pwszDeploymentName, _pwszLocalScriptPath, Status));
    }

    if ( (ERROR_SUCCESS == Status) && bRemoveAppData )
    {
        _pManApp->Revert();

        DeleteFile( _pwszLocalScriptPath );
        _State &= ~APPSTATE_SCRIPT_PRESENT;

        //
        // Do not delete the productid->installui hint value when a product is removed
        // because of productid or transform conflicts.  In both of these cases it means
        // an app with the same productid is still currently being managed.  
        // This is important because the unmanage calls are done last when handling ARP
        // requests and this will inadvertently delete the productid->installui hint value
        // for a product which is still being managed.
        //
        if ( (_dwRemovalCause != APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT) &&
             (_dwRemovalCause != APP_ATTRIBUTE_REMOVALCAUSE_TRANSFORM) )
            RegDeleteValue( _pManApp->AppmgmtKey(), _pwszProductId );

        _AssignCount--;

        if ( _AssignCount > 0 )
        {
            BOOL bUpdateState;
            
            bUpdateState = TRUE;

            if ( ACTION_ORPHAN == _Action )
            {
                DebugMsg((DM_VERBOSE, IDS_UNMANAGE_ORPHAN, _pwszDeploymentName));
                AppState = APPSTATE_ORPHANED;
            }
            else if ( ( ACTION_UNINSTALL == _Action ) || ( ACTION_NONE == _Action ) )
            {
                DebugMsg((DM_VERBOSE, IDS_UNMANAGE_UNINSTALL, _pwszDeploymentName));
                AppState = APPSTATE_UNINSTALLED;
            }
            else
            {
                bUpdateState = FALSE;
            }

            Status = RegOpenKeyEx(
                            _pManApp->AppmgmtKey(),
                            wszDeploymentId,
                            0,
                            KEY_ALL_ACCESS,
                            &hkApp );

            if ( ERROR_SUCCESS == Status )
            {
                DWORD RemovedState;

                RemovedState = _State & APPSTATE_PERSIST_MASK;

                if ( _pManApp->IsRemovingPolicies() )
                {
                    Status = RegSetValueEx(
                        hkApp,
                        REMOVEDGPOSTATE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &RemovedState,
                        sizeof(DWORD) );
                }
                
                if ( bUpdateState &&
                     ( ERROR_SUCCESS == Status ) )
                {
                    Status = RegSetValueEx(
                        hkApp,
                        APPSTATEVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &AppState,
                        sizeof(DWORD) );
                }

                if ( ERROR_SUCCESS == Status )
                {
                    Status = RegSetValueEx(
                                hkApp,
                                ASSIGNCOUNTVALUE,
                                0,
                                REG_DWORD,
                                (LPBYTE) &_AssignCount,
                                sizeof(DWORD) );
                }

                RegCloseKey( hkApp );
            }

            if ( Status != ERROR_SUCCESS )
            {
                Status = ERROR_SUCCESS;
                RegDeleteKey( _pManApp->AppmgmtKey(), wszDeploymentId );
            }
        }
        else
        {
            RegDeleteKey( _pManApp->AppmgmtKey(), wszDeploymentId );
        }

        DWORD impStatus = _pManApp->Impersonate();
        if ( (impStatus != ERROR_SUCCESS) && (Status == ERROR_SUCCESS) )
        {
            Status = impStatus;
        }
    }

    if ( bRemoveAppData )
        gpEvents->Unassign( Status, this );

    return Status;
}

DWORD
CAppInfo::Uninstall( 
    BOOL bLogFailure // = TRUE
    )
{
    DWORD   Status;

    //
    // For async refreshes, We do not want to uninstall an application
    // since that would disrupt the user
    //
    if ( ! _pManApp->Async() )
    {
        // Uninstalls happen in our background thread.  Always set UI to NONE.
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NONE, NULL );

        DebugMsg((DM_VERBOSE, IDS_UNINSTALL, _pwszDeploymentName, _pwszGPOName));

        Status = CallMsiConfigureProduct(
            _pwszProductId,
            INSTALLLEVEL_MAXIMUM,
            INSTALLSTATE_ABSENT,
            NULL );

        // It's possible for the product to be uninstalled without us knowing.
        if ( ERROR_UNKNOWN_PRODUCT == Status )
            Status = ERROR_SUCCESS;
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
        
        Status = _Status;
    }

    if ( bLogFailure )
    {
        gpEvents->Uninstall( Status, this );
    }

    return Status;
}


HRESULT
CAppInfo::Write( CPolicyRecord* pRecord )
{
    HRESULT hr;
    LONG   EntryType;
    WCHAR  wszDeploymentId[ MAX_SZGUID_LEN ];

    EntryType = GetPublicRsopEntryType();

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ENTRYTYPE,
        EntryType);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pRecord->SetValue(
        RSOP_ATTRIBUTE_NAME,
        _pwszDeploymentName);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_NAME, hr )

    if (FAILED(hr))
    {
        goto cleanup;
    }

    GuidToString( _DeploymentId, wszDeploymentId);

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_APPID,
        wszDeploymentId);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPID, hr );

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ENTRYTYPE,
        EntryType);
    
    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ENTRYTYPE, hr )

    if (FAILED(hr))
    {
        goto cleanup;
    }

    //
    // For the remaining attributes, we will ignore failures -- at this
    // point, they have the application name, which is useful in
    // and of itself.
    //

    //
    // These properties are only written for new records -- if we are creating
    // an instance from an existing record, will not write these properties since
    // the current instance already has them set correctly and the reason that we're
    // re-using this instance is that we do not have this information
    //
    if ( pRecord->AlreadyExists() )
    {
        return hr;
    }
     
    {
        SYSTEMTIME CurrentTime;

        //
        // This does not fail
        //
        GetSystemTime( &CurrentTime );

        hr = pRecord->SetValue(
            RSOP_ATTRIBUTE_CREATIONTIME,
            &CurrentTime);

        REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_CREATIONTIME, hr );
    }

    hr = pRecord->SetValue(
        RSOP_ATTRIBUTE_GPOID,
        _pwszGPODSPath);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_GPOID, hr )

    hr = pRecord->SetValue(
        RSOP_ATTRIBUTE_SOMID,
        _pwszSOMId);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_SOMID, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ENTRYTYPE,
        EntryType);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ENTRYTYPE, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_SECURITY_DESCRIPTOR,
        _rgSecurityDescriptor,
        _cbSecurityDescriptor);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_SECURITY_DESCRIPTOR, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_VERSIONLO,
        (LONG)_VersionLo);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_VERSIONLO, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_VERSIONHI,
        (LONG)_VersionHi);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_VERSIONHI, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_PRODUCT_ID,
        _pwszProductId);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PRODUCT_ID, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_SCRIPTFILE,
        _pwszGPTScriptPath);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_SCRIPTFILE, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_LANGUAGEID,
        (LONG) _LangId);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_LANGUAGEID, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_DEPLOY_TYPE,
        (_ActFlags & ACTFLG_Assigned ?
         APP_ATTRIBUTE_DEPLOY_VALUE_ASSIGNED :
         APP_ATTRIBUTE_DEPLOY_VALUE_PUBLISHED));

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_DEPLOY_TYPE, hr )

    {
        LONG AssignmentType;
        
        if ( _ActFlags & ACTFLG_Published )
        {
            AssignmentType = APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_NOTASSIGNED;
        }
        else if ( _ActFlags & ACTFLG_InstallUserAssign )
        {
            AssignmentType = APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_INSTALL;
        }
        else
        {
            AssignmentType = APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_STANDARD;
        }
    
        hr = pRecord->SetValue(
            APP_ATTRIBUTE_ASSIGNMENT_TYPE,
            AssignmentType);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ASSIGNMENT_TYPE, hr )
    }

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_INSTALLATIONUI,
        ((INSTALLUILEVEL_FULL == _InstallUILevel) ?
             APP_ATTRIBUTE_INSTALLATIONUI_VALUE_MAXIMUM :
             APP_ATTRIBUTE_INSTALLATIONUI_VALUE_BASIC));

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_INSTALLATIONUI, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ONDEMAND,
        (BOOL)(_ActFlags & ACTFLG_OnDemandInstall));

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_LOSSOFSCOPEACTION,
        (BOOL)(_ActFlags & ACTFLG_OrphanOnPolicyRemoval) ?
            APP_ATTRIBUTE_SCOPELOSS_ORPHAN :
            APP_ATTRIBUTE_SCOPELOSS_UNINSTALL);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_LOSSOFSCOPEACTION, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_IGNORELANGUAGE,
        (BOOL)(_ActFlags & ACTFLG_IgnoreLanguage));

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_IGNORELANGUAGE, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_PACKAGELOCATION,
        _pwszPackageLocation);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PACKAGELOCATION, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_CATEGORYLIST,
        _rgwszCategories,
        _cCategories);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_CATEGORYLIST, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_TRANSFORMLIST,
        _rgwszTransforms,
        _cTransforms);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_TRANSFORMLIST, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ARCHITECTURES,
        _rgArchitectures,
        _cArchitectures);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ARCHITECTURES, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_PUBLISHER,
        _pwszPublisher ? _pwszPublisher : L"" );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PUBLISHER, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_REDEPLOYCOUNT,
        (LONG) _DirectoryRevision);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REDEPLOYCOUNT, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_UPGRADE_SETTINGS_MANDATORY,
        (BOOL) ( _ActFlags & ACTFLG_ForceUpgrade ) );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_UPGRADE_SETTINGS_MANDATORY, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_UNINSTALL_UNMANAGED,
        (BOOL) ( _bNeedsUnmanagedRemove ) );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_UNINSTALL_UNMANAGED, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_DISPLAYINARP,
        (BOOL) ( _ActFlags & ACTFLG_UserInstall ) );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_DISPLAYINARP, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_SUPPORTURL,
        _pwszSupportURL);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_SUPPORTURL, hr );

    if ( APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE == EntryType )
    {
        hr = WriteRemovalProperties( pRecord );
    }

    {
        BOOL bX86OnWin64;

        bX86OnWin64 = FALSE;

        //
        // If this is an x86 package, see if this applies to 64-bit clients
        //
        if ( PROCESSOR_ARCHITECTURE_INTEL == _PrimaryArchitecture )
        {
            //
            // If it has been excluded by the admin, it does not apply
            //
            if ( ! ( ACTFLG_ExcludeX86OnWin64 & _ActFlags ) )
            {
                bX86OnWin64 = TRUE;
            }
                
            //
            // The flag above is reversed if this is a ZAP app -- flip
            // the logic to support the reverse preference.
            //
            if ( SetupNamePath == _PathType )
            {
                bX86OnWin64 = ! bX86OnWin64;
            }
        }

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_X86OnWin64,
            bX86OnWin64);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_X86OnWin64, hr);
    }

    {
        SYSTEMTIME SystemTime;
        BOOL       bStatus;

        bStatus = FileTimeToSystemTime(
            (FILETIME*) &_USN,
            &SystemTime);

        if ( bStatus )
        {
            hr = pRecord->SetValue(
                APP_ATTRIBUTE_MODIFYTIME,
                &SystemTime);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_MODIFYTIME, hr);
        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    {
        LONG PackageType;

        switch ( _PathType )
        {
        case DrwFilePath:
            PackageType = APP_ATTRIBUTE_PACKAGETYPE_VALUE_WIN_INSTALLER;
            break;

        case SetupNamePath:
            PackageType = APP_ATTRIBUTE_PACKAGETYPE_VALUE_ZAP;
            break;

        default:
            ASSERT ( L"Invalid packagetype" && FALSE );
            break;
        }

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_PACKAGETYPE,
            (LONG) PackageType);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PACKAGETYPE, hr )
    }

    if ( ! _pManApp->ARPList() )
    {
        DWORD  dwInstallType;
        WCHAR* wszDemandSpec;
        WCHAR* wszProperty;

        dwInstallType = _pManApp->GetRsopContext()->GetDemandSpec( &wszDemandSpec );
        wszProperty = NULL;

        switch (dwInstallType)
        {
        case CRsopAppContext::DEMAND_INSTALL_FILEEXT:

            wszProperty = APP_ATTRIBUTE_ONDEMAND_FILEEXT;
            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_FILEEXT;
            break;

        case CRsopAppContext::DEMAND_INSTALL_CLSID:

            wszProperty = APP_ATTRIBUTE_ONDEMAND_CLSID;
            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_CLSID;
            break;

        case CRsopAppContext::DEMAND_INSTALL_PROGID:

            wszProperty = APP_ATTRIBUTE_ONDEMAND_PROGID;
            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROGID;
            break;

        case CRsopAppContext::DEMAND_INSTALL_NAME:

            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_USER;
            wszProperty = NULL;
            break;

        case CRsopAppContext::DEMAND_INSTALL_NONE:

            //
            // We reach this case if we are in policy application 
            //
            wszProperty = NULL;

            if ( ( _dwApplyCause == APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE ) && ! IsSuperseded() ) 
            {
                if ( _ActFlags & ACTFLG_Assigned ) 
                {
                    _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED;
                }
                else if ( _ActFlags & ACTFLG_Published )
                {
                    if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
                    {
                        _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE;
                    }
                    else if ( _State & APPSTATE_ASSIGNED )
                    { 
                        _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED;
                    }
                    else
                    {
                        _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_USER;

                        if ( ! _pManApp->GetRsopContext()->Transition() )
                        {
                            _dwApplyCause = _dwUserApplyCause;
                            wszProperty = _wszDemandProp;
                            wszDemandSpec = _wszDemandSpec;
                        }
                    }
                }
            }

            break;

        default:
            
            ASSERT( L"Invalid RSoP Install Context" && FALSE );
            break;

        }

        if ( wszProperty )
        {
            hr = pRecord->SetValue(
                wszProperty,
                wszDemandSpec);

            REPORT_ATTRIBUTE_SET_STATUS( wszProperty, hr )
        }
        else if ( APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE != EntryType )
        {
            //
            // Ensure that
            //
            hr = pRecord->ClearValue(
                APP_ATTRIBUTE_ONDEMAND_FILEEXT);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_FILEEXT, hr )

            hr = pRecord->ClearValue(
                APP_ATTRIBUTE_ONDEMAND_CLSID);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_CLSID, hr )

            hr = pRecord->ClearValue(
                APP_ATTRIBUTE_ONDEMAND_PROGID);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_PROGID, hr )
        }
      
        if ( APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE != _dwApplyCause )
        {
            hr = pRecord->SetValue(
                APP_ATTRIBUTE_APPLY_CAUSE,
                (LONG) _dwApplyCause);
            
            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPLY_CAUSE, hr )
        }
    }

    {
        LONG MatchType;

        switch(_LanguageWeight)
        {
        case PRI_LANG_ALWAYSMATCH:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_IGNORE;
            break;

        case PRI_LANG_SYSTEMLOCALE:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_SYSLOCALE;
            break;

        case PRI_LANG_ENGLISH:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_ENGLISH;
            break;

        case PRI_LANG_NEUTRAL:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_NEUTRAL;
            break;

        default:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_NOMATCH;
            break;
        }

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_LANGMATCH,
            MatchType);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_LANGMATCH, hr )
    }

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ELIGIBILITY,
        GetEligibility() );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ELIGIBILITY, hr )

    LogUpgrades( pRecord );

cleanup:

    return hr;
}

HRESULT
CAppInfo::WriteRemovalProperties(
    CPolicyRecord* pRemovalRecord )
{
    HRESULT hr;
    LONG    RemovalType;
    LONG    RemovalCause;

    RemovalCause = (LONG) _dwRemovalCause;

    if ( CRsopAppContext::REMOVAL == _pManApp->GetRsopContext()->GetContext() )
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED;
    }
    else if ( APP_ATTRIBUTE_REMOVALCAUSE_UPGRADE == RemovalCause )
    {
        if ( ACTION_UNINSTALL == Action() )
        {
            RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED;
        }
        else
        {
            RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UPGRADED;
        }
    }
    else if ( APP_ATTRIBUTE_REMOVALCAUSE_TRANSFORM == RemovalCause )
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED;
    }
    else if ( ACTION_ORPHAN == Action() )
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_ORPHAN;
    }
    else if ( ACTION_UNINSTALL == Action() )
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED;
    }
    else 
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_NONE;
    }

    if ( APP_ATTRIBUTE_REMOVALTYPE_NONE == RemovalType )
    {
        return S_OK;
    }
     
    hr = pRemovalRecord->SetValue(
            APP_ATTRIBUTE_REMOVAL_CAUSE,
            RemovalCause);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVAL_CAUSE, hr );

    hr = pRemovalRecord->SetValue(
        APP_ATTRIBUTE_REMOVAL_TYPE,
        RemovalType);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVAL_TYPE, hr );

    hr = pRemovalRecord->ClearValue(
        APP_ATTRIBUTE_PRECEDENCE_REASON);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PRECEDENCE_REASON, hr );

    if ( _pwszRemovingDeploymentId )
    {
        hr = pRemovalRecord->SetValue(
            APP_ATTRIBUTE_REMOVING_APP,
            _pwszRemovingDeploymentId);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVING_APP, hr )
    }

    return hr;
}

HRESULT
CAppInfo::ClearRemovalProperties( CPolicyRecord* pRecord )
{
    HRESULT hr;

    hr = pRecord->ClearValue( APP_ATTRIBUTE_REMOVAL_CAUSE );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVAL_CAUSE, hr )

    if ( SUCCEEDED( hr ) )
    {
        hr = pRecord->ClearValue( APP_ATTRIBUTE_REMOVAL_TYPE );

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVAL_TYPE, hr )
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = pRecord->ClearValue( APP_ATTRIBUTE_REMOVING_APP );

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVING_APP, hr )
    }

    return hr;
}


LONG
CAppInfo::GetRsopEntryType()
{
    LONG EntryType;

    if ( _pManApp->ARPList() )
    {
         EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM;
    }
    else
    {
        if ( ( _Action == ACTION_APPLY )  ||
             ( _Action == ACTION_INSTALL ) ||
             ( _Action == ACTION_REINSTALL ) )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE;
        }
        else if ( ( _Action == ACTION_ORPHAN ) ||
                  ( _Action == ACTION_UNINSTALL ) )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE;
        }
        else if ( ( _State & APPSTATE_ASSIGNED ) |
                  ( _State & APPSTATE_PUBLISHED ) )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE;
        }
        else
        {
            EntryType = NO_RSOP_ENTRY;
        }
    }

    return EntryType;
}

LONG
CAppInfo::GetPublicRsopEntryType()
{
    LONG EntryType;

    if ( IsSuperseded() )
    {
        if ( _pManApp->ARPList() )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM;
        }
        else
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE;
        }
    }
    else
    {
        EntryType = GetRsopEntryType();
    }

    return EntryType;
}

LONG
CAppInfo::GetEligibility()
{
    LONG Eligibility;

    Eligibility = 0;

    if ( ! ( CRsopAppContext::ARPLIST == _pManApp->GetRsopContext()->GetContext() ) )
    {
        if ( ! ( CRsopAppContext::POLICY_REFRESH == _pManApp->GetRsopContext()->GetContext() ) && 
             ! IsSuperseded() )
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_APPLIED;
        }
        else if ( ( _ActFlags & ACTFLG_Assigned ) || ( _State & APPSTATE_ASSIGNED ) ) 
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_ASSIGNED;
        }
        else if ( _ActFlags & ACTFLG_HasUpgrades )
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_UPGRADES;
        }
        else if ( ( _dwApplyCause == APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE ) ||
                  _DemandInstall ) 
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_APPLIED;
        }
        else if ( _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_PLANNING;
        }
        else
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_APPLIED;
        }
    }

    return Eligibility;
}

HRESULT
CAppInfo::SetRemovingDeploymentId( GUID* pDeploymentId )
{
    if ( ! _pwszRemovingDeploymentId )
    {
        _pwszRemovingDeploymentId = new WCHAR[ MAX_SZGUID_LEN ];
    }

    if ( ! _pwszRemovingDeploymentId )
    {
        return E_OUTOFMEMORY;
    }

    GuidToString( *pDeploymentId, _pwszRemovingDeploymentId);

    return S_OK;
}

void
CAppInfo::SetRsopFailureStatus(
    DWORD dwStatus,
    DWORD dwEventId)
{
    CAppStatus* pNewStatus;

    //
    // Allocate a new failure status for this application --
    // it will be freed by the destructor of this class
    //
    pNewStatus = new CAppStatus;

    if ( ! pNewStatus )
    {
        _pManApp->GetRsopContext()->DisableRsop( E_OUTOFMEMORY );
        return;
    }

    //
    // Set the status as specified by the caller
    //
    pNewStatus->SetRsopFailureStatus( dwStatus, dwEventId );

    //
    // Remember this new status --
    // keep track of multiple errors in the order they were logged
    //
    _StatusList.InsertFIFO( pNewStatus );

    //
    // Always reset this so that if someone calls GetCurrentItem,
    // they will get the first thing in the list -- if this is
    // never called, the list returns NULL
    //
    _StatusList.Reset();
}

void
CAppInfo::ForceFailureStatus()
{
    //
    // If we haven't already failed, set an arbitrary
    // error code -- this is used in cases where the app
    // itself did not fail to apply, but some other app
    // failed (as in the upgrade case), but we need to
    // set this as a failure so that the application will
    // clean up its state
    //
    if ( ERROR_SUCCESS == _Status )
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
    }
}


LONG
CAppInfo::UpdatePrecedence(
    CAppInfo* pLosingApp,
    DWORD     dwConflict
    )
{
    LONG Status;

    Status = ERROR_SUCCESS;

    if ( ! _bSupersedesAssigned )
    {
        if ( pLosingApp->_bSupersedesAssigned )
        {
            _bSupersedesAssigned = pLosingApp->_bSupersedesAssigned;
        }
        else
        {
            _bSupersedesAssigned = ( ACTFLG_Assigned & pLosingApp->_ActFlags );
        }
    }

    //
    // If Rsop logging is enabled, we need to update
    // the precedence of this application according
    // to the conflict
    //
    if ( _pManApp->GetRsopContext()->IsRsopEnabled() )
    {
        Status = _SupersededApps.AddConflict( pLosingApp, this, dwConflict );

        //
        // Supersede the losing app -- that is, mark it as
        // superseded so that later on when writing the rsop
        // log we do not log it as a winning application
        //
        if ( ERROR_SUCCESS == Status )
        {
            pLosingApp->Supersede();

            DebugMsg((
                DM_VERBOSE,
                IDS_RSOP_SUPERSEDED,
                pLosingApp->_pwszDeploymentName,
                pLosingApp->_pwszGPOName,
                _pwszDeploymentName,
                _pwszGPOName,
                dwConflict));
        }
        else
        {
            HRESULT hr;

            hr = HRESULT_FROM_WIN32( Status );

            _pManApp->GetRsopContext()->DisableRsop( hr );
        }
    }

    return Status;
}


void
CAppInfo::LogUpgrades( CPolicyRecord* pRecord )
{
    if (!_Upgrades)
    {
        return;
    }

    WCHAR** rgwszUpgradeable;
    WCHAR** rgwszReplaceable;

    rgwszUpgradeable = NULL;
    rgwszReplaceable = NULL;

    rgwszUpgradeable = new WCHAR*[_Upgrades];

    if ( ! rgwszUpgradeable )
    {
        goto ExitAndCleanup_LogUpgrades;
    }

    rgwszReplaceable = new WCHAR*[_Upgrades];

    if ( ! rgwszUpgradeable )
    {
        goto ExitAndCleanup_LogUpgrades;
    }

    RtlZeroMemory(rgwszUpgradeable, _Upgrades * sizeof(*rgwszUpgradeable));
    RtlZeroMemory(rgwszReplaceable, _Upgrades * sizeof(*rgwszReplaceable));

    DWORD cUpgradeable;
    DWORD cReplaceable;

    cUpgradeable = 0;
    cReplaceable = 0;

    //
    // We will iterate through each upgrade so that we can log it
    //
    DWORD   iUpgrade;

    for (iUpgrade = 0; iUpgrade < _Upgrades; iUpgrade++)
    {
        WCHAR** ppwszUpgradeId;

        //
        // We only track the applications that we upgrade, not those
        // that we are upgraded by. Note that we do not check for the
        // converse flag, UPGRADE_OVER, since it can get cleared when
        // an upgrade relationship is reversed -- we still need to
        // log that as an upgrade for this app
        //
        if ( _pUpgrades[iUpgrade].Flags & UPGRADE_BY )
        {
            continue;
        }

        //
        // If this upgrade is the result of a reversed upgrade due to
        // a policy precedence violation, we should not log it as part
        // of this application's upgrades
        //
        if ( _pUpgrades[iUpgrade].Flags & UPGRADE_REVERSED )
        {
            continue;
        }

        if ( _pUpgrades[iUpgrade].Flags & UPGRADE_UNINSTALL )
        {
            ppwszUpgradeId = &(rgwszReplaceable[cReplaceable]);
            cReplaceable++;
        }
        else
        {
            ppwszUpgradeId = &(rgwszUpgradeable[cUpgradeable]);
            cUpgradeable++;
        }

        //
        // The RSoP schema requires the guids be in string form,
        // so we need to convert this guid to a string -- note that
        // this call allocates memory which must be freed later
        //
        GuidToString(
            _pUpgrades[iUpgrade].DeploymentId,
            ppwszUpgradeId);

        if ( ! *ppwszUpgradeId )
        {
            break;
        }
    }

    if (iUpgrade == _Upgrades)
    {
        HRESULT hr;

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_UPGRADEABLE_APPLICATIONS,
            rgwszUpgradeable,
            cUpgradeable);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_UPGRADEABLE_APPLICATIONS, hr )

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_REPLACEABLE_APPLICATIONS,
            rgwszReplaceable,
            cReplaceable);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REPLACEABLE_APPLICATIONS, hr )
    }

    //
    // Free the memory allocated in the GuidToString call for each upgrade guid
    //
    for (iUpgrade = 0; iUpgrade < cUpgradeable; iUpgrade++)
    {
        delete [] rgwszUpgradeable[iUpgrade];
    }

    for (iUpgrade = 0; iUpgrade < cReplaceable; iUpgrade++)
    {
        delete [] rgwszReplaceable[iUpgrade];
    }

ExitAndCleanup_LogUpgrades:

    delete [] rgwszUpgradeable;
    delete [] rgwszReplaceable;
}

BOOL
CAppInfo::IsLocal()
{
    return NULL == _pwszGPODSPath;
}

BOOL
CAppInfo::IsGpoInScope()
{
    BOOL bGpoInScope;

    bGpoInScope = FALSE;

    if ( _pwszGPOId )
    {
        CGPOInfoList& GpoInfoList = _pManApp->GPOList();

        bGpoInScope = ( NULL != GpoInfoList.Find( _pwszGPOId ) );
    }

    return bGpoInScope;
}

LONG
CAppInfo::InitializeRSOPTransformsList(
    PACKAGEDISPINFO* pPackageInfo
    )
{
    if ( ! pPackageInfo->cTransforms )
    {
        return ERROR_SUCCESS;
    }

    //
    // The first element of the transforms list is
    // actually the original package itself, so we don't count it
    //
    _cTransforms = pPackageInfo->cTransforms - 1;

    //
    // If we have transforms, get space for them
    //
    if ( 0 != _cTransforms )
    {
        //
        // The elements in the transform list are
        // the actual transforms, so we'll copy them to our own list -- first
        // allocate enough space for pointers to each path
        //
        _rgwszTransforms = new WCHAR* [ _cTransforms ];
        
        if ( ! _rgwszTransforms )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RtlZeroMemory( _rgwszTransforms, sizeof(*_rgwszTransforms) * _cTransforms );
    }

    //
    // Now place the transforms into the array
    //
    
    //
    // Each transform is of the form <index>:<path>.  The <index> is
    // an integer that is unique for each transform in this package and
    // less than or equal to the number of transforms.  The 0th transform
    // is actually not a transform, but the source package itself, and this
    // is special cased
    //

    //
    // Copy each transform path to an element in the array of strings.  We 
    // decide which element in the array based on the <index> indicated
    // in the transform string, shifted down 1 to skip the 0th (the source package).
    // For example, the transform with <index> 1 goes to array element 0, 
    // the transform with <index> 4 goes to 3, etc.  That way, no matter what
    // order the transforms are in (e.g. 3,2,0,4,1), because we are mapping
    // based on index, we end up with an ordered array (e.g. 1,2,3,4).
    //
    DWORD iTransform;
    BOOL  bFoundSource;

    bFoundSource = FALSE;

    for ( iTransform = 0; iTransform < pPackageInfo->cTransforms; iTransform++ )
    {
        WCHAR* wszTransform;
        DWORD  dwTransformIndex;

        //
        // First, we need the transform index -- look for the separator
        // so we can find it
        //
        wszTransform = wcschr( pPackageInfo->prgTransforms[ iTransform ], L':' );

        //
        // Check for bogus data
        //
        if ( ! wszTransform )
        {
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Truncate the string right after the index
        //
        *wszTransform = L'\0';

        //
        // The actual transform path starts one past the separator
        //
        wszTransform++;

        //
        // Now convert the index to integer
        //
        UNICODE_STRING TransformIndex;
        NTSTATUS       NtStatus;

        RtlInitUnicodeString( &TransformIndex, pPackageInfo->prgTransforms[ iTransform ] );

        NtStatus = RtlUnicodeStringToInteger( &TransformIndex, 10, &dwTransformIndex );

        //
        // This should only fail if the index string is corrupt ( i.e. the number is not in base 10 )
        //
        if ( ! NT_SUCCESS( NtStatus ) )
        {
            return RtlNtStatusToDosError( NtStatus );
        }

        //
        // The number is correct syntactically, now ensure that semantically it is correct --
        // the index cannot exceed the number of transforms.
        //
        if ( dwTransformIndex > _cTransforms )
        {
            return ERROR_INVALID_PARAMETER;
        }
        
        //
        // Check for the source package -- it is transform index 0
        //
        if ( 0 == dwTransformIndex )
        {
            //
            // Make sure the source is not listed twice
            //
            if ( bFoundSource )
            {
                return ERROR_INVALID_PARAMETER;
            }

            bFoundSource = TRUE;

            //
            // Copy the source package path, minus the prefix,
            // to the member reserved for this purpose -- it currently
            // points to the separator, so we need to go 1 past it
            //
            _pwszPackageLocation = StringDuplicate( wszTransform );
            
            if ( ! _pwszPackageLocation )
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            continue;
        }

        //
        // Shift it down since this index's value includes the source package's
        // occupation of zero, and we want to exclude it
        //
        dwTransformIndex--;

        //
        // Make sure we don't already have a transform at this index -- if we do, this
        // is an ill-formed transform list
        //
        if ( _rgwszTransforms [ dwTransformIndex ] )
        {
            return ERROR_INVALID_PARAMETER;
        }

        _rgwszTransforms[ dwTransformIndex ] = StringDuplicate( wszTransform );

        if ( ! _rgwszTransforms[ dwTransformIndex ] )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // If we did not find a source, this is not a valid transform list
    //
    if ( ! bFoundSource )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return S_OK;
}

LONG
CAppInfo::InitializeRSOPArchitectureInfo( PACKAGEDISPINFO* pPackageInfo )
{
    DWORD iArchitecture;

    _rgArchitectures = new LONG [ pPackageInfo->cArchitectures ];

    if ( ! _rgArchitectures )
    {
        return ERROR_OUTOFMEMORY;
    }

    _cArchitectures = pPackageInfo->cArchitectures;
        
    for ( 
        iArchitecture = 0;
        iArchitecture < _cArchitectures;
        iArchitecture ++ )
    {
        //
        // We need to extract the Win32 processor architecture --
        // the element in the PACKAGEDISPINFO is actually a combination
        // of several other attributes -- the processor architecture is
        // in highest 8 bits, so we'll shift everything right to get it.
        //
        _rgArchitectures[ iArchitecture ] =
            pPackageInfo->prgArchitectures[ iArchitecture ] >> 24;

        //
        // In planning mode, we determine architecture by seeing if it lists 64-bit --
        // if so, we mark it as 64 bit.  If it doesn't list 64-bit, it will be marked 32-bit 
        // if it lists 32-bit.  If it doesn't list either of those, it will be
        // marked as unknown.
        //
        if ((PROCESSOR_ARCHITECTURE_IA64 != _PrimaryArchitecture) &&
            (PROCESSOR_ARCHITECTURE_AMD64 != _PrimaryArchitecture)) 
        {
            if ((PROCESSOR_ARCHITECTURE_INTEL == _rgArchitectures[ iArchitecture ]) ||
                (PROCESSOR_ARCHITECTURE_AMD64 == _rgArchitectures[ iArchitecture ]) ||
                (PROCESSOR_ARCHITECTURE_IA64 == _rgArchitectures[ iArchitecture ]))
            {
                _PrimaryArchitecture = _rgArchitectures[ iArchitecture ];
            }
        }
    }

    if ( _pManApp->GetRsopContext()->IsDiagnosticModeEnabled() )
    {
        _PrimaryArchitecture = pPackageInfo->MatchedArchitecture >> 24;
    }

    return ERROR_SUCCESS;
}


LONG
CAppInfo::InitializeCategoriesList(
    PACKAGEDISPINFO* pPackageInfo
    )
{
    if ( ! pPackageInfo->cCategories )
    {
        return ERROR_SUCCESS;
    }

    //
    // Reserve enough space so that we can have a pointer
    // to each category guid string
    //
    _cCategories = pPackageInfo->cCategories;

    _rgwszCategories = new WCHAR* [ pPackageInfo->cCategories ];

    if ( ! _rgwszCategories )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( _rgwszCategories, sizeof( *_rgwszCategories ) * _cCategories );

    //
    // Now reserve enough space for each copy of the category
    // guid strings
    //
    DWORD iCategory;

    for ( iCategory = 0; iCategory < _cCategories; iCategory++ )
    {
        _rgwszCategories[ iCategory ] = StringDuplicate( pPackageInfo->prgCategories[ iCategory ] );

        if ( ! _rgwszCategories[ iCategory ] )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return S_OK;
}

WCHAR* CAppInfo::GetRsopAppCriteria()
{
    //
    // We will want to specify an instance that has the conflict id unique
    // to this package and its conflicts, and has an "installed" entry type.
    //

    //
    // First, we calculate the length -- this is actually a constant based
    // on the maximum sizes of the 2 criteria mentioned above: the conflict id
    // is a guid string, and thus has a fixed maximum.  The entry type is a
    // 32 bit quantities, which of course has a maximum string length
    // in decimal notation
    //
    DWORD cCriteriaLen;

    cCriteriaLen =
        MAXLEN_RSOPREMOVAL_QUERY_CRITERIA +
        MAXLEN_RSOPENTRYTYPE_DECIMAL_REPRESENTATION +
        MAXLEN_RSOPPACKAGEID_GUID_REPRESENTATION;

    WCHAR* wszCriteria = new WCHAR [ cCriteriaLen ];

    if ( wszCriteria )
    {
        WCHAR wszDeploymentId [ MAX_SZGUID_LEN ];
        HRESULT hr;

        GuidToString( _DeploymentId, wszDeploymentId);

        hr = StringCchPrintf(
            wszCriteria,
            cCriteriaLen,
            RSOP_REMOVAL_QUERY_CRITERIA,
            APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE,
            wszDeploymentId);
        if (FAILED(hr)) 
        {
            delete [] wszCriteria;
            return NULL;
        }
    }

    return wszCriteria;
}


DWORD
CAppInfo::CopyScriptIfNeeded()
{
    WCHAR * pwszTempScript;
    DWORD   Length;
    DWORD   Status;

    if ( _State & APPSTATE_SCRIPT_PRESENT )
        return ERROR_SUCCESS;

    Status = ERROR_SUCCESS;

    //
    // It is remotely possible that we could hit this.  For instance, during
    // an ARP readvertise of an uninstalled assigned app.  When using roaming
    // profiles & with policy failing to run at the last logon, we might not
    // have the local script, so we get this far, but this member will not be
    // set when run in the service.
    //
    if ( ! _pwszGPTScriptPath )
        return ERROR_BAD_PATHNAME;

    //
    // When doing user policy we have to do two copies to get the script in the
    // right place.  First we copy to a temp file while impersonating.  This is
    // so our sysvol access is done as the user.  Then we copy from the temp file
    // to the ACLed script dir under %systemroot% while reverted as LocalSystem.
    //
    if ( _pManApp->IsUserPolicy() )
    {
        pwszTempScript = 0;

        Length = GetTempPath( 0, NULL );

        if ( Length > 0 )
        {
            pwszTempScript = new WCHAR[Length + 1 + GUIDSTRLEN + 1];

            if ( pwszTempScript )
            {
                if ( 0 == GetTempPath( Length, pwszTempScript ) )
                    Status = GetLastError();
            }
            else
            {
                Status = ERROR_OUTOFMEMORY;
            }
        }
        else
            Status = GetLastError();

        if ( ERROR_SUCCESS == Status )
        {
            if ( pwszTempScript[lstrlen(pwszTempScript)-1] != L'\\' )
            {
                HRESULT hr;
                hr = StringCchCat( pwszTempScript, Length + 1 + GUIDSTRLEN + 1, L"\\" );
                if (FAILED(hr)) 
                {
                    Status = HRESULT_CODE(hr);
                }
            }
            if (ERROR_SUCCESS == Status) 
            {
                GuidToString( _DeploymentId, &pwszTempScript[lstrlen(pwszTempScript)]);

                //  
                // CopyFile does not use the thread impersonation token for access checks,
                // so we are ok copying into the system temp dir.
                //
                if ( ! CopyFile(_pwszGPTScriptPath, pwszTempScript, FALSE) )
                {
                    Status = GetLastError();
                    DebugMsg((DM_WARNING, IDS_SCRIPT_COPY_FAIL, _pwszDeploymentName, _pwszGPOName, _pwszGPTScriptPath, pwszTempScript, Status));
                }
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            _pManApp->Revert();

            if ( ! CopyFile(pwszTempScript, _pwszLocalScriptPath, FALSE) )
            {
                Status = GetLastError();
                DebugMsg((DM_WARNING, IDS_SCRIPT_COPY_FAIL, _pwszDeploymentName, _pwszGPOName, pwszTempScript, _pwszLocalScriptPath, Status));
            }

            DeleteFile( pwszTempScript );

            DWORD impStatus = _pManApp->Impersonate();
            if ( (impStatus != ERROR_SUCCESS) && (Status == ERROR_SUCCESS) )
            {
                Status = impStatus;
            }
        }

        delete []  pwszTempScript;
    }
    else
    {
        if ( ! CopyFile(_pwszGPTScriptPath, _pwszLocalScriptPath, FALSE) )
        {
            Status = GetLastError();
            DebugMsg((DM_WARNING, IDS_SCRIPT_COPY_FAIL, _pwszDeploymentName, _pwszGPOName, _pwszGPTScriptPath, _pwszLocalScriptPath, Status));
        }
    }

    if ( ERROR_SUCCESS == Status )
        _State |= APPSTATE_SCRIPT_PRESENT;

    return Status;
}

void
CAppInfo::CheckScriptExistence()
{
    if ( _State & (APPSTATE_SCRIPT_EXISTED | APPSTATE_SCRIPT_NOT_EXISTED) )
        return;

    if ( _pManApp->ScriptList().Find( _DeploymentId ) != NULL )
        _State |= APPSTATE_SCRIPT_EXISTED | APPSTATE_SCRIPT_PRESENT;
    else
        _State |= APPSTATE_SCRIPT_NOT_EXISTED;
}

DWORD
CAppInfo::EnforceAssignmentSecurity(
    BOOL * pbDidUninstall
    )
{
    INSTALLSTATE    InstallState;
    WCHAR           wszBuffer[8];
    DWORD           Size;
    DWORD           Status;
    BOOL            bPerMachine;
    BOOL            bUninstall;

    *pbDidUninstall = FALSE;

    if ( ! _bNeedsUnmanagedRemove )
        return ERROR_SUCCESS;

    DebugMsg((DM_VERBOSE, IDS_ENFORCE_SECURE_ON, _pwszDeploymentName, _pwszGPOName));

    InstallState = (*gpfnMsiQueryProductState)( _pwszProductId );

    //
    // If the app is not installed for the user/machine then we are done.
    // Note that if only advertised, our subsequent advertise will update
    // the source path, so we return in that case.
    //
    if ( ! AppPresent( InstallState) || (INSTALLSTATE_ADVERTISED == InstallState) )
        return ERROR_SUCCESS;

    Size = sizeof(wszBuffer) / sizeof(WCHAR);

    Status = (*gpfnMsiGetProductInfo)(
                _pwszProductId,
                INSTALLPROPERTY_ASSIGNMENTTYPE,
                wszBuffer,
                &Size );

    if ( Status != ERROR_SUCCESS )
    {
        DebugMsg((DM_WARNING, IDS_ENFORCE_SECURE_FAIL, _pwszDeploymentName, Status));
        return Status;
    }

    bPerMachine = (L'1' == wszBuffer[0]);

    //
    // For user policy we only care about user installed apps and for machine
    // policy we only care about machine installed apps.
    //
    if ( (_pManApp->IsUserPolicy() && bPerMachine) ||
         (! _pManApp->IsUserPolicy() && ! bPerMachine) )
        return ERROR_SUCCESS;

    //
    // If the app is present for the user and we've previously
    // assigned it, we are safe if the product is marked for elevated
    // install.
    // 
    // If we've previously installed a machine assigned app then it's ok,
    // because by definition all machine installed apps are elevated
    // (because they require admin priviledge to install), so we 
    // don't need this extra check for them.
    //
    if ( _State & APPSTATE_SCRIPT_EXISTED )
    {
        BOOL    bElevated;

        if ( _pManApp->IsUserPolicy() )
        {
            Status = (*gpfnMsiIsProductElevated)( _pwszProductId, &bElevated );
    
            if ( Status != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, IDS_ENFORCE_SECURE_FAIL, _pwszDeploymentName, Status));
                return Status;
            }
        }
        else
        {
            bElevated = TRUE;
        }

        if ( bElevated )
            return ERROR_SUCCESS;
    }

    gpEvents->RemoveUnmanaged( this );
    _pManApp->LogonMsgInstall( _pwszDeploymentName );
    Status = Uninstall();
    _pManApp->LogonMsgApplying();

    if ( ERROR_SUCCESS == Status )
    {
        _InstallState = INSTALLSTATE_ABSENT;
        *pbDidUninstall = TRUE;
    }
    else
    {
        DebugMsg((DM_WARNING, IDS_ENFORCE_SECURE_FAIL, _pwszDeploymentName, Status));
    }

    return Status;
}

BOOL
CAppInfo::RequiresUnmanagedRemoval()
{
    BOOL bRequiresUnmanagedRemoval = FALSE;

    if ( _pManApp->ARPList() )
    {
        return FALSE;
    }

    //
    // We remove unmanaged installs as a security precaution to
    // prevent elevation of privileges --
    // this means that we do not need to do it for machine assigned apps
    // or per-user apps for admins, since since system and admins
    // already have the highest privileges
    //
    // Note that we could do this for all apps (whether or not they 
    // are machine assigned or user assigned / published to an admin),
    // but the unmanaged removal is a less enjoyable user experience,
    // so we only want to do this in the case where it is required --
    // the per-user, non-admin case where the unmanaged application
    // is not already elevated
    //

    //
    // Verify that this is a per-user app 
    //
    if ( _pManApp->IsUserPolicy() )
    {
        //        
        // For planning mode, we'll need to choose a "default" behavior
        // so that we can simulate what might happen if this application
        // were to be applied to a machine
        //
        if ( _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            //
            // We will err on the side of safety and say that this
            // simulated application may require removal of unmanaged
            // installs
            //
            bRequiresUnmanagedRemoval = TRUE;
        }
        else
        {
            //
            // If this user is not an admin, we may require
            // the removal of an unmanaged install of this app
            // if one exists
            //
            if ( ! IsMemberOfAdminGroup( _pManApp->UserToken() ) )
            {
                BOOL  bIsProductElevated = FALSE;
                DWORD StatusElevated;

                //
                // The last check -- is this app present as an elevated install?  If not,
                // we should require its uninstall.  Elevated apps were placed here by some
                // admin user, so we do not consider these a threat to the system.
                //
                // Note that this call requires that the caller is impersonating
                //
                StatusElevated = gpfnMsiIsProductElevated( _pwszProductId, &bIsProductElevated );

                //
                // If this unmanaged install is not elevated, or if we were unable to determine whether
                // or not it was elevated, we will require that the application is removed if it
                // exists on the machine
                //
                if ( ( ERROR_SUCCESS != StatusElevated ) ||
                    ! bIsProductElevated )
                {
                    bRequiresUnmanagedRemoval = TRUE;
                }
            }
        }
    }

    return bRequiresUnmanagedRemoval;
}

DWORD
CAppInfo::RollbackUpgrades()
{
    DWORD   Status;

    for ( DWORD n = 0; n < _Upgrades; n++ )
    {
        Status = ERROR_SUCCESS;

        if ( ! _pUpgrades[n].pBaseApp || ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
            continue;

        // Skip it if the app didn't exist here to begin with.
        if ( ! (_pUpgrades[n].pBaseApp->_State & (APPSTATE_PUBLISHED | APPSTATE_ASSIGNED)) )
            continue;

        if ( _Status != ERROR_SUCCESS )
            Status = _Status;
        else
            Status = _pUpgrades[n].pBaseApp->_Status;

        gpEvents->UpgradeAbort( Status, this, _pUpgrades[n].pBaseApp, ERROR_SUCCESS == _Status );

        // Re-apply any app which was successfully removed.
        if ( ERROR_SUCCESS == _pUpgrades[n].pBaseApp->_Status )
        {
            DWORD ScriptFlags = SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS;
            DWORD AssignStatus;

            if ( _pUpgrades[n].pBaseApp->_State & APPSTATE_ASSIGNED )
                ScriptFlags |= SCRIPTFLAGS_REGDATA_EXTENSIONINFO;

            AssignStatus = _pUpgrades[n].pBaseApp->Assign( ScriptFlags, TRUE, TRUE );

            //
            // Here we are checking for any assigned apps which are configured for 
            // default install.  If such an app was previously in an install state
            // before the upgrade attempt, then we put it back into this state by 
            // doing a default install again.
            //
            if ( (ERROR_SUCCESS == AssignStatus) &&
                 (! _pManApp->IsUserPolicy() || (_pUpgrades[n].pBaseApp->_State & APPSTATE_INSTALL)) &&
                 (AppPresent(_pUpgrades[n].pBaseApp->_InstallState) && (_pUpgrades[n].pBaseApp->_InstallState != INSTALLSTATE_ADVERTISED)) )
            {
                (void) _pUpgrades[n].pBaseApp->Install();
            }

            if ( ERROR_SUCCESS == AssignStatus )
            {
                _pUpgrades[n].pBaseApp->_bRollback = TRUE;
            }
        }
    }

    // Each upgrade rollback has its own status set ...
    Status = ERROR_SUCCESS;

    if ( (_State & APPSTATE_SCRIPT_NOT_EXISTED) && (_State & APPSTATE_SCRIPT_PRESENT) && _pwszLocalScriptPath )
    {
        //
        // Remove the local script for the upgrade app since this app is not currently applied --
        // we need to revert since the user does not have rights in this directory.
        // 

        _pManApp->Revert();     

        DeleteFile( _pwszLocalScriptPath );

        Status = _pManApp->Impersonate();
    }

    return Status;
}

BOOL
CAppInfo::CopyToApplicationInfo(
    APPLICATION_INFO * pApplicationInfo
    )
{
    GuidToString( _DeploymentId, &pApplicationInfo->pwszDeploymentId );
    pApplicationInfo->pwszDeploymentName = StringDuplicate( _pwszDeploymentName );
    pApplicationInfo->pwszGPOName = StringDuplicate( _pwszGPOName );
    pApplicationInfo->pwszProductCode = StringDuplicate( _pwszProductId );
    pApplicationInfo->pwszDescriptor = 0;
    pApplicationInfo->pwszSetupCommand = 0;
    pApplicationInfo->Flags = 0;

    if ( INSTALLUILEVEL_FULL == _InstallUILevel )
        pApplicationInfo->Flags = APPINFOFLAG_FULLUI;
    else
        pApplicationInfo->Flags = APPINFOFLAG_BASICUI;

    if ( _State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED) )
        pApplicationInfo->Flags |= APPINFOFLAG_ALREADYMANAGED;

    if ( ACTION_UNINSTALL == _Action )
        pApplicationInfo->Flags |= APPINFOFLAG_UNINSTALL;
    else if ( ACTION_ORPHAN == _Action )
        pApplicationInfo->Flags |= APPINFOFLAG_ORPHAN;

    if ( ! pApplicationInfo->pwszDeploymentId ||
         ! pApplicationInfo->pwszDeploymentName ||
         ! pApplicationInfo->pwszGPOName ||
         ! pApplicationInfo->pwszProductCode )
        return FALSE;

    return TRUE;
}

void
CAppInfo::AddToOverrideList(
    GUID * pDeploymentId
    )
{
    GUID * pOldList;

    if ( _pManApp->ARPList() )
        return;

    pOldList = _pOverrides;

    _pOverrides = new GUID[_Overrides+1];
    if ( ! _pOverrides )
    {
        _pOverrides = pOldList;
        return;
    }

    if ( _Overrides > 0 )
    {
        memcpy( _pOverrides, pOldList, _Overrides * sizeof(GUID) );
        delete pOldList;
    }

    memcpy( &_pOverrides[_Overrides++], pDeploymentId, sizeof(GUID) );
}

DWORD
CallMsiConfigureProduct(
    WCHAR *         pwszProduct,
    int             InstallLevel,
    INSTALLSTATE    InstallState,
    WCHAR *         pwszCommandLine
    )
{
    DWORD   Status;

    Status = (*gpfnMsiConfigureProductEx)( pwszProduct, InstallLevel, InstallState, pwszCommandLine );

    REMAP_DARWIN_STATUS( Status );

    return Status;
}

DWORD
CallMsiReinstallProduct(
    WCHAR * pwszProduct
    )
{
    DWORD   Status;

    Status = (*gpfnMsiReinstallProduct)(
                pwszProduct,
                REINSTALLMODE_FILEOLDERVERSION | REINSTALLMODE_PACKAGE | REINSTALLMODE_MACHINEDATA | REINSTALLMODE_USERDATA | REINSTALLMODE_SHORTCUT );

    REMAP_DARWIN_STATUS( Status );

    return Status;
}

DWORD
CallMsiAdvertiseScript(
    WCHAR *         pwszScriptFile,
    DWORD           Flags,
    PHKEY           phkClasses,
    BOOL            bRemoveItems
    )
{
    return (*gpfnMsiAdvertiseScript)( pwszScriptFile, Flags, phkClasses, bRemoveItems );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\appmgext.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  appmgext.cxx
//
//*************************************************************

#include "appmgext.hxx"

BOOL gbInitialized = FALSE;
HINSTANCE ghInst = NULL;


extern "C" DWORD WINAPI
ProcessGroupPolicyObjectsEx(
    IN DWORD dwFlags,
    IN HANDLE hUserToken,
    IN HKEY hKeyRoot,
    IN PGROUP_POLICY_OBJECT  pDeletedGPOList,
    IN PGROUP_POLICY_OBJECT  pChangedGPOList,
    IN ASYNCCOMPLETIONHANDLE pHandle,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
    IN IWbemServices *pWbemServices,
    OUT HRESULT      *phrRsopStatus
    )
{
    DWORD   Status;

    *phrRsopStatus = S_OK;

    Status = ERROR_SUCCESS;

    //
    // It is not appropriate for appmgmt to function in safe mode --
    // detect this case and exit if we are in safe mode
    //
    if ( dwFlags & GPO_INFO_FLAG_SAFEMODE_BOOT )
        return ERROR_GEN_FAILURE;

    if ( ! gbInitialized )
        Initialize();

    InitDebugSupport( DEBUGMODE_POLICY );
    CreatePolicyEvents();

    if ( dwFlags & GPO_INFO_FLAG_VERBOSE )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;

    ConditionalBreakIntoDebugger();

    //
    // Before NT 5.1, appmgmt was never applied in the background. Starting
    // with NT 5.1 however, it gets called for background refresh when asynchronous
    // foreground refreshes are enabled so that it can detect the need for a synchronous refresh.

    //
    // Normally, it will not be called for a slow link, but that behavior
    // can be modified by policy on group policy.
    //

    //
    // Note that during the asynchronous foreground refresh, the background refresh flag is
    // also set in order to maintain compatibility with earlier extensions, so when detecting
    // a true background refresh case below, we need to make sure the asynchronous foreground flag
    // is not enabled
    //
    if ( ( dwFlags & GPO_INFO_FLAG_BACKGROUND ) && ! ( dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND ) )
    {
        DebugMsg((DM_VERBOSE, IDS_BACKGROUND_REFRESH));

        //
        // For background refreshes, we will notify the policy engine that we
        // need to be called in the synchronous foreground refresh if there are changes
        //
        if ( ! ( dwFlags & GPO_INFO_FLAG_NOCHANGES ) )
        {
            DebugMsg((DM_VERBOSE, IDS_CHANGES_DETECTED));

            Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
        }

        DebugMsg((DM_VERBOSE, IDS_PROCESSGPT_RETURN, Status));

        return Status;
    }

    gpEvents->SetToken( hUserToken );

    LogTime();

    SignalPolicyStart( ! (dwFlags & GPO_INFO_FLAG_MACHINE) );

    CRsopAppContext DiagnosticModeContext(
        pWbemServices,
        ( dwFlags & GPO_INFO_FLAG_LOGRSOP_TRANSITION ) && ! ( dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND ), 
        phrRsopStatus );

    if ( pDeletedGPOList )
    {
        DiagnosticModeContext.SetGPOAppRemoval();

        Status = ProcessGPOList(
                    pDeletedGPOList,
                    dwFlags,
                    hUserToken,
                    hKeyRoot,
                    pfnStatusCallback,
                    PROCESSGPOLIST_DELETED,
                    &DiagnosticModeContext
                    );
    }

    if ( pChangedGPOList && (ERROR_SUCCESS == Status) )
    {
        DiagnosticModeContext.SetGPOAppAdd();

        Status = ProcessGPOList(
                    pChangedGPOList,
                    dwFlags,
                    hUserToken,
                    hKeyRoot,
                    pfnStatusCallback,
                    PROCESSGPOLIST_CHANGED,
                    &DiagnosticModeContext);
    }

    DebugMsg((DM_VERBOSE, IDS_PROCESSGPT_RETURN, Status));

    SignalPolicyEnd( ! (dwFlags & GPO_INFO_FLAG_MACHINE) );

    gpEvents->ClearToken();

    return Status;
}


DWORD
ProcessGPOList(
    PGROUP_POLICY_OBJECT   pGPOList,
    DWORD                  dwFlags,
    HANDLE                 hUserToken,
    HKEY                   hKeyRoot,
    PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
    DWORD                  dwListType,
    CRsopAppContext*       pRsopContext
    )
{
    CManagedAppProcessor * pManApps;
    PGROUP_POLICY_OBJECT   pCurrentGPO;

    DWORD   Status;
    BOOL    bDeletedGPOs;

    //
    // In reporting mode, we need to dump all the apps --
    // here, we are computing resultant set, which is much different
    // than dumping the contents -- we will simply exit 
    // successfully and instead allow the ARP planning simulation
    // to dump the list of apps
    //
    if ( pRsopContext->IsReportingModeEnabled() )
    {
        return STATUS_SUCCESS;
    }

    CLoadMsi    LoadMsi( Status );

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = ERROR_OUTOFMEMORY;

    bDeletedGPOs = (PROCESSGPOLIST_DELETED == dwListType);

    pManApps = new CManagedAppProcessor(
        dwFlags,
        hUserToken,
        hKeyRoot,
        pfnStatusCallback,
        FALSE,
        ! bDeletedGPOs,
        pRsopContext,
        Status);

    if ( ERROR_SUCCESS != Status )
    {
        if ( pManApps )
            delete pManApps;

        pManApps = 0;
    }

    if ( ! pManApps )
        return Status;

    if ( bDeletedGPOs )
    {
        DebugMsg((DM_VERBOSE, IDS_POLICY_REMOVED, dwFlags));
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_POLICY_APPLY, dwFlags));
    }

    Status = pManApps->SetPolicyListFromGPOList( pGPOList );
    if ( ERROR_SUCCESS != Status )
        return Status;

    if ( bDeletedGPOs )
        Status = pManApps->Delete();
    else
        Status = pManApps->Process();

    //
    // Write any Rsop logs -- this is a no op if
    // rsop logging is not enabled
    //
    pManApps->WriteRsopLogs();

    if ( ! pManApps->NoChanges() &&
         ((Status != ERROR_SUCCESS) || ! bDeletedGPOs) )
    {
        gpEvents->PolicyStatus( Status, pManApps->ErrorReason() );
    }

    if ( ! pManApps->GetRsopContext()->PurgeRemovalEntries() )
    {
        pRsopContext->ResetRemovalPurge();
    }

    HRESULT hrRsopStatus;

    hrRsopStatus = pManApps->GetRsopContext()->GetRsopStatus();

    if ( FAILED( hrRsopStatus ) )
    {
        gpEvents->RsopLoggingStatus( hrRsopStatus );
    }

    delete pManApps;

    return Status;
}

extern "C" BOOL WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH :
        ghDllInstance = hInstance;
        gSystemLangId = GetSystemDefaultLangID();
        DisableThreadLibraryCalls(hInstance);
        InitDebugSupport( DEBUGMODE_CLIENT );
        InitializeClassStore(FALSE);

        //
        // Init our event logging -- this is used
        // by both server and cstore subcomponents
        //
        gpEvents = new CEvents();

        if (!gpEvents)
            return FALSE;

        break;
    case DLL_PROCESS_DETACH :
        Uninitialize();
        break;
    }

    return TRUE;
}

void
Initialize()
{
    ghInst = LoadLibrary( L"appmgmts.dll" );
    gbInitialized = ghInst != NULL;
}

extern "C" DWORD WINAPI
GenerateGroupPolicy(
                   IN DWORD dwFlags,
                   IN BOOL  *pbAbort,
                   IN WCHAR *pwszSite,
                   IN PRSOP_TARGET pComputerTarget,
                   IN PRSOP_TARGET pUserTarget )
{
    DWORD   Status;

    Status = ERROR_SUCCESS;

    if ( ! gbInitialized )
        Initialize();

    InitDebugSupport( DEBUGMODE_POLICY );

    if ( dwFlags & GPO_INFO_FLAG_VERBOSE )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;

    ConditionalBreakIntoDebugger();

    LogTime();

    if ( pComputerTarget && pComputerTarget->pGPOList )
    {
        CRsopAppContext MachinePlanningModeContext(
            pComputerTarget,
            dwFlags & GPO_INFO_FLAG_REPORT
            );

        Status = ProcessGPOList(
                    pComputerTarget->pGPOList,
                    dwFlags,
                    NULL,
                    NULL,
                    NULL,
                    PROCESSGPOLIST_CHANGED,
                    &MachinePlanningModeContext);

        if ( ( ERROR_SUCCESS == Status ) &&
             ( dwFlags & GPO_INFO_FLAG_REPORT ) )
        {
            CRsopAppContext MachineReportingModeContext( pComputerTarget, TRUE );

            Status = GenerateManagedApplications( 
                pComputerTarget->pGPOList,
                dwFlags,
                &MachineReportingModeContext);
        }
    }

    if ( pUserTarget && pUserTarget->pGPOList )
    {
        CRsopAppContext UserPlanningModeContext(
            pUserTarget,
            dwFlags & GPO_INFO_FLAG_REPORT
            );

        Status = ProcessGPOList(
                    pUserTarget->pGPOList,
                    dwFlags,
                    NULL,
                    NULL,
                    NULL,
                    PROCESSGPOLIST_CHANGED,
                    &UserPlanningModeContext);

        if ( ERROR_SUCCESS == Status )
        {
            CRsopAppContext UserPlanningModeARPContext( pUserTarget, dwFlags & GPO_INFO_FLAG_REPORT );

            Status = GenerateManagedApplications( 
                pUserTarget->pGPOList,
                dwFlags,
                &UserPlanningModeARPContext);
        }
    }

    //
    // In planning mode, Need to undo the extra reference count
    // that normally occurs in regular policy execution mode.
    //
    if ( ghInst )
    {
        FreeLibrary( ghInst );
    }

    DebugMsg((DM_VERBOSE, IDS_PROCESSGPT_RETURN, Status));

    return Status;
}


DWORD
GenerateManagedApplications(
    PGROUP_POLICY_OBJECT  pGPOList,
    DWORD                 dwFlags,
    CRsopAppContext*      pRsopContext 
    )
{
    DWORD   Status;
    HRESULT hr;

    hr = pRsopContext->SetARPContext();

    if ( FAILED(hr) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    CManagedAppProcessor ApplicationProcessor(
        dwFlags,
        NULL,
        NULL,
        NULL,
        TRUE,
        FALSE,
        pRsopContext,
        Status);

    if ( ERROR_SUCCESS == Status )
    {
        Status = ApplicationProcessor.SetPolicyListFromGPOList(
            pGPOList);

        if ( ERROR_SUCCESS == Status )
        {
            Status = ApplicationProcessor.GetManagedApplications(
                NULL,
                NULL);
        }
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\conflict.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 2000-2001
//  All rights reserved
//
//  conflict.cxx
//
//*************************************************************

#include "appmgext.hxx"


CConflict::CConflict( 
    CAppInfo* pAppInfo,
    CAppInfo* pWinner,
    DWORD     dwReason,
    LONG      Precedence ) :
    _pAppInfo( pAppInfo ),
    _pwszConflictId( NULL ),
    _Precedence( Precedence ),
    _PrecedenceReason( dwReason ),
    _pWinner( pWinner )
{}

CConflict::~CConflict()
{
    delete [] _pwszConflictId;
}

HRESULT 
CConflict::Write() 
{
    HRESULT hr;

    DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_WRITE_INFO, GetApp()->_pwszDeploymentName, GetApp()->_pwszGPOName));

    hr = SetValue(
        RSOP_ATTRIBUTE_ID,
        _pwszConflictId);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_ID, hr )

    if (FAILED(hr))
    {
        goto CConflict_Write_cleanup;
    }

    hr = SetValue(
        RSOP_ATTRIBUTE_PRECEDENCE,
        _Precedence);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_PRECEDENCE, hr )

    if (FAILED(hr))
    {
        goto CConflict_Write_cleanup;
    }

    if ( 1 == _Precedence )
    {
        _PrecedenceReason = APP_ATTRIBUTE_REASON_VALUE_WINNING;
    }

    if ( 0 != _PrecedenceReason ) 
    {
        hr = SetValue(
            APP_ATTRIBUTE_PRECEDENCE_REASON,
            (LONG) _PrecedenceReason);
        
        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PRECEDENCE_REASON, hr )
    }

    if ( 0 != _Precedence )
    {
        if ( _Precedence > 1 || AlreadyExists() )
        {
            GetApp()->_dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE;

            hr = ClearValue( APP_ATTRIBUTE_APPLY_CAUSE );

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPLY_CAUSE, hr )
        }
    }
    else
    {
        GetApp()->_dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_NONE;
    }
            
    hr = GetApp()->Write( this );        

CConflict_Write_cleanup:

    return S_OK;
}

HRESULT
CConflict::GetPath( WCHAR* wszPath, DWORD* pchLength )
{
    //
    // A relative path to an instance of RSOP_ApplicationManagementPolicySetting
    // looks like:
    //
    // RSOP_ApplicationManagementPolicySetting.EntryType=<entrytype>,id="<id-guid>",applicationid="<appid-guid>",precedence=<precedence>
    //
    DWORD cchRequired;
    HRESULT hr = S_OK;

    ASSERT( ( GetApp()->GetPublicRsopEntryType() <= APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM ) &&
            ( GetApp()->GetPublicRsopEntryType() >= APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE ) );

    cchRequired = sizeof( RELATIVE_PATH_FORMAT ) / sizeof( WCHAR ) + // Fixed length portion
                    1 +                                              // Entry type
                    MAX_SZGUID_LEN * 2 +                             // 2 guids
                    9;                                               // Precedence = 1

    if ( cchRequired <= *pchLength )
    {
        WCHAR  wszDeploymentId[ MAX_SZGUID_LEN ];
        WCHAR* wszApplicationId;

        LONG  lPrecedence;
        LONG  EntryType;

        if ( GetApp()->_bRemovalLogged )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE;
            lPrecedence = 0;
        }
        else
        {
            EntryType = GetApp()->GetPublicRsopEntryType();
            lPrecedence = 1;
        }

        GuidToString( GetApp()->_DeploymentId, wszDeploymentId);

        //
        // Since we are only using precedence 1 applications, the application id
        // happens to be the same as the id
        //
        wszApplicationId = wszDeploymentId;

        hr = StringCchPrintf( 
            wszPath,
            *pchLength,
            RELATIVE_PATH_FORMAT, 
            EntryType,
            wszDeploymentId,
            wszApplicationId,
            lPrecedence);

        ASSERT(SUCCEEDED(hr));
    }
    else
    {
        *pchLength = cchRequired;

        hr = S_FALSE;
    }
            
     return hr;
}



HRESULT
CConflict::SetConflictId( WCHAR* pwszConflictId )
{
    HRESULT hr;

    hr = ERROR_SUCCESS;

    ASSERT ( ! _pwszConflictId );

    _pwszConflictId = StringDuplicate( pwszConflictId );

    if ( ! _pwszConflictId )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


CConflictList::~CConflictList()
{
    CConflict* pConflict;

    Reset();
    
    for ( Reset(); pConflict = (CConflict*) GetCurrentItem(); )
    {
        MoveNext();

        pConflict->Remove();

        delete pConflict;
    }
}

LONG
CConflictList::AddConflict( CAppInfo* pAppInfo, CAppInfo* pWinner, DWORD dwReason, LONG Precedence )
{
    CConflict* pNewConflict;

    pNewConflict = new CConflict( pAppInfo, pWinner, dwReason, Precedence );

    if ( ! pNewConflict )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InsertFIFO( pNewConflict );

    return ERROR_SUCCESS;
}

CConflictTable::CConflictTable() :
    _pLastConflict( NULL )
{}

void
CConflictTable::Reset()
{
    _pLastConflict = NULL;

    _SupersededApps.Reset();
}


LONG
CConflictTable::AddConflict(
    CAppInfo* pAppInfo,
    CAppInfo* pWinner,
    DWORD     dwReason,
    LONG      Prececence )
{
    return _SupersededApps.AddConflict( pAppInfo, pWinner, dwReason );
}

CConflict*
CConflictTable::GetNextConflict( LONG* pCurrentPrecedence )
{
    CConflict* pNextConflict;

    pNextConflict = NULL;       

    //
    // If we're at the end, leave
    //
    if ( ! _pLastConflict && ! _SupersededApps.GetCurrentItem() )
    {
        return NULL;
    }

    //
    // Try to traverse the last conflict to find the next conflict
    //
    if ( _pLastConflict )
    {
        //
        // The precedence of the next application should be one more
        // than the last conflict
        //
        pNextConflict = _pLastConflict->GetApp()->GetConflictTable()->GetNextConflict( pCurrentPrecedence );

        if ( pNextConflict )
        {
            (*pCurrentPrecedence)++; 
        }
    }

    if ( ! pNextConflict )
    {
        //
        // If we did not find a conflict as a result of the previous conflict,
        // let's try the next item in our conflict list
        //
        pNextConflict = (CConflict*) ( _SupersededApps.GetCurrentItem() );

        _SupersededApps.MoveNext();

        if ( pNextConflict )
        {
            pNextConflict->GetApp()->GetConflictTable()->Reset();
        }
    }

    _pLastConflict = pNextConflict;

    //
    // We are finished calculating the precedence and may now
    // set the final precedence value
    //
    if ( pNextConflict )
    {
        pNextConflict->_Precedence = *pCurrentPrecedence;
    }

    return pNextConflict;
}

LONG
CConflictTable::GenerateResultantConflictList( CConflictList* pConflictList )
{
    CConflict* pConflict;
    LONG       Status;
    LONG       Precedence;

    Precedence = 2;

    Status = ERROR_SUCCESS;

    Reset();

    while ( pConflict = GetNextConflict( &Precedence ) )
    {
        Status = pConflictList->AddConflict( 
            pConflict->GetApp(),
            pConflict->_pWinner,
            pConflict->_PrecedenceReason,
            pConflict->_Precedence);

        if ( ERROR_SUCCESS != Status )
            break;

        Precedence = pConflict->_Precedence;
    }
     
    return Status;
}

HRESULT
CConflict::LogFailure()
{
    //
    // We only log status for settings
    // with failures
    //
    CAppStatus* pAppStatus;

    //
    // First, see if this setting (app) has a status
    //
    pAppStatus = (CAppStatus*) GetApp()->_StatusList.GetCurrentItem();

    if ( ! pAppStatus )
    {
        return S_FALSE;
    }

    //
    // Advance the list to the next failure so
    // that the next caller will log a different failure
    //
    GetApp()->_StatusList.MoveNext();

    //
    // Skip this status if this is not a failure
    //
    if ( RSOPFailed != pAppStatus->_SettingStatus )
    {
        return S_OK;
    }

    HRESULT        hr;
    IWbemServices* pWbemServices;

    //
    // Bind to WMI -- this is essentially no op in policy refresh
    //
    hr = GetApp()->_pManApp->GetRsopContext()->Bind( &pWbemServices );

    if ( SUCCEEDED(hr) )
    {
        POLICYSETTINGSTATUSINFO SettingStatus;
        
        memset( &SettingStatus, 0, sizeof( SettingStatus ) );

        SettingStatus.szEventSource = APPMGMT_EVENT_SOURCE;
        SettingStatus.szEventLogName = L"Application";
        SettingStatus.dwEventID = pAppStatus->_dwEventId;
        SettingStatus.dwErrorCode = ERROR_SUCCESS;
        SettingStatus.status = pAppStatus->_SettingStatus;
        SettingStatus.timeLogged = pAppStatus->_StatusTime;
        
        hr = RsopSetPolicySettingStatus(
            0,
            pWbemServices,
            GetRecordInterface(),
            1,
            &SettingStatus);
    }

    if ( FAILED(hr) )
    {
        REPORT_ATTRIBUTE_SET_STATUS( L"Policy Setting Status", hr )
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\logonmsg.h ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  logonmsg.h
//
//*************************************************************

#define IDS_STATUS_APPLY            1000
#define IDS_STATUS_ADVERTISE        1001
#define IDS_STATUS_INSTALL          1002
#define IDS_STATUS_UNINSTALL        1003

#define IDS_STATUS_COMPUTER_SETTINGS    1100
#define IDS_STATUS_USER_SETTINGS        1101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\events.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  events.cxx
//
//*************************************************************

#include "appmgext.hxx"

void
CEvents::Assign(
    DWORD       ErrorStatus,
    CAppInfo *  pAppInfo
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_ASSIGN_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName,
            wszStatus );

        SetRsopFailureStatus(
            pAppInfo,
            ErrorStatus,
            EVENT_APPMGMT_ASSIGN_FAILED);
    }
    else
    {
        Report(
            EVENT_APPMGMT_ASSIGN,
            FALSE,
            2,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName );
    }
}

void
CEvents::Reinstall(
    DWORD       ErrorStatus,
    CAppInfo *  pAppInfo
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_REINSTALL_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName,
            wszStatus );

        SetRsopFailureStatus(
            pAppInfo,
            ErrorStatus,
            EVENT_APPMGMT_REINSTALL_FAILED);
    }
    else
    {
        Report(
            EVENT_APPMGMT_REINSTALL,
            FALSE,
            2,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName );
    }
}

void
CEvents::Unassign(
    DWORD       ErrorStatus,
    CAppInfo *  pAppInfo
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_UNASSIGN_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName,
            wszStatus );

        SetRsopFailureStatus(
            pAppInfo,
            ErrorStatus,
            EVENT_APPMGMT_UNASSIGN_FAILED);
    }
    else
    {
        Report(
            EVENT_APPMGMT_UNASSIGN,
            FALSE,
            2,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName );
    }
}

void
CEvents::Upgrade(
    CAppInfo *  pNewApp,
    CAppInfo *  pOldApp,
    BOOL        bForceUninstall
    )
{
    DWORD   EventId;

    EventId = bForceUninstall ? EVENT_APPMGMT_HARD_UPGRADE : EVENT_APPMGMT_SOFT_UPGRADE;

    Report(
        EventId,
        FALSE,
        4,
        pNewApp->_pwszDeploymentName,
        pNewApp->_pwszGPOName,
        pOldApp->_pwszDeploymentName,
        pOldApp->_pwszGPOName );
}

void
CEvents::UpgradeAbort(
    DWORD       ErrorStatus,
    CAppInfo *  pNewApp,
    CAppInfo *  pOldApp,
    BOOL        bOldFailed
    )
{
    WCHAR   wszStatus[12];

    DwordToString( ErrorStatus, wszStatus );

    Report(
        bOldFailed ? EVENT_APPMGMT_UPGRADE_ABORT : EVENT_APPMGMT_UPGRADE_ABORT2,
        ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
        5,
        pNewApp->_pwszDeploymentName,
        pNewApp->_pwszGPOName,
        pOldApp->_pwszDeploymentName,
        pOldApp->_pwszGPOName,
        wszStatus );

    SetRsopFailureStatus(
        pNewApp,
        ErrorStatus,
        bOldFailed ? EVENT_APPMGMT_UPGRADE_ABORT : EVENT_APPMGMT_UPGRADE_ABORT2);
}

void
CEvents::UpgradeComplete(
    CAppInfo *  pNewApp,
    CAppInfo *  pOldApp
    )
{
    Report(
        EVENT_APPMGMT_UPGRADE_COMPLETE,
        FALSE,
        4,
        pNewApp->_pwszDeploymentName,
        pNewApp->_pwszGPOName,
        pOldApp->_pwszDeploymentName,
        pOldApp->_pwszGPOName );
}

void
CEvents::RemoveUnmanaged(
    CAppInfo *  pAppInfo
    )
{
    Report(
        EVENT_APPMGMT_REMOVE_UNMANAGED,
        FALSE,
        2,
        pAppInfo->_pwszDeploymentName,
        pAppInfo->_pwszGPOName );
}

void
CEvents::PolicyStatus(
    DWORD       ErrorStatus,
    DWORD       ErrorReason
    )
{
    WCHAR   wszStatus[12];
    WCHAR   wszReason[192];
    DWORD   Size;
    int     Status;

    if ( ErrorStatus != ERROR_SUCCESS )
    {
		if ( ! LoadLoadString() )
			return;

        DwordToString( ErrorStatus, wszStatus );

        wszReason[0] = 0;
        Size = sizeof(wszReason) / sizeof(WCHAR);

        switch ( ErrorReason )
        {
        case ERRORREASON_CSPATH :
            (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_CSPATH, wszReason, Size );
            break;
        case ERRORREASON_ENUM :
            (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_ENUM, wszReason, Size );
            break;
        case ERRORREASON_LOCAL :
            (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_LOCAL, wszReason, Size );
            break;
        case ERRORREASON_PROCESS :
            if ( ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED != ErrorStatus )
            {
                (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_PROCESS, wszReason, Size );
            }
            else
            {
                //
                // When we fail due to the need for a sync foreground refresh, we log
                // a special warning event that makes the situation very clear
                //

                //
                // The message depends on whether this is user or machine policy, so we
                // load different messages in those cases
                //
                if ( _hUserToken )
                {
                    (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_ASYNC_USER, wszReason, Size );
                }
                else
                {
                    (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_ASYNC_MACHINE, wszReason, Size );                    
                }
            }
            break;
        }

        Report(
            EVENT_APPMGMT_POLICY_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            2,
            wszReason,
            wszStatus);
    }
    else
    {
        Report( EVENT_APPMGMT_POLICY, FALSE, 0 );
    }
}

void
CEvents::PolicyAbort()
{
    Report( EVENT_APPMGMT_POLICY_ABORT, FALSE, 0 );
}


void
CEvents::Install(
        DWORD                 ErrorStatus,
        CAppInfo*             pAppInfo
        )
{
    ( (CEventsBase*) this)->Install(
        ErrorStatus,
        pAppInfo->_pwszDeploymentName,
        pAppInfo->_pwszGPOName);

    SetRsopFailureStatus(
        pAppInfo,
        ErrorStatus,
        EVENT_APPMGMT_INSTALL_FAILED);
}

void
CEvents::Uninstall(
    DWORD                 ErrorStatus,
    CAppInfo*             pAppInfo
    )
{
    ( (CEventsBase*) this)->Uninstall(
        ErrorStatus,
        pAppInfo->_pwszDeploymentName,
        pAppInfo->_pwszGPOName);

    SetRsopFailureStatus(
        pAppInfo,
        ErrorStatus,
        EVENT_APPMGMT_UNINSTALL_FAILED);
}


void
CEvents::RsopLoggingStatus( HRESULT hrStatus )
{
    WCHAR   wszStatus[12];

    DwordToString( (DWORD) hrStatus, wszStatus );    

    Report( EVENT_APPMGMT_RSOP_FAILED, FALSE, 1, wszStatus );
}


void
CEvents::SetRsopFailureStatus(
    CAppInfo* pAppInfo,
    DWORD     dwStatus,
    DWORD     dwEventId)
{
    //
    // We only log failure status in logging (diagnostic) mode
    //
    if ( ! pAppInfo->_pManApp->GetRsopContext()->IsDiagnosticModeEnabled() )
    {
        return;
    }

    //
    // Now set the app's failure status
    //
    pAppInfo->SetRsopFailureStatus(
        dwStatus,
        dwEventId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\catlog.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  catlog.cxx
//
//*************************************************************

#include "appmgext.hxx"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfo::CCategoryInfo
//
// Purpose: Constructor for category encapsulation class --
//          initializes state with information about a category
//
// Params: pCategoryInfo -- structure containing information
//         about this category
//
// Return value: none
//
// Notes:  The class maintains the reference to the passed
//         in structure -- therefore, the memory for that
//         structure should not be freed before this object
//         is used.  This class does not own the reference --
//         caller should free the pCategoryInfo memory after
//         this class is no longer in use.
//
//------------------------------------------------------------
CCategoryInfo::CCategoryInfo(
    APPCATEGORYINFO*     pCategoryInfo) :
    _pCategoryInfo( pCategoryInfo )
{}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfo::Write
//
// Purpose: Write information regarding this category into
//          a database record
//
// Params: 
//
// Return value: S_OK if successful, error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CCategoryInfo::Write()
{
    HRESULT hr;
    WCHAR   wszUniqueId[MAX_SZGUID_LEN];

    //
    // Get our unique id
    //
    GuidToString(
        _pCategoryInfo->AppCategoryId,
        wszUniqueId);

    //
    // The category guid is the unique id for this record --
    //
    hr = SetValue(
        CAT_ATTRIBUTE_ID,
        wszUniqueId);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Set the time stamp on the record
    //
    {
        SYSTEMTIME CurrentTime;
        
        //
        // This does not fail
        //
        GetSystemTime( &CurrentTime );

        hr = SetValue(
            CAT_ATTRIBUTE_CREATIONTIME,
            &CurrentTime);

        REPORT_ATTRIBUTE_SET_STATUS( CAT_ATTRIBUTE_CREATIONTIME, hr );
    }

    //
    // Set the name of the category
    //
    hr = SetValue(
        CAT_ATTRIBUTE_NAME,
        _pCategoryInfo->pszDescription);

    REPORT_ATTRIBUTE_SET_STATUS( CAT_ATTRIBUTE_NAME, hr );

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::CCategoryInfoLog
//
// Purpose: Initialize the domain app categories to log object
//
// Params: 
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CCategoryInfoLog::CCategoryInfoLog(
    CRsopContext*        pRsopContext,
    APPCATEGORYINFOLIST* pCategoryList ) :
    _bRsopEnabled( FALSE ),
    _pRsopContext( pRsopContext ),
    _pCategoryList( pCategoryList )
{
    if ( ! pCategoryList )
    {
        _pCategoryList = & _AppCategoryList;
    }

    //
    // Zero the list of apps so the destructor never mistakes
    // unitialized data for real data that it would attempt to free
    //
    RtlZeroMemory(&_AppCategoryList, sizeof(_AppCategoryList));
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::~CCategoryInfoLog
//
// Purpose: Initialize the domain app categories to log object
//
// Params: 
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CCategoryInfoLog::~CCategoryInfoLog()
{
    //
    // If the members of this function are NULL, this is
    // just a noop.  Otherwise, it clears all memory
    // references by this structure and its members.
    //
    (void) ReleaseAppCategoryInfoList( &_AppCategoryList );
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::WriteLog
//
// Purpose: Log domain categories to the policy database
//
// Params: none
//
// Return value: S_OK if all categories logged, S_FALSE if
//               one or more categories could not be logged,
//               other error otherwise
//
// Notes: Does nothing if the rsop logging is disabled
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::WriteLog()
{
    HRESULT hr;

    //
    // Make sure logging is enabled -- if not, this function
    // will just be a noop. Logging is disabled if we have
    // any sort of initialization errors.
    //
    if ( !_pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Initialize the log so that we can write into it -- if this
    // doesn't succeed, we can't log anything.
    //
    hr = InitCategoryLog();

    if (FAILED(hr))
    {
        return hr;
    }

    if ( _pRsopContext->IsPlanningModeEnabled() )
    {
        //
        // Now that log support is set, we need to obtain the categories
        // which we are going to log
        //
        hr = GetCategoriesFromDirectory();

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // We have the categories we wish to log, now we should write 
    // all the categories to the log
    //
    return WriteCategories();
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::InitCategoryLog
//
// Purpose: Initialize the logging support, including 
//          establishing a connection to the policy database
//
// Params: none
//
// Return value: S_OK if successful, other error otherwise
//
// Notes: If this fails, categories cannot be logged
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::InitCategoryLog()
{
    HRESULT hr;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Initialize the base logging functions to allow logging
    // to the policy database of the class of policy
    // in which we're interested: software categories.  We
    // supply a flag indicating whether this is machine or user
    // policy since machine and user policy records are logged
    // in separate namespaces (i.e. we maintain separate logs).
    //
    hr = InitLog( _pRsopContext,
                  RSOP_MANAGED_SOFTWARE_CATEGORY);

    //
    // If this init fails, we should disable logging so
    // subsequent method calls on this object will
    // not attempt to write to an inaccessible database
    //
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // We have access to the database, we should clear previous
    // logs in this namespace
    //
    hr = ClearLog();

    //
    // If we couldn't clear the log, we will not attempt to write
    // any more records -- we make sure of this by resetting the
    // disable flag
    //
    if (SUCCEEDED(hr))
    {
        _bRsopEnabled = TRUE;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::AddBlankCategory
//
// Purpose: Adds an empty category record to the log
//
// Params: none
//
// Return value: S_OK if successful, other error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::AddBlankCategory(CCategoryInfo* pCategoryInfo)
{
    return AddBlankRecord(pCategoryInfo);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::GetCategories()
//
// Purpose: Obtains the list of app categories from the domain
//
// Params: none
//
// Return value: S_OK if successful, other error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::GetCategoriesFromDirectory()
{
    HRESULT hr;

    //
    // Call the internal api to the directory service software
    // management interface to obtain the list of categories
    //
    hr = CsGetAppCategories( &_AppCategoryList );

    if (FAILED(hr))
    {
        return hr;
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::WriteLog
//
// Purpose: Write domain categories as records 
//          to the policy database
//
// Params: none
//
// Return value: S_OK if all categories logged, S_FALSE if
//               one or more categories could not be logged,
//               other error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::WriteCategories()
{
    DWORD   iCat;
    HRESULT hr;

    hr = S_OK;

    //
    // Iterate through the list of categories so that we
    // can log each one.
    //
    for (iCat = 0; iCat < _pCategoryList->cCategory; iCat++)
    {
        HRESULT hrWrite;

        DebugMsg((DM_VERBOSE, IDS_RSOP_CAT_INFO, _pCategoryList->pCategoryInfo[iCat].pszDescription));

        //
        // Place this code in a new scope so that the constructor
        // and destructor for CCategoryInfo are called each time (we
        // need to get a new record object for each iteration in the loop)
        //
        {
            //
            // Create a record object with information about the current
            // category in this iteration
            //
            CCategoryInfo CategoryInfo( &(_pCategoryList->pCategoryInfo[iCat]) );

            //
            // Now write the record into the database.
            //
            hrWrite = WriteNewRecord( &CategoryInfo );

            //
            // Set our return value to S_FALSE if we failed in any way to log this category
            //
            if (FAILED(hrWrite))
            {
                DebugMsg((DM_VERBOSE, IDS_RSOP_CAT_WRITE_FAIL, _pCategoryList->pCategoryInfo->pszDescription, hr));
                hr = S_FALSE;
            }
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\main.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  main.cxx
//
//*************************************************************

#include "appmgext.hxx"

static SERVICE_STATUS gServiceStatus;
static SERVICE_STATUS_HANDLE ghServiceHandle;
static HINSTANCE ghInstAppmgmt;

extern "C" void
ServiceHandler(
    DWORD   OpCode
    );

void
UpdateState(
    DWORD   NewState
    );

extern "C" void
ServiceMain(
    DWORD               argc,
    LPWSTR              argv[]
    )
{
    DWORD   Status;
    BOOL    bStatus;

    Status = ERROR_SUCCESS;

    if ( ! gbInitialized )
        Initialize();

    InitDebugSupport( DEBUGMODE_SERVICE );

    VerboseDebugDump( L"Entering ServiceMain" );

    gServiceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    gServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    gServiceStatus.dwControlsAccepted = 0;
    gServiceStatus.dwWin32ExitCode = 0;
    gServiceStatus.dwServiceSpecificExitCode = 0;
    gServiceStatus.dwCheckPoint = 0;
    gServiceStatus.dwWaitHint = 10000L;

    ghServiceHandle = RegisterServiceCtrlHandler( L"APPMGMT", ServiceHandler );

    if ( ! ghServiceHandle )
        Status = GetLastError();

    if ( ERROR_SUCCESS == Status )
    {
        //
        // SD is null indicating that RPC should pick a default DACL.
        // which should be everybody can call and nobody can change this
        // permission
        //
        Status = RpcServerUseProtseqEp(
                    L"ncalrpc",
                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                    L"appmgmt",
                    NULL );
    }

    if ( ERROR_SUCCESS == Status )
        Status = RpcServerRegisterIf( appmgmt_ServerIfHandle, NULL, NULL );

    if ( Status != ERROR_SUCCESS )
    {
        gServiceStatus.dwWin32ExitCode = Status;
        UpdateState( SERVICE_STOPPED );
        return;
    }

    InitializeCriticalSection( &gAppCS );

    UpdateState( SERVICE_RUNNING );
}

extern "C" void
ServiceHandler(
    DWORD   OpCode
    )
{
    RPC_STATUS status;

    switch( OpCode )
    {
    case SERVICE_CONTROL_STOP:
        // Not registered for this control.
        break;

    case SERVICE_CONTROL_INTERROGATE:
        // Service controller wants us to call SetServiceStatus.
        UpdateState( gServiceStatus.dwCurrentState );
        break ;

    case SERVICE_CONTROL_SHUTDOWN:
        // Not registered for this control.
        break;

    // case SERVICE_CONTROL_PAUSE:
    // case SERVICE_CONTROL_CONTINUE:
    default:
        break;
    }

    return;
}

void
UpdateState(
    DWORD   NewState
    )
{
    DWORD Status = ERROR_SUCCESS;

    switch ( NewState )
    {
    case SERVICE_RUNNING:
    case SERVICE_STOPPED:
        gServiceStatus.dwCheckPoint = 0;
        gServiceStatus.dwWaitHint = 0;
        break;

    case SERVICE_START_PENDING:
    case SERVICE_STOP_PENDING:
        ++gServiceStatus.dwCheckPoint;
        gServiceStatus.dwWaitHint = 30000L;
        break;

    default:
        ASSERT(0);
        return;
    }

    gServiceStatus.dwCurrentState = NewState;
    SetServiceStatus( ghServiceHandle, &gServiceStatus );

    // We could return a status but how would we recover?  Ignore it, the
    // worst thing is that services will kill us and there's nothing
    // we can about it if this call fails.
}

void * midl_user_allocate( size_t len )
{
    return (void *) LocalAlloc( 0, len );
}

void midl_user_free( void * ptr )
{
    LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\debug.cxx ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "appmgext.hxx"

//
// Policy finish events for test code.  Only used if DL_EVENT debug
// level is on.
//
HANDLE ghUserPolicyEvent = 0;
HANDLE ghMachinePolicyEvent = 0;

void
CreatePolicyEvents()
{
    SECURITY_ATTRIBUTES SecAttr;
    SECURITY_DESCRIPTOR SecDesc;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    PSID psidAdmin = NULL;
    PSID psidSystem = NULL;
    PSID psidEveryOne = NULL;
    PACL pAcl = NULL;
    DWORD cbMemSize;
    DWORD cbAcl;



    if ( ! (gDebugLevel & DL_EVENT) )
        return;

    if ( ghUserPolicyEvent && ghMachinePolicyEvent )
        return;

    
    //
    // Create an SD with following permissions
    //      LocalSystem:F
    //      Administrators:F
    //      EveryOne:Synchronize
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0, &psidSystem)) 
    {
         goto Exit;
    }

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) 
    {
        goto Exit;
    }

    if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0, &psidEveryOne)) 
    {
        goto Exit;
    }
     
    cbAcl = (GetLengthSid (psidSystem)) +
            (GetLengthSid (psidAdmin))  +
            (GetLengthSid (psidEveryOne))  +
            sizeof(ACL) +
            (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    pAcl = (PACL) LocalAlloc(LPTR, cbAcl);
    
    if (!pAcl)
    {
       goto Exit;
    }

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) 
    {
        goto Exit;
    }

    if (!AddAccessAllowedAceEx(pAcl, ACL_REVISION, 0, GENERIC_ALL, psidSystem)) 
    {
        goto Exit;
    }

    if (!AddAccessAllowedAceEx(pAcl, ACL_REVISION, 0, GENERIC_ALL, psidAdmin)) 
    {
        goto Exit;
    }

    if (!AddAccessAllowedAceEx(pAcl, ACL_REVISION, 0, SYNCHRONIZE, psidEveryOne)) 
    {
        goto Exit;
    }

    if (!InitializeSecurityDescriptor( &SecDesc, SECURITY_DESCRIPTOR_REVISION )) 
    {
        goto Exit;
    }

    if (!SetSecurityDescriptorDacl( &SecDesc, TRUE, pAcl, FALSE )) 
    {
        goto Exit;
    }


    SecAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecAttr.lpSecurityDescriptor = &SecDesc;
    SecAttr.bInheritHandle = FALSE;

    if ( ! ghUserPolicyEvent )
    {
        ghUserPolicyEvent = CreateEvent(
                                &SecAttr,
                                TRUE,
                                FALSE,
                                L"AppMgmtUserPolicyEvent" );
    }

    if ( ! ghMachinePolicyEvent )
    {
        ghMachinePolicyEvent = CreateEvent(
                                &SecAttr,
                                TRUE,
                                FALSE,
                                L"AppMgmtMachinePolicyEvent" );
    }

Exit:
    if (psidSystem) 
    {
        FreeSid(psidSystem);
    }
    
    if (psidAdmin) 
    {
        FreeSid(psidAdmin);
    }
    
    if (psidEveryOne) 
    {
        FreeSid(psidEveryOne);
    }

    if (pAcl) 
    {
       LocalFree (pAcl);
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\cspath.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  cspath.cxx
//
//  Class for building and setting the ClassStore path in the
//  registry.
//
//*************************************************************

#include "appmgext.hxx"

CSPath::CSPath()
{
    _pwszPath = 0;
}

CSPath::~CSPath()
{
    if ( _pwszPath )
        LocalFree( _pwszPath );
}

DWORD
CSPath::AddComponent(
    WCHAR * pwszDSPath,
    WCHAR * pwszDisplayName
    )
{
    WCHAR * pwszCSPath;
    WCHAR * pwszNewPath;
    DWORD   Size;
    HRESULT hr;
    DWORD   Status;
 
    if ( ! pwszDSPath )
        return ERROR_SUCCESS;

    hr = CsGetClassStorePath( pwszDSPath, &pwszCSPath );

    if ( hr != S_OK )
    {
        //
        // This call was simply a string manipulation, it should 
        // only fail due to out of memory
        //
        DebugMsg((DM_VERBOSE, IDS_NO_CLASSSTORE, pwszDisplayName, hr));
        return (DWORD) hr;
    }

    Size = 0;

    if ( _pwszPath )
        Size += lstrlen(_pwszPath) * sizeof(WCHAR);

    Size += (lstrlen(pwszCSPath) + 2) * sizeof(WCHAR);

    pwszNewPath = (WCHAR *) LocalAlloc( 0, Size );

    if ( ! pwszNewPath )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        hr = StringCchCopy( pwszNewPath, Size, pwszCSPath );
        if (FAILED(hr)) 
        {
            LocalFree(pwszNewPath);
            Status = HRESULT_CODE(hr);
        }
        else
        {
            hr = StringCchCat( pwszNewPath, Size, L";" );
            if (SUCCEEDED(hr))
            {
                if ( _pwszPath )
                {
                    hr = StringCchCat( pwszNewPath, Size, _pwszPath );
                }
            }
            if (FAILED(hr)) 
            {
                LocalFree(pwszNewPath);
                Status = HRESULT_CODE(hr);
            }
            else
            {            
                LocalFree( _pwszPath );
                _pwszPath = pwszNewPath;
                Status = ERROR_SUCCESS;
            }
        }
    }

    LocalFree( pwszCSPath );

    return Status;
}

DWORD
CSPath::Commit(
    HANDLE hToken
    )
{
    DWORD   Status;

    if ( _pwszPath )
    {
        Status = WriteClassStorePath(hToken, _pwszPath);

        DebugMsg((DM_VERBOSE, IDS_CSPATH, _pwszPath));
    }
    else
    {
        (void) WriteClassStorePath(hToken, L"");
        Status = CS_E_NO_CLASSSTORE;

        DebugMsg((DM_VERBOSE, IDS_NOCSPATH));
    }

    return Status;
}

DWORD
CSPath::WriteClassStorePath(
    HANDLE hToken,
    LPWSTR pwszClassStorePath
    )
{
    DWORD   err;
    LPWSTR  wszIniFilePath;
    HRESULT hr;
    DWORD   dwSize;

    err = GetScriptDirPath(
        hToken,
        sizeof(APPMGMT_INI_FILENAME) / sizeof(WCHAR),
        &wszIniFilePath,
        &dwSize);

    if (ERROR_SUCCESS != err)
    {
        return err;
    }

    hr = StringCchCat(wszIniFilePath, dwSize, APPMGMT_INI_FILENAME);
    if (FAILED(hr)) 
    {
        err = HRESULT_CODE(hr);
    }
    if (ERROR_SUCCESS == err) 
    {
        err = WriteClassStorePathToFile(
            wszIniFilePath,
            pwszClassStorePath);
    }

    delete [] wszIniFilePath;

    return err;
}


LONG
CSPath::WriteClassStorePathToFile(
    WCHAR* wszIniFilePath,
    WCHAR* wszClassStorePath
    )
{
    HANDLE hFile;
    BOOL   bStatus;
    DWORD  dwWritten;

    //
    // This method attempts to write the class store path
    // into a file in a non-roaming portion of the user's profile.
    //
    // The format of the file is simple: it is a sequence of unicode
    // characters terminated by a null unicode character -- i.e.,
    // its contents are simply the exact bytes of the wszClassStorePath
    // parameter, including the terminating character.
    //
    // Clients reading the file should verify that the very last character
    // of the file is a null terminator in order to detect corrupt files.
    //

    //
    // First, attempt to open the file, creating it if it does not exist
    //
    hFile = CreateFile(
        wszIniFilePath,
        GENERIC_WRITE,
        0,    // do not allow anyone else access while we are modifying the file
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_SYSTEM,
        NULL);

    //
    // If we can't create the file, we have failed
    //
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        return GetLastError();
    }

    LONG Status;

    Status = ERROR_SUCCESS;

    //
    // Now erease the data in it -- truncate the file to the current file pointer,
    // which is at the beginning of the file
    //
    bStatus = SetEndOfFile( hFile );

    //
    // If we cannot erase the current contents, this is a failure
    //
    if ( ! bStatus )
    {
        Status = GetLastError();
        goto cleanup_and_exit;
    }

    //
    // Now write the class store path into the file -- we simply do a memory copy
    // of the string into the file
    //
    bStatus = WriteFile(
        hFile,
        wszClassStorePath,
        ( lstrlen(wszClassStorePath) + 1 ) * sizeof(*wszClassStorePath),
        &dwWritten,
        NULL);

    //
    // If the write failed, find out why and return that status
    //
    if ( ! bStatus )
    {
        Status = GetLastError();
    }

cleanup_and_exit:

    //
    // Free our file resource since its no longer needed
    //
    CloseHandle( hFile );

    //
    // Everything worked, we return a success code
    //
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\util.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  util.cxx
//
//*************************************************************

#include "appmgext.hxx"

SRSETRESTOREPOINTW * gpfnSRSetRetorePointW = 0;

BOOL
IsMemberOfAdminGroup(
    HANDLE hUserToken
    )
{
    SID_IDENTIFIER_AUTHORITY AuthorityNT = SECURITY_NT_AUTHORITY;
    PSID            pSidAdmin;
    BOOL            bStatus;
    BOOL            bIsAdmin;

    bIsAdmin = FALSE;
    pSidAdmin = 0;

    bStatus = AllocateAndInitializeSid( &AuthorityNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSidAdmin );

    if ( bStatus )
        bStatus = CheckTokenMembership( hUserToken, pSidAdmin, &bIsAdmin );

    FreeSid( pSidAdmin );

    return bIsAdmin;
}

DWORD
GetPreviousSid(
    HANDLE      hUserToken,
    WCHAR *     pwszCurrentScriptPath,
    WCHAR **    ppwszPreviousSid
    )
{
    HANDLE      hFind;
    WIN32_FIND_DATA FindData;
    PSID        pSid;
    WCHAR *     pwszSlash1;
    WCHAR *     pwszSlash2;
    WCHAR *     pwszSearchPath;
    DWORD       Length;
    DWORD       Status;
    BOOL        bMember;
    BOOL        bStatus;

    *ppwszPreviousSid = 0;

    //
    // Script dir paths created by GetScriptDirPath have '\' at the end.
    //
    pwszSlash1 = wcsrchr( pwszCurrentScriptPath, L'\\' );
    *pwszSlash1 = 0;
    pwszSlash2 = wcsrchr( pwszCurrentScriptPath, L'\\' );
    *pwszSlash2 = 0;

    Length = lstrlen(pwszCurrentScriptPath);
    pwszSearchPath = new WCHAR[Length + 3];

    if ( pwszSearchPath )
    {
        memcpy( pwszSearchPath, pwszCurrentScriptPath, Length * sizeof(WCHAR) );
        pwszSearchPath[Length] = L'\\';
        pwszSearchPath[Length+1] = L'*';
        pwszSearchPath[Length+2] = 0;
    }

    *pwszSlash1 = *pwszSlash2 = L'\\';
    
    if ( ! pwszSearchPath )
        return ERROR_OUTOFMEMORY;

    //
    // We've constructed a search path of %systemroot%\system32\appmgmt\*.
    //
    hFind = FindFirstFile( pwszSearchPath, &FindData );

    delete [] pwszSearchPath;

    if ( INVALID_HANDLE_VALUE == hFind )
        return ERROR_SUCCESS;

    Status = ERROR_SUCCESS;

    do
    {
        if ( ! (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
            continue;

        if ( (0 == lstrcmp( FindData.cFileName, L"." )) ||
             (0 == lstrcmp( FindData.cFileName, L".." )) ||
             (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, FindData.cFileName, -1, L"MACHINE", -1) == CSTR_EQUAL))

            continue;

        bMember = FALSE;
        pSid = 0;
        bStatus = ConvertStringSidToSid( FindData.cFileName, &pSid );

        if ( bStatus )
        {
            bStatus = CheckTokenMembership( hUserToken, pSid, &bMember );

            if ( bStatus && bMember )
                bStatus = ConvertSidToStringSid( pSid, ppwszPreviousSid );

            LocalFree( pSid );
        }

        if ( ! bStatus )
        {
            Status = GetLastError();
            break;
        }

        if ( bMember )
            break;
    } while ( FindNextFile( hFind, &FindData ) );

    FindClose( hFind );

    return Status;
}

DWORD
RenameScriptDir(
    WCHAR *     pwszPreviousSid,
    WCHAR *     pwszCurrentScriptPath
    )
{
    WCHAR * pwszSlash1;
    WCHAR * pwszSlash2;
    WCHAR * pwszOldScriptPath;
    DWORD   Length;
    BOOL    bStatus;

    //
    // Script dir paths created by GetScriptDirPath have '\' at the end.
    //
    pwszSlash1 = wcsrchr( pwszCurrentScriptPath, L'\\' );
    *pwszSlash1 = 0;
    pwszSlash2 = wcsrchr( pwszCurrentScriptPath, L'\\' );
    *pwszSlash2 = 0;

    Length = lstrlen( pwszCurrentScriptPath );

    pwszOldScriptPath = new WCHAR[Length + 1 + lstrlen(pwszPreviousSid) + 1];
    
    if ( pwszOldScriptPath )
    {
        HRESULT hr;

        memcpy( pwszOldScriptPath, pwszCurrentScriptPath, Length * sizeof(WCHAR) );
        pwszOldScriptPath[Length] = L'\\';
        hr = StringCchCopy( &pwszOldScriptPath[Length+1], lstrlen(pwszPreviousSid) + 1, pwszPreviousSid );
        if (FAILED(hr)) 
        {
            delete [] pwszOldScriptPath;
            return hr;
        }
    }

    *pwszSlash1 = *pwszSlash2 = L'\\';

    if ( ! pwszOldScriptPath )
        return ERROR_OUTOFMEMORY;

    bStatus = MoveFileEx( pwszOldScriptPath, pwszCurrentScriptPath, 0 );

    delete [] pwszOldScriptPath;

    if ( ! bStatus )
        return GetLastError();

    return ERROR_SUCCESS;
}

DWORD
GetCurrentUserGPOList( 
    OUT PGROUP_POLICY_OBJECT* ppGpoList // Free this with the FreeGPOList API
    )
{
    GUID  AppmgmtExtension = {0xc6dc5466, 0x785a, 0x11d2, 
                              0x84, 0xd0,
                              0x00, 0xc0, 0x4f, 0xb1, 0x69, 0xf7};

    return GetAppliedGPOList(
        0,
        NULL,
        NULL,
        &AppmgmtExtension,
        ppGpoList);
} 


DWORD GetWin32ErrFromHResult( HRESULT hr )
{
    DWORD   Status = ERROR_SUCCESS;

    if (S_OK != hr)
    {
        if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
        {
            Status = HRESULT_CODE(hr);
        }
        else
        {
            Status = GetLastError();
            if (ERROR_SUCCESS == Status)
            {
                //an error had occurred but nobody called SetLastError
                //should not be mistaken as a success.
                Status = (DWORD) hr;
            }
        }
    }

    return Status;
}

void  ClearManagedApp( MANAGED_APP* pManagedApp )
{
    if (pManagedApp->pszPackageName)
    {
        midl_user_free(pManagedApp->pszPackageName);
    }

    if (pManagedApp->pszSupportUrl)
    {
        midl_user_free(pManagedApp->pszSupportUrl);
    }

    if (pManagedApp->pszPolicyName)
    {
        midl_user_free(pManagedApp->pszPolicyName);
    }

    if (pManagedApp->pszPublisher)
    {
        midl_user_free(pManagedApp->pszPublisher);
    }

    //
    // Make sure to clear the structure if there is a failure
    // so we won't try to marshal bogus data
    //
    memset(pManagedApp, 0, sizeof(*pManagedApp));
}

CLoadSfc::CLoadSfc( DWORD &Status )
{
    hSfc = LoadLibrary( L"sfc.dll" );

    if ( ! hSfc )
    {
        Status = GetLastError();
        return;
    }

    gpfnSRSetRetorePointW = (SRSETRESTOREPOINTW *) GetProcAddress( hSfc, "SRSetRestorePointW" );

    if ( ! gpfnSRSetRetorePointW )
    {
        Status = ERROR_PROC_NOT_FOUND;
        return;
    }

    Status = ERROR_SUCCESS;
}

CLoadSfc::~CLoadSfc()
{
    if ( hSfc )
        FreeLibrary( hSfc );
}

//
// Force policy to be synchronous at next refresh --
// use a token for user policy, NULL for machine policy
//
DWORD ForceSynchronousRefresh( HANDLE hUserToken )
{
    LONG           Status;
    UNICODE_STRING SidString;

    Status = GetSidString( hUserToken, &SidString );

    if ( ERROR_SUCCESS == Status )
    {
        //
        // Inform the gp engine to give us a sync refresh
        //
        Status = ForceSyncFgPolicy( SidString.Buffer );

        RtlFreeUnicodeString( &SidString );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\appmgmt\server\manapp.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  manapp.cxx
//
//*************************************************************

#include "appmgext.hxx"

#pragma warning(disable:4355)

CManagedAppProcessor::CManagedAppProcessor(
        DWORD             dwFlags,
        HANDLE            hUserToken,
        HKEY              hKeyRoot,
        PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
        BOOL              bIncludeLegacy,
        BOOL              bRegularPolicyRun,
        CRsopAppContext*  pRsopContext,
        DWORD &           Status
    ) : _Apps( this, &_RsopContext ), _LocalScripts( this ), _pfnStatusCallback(pfnStatusCallback)
{
    DWORD   Size;
    DWORD   LastArchLang;
    BOOL    bFullPolicy;
    HRESULT hr;

    _bUser = ! (dwFlags & GPO_INFO_FLAG_MACHINE);
    _bNoChanges = (dwFlags & GPO_INFO_FLAG_NOCHANGES) && ! (gDebugLevel & DL_APPLY) && ! ( dwFlags & GPO_INFO_FLAG_LOGRSOP_TRANSITION );
    _bAsync = (dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND) && ! (gDebugLevel & DL_APPLY) && ! ( dwFlags & GPO_INFO_FLAG_LOGRSOP_TRANSITION );
    _bARPList = FALSE;
    _hkRoot = 0;
    _hkPolicy = 0;
    _hkAppmgmt = 0;
    _hUserToken = 0;
    _NewUsn = 0;
    _ArchLang = 0;
    
    _pwszLocalPath = 0;
    
    _bIncludeLegacy = bIncludeLegacy;
    _bDeleteGPOs = FALSE;
    _bRegularPolicyRun = bRegularPolicyRun;
    _ErrorReason = 0;

    //
    // In the case of gpo removal, we cannot apply this during an async refresh
    //
    if ( _bAsync  && ! bRegularPolicyRun )
    {
        _ErrorReason = ERRORREASON_PROCESS;
        
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;

        return;
    }
    
    if ( CRsopAppContext::POLICY_REFRESH == pRsopContext->GetContext() )
    {
        if ( _bAsync )
        {
            DebugMsg((DM_VERBOSE, IDS_ASYNC_REFRESH));
        }
        else
        {
            DebugMsg((DM_VERBOSE, IDS_SYNC_REFRESH));
        }
    }

    hr = GetRsopContext()->MoveAppContextState( pRsopContext );

    if ( FAILED( hr ) )
    {
        Status = GetWin32ErrFromHResult( hr );
        goto CManagedAppProcessor__CManagedAppProcessor_Exit;
    }

    if ( _bUser && ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        if ( ! DuplicateToken( hUserToken, SecurityImpersonation, &_hUserToken ) )
        {
            goto CManagedAppProcessor__CManagedAppProcessor_Exit;
        }
    }

    //
    // Act as if there are changes when planning mode is enabled
    //
    if ( GetRsopContext()->IsPlanningModeEnabled() )
    {
        _bNoChanges = FALSE;
    }

    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        Status = RegOpenKeyEx(
            hKeyRoot,
            NULL,
            0,
            KEY_READ | KEY_WRITE,
            &_hkRoot );

        if ( Status != ERROR_SUCCESS )
            goto CManagedAppProcessor__CManagedAppProcessor_Exit;

        Status = RegCreateKeyEx(
            _hkRoot,
            POLICYKEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &_hkPolicy,
            NULL );

        if ( Status != ERROR_SUCCESS )
            goto CManagedAppProcessor__CManagedAppProcessor_Exit;

        Status = RegCreateKeyEx(
            _hkPolicy,
            APPMGMTSUBKEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &_hkAppmgmt,
            NULL );

        if ( Status != ERROR_SUCCESS )
            goto CManagedAppProcessor__CManagedAppProcessor_Exit;
    }

    BOOL        bForcedRefresh;

    bForcedRefresh = FALSE;

    if ( bRegularPolicyRun )
    {
        SYSTEM_INFO SystemInfo;

        //
        // The service sets the FULLPOLICY value when the user does an uninstall.
        // This forces us to do a full policy run to pick up any new app that may
        // need to be applied now.
        //

        bFullPolicy = FALSE;
        Size = sizeof( bFullPolicy );

        if (!GetRsopContext()->IsPlanningModeEnabled())
        {
            (void) RegQueryValueEx(
                _hkAppmgmt,
                FULLPOLICY,
                NULL,
                NULL,
                (LPBYTE) &bFullPolicy,
                &Size );
            (void) RegDeleteValue( _hkAppmgmt, FULLPOLICY );

            if ( _bNoChanges )
            {
                bForcedRefresh = bFullPolicy;
            }
        }
        else
        {
            bFullPolicy = TRUE;
        }

        if ( bFullPolicy )
            _bNoChanges = FALSE;

        _ArchLang = GetSystemDefaultLangID();
        GetSystemInfo( &SystemInfo );
        _ArchLang |= (SystemInfo.wProcessorArchitecture << 16);

        if (!GetRsopContext()->IsPlanningModeEnabled())
        {
            Size = sizeof( LastArchLang );

            Status = RegQueryValueEx(
                _hkAppmgmt,
                LASTARCHLANG,
                NULL,
                NULL,
                (LPBYTE) &LastArchLang,
                &Size );

            if ( (ERROR_SUCCESS == Status) && _bNoChanges && (_ArchLang != LastArchLang) )
            {
                if ( _bNoChanges )
                {
                    bForcedRefresh = TRUE;
                }

                _bNoChanges = FALSE;

                if ( Async() )
                {
                    DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));
                }
            }
        }
    }

    Status = GetScriptDirPath( _bUser ? _hUserToken : NULL, 0, &_pwszLocalPath );

    if ( ERROR_SUCCESS == Status && ! GetRsopContext()->IsPlanningModeEnabled() )
        Status = CreateAndSecureScriptDir();

    if ( (ERROR_SUCCESS == Status) && ! GetRsopContext()->IsPlanningModeEnabled() )
        Status = GetLocalScriptAppList( _LocalScripts );

    if ( Status != ERROR_SUCCESS )
    {
        DebugMsg((DM_WARNING, IDS_CREATEDIR_FAIL, Status));
        goto CManagedAppProcessor__CManagedAppProcessor_Exit;
    }

    if ( _bNoChanges )
    {
        if ( DetectLostApps() )
        {
            bForcedRefresh = TRUE;
            _bNoChanges = FALSE;
        }
    }

    //
    // Ensure that the rsop context is properly initialized, even if the
    // group policy engine did not give us a context but we need to log data
    //
    (void) GetRsopContext()->InitializeRsopContext(
        UserToken(),
        AppmgmtKey(),
        bForcedRefresh,
        &_bNoChanges);
    
CManagedAppProcessor__CManagedAppProcessor_Exit:

    return;
}

#pragma warning(default:4355)

CManagedAppProcessor::~CManagedAppProcessor()
{
    if ( _hkPolicy )
        RegCloseKey( _hkPolicy );

    if ( _hkAppmgmt )
        RegCloseKey( _hkAppmgmt );

    if ( _hkRoot )
        RegCloseKey( _hkRoot );

    if ( _hUserToken )
        CloseHandle( _hUserToken );

    delete _pwszLocalPath;
}

BOOL
CManagedAppProcessor::AddGPO(
    PGROUP_POLICY_OBJECT pGPOInfo
    )
{
    CGPOInfo *  pGPO;
    BOOL        bStatus;

    //
    // Prevent duplicates in the list.  A GPO could be linked to multiple
    // OUs, so only keep the last instance of a policy.
    //
    pGPO = _GPOs.Find( pGPOInfo->szGPOName );
    if ( pGPO )
    {
        pGPO->Remove();
        delete pGPO;
    }

    return _GPOs.Add( pGPOInfo );
}

DWORD
CManagedAppProcessor::Delete()
{
    DWORD Status;

    _bDeleteGPOs = TRUE;

    ASSERT( ! Async() );

    Status = GetRemovedApps();

    if ( Status != ERROR_SUCCESS )
    {
        _ErrorReason = ERRORREASON_LOCAL;
        return Status;
    }

    _CSPath.Commit(_hUserToken);

    Status = _Apps.ProcessPolicy();

    if ( Status != ERROR_SUCCESS )
        _ErrorReason = ERRORREASON_PROCESS;

    return Status;
}

DWORD
CManagedAppProcessor::GetRemovedApps()
{
    CAppList    LocalApps( NULL );
    CGPOInfo *  pGPOInfo;
    CAppInfo *  pAppInfo;
    DWORD       Status;

    Status = GetOrderedLocalAppList( LocalApps );

    if ( ERROR_SUCCESS == Status )
        Status = Impersonate();

    if ( Status != ERROR_SUCCESS )
        return Status;

    _GPOs.Reset();

    for ( pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem();
          pGPOInfo;
          _GPOs.MoveNext(), pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem() )
    {
        DebugMsg((DM_VERBOSE, IDS_REMOVE_POLICY, pGPOInfo->_pwszGPOName));

        LocalApps.Reset();

        for ( pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem();
              pAppInfo;
              pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem() )
        {
            //
            // Look for apps in the removed policy.
            //
            // Ignore apps which are not currently assigned or published from the removed
            // policy except for apps which have been uninstalled from machines other
            // than this one.  This is what the second logic check is doing.  In this case
            // we have to uninstall it at this machine as well.
            //
            if ( ! (pAppInfo->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_UNINSTALLED)) ||
                 ((pAppInfo->_State & APPSTATE_UNINSTALLED) && ! (pAppInfo->_State & APPSTATE_SCRIPT_PRESENT)) ||
                 (lstrcmpi( pAppInfo->_pwszGPOId, pGPOInfo->_pwszGPOId ) != 0) )
            {
                LocalApps.MoveNext();
                continue;
            }

            //
            // On very rare occasion, a policy could be removed at the same time a
            // first time logon to a machine is made.  In this case we will need
            // to copy scripts for uninstalled apps.  We attempt to get the script
            // path here.  This may fail for permission reasons, if the policy
            // is being removed, it's likely it will not be accessible for this
            // user/machine.
            //
            if ( (pAppInfo->_State & APPSTATE_POLICYREMOVE_UNINSTALL) &&
                 ! (pAppInfo->_State & APPSTATE_SCRIPT_PRESENT) )
            {
                PACKAGEDISPINFO PackageInfo;
                HRESULT         hr;

                hr = GetDsPackageFromGPO(
                    pGPOInfo,
                    &(pAppInfo->_DeploymentId),
                    &PackageInfo);

                if ( S_OK == hr )
                {
                    pAppInfo->_pwszGPTScriptPath = StringDuplicate( PackageInfo.pszScriptPath );
                    ReleasePackageInfo( &PackageInfo );
                    if ( ! pAppInfo->_pwszGPTScriptPath )
                    {
                        Revert();
                        return ERROR_OUTOFMEMORY;
                    }
                }
            }

            if ( pAppInfo->_State & APPSTATE_POLICYREMOVE_UNINSTALL )
            {
                pAppInfo->SetAction( 
                    ACTION_UNINSTALL,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    NULL);
            }
            else
            {
                pAppInfo->SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    NULL);
            }

            LocalApps.MoveNext();
            pAppInfo->Remove();
            _Apps.InsertFIFO( pAppInfo );
        }

        LocalApps.ResetEnd();
    }

    _GPOs.ResetEnd();

    Revert();

    return Status;
}

DWORD
CManagedAppProcessor::Process()
{
    CGPOInfo *  pGPOInfo;
    DWORD       Status;

    Status = Impersonate();

    if ( Status != ERROR_SUCCESS )
        return Status;

    for ( _GPOs.Reset(); pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem(); _GPOs.MoveNext() )
    {
        Status = _CSPath.AddComponent( pGPOInfo->_pwszGPOPath, pGPOInfo->_pwszGPOName );
        if ( Status != ERROR_SUCCESS )
            break;
    }

    Revert();

    _GPOs.ResetEnd();
        
    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        if ( ERROR_SUCCESS == Status ) 
        {
            Status = _CSPath.Commit( _hUserToken );
        }

        if ( Status != ERROR_SUCCESS )
        {
            if ( CS_E_NO_CLASSSTORE == Status )
            {
                return ERROR_SUCCESS;
            }
            else
            {
                _ErrorReason = ERRORREASON_CSPATH;
                return Status;
            }
        }
    }

    if ( _bNoChanges )
    {
        DebugMsg((DM_VERBOSE, IDS_NOCHANGES));
    }
    else
    {
        if ( ! GetRsopContext()->IsPlanningModeEnabled() )
        {
            LogonMsgApplying();
        }

        // Really returns an HRESULT.
        Status = (DWORD) GetAppsFromDirectory();

        if ( Status != ERROR_SUCCESS )
            _ErrorReason = ERRORREASON_ENUM;
    }

    if ( ERROR_SUCCESS == Status )
        Status = GetAppsFromLocal();

    if ( ERROR_SUCCESS == Status )
        Status = CommitPolicyList();

    if ( ERROR_SUCCESS == Status )
        Status = GetLostApps();

    if ( Status != ERROR_SUCCESS )
        _ErrorReason = ERRORREASON_LOCAL;

    if ( ERROR_SUCCESS == Status )
        Status = _Apps.ProcessPolicy();

    if ( Status != ERROR_SUCCESS )
        _ErrorReason = ERRORREASON_PROCESS;

    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        if ( (ERROR_SUCCESS == Status) && (_ArchLang != 0) )
        {
            (void) RegSetValueEx(
                _hkAppmgmt,
                LASTARCHLANG,
                0,
                REG_DWORD,
                (LPBYTE) &_ArchLang,
                sizeof(_ArchLang) );
        }

        if ( ! _bNoChanges )
            LogonMsgDefault();
    }

    //
    // If we are processing asynchronously and changes are detected,
    // we should ensure that a synchronous refresh occurs next time
    //
    if ( ( ERROR_SUCCESS == Status ) && Async() &&
         ! _bNoChanges ) 
    {
        Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
    }

    return Status;
}

void
CManagedAppProcessor::WriteRsopLogs()
{
    HRESULT hr;
    BOOL    ResultantSetChanged;
    
    hr = S_OK;

    //
    // By default, the resultant set changes only if policy has changed
    //
    ResultantSetChanged = ! _bNoChanges;

#if DBG
    DWORD   DebugStatus;
#endif // DBG

    //
    // If we're in diagnostic mode, make sure we reset
    // the diagnostic namespace if policy has changed
    //
    if ( 
        ( GetRsopContext()->IsDiagnosticModeEnabled() && ResultantSetChanged ) &&
         ( CRsopAppContext::POLICY_REFRESH == GetRsopContext()->GetContext() ) )
    {
        if ( ! GetRsopContext()->IsPlanningModeEnabled() && ! GetRsopContext()->ForcedRefresh() )
        {
            //
            // Reset the namespace
            //
            GetRsopContext()->DeleteSavedNameSpace();
        }
    }

    //
    // For ARP, ensure that no one tries to read the namespace to
    // which we are logging until we are finished. 
    //
    if ( ARPList() )
    {
        hr = GetRsopContext()->GetExclusiveLoggingAccess( NULL == UserToken() );
    }

    //
    // First, make sure rsop logging is enabled
    //
    if ( SUCCEEDED(hr) && GetRsopContext()->IsRsopEnabled() )
    {
        if ( ResultantSetChanged )
        {
            hr = _Apps.WriteLog();

            if (FAILED(hr))
            {
                GetRsopContext()->DisableRsop( hr );
            }
        }
        else
        {
            //
            // Disable rsop if there are no changes -- there is nothing
            // to log
            //
            GetRsopContext()->DisableRsop( S_OK );
        }
    }

    if ( GetRsopContext()->IsRsopEnabled() && 
         GetRsopContext()->IsPlanningModeEnabled() &&
         ARPList() )
    {
        CCategoryInfoLog CategoryLog( GetRsopContext(), NULL); 

        hr = CategoryLog.WriteLog();

        if (FAILED(hr))
        {
            GetRsopContext()->DisableRsop( hr );
        }
    }

    //
    // We will not set ARP's logging namespace if logging is not enabled
    //
    if ( GetRsopContext()->IsRsopEnabled() && ! GetRsopContext()->ForcedRefresh() )
    {
        //
        // First, record the namespace so that app management
        // service can perform rsop logging
        //
        if ( ! ARPList() && ! GetRsopContext()->IsPlanningModeEnabled() )
        {
            (void) GetRsopContext()->SaveNameSpace();

            //
            // For users, whose apps will roam if they have a user profile,
            // write a version into the profile so we can determine if their 
            // profile is in sync with the machine's current rsop data -- this
            // gets updated at each policy run and each time an app is installed
            //
            if ( IsUserPolicy() )
            {
                (void) GetRsopContext()->WriteCurrentRsopVersion( AppmgmtKey() );
            }
        }
    }

    //
    // For ARP, we are now finished logging and users may read
    // the logged data now -- release our lock
    //
    if ( ARPList() )
    {
        (void) GetRsopContext()->ReleaseExclusiveLoggingAccess();
    }
}

HRESULT
CManagedAppProcessor::GetAppsFromDirectory()
{
    IEnumPackage *  pEnumPackage;
    DWORD           Size;
    DWORD           Type;
    DWORD           AppFlags;
    DWORD           Status;
    HRESULT         hr;

    Status = Impersonate();
    if ( Status != ERROR_SUCCESS )
        return HRESULT_FROM_WIN32( Status );

    //
    // Determine what apps to ask the Diretory for
    //
    AppFlags = GetDSQuery();

    if ( DebugLevelOn( DM_VERBOSE ) )
    {
        WCHAR Name[32];
        DWORD NameLength =  sizeof(Name) / sizeof(WCHAR);

        Name[0] = 0;

        if ( _bUser )
        {
            if ( ! GetUserName( Name, &NameLength) )
            {   
                if ( LoadLoadString() )
                    (*pfnLoadStringW)( ghDllInstance, IDS_UNKNOWN, Name, NameLength );
            }

            DebugMsg((DM_VERBOSE, IDS_USERAPPS_NOCAT, Name, AppFlags));
        }
        else
        {
            if ( ! GetComputerName( Name, &NameLength) )
            {
                if ( LoadLoadString() )
                    (*pfnLoadStringW)( ghDllInstance, IDS_UNKNOWN, Name, NameLength );
            }

            DebugMsg((DM_VERBOSE, IDS_MACHINEAPPS, Name, AppFlags));
        }
    }

    //
    // If we are not in planning mode, we can use a function that uses
    // the cached class store ds paths to determine which parts of the
    // ds to query -- this function obtains an enumerator that returns
    // query results from the cached ds paths
    //
    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        hr = CsEnumApps(
            NULL,
            NULL,
            NULL,
            AppFlags,
            &pEnumPackage );
    }
    else
    {
        //
        // In planning mode, we have no cached ds paths and must explicitly
        // specify it in order to obtain an enumerator
        //
        hr = GetPackageEnumeratorFromPath(
            _CSPath.GetPath(),
            NULL,
            AppFlags,
            &pEnumPackage);
    }

    if ( S_OK == hr )
    {
        hr = EnumerateApps(pEnumPackage);
        pEnumPackage->Release();
    }
    else
    {
        DebugMsg((DM_WARNING, IDS_CSENUMAPPS_FAIL, hr));
    }

    Revert();

    return hr;
}

HRESULT
CManagedAppProcessor::EnumerateApps(
    IEnumPackage * pEnumPackages
    )
{
    PACKAGEDISPINFO rgPackages[PACKAGEINFO_ALLOC_COUNT];
    ULONG       cRetrieved;
    CAppList    AppList( this );
    CAppInfo *  pAppInfo;
    CAppInfo *  pAppInfoOldest;
    CGPOInfo *  pGPOInfo;
    WCHAR *     pwszGPOName;
    DWORD       AppCount;
    HRESULT     hr;
    BOOL        bStatus;

    memset( rgPackages, 0, sizeof(rgPackages) );

    for (;;)
    {
        hr = pEnumPackages->Next(
            PACKAGEINFO_ALLOC_COUNT,
            rgPackages,
            &cRetrieved);

        if ( FAILED(hr) )
            return hr;

        // This call only fails on out of memory.
        bStatus = AddAppsFromDirectory( cRetrieved, rgPackages, AppList );

        for ( DWORD n = 0; n < cRetrieved; n++ )
            ReleasePackageInfo( &rgPackages[n] );

        if ( ! bStatus )
            return E_OUTOFMEMORY;

        if ( hr == S_FALSE )
            break;
    }

    //
    // Now that we have all the packages from the DS, we sort them within each policy
    // from oldest to newest deployment time and put them in our final app list.
    //
    for ( _GPOs.Reset(); pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem(); _GPOs.MoveNext() )
    {
        pwszGPOName = 0;
        AppCount = 0;

        for (;;)
        {
            pAppInfoOldest = 0;

            for ( AppList.Reset(); pAppInfo = (CAppInfo *) AppList.GetCurrentItem(); AppList.MoveNext() )
            {
                if ( lstrcmpi( pGPOInfo->_pwszGPOId, pAppInfo->_pwszGPOId ) != 0 )
                    break;

                if ( ! pAppInfoOldest ||
                     (CompareFileTime( &pAppInfo->_USN, &pAppInfoOldest->_USN ) < 0) )
                {
                    pAppInfoOldest = pAppInfo;
                }
            }

            AppList.ResetEnd();

            if ( ! pAppInfoOldest )
                break;

            if ( 0 == AppCount )
            {
                pwszGPOName = pAppInfoOldest->_pwszGPOName;
                DebugMsg((DM_VERBOSE, IDS_GPOAPPS, pwszGPOName));
            }

            AppCount++;

            if ( DebugLevelOn( DM_VERBOSE ) )
            {
                if ( pAppInfoOldest->_ActFlags & ACTFLG_Assigned )
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDASSIGNED, pAppInfoOldest->_pwszDeploymentName, pAppInfoOldest->_ActFlags));
                }
                else if ( pAppInfoOldest->_ActFlags & ACTFLG_Published )
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDPUBLISHED, pAppInfoOldest->_pwszDeploymentName, pAppInfoOldest->_ActFlags));
                }
                else if ( pAppInfoOldest->_ActFlags & ACTFLG_Orphan )
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDORPHANED, pAppInfoOldest->_pwszDeploymentName));
                }
                else if ( pAppInfoOldest->_ActFlags & ACTFLG_Uninstall )
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDUNINSTALLED, pAppInfoOldest->_pwszDeploymentName));
                }
                else
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDUNKNOWN, pAppInfoOldest->_pwszDeploymentName));
                }
            }

            pAppInfoOldest->Remove();
            _Apps.InsertFIFO( pAppInfoOldest );
        }

        if ( AppCount > 0 )
            DebugMsg((DM_VERBOSE, IDS_NUMAPPS, AppCount, pwszGPOName));
    }
    _GPOs.ResetEnd();

    return S_OK;
}

BOOL
CManagedAppProcessor::AddAppsFromDirectory(
    ULONG               cApps,
    PACKAGEDISPINFO *   rgPackageInfo,
    CAppList &          AppList
    )
{
    CAppInfo *  pAppInfo;
    BOOL        bStatus;

    for ( DWORD App = 0; App < cApps; App++)
    {
        switch ( rgPackageInfo[App].PathType )
        {
        case DrwFilePath :
            break;
        case SetupNamePath :
            if ( ! _bIncludeLegacy )
                continue;
            break;
        default :
            continue;
        }

    bStatus = FALSE;

        pAppInfo = new CAppInfo( this, &(rgPackageInfo[App]), FALSE, bStatus );

        if ( ! bStatus )
        {
            if ( pAppInfo )
                delete pAppInfo;
            pAppInfo = 0;
        }

        if ( ! pAppInfo )
            return FALSE;

        AppList.InsertLIFO( pAppInfo );
    }

    return TRUE;
}

DWORD
CManagedAppProcessor::GetDSQuery()
{
    DWORD AppFlags;

    //
    // We perform different queries depending on whether or not RSoP
    // is enabled as well as whether we are doing a query for the
    // ARP list of apps or for a policy run
    //
    if ( GetRsopContext()->IsRsopEnabled() )
    {
        if (ARPList())
        {
            AppFlags = APPQUERY_RSOP_ARP;
        }
        else
        {
            AppFlags = APPQUERY_RSOP_LOGGING;
        }
    }
    else
    {
        if (ARPList())
        {
            AppFlags = APPQUERY_USERDISPLAY;
        }
        else
        {
            AppFlags = APPQUERY_POLICY;
        }
    }

    return AppFlags;
}

DWORD
CManagedAppProcessor::GetManagedApplications(
    GUID *              pCategory,
    ARPCONTEXT*         pArpContext /* allocated on separate waiting thread */
    )
{
    WCHAR                wszCategoryGuid[40];
    DWORD                Status;
    BOOL                 bStatus;
    MANAGED_APPLIST *    pAppList;
    BOOL                 fPlanningMode;

    _bARPList = TRUE;

    fPlanningMode = pArpContext == NULL;

    //
    // *********IMPORTANT********
    // Note that we should not access the pArpContext structure after we've signaled
    // that enumeration is complete using the hEventAppsEnumerated member --
    // otherwise, the stack on which this structure is allocated will disappear
    // once its thread unblocks waiting for us
    //

    if ( ! fPlanningMode )
    {
        pAppList = pArpContext->pAppList;
    }

    Status = ERROR_SUCCESS;

    //
    // GPO precedence list is needed for sorting the apps based on USN
    // and because the upgrade processing logic requires having the GPO
    // precedence list.
    //
    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        Status = LoadPolicyList();
    }
    else
    {
        CGPOInfo* pGPOInfo;

        for ( _GPOs.Reset(); pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem(); _GPOs.MoveNext() )
        {
            Status = _CSPath.AddComponent( pGPOInfo->_pwszGPOPath, pGPOInfo->_pwszGPOName );
            if ( Status != ERROR_SUCCESS )
                break;
        }
    }

    if ( ERROR_SUCCESS == Status )
        Status = GetAppsFromDirectory();

    //
    // Not all managed applications should be visible to the caller --
    // filter out the ones the caller doesn't want
    //
    if ( ERROR_SUCCESS == Status )
        Status = _Apps.ProcessARPList();

    if ( ( Status != ERROR_SUCCESS ) || 
         GetRsopContext()->IsPlanningModeEnabled() )
    {
        goto GetManagedApplications_WriteLogsAndExit;
    }

    if ( pCategory )
    {
        GuidToString( *pCategory, wszCategoryGuid);
        DebugMsg((DM_VERBOSE, IDS_USERAPPS_CAT, wszCategoryGuid));
    }

    //
    // Now that we have the correct list of apps,
    // we need to allocate space for all the apps
    // and copy the data for each app to give back to the user
    //

    //
    // First we must count the number of apps we're giving back.
    //
    // We also determine which apps have common display names and tag them
    // to have their policy name catenated to their display names.
    //

    DWORD dwCount;
    CAppInfo * pAppInfo;
    CAppInfo * pAppInfoOther;

    dwCount = 0;
    _Apps.Reset();

    for ( pAppInfo = (CAppInfo *) _Apps.GetCurrentItem();
          pAppInfo;
          _Apps.MoveNext(), pAppInfo = (CAppInfo *) _Apps.GetCurrentItem() )
    {
        if ( (pAppInfo->_Action != ACTION_INSTALL) )
            continue;
        if ( pCategory && ! pAppInfo->HasCategory( wszCategoryGuid ) )
        {
            pAppInfo->SetAction(
                ACTION_UNINSTALL,
                0,
                NULL);

            continue;
        }

        dwCount++;
    }

    _Apps.ResetEnd();

    //
    // Now that we know how many apps we have, we can allocate
    // space for them.
    //

    if ( ! fPlanningMode )
    {
        pAppList->rgApps = (MANAGED_APP*) midl_user_allocate( sizeof(MANAGED_APP) * dwCount);

        if (!(pAppList->rgApps))
        {
            pArpContext->Status = ERROR_NOT_ENOUGH_MEMORY;

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memset(pAppList->rgApps, 0, dwCount * sizeof(MANAGED_APP));

        //
        // Now we do the copying
        //
        DWORD dwApp;
    
        dwApp = 0;
        _Apps.Reset();

        for (;;)
        {
            CAppInfo* pAppInfoCopy;

            pAppInfoCopy = (CAppInfo *) _Apps.GetCurrentItem();

            if ( ! pAppInfoCopy )
                break;

            _Apps.MoveNext();

            if ( ACTION_INSTALL == pAppInfoCopy->_Action) 
            {
                Status = pA