 Entry = Entry->Flink;
    }

    //
    // If any changes were made to the depth of any lookaside list during
    // this scan period, then lower the scan period to the minimum value.
    // Otherwise, attempt to raise the scan period.
    //

    if (Changes != FALSE) {
        PplCurrentScanPeriod = 1;
    } else {
        if (PplCurrentScanPeriod != MAXIMUM_SCAN_PERIOD) {
            PplCurrentScanPeriod += 1;
        }
    }

    ExReleaseSpinLock(&PplLookasideLock, OldIrql);

    //
    // Restart the timer.
    //

    CTEStartTimer(&PplTimer, PplCurrentScanPeriod * 1000L, PplTimeout, NULL);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\common\9x\mdlpool9x.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mdlpool9x.c

Abstract:

    This file contains the implementation of an NDIS_BUFFER pool.

Author:

    Shaun Cox (shaunco) 11-Nov-1999

--*/

#include "ndis.h"
#include "mdlpool.h"


// The pool structure itself is just a look aside list allocated out of
// non-paged pool.
//
// Each entry in the look aside list is an NDIS_BUFFER structure followed
// by the buffer itself.  We initialize the NDIS_BUFFER structure each
// time we allocate from the look aside list.  We need to do this in order
// to properly associate the NDIS_BUFFER with its owning pool.  This is not
// possible to do with a custom allocate routine for the look aside list
// because their is no provision for an extra context parameter to the
// look aside allocate function.
//

// ---- Temporary Definitions until ndis.h is updated for Millennium -----
//

typedef struct _XNDIS_BUFFER {
    struct _NDIS_BUFFER *Next;
    PVOID VirtualAddress;
    PVOID Pool;
    UINT Length;
    UINT Signature;
} XNDIS_BUFFER, *PXNDIS_BUFFER;

__inline
SIZE_T
NDIS_SIZEOF_NDIS_BUFFER(
    VOID
    )
{
    return sizeof(XNDIS_BUFFER);
}

__inline
VOID
NdisInitializeNdisBuffer(
    OUT PNDIS_BUFFER Buffer,
    IN PVOID Pool,
    IN PVOID VirtualAddress,
    IN UINT Length
    )
{
    PXNDIS_BUFFER Internal = (PXNDIS_BUFFER)Buffer;

    Internal->Next = 0;
    Internal->Pool = Pool;
    Internal->VirtualAddress = VirtualAddress;
    Internal->Length = Length;
    Internal->Signature = 0;
}

__inline
PVOID
NdisGetPoolFromNdisBuffer(
    IN PNDIS_BUFFER Buffer
    )
{
    PXNDIS_BUFFER Internal = (PXNDIS_BUFFER)Buffer;

    return Internal->Pool;
}

// ---- End temporary Definitions until ndis.h is updated for Millennium -----



UINT SizeOfNdisBufferStructure;

// Creates a pool of NDIS_BUFFERs built over non-paged pool.  Each
// NDIS_BUFFER describes a buffer that is BufferSize bytes long.
// If NULL is not returned, MdpDestroyPool should be called at a later time
// to reclaim the resources used by the pool.
//
// Arguments:
//  BufferSize - The size, in bytes, of the buffer that each MDL
//      should describe.
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
MdpCreatePool(
    IN USHORT BufferSize,
    IN ULONG Tag
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;

    ASSERT(BufferSize);

    // Cache the constant value of an NDIS_BUFFER structure size to
    // avoid calling back into NDIS everytime we want a buffer.
    //
    if (0 == SizeOfNdisBufferStructure)
    {
        SizeOfNdisBufferStructure = NDIS_SIZEOF_NDIS_BUFFER();
    }

    ASSERT(SizeOfNdisBufferStructure);

    // Allocate the pool header.  This is a look aside list on Millenium.
    //
    Lookaside = ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(NPAGED_LOOKASIDE_LIST),
                    ' pdM');

    if (Lookaside)
    {
        // The size of the entries allocated by the look aside list are
        // the NDIS_BUFFER structure size plus the buffer size requested by
        // the caller.
        //
        ExInitializeNPagedLookasideList(
            Lookaside,
            NULL,
            NULL,
            0,
            SizeOfNdisBufferStructure + BufferSize,
            Tag,
            0);
    }

    return Lookaside;
}

// Destroys a pool of NDIS_BUFFERs previously created by a call to
// MdpCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpDestroyPool(
    IN HANDLE PoolHandle
    )
{
    ExDeleteNPagedLookasideList(PoolHandle);
}

// Returns an NDIS_BUFFER allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PNDIS_BUFFER
MdpAllocate(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    PNDIS_BUFFER NdisBuffer;
    PUCHAR VirtualAddress;

    ASSERT(PoolHandle);

    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

    // Get an item from the look aside list.
    //
    NdisBuffer = ExAllocateFromNPagedLookasideList(Lookaside);

    if (NdisBuffer)
    {
        // (Re)Initialize it to associate it with the pool handle so that
        // we know which look aside list to return it to when it is freed.
        //
        VirtualAddress = (PUCHAR)NdisBuffer + SizeOfNdisBufferStructure;

        NdisInitializeNdisBuffer(
            NdisBuffer,
            PoolHandle,
            VirtualAddress,
            Lookaside->L.Size - SizeOfNdisBufferStructure);

        *Buffer = VirtualAddress;
    }

    return NdisBuffer;
}

// Free an NDIS_BUFFER to the pool from which it was allocated.
//
// Arguments:
//  NdisBuffer - An NDIS_BUFFER returned from a prior call to MdpAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpFree(
    IN PNDIS_BUFFER NdisBuffer
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;

    // Locate the owning look aside list for this buffer and return it.
    //
    Lookaside = NdisGetPoolFromNdisBuffer(NdisBuffer);
    ASSERT(Lookaside);

    ExFreeToNPagedLookasideList(Lookaside, NdisBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\common\pplasl.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    pplasl.c

Abstract:

    This file contains the implementation of a per-processor lookaside
    list manager.

Author:

    Shaun Cox (shaunco) 25-Oct-1999

--*/

#include "ntddk.h"
#include "pplasl.h"


HANDLE
PplCreatePool(
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    )
{
    HANDLE PoolHandle;
    SIZE_T PoolSize;
    CCHAR NumberProcessors;
    CCHAR NumberLookasideLists;
    CCHAR i;
    PNPAGED_LOOKASIDE_LIST Lookaside;

#if MILLEN
    NumberProcessors = 1;
#else // MILLEN
    NumberProcessors = KeNumberProcessors;
#endif // !MILLEN

    // Allocate room for 1 lookaside list per processor plus 1 extra
    // lookaside list for overflow.  Only allocate 1 lookaside list if
    // we're on a single processor machine.
    //
    NumberLookasideLists = NumberProcessors;
    if (NumberProcessors > 1)
    {
        NumberLookasideLists++;
    }

    PoolSize = sizeof(NPAGED_LOOKASIDE_LIST) * NumberLookasideLists;

    PoolHandle = ExAllocatePoolWithTagPriority(NonPagedPool, PoolSize, Tag,
                                               NormalPoolPriority);
    if (PoolHandle)
    {
        for (i = 0, Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;
             i < NumberLookasideLists;
             i++, Lookaside++)
        {
            ExInitializeNPagedLookasideList(
                Lookaside,
                Allocate,
                Free,
                Flags,
                Size,
                Tag,
                Depth);

            // ExInitializeNPagedLookasideList doesn't really set the
            // maximum depth to Depth, so we'll do it here.
            //
            if (Depth != 0) {
                Lookaside->L.MaximumDepth = Depth;
            }
        }
    }

    return PoolHandle;
}

VOID
PplDestroyPool(
    IN HANDLE PoolHandle
    )
{
    CCHAR NumberProcessors;
    CCHAR NumberLookasideLists;
    CCHAR i;
    PNPAGED_LOOKASIDE_LIST Lookaside;

    if (!PoolHandle)
    {
        return;
    }

#if MILLEN
    NumberProcessors = 1;
#else // MILLEN
    NumberProcessors = KeNumberProcessors;
#endif // !MILLEN

    NumberLookasideLists = NumberProcessors;
    if (NumberProcessors > 1)
    {
        NumberLookasideLists++;
    }

    for (i = 0, Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;
         i < NumberLookasideLists;
         i++, Lookaside++)
    {
        ExDeleteNPagedLookasideList(Lookaside);
    }

    ExFreePool(PoolHandle);
}

PVOID
PplAllocate(
    IN HANDLE PoolHandle,
    OUT LOGICAL *FromList
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    CCHAR NumberProcessors;
    PVOID Entry;

    // Assume we'll get the item from the lookaside list.
    //
    *FromList = TRUE;

#if MILLEN
    NumberProcessors = 1;
#else // MILLEN
    NumberProcessors = KeNumberProcessors;
#endif // !MILLEN

    if (1 == NumberProcessors)
    {
        goto SingleProcessorCaseOrMissedPerProcessor;
    }

    // Try first for the per-processor lookaside list.
    //
    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle +
                    KeGetCurrentProcessorNumber() + 1;

    Lookaside->L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
    if (!Entry)
    {
        Lookaside->L.AllocateMisses += 1;

SingleProcessorCaseOrMissedPerProcessor:
        // We missed on the per-processor lookaside list, (or we're
        // running on a single processor machine) so try for
        // the overflow lookaside list.
        //
        Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

        Lookaside->L.TotalAllocates += 1;
        Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
        if (!Entry)
        {
            Lookaside->L.AllocateMisses += 1;
            Entry = (Lookaside->L.Allocate)(
                        Lookaside->L.Type,
                        Lookaside->L.Size,
                        Lookaside->L.Tag);
            *FromList = FALSE;
        }
    }
    return Entry;
}

VOID
PplFree(
    IN HANDLE PoolHandle,
    IN PVOID Entry
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    CCHAR NumberProcessors;

#if MILLEN
    NumberProcessors = 1;
#else // MILLEN
    NumberProcessors = KeNumberProcessors;
#endif // !MILLEN

    if (1 == NumberProcessors)
    {
        goto SingleProcessorCaseOrMissedPerProcessor;
    }

    // Try first for the per-processor lookaside list.
    //
    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle +
                    KeGetCurrentProcessorNumber() + 1;

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth)
    {
        Lookaside->L.FreeMisses += 1;

SingleProcessorCaseOrMissedPerProcessor:
        // We missed on the per-processor lookaside list, (or we're
        // running on a single processor machine) so try for
        // the overflow lookaside list.
        //
        Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

        Lookaside->L.TotalFrees += 1;
        if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth)
        {
            Lookaside->L.FreeMisses += 1;
            (Lookaside->L.Free)(Entry);
        }
        else
        {
            InterlockedPushEntrySList(
                &Lookaside->L.ListHead,
                (PSLIST_ENTRY)Entry);
        }
    }
    else
    {
        InterlockedPushEntrySList(
            &Lookaside->L.ListHead,
            (PSLIST_ENTRY)Entry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\common\fsbpool.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fsbpool.c

Abstract:

    This file contains the implementation of fixed-size block pool.

Author:

    Shaun Cox (shaunco) 10-Dec-1999

--*/

#include "ntddk.h"
#include "fsbpool.h"

typedef PVOID LPVOID;
#include "align.h"              // Macros: ROUND_UP_POINTER, POINTER_IS_ALIGNED

#define FSB_SCAVENGE_PERIOD_IN_SECONDS          30
#define FSB_MINIMUM_PAGE_LIFETIME_IN_SECONDS    20

#if defined (_WIN64)
#define MAX_CACHE_LINE_SIZE 128
#else
#define MAX_CACHE_LINE_SIZE 64
#endif

// The following structures are used in the single allocation that
// a pool handle points to.
//      PoolHandle ---> [FSB_POOL_HEADER + FSB_CPU_POOL_HEADER for cpu 0 +
//                                         FSB_CPU_POOL_HEADER for cpu 1 + ...
//                                         FSB_CPU_POOL_HEADER for cpu N]
//

// FSB_POOL_HEADER is the data common to all CPUs for a given pool.
//
typedef struct _FSB_POOL_HEADER
{
// cache-line -----
    struct _FSB_POOL_HEADER_BASE
    {
        ULONG Tag;
        USHORT CallerBlockSize;     // caller's requested block size
        USHORT AlignedBlockSize;    // ALIGN_UP(CallerBlockSize, PVOID)
        USHORT BlocksPerPage;
        USHORT FreeBlockLinkOffset;
        PFSB_BUILDBLOCK_FUNCTION BuildFunction;
        PVOID Allocation;
    };
    UCHAR Alignment[MAX_CACHE_LINE_SIZE
            - (sizeof(struct _FSB_POOL_HEADER_BASE) % MAX_CACHE_LINE_SIZE)];
} FSB_POOL_HEADER, *PFSB_POOL_HEADER;

C_ASSERT(sizeof(FSB_POOL_HEADER) % MAX_CACHE_LINE_SIZE == 0);


// FSB_CPU_POOL_HEADER is the data specific to a CPU for a given pool.
//
typedef struct _FSB_CPU_POOL_HEADER
{
// cache-line -----
    struct _FSB_CPU_POOL_HEADER_BASE
    {
        // The doubly-linked list of pages that make up this processor's pool.
        // These pages have one or more free blocks available.
        //
        LIST_ENTRY PageList;

        // The doubly-linked list of pages that are fully in use.  This list
        // is separate from the above list so that we do not spend time walking
        // a very long list during FsbAllocate when many pages are fully used.
        //
        LIST_ENTRY UsedPageList;

        // The next scheduled time (in units of KeQueryTickCount()) for
        // scavenging this pool.  The next scavenge will happen no earlier
        // than this.
        //
        LARGE_INTEGER NextScavengeTick;

        // The number of the processor that owns this pool.
        //
        ULONG OwnerCpu;

        ULONG TotalBlocksAllocated;
        ULONG TotalBlocksFreed;
        ULONG PeakBlocksInUse;
        ULONG TotalPagesAllocated;
        ULONG TotalPagesFreed;
        ULONG PeakPagesInUse;
    };
    UCHAR Alignment[MAX_CACHE_LINE_SIZE
            - (sizeof(struct _FSB_CPU_POOL_HEADER_BASE) % MAX_CACHE_LINE_SIZE)];
} FSB_CPU_POOL_HEADER, *PFSB_CPU_POOL_HEADER;

C_ASSERT(sizeof(FSB_CPU_POOL_HEADER) % MAX_CACHE_LINE_SIZE == 0);


// FSB_PAGE_HEADER is the data at the beginning of each allocated pool page
// that describes the current state of the blocks on the page.
//
typedef struct _FSB_PAGE_HEADER
{
// cache-line -----
    // Back pointer to the owning cpu pool.
    //
    PFSB_CPU_POOL_HEADER Pool;

    // Linkage entry for the list of pages managed by the cpu pool.
    //
    LIST_ENTRY PageLink;

    // Number of blocks built so far on this page.  Blocks are built on
    // demand.  When this number reaches Pool->BlocksPerPage, all blocks on
    // this page have been built.
    //
    USHORT BlocksBuilt;

    // Boolean indicator of whether or not this page is on the cpu pool's
    // used-page list.  This is checked during FsbFree to see if the page
    // should be moved back to the normal page list.
    // (it is a USHORT, instead of BOOLEAN, for proper padding)
    //
    USHORT OnUsedPageList;

    // List of free blocks on this page.
    //
    SLIST_HEADER FreeList;

    // The value of KeQueryTickCount (normalized to units of seconds)
    // which represents the time after which this page can be freed back
    // to the system's pool.  This time is only used once the depth of
    // FreeList is Pool->BlocksPerPage.  (i.e. this time is only used if
    // the page is completely unused.)
    //
    LARGE_INTEGER LastUsedTick;

} FSB_PAGE_HEADER, *PFSB_PAGE_HEADER;

// Get a pointer to the overall pool given a pointer to one of
// the per-processor pools within it.
//
__inline
PFSB_POOL_HEADER
PoolFromCpuPool(
    IN PFSB_CPU_POOL_HEADER CpuPool
    )
{
    return (PFSB_POOL_HEADER)(CpuPool - CpuPool->OwnerCpu) - 1;
}

__inline
VOID
ConvertSecondsToTicks(
    IN ULONG Seconds,
    OUT PLARGE_INTEGER Ticks
    )
{
    // If the following assert fires, you need to cast Seconds below to
    // ULONGLONG so that 64 bit multiplication and division are used.
    // The current code assumes less than 430 seconds so that the
    // 32 multiplication below won't overflow.
    //
    ASSERT(Seconds < 430);

    Ticks->HighPart = 0;
    Ticks->LowPart = (Seconds * 10*1000*1000) / KeQueryTimeIncrement();
}

// Build the next block on the specified pool page.
// This can only be called if not all of the blocks have been built yet.
//
PUCHAR
FsbpBuildNextBlock(
    IN const FSB_POOL_HEADER* Pool,
    IN OUT PFSB_PAGE_HEADER Page
    )
{
    PUCHAR Block;

    ASSERT(Page->BlocksBuilt < Pool->BlocksPerPage);
    ASSERT((PAGE_SIZE - sizeof(FSB_PAGE_HEADER)) / Pool->AlignedBlockSize
                == Pool->BlocksPerPage);
    ASSERT(Pool->CallerBlockSize <= Pool->AlignedBlockSize);

    Block = (PUCHAR)(Page + 1) + (Page->BlocksBuilt * Pool->AlignedBlockSize);
    ASSERT(PAGE_ALIGN(Block) == Page);

    if (Pool->BuildFunction) {
        Pool->BuildFunction(Block, Pool->CallerBlockSize);
    }

    Page->BlocksBuilt++;

    return Block;
}

// Allocate a new pool page and insert it at the head of the specified
// CPU pool.  Build the first block on the new page and return a pointer
// to it.
//
PUCHAR
FsbpAllocateNewPageAndBuildOneBlock(
    IN const FSB_POOL_HEADER* Pool,
    IN PFSB_CPU_POOL_HEADER CpuPool
    )
{
    PFSB_PAGE_HEADER Page;
    PUCHAR Block = NULL;
    ULONG PagesInUse;

    ASSERT(Pool);

    Page = ExAllocatePoolWithTagPriority(NonPagedPool, PAGE_SIZE, Pool->Tag,
                                         NormalPoolPriority);
    if (Page)
    {
        ASSERT(Page == PAGE_ALIGN(Page));

        RtlZeroMemory(Page, sizeof(FSB_PAGE_HEADER));
        Page->Pool = CpuPool;
        ExInitializeSListHead(&Page->FreeList);

        // Insert the page at the head of the cpu's pool.
        //
        InsertHeadList(&CpuPool->PageList, &Page->PageLink);
        CpuPool->TotalPagesAllocated++;

        // Update the pool's statistics.
        //
        PagesInUse = CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed;
        if (PagesInUse > CpuPool->PeakPagesInUse)
        {
            CpuPool->PeakPagesInUse = PagesInUse;
        }

        Block = FsbpBuildNextBlock(Pool, Page);
        ASSERT(Block);
    }

    return Block;
}

// Free the specified pool page back to the system's pool.
//
VOID
FsbpFreePage(
    IN PFSB_CPU_POOL_HEADER CpuPool,
    IN PFSB_PAGE_HEADER Page
    )
{
    ASSERT(Page == PAGE_ALIGN(Page));
    ASSERT(Page->Pool == CpuPool);

    ExFreePool(Page);
    CpuPool->TotalPagesFreed++;

    ASSERT(CpuPool->TotalPagesFreed <= CpuPool->TotalPagesAllocated);
}

// Free the specified pool page list back to the system's pool.
//
VOID
FsbpFreeList(
    IN PFSB_CPU_POOL_HEADER CpuPool,
    IN PLIST_ENTRY Head
    )
{
    PFSB_POOL_HEADER Pool;
    PFSB_PAGE_HEADER Page;
    PLIST_ENTRY Scan;
    PLIST_ENTRY Next;
    BOOLEAN UsedPageList;

    Pool = PoolFromCpuPool(CpuPool);
    UsedPageList = (Head == &CpuPool->UsedPageList);
    
    for (Scan = Head->Flink; Scan != Head; Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(UsedPageList ? Page->OnUsedPageList : !Page->OnUsedPageList);
        
        ASSERT(Page->BlocksBuilt <= Pool->BlocksPerPage);
        ASSERT(Page->BlocksBuilt == ExQueryDepthSList(&Page->FreeList));
        
        // Step to the next link before we free this page.
        //
        Next = Scan->Flink;
        
        RemoveEntryList(Scan);
        FsbpFreePage(CpuPool, Page);
    }
}

// Reclaim the memory consumed by completely unused pool pages belonging
// to the specified per-processor pool.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
VOID
FsbpScavengePool(
    IN OUT PFSB_CPU_POOL_HEADER CpuPool
    )
{
    PFSB_POOL_HEADER Pool;
    PFSB_PAGE_HEADER Page;
    PLIST_ENTRY Scan;
    PLIST_ENTRY Next;
    LARGE_INTEGER Ticks;
    LARGE_INTEGER TicksDelta;

    // We must not only be at DISPATCH_LEVEL (or higher), we must also
    // be called on the processor that owns the specified pool.
    //
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    ASSERT((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu);

    Pool = PoolFromCpuPool(CpuPool);

    KeQueryTickCount(&Ticks);

    // Compute the next tick value which represents the earliest time
    // that we will scavenge this pool again.
    //
    ConvertSecondsToTicks(FSB_SCAVENGE_PERIOD_IN_SECONDS, &TicksDelta);
    CpuPool->NextScavengeTick.QuadPart = Ticks.QuadPart + TicksDelta.QuadPart;

    // Compute the tick value which represents the last point at which
    // its okay to free a page.
    //
    ConvertSecondsToTicks(FSB_MINIMUM_PAGE_LIFETIME_IN_SECONDS, &TicksDelta);
    Ticks.QuadPart = Ticks.QuadPart - TicksDelta.QuadPart;

    Scan = CpuPool->PageList.Flink;
    while (Scan != &CpuPool->PageList)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if ((Pool->BlocksPerPage == ExQueryDepthSList(&Page->FreeList)) &&
            (Ticks.QuadPart > Page->LastUsedTick.QuadPart))
        {
            RemoveEntryList(Scan);

            FsbpFreePage(CpuPool, Page);
        }

        Scan = Next;
    }

    // Scan the used pages to see if they can be moved back to the normal
    // list.  This can happen if too many frees by non-owning processors
    // are done.  In that case, the pages get orphaned on the used-page
    // list after all of their blocks have been freed to the page.  Un-orphan
    // them here.
    //
    Scan = CpuPool->UsedPageList.Flink;
    while (Scan != &CpuPool->UsedPageList)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if (0 != ExQueryDepthSList(&Page->FreeList))
        {
            RemoveEntryList(Scan);
            Page->OnUsedPageList = FALSE;
            InsertTailList(&CpuPool->PageList, Scan);
        }

        Scan = Next;
    }
}


// Creates a pool of fixed-size blocks built over non-paged pool.  Each
// block is BlockSize bytes long.  If NULL is not returned,
// FsbDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BlockSize - The size, in bytes, of each block.
//  FreeBlockLinkOffset - The offset, in bytes, from the beginning of a block
//      that represenets a pointer-sized storage location that the pool can
//      use to chain free blocks together.  Most often this will be zero
//      (meaning use the first pointer-size bytes of the block.)
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//  BuildFunction - An optional pointer to a function which initializes
//      blocks when they are first allocated by the pool.  This allows the
//      caller to perform custom, on-demand initialization of each block.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
FsbCreatePool(
    IN USHORT BlockSize,
    IN USHORT FreeBlockLinkOffset,
    IN ULONG Tag,
    IN PFSB_BUILDBLOCK_FUNCTION BuildFunction OPTIONAL
    )
{
    SIZE_T Size;
    PVOID Allocation;
    PFSB_POOL_HEADER Pool = NULL;
    PFSB_CPU_POOL_HEADER CpuPool;
#if MILLEN
    CCHAR NumberCpus = 1;
#else // MILLEN
    CCHAR NumberCpus = KeNumberProcessors;
#endif // !MILLEN
    CCHAR i;

    // We need at least a pointer size worth of space to manage free
    // blocks and we don't impose any per-block overhead, so we borrow it
    // from the block itself.
    //
    ASSERT(BlockSize >= FreeBlockLinkOffset + sizeof(PVOID));

    // This implementation shouldn't be used if we are not going to get more
    // than about 8 blocks per page.  Blocks bigger than this should probably
    // be allocated with multiple pages at a time.
    //
    ASSERT(BlockSize < PAGE_SIZE / 8);

    // Compute the size of our pool header allocation.
    // Add padding to ensure that the pool header can begin on a cache line.
    //
    Size = sizeof(FSB_POOL_HEADER) + (sizeof(FSB_CPU_POOL_HEADER) * NumberCpus)
        + (MAX_CACHE_LINE_SIZE - MEMORY_ALLOCATION_ALIGNMENT);

    // Allocate the pool header.
    //
    Allocation = ExAllocatePoolWithTag(NonPagedPool, Size, ' bsF');

    if (Allocation)
    {
        ASSERT(POINTER_IS_ALIGNED(Allocation, MEMORY_ALLOCATION_ALIGNMENT));
        RtlZeroMemory(Allocation, Size);
        
        Pool = ROUND_UP_POINTER(Allocation, MAX_CACHE_LINE_SIZE);        
        
        // Initialize the pool header fields.
        //
        Pool->Tag = Tag;
        Pool->CallerBlockSize = BlockSize;
        Pool->AlignedBlockSize = (USHORT)ALIGN_UP(BlockSize, PVOID);
        Pool->BlocksPerPage = (PAGE_SIZE - sizeof(FSB_PAGE_HEADER))
                                    / Pool->AlignedBlockSize;
        Pool->FreeBlockLinkOffset = FreeBlockLinkOffset;
        Pool->BuildFunction = BuildFunction;
        Pool->Allocation = Allocation;

        // Initialize the per-cpu pool headers.
        //
        CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1);

        for (i = 0; i < NumberCpus; i++)
        {
            InitializeListHead(&CpuPool[i].PageList);
            InitializeListHead(&CpuPool[i].UsedPageList);
            CpuPool[i].OwnerCpu = i;
        }
    }

    return Pool;
}

// Destroys a pool of fixed-size blocks previously created by a call to
// FsbCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbDestroyPool(
    IN HANDLE PoolHandle
    )
{
    PFSB_POOL_HEADER Pool;
    PFSB_CPU_POOL_HEADER CpuPool;
#if MILLEN
    CCHAR NumberCpus = 1;
#else // MILLEN
    CCHAR NumberCpus = KeNumberProcessors;
#endif // !MILLEN
    CCHAR i;

    Pool = (PFSB_POOL_HEADER)PoolHandle;
    if (!Pool)
    {
        return;
    }

    for (i = 0, CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1);
         i < NumberCpus;
         i++, CpuPool++)
    {
        ASSERT(CpuPool->OwnerCpu == (ULONG)i);

        FsbpFreeList(CpuPool, &CpuPool->PageList);
        FsbpFreeList(CpuPool, &CpuPool->UsedPageList);

        ASSERT(CpuPool->TotalPagesAllocated == CpuPool->TotalPagesFreed);
        ASSERT(CpuPool->TotalBlocksAllocated == CpuPool->TotalBlocksFreed);
    }

    ASSERT(Pool == ROUND_UP_POINTER(Pool->Allocation, MAX_CACHE_LINE_SIZE));
    ExFreePool(Pool->Allocation);
}

// Returns a pointer to a block allocated from a pool.  NULL is returned if
// the request could not be granted.  The returned pointer is guaranteed to
// have 8 byte alignment.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PUCHAR
FsbAllocate(
    IN HANDLE PoolHandle
    )
{
    PFSB_POOL_HEADER Pool;
    PFSB_CPU_POOL_HEADER CpuPool;
    PFSB_PAGE_HEADER Page;
    PSLIST_ENTRY BlockLink;
    PUCHAR Block = NULL;
    KIRQL OldIrql;
    ULONG Cpu;
    LARGE_INTEGER Ticks;

    ASSERT(PoolHandle);

    Pool = (PFSB_POOL_HEADER)PoolHandle;

    // Raise IRQL before saving the processor number since there is chance
    // it could have changed if we saved it while at passive.
    //
    OldIrql = KeRaiseIrqlToDpcLevel();

    Cpu = KeGetCurrentProcessorNumber();
    CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1) + Cpu;

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.  Normally, scavenging
    // should only be performed when we free.  However, for the case when
    // the caller constantly frees on a non-owning processor, we'll
    // take this chance to do the scavenging.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        FsbpScavengePool(CpuPool);
    }

    if (!IsListEmpty(&CpuPool->PageList))
    {
        Page = CONTAINING_RECORD(CpuPool->PageList.Flink, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        BlockLink = InterlockedPopEntrySList(&Page->FreeList);
        if (BlockLink)
        {
            Block = (PUCHAR)BlockLink - Pool->FreeBlockLinkOffset;
        }
        else
        {
            // If there were no blocks on this page's free list, it had better
            // mean we haven't yet built all of the blocks on the page.
            // (Otherwise, what is a fully used page doing on the page list
            // and not on the used-page list?)
            //
            ASSERT(Page->BlocksBuilt < Pool->BlocksPerPage);

            Block = FsbpBuildNextBlock(Pool, Page);
            ASSERT(Block);
        }

        // Got a block.  Now check to see if it was the last one on a fully
        // built page.  If so, move the page to the used-page list.
        //
        if ((0 == ExQueryDepthSList(&Page->FreeList)) &&
            (Page->BlocksBuilt == Pool->BlocksPerPage))
        {
            PLIST_ENTRY PageLink;
            PageLink = RemoveHeadList(&CpuPool->PageList);
            InsertTailList(&CpuPool->UsedPageList, PageLink);
            Page->OnUsedPageList = TRUE;

            ASSERT(Page == CONTAINING_RECORD(PageLink, FSB_PAGE_HEADER, PageLink));
        }

        ASSERT(Block);
        goto GotABlock;
    }
    else
    {
        // The page list is empty so we have to allocate and add a new page.
        //
        Block = FsbpAllocateNewPageAndBuildOneBlock(Pool, CpuPool);
    }

    // If we are returning an block, update the statistics.
    //
    if (Block)
    {
        ULONG BlocksInUse;
GotABlock:

        CpuPool->TotalBlocksAllocated++;

        BlocksInUse = CpuPool->TotalBlocksAllocated - CpuPool->TotalBlocksFreed;
        if (BlocksInUse > CpuPool->PeakBlocksInUse)
        {
            CpuPool->PeakBlocksInUse = BlocksInUse;
        }

        // Don't give anyone ideas about where this might point.  I don't
        // want anyone trashing my pool because they thought this field
        // was valid for some reason.
        //
        ((PSINGLE_LIST_ENTRY)((PUCHAR)Block + Pool->FreeBlockLinkOffset))->Next = NULL;
    }

    KeLowerIrql(OldIrql);

    return Block;
}

// Free a block back to the pool from which it was allocated.
//
// Arguments:
//  Block - A block returned from a prior call to FsbAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbFree(
    IN PUCHAR Block
    )
{
    PFSB_PAGE_HEADER Page;
    PFSB_CPU_POOL_HEADER CpuPool;
    PFSB_POOL_HEADER Pool;
    LARGE_INTEGER Ticks;
    LOGICAL PageIsOnUsedPageList;
    LOGICAL Scavenge = FALSE;

    ASSERT(Block);

    // Get the address of the page that this block lives on.  This is where
    // our page header is stored.
    //
    Page = PAGE_ALIGN(Block);

    // Follow the back pointer in the page header to locate the owning
    // cpu's pool.
    //
    CpuPool = Page->Pool;

    // Locate the pool header.
    //
    Pool = PoolFromCpuPool(CpuPool);

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        Scavenge = TRUE;
    }

    // Note the tick that this page was last used.  If this is the last block
    // to be returned to this page, this sets the minimum time that this page
    // will continue to live unless it gets re-used.
    //
    Page->LastUsedTick.QuadPart = Ticks.QuadPart;

    // If this page is on the used-page list, we'll put it back on the normal
    // page list (only after pushing the block back on the page's free list)
    // if, after raising IRQL, we are on the processor that owns this
    // pool.
    //
    PageIsOnUsedPageList = Page->OnUsedPageList;


    InterlockedIncrement(&CpuPool->TotalBlocksFreed);

    // Now return the block to the page's free list.
    //
    InterlockedPushEntrySList(
        &Page->FreeList,
        (PSLIST_ENTRY)((PUCHAR)Block + Pool->FreeBlockLinkOffset));

    //
    // Warning: Now that the block is back on the page, one cannot *reliably*
    // dereference anything through 'Page' anymore.  It may have just been
    // scavenged by its owning processor and subsequently freed.  This is a
    // particularly rare condition given that MINIMUM_PAGE_LIFETIME_IN_SECONDS
    // is 20s, so we choose to live with it.  The alternative would be to walk
    // the UsedPageList whenever PageIsOnUsedPageList is true, making the
    // FsbFree operation potentially expensive.  We saved off the value of
    // Page->OnUsedPageList before returning the block so we would not risk
    // touching Page to get this value only to find that it was false.
    //

    // If we need to move the page from the used-page list to the normal
    // page list, or if we need to scavenge, we need to be at DISPATCH_LEVEL
    // and be executing on the processor that owns this pool.
    // Find out if the CPU we are executing on right now owns this pool.
    // Note that if we are running at PASSIVE_LEVEL, the current CPU may
    // change over the duration of this function call, so this value is
    // not absolute over the life of the function.
    //
    if ((PageIsOnUsedPageList || Scavenge) &&
        ((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu))
    {
        KIRQL OldIrql;

        OldIrql = KeRaiseIrqlToDpcLevel();

        // Now that we are at DISPATCH_LEVEL, perform the work if we are still
        // executing on the processor that owns the pool.
        //
        if ((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu)
        {
            // If the page is still on the used-page list (meaning another
            // FsbFree didn't just sneak by) and still has a free block (for
            // instance, an FsbAllocate might sneak in on its owning processor,
            // scavenge the page, and allocate the block we just freed; thereby
            // putting it back on the used-page list), then put the page on the
            // normal list.  Very important to do this after (not before)
            // returning the block to the free list because FsbAllocate expects
            // blocks to be available from pages on the page list.
            //
            if (PageIsOnUsedPageList &&
                Page->OnUsedPageList &&
                (0 != ExQueryDepthSList(&Page->FreeList)))
            {
                RemoveEntryList(&Page->PageLink);
                Page->OnUsedPageList = FALSE;
                InsertTailList(&CpuPool->PageList, &Page->PageLink);
            }

            // Perform the scavenge if we previously noted we needed to do so.
            //
            if (Scavenge)
            {
                FsbpScavengePool(CpuPool);
            }
        }

        KeLowerIrql(OldIrql);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\common\9x\mdl2ndis.c ===
/*--Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mdl2ndis.c

Abstract:

    MDL <--> NDIS_BUFFER conversion

Author:

    Bruce Johnson (bjohnson) 31-Aug-1999

--*/

#include <tcpipbase.h>

#if MILLEN

ULONG g_cConvertedNdisBuffers = 0;
ULONG g_cConvertedMdls        = 0;

TDI_STATUS
ConvertMdlToNdisBuffer(
    PIRP          pIrp,
    PMDL          pMdl,
    PNDIS_BUFFER *ppNdisBuffer
    )
{
    NDIS_STATUS         NdisStatus;
    PVOID               VirtualAddress;
    ULONG               Length;
    PNDIS_BUFFER        pNdisBuffer;
    TDI_STATUS          TdiStatus = TDI_SUCCESS;
#ifdef DEBUG_MSG
    PMDL                pSavedMdl = pMdl;
#endif // DEBUG_MSG

    //
    // Allocate the NDIS_BUFFER chain describing the MDL chain.
    //

    *ppNdisBuffer = NULL;
    pNdisBuffer   = NULL;

    do {
        VirtualAddress = MmGetSystemAddressForMdl(pMdl);
        Length         = MmGetMdlByteCount(pMdl);

        NdisAllocateBuffer(
            &NdisStatus,
            (pNdisBuffer == NULL) ? (&pNdisBuffer) : (&(pNdisBuffer->Next)),
            NULL, //gBufferPool
            VirtualAddress,
            Length
            );

        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("ConvertMdlToNdisBuffer failed to allocate NDIS_BUFFER.\n")));
            break;
        }

        if (*ppNdisBuffer != NULL) {
            pNdisBuffer = pNdisBuffer->Next;
        }
        else {
            *ppNdisBuffer = pNdisBuffer;
        }

        pNdisBuffer->Next = NULL;

        pMdl = pMdl->Next;

    } while (pMdl != NULL);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        PNDIS_BUFFER pNext;

        pNdisBuffer = *ppNdisBuffer;

        while (pNdisBuffer) {
            pNext = pNdisBuffer->Next;
            NdisFreeBuffer(pNdisBuffer);
            pNdisBuffer = pNext;
        }

        *ppNdisBuffer = NULL;
        TdiStatus = TDI_NO_RESOURCES;
        goto done;
    }

    InterlockedIncrement(&g_cConvertedNdisBuffers);

done:

    // Ensure that it is initialized, either way.
    pIrp->Tail.Overlay.DriverContext[0] = *ppNdisBuffer;

    DEBUGMSG(DBG_INFO && DBG_TDI && DBG_VERBOSE,
        (DTEXT("Convert IRP %x MDL %x NDIS_BUFFER %x\n"),
         pIrp, pSavedMdl, *ppNdisBuffer));

    return TdiStatus;
}

TDI_STATUS
FreeMdlToNdisBufferChain(
    PIRP pIrp
    )
{
    PNDIS_BUFFER pNdisBuffer = pIrp->Tail.Overlay.DriverContext[0];
    PNDIS_BUFFER pNext;

    if (pNdisBuffer == NULL) {
        goto done;
    }

    DEBUGMSG(DBG_INFO && DBG_TDI && DBG_VERBOSE,
        (DTEXT("FreeConvert IRP %x NdisBuffer %x\n"), pIrp, pNdisBuffer));

    do {
        pNext = pNdisBuffer->Next;
        NdisFreeBuffer(pNdisBuffer);
        pNdisBuffer = pNext;
    } while (pNdisBuffer);

    pIrp->Tail.Overlay.DriverContext[0] = NULL;
    InterlockedDecrement(&g_cConvertedNdisBuffers);

done:
    return TDI_SUCCESS;
}

TDI_STATUS
ConvertNdisBufferToMdl(
    PNDIS_BUFFER pNdisBuffer,
    PMDL        *ppMdl
    )
{
    NDIS_STATUS  NdisStatus = NDIS_STATUS_SUCCESS;
    TDI_STATUS   TdiStatus  = TDI_SUCCESS;
    PVOID        VirtualAddress;
    ULONG        Length;
    PMDL         pMdl   = NULL;
    PMDL         pLast  = NULL;
#ifdef DEBUG_MSG
    PNDIS_BUFFER pSavedNdisBuffer = pNdisBuffer;
#endif // DEBUG_MSG

    *ppMdl = NULL;

    do {
        NdisQueryBuffer(
            pNdisBuffer,
            &VirtualAddress,
            &Length);

        pMdl = IoAllocateMdl(
            VirtualAddress,
            Length,
            FALSE,
            FALSE,
            NULL);

        if (pMdl == NULL) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("ConvertNdisBufferToMdl failed to allocate MDL.\n")));
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        if (*ppMdl != NULL) {
            pLast->Next = pMdl;
        } else {
            *ppMdl = pMdl;
        }

        pMdl->Next = NULL;
        pLast      = pMdl;

        pNdisBuffer = pNdisBuffer->Next;

    } while (pNdisBuffer != NULL);

    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        PMDL pNext;

        pMdl = *ppMdl;

        while (pMdl) {
            pNext = pMdl->Next;
            IoFreeMdl(pMdl);
            pMdl = pNext;
        }

        *ppMdl = NULL;
        TdiStatus = TDI_NO_RESOURCES;
        goto done;
    }

    InterlockedIncrement(&g_cConvertedMdls);

done:

    DEBUGMSG(DBG_INFO && DBG_TDI && DBG_VERBOSE,
        (DTEXT("Convert NDIS_BUFFER %x MDL %x\n"),
         pSavedNdisBuffer, *ppMdl));

    return TdiStatus;
}

TDI_STATUS
FreeNdisBufferToMdlChain(
    PMDL pMdl
    )
{
    PMDL pNext;

    DEBUGMSG(DBG_INFO && DBG_TDI && DBG_VERBOSE,
        (DTEXT("FreeConvert MDL %x\n"), pMdl));

    while (pMdl) {
        pNext = pMdl->Next;
        IoFreeMdl(pMdl);
        pMdl = pNext;
    }

    InterlockedDecrement(&g_cConvertedMdls);
    return TDI_SUCCESS;
}

#endif // MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\common\nt\mdlpool.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mdlpool.c

Abstract:

    This file contains the implementation of an MDL buffer pool.

Author:

    Shaun Cox (shaunco) 21-Oct-1999

--*/

#include "ntddk.h"
#include "mdlpool.h"

typedef PVOID LPVOID;
#include "align.h"              // Macros: ROUND_UP_POINTER, POINTER_IS_ALIGNED

#define SHOW_DEBUG_OUTPUT 0

#define SCAVENGE_PERIOD_IN_SECONDS          30
#define MINIMUM_PAGE_LIFETIME_IN_SECONDS    20
#define USED_PAGES_SCAVENGE_THRESHOLD       64

#if defined (_WIN64)
#define MAX_CACHE_LINE_SIZE 128
#define BLOCK_TYPE  SLIST_HEADER
#else
#define MAX_CACHE_LINE_SIZE 64
#define BLOCK_TYPE  PVOID
#endif

// The following structures are used in the single allocation that
// a pool handle points to.
//      PoolHandle ---> [POOL_HEADER + CPU_POOL_HEADER for cpu 0 +
//                                     CPU_POOL_HEADER for cpu 1 + ...
//                                     CPU_POOL_HEADER for cpu N]
//

// POOL_HEADER is the data common to all CPUs for a given pool.
//
typedef struct _POOL_HEADER
{
// cache-line -----
    struct _POOL_HEADER_BASE
    {
        ULONG Tag;
        USHORT BufferSize;
        USHORT MdlsPerPage;
        PVOID Allocation;
    };
    UCHAR Alignment[MAX_CACHE_LINE_SIZE
            - (sizeof(struct _POOL_HEADER_BASE) % MAX_CACHE_LINE_SIZE)];
} POOL_HEADER, *PPOOL_HEADER;

C_ASSERT(sizeof(POOL_HEADER) % MAX_CACHE_LINE_SIZE == 0);


// CPU_POOL_HEADER is the data specific to a CPU for a given pool.
//
typedef struct _CPU_POOL_HEADER
{
// cache-line -----
    struct _CPU_POOL_HEADER_BASE
    {
        // The doubly-linked list of pages that make up this processor's pool.
        // These pages have one or more free MDLs available.
        //
        LIST_ENTRY PageList;

        // The doubly-linked list of pages that are fully in use.  This list
        // is separate from the above list so that we do not spend time walking
        // a very long list during MdpAllocate when many pages are fully used.
        //
        LIST_ENTRY UsedPageList;

        // The next scheduled time (in units of KeQueryTickCount()) for
        // scavenging this pool.  The next scavenge will happen no earlier
        // that this.
        //
        LARGE_INTEGER NextScavengeTick;

        // Count of pages on the used page list.
        // If this becomes greater than USED_PAGES_SCAVENGE_THRESHOLD
        // and we know we missed a page move during a prior MdpFree,
        // we will scavenge during the next MdpAllocate.
        //
        USHORT PagesOnUsedPageList;

        // Set to TRUE during MdpFree if could not move a previously used
        // page back to the normal list because the free was done by a
        // non-owning processor.  Set to FALSE during MdpScavenge.
        //
        BOOLEAN MissedPageMove;

        // The number of the processor that owns this pool.
        //
        UCHAR OwnerCpu;

        ULONG TotalMdlsAllocated;
        ULONG TotalMdlsFreed;
        ULONG PeakMdlsInUse;
        ULONG TotalPagesAllocated;
        ULONG TotalPagesFreed;
        ULONG PeakPagesInUse;
    };
    UCHAR Alignment[MAX_CACHE_LINE_SIZE
            - (sizeof(struct _CPU_POOL_HEADER_BASE) % MAX_CACHE_LINE_SIZE)];
} CPU_POOL_HEADER, *PCPU_POOL_HEADER;

C_ASSERT(sizeof(CPU_POOL_HEADER) % MAX_CACHE_LINE_SIZE == 0);


// PAGE_HEADER is the data at the beginning of each allocated pool page
// that describes the current state of the MDLs on the page.
//
typedef struct _PAGE_HEADER
{
// cache-line -----
    // Back pointer to the owning cpu pool.
    //
    PCPU_POOL_HEADER Pool;

    // Linkage entry for the list of pages managed by the cpu pool.
    //
    LIST_ENTRY PageLink;

    // Number of MDLs built so far on this page.  MDLs are built on
    // demand.  When this number reaches Pool->MdlsPerPage, all MDLs on this
    // page have been built.
    //
    USHORT MdlsBuilt;

    // Boolean indicator of whether or not this page is on the cpu pool's
    // used-page list.  This is checked during MdpFree to see if the page
    // should be moved back to the normal page list.
    // (it is a USHORT, instead of BOOLEAN, for proper padding)
    //
    USHORT OnUsedPageList;

    // List of free MDLs on this page.
    //
    SLIST_HEADER FreeList;

    // The value of KeQueryTickCount (normalized to units of seconds)
    // which represents the time after which this page can be freed back
    // to the system's pool.  This time is only used once the depth of
    // FreeList is Pool->MdlsPerPage.  (i.e. this time is only used if
    // the page is completely unused.)
    //
    LARGE_INTEGER LastUsedTick;

} PAGE_HEADER, *PPAGE_HEADER;


// MDLs that we build are always limited to one page and they never
// describe buffers that span a page boundry.
//
#define MDLSIZE sizeof(MDL) + sizeof(PFN_NUMBER)


// Get a pointer to the overall pool given a pointer to one of
// the per-processor pools within it.
//
__inline
PPOOL_HEADER
PoolFromCpuPool(
    IN PCPU_POOL_HEADER CpuPool
    )
{
    return (PPOOL_HEADER)(CpuPool - CpuPool->OwnerCpu) - 1;
}

__inline
VOID
ConvertSecondsToTicks(
    IN ULONG Seconds,
    OUT PLARGE_INTEGER Ticks
    )
{
    // If the following assert fires, you need to cast Seconds below to
    // ULONGLONG so that 64 bit multiplication and division are used.
    // The current code assumes less that 430 seconds so that the
    // 32 multiplication below won't overflow.
    //
    ASSERT(Seconds < 430);

    Ticks->HighPart = 0;
    Ticks->LowPart = (Seconds * 10*1000*1000) / KeQueryTimeIncrement();
}

// Build the next MDL on the specified pool page.
// This can only be called if not all of the MDLs have been built yet.
//
PMDL
MdppBuildNextMdl(
    IN const POOL_HEADER* Pool,
    IN OUT PPAGE_HEADER Page
    )
{
    PMDL Mdl;
    ULONG BlockSize = ALIGN_UP(MDLSIZE + Pool->BufferSize, BLOCK_TYPE);

    ASSERT(Page->MdlsBuilt < Pool->MdlsPerPage);
    ASSERT((PAGE_SIZE - sizeof(PAGE_HEADER)) / BlockSize == Pool->MdlsPerPage);

    Mdl = (PMDL)((PCHAR)(Page + 1) + (Page->MdlsBuilt * BlockSize));
    ASSERT(PAGE_ALIGN(Mdl) == Page);

    MmInitializeMdl(Mdl, (PCHAR)Mdl + MDLSIZE, Pool->BufferSize);
    MmBuildMdlForNonPagedPool(Mdl);

    ASSERT(MDLSIZE == Mdl->Size);
    ASSERT(MmGetMdlBaseVa(Mdl) == Page);
    ASSERT(MmGetMdlByteCount(Mdl) == Pool->BufferSize);

    Page->MdlsBuilt++;

    return Mdl;
}

// Allocate a new pool page and insert it at the head of the specified
// CPU pool.  Build the first MDL on the new page and return a pointer
// to it.
//
PMDL
MdppAllocateNewPageAndBuildOneMdl(
    IN const POOL_HEADER* Pool,
    IN PCPU_POOL_HEADER CpuPool
    )
{
    PPAGE_HEADER Page;
    PMDL Mdl = NULL;
    ULONG PagesInUse;

    ASSERT(Pool);

    Page = ExAllocatePoolWithTagPriority(NonPagedPool, PAGE_SIZE, Pool->Tag,
                                         NormalPoolPriority);
    if (Page)
    {
        ASSERT(Page == PAGE_ALIGN(Page));

        RtlZeroMemory(Page, sizeof(PAGE_HEADER));
        Page->Pool = CpuPool;
        ExInitializeSListHead(&Page->FreeList);

        // Insert the page at the head of the cpu's pool.
        //
        InsertHeadList(&CpuPool->PageList, &Page->PageLink);
        CpuPool->TotalPagesAllocated++;

        // Update the pool's statistics.
        //
        PagesInUse = CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed;
        if (PagesInUse > CpuPool->PeakPagesInUse)
        {
            CpuPool->PeakPagesInUse = PagesInUse;
        }

        Mdl = MdppBuildNextMdl(Pool, Page);
        ASSERT(Mdl);

#if SHOW_DEBUG_OUTPUT
        DbgPrint(
            "[%d] %c%c%c%c page allocated : Pages(a%4d,u%4d,p%4d), Mdls(a%6d,u%6d,p%6d)\n",
            CpuPool->OwnerCpu,
            Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24,
            CpuPool->TotalPagesAllocated,
            CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed,
            CpuPool->PeakPagesInUse,
            CpuPool->TotalMdlsAllocated,
            CpuPool->TotalMdlsAllocated - CpuPool->TotalMdlsFreed,
            CpuPool->PeakMdlsInUse);
#endif
    }

    return Mdl;
}

// Free the specified pool page back to the system's pool.
//
VOID
MdppFreePage(
    IN PCPU_POOL_HEADER CpuPool,
    IN PPAGE_HEADER Page
    )
{
#if SHOW_DEBUG_OUTPUT
    ULONG Tag;
#endif

    ASSERT(Page == PAGE_ALIGN(Page));
    ASSERT(Page->Pool == CpuPool);

    ExFreePool (Page);
    CpuPool->TotalPagesFreed++;

    ASSERT(CpuPool->TotalPagesFreed <= CpuPool->TotalPagesAllocated);

#if SHOW_DEBUG_OUTPUT
    Tag = PoolFromCpuPool(CpuPool)->Tag;

    DbgPrint(
        "[%d] %c%c%c%c page freed     : Pages(a%4d,u%4d,p%4d), Mdls(a%6d,u%6d,p%6d)\n",
        CpuPool->OwnerCpu,
        Tag, Tag >> 8, Tag >> 16, Tag >> 24,
        CpuPool->TotalPagesAllocated,
        CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed,
        CpuPool->PeakPagesInUse,
        CpuPool->TotalMdlsAllocated,
        CpuPool->TotalMdlsAllocated - CpuPool->TotalMdlsFreed,
        CpuPool->PeakMdlsInUse);
#endif
}


// Free the specified pool page list back to the system's pool.
//
VOID
MdppFreeList(
    IN PCPU_POOL_HEADER CpuPool,
    IN PLIST_ENTRY Head
    )
{
    PPOOL_HEADER Pool;
    PPAGE_HEADER Page;
    PLIST_ENTRY Scan;
    PLIST_ENTRY Next;
    BOOLEAN UsedPageList;

    Pool = PoolFromCpuPool(CpuPool);
    UsedPageList = (Head == &CpuPool->UsedPageList);

    for (Scan = Head->Flink; Scan != Head; Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(UsedPageList ? Page->OnUsedPageList : !Page->OnUsedPageList);
        
        ASSERT(Page->MdlsBuilt <= Pool->MdlsPerPage);
        ASSERT(Page->MdlsBuilt == ExQueryDepthSList(&Page->FreeList));
        
        // Step to the next link before we free this page.
        //
        Next = Scan->Flink;
        
        RemoveEntryList(Scan);
        MdppFreePage(CpuPool, Page);
    }
}


// Reclaim the memory consumed by completely unused pool pages belonging
// to the specified per-processor pool.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
VOID
MdppScavengePool(
    IN OUT PCPU_POOL_HEADER CpuPool
    )
{
    PPOOL_HEADER Pool;
    PPAGE_HEADER Page;
    PLIST_ENTRY Scan;
    PLIST_ENTRY Next;
    LARGE_INTEGER Ticks;
    LARGE_INTEGER TicksDelta;

    // We must not only be at DISPATCH_LEVEL (or higher), we must also
    // be called on the processor that owns the specified pool.
    //
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    ASSERT(KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu);

    Pool = PoolFromCpuPool(CpuPool);

    KeQueryTickCount(&Ticks);

    // Compute the next tick value which represents the earliest time
    // that we will scavenge this pool again.
    //
    ConvertSecondsToTicks(SCAVENGE_PERIOD_IN_SECONDS, &TicksDelta);
    CpuPool->NextScavengeTick.QuadPart = Ticks.QuadPart + TicksDelta.QuadPart;

    // Compute the tick value which represents the last point at which
    // its okay to free a page.
    //
    ConvertSecondsToTicks(MINIMUM_PAGE_LIFETIME_IN_SECONDS, &TicksDelta);
    Ticks.QuadPart = Ticks.QuadPart - TicksDelta.QuadPart;

    for (Scan = CpuPool->PageList.Flink;
         Scan != &CpuPool->PageList;
         Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if ((Pool->MdlsPerPage == ExQueryDepthSList(&Page->FreeList)) &&
            (Ticks.QuadPart > Page->LastUsedTick.QuadPart))
        {
            RemoveEntryList(Scan);

            MdppFreePage(CpuPool, Page);
        }
    }

    // Scan the used pages to see if they can be moved back to the normal
    // list.  This can happen if too many frees by non-owning processors
    // are done.  In that case, the pages get orphaned on the used-page
    // list after all of their MDLs have been freed to the page.  Un-orphan
    // them here.
    //
    for (Scan = CpuPool->UsedPageList.Flink;
         Scan != &CpuPool->UsedPageList;
         Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if (0 != ExQueryDepthSList(&Page->FreeList))
        {
            RemoveEntryList(Scan);
            Page->OnUsedPageList = FALSE;
            InsertTailList(&CpuPool->PageList, Scan);
            CpuPool->PagesOnUsedPageList--;

#if SHOW_DEBUG_OUTPUT
            DbgPrint(
                "[%d] %c%c%c%c page moved off of used-page list during scavenge\n",
                CpuPool->OwnerCpu,
                Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24);
#endif
        }
    }

    // Reset our indicator of a missed page move now that we've scavenged.
    //
    CpuPool->MissedPageMove = FALSE;
}


// Creates a pool of MDLs built over non-paged pool.  Each MDL describes
// a buffer that is BufferSize bytes long.  If NULL is not returned,
// MdpDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BufferSize - The size, in bytes, of the buffer that each MDL
//      should describe.
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
MdpCreatePool(
    IN USHORT BufferSize,
    IN ULONG Tag
    )
{
    SIZE_T Size;
    PVOID Allocation;
    PPOOL_HEADER Pool = NULL;
    PCPU_POOL_HEADER CpuPool;
    USHORT BlockSize;
    CCHAR NumberCpus = KeNumberProcessors;
    CCHAR i;

    ASSERT(BufferSize);

    // Compute the size of our pool header allocation.
    // Add padding to ensure that the pool header can begin on a cache line.
    //
    Size = sizeof(POOL_HEADER) + (sizeof(CPU_POOL_HEADER) * NumberCpus) +
        (MAX_CACHE_LINE_SIZE - MEMORY_ALLOCATION_ALIGNMENT);

    // Allocate the pool header.
    //
    Allocation = ExAllocatePoolWithTag(NonPagedPool, Size, ' pdM');
    if (Allocation)
    {
        ASSERT(POINTER_IS_ALIGNED(Allocation, MEMORY_ALLOCATION_ALIGNMENT));
        RtlZeroMemory(Allocation, Size);
        
        Pool = ROUND_UP_POINTER(Allocation, MAX_CACHE_LINE_SIZE);
        
        BlockSize = (USHORT)ALIGN_UP(MDLSIZE + BufferSize, BLOCK_TYPE);

        // Initialize the pool header fields.
        //
        Pool->Tag = Tag;
        Pool->BufferSize = BufferSize;
        Pool->MdlsPerPage = (PAGE_SIZE - sizeof(PAGE_HEADER)) / BlockSize;
        Pool->Allocation = Allocation;
        
        // Initialize the per-cpu pool headers.
        //
        CpuPool = (PCPU_POOL_HEADER)(Pool + 1);

        for (i = 0; i < NumberCpus; i++)
        {
            InitializeListHead(&CpuPool[i].PageList);
            InitializeListHead(&CpuPool[i].UsedPageList);
            CpuPool[i].OwnerCpu = i;
        }
    }

    return Pool;
}

// Destroys a pool of MDLs previously created by a call to MdpCreatePool.
//
// Arguments:
//  Pool - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpDestroyPool(
    IN HANDLE PoolHandle
    )
{
    PPOOL_HEADER Pool;
    PCPU_POOL_HEADER CpuPool;
    CCHAR NumberCpus = KeNumberProcessors;
    CCHAR i;

    ASSERT(PoolHandle);

    Pool = (PPOOL_HEADER)PoolHandle;
    if (!Pool)
    {
        return;
    }

    for (i = 0, CpuPool = (PCPU_POOL_HEADER)(Pool + 1);
         i < NumberCpus;
         i++, CpuPool++)
    {
        ASSERT(CpuPool->OwnerCpu == (ULONG)i);

        MdppFreeList(CpuPool, &CpuPool->PageList);
        MdppFreeList(CpuPool, &CpuPool->UsedPageList);

        ASSERT(CpuPool->TotalPagesAllocated == CpuPool->TotalPagesFreed);
        ASSERT(CpuPool->TotalMdlsAllocated == CpuPool->TotalMdlsFreed);
    }

    ASSERT(Pool == ROUND_UP_POINTER(Pool->Allocation, MAX_CACHE_LINE_SIZE));
    ExFreePool(Pool->Allocation);
}


// Returns an MDL allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PMDL
MdpAllocate(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    )
{
    KIRQL OldIrql;
    PMDL Mdl;

    OldIrql = KeRaiseIrqlToDpcLevel();

    Mdl = MdpAllocateAtDpcLevel(PoolHandle, Buffer);

    KeLowerIrql(OldIrql);

    return Mdl;
}

// Returns an MDL allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
PMDL
MdpAllocateAtDpcLevel(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    )
{
    PPOOL_HEADER Pool;
    PCPU_POOL_HEADER CpuPool;
    PPAGE_HEADER Page;
    PSLIST_ENTRY MdlLink;
    PMDL Mdl = NULL;
    ULONG Cpu;
    LARGE_INTEGER Ticks;

#if DBG
    ASSERT(PoolHandle);
    ASSERT(Buffer);
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
#endif
    *Buffer = NULL;

    Pool = (PPOOL_HEADER)PoolHandle;
    Cpu = KeGetCurrentProcessorNumber();
    CpuPool = (PCPU_POOL_HEADER)(Pool + 1) + Cpu;

    // If we know we've had frees by non-owning processors and there
    // are more than USED_PAGES_SCAVENGE_THRESHOLD pages on the used
    // page list, it is time to scavenge.  This is common in situations
    // where the buffer size is very large causing there to be just a few
    // MDLs per page.  Pages get used up quickly and if non-owning frees
    // are prevalent, the used page list can get very big even in
    // the normal scavenge period.
    //
    if (CpuPool->MissedPageMove &&
        (CpuPool->PagesOnUsedPageList > USED_PAGES_SCAVENGE_THRESHOLD))
    {
#if SHOW_DEBUG_OUTPUT
        DbgPrint(
            "[%d] %c%c%c%c Scavenging because of excessive used pages.\n",
            CpuPool->OwnerCpu,
            Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24);
#endif
        MdppScavengePool(CpuPool);
    }
    else
    {
        // See if the minimum time has passed since we last scavenged
        // the pool.  If it has, we'll scavenge again.  Normally, scavenging
        // should only be performed when we free.  However, for the case when
        // the caller constantly frees on a non-owning processor, we'll
        // take this chance to do the scavenging.
        //
        KeQueryTickCount(&Ticks);
        if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
        {
            MdppScavengePool(CpuPool);
        }
    }

    if (!IsListEmpty(&CpuPool->PageList))
    {
        Page = CONTAINING_RECORD(CpuPool->PageList.Flink, PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        MdlLink = InterlockedPopEntrySList(&Page->FreeList);
        if (MdlLink)
        {
            Mdl = CONTAINING_RECORD(MdlLink, MDL, Next);
        }
        else
        {
            // If there were no MDLs on this page's free list, it had better
            // mean we haven't yet built all of the MDLs on the page.
            // (Otherwise, what is a fully used page doing on the page list
            // and not on the used-page list?)
            //
            ASSERT(Page->MdlsBuilt < Pool->MdlsPerPage);

            Mdl = MdppBuildNextMdl(Pool, Page);
            ASSERT(Mdl);
        }

        if ((Page != PAGE_ALIGN(Page)) || (CpuPool != Page->Pool) ||
            Page->OnUsedPageList || (PAGE_ALIGN(Mdl) != Page))
        {
            KeBugCheckEx(BAD_POOL_CALLER, 2, (ULONG_PTR)Mdl,
                (ULONG_PTR)Page, (ULONG_PTR)CpuPool);
        }

        // Got an MDL.  Now check to see if it was the last one on a fully
        // built page.  If so, move the page to the used-page list.
        //
        if ((0 == ExQueryDepthSList(&Page->FreeList)) &&
            (Page->MdlsBuilt == Pool->MdlsPerPage))
        {
            PLIST_ENTRY PageLink;
            PageLink = RemoveHeadList(&CpuPool->PageList);
            InsertTailList(&CpuPool->UsedPageList, PageLink);
            Page->OnUsedPageList = TRUE;
            CpuPool->PagesOnUsedPageList++;

            ASSERT(Page == CONTAINING_RECORD(PageLink, PAGE_HEADER, PageLink));

#if SHOW_DEBUG_OUTPUT
            DbgPrint(
                "[%d] %c%c%c%c page moved to used-page list\n",
                CpuPool->OwnerCpu,
                Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24);
#endif
        }

        ASSERT(Mdl);
        goto GotAnMdl;
    }
    else
    {
        // The page list is empty so we have to allocate and add a new page.
        //
        Mdl = MdppAllocateNewPageAndBuildOneMdl(Pool, CpuPool);
    }

    // If we are returning an MDL, update the statistics.
    //
    if (Mdl)
    {
        ULONG MdlsInUse;
GotAnMdl:

        CpuPool->TotalMdlsAllocated++;

        MdlsInUse = CpuPool->TotalMdlsAllocated - CpuPool->TotalMdlsFreed;
        if (MdlsInUse > CpuPool->PeakMdlsInUse)
        {
            CpuPool->PeakMdlsInUse = MdlsInUse;
        }

        // Don't give anyone ideas about where this might point.  I don't
        // want anyone trashing my pool because they thought this field
        // was valid for some reason.
        //
        Mdl->Next = NULL;

        // Reset the length of the buffer described by the MDL.  This is
        // a convienence to callers who sometimes adjust this length while
        // using the MDL, but who expect it to be reset on subsequent MDL
        // allocations.
        //
        Mdl->ByteCount = Pool->BufferSize;

        ASSERT(Mdl->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL);
        *Buffer = Mdl->MappedSystemVa;
    }

    return Mdl;
}

// Free an MDL to the pool from which it was allocated.
//
// Arguments:
//  Mdl - An Mdl returned from a prior call to MdpAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpFree(
    IN PMDL Mdl
    )
{
    PPAGE_HEADER Page;
    PCPU_POOL_HEADER CpuPool;
    PPOOL_HEADER Pool;
    LARGE_INTEGER Ticks;
    LOGICAL PageIsOnUsedPageList;
    LOGICAL Scavenge = FALSE;

    ASSERT(Mdl);

    // Get the address of the page that this MDL maps.  This is where
    // our page header is stored.
    //
    Page = PAGE_ALIGN(Mdl);

    // Follow the back pointer in the page header to locate the owning
    // cpu's pool.
    //
    CpuPool = Page->Pool;

    // Locate the pool header.
    //
    Pool = PoolFromCpuPool(CpuPool);

//#if DBG
    // If someone changed the MDL to point to there own buffer,
    // or otherwise corrupted it, we'll stop here and let them know.
    //
    if ((MmGetMdlBaseVa(Mdl) != Page) ||
        (MDLSIZE != Mdl->Size) ||
        ((ULONG_PTR)Mdl->MappedSystemVa != (ULONG_PTR)Mdl + MDLSIZE) ||
        (MmGetMdlVirtualAddress(Mdl) != Mdl->MappedSystemVa))
    {
        KeBugCheckEx(BAD_POOL_CALLER, 3, (ULONG_PTR)Mdl,
            (ULONG_PTR)CpuPool, (ULONG_PTR)Pool);
    }
//#endif

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        Scavenge = TRUE;
    }

    // Note the tick that this page was last used.  If this is the last MDL to
    // be returned to this page, this sets the minimum time that this page will
    // continue to live unless it gets re-used.
    //
    Page->LastUsedTick.QuadPart = Ticks.QuadPart;

    // If this page is on the used-page list, we'll put it back on the normal
    // page list (only after pushing the MDL back on the page's free list)
    // if, after raising IRQL, we are on the processor that owns this
    // pool.
    //
    PageIsOnUsedPageList = Page->OnUsedPageList;


    InterlockedIncrement(&CpuPool->TotalMdlsFreed);

    // Now return the MDL to the page's free list.
    //
    InterlockedPushEntrySList(&Page->FreeList, (PSLIST_ENTRY)&Mdl->Next);

    //
    // Warning: Now that the MDL is back on the page, one cannot *reliably*
    // dereference anything through 'Page' anymore.  It may have just been
    // scavenged by its owning processor and subsequently freed.  This is a
    // particularly rare condition given that MINIMUM_PAGE_LIFETIME_IN_SECONDS
    // is 20s, so we choose to live with it.  The alternative would be to walk
    // the UsedPageList whenever PageIsOnUsedPageList is true, making the
    // MdpFree operation potentially expensive.  We saved off the value of
    // Page->OnUsedPageList before returning the MDL so we would not risk
    // touching Page to get this value only to find that it was false.
    //

    // If we need to move the page from the used-page list to the normal
    // page list, or if we need to scavenge, we need to be at DISPATCH_LEVEL
    // and be executing on the processor that owns this pool.
    // Find out if the CPU we are executing on right now owns this pool.
    // Note that if we are running at PASSIVE_LEVEL, the current CPU may
    // change over the duration of this function call, so this value is
    // not absolute over the life of the function.
    //
    if ((PageIsOnUsedPageList || Scavenge) &&
        (KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu))
    {
        KIRQL OldIrql;

        OldIrql = KeRaiseIrqlToDpcLevel();

        // Now that we are at DISPATCH_LEVEL, perform the work if we are still
        // executing on the processor that owns the pool.
        //
        if (KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu)
        {
            // If the page is still on the used-page list (meaning another
            // MdpFree didn't just sneak by) and still has a free MDL (for
            // instance, an MdpAllocate might sneak in on its owning processor,
            // scavenge the page, and allocate the MDL we just freed; thereby
            // putting it back on the used-page list), then put the page on the
            // normal list.  Very important to do this after (not before)
            // returning the MDL to the free list because MdpAllocate expects
            // MDL's to be available from pages on the page list.
            //
            if (PageIsOnUsedPageList &&
                Page->OnUsedPageList &&
                (0 != ExQueryDepthSList(&Page->FreeList)))
            {
                RemoveEntryList(&Page->PageLink);
                Page->OnUsedPageList = FALSE;
                InsertTailList(&CpuPool->PageList, &Page->PageLink);
                CpuPool->PagesOnUsedPageList--;

                PageIsOnUsedPageList = FALSE;

#if SHOW_DEBUG_OUTPUT
                DbgPrint(
                    "[%d] %c%c%c%c page moved off of used-page list\n",
                    CpuPool->OwnerCpu,
                    Pool->Tag, Pool->Tag >> 8, Pool->Tag >> 16, Pool->Tag >> 24);
#endif
            }

            // Perform the scavenge if we previously noted we needed to do so.
            //
            if (Scavenge)
            {
                MdppScavengePool(CpuPool);
            }
        }

        KeLowerIrql(OldIrql);
    }

    // If we missed being able to put this page back on the normal list.
    // note it.
    //
    if (PageIsOnUsedPageList)
    {
        CpuPool->MissedPageMove = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\bitmap.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    BitMap.h

Abstract:

    RTL Bitmap definitions and prototypes.            

Revision History:

    Borrowed from ntoskrnl for compatibility on other platforms (Win9x).
    
--*/

#ifndef _TCPIP_BITMAP_H_
#define _TCPIP_BITMAP_H_

#if MILLEN

//
//  BitMap routines.  The following structure, routines, and macros are
//  for manipulating bitmaps.  The user is responsible for allocating a bitmap
//  structure (which is really a header) and a buffer (which must be longword
//  aligned and multiple longwords in size).
//

typedef struct _RTL_BITMAP {
    ULONG SizeOfBitMap;                     // Number of bits in bit map
    PULONG Buffer;                          // Pointer to the bit map itself
} RTL_BITMAP;
typedef RTL_BITMAP *PRTL_BITMAP;

//
//  The following routine initializes a new bitmap.  It does not alter the
//  data currently in the bitmap.  This routine must be called before
//  any other bitmap routine/macro.


VOID
RtlInitializeBitMap (
    PRTL_BITMAP BitMapHeader,
    PULONG BitMapBuffer,
    ULONG SizeOfBitMap
    );

//
//  The following three routines clear, set, and test the state of a
//  single bit in a bitmap.
//

VOID
RtlClearBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

VOID
RtlSetBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

BOOLEAN
RtlTestBit (
    PRTL_BITMAP BitMapHeader,
    ULONG BitNumber
    );

//
//  The following two routines either clear or set all of the bits
//  in a bitmap.
//

VOID
RtlClearAllBits (
    PRTL_BITMAP BitMapHeader
    );

VOID
RtlSetAllBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap.  The region will be at least
//  as large as the number specified, and the search of the bitmap will
//  begin at the specified hint index (which is a bit index within the
//  bitmap, zero based).  The return value is the bit index of the located
//  region (zero based) or -1 (i.e., 0xffffffff) if such a region cannot
//  be located
//

ULONG
RtlFindClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
RtlFindSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines locate a contiguous region of either
//  clear or set bits within the bitmap and either set or clear the bits
//  within the located region.  The region will be as large as the number
//  specified, and the search for the region will begin at the specified
//  hint index (which is a bit index within the bitmap, zero based).  The
//  return value is the bit index of the located region (zero based) or
//  -1 (i.e., 0xffffffff) if such a region cannot be located.  If a region
//  cannot be located then the setting/clearing of the bitmap is not performed.
//

ULONG
RtlFindClearBitsAndSet (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

ULONG
RtlFindSetBitsAndClear (
    PRTL_BITMAP BitMapHeader,
    ULONG NumberToFind,
    ULONG HintIndex
    );

//
//  The following two routines clear or set bits within a specified region
//  of the bitmap.  The starting index is zero based.
//

VOID
RtlClearBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToClear
    );

VOID
RtlSetBits (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG NumberToSet
    );

//
//  The following routine locates a set of contiguous regions of clear
//  bits within the bitmap.  The caller specifies whether to return the
//  longest runs or just the first found lcoated.  The following structure is
//  used to denote a contiguous run of bits.  The two routines return an array
//  of this structure, one for each run located.
//

typedef struct _RTL_BITMAP_RUN {

    ULONG StartingIndex;
    ULONG NumberOfBits;

} RTL_BITMAP_RUN;
typedef RTL_BITMAP_RUN *PRTL_BITMAP_RUN;

ULONG
RtlFindClearRuns (
    PRTL_BITMAP BitMapHeader,
    PRTL_BITMAP_RUN RunArray,
    ULONG SizeOfRunArray,
    BOOLEAN LocateLongestRuns
    );

//
//  The following routine locates the longest contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the longest region found.
//

ULONG
RtlFindLongestRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following routine locates the first contiguous region of
//  clear bits within the bitmap.  The returned starting index value
//  denotes the first contiguous region located satisfying our requirements
//  The return value is the length (in bits) of the region found.
//

ULONG
RtlFindFirstRunClear (
    PRTL_BITMAP BitMapHeader,
    PULONG StartingIndex
    );

//
//  The following macro returns the value of the bit stored within the
//  bitmap at the specified location.  If the bit is set a value of 1 is
//  returned otherwise a value of 0 is returned.
//
//      ULONG
//      RtlCheckBit (
//          PRTL_BITMAP BitMapHeader,
//          ULONG BitPosition
//          );
//
//
//  To implement CheckBit the macro retrieves the longword containing the
//  bit in question, shifts the longword to get the bit in question into the
//  low order bit position and masks out all other bits.
//

#define RtlCheckBit(BMH,BP) ((((BMH)->Buffer[(BP) / 32]) >> ((BP) % 32)) & 0x1)

//
//  The following two procedures return to the caller the total number of
//  clear or set bits within the specified bitmap.
//

ULONG
RtlNumberOfClearBits (
    PRTL_BITMAP BitMapHeader
    );

ULONG
RtlNumberOfSetBits (
    PRTL_BITMAP BitMapHeader
    );

//
//  The following two procedures return to the caller a boolean value
//  indicating if the specified range of bits are all clear or set.
//

BOOLEAN
RtlAreBitsClear (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

BOOLEAN
RtlAreBitsSet (
    PRTL_BITMAP BitMapHeader,
    ULONG StartingIndex,
    ULONG Length
    );

ULONG
RtlFindNextForwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

ULONG
RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    );

#endif // MILLEN

#endif // !_TCPIP_BITMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\common\9x\timer.c ===
/*++
 
  Copyright (c) 1999 Microsoft Corporation
 
  Module Name:    
        
        timer.c
 
  Abstract:       
        
        Contains CTE timer which uses NDIS_TIMERs. We need to do this so 
        that the timer is fired on a global event rather than timer DPC.
        This is because some of the Millennium TDI clients touch pageable 
        code, etc.
        
  Author:
  
        Scott Holden (sholden)  2/8/2000
        
  Revision History:
 
 --*/

#include <tcpipbase.h>

VOID
CTEpTimerHandler(
    IN PVOID  SS1,
    IN PVOID  DeferredContext,
    IN PVOID  SS2,
    IN PVOID  SS3
    )
{
    CTETimer *Timer;

    UNREFERENCED_PARAMETER(SS1);
    UNREFERENCED_PARAMETER(SS2);
    UNREFERENCED_PARAMETER(SS3);

    Timer = (CTETimer *) DeferredContext;
    (*Timer->t_handler)((CTEEvent *)Timer, Timer->t_arg);
}

void
CTEInitTimer(
    CTETimer    *Timer
    )
/*++

Routine Description:

    Initializes a CTE Timer variable.

Arguments:

    Timer   - Timer variable to initialize.

Return Value:

    None.

--*/

{
    Timer->t_handler = NULL;
    Timer->t_arg = NULL;
    NdisInitializeTimer(&Timer->t_timer, CTEpTimerHandler, Timer);
    return;
}


void *
CTEStartTimer(
    CTETimer      *Timer,
    unsigned long  DueTime,
    CTEEventRtn    Handler,
    void          *Context
    )

/*++

Routine Description:

    Sets a CTE Timer for expiration.

Arguments:

    Timer    - Pointer to a CTE Timer variable.
    DueTime  - Time in milliseconds after which the timer should expire.
    Handler  - Timer expiration handler routine.
    Context  - Argument to pass to the handler.

Return Value:

    0 if the timer could not be set. Nonzero otherwise.

--*/

{
    ASSERT(Handler != NULL);

    Timer->t_handler = Handler;
    Timer->t_arg = Context;

    NdisSetTimer(&Timer->t_timer, DueTime);

	return((void *) 1);
}

//++
//
// int
// CTEStopTimer(
//     IN CTETimer *Timer
//     );
//
// Routine Description:
//
//     Cancels a running CTE timer.
//
// Arguments:
//
//     Timer - Pointer to the CTE Timer to be cancelled.
//
// Return Value:
//
//     0 if the timer could not be cancelled. Nonzero otherwise.
//
// Notes:
//
//     Calling this function on a timer that is not active has no effect.
//     If this routine fails, the timer may be in the process of expiring
//     or may have already expired. In either case, the caller must
//     sychronize with the Handler function as appropriate.
//
//--

int
CTEStopTimer(
    IN CTETimer *Timer
    )
{
    BOOLEAN fTimerCancelled;

    NdisCancelTimer(&Timer->t_timer, &fTimerCancelled);

    return (fTimerCancelled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\dbgmsg.h ===
/*++

 Copyright (c) 1998-2000 Microsoft Corporation

 Module Name:    
       
       dbgmsg.h

 Abstract:       
       
       Debug message macros and zones.
       
 Revision History:

--*/

#if DBG
#define DEBUG_MSG 1
#endif // DBG

//
// If DEBUG_MSG is defined, then we have DEBUGMSG turned on in this environment.
//

#ifdef DEBUG_MSG

#define DTEXT(x) x

extern  uint DbgSettingsLevel;
extern  uint DbgSettingsZone;

#define DEBUGZONE(n)   (DbgSettingsZone & (0x00000001<<n))
#define DEBUGLEVEL(n)  (DbgSettingsLevel & (0x00000001<<n))

typedef ULONG (__cdecl *PDBGMSG)(PCH pszFormat, ...);
extern PDBGMSG g_pDbgMsg;
#define DEBUGMSG(dbgs,format) ((dbgs) ? g_pDbgMsg format:0)

extern VOID DebugMsgInit();
#define DEBUGMSGINIT() DebugMsgInit()

#define DBG_INIT                DEBUGZONE(0)
#define DBG_PNP                 DEBUGZONE(1)

#define DBG_REQUEST             DEBUGZONE(4)
#define DBG_INTERFACE           DEBUGZONE(5)
#define DBG_OFFLOAD             DEBUGZONE(6)
#define DBG_REG                 DEBUGZONE(7)
#define DBG_ROUTE               DEBUGZONE(8)

#define DBG_ARP                 DEBUGZONE(9)
#define DBG_IP                  DEBUGZONE(10)
#define DBG_TCP                 DEBUGZONE(11)
#define DBG_UDP                 DEBUGZONE(12)
#define DBG_ICMP                DEBUGZONE(13)
#define DBG_IGMP                DEBUGZONE(14)
#define DBG_RAW                 DEBUGZONE(15)

#define DBG_TDI                 DEBUGZONE(16)
#define DBG_NDIS                DEBUGZONE(17)

#define DBG_SETINFO             DEBUGZONE(18)
#define DBG_QUERYINFO           DEBUGZONE(19)
#define DBG_NOTIFY              DEBUGZONE(20)
#define DBG_DHCP                DEBUGZONE(21)

// These are very verbose!
#define DBG_TX                  DEBUGZONE(29)
#define DBG_RX                  DEBUGZONE(30)
#define DBG_FWD                 DEBUGZONE(31)

#define DBG_TRACE               DEBUGLEVEL(0)
#define DBG_INFO                DEBUGLEVEL(1)
#define DBG_WARN                DEBUGLEVEL(2)
#define DBG_ERROR               DEBUGLEVEL(3)
#define DBG_VERBOSE             DEBUGLEVEL(31)

#else // DEBUG_MSG

//
// No DEBUGMSGs.
//
#define DEBUGMSG(d,f)   (0)
#define DEBUGMSGINIT()  (0)

#endif // DEBUG_MSG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\mdlpool.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mdlpool.h

Abstract:

    This file contains definitions and function prototypes for manipulating
    MDL buffer pools.

Author:

    Shaun Cox (shaunco) 21-Oct-1999

--*/

#pragma once


// Creates a pool of MDLs built over non-paged pool.  Each MDL describes
// a buffer that is BufferSize bytes long.  If NULL is not returned,
// MdpDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BufferSize - The size, in bytes, of the buffer that each MDL
//      should describe.
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
MdpCreatePool(
    IN USHORT BufferSize,
    IN ULONG Tag
    );

// Destroys a pool of MDLs previously created by a call to MdpCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpDestroyPool(
    IN HANDLE PoolHandle
    );

// Returns an MDL allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
#if MILLEN
PNDIS_BUFFER
#else
PMDL
#endif
MdpAllocate(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    );

// Returns an MDL allocated from a pool.  NULL is returned if the
// request could not be granted.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//  Buffer - Address to receive the pointer to the underlying mapped buffer
//      described by the MDL.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
#if MILLEN
#define MdpAllocateAtDpcLevel MdpAllocate
#else
PMDL
MdpAllocateAtDpcLevel(
    IN HANDLE PoolHandle,
    OUT PVOID* Buffer
    );
#endif

// Free an MDL to the pool from which it was allocated.
//
// Arguments:
//  Mdl - An Mdl returned from a prior call to MdpAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
MdpFree(
    IN PMDL Mdl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\oscfg.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

#ifndef OSCFG_INCLUDED
#define OSCFG_INCLUDED

#define MIN(a,b)    ((a) < (b) ? (a) : (b))
#define MAX(a,b)    ((a) > (b) ? (a) : (b))

// My binary compatible definition for compiling an Millennium tcpip.sys
#if MILLEN
#include "wdm.h"
#define KdPrintEx(_x_)
#else // MILLEN
#include <ntosp.h>
#include <zwapi.h>
#endif // !MILLEN

#define BEGIN_INIT
#define END_INIT


#if defined (_WIN64)
#define MAX_CACHE_LINE_SIZE 128
#else
#define MAX_CACHE_LINE_SIZE 64
#endif

#define CACHE_ALIGN __declspec(align(MAX_CACHE_LINE_SIZE))

typedef struct CACHE_ALIGN _CACHE_LINE_KSPIN_LOCK {
    KSPIN_LOCK Lock;
} CACHE_LINE_KSPIN_LOCK;
C_ASSERT(sizeof(CACHE_LINE_KSPIN_LOCK) % MAX_CACHE_LINE_SIZE == 0);
C_ASSERT(__alignof(CACHE_LINE_KSPIN_LOCK) == MAX_CACHE_LINE_SIZE);

typedef struct CACHE_ALIGN _CACHE_LINE_SLIST_HEADER {
    SLIST_HEADER SListHead;
} CACHE_LINE_SLIST_HEADER;
C_ASSERT(sizeof(CACHE_LINE_SLIST_HEADER) % MAX_CACHE_LINE_SIZE == 0);
C_ASSERT(__alignof(CACHE_LINE_SLIST_HEADER) == MAX_CACHE_LINE_SIZE);

typedef struct CACHE_ALIGN _CACHE_LINE_ULONG {
    ULONG Value;
} CACHE_LINE_ULONG;
C_ASSERT(sizeof(CACHE_LINE_ULONG) % MAX_CACHE_LINE_SIZE == 0);
C_ASSERT(__alignof(CACHE_LINE_ULONG) == MAX_CACHE_LINE_SIZE);

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#define net_long(_x)  _byteswap_ulong(_x)
#else
__inline
USHORT
FASTCALL
net_short(
    ULONG NaturalData)
{
    USHORT ShortData = (USHORT)NaturalData;

    return (ShortData << 8) | (ShortData >> 8);
}

// if x is aabbccdd (where aa, bb, cc, dd are hex bytes)
// we want net_long(x) to be ddccbbaa.  A small and fast way to do this is
// to first byteswap it to get bbaaddcc and then swap high and low words.
//
__inline
ULONG
FASTCALL
net_long(
    ULONG NaturalData)
{
    ULONG ByteSwapped;

    ByteSwapped = ((NaturalData & 0x00ff00ff) << 8) |
                  ((NaturalData & 0xff00ff00) >> 8);

    return (ByteSwapped << 16) | (ByteSwapped >> 16);
}
#endif


#pragma warning(push)
#pragma warning(disable:4244) // conversion from 'int' to 'BOOLEAN'

__inline
BOOLEAN
IsPowerOfTwo(
    ULONG Value
    )
{
    return (Value & (Value - 1)) == 0;
}

#pragma warning(pop)


// Find the highest power of two that is greater
// than or equal to the Value.
//
__inline
ULONG
ComputeLargerOrEqualPowerOfTwo(
    ULONG Value
    )
{
    ULONG Temp;

    for (Temp = 1; Temp < Value; Temp <<= 1);

    return Temp;
}

// Find the highest power of two, in the form of its shift, that is greater
// than or equal to the Value.
//
__inline
ULONG
ComputeShiftForLargerOrEqualPowerOfTwo(
    ULONG Value
    )
{
    ULONG Shift;
    ULONG Temp;

    for (Temp = 1, Shift = 0; Temp < Value; Temp <<= 1, Shift++);

    return Shift;
}


__inline
VOID
FASTCALL
CTEGetLockAtIrql (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL OrigIrql,
    OUT PKIRQL OldIrql)
{
#if !MILLEN
    if (DISPATCH_LEVEL == OrigIrql) {
        ASSERT(DISPATCH_LEVEL == KeGetCurrentIrql());
        ExAcquireSpinLockAtDpcLevel(SpinLock);
        *OldIrql = DISPATCH_LEVEL;
    } else {
        ExAcquireSpinLock(SpinLock, OldIrql);
    }
#else
    *OldIrql = 0;
#endif
}

__inline
VOID
FASTCALL
CTEFreeLockAtIrql (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL OrigIrql,
    IN KIRQL NewIrql)
{
#if !MILLEN
    if (DISPATCH_LEVEL == OrigIrql) {
        ASSERT(DISPATCH_LEVEL == NewIrql);
        ASSERT(DISPATCH_LEVEL == KeGetCurrentIrql());
        ExReleaseSpinLockFromDpcLevel(SpinLock);
    } else {
        ExReleaseSpinLock(SpinLock, NewIrql);
    }
#endif
}

#endif // OSCFG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\fsbpool.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fsbpool.h

Abstract:

    This file contains definitions and function prototypes for manipulating
    fixed-size block pools.

Author:

    Shaun Cox (shaunco) 10-Dec-1999

--*/

#pragma once


typedef
VOID
(__stdcall *PFSB_BUILDBLOCK_FUNCTION) (
    IN PUCHAR Block,
    IN SIZE_T NumberOfBytes
    );


// Creates a pool of fixed-size blocks built over non-paged pool.  Each
// block is BlockSize bytes long.  If NULL is not returned,
// FsbDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BlockSize - The size, in bytes, of each block.
//  FreeBlockLinkOffset - The offset, in bytes, from the beginning of a block
//      that represenets a pointer-sized storage location that the pool can
//      use to chain free blocks together.  Most often this will be zero
//      (meaning use the first pointer-size bytes of the block.)
//  Tag - The pool tag to be used internally for calls to
//      ExAllocatePoolWithTag.  This allows callers to track
//      memory consumption for different pools.
//  BuildFunction - An optional pointer to a function which initializes
//      blocks when they are first allocated by the pool.  This allows the
//      caller to perform custom, on-demand initialization of each block.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
FsbCreatePool(
    IN USHORT BlockSize,
    IN USHORT FreeBlockLinkOffset,
    IN ULONG Tag,
    IN PFSB_BUILDBLOCK_FUNCTION BuildFunction OPTIONAL
    );

// Destroys a pool of fixed-size blocks previously created by a call to
// FsbCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbDestroyPool(
    IN HANDLE PoolHandle
    );

// Returns a pointer to a block allocated from a pool.  NULL is returned if
// the request could not be granted.  The returned pointer is guaranteed to
// have 8 byte alignment.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PUCHAR
FsbAllocate(
    IN HANDLE PoolHandle
    );

// Free a block back to the pool from which it was allocated.
//
// Arguments:
//  Block - A block returned from a prior call to FsbAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbFree(
    IN PUCHAR Block
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\mdl2ndis.h ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:    
       
       mdl2ndis.h

 Abstract:       
       
       MDL <--> NDIS_BUFFER conversion.
       
 Author:
 
       Scott Holden (sholden)  11/12/1999
       
 Revision History:

--*/

#if MILLEN

TDI_STATUS
ConvertMdlToNdisBuffer(
    PIRP pIrp,
    PMDL pMdl, 
    PNDIS_BUFFER *ppNdisBuffer
    );

TDI_STATUS
FreeMdlToNdisBufferChain(
    PIRP pIrp
    );

#else // MILLEN
//
// Of course for Windows 2000 an NDIS_BUFFER chain is really an MDL chain.
//

__inline          
TDI_STATUS
ConvertMdlToNdisBuffer(
    PIRP pIrp,
    PMDL pMdl, 
    PNDIS_BUFFER *ppNdisBuffer
    )
{
    *ppNdisBuffer = pMdl;
    return TDI_SUCCESS;
}

__inline          
TDI_STATUS
FreeMdlToNdisBufferChain(
    PIRP pIrp
    )
{
    return TDI_SUCCESS;
}
#endif // !MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\pplasl.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    pplasl.c

Abstract:

    This file contains definitions and function prototypes of a per-processor
    lookaside list manager.

Author:

    Shaun Cox (shaunco) 25-Oct-1999

--*/

#pragma once

#if MILLEN

BOOLEAN
PplInit(
    VOID
    );

VOID
PplDeinit(
    VOID
    );
                
#endif // MILLEN

HANDLE
PplCreatePool(
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

VOID
PplDestroyPool(
    IN HANDLE PoolHandle
    );

PVOID
PplAllocate(
    IN HANDLE PoolHandle,
    OUT LOGICAL *FromList
    );

VOID
PplFree(
    IN HANDLE PoolHandle,
    IN PVOID Entry
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\tcp.h ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

#ifndef _TCP_INCLUDED_
#define _TCP_INCLUDED_
#include "tcpinfo.h"

//** TCP.H - TCP definitions.
//
// This file contains the definitions of TCP protocol specific options, such
// as the sequence numbers and TCB.
//

#define PROTOCOL_TCP        6
#define MIN_LOCAL_MSS       88
#define MAX_REMOTE_MSS      536

//* Timer stuff. We keep timers as ticks.
#define MS_PER_TICK         100
#define MS_TO_TICKS(m)      ((m) / MS_PER_TICK)
#define MIN_RETRAN_TICKS    3
#define DEL_ACK_TICKS       2
#define MAX_DEL_ACK_TICKS   6
#define MIN_INITIAL_RTT     3

// Define MAX_REXMIT_TO to be number of ticks in 2MSL
#define MAX_REXMIT_TO   ((ushort)FinWait2TO)

#define SWS_TO          MS_TO_TICKS(5000)
#define PUSH_TO         MS_TO_TICKS(500)

typedef ulong TCP_TIME;
#define MAX_CONN_TO_TICKS       0xffff
#define INFINITE_CONN_TO(t)     ((t) == 0)
#define TCP_TIME_TO_TICKS(t)    (((t)/MS_PER_TICK)+1)

//  Sequence numbers are kept as signed 32 bit quantities, with macros
//  defined to do wraparound comparisons on them.

typedef int SeqNum;                     // A sequence number.

//* Macros for comparions on sequence numbers.

#define SEQ_GT(a, b)    ((SeqNum)((a) - (b)) > 0)
#define SEQ_GTE(a, b)   ((SeqNum)((a) - (b)) >= 0)
#define SEQ_LT(a, b)    ((SeqNum)((a) - (b)) < 0)
#define SEQ_LTE(a, b)   ((SeqNum)((a) - (b)) <= 0)
#define SEQ_EQ(a, b)    ((a) == (b))

#define TS_LT(a, b)     (((a) - (b)) < 0)
#define TS_LTE(a, b)    (((a) - (b)) <= 0)
#define TS_GTE(a, b)    (((a) - (b)) >= 0)

#define TCPTIME_LTE(a, b) ((int)((a) - (b)) <= 0)
#define TCPTIME_LT(a, b)  ((int)((a) - (b)) < 0)

#define TIMWAITTABLE 1  //turn on timed wait TCB table changes
#define IRPFIX          1  //turn on quick Irp to Conn find

#if DBG && !MILLEN
#ifndef REFERENCE_DEBUG
#define REFERENCE_DEBUG 1
#endif

#else // DBG && !MILLEN

#ifndef REFERENCE_DEBUG
#define REFERENCE_DEBUG 0
#endif

#endif // DBG && !MILLEN

#if REFERENCE_DEBUG
// Reference history structure.
//

#define MAX_REFERENCE_HISTORY 64

typedef struct _TCP_REFERENCE_HISTORY {
    uchar *File;
    uint Line;
    void *Caller;
    uint Count;
} TCP_REFERENCE_HISTORY;

#endif // REFERENCE_DEBUG

 //* The TCB - transport control block structure. This is the
//  structure that contains all of the state for the transport
//  connection, including sequence numbers, flow control information,
//  pending sends and receives, etc.

#define tcb_signature   0x20424354      // 'TCB '
#define twtcb_signature 0x22424354      // 'TCB2'
#define syntcb_signature 0x23424354      // 'TCB3'


typedef struct TWTCB {
#if DBG
    ulong           twtcb_sig;
#endif
    Queue           twtcb_link;

    // Do not reorder or move apart the following address fields.
    union {
        struct twtcb_addrinfo {
            IPAddr          twtcb_daddr;        // Destination IP address.
            IPAddr          twtcb_saddr;        // Source IP address.
            ushort          twtcb_dport;        // Destination port.
            ushort          twtcb_sport;        // Source port.
        };
        TCPAddrInfo     twtcb_addrbytes;
    };
    
    Queue           twtcb_TWQueue;      // Place to hang all the timed_waits
    ushort          twtcb_delta;
    ushort          twtcb_rexmittimer;
    SeqNum          twtcb_rcvnext;
    SeqNum          twtcb_sendnext;

#if DBG
    uint            twtcb_flags;
#endif
} TWTCB;



typedef struct SYNTCB {
#if DBG
    ulong               syntcb_sig;        // Debug signature.
#endif
    Queue               syntcb_link;      // Next pointer in TCB table.
    DEFINE_LOCK_STRUCTURE(syntcb_lock)

    // Do not reorder or move apart the following address fields.
    union {
        struct syntcb_addrinfo {
            IPAddr              syntcb_daddr;      // Destination IP address.
            IPAddr              syntcb_saddr;      // Source IP address.
            ushort              syntcb_dport;      // Destination port.
            ushort              syntcb_sport;      // Source port.
        };
        TCPAddrInfo         syntcb_addrbytes;
    };

    // State information.
    uchar               syntcb_state;      // State of this TCB.
    uchar               syntcb_rexmitcnt;  // Count of rexmits on this TCB.

    // Highly used receive sequence variables.
    ushort              syntcb_mss;        // MSS for this connection.
    ushort              syntcb_remmss;     // MSS advertised by peer.
    uchar               syntcb_tcpopts;    // rfc 1323 and 2018 options holder
    uchar               syntcb_ttl;
    SeqNum              syntcb_rcvnext;    // Next byte we expect to receive.

    // Send sequence variables.
    SeqNum              syntcb_sendnext;   // Sequence number of next byte to send.
    uint                syntcb_sendwin;    // Send window.
    uint                syntcb_flags;      // Flags for this TCB.
    uint                syntcb_refcnt;     // Reference count for TCB.
    ushort              syntcb_rexmit;     // Rexmit value.

    ushort              syntcb_rexmittimer;// Timer for rexmit.
    uint                syntcb_defaultwin; // Default rcv. window.

    short               syntcb_sndwinscale;// send window scale
    short               syntcb_rcvwinscale;// receive window scale
    int                 syntcb_tsrecent;   // time stamp recent
    int                 syntcb_tsupdatetime;    // Time when tsrecent was updated
    uint                syntcb_walkcount;
    uint                syntcb_partition;
} SYNTCB;



#if TRACE_EVENT
typedef struct WMIData {
    ulong           wmi_context;        // PID
    ulong           wmi_size;           // num Bytes successfully sent.
    IPAddr          wmi_destaddr;       // Remote IPAddr.
    IPAddr          wmi_srcaddr;        // Local IPAddr.
    ushort          wmi_destport;       // Remote port.
    ushort          wmi_srcport;        // Local Port.
} WMIData;
#endif


// We will have 7 timers in TCP, and integrate all their processing
typedef enum {
    RXMIT_TIMER = 0,
    DELACK_TIMER,
    PUSH_TIMER,
    SWS_TIMER,
    ACD_TIMER,
    CONN_TIMER,
    KA_TIMER,
    NUM_TIMERS
} TCP_TIMER_TYPE;


#define NO_TIMER   NUM_TIMERS


typedef struct TCB {
#if DBG
    ulong               tcb_sig;        // Debug signature.
#endif
    struct TCB          *tcb_next;      // Next pointer in TCB table.
    DEFINE_LOCK_STRUCTURE(tcb_lock)
    uint                tcb_refcnt;     // Reference count for TCB.

    // Do not reorder or move apart the following address fields.
    union {
        struct tcb_addrinfo {
            IPAddr              tcb_daddr;      // Destination IP address.
            IPAddr              tcb_saddr;      // Source IP address.
            ushort              tcb_dport;      // Destination port.
            ushort              tcb_sport;      // Source port.
        };
        TCPAddrInfo         tcb_addrbytes;
    };
    
#if TRACE_EVENT
    ulong               tcb_cpcontext;
#endif
    // State information.
    uchar               tcb_state;      // State of this TCB.
    uchar               tcb_rexmitcnt;  // Count of rexmits on this TCB.
    uchar               tcb_pending;    // Pending actions on this TCB.
    uchar               tcb_kacount;    // Count of keep alive probes sent.

    // Highly used receive sequence variables.
    ushort              tcb_mss;        // MSS for this connection.
    ushort              tcb_remmss;     // MSS advertised by peer.
    SeqNum              tcb_rcvnext;    // Next byte we expect to receive.
    int                 tcb_rcvwin;     // Receive window we're offering.

    // Send sequence variables.
    SeqNum              tcb_senduna;    // Sequence number of first unack'd data.
    SeqNum              tcb_sendnext;   // Sequence number of next byte to send.
    SeqNum              tcb_sendmax;    // Max value of sendnext this epoch.
    uint                tcb_sendwin;    // Send window.
    uint                tcb_unacked;    // Total number of bytes of unacked data.
    uint                tcb_maxwin;     // Max send window seen.
    uint                tcb_cwin;       // Congestion window.
    uint                tcb_ssthresh;   // Slow start threshold.
    uint                tcb_phxsum;     // Precomputed pseudo-header xsum.
    struct TCPSendReq   *tcb_cursend;   // Current send in use.
    PNDIS_BUFFER        tcb_sendbuf;    // Current buffer chain being sent.
    uint                tcb_sendofs;    // Offset into start of chain.
    uint                tcb_sendsize;   // Number of bytes unsent in current send.
    Queue               tcb_sendq;      // Queue of send requests.

    // Less highly used receive sequence variables.
    SeqNum              tcb_sendwl1;    // Window update sequence number.
    SeqNum              tcb_sendwl2;    // Window update ack number.
    struct TCPRcvReq    *tcb_currcv;    // Current receive buffer.
    uint                tcb_indicated;  // Bytes of data indicated.
    uint                tcb_flags;      // Flags for this TCB.
    uint                tcb_fastchk;    // Fast receive path check field.
    uint                (*tcb_rcvhndlr)(struct TCB *, uint, struct IPRcvBuf *, uint Size);
    SeqNum              tcb_rttseq;     // Sequence number being measured for RTT.
    ushort              tcb_rexmit;     // Rexmit value.

    // Retransmit timer information. These are stored as ticks, where by
    // default each tick is 100ms.
    ushort              tcb_smrtt;      // Smoothed rtt value.
    ushort              tcb_delta;      // Delta value.
    uchar               tcb_slowcount;  // Count of reasons why we're on the slow path.
    uchar               tcb_closereason;    // Reason we're closing.

    IP_STATUS           tcb_error;      // Last error we heard about from IP.
    uint                tcb_rtt;        // Current round trip time TS.
    uint                tcb_defaultwin; // Default rcv. window.

    struct TCPRAHdr     *tcb_raq;       // Reassembly queue.
    struct TCPRcvReq    *tcb_rcvhead;   // Head of recv. buffer queue.
    struct TCPRcvReq    *tcb_rcvtail;   // Tail of recv. buffer queue.
    uint                tcb_pendingcnt; // Bytes waiting to be received.
    struct IPRcvBuf     *tcb_pendhead;  // Head of pending recv. queue.
    struct IPRcvBuf     *tcb_pendtail;  // Tail of pending recv. queue.

    struct TCPConnReq   *tcb_connreq;   // Connection-type request for
                                        // this connection.
    void                *tcb_conncontext;    // Connection context for this
                                             // connection.

    uint                tcb_bcountlow;  // Low part of byte count.
    uint                tcb_bcounthi;   // High part of bytecount.
    uint                tcb_totaltime;  // Total number of ticks spent
                                        // sending.
    struct TCPConn      *tcb_conn;      // Back pointer to conn for TCB.
    Queue               tcb_delayq;     // Queue linkage for delay queue.

    void                *tcb_rcvind;    // Receive indication handler.
    union {
        void            *tcb_ricontext; // Receive indication context.
        struct  TCB     *tcb_aonext;    // Next pointer on AddrObj.
    };
    // Miscellaneous info, for IP.
    IPOptInfo           tcb_opt;        // Option information.
    RouteCacheEntry     *tcb_rce;       // RCE for this connection.
    struct TCPConnReq   *tcb_discwait;  // Disc-Wait req., if there is one.
    struct TCPAbortReq  *tcb_abortreq;  // Abort req., if there is one.
    struct TCPRcvReq    *tcb_exprcv;    // Head of expedited recv. buffer
                                        // queue.
    struct IPRcvBuf     *tcb_urgpending;    // Urgent data queue.
    uint                tcb_urgcnt;     // Byte count of data on urgent q.
    uint                tcb_urgind;     // Urgent bytes indicated.
    SeqNum              tcb_urgstart;   // Start of urgent data.
    SeqNum              tcb_urgend;     // End of urgent data.
    short                tcb_walkcount;  // Count of number of people
                                        // 'walking' this TCB.
    short               tcb_unusedpendbuf;  // Tracks the number of bytes
                                            // wasted while using slist buffers.
    ushort              tcb_dup;        // For Fast recovery algorithm

    ushort              tcb_force : 1;  // Force next send after fast send
    ushort              tcb_tcpopts : 3;// rfc 1323 and 2018 options holder
    ushort              tcb_moreflag : 3;
    ushort              tcb_allowedoffloads : 9; // Types of allowed offloads.

    struct SACKSendBlock *tcb_SackBlock;// Sacks which needs to be sent
    struct SackListEntry *tcb_SackRcvd; // Sacks which needs to be processed

    short               tcb_sndwinscale;// send window scale
    short               tcb_rcvwinscale;// receive window scale
    int                 tcb_tsrecent;   // time stamp recent
    SeqNum              tcb_lastack;    // ack number in  the last segment sent
    int                 tcb_tsupdatetime;    // Time when tsrecent was updated
    void                *tcb_chainedrcvind;    //for chained receives
    void                *tcb_chainedrcvcontext;

#if GPC
    ULONG               tcb_GPCCachedIF;
    ULONG               tcb_GPCCachedLink;
    struct RouteTableEntry *tcb_GPCCachedRTE;

#endif
#if DBG
    uint                tcb_LargeSend;  // Counts the number of outstanding
                                        // large-send transmit-requests
#endif
    uint                tcb_partition;
    uint                tcb_connid;

    // ACK behavior
    uchar               tcb_delackticks;
    uchar               tcb_numdelacks;
    uchar               tcb_rcvdsegs;

    uchar               tcb_bhprobecnt; // BH probe count.

    // Timer wheel parameters
    // The first two are one logical group called wheel state.
    // They indicate which slot in the timer wheel the TCB is in,
    // and it's linkage in the timer slot queue.

    Queue               tcb_timerwheelq;
    ushort              tcb_timerslot : 12;

    // These three variables are another logical group called timer
    // state. They indicate the state of timers active on the TCB,
    // tcb_timertime maintains the time at which the earliest timer
    // will fire, and tcb_timertype maintains the earliest timer's
    // type.
    // To see why this whole thing is important, see comments after
    // the TIMER_WHEEL structure definition.

    ushort              tcb_timertype : 4;
    uint                tcb_timertime;
    uint                tcb_timer[NUM_TIMERS];

#if REFERENCE_DEBUG
    uint                tcb_refhistory_index;
    TCP_REFERENCE_HISTORY tcb_refhistory[MAX_REFERENCE_HISTORY];
#endif //REFERENCE_DEBUG


} TCB;


#define TIMER_WHEEL_SIZE     511

#define DUMMY_SLOT     TIMER_WHEEL_SIZE
#define MAX_TIME_VALUE 0xffffffff




// The Timer wheel structure definition has:
// tw_timerslot:  An array of queues, one for each timer slot.
// tw_lock:       A lock protecting the complete timer wheel.
//                (Contention is reduced by having as many timer
//                wheels as partitions in the system).
// tw_starttick:  Indicates the first time tick that has to
//                be looked at.
//                For e.g., if a timer routine looked at all
//                TCBs firing on or before tick 5 in a pass,
//                it would set tw_starttick to 6, and that is
//                the point it would start processing from on
//                the next pass.

typedef struct CACHE_ALIGN _Timer_Wheel {
    Queue      tw_timerslot[TIMER_WHEEL_SIZE];
    uint       tw_starttick;
    CTELock    tw_lock;
} TIMER_WHEEL, *PTIMER_WHEEL;

C_ASSERT(sizeof(TIMER_WHEEL) % MAX_CACHE_LINE_SIZE == 0);
C_ASSERT(__alignof(TIMER_WHEEL) == MAX_CACHE_LINE_SIZE);


// The first two functions operate on timer state (see comments in definition
// of TCB for meaning of timer state). StopTCBTimerR and StartTCBTimerR
// operate on the timer state (tcb_timertype, tcb_timertime, tcb_timer)
// atomically. A call to either of these functions will always leave wheel
// state consistent.

extern void StopTCBTimerR(TCB  *StopTCB, TCP_TIMER_TYPE TimerType);
extern BOOLEAN StartTCBTimerR(TCB *StartTCB, TCP_TIMER_TYPE TimerType, uint TimerValue);

// The following functions operate on the TCB's wheel state (tcb_timerwheelq
// and tcb_timerslot). A call to any of these functions changes the value
// of both the variables in such a way that they are consistent.

extern void InsertIntoTimerWheel(TCB *InsertTCB, ushort Slot);
extern void RemoveFromTimerWheel(TCB *RemoveTCB);
extern void RemoveAndInsertIntoTimerWheel(TCB *RemInsTCB, ushort Slot);

// The job of the inline functions below, is to sort-of act as glue, and they ensure
// that the wheel state and timer state of a TCB are in tandem with each
// other.

// STOP_TCB_TIMER_R modifies the timer state but never
// does anything to the wheel state. This means that the TCB will remain
// where it was in the timer wheel, and the timer routine will eventually
// bring the wheel state in conformance with the timer state.

extern void STOP_TCB_TIMER_R(TCB *Tcb, TCP_TIMER_TYPE Type);

// START_TCB_TIMER_R modifies the timer state and only modifies
// wheel state if the timer that was started was earlier than all the
// other timers on that TCB. This is in accordance with the lazy evaluation
// strategy.
extern void START_TCB_TIMER_R(TCB *Tcb, TCP_TIMER_TYPE Type, uint Value);



#define COMPUTE_SLOT(Time)  ((Time) % TIMER_WHEEL_SIZE)


#define TCB_TIMER_FIRED_R(tcb, type, time)   \
        ((tcb->tcb_timer[type]) && (tcb->tcb_timer[type] == time))

#define TCB_TIMER_RUNNING_R(tcb, type)  (tcb->tcb_timer[type] != 0)

//* Definitions for TCP states.
#define TCB_CLOSED      0               // Closed.
#define TCB_LISTEN      1               // Listening.
#define TCB_SYN_SENT    2               // SYN Sent.
#define TCB_SYN_RCVD    3               // SYN received.
#define TCB_ESTAB       4               // Established.
#define TCB_FIN_WAIT1   5               // FIN-WAIT-1
#define TCB_FIN_WAIT2   6               // FIN-WAIT-2
#define TCB_CLOSE_WAIT  7               // Close waiting.
#define TCB_CLOSING     8               // Closing state.
#define TCB_LAST_ACK    9               // Last ack state.
#define TCB_TIME_WAIT   10              // Time wait state.

#define SYNC_STATE(s)   ((s) > TCB_SYN_RCVD)
#define SYNC_RCVD_STATE(s)  ((s) > TCB_SYN_SENT)
#define GRACEFUL_CLOSED_STATE(s)    ((s) >= TCB_LAST_ACK)
#define DATA_RCV_STATE(s)   ((s) >= TCB_ESTAB && (s) <= TCB_FIN_WAIT2)
#define DATA_SEND_STATE(s)  ((s) == TCB_ESTAB || (s) == TCB_CLOSE_WAIT)
#define CONN_STATE(TcbState)  ((TcbState) + 1)

C_ASSERT(TCP_CONN_CLOSED == TCB_CLOSED + 1);
C_ASSERT(TCP_CONN_LISTEN == TCB_LISTEN + 1);
C_ASSERT(TCP_CONN_SYN_SENT == TCB_SYN_SENT + 1);
C_ASSERT(TCP_CONN_SYN_RCVD == TCB_SYN_RCVD + 1);
C_ASSERT(TCP_CONN_ESTAB == TCB_ESTAB + 1);
C_ASSERT(TCP_CONN_FIN_WAIT1 == TCB_FIN_WAIT1 + 1);
C_ASSERT(TCP_CONN_FIN_WAIT2 == TCB_FIN_WAIT2 + 1);
C_ASSERT(TCP_CONN_CLOSE_WAIT == TCB_CLOSE_WAIT + 1);
C_ASSERT(TCP_CONN_CLOSING == TCB_CLOSING + 1);
C_ASSERT(TCP_CONN_LAST_ACK == TCB_LAST_ACK + 1);
C_ASSERT(TCP_CONN_TIME_WAIT == TCB_TIME_WAIT + 1);

//* Definitions for flags.
#define WINDOW_SET      0x00000001      // Window explictly set.
#define CLIENT_OPTIONS  0x00000002      // Have client IP options on conn.
#define CONN_ACCEPTED   0x00000004      // Connection was accepted.
#define ACTIVE_OPEN     0x00000008      // Connection came from an active
                                        // open.
#define DISC_NOTIFIED   0x00000010      // Client has been notified of a
                                        // disconnect.
#define IN_DELAY_Q      0x00000020      // We're in the delayed action Q.
#define RCV_CMPLTING    0x00000040      // We're completeing rcvs.
#define IN_RCV_IND      0x00000080      // We're calling a rcv. indicate
                                        // handler.
#define NEED_RCV_CMPLT  0x00000100      // We need to have recvs. completed.
#define NEED_ACK        0x00000200      // We need to send an ACK.
#define NEED_OUTPUT     0x00000400      // We need to output.

#define DELAYED_FLAGS   (NEED_RCV_CMPLT | NEED_ACK | NEED_OUTPUT)


#define ACK_DELAYED     0x00000800      // We've delayed sending an ACK.

#define PMTU_BH_PROBE   0x00001000      // We're probing for a PMTU BH.
#define BSD_URGENT      0x00002000      // We're using BSD urgent semantics.
#define IN_DELIV_URG    0x00004000      // We're in the DeliverUrgent routine.
#define URG_VALID       0x00008000      // We've seen urgent data, and
                                        // the urgent data fields are valid.

#define FIN_NEEDED      0x00010000      // We need to send a FIN.
#define NAGLING         0x00020000      // We are using Nagle's algorithm.
#define IN_TCP_SEND     0x00040000      // We're in TCPSend.
#define FLOW_CNTLD      0x00080000      // We've received a zero window
                                        // from our peer.
#define DISC_PENDING    0x00100000      // A disconnect notification is
                                        // pending.
#define TW_PENDING      0x00200000      // We're waiting to finish going
                                        // to TIME-WAIT.
#define FORCE_OUTPUT    0x00400000      // Output is being forced.
#define FORCE_OUT_SHIFT 22              // Shift to get FORCE_OUTPUT into
                                        // low bit.
#define SEND_AFTER_RCV  0x00800000      // We need to send after we get out
                                        // of recv.
#define GC_PENDING      0x01000000      // A graceful close is pending.
#define KEEPALIVE       0x02000000      // Doing keepalives on this TCB.
#define URG_INLINE      0x04000000      // Urgent data to be processed
                                        // inline.

#define SCALE_CWIN      0x08000000      // Increment CWin proportionally to
                                        // amount of data acknowledged.
#define FIN_OUTSTANDING 0x10000000      // We've sent a FIN 'recently', i.e.
                                        // since the last retransmit. When
                                        // this flag is set sendnext ==
                                        // sendmax.

#define FIN_OUTS_SHIFT  28              // Shift to FIN_OUTSTANDING bit into
                                        // low bit.
#define FIN_SENT        0x20000000      // We've sent a FIN that hasn't
                                        // been acknowledged. Once this
                                        // bit has been turned on in
                                        // FIN-WAIT-1 the sequence number
                                        // of the FIN will be sendmax-1.
#define NEED_RST        0x40000000      // We need to send a RST when
                                        // closing.
#define IN_TCB_TABLE    0x80000000      // TCB is in the TCB table.


#define IN_TWTCB_TABLE  0x80000000
#define IN_TWQUEUE      0x00000001

// N.B. SYNTCB flags share the same bits as TCB flags.
#define IN_SYNTCB_TABLE IN_TCB_TABLE
#define SYNTCB_SHARED_FLAGS     (CONN_ACCEPTED | WINDOW_SET)


//* The defintion of the 'slow flags'. If any of these flags are set we'll
//  be forced off of the fast path.

#define TCP_SLOW_FLAGS  (URG_VALID | FLOW_CNTLD | GC_PENDING | \
                            TW_PENDING | DISC_NOTIFIED | IN_DELIV_URG | \
                            FIN_NEEDED | FIN_SENT | FIN_OUTSTANDING | \
                            DISC_PENDING | PMTU_BH_PROBE)

//* Close reasons.
#define TCB_CLOSE_RST       0x80        // Received a RST segment.
#define TCB_CLOSE_ABORTED   0x40        // Had a local abort.
#define TCB_CLOSE_TIMEOUT   0x20        // Connection timed out.
#define TCB_CLOSE_REFUSED   0x10        // Connect attempt was refused.
#define TCB_CLOSE_UNREACH   0x08        // Remote destination unreachable.
#define TCB_CLOSE_SUCCESS   0x01        // Successfull close.

//* TCB Timer macros.
#define START_TCB_TIMER(t, v) (t) = (v)
#define STOP_TCB_TIMER(t) (t) = 0
#define TCB_TIMER_RUNNING(t)    ((t) != 0)

//  Macro to compute retransmit timeout.
#define REXMIT_TO(t)    ((((t)->tcb_smrtt >> 2) + (t)->tcb_delta) >> 1)

//* Definitons for pending actions. We define a PENDING_ACTION macro
//  that can be used to decide whether or not we can proceed with an
//  activity. The only pending action we really care about is DELETE - others
//  are low priority and can be put off.
#define PENDING_ACTION(t)   ((t)->tcb_pending & DEL_PENDING)
#define DEL_PENDING     0x01            // Delete is pending.
#define OPT_PENDING     0x02            // Option set is pending.
#define FREE_PENDING    0x04            // Can be freed
#define RST_PENDING     0x08            // RST-indication is pending.


//* Macro to see if a TCB is closing.
#define CLOSING(t)  ((t)->tcb_pending & DEL_PENDING)

//* Structure of a TCP packet header.

struct TCPHeader {
    ushort              tcp_src;        // Source port.
    ushort              tcp_dest;       // Destination port.
    SeqNum              tcp_seq;        // Sequence number.
    SeqNum              tcp_ack;        // Ack number.
    ushort              tcp_flags;      // Flags and data offset.
    ushort              tcp_window;     // Window offered.
    ushort              tcp_xsum;       // Checksum.
    ushort              tcp_urgent;     // Urgent pointer.
};

typedef struct TCPHeader TCPHeader;

//* Definitions for header flags.
#define TCP_FLAG_FIN    0x00000100
#define TCP_FLAG_SYN    0x00000200
#define TCP_FLAG_RST    0x00000400
#define TCP_FLAG_PUSH   0x00000800
#define TCP_FLAG_ACK    0x00001000
#define TCP_FLAG_URG    0x00002000

#define TCP_FLAGS_ALL   (TCP_FLAG_FIN | TCP_FLAG_SYN | TCP_FLAG_RST | \
                         TCP_FLAG_ACK | TCP_FLAG_URG)

//* Flags in the tcb_fastchk field that are not in the TCP header proper.
//  Setting these flags forces us off the fast path.
#define TCP_FLAG_SLOW               0x00000001  // Need to be on slow path.
#define TCP_FLAG_IN_RCV             0x00000002  // In recv. path already.
#define TCP_FLAG_FASTREC            0x00000004  // This is used to mark tcb
#define TCP_FLAG_SEND_AND_DISC      0x00000008
// former tcb_flag2 flags, now in tcb_fastchk
#define TCP_FLAG_ACCEPT_PENDING              0x00000010
#define TCP_FLAG_REQUEUE_FROM_SEND_AND_DISC  0x00000020
#define TCP_FLAG_RST_WHILE_SYN      0x00000040  // Valid RST was received while
                                                // establishing outboud connct.



#define TCP_OFFSET_MASK 0xf0
#define TCP_HDR_SIZE(t) (uint)(((*(uchar *)&(t)->tcp_flags) & TCP_OFFSET_MASK) >> 2)

#define MAKE_TCP_FLAGS(o, f) ((f) | ((o) << 4))

#define TCP_OPT_EOL     0
#define TCP_OPT_NOP     1
#define TCP_OPT_MSS     2
#define MSS_OPT_SIZE    4

#define TCP_SACK_PERMITTED_OPT 4
#define SACK_PERMITTED_OPT_SIZE 2       // SACK "permitted" option size, in SYN segments
#define TCP_FLAG_SACK   0x00000004
#define TCP_OPT_SACK    5               // Sack option

#define ALIGNED_TS_OPT_SIZE 12

#define TCP_OPT_WS      3               // Window scale option
#define TCP_OPT_TS      8               // Time stamp option
#define WS_OPT_SIZE     3
#define TS_OPT_SIZE     10
#define TCP_MAXWIN      65535           // maximum unscaled window size
#define TCP_MAX_SCALED_WIN 0x3fffffff   // maximum window with scaling
#define TCP_MAX_WINSHIFT 14             // Maximum shift allowed
#define TCP_MAX_SCALED_WIN 0x3fffffff   // maximum window with scaling.
#define TCP_FLAG_WS     0x00000001      // Flags in tcb_options for ws and ts
#define TCP_FLAG_TS     0x00000002
#define PAWS_IDLE       24*24*60*60*100 // Paws idle time - 24 days

//* Convenient byte swapped structure for receives.
struct TCPRcvInfo {
    SeqNum              tri_seq;        // Sequence number.
    SeqNum              tri_ack;        // Ack number.
    uint                tri_window;     // Window.
    uint                tri_urgent;     // Urgent pointer.
    uint                tri_flags;      // Flags.
};

typedef struct TCPRcvInfo TCPRcvInfo;



//* General structure, at the start of all command specific request structures.

#define tr_signature    0x20205254      // 'TR  '

struct TCPReq {
#if DBG
    ulong           tr_sig;
#endif
    struct  Queue   tr_q;               // Q linkage.
    CTEReqCmpltRtn  tr_rtn;             // Completion routine.
    PVOID           tr_context;         // User context.
    int             tr_status;          // Final complete status.
};

typedef struct TCPReq TCPReq;
// structures to support SACK

struct SackSeg {
    SeqNum begin;
    SeqNum end;
};
typedef struct SackSeg SackSeg;

// Maximum 4 sack entries can be sent
// so, size sack send block acordingly

struct SACKSendBlock {
    uchar Mask[4];
    SackSeg Block[4];
};
typedef struct SACKSendBlock SACKSendBlock;


// list of received sack entries

struct SackListEntry {
    struct SackListEntry *next;
    SeqNum begin;
    SeqNum end;
};
typedef struct SackListEntry SackListEntry;

struct ReservedPortListEntry {
    struct ReservedPortListEntry *next;
    ushort UpperRange;
    ushort LowerRange;
};
typedef struct ReservedPortListEntry ReservedPortListEntry;


#ifdef POOL_TAGGING

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#ifdef CTEAllocMemN
#undef CTEAllocMemN
#endif


#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, 'tPCT')

#ifndef CTEAllocMem
#error "CTEAllocMem is not already defined - will override tagging"
#else
#undef CTEAllocMem
#endif

#ifdef CTEAllocMemBoot
#undef CTEAllocMemBoot
#endif

#if MILLEN
#define CTEAllocMem(size) ExAllocatePoolWithTag(NonPagedPool, size, 'tPCT')
#define CTEAllocMemN(size,tag) ExAllocatePoolWithTag(NonPagedPool, size, tag)
#define CTEAllocMemLow(size,tag) ExAllocatePoolWithTag(NonPagedPool, size, tag)
#define CTEAllocMemBoot(size) ExAllocatePoolWithTag(NonPagedPool, size, 'tPCT')
#else // MILLEN
#define CTEAllocMem(size) ExAllocatePoolWithTagPriority(NonPagedPool, size, 'tPCT', NormalPoolPriority)
#define CTEAllocMemN(size,tag) ExAllocatePoolWithTagPriority(NonPagedPool, size, tag,NormalPoolPriority)
#define CTEAllocMemLow(size,tag) ExAllocatePoolWithTagPriority(NonPagedPool, size, tag,LowPoolPriority)
#define CTEAllocMemBoot(size) ExAllocatePoolWithTag(NonPagedPool, size, 'tPCT')
#endif // !MILLEN


#endif // POOL_TAGGING

#if TRACE_EVENT
#define _WMIKM_
#include "evntrace.h"
#include "wmikm.h"
#include "wmistr.h"

#define EVENT_TRACE_GROUP_TCPIP                0x0600
#define EVENT_TRACE_GROUP_UDPIP                0x0800


typedef VOID (*PTDI_DATA_REQUEST_NOTIFY_ROUTINE)(
                                                IN  ULONG   EventType,
                                                IN  PVOID   DataBlock,
                                                IN  ULONG   Size,
                                                IN  PETHREAD  Thread);

extern PTDI_DATA_REQUEST_NOTIFY_ROUTINE TCPCPHandlerRoutine;


typedef struct _CPTRACE_DATABLOCK {
    IPAddr  saddr;
    IPAddr  daddr;
    ushort  sport;
    ushort  dport;
    uint    size;
    HANDLE  cpcontext;
} CPTRACE_DATABLOCK, *PCPTRACE_BLOCK;
#endif

//
// TCP endpoint context structure allocated for each open of TCP/UDP.
// A pointer to this structure is stored in FileObject->FsContext.
//
typedef struct _TCP_CONTEXT {
    union {
        HANDLE AddressHandle;
        CONNECTION_CONTEXT ConnectionContext;
        HANDLE ControlChannel;
    } Handle;
    ULONG      ReferenceCount;
    BOOLEAN    CancelIrps;
    BOOLEAN    Cleanup;
#if DBG
    LIST_ENTRY PendingIrpList;
    LIST_ENTRY CancelledIrpList;
#endif
    KEVENT     CleanupEvent;
    UINT_PTR   Conn;
    PIRP       Irp;
    DEFINE_LOCK_STRUCTURE(EndpointLock)
} TCP_CONTEXT, *PTCP_CONTEXT;


#define MAJOR_TDI_VERSION 2
#define MINOR_TDI_VERSION 0

extern HANDLE DgHeaderPool;

//* Definition of an AO request structure. There structures are used only for
//  queuing delete and option get/set requests.

#define aor_signature   0x20524F41

typedef struct AORequest {
    struct AODeleteRequest {
#if DBG
        ulong               aor_sig;
#endif
        CTEReqCmpltRtn      aor_rtn;            // Request complete routine for
                                                // this request.
        PVOID               aor_context;        // Request context.
        uint                aor_type;           // Request type.
    };
    struct AORequest    *aor_next;          // Next pointer in chain.
    uint                aor_id;             // ID for the request.
    uint                aor_length;         // Length of buffer.
    void                *aor_buffer;        // Buffer for this request.
} AORequest;


//
// Values of aor_type
//
#define AOR_TYPE_GET_OPTIONS      1
#define AOR_TYPE_SET_OPTIONS      2
#define AOR_TYPE_REVALIDATE_MCAST 3
#define AOR_TYPE_DELETE           4
#define AOR_TYPE_CONNECT          5
#define AOR_TYPE_DISCONNECT       6

extern AORequest *AORequestBlockPtr;

#include    "tcpdeb.h"

#if REFERENCE_DEBUG
uint
TcpReferenceTCB (
    IN TCB *RefTCB,
    IN uchar *File,
    IN uint Line
    );

uint
TcpDereferenceTCB (
    IN TCB *DerefTCB,
    IN uchar *File,
    IN uint Line
    );

#define REFERENCE_TCB(_a) TcpReferenceTCB((_a), (PUCHAR)__FILE__, __LINE__)

#define DEREFERENCE_TCB(_a) TcpDereferenceTCB((_a), (PUCHAR)__FILE__, __LINE__)

#else // REFERENCE_DEBUG

#define REFERENCE_TCB(_a) ++(_a)->tcb_refcnt

#define DEREFERENCE_TCB(_a) --(_a)->tcb_refcnt

#endif // REFERENCE_DEBUG

#endif // _TCP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\queue.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */
#ifndef __QUEUE_H__
#define __QUEUE_H__

//** QUEUE.H - TCP/UDP queuing definitons.
//
//	This file contains the definitions for the queue functions used
//	by the TCP/UDP code.
//

//*	Definition of a queue linkage field.
struct Queue {
	struct	Queue	*q_next;
	struct	Queue	*q_prev;
}; /* Queue */

typedef struct Queue Queue;

//* Initialize queue macro.

#define	INITQ(q)   {	(q)->q_next = (q);\
						(q)->q_prev = (q); }

//*	Macro to check for queue empty.
#define	EMPTYQ(q)	((BOOLEAN)((q)->q_next == (q)))

//*	Place an element onto the end of the queue.

#define	ENQUEUE(q, e)	{	(q)->q_prev->q_next = (e);\
							(e)->q_prev = (q)->q_prev;\
							(q)->q_prev = (e);\
							(e)->q_next = (q); }

//*	Remove an element from the head of the queue. This macro assumes the queue
//	is not empty. The element is returned as type t, queued through linkage
//	l.

#define	DEQUEUE(q, ptr, t, l)	{\
				Queue	*__tmp__;\
				\
				__tmp__ = (q)->q_next;\
				(q)->q_next = __tmp__->q_next;\
				__tmp__->q_next->q_prev = (q);\
				(ptr) = STRUCT_OF(t, __tmp__, l);\
				}

//*	Peek at an element at the head of the queue. We return a pointer to it
//	without removing anything.

#define	PEEKQ(q, ptr, t, l)	{\
				Queue	*__tmp__;\
				\
				__tmp__ = (q)->q_next;\
				(ptr) = STRUCT_OF(t, __tmp__, l);\
				}

//* Macro to push an element onto the head of a queue.

#define	PUSHQ(q, e)	{	(e)->q_next = (q)->q_next;\
						(q)->q_next->q_prev = (e);\
						(e)->q_prev = (q);\
						(q)->q_next = e; }

//* Macro to remove an element from the middle of a queue.
#define	REMOVEQ(q)	{	(q)->q_next->q_prev = (q)->q_prev;\
						(q)->q_prev->q_next = (q)->q_next; }

//** The following macros define methods for working with queue without
// dequeueing, mostly dealing with Queue structures directly.

//* Macro to define the end of a Q, used in walking a queue sequentially.
#define QEND(q) (q)

//* Macro to get the first on a queue.
#define	QHEAD(q) (q)->q_next

//* Macro to get a structure, given a queue.

#define	QSTRUCT(t, q, l) STRUCT_OF(t, (q), l)

//* Macro to get the next thing on q queue.

#define	QNEXT(q)	(q)->q_next

//* Macro to get the previous thing on q queue.

#define QPREV(q)    (q)->q_prev


__inline
VOID
InterlockedEnqueue(
    IN Queue* Q,
    IN Queue* Item,
    IN CTELock* Lock)
{
    CTELockHandle Handle;
    
    CTEGetLock(Lock, &Handle);
    ENQUEUE(Q, Item);
    CTEFreeLock(Lock, Handle);
}

__inline
VOID
InterlockedEnqueueAtDpcLevel(
    IN Queue* Q,
    IN Queue* Item,
    IN CTELock* Lock)
{
    CTEGetLockAtDPC(Lock);
    ENQUEUE(Q, Item);
    CTEFreeLockFromDPC(Lock);
}

__inline
Queue*
InterlockedDequeueIfNotEmpty(
    IN Queue* Q,
    IN CTELock* Lock)
{
    CTELockHandle Handle;
    Queue* Item = NULL;
    
    if (!EMPTYQ(Q)) {
        CTEGetLock(Lock, &Handle);
        if (!EMPTYQ(Q)) {
            Item = Q->q_next;
            Q->q_next = Item->q_next;
            Item->q_next->q_prev = Q;
        }
        CTEFreeLock(Lock, Handle);
    }
        
    return Item;
}

__inline
Queue*
InterlockedDequeueIfNotEmptyAtIrql(
    IN Queue* Q,
    IN CTELock* Lock,
    IN KIRQL OrigIrql)
{
    CTELockHandle Handle;
    Queue* Item = NULL;
    
    if (!EMPTYQ(Q)) {
        CTEGetLockAtIrql(Lock, OrigIrql, &Handle);
        if (!EMPTYQ(Q)) {
            Item = Q->q_next;
            Q->q_next = Item->q_next;
            Item->q_next->q_prev = Q;
        }
        CTEFreeLockAtIrql(Lock, OrigIrql, Handle);
    }
        
    return Item;
}

__inline
VOID
InterlockedRemoveQueueItem(
    IN Queue* Q,
    IN CTELock* Lock)
{
    CTELockHandle Handle;
    CTEGetLock(Lock, &Handle);
    REMOVEQ(Q);
    CTEFreeLock(Lock, Handle);
}

__inline
VOID
InterlockedRemoveQueueItemAtDpcLevel(
    IN Queue* Q,
    IN CTELock* Lock)
{
    CTEGetLockAtDPC(Lock);
    REMOVEQ(Q);
    CTEFreeLockFromDPC(Lock);
}


#endif      // __QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\tcpdeb.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TCPDEB.H - TCP debug definitions.
//
// This file contains the definitions for the debug code.
//

#ifndef NO_TCP_DEFS
#ifdef	DEBUG

extern	void CheckRBList(IPRcvBuf *RBList, uint Size);
extern	void CheckTCBSends(TCB *SendTcb);
extern	void CheckTCBRcv(TCB *RcvTCB);

#else

#define CheckRBList(R, S)
#define CheckTCBSends(T)
#define	CheckTCBRcv(T)
#endif  // DEBUG
#endif  // NO_TCP_DEFS

//
// Additional debugging support for NT
//
#if DBG

extern ULONG TCPDebug;

#define TCP_DEBUG_OPEN           0x00000001
#define TCP_DEBUG_CLOSE          0x00000002
#define TCP_DEBUG_ASSOCIATE      0x00000004
#define TCP_DEBUG_CONNECT        0x00000008
#define TCP_DEBUG_SEND           0x00000010
#define TCP_DEBUG_RECEIVE        0x00000020
#define TCP_DEBUG_INFO           0x00000040
#define TCP_DEBUG_IRP            0x00000080
#define TCP_DEBUG_SEND_DGRAM     0x00000100
#define TCP_DEBUG_RECEIVE_DGRAM  0x00000200
#define TCP_DEBUG_EVENT_HANDLER  0x00000400
#define TCP_DEBUG_CLEANUP        0x00000800
#define TCP_DEBUG_CANCEL         0x00001000
#define TCP_DEBUG_RAW            0x00002000
#define TCP_DEBUG_OPTIONS        0x00004000
#define TCP_DEBUG_1323           0x00008000
#define TCP_DEBUG_SACK           0x00010000
#define TCP_DEBUG_CONUDP         0x00020000
#define TCP_DEBUG_GPC            0x00040000
#define TCP_DEBUG_OFFLOAD        0x00080000






#define TCPTRACE(many_args) DbgPrint many_args

#define IF_TCPDBG(flag)  if (TCPDebug & flag)


#else // DBG


#define TCPTRACE(many_args)
#define IF_TCPDBG(flag)   if (0)


#endif // DBG


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\tcpipbuf.h ===
/*++

 Copyright (c) 1999-2000 Microsoft Corporation

 Module Name:

       tcpipbuf.h

 Abstract:

       This file implements inline wrappers for the NdisBufferVirtualAddress
       and NdisQueryBuffer (which in turn calls MmGetSystemAddressForMdl)
       so that we can test the failure paths and add TCP/IP functionality
       as required.

 Revision History:

--*/

#if DBG

// #define DBG_MAP_BUFFER 1

#if DBG_MAP_BUFFER
// This is to allow us to test failure conditions.
extern ULONG g_cFailSafeMDLQueries;
extern ULONG g_fPerformMDLFailure;
#endif // DBG_MAP_BUFFER

#define TcpipBufferVirtualAddress(pBuffer, Priority) \
    DbgTcpipBufferVirtualAddress(pBuffer, Priority, __FILE__, __LINE__)

#define TcpipQueryBuffer(pBuffer, ppvBuffer, pcbBuffer, Priority) \
    DbgTcpipQueryBuffer(pBuffer, ppvBuffer, pcbBuffer, Priority, __FILE__, __LINE__)

__inline PVOID
DbgTcpipBufferVirtualAddress(
    IN PNDIS_BUFFER pBuffer,
    IN UINT         Priority,
    IN char        *pFileName,
    IN int          cLineNumber
    )
{
    PVOID pvBuffer;

#if DBG_MAP_BUFFER
    if (g_fPerformMDLFailure == TRUE)
    {
        if (InterlockedDecrement(&g_cFailSafeMDLQueries) == 0)
        {
            // Stop failing requests.
            g_fPerformMDLFailure = FALSE;
        }

        DbgPrint("TcpipBufferVirtualAddress FORCED failure - MDL %x: %s @ line %d\n",
            pBuffer, pFileName, cLineNumber);

        return (NULL);
    }
#endif // DBG_MAP_BUFFER

#if MILLEN
    pvBuffer = NdisBufferVirtualAddress(pBuffer);
#else // MILLEN
    pvBuffer = NdisBufferVirtualAddressSafe(pBuffer, Priority);
#endif // !MILLEN

    if (pvBuffer == NULL)
    {
        DbgPrint("TcpipBufferVirtualAddress failure - MDL %x: %s @ line %d\n",
            pBuffer, pFileName, cLineNumber);
    }

    return (pvBuffer);
}

__inline VOID
DbgTcpipQueryBuffer(
    IN	PNDIS_BUFFER pNdisBuffer,
    OUT PVOID *      ppvBuffer OPTIONAL,
    OUT PUINT        pcbBuffer,
    IN  UINT         Priority,
    IN  char        *pFileName,
    IN  int          cLineNumber
    )
{

#if DBG_MAP_BUFFER
    if (g_fPerformMDLFailure == TRUE)
    {
        if (InterlockedDecrement(&g_cFailSafeMDLQueries) == 0)
        {
            // Stop failing requests.
            g_fPerformMDLFailure = FALSE;
        }

        *ppvBuffer = NULL;
        *pcbBuffer = MmGetMdlByteCount(pNdisBuffer);

        DbgPrint("TcpipQueryBuffer FORCED failure - MDL %x: %s @ line %d\n",
            pNdisBuffer, pFileName, cLineNumber);

        return;
    }
#endif // DBG_MAP_BUFFER

#if MILLEN
    NdisQueryBuffer(pNdisBuffer, ppvBuffer, pcbBuffer);
#else // MILLEN
    NdisQueryBufferSafe(pNdisBuffer, ppvBuffer, pcbBuffer, Priority);
#endif // !MILLEN

    if (*ppvBuffer == NULL)
    {
        DbgPrint("TcpipQueryBuffer failure - MDL %x: %s @ line %d\n",
            pNdisBuffer, pFileName, cLineNumber);
    }

    return;
}

#if DBG_MAP_BUFFER

#define IOCTL_IP_DBG_TEST_FAIL_MAP_BUFFER \
            _IP_CTL_CODE(40, METHOD_BUFFERED, FILE_WRITE_ACCESS)

__inline NTSTATUS
DbgTestFailMapBuffers(
    ULONG cFailures
    )
{
    if (g_fPerformMDLFailure == FALSE) {
        DbgPrint("DbgTestFailMapBuffers %d\n", cFailures);
        g_cFailSafeMDLQueries = cFailures;
        g_fPerformMDLFailure = TRUE;
    } else {
        return (STATUS_UNSUCCESSFUL);
    }

    return (STATUS_SUCCESS);
}
#endif // DBG_MAP_BUFFER

#else // DBG

__inline PVOID
TcpipBufferVirtualAddress(
    IN PNDIS_BUFFER pBuffer,
    IN INT          Priority
    )
{
#if MILLEN
    return (NdisBufferVirtualAddress(pBuffer));
#else // MILLEN
    return (NdisBufferVirtualAddressSafe(pBuffer, Priority));
#endif // !MILLEN
}

__inline VOID
TcpipQueryBuffer(
    IN	PNDIS_BUFFER pNdisBuffer,
    OUT PVOID *      ppvBuffer OPTIONAL,
    OUT PUINT        pcbBuffer,
    IN  UINT         Priority
    )
{
#if MILLEN
    NdisQueryBuffer(pNdisBuffer, ppvBuffer, pcbBuffer);
#else // MILLEN
    NdisQueryBufferSafe(pNdisBuffer, ppvBuffer, pcbBuffer, Priority);
#endif // !MILLEN
    return;
}

#endif // !DBG

#if MILLEN

typedef struct _XNDIS_BUFFER {
    struct _NDIS_BUFFER *Next;
    PVOID VirtualAddress;
    PVOID Pool;
    UINT Length;
    UINT Signature;
} XNDIS_BUFFER, *PXNDIS_BUFFER;

__inline VOID
NdisAdjustBuffer(
    IN  PNDIS_BUFFER Mdl,
    IN  PVOID        NewVirtualAddress,
    IN  UINT         NewLength
	)
{
    PXNDIS_BUFFER Buffer = (PXNDIS_BUFFER) Mdl;

    Buffer->VirtualAddress = NewVirtualAddress;
    Buffer->Length         = NewLength;
}
#else // MILLEN
__inline VOID
NdisAdjustBuffer(
    IN  PNDIS_BUFFER Buffer,
    IN  PVOID        NewVirtualAddress,
    IN  UINT         NewLength
	)
{
    PMDL Mdl = (PMDL) Buffer;

    Mdl->MappedSystemVa = NewVirtualAddress;
    Mdl->ByteCount      = NewLength;
    Mdl->ByteOffset     = BYTE_OFFSET(NewVirtualAddress);
}
#endif // !MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\tcpsend.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** TCPSEND.H - TCP send protocol definitions.
//
// This file contains the definitions of TCP send protocol things.
//
#pragma once

#define NUM_TCP_BUFFERS     150

#ifdef SEND_DEBUG
#define SEND_TICKS          10
EXTERNAL_LOCK(SendUseLock)
extern struct TCPSendReq    *SendUseList;
#endif

//* Structure of a TCP send request.

#define tsr_signature       0x20525354  // 'TSR '

typedef struct TCPSendReq {
    struct  TCPReq  tsr_req;            // General request structure.
#if DBG
    ulong           tsr_sig;
#endif
    uint            tsr_size;           // Size in bytes of data in send.
    long            tsr_refcnt;         // Reference count for this send.
    ulong           tsr_flags;          // Flags for this send.
    uint            tsr_unasize;        // Number of bytes unacked.
    uint            tsr_offset;         // Offset into first buffer in chain
                                        // of start of unacked data.
    PNDIS_BUFFER    tsr_buffer;         // Pointer to start of unacked buffer
                                        // chain.
    PNDIS_BUFFER    tsr_lastbuf;        // Pointer to last buffer in chain.
                                        // Valid iff we've sent directly from
                                        // the buffer chain w/o doing an
                                        // NdisCopyBuffer.
    uint            tsr_time;           // TCP time this was received.
#ifdef SEND_DEBUG
    struct TCPSendReq *tsr_next;        // Debug next field.
    uint            tsr_timer;          // Timer field.
    uint            tsr_cmplt;          // Who completed it.
#endif
} TCPSendReq;

#define TSR_FLAG_URG            0x01    // Urgent data.
#define TSR_FLAG_SEND_AND_DISC  0x02    // Send and disconnect


//* Structure defining the context received during a send completes.

#define scc_signature   0x20434353      // 'SCC '

typedef struct SendCmpltContext {
#if DBG
    ulong           scc_sig;
#endif
    ulong           scc_SendSize;
    ulong           scc_ByteSent;
    TCB             *scc_LargeSend;
    TCPSendReq      *scc_firstsend;     // First send in this context.
    uint            scc_count;          // Number of sends in count.
    ushort          scc_ubufcount;      // Number of 'user' buffers in send.
    ushort          scc_tbufcount;      // Number of transport buffers in send.
} SendCmpltContext;

extern void InitSendState(struct TCB *NewTCB);
extern void SendSYN(struct TCB *SYNTcb, CTELockHandle);
extern void SendKA(struct TCB *KATCB, CTELockHandle Handle);
extern void SendRSTFromHeader(struct TCPHeader UNALIGNED *TCPH, uint Length,
                              IPAddr Dest, IPAddr Src, IPOptInfo *OptInfo);
extern void SendACK(struct TCB *ACKTcb);
extern void SendRSTFromTCB(struct TCB *RSTTcb, RouteCacheEntry* RCE);
extern void GoToEstab(struct TCB *EstabTCB);
extern void FreeSendReq(TCPSendReq *FreedReq);
extern void FreeTCPHeader(PNDIS_BUFFER FreedBuffer);

extern int  InitTCPSend(void);
extern void UnInitTCPSend(void);

extern void TCPSend(struct TCB *SendTCB, CTELockHandle Handle);
extern TDI_STATUS TdiSend(PTDI_REQUEST Request, ushort Flags, uint SendLength,
                          PNDIS_BUFFER SendBuffer);
extern uint RcvWin(struct TCB *WinTCB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\tcpipbase.h ===
#pragma once

#include "oscfg.h"

#include <ndis.h>
#include <cxport.h>

#include <tdikrnl.h>
#include <tdiinfo.h>
#include <tdistat.h>
#include "tdint.h"  // do we need this header?

#include <ip.h>
#include <ntddip.h>
#include <ipifcons.h>

#include "queue.h"
#include "refptr.h"
#include "dbgmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\refptr.h ===
//** REFPTR.H - referenced pointer definitons.
//
//	This file contains the definitions for the referenced-pointer package used
//	by the TCP/UDP/IP code.
//


//* Definition of a referenced pointer instance.
//
//  The rp_valid field indicates whether the pointer is valid.
//  SetRefPtr(..., <value>) is used to install <value> as the pointer.
//  ClearRefPtr(...) clears the installed pointer value.
//
//  N.B. The pointer value may only be set when invalid. All attempts to set
//  the pointer will fail until the installed value is cleared.
//
//  If valid, a reference may be taken and the installed pointer captured
//  using AcquireRefPtr. The reference taken should then be released
//  using ReleaseRefPtr.
//
//  N.B. Clearing a pointer may require a wait for all outstanding references
//  to be released, so ClearRefPtr(...) releases the object's lock and assumes
//  that the resulting IRQL is below DISPATCH_LEVEL.
//
struct RefPtr {
    void*           rp_ptr;
    void*           rp_dummy;
    CTELock*        rp_lock;
    BOOLEAN         rp_valid;
    uint            rp_refcnt;
    CTEBlockStruc   rp_block;
};

typedef struct RefPtr RefPtr;

__inline void
InitRefPtr(RefPtr* RP, CTELock* Lock, void* Dummy)
{
    RP->rp_ptr = NULL;
    RP->rp_lock = Lock;
    RP->rp_valid = FALSE;
    RP->rp_refcnt = 0;
    RP->rp_dummy = Dummy;
    CTEInitBlockStruc(&RP->rp_block);
}

__inline BOOLEAN
RefPtrValid(RefPtr* RP)
{
    return RP->rp_valid;
}

__inline void*
AcquireRefPtr(RefPtr* RP)
{
    CTEInterlockedIncrementLong(&RP->rp_refcnt);
    return RP->rp_ptr;
}

__inline void
ReleaseRefPtr(RefPtr* RP)
{
    if (CTEInterlockedDecrementLong(&RP->rp_refcnt) == 0) {
        CTESignal(&RP->rp_block, IP_SUCCESS);
    }
}

__inline IP_STATUS
SetRefPtr(RefPtr* RP, void* Ptr)
{
    ASSERT(Ptr != NULL);

    // We must synchronize the pointer-installation with the execution
    // of all threads holding references. Again, a sequence of operations
    // is required, in the given order:
    // - make an initial reference for the pointer to be installed;
    //   if there were any existing references then someone beat us
    //   into the registration and we must fail this request.
    // - install the new pointer; this is done before setting the flag
    //   to ensure that the pointer is available before any thread
    //   attempts to refer to it.
    // - set the flag indicating the pointer has been enabled.

    if (CTEInterlockedIncrementLong(&RP->rp_refcnt) != 1) {
        ReleaseRefPtr(RP);
        return IP_GENERAL_FAILURE;
    }
    InterlockedExchangePointer((PVOID*)&RP->rp_ptr, Ptr);
    RP->rp_valid = TRUE;

    return IP_SUCCESS;
}


__inline IP_STATUS
ClearRefPtr(RefPtr* RP, CTELockHandle* LockHandle)
{
    if (!RP->rp_valid) {
        return IP_GENERAL_FAILURE;
    }

    // We must now synchronize the clearing of the pointer with
    // the execution of all threads holding references to it. This involves
    // the following operations, *in the given order*:
    // - clear the 'enabled' flag and install the dummy pointer value;
    //   this ensures that no additional references will be made to the
    //   pointer until we return control, and that any references begun
    //   after we set the flag will hold the dummy rather than the
    //   actual pointer.
    // - clear the event in case we need to wait for outstanding references
    //   to be released; the event might still be signalled from a
    //   superfluous dereference during a previous clearing.
    // - drop the initial reference made to the pointer, and wait for all
    //   outstanding references (if any) to be released.

    RP->rp_valid = FALSE;
    InterlockedExchangePointer(&RP->rp_ptr, RP->rp_dummy);

    CTEClearSignal(&RP->rp_block);
    if (CTEInterlockedDecrementLong(&RP->rp_refcnt) != 0) {
        CTEFreeLock(RP->rp_lock, *LockHandle);
        CTEBlock(&RP->rp_block);
        CTEGetLock(RP->rp_lock, LockHandle);
    }

    return IP_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\kdext\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 6/9/1995, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   global
        ,"global - Dumps IPSEC global.\n"
        ,""
        ,""
        ,CUSTOM)

DOIT(   mfl
        ,"mfl - Dumps all masked filters.\n"
        ,""
        ,""
        ,CUSTOM)

DOIT(   tfl
        ,"tfl - Dumps all tunnel filters.\n"
        ,""
        ,""
        ,CUSTOM)

DOIT(   sas
        ,"sas - Dumps all security associations.\n"
        ,""
        ,""
        ,CUSTOM)

DOIT(   tsas
        ,"tsas - Dumps all tunnel security associations.\n"
        ,""
        ,""
        ,CUSTOM)


DOIT(   larvalsas
        ,"larvalsas - Dumps all larval security associations.\n"
        ,""
        ,""
        ,CUSTOM)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\kdext\ipsec.c ===
#include "precomp.h"
#pragma hdrstop

#include <wdbgexts.h>
#include <stdlib.h>
#include "rtkmext.h"
#include "kdmacros.h"

INT                    Item;

HANDLE _hInstance;
HANDLE _hAdditionalReference;
HANDLE _hProcessHeap;

int _Indent = 0;
char IndentBuf[ 80 ]={"\0                                                                      "};

BOOL
dprint_enum_name
(
    ULONG Value,
    PENUM_INFO pEnumInfo
)
{
    while ( pEnumInfo->pszDescription != NULL )
    {
        if ( pEnumInfo->Value == Value )
        {
            dprintf( "%.40s", pEnumInfo->pszDescription );
            return( TRUE );
        }
        pEnumInfo ++;
    }

    dprintf( "Unknown enumeration value." );
    return( FALSE );
}

BOOL
dprint_flag_names
(
    ULONG Value,
    PFLAG_INFO pFlagInfo
)
{
    BOOL bFoundOne = FALSE;

    while ( pFlagInfo->pszDescription != NULL )
    {
        if ( pFlagInfo->Value & Value )
        {
            if ( bFoundOne )
            {
                dprintf( " | " );
            }
            bFoundOne = TRUE;

            dprintf( "%.15s", pFlagInfo->pszDescription );
        }
        pFlagInfo ++;
    }

    return( bFoundOne );
}

VOID
dprint_IP_address
(
    IPAddr Address
)
{
    uchar    IPAddrBuffer[(sizeof(IPAddr) * 4)];
    uint     i;
    uint     IPAddrCharCount;

    //
    // Convert the IP address into a string.
    //
    IPAddrCharCount = 0;

    for (i = 0; i < sizeof(IPAddr); i++) {
        uint    CurrentByte;

        CurrentByte = Address & 0xff;
        if (CurrentByte > 99) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 100) + '0';
            CurrentByte %= 100;
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        } else if (CurrentByte > 9) {
            IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
            CurrentByte %= 10;
        }

        IPAddrBuffer[IPAddrCharCount++] = CurrentByte + '0';
        if (i != (sizeof(IPAddr) - 1))
            IPAddrBuffer[IPAddrCharCount++] = '.';

        Address >>= 8;
    }
    IPAddrBuffer[IPAddrCharCount] = '\0';

    dprintf( "%s", IPAddrBuffer );
}

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        IpsecGlobal
#define _objAddr    pIpsecGlobal
#define _objType    IPSEC_GLOBAL

VOID
Iglobal(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  pDevice = 0;
    ULONG  result;
    UCHAR  cmdline[MAX_PATH]="0";
    UCHAR  arg[MAX_PATH]="0";

    IPSEC_GLOBAL    IpsecGlobal;
    PIPSEC_GLOBAL   pIpsecGlobal;

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {
        if ( !ReadMemory( pDevice,
                          &IpsecGlobal,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    pIpsecGlobal = &IpsecGlobal;

    PrintBool(DriverUnloading);
    PrintBool(BoundToIP);
    PrintBool(SendBoundToIP);

    PrintULong(NumSends);
    PrintULong(NumThreads);
    PrintULong(NumWorkers);
    PrintULong(NumTimers);

    PrintLL(LarvalSAList);
    PrintLock(LarvalListLock);

    PrintLock(SADBLock.SpinLock);
    PrintULong(SADBLock.RefCount);
    PrintLock(SPIListLock.SpinLock);
    PrintULong(SPIListLock.RefCount);

    PrintLL(FilterList[INBOUND_TRANSPORT_FILTER]);
    PrintLL(FilterList[OUTBOUND_TRANSPORT_FILTER]);
    PrintLL(FilterList[INBOUND_TUNNEL_FILTER]);
    PrintLL(FilterList[OUTBOUND_TUNNEL_FILTER]);

    PrintULong(NumPolicies);
    PrintULong(NumTunnelFilters);
    PrintULong(NumMaskedFilters);
    PrintULong(NumOutboundSAs);
    PrintULong(NumMulticastFilters);

    PrintPtr(pSADb);
    PrintULong(NumSA);
    PrintULong(SAHashSize);

    PrintPtr(ppCache);
    PrintULong(CacheSize);

    PrintPtr(IPSecDevice);
    PrintPtr(IPSecDriverObject);

    PrintULong(EnableOffload);
    PrintULong(DefaultSAIdleTime);
    PrintULong(LogInterval);
    PrintULong(EventQueueSize);
    PrintULong(NoDefaultExempt);

    PrintULong(IPSecBufferedEvents);

    PrintPtr(IPSecLogMemory);
    PrintPtr(IPSecLogMemoryLoc);
    PrintPtr(IPSecLogMemoryEnd);

    PrintULong(OperationMode);
    return;
}

FLAG_INFO   FlagsFilter[] =
{
    {   FILTER_FLAGS_PASS_THRU      , "Pass Thru'"     },
    {   FILTER_FLAGS_DROP           , "Drop"      },
    {   0, NULL }
};

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        Filter
#define _objAddr    pFilter
#define _objType    FILTER

VOID
DumpFilter(PFILTER  pFilter, FILTER  Filter)
{
    ULARGE_INTEGER   uliSrcDstAddr;
    ULARGE_INTEGER   uliSrcDstMask;
    ULARGE_INTEGER   uliProtoSrcDstPort;

    uliSrcDstAddr = Filter.uliSrcDstAddr;
    uliSrcDstMask = Filter.uliSrcDstMask;
    uliProtoSrcDstPort = Filter.uliProtoSrcDstPort;

    dprintf("\n--------------------------- FILTER: %lx -------------------------------\n", pFilter);

    PrintLL(MaskedLinkage);
    PrintXULong(Signature);

    PrintFlags(Flags, FlagsFilter);

    PrintFieldName("SrcAddr");
    dprint_IP_address( SRC_ADDR );
    PrintNL();

    PrintFieldName("SrcMask");
    dprint_IP_address( SRC_MASK );
    PrintNL();

    PrintFieldName("DestAddr");
    dprint_IP_address( DEST_ADDR );
    PrintNL();

    PrintFieldName("DestMask");
    dprint_IP_address( DEST_MASK );
    PrintNL();

    PrintUShort(PROTO);

    PrintFieldName("SrcPort");
    dprintf("%-10hu%s", SRC_PORT, EOL);

    PrintFieldName("DestPort");
    dprintf("%-10hu%s", DEST_PORT, EOL);

    PrintIPAddress(TunnelAddr);

    PrintULong(SAChainSize);

    PrintULong(Index);
    PrintGUID(PolicyId);
    PrintGUID(FilterId);
}


VOID
Imfl(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    UCHAR  cmdline[MAX_PATH]="0";
    UCHAR  arg[MAX_PATH]="0";
    ULONG  pDevice=0;

    IPSEC_GLOBAL    IpsecGlobal;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    LONG            Index;

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {
        if ( !ReadMemory( pDevice,
                          &IpsecGlobal,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    for (Index = MIN_TRANSPORT_FILTER; Index <= MAX_TRANSPORT_FILTER; Index++) {
        pEntry = IpsecGlobal.FilterList[Index].Flink;
        while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, FilterList[Index]))) {
            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            if ( !ReadMemory( (ULONG)pFilter,
                            &Filter,
                            sizeof(Filter),
                            &result )) {
                dprintf("%08lx: Could not read device context\n", pDevice);
                return;
            }

            DumpFilter(pFilter, Filter);

            pEntry = Filter.MaskedLinkage.Flink;
        }
    }

    return;
}

VOID
Itfl(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    UCHAR  cmdline[MAX_PATH]="0";
    UCHAR  arg[MAX_PATH]="0";
    ULONG  pDevice=0;

    IPSEC_GLOBAL    IpsecGlobal;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    LONG            Index;

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {

        if ( !ReadMemory( pDevice,
                          &IpsecGlobal,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    for (Index = MIN_TUNNEL_FILTER; Index <= MAX_TUNNEL_FILTER; Index++) {
        pEntry = IpsecGlobal.FilterList[Index].Flink;
        while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, FilterList[Index]))) {
            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            if ( !ReadMemory( (ULONG)pFilter,
                            &Filter,
                            sizeof(Filter),
                            &result )) {
                dprintf("%08lx: Could not read device context\n", pDevice);
                return;
            }

            DumpFilter(pFilter, Filter);

            pEntry = Filter.MaskedLinkage.Flink;
        }
    }

    return;
}

FLAG_INFO   FlagsSA[] =
{
    {   FLAGS_SA_INITIATOR      ,   "Initiator"         },
    {   FLAGS_SA_OUTBOUND       ,   "Outbound"          },
    {   FLAGS_SA_TUNNEL         ,   "Tunnel"            },
    {   FLAGS_SA_REKEY          ,   "Rekey"             },
    {   FLAGS_SA_MANUAL         ,   "Manual"            },
    {   FLAGS_SA_MTU_BUMPED     ,   "MTU_Bumped"        },
    {   FLAGS_SA_PENDING        ,   "Pending"           },
    {   FLAGS_SA_TIMER_STARTED  ,   "Timer_Started"     },
    {   FLAGS_SA_HW_PLUMBED     ,   "HW_Plumbed"        },
    {   FLAGS_SA_HW_PLUMB_FAILED,   "HW_Plumb_failed"   },
    {   FLAGS_SA_HW_CRYPTO_ONLY ,   "HW_Crpto_only"     },
    {   FLAGS_SA_REFERENCED     ,   "SA_referenced"     },
    { 0, NULL }
};

ENUM_INFO   StateSA[] =
{
    {   STATE_SA_CREATED,   "Created"   },
    {   STATE_SA_LARVAL,    "Larval"    },
    {   STATE_SA_ACTIVE,    "Active"    },
    {   STATE_SA_ZOMBIE,    "Zombie"    },
    { 0, NULL }
};

ENUM_INFO   OperationSA[] =
{
    {   None,   "None"   },
    {   Auth,   "Auth"   },
    {   Encrypt,"Encrypt"},
    {   Compress,"Compress"},
    { 0, NULL }
};

ENUM_INFO   AHAlgo[] =
{
    {   IPSEC_AH_NONE, "IPSEC_AH_NONE"},
    {   IPSEC_AH_MD5, "IPSEC_AH_MD5"},
    {   IPSEC_AH_SHA, "IPSEC_AH_SHA"},
    {   IPSEC_AH_MAX, "IPSEC_AH_MAX"},
    { 0, NULL }
};

ENUM_INFO   ESPAlgo[] =
{
    {   IPSEC_ESP_NONE,  "IPSEC_ESP_NONE"},
    {   IPSEC_ESP_DES,  "IPSEC_ESP_DES"},
    {   IPSEC_ESP_DES_40,  "IPSEC_ESP_DES_40"},
    {   IPSEC_ESP_3_DES,  "IPSEC_ESP_3_DES"},
    {   IPSEC_ESP_MAX,  "IPSEC_ESP_MAX"},
    { 0, NULL }
};

#ifdef _obj
#   undef _obj
#   undef _objAddr
#   undef _objType
#endif

#define _obj        SA
#define _objAddr    pSA
#define _objType    SA_TABLE_ENTRY

VOID
DumpSA(PSA_TABLE_ENTRY  pSA, SA_TABLE_ENTRY  SA)
{
    ULARGE_INTEGER   uliSrcDstAddr;
    ULARGE_INTEGER   uliSrcDstMask;
    ULARGE_INTEGER   uliProtoSrcDstPort;
    LONG   i;

    uliSrcDstAddr = SA.sa_uliSrcDstAddr;
    uliProtoSrcDstPort = SA.sa_uliProtoSrcDstPort;

    dprintf("\n---------------------- Security Association: %lx -----------------------\n", pSA);

    PrintLL(sa_SPILinkage);
    PrintLL(sa_FilterLinkage);
    PrintLL(sa_LarvalLinkage);
    PrintLL(sa_PendingLinkage);

    PrintXULong(sa_AssociatedSA);
    PrintXULong(sa_RekeyLarvalSA);
    PrintXULong(sa_RekeyOriginalSA);

    PrintXULong(sa_Filter);

    PrintXULong(sa_Signature);
    PrintULong(sa_Reference);

    PrintFlags(sa_Flags, FlagsSA);
    PrintEnum(sa_State, StateSA);

    PrintFieldName("SrcAddr");
    dprint_IP_address( SRC_ADDR );
    PrintNL();

    PrintFieldName("DestAddr");
    dprint_IP_address( DEST_ADDR );
    PrintNL();

    PrintUShort(SA_PROTO);

    PrintFieldName("SrcPort");
    dprintf("%-10hu%s", SA_SRC_PORT(&SA), EOL);

    PrintFieldName("DestPort");
    dprintf("%-10hu%s", SA_DEST_PORT(&SA), EOL);

    PrintIPAddress(sa_TunnelAddr);

    PrintXULong(sa_SPI);

    PrintULong(sa_NumOps);

    for (i=0; i<SA.sa_NumOps; i++) {
        PrintXULong(sa_OtherSPIs[i]);
        switch (SA.sa_Operation[i]) {
        case None:
            break;
        case Auth:
            PrintEnum(sa_Algorithm[i].integrityAlgo.algoIdentifier, AHAlgo);
            PrintFieldName("algoKey");
            dprintf("%lx %lx", SA.sa_Algorithm[i].integrityAlgo.algoKey, EOL);
            PrintNL();

            PrintULong(sa_Algorithm[i].integrityAlgo.algoKeylen);

            break;
        case Encrypt:
            PrintEnum(sa_Algorithm[i].integrityAlgo.algoIdentifier, AHAlgo);
            PrintFieldName("algoKey");
            dprintf("%lx %lx", SA.sa_Algorithm[i].integrityAlgo.algoKey, EOL);
            PrintNL();

            PrintULong(sa_Algorithm[i].integrityAlgo.algoKeylen);

            PrintEnum(sa_Algorithm[i].confAlgo.algoIdentifier, ESPAlgo);
            PrintFieldName("algoKey");
            dprintf("%lx %lx", SA.sa_Algorithm[i].confAlgo.algoKey, EOL);
            PrintNL();

            PrintULong(sa_Algorithm[i].confAlgo.algoKeylen);

            break;
        }
    }

    PrintULong(sa_TruncatedLen);
    PrintULong(sa_ReplayStartPoint);
    PrintULong(sa_ReplayLastSeq);
    PrintULong(sa_ReplayBitmap);
    PrintULong(sa_ReplaySendSeq);
    PrintULong(sa_ReplayLen);

    PrintULong(sa_BlockedDataLen);
    PrintXULong(sa_BlockedBuffer);
    PrintULong(sa_ExpiryTime);
}

VOID
Isas(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    ULONG  pDevice=0;

    IPSEC_GLOBAL    IpsecGlobal;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pEntry1;
    PSA_TABLE_ENTRY pSA;
    SA_TABLE_ENTRY  SA;
    SA_TABLE_ENTRY  NextSA;
    LONG            Index, SAIndex;
    LIST_ENTRY     * SAChain;          

    pDevice    =   GetExpression( "ipsec!g_ipsec" );


    SAChain= malloc(256*sizeof(LIST_ENTRY)*sizeof(LIST_ENTRY));
    if (NULL==SAChain) 
    	{
    		dprintf("Could not allocate memory resources\n");
    		return;
    	}
    			
    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        free(SAChain);
        return;
    } else {

        if ( !ReadMemory( pDevice,
                          &IpsecGlobal,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            free(SAChain);
            return;
        }
    }

    for (Index = MIN_TRANSPORT_FILTER; Index <= MAX_TRANSPORT_FILTER; Index++) {
        pEntry = IpsecGlobal.FilterList[Index].Flink;
        while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, FilterList[Index]))) {
            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            if ( !ReadMemory(   (ULONG)pFilter,
                            &Filter,
                            sizeof(Filter),
                            &result )) {
                dprintf("%08lx: Could not read filter context\n", pFilter);
                free(SAChain);
                return;
            }

            if ( !ReadMemory(   (ULONG)pFilter + FIELD_OFFSET(FILTER, SAChain[0]),
                            SAChain,
                            Filter.SAChainSize * sizeof(LIST_ENTRY),
                            &result )) {
                dprintf("%08lx: Could not read SAChain context\n", pFilter + FIELD_OFFSET(FILTER, SAChain[0]));
                free(SAChain);
                return;
            }

            DumpFilter(pFilter, Filter);

            for (SAIndex = 0; SAIndex < Filter.SAChainSize; SAIndex++) {
                pEntry1 = SAChain[SAIndex].Flink;

                while (pEntry1 != (PLIST_ENTRY)((PUCHAR)pFilter + FIELD_OFFSET(FILTER, SAChain[SAIndex]))) {
                    pSA = CONTAINING_RECORD(pEntry1,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ( !ReadMemory( (ULONG)pSA,
                                    &SA,
                                    sizeof(SA),
                                    &result )) {
                        dprintf("%08lx: Could not read SA context\n", pSA);
                        free(SAChain);
                        return;
                    }

                    DumpSA(pSA, SA);

                    pEntry1 = SA.sa_FilterLinkage.Flink;
                }
            }

            pEntry = Filter.MaskedLinkage.Flink;
        }
    }


    
    free(SAChain);
    return;
}

VOID
Itsas(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    ULONG  pDevice=0;

    IPSEC_GLOBAL    IpsecGlobal;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pEntry1;
    PSA_TABLE_ENTRY pSA;
    SA_TABLE_ENTRY  SA;
    SA_TABLE_ENTRY  NextSA;
    LONG            Index, SAIndex;
    LIST_ENTRY      * SAChain;          

    pDevice    =   GetExpression( "ipsec!g_ipsec" );


    SAChain=malloc(256*sizeof(LIST_ENTRY)*sizeof(LIST_ENTRY));
    if (NULL==SAChain) 
    	{
    		dprintf("Could not allocate memory resources\n");
    		return;
    	}
    
    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        free(SAChain);
        return;
    } else {

        if ( !ReadMemory( pDevice,
                          &IpsecGlobal,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            free(SAChain);
            return;
        }
    }

    for (Index = MIN_TUNNEL_FILTER; Index <= MAX_TUNNEL_FILTER; Index++) {
        pEntry = IpsecGlobal.FilterList[Index].Flink;
        while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, FilterList[Index]))) {
            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            if ( !ReadMemory(   (ULONG)pFilter,
                            &Filter,
                            sizeof(Filter),
                            &result )) {
                dprintf("%08lx: Could not read filter context\n", pFilter);
                free(SAChain);
                return;
            }

            if ( !ReadMemory(   (ULONG)pFilter + FIELD_OFFSET(FILTER, SAChain[0]),
                            SAChain,
                            Filter.SAChainSize * sizeof(LIST_ENTRY),
                            &result )) {
                dprintf("%08lx: Could not read SAChain context\n", pFilter + FIELD_OFFSET(FILTER, SAChain[0]));
                free(SAChain);
                return;
            }

            DumpFilter(pFilter, Filter);

            for (SAIndex = 0; SAIndex < Filter.SAChainSize; SAIndex++) {
                pEntry1 = SAChain[SAIndex].Flink;

                while (pEntry1 != (PLIST_ENTRY)((PUCHAR)pFilter + FIELD_OFFSET(FILTER, SAChain[SAIndex]))) {
                    pSA = CONTAINING_RECORD(pEntry1,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ( !ReadMemory( (ULONG)pSA,
                                    &SA,
                                    sizeof(SA),
                                    &result )) {
                        dprintf("%08lx: Could not read SA context\n", pSA);
                        free(SAChain);
                        return;
                    }

                    DumpSA(pSA, SA);

                    pEntry1 = SA.sa_FilterLinkage.Flink;
                }
            }

            pEntry = Filter.MaskedLinkage.Flink;
        }
    }

    free(SAChain);
    return;
}


VOID
Ilarvalsas(DWORD   opts, LPSTR args)
{
    ULONG  deviceToDump = 0;
    ULONG  result;
    ULONG  pDevice=0;

    IPSEC_GLOBAL    IpsecGlobal;
    PFILTER         pFilter;
    FILTER          Filter;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pEntry1;
    PSA_TABLE_ENTRY pSA;
    SA_TABLE_ENTRY  SA;
    SA_TABLE_ENTRY  NextSA;

    pDevice    =   GetExpression( "ipsec!g_ipsec" );

    if ( !pDevice ) {
        dprintf("Could not get g_ipsec, Try !reload\n");
        return;
    } else {

        if ( !ReadMemory( pDevice,
                          &IpsecGlobal,
                          sizeof(IPSEC_GLOBAL),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }
    }

    pEntry = IpsecGlobal.LarvalSAList.Flink;
    while (pEntry != (PLIST_ENTRY)(pDevice + FIELD_OFFSET(IPSEC_GLOBAL, LarvalSAList))) {
        pSA = CONTAINING_RECORD(pEntry,
                                SA_TABLE_ENTRY,
                                sa_LarvalLinkage);

        if ( !ReadMemory( (ULONG)pSA,
                          &SA,
                          sizeof(SA),
                          &result )) {
            dprintf("%08lx: Could not read device context\n", pDevice);
            return;
        }

        DumpSA(pSA, SA);

        pEntry = SA.sa_LarvalLinkage.Flink;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\kdext\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <stdio.h>

#include <tcpipbase.h>

#if GPC
#include <gpcifc.h>
#endif

#include <ipfilter.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <llipif.h>
#include <ffp.h>
#include <ipinit.h>
#include <ipdef.h>

#if FIPS
#include <fipsapi.h>
#endif

#include <des.h>
#include <md5.h>
#include <modes.h>
#include <ntddksec.h>
#include <randlib.h>
#include <rc4.h>
#include <sha.h>
#include <tripldes.h>

#include "ipsec.h"
#include "debug.h"
#include "timer.h"
#include "locks.h"
#include "globals.h"
#include "ah.h"
#include "esp.h"
#include "externs.h"
#include "ahxforms.h"
#include "filter.h"
#include "acquire.h"
#include "intirspn.h"
#include "driver.h"
#include "saapi.h"
#include "ipseceng.h"
#include "gpc.h"
#include "offload.h"
#include "hughes.h"
#include "macros.h"
#include "iperrs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\kdext\kdexts.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:


Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntsdexts.h>
//#define NOEXTAPI
#include <wdbgexts.h>
#include <ntverp.h>
//#include <stdexts.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
USHORT                 usProcessorArchitecture;
BOOL                   bDebuggingChecked;

PSZ szProcessorArchitecture[] = {
    "Intel",
    "MIPS",
    "Alpha",
    "PPC"
};
#define cArchitecture (sizeof(szProcessorArchitecture) / sizeof(PSZ))

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ULONG offKeProcessorArchitecture;
    ULONG Result;

    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);
    usProcessorArchitecture = (USHORT)-1;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\kdext\rtext.c ===
#ifndef KERNEL
PSTR pszExtName         = "RTUMEXT";
#else
PSTR pszExtName         = "IPSEC";
#endif

#include <stdexts.h>
#include <stdexts.c>

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\kdext\kdmacros.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdmacros.h

Abstract:

    This file is a common header file for tcpext.dll

Author:

    John Ballard (jballard)

Environment:

    User Mode

--*/

#define ITEMSIZE    25

typedef struct
{
    ULONG Value;
    PCHAR pszDescription;
} ENUM_INFO, *PENUM_INFO, FLAG_INFO, *PFLAG_INFO;

#define EnumString( Value ) { Value, #Value }

extern ENUM_INFO EnumStructureType[];

//#define EOL ( (Item++ & 1) ? "\n":"" )
typedef enum
{
    VERBOSITY_ONE_LINER = 0,
    VERBOSITY_NORMAL,
    VERBOSITY_FULL
} VERBOSITY;

#define PrintStart Item = 0;

extern int _Indent;
extern char IndentBuf[ 80 ];

#define IndentChange( cch ) { IndentBuf[_Indent]=' '; _Indent += ( cch ); IndentBuf[_Indent]='\0';}
#define Indent( cch ) IndentChange( cch )
#define Outdent( cch ) IndentChange( -( cch ) )

#define PrintStartStruct()  { PrintStart; dprintf( "%s{\n", IndentBuf ); Indent( 2 );  }

#define PrintStartNamedStruct( _name )  { PrintStart; dprintf( "%s%s {\n", IndentBuf, _name ); Indent( 2 );  }

static PCHAR pchEol = "\n";
static PCHAR pchBlank = "";
static PCHAR * ppchCurrentEol = &pchEol;
static PCHAR * ppchTempEol = &pchEol;

#define PrintJoin() { ppchCurrentEol = &pchBlank; }

#define EOL (( ppchTempEol = ppchCurrentEol ), ( ppchCurrentEol = &pchEol ), ( *ppchTempEol ))

VOID
dprintSymbolPtr
(
    PVOID Pointer,
    PCHAR EndOfLine
);

VOID
dprint_nchar
(
    PCHAR pch,
    int cch
);

VOID
dprint_hardware_address
(
    PUCHAR Address
);

BOOL
dprint_enum_name
(
    ULONG Value,
    PENUM_INFO pEnumInfo
);


BOOL
dprint_flag_names
(
    ULONG Value,
    PFLAG_INFO pFlagInfo
);

BOOL
dprint_masked_value
(
    ULONG Value,
    ULONG Mask
);

VOID
dprint_addr_list(
    ULONG FirstAddress,
    ULONG OffsetToNextPtr
);

VOID
dprint_IP_address
(
    IPAddr Address
);

ULONG
GetUlongValue (
    PCHAR String
);

/*
#define PrintEnd   \
        dprintf( "%s", EOL ); \
        Item = 0;
*/

#define PrintEnd   \
        Item = 0;

#define PrintNL()   dprintf("\n");

#define PrintEndStruct()  { Outdent( 2 ); PrintEnd; dprintf( "%s}\n", IndentBuf ); }

#define PrintFlushLeft() PrintEnd

#define PRINTBOOL(var)  ( (var) ? "True" : "False")

#define PrintFieldName(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s = ",IndentBuf,_fieldName );                                        \
        }

#define PrintFieldNameAt(_fieldName) \
        if ( strlen(_fieldName) > 35 ) {                                                \
            dprintf("%s%-.25s..%s @ ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-8]));   \
        }else {                                                                         \
            dprintf("%s%-35.35s @ ",IndentBuf,_fieldName );                                        \
        }

#define PrintListTcpFieldName(_fieldName) \
        if ( strlen(_fieldName) > 40 ) {                                                \
            dprintf("%s%-.30s...%s q_next = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-7]));   \
        }else {                                                                        \
            dprintf("%s%-40.40s q_next = ",IndentBuf,_fieldName );                                        \
        }

#define PrintListFieldName(_fieldName) \
        if ( strlen(_fieldName) > 40 ) {                                                \
            dprintf("%s%-.30s...%s FLink = ",IndentBuf,_fieldName, &(_fieldName[strlen(_fieldName)-7]));   \
        }else {                                                                        \
            dprintf("%s%-40.40s FLink = ",IndentBuf,_fieldName );                                        \
        }

#define PrintIndent()   dprintf( "%s", IndentBuf );
/* #define PrintFieldName(_fieldName) \
        dprintf(" %-25.25s = ",_fieldName );*/

#define PrintRawBool( _bValue ) \
            dprintf("%-10s%s", (_obj._bValue) ? "True" : "False", EOL)

#define PrintBool(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10s%s", (_obj._field) ? "True" : "False", EOL)

#define PrintULong(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", _obj._field, EOL)

#define PrintXULong(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%08lx%s", _obj._field, EOL)

#define PrintUShort(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10hu%s", _obj._field, EOL)

#define PrintHTONUShort(_field) \
            PrintFieldName(#_field)  \
            dprintf("%-10hu%s", htons(_obj._field), EOL)

#define PrintXUShort(_field)     \
            PrintFieldName(#_field)  \
            dprintf("0x%04hx%s", _obj._field, EOL)

#define PrintNChar( _field, count )        \
            PrintFieldName(#_field)  \
            dprint_nchar( ( PCHAR )_obj._field, count ); \
            dprintf("%s", EOL)

#define PrintUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("%-10lu%s", (ULONG) _obj._field, EOL)

#define PrintXUChar(_field)        \
            PrintFieldName(#_field)  \
            dprintf("0x%-8lx%s", (ULONG) _obj._field, EOL)

#define PrintPtr(_field)            \
            PrintFieldName(#_field)  \
            dprintf("%-10lx%s", _obj._field, EOL)

#define PrintSymbolPtr( _field )    \
            PrintFieldName(#_field)  \
            dprintSymbolPtr( (( PVOID )_obj._field), EOL );

#define AddressOf( _field ) ((( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ))

#define PrintAddr(_field)               \
            PrintFieldNameAt(#_field)   \
            dprintf("%-10lx%s", AddressOf( _field ), EOL)

#define PrintL(_field) \
            PrintFieldName(#_field##".Next")  \
            dprintf("%-10lx%s",  _obj._field.Next, EOL )

#define PrintLL(_field)                                     \
            PrintEnd;                                       \
            PrintListFieldName(#_field );                  \
            dprintf("%-10lx",  _obj._field.Flink );         \
            dprintf("Blink = %-10lx",  _obj._field.Blink );         \
            dprintf("%s\n", ( _obj._field.Flink == _obj._field.Blink ) ? " (Empty)" : "" );

#define PrintLLTcp(_field)                                     \
            PrintEnd;                                       \
            PrintListTcpFieldName(#_field );                  \
            dprintf("%-10lx",  _obj._field.q_next );         \
            dprintf("q_prev = %-10lx",  _obj._field.q_prev );         \
            dprintf("%s\n", ( _obj._field.q_next == _obj._field.q_prev ) ? " (Empty)" : "" );

#define PrintIrpQ(_field) \
            PrintEnd;   \
            PrintFieldName(#_field##".Head");                 \
            dprintf("%-10lx",  _obj._field.Head );            \
            PrintFieldName(#_field##".Tail");                 \
            dprintf("%-10lx\n",  _obj._field.Tail );

#define PrintFlags( _field, _pFlagStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );     \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintFlagsMask( _field, _pFlagStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_flag_names( (ULONG) _obj._field, _pFlagStruct );  \
            dprintf( ")\n" );

#define PrintEnum( _field, _pEnumStruct )                   \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("%lu (", (ULONG) _obj._field );         \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnum( _field, _pEnumStruct )                  \
            PrintEnd;                                       \
            PrintFieldName(#_field);                        \
            dprintf("0x%08lx (", (ULONG) _obj._field );    \
            dprint_enum_name( (ULONG) _obj._field, _pEnumStruct );  \
            dprintf( ")\n" );

#define PrintXEnumMask( _field, _pEnumStruct, _Mask )       \
            PrintEnd;                                       \
            PrintFieldName(" & " ## #_Mask );               \
            dprintf("0x");                                  \
            dprint_masked_value((ULONG) _obj._field, _Mask );    \
            dprintf("(");                                   \
            dprint_enum_name((ULONG) _obj._field & _Mask, _pEnumStruct );  \
            dprintf( ")\n" );


#define PrintHardwareAddress( _field )                      \
            PrintFieldName(#_field);                        \
            dprint_hardware_address( _obj._field.Address ); \
            dprintf( "%s", EOL );

#define PrintIPAddress( _field )                      \
            PrintFieldName(#_field);                        \
            dprint_IP_address( _obj._field ); \
            dprintf( "%s", EOL );

#define PrintGUID( _field )                                 \
            PrintFieldName(#_field);                        \
            dprintf("{%lx.%lx.%lx.%lx}",                    \
                    *(PULONG)(&_obj._field),                \
                    *((PUCHAR)(&_obj._field)+4),            \
                    *((PUCHAR)(&_obj._field)+8),            \
                    *((PUCHAR)(&_obj._field)+12));          \
            dprintf( "%s", EOL );

#define PrintLock(_field) \
            PrintFieldName(#_field)  \
            dprintf("( 0x%08lx ) %-10s%s", (_obj._field), (_obj._field) ? "Locked" : "UnLocked", EOL)

#define PrintTDIAddress( _field )                           \
            PrintFieldName( #_field );                      \
            dprintf( "{ NetworkAddress = %X, NodeAddress = ", _obj._field.NetworkAddress );\
            dprint_hardware_address( _obj._field.NodeAddress );\
            dprintf( ", Socket = %d }%s", _obj._field.Socket, EOL );

#define PrintCTETimer( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpCTETimer ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintCTEEvent( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpCTEEvent ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintKEvent( _field )                             \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpKEvent ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();

#define PrintWorkQueueItem( _field )                        \
            dprintf( "%s", #_field );                       \
            PrintStartStruct();                             \
            DumpWorkQueueItem ( ((ULONG)_objAddr) +FIELD_OFFSET( _objType, _field ), VERBOSITY_NORMAL );\
            PrintEndStruct();


extern  BOOLEAN ChkTarget;
extern  INT     Item;

#define CHECK_SIGNATURE( _field, _signature )   \
    if ( _obj._field != _signature )            \
    {                                           \
        dprintf( "Object at %08X doesn't have signature %s at %08X\n",   \
                 _objAddr,                                              \
                 #_signature,                                           \
                 (( ULONG )_objAddr) + FIELD_OFFSET( _objType, _field ));\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\kdext\rtkmext.c ===
#include    "rtkmext.h"

#include "precomp.h"
#pragma hdrstop

#ifndef KERNEL
PSTR pszExtName         = "RTUMEXT";
#else
PSTR pszExtName         = "IPSEC";
#endif

#include <stdexts.h>
#include <stdexts.c>

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\inc\tdint.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    tdint.h

Abstract:

    This file defines TDI types specific to the NT environment.

Author:

    Mike Massa (mikemas)    August 13, 1993

Revision History:

--*/

#ifndef _TDINT_
#define _TDINT_

#include <tdikrnl.h>

typedef PTDI_IND_DISCONNECT      PDisconnectEvent;
typedef PTDI_IND_ERROR           PErrorEvent;
typedef PTDI_IND_ERROR_EX        PErrorEx;
typedef PTDI_IND_CHAINED_RECEIVE PChainedRcvEvent;

#if MILLEN

typedef struct _EventRcvBuffer {
    PNDIS_BUFFER   erb_buffer;
    uint           erb_size;
    CTEReqCmpltRtn erb_rtn;
    PVOID          erb_context;
    ushort        *erb_flags;
} EventRcvBuffer;

typedef struct _ConnectEventInfo {
    CTEReqCmpltRtn              cei_rtn;
    PVOID                       cei_context;
    PTDI_CONNECTION_INFORMATION cei_acceptinfo;
    PTDI_CONNECTION_INFORMATION cei_conninfo;
} ConnectEventInfo;

typedef TDI_STATUS  (*PRcvEvent)(PVOID EventContext, PVOID ConnectionContext,
                        ulong Flags, uint Indicated, uint Available,
                        uint *Taken, uchar *Data, EventRcvBuffer *Buffer);

typedef TDI_STATUS  (*PRcvDGEvent)(PVOID EventContext, uint AddressLength,
                        PTRANSPORT_ADDRESS Address, uint OptionsLength, PVOID
                        Options,  uint Flags, uint Indicated, uint Available,
                        uint *Taken, uchar *Data, EventRcvBuffer **Buffer);

typedef TDI_STATUS  (*PRcvExpEvent)(PVOID EventContext, PVOID ConnectionContext,
                        ulong Flags, uint Indicated, uint Available,
                        uint *Taken, uchar *Data, EventRcvBuffer *Buffer);

typedef TDI_STATUS  (*PConnectEvent)(PVOID EventContext, uint AddressLength,
                        PTRANSPORT_ADDRESS Address, uint UserDataLength,
                        PVOID UserData, uint OptionsLength, PVOID
                        Options,  PVOID *AcceptingID,
                        ConnectEventInfo *EventInfo);

#else // MILLEN
typedef IRP EventRcvBuffer;
typedef IRP ConnectEventInfo;

typedef PTDI_IND_CONNECT           PConnectEvent;
typedef PTDI_IND_RECEIVE           PRcvEvent;
typedef PTDI_IND_RECEIVE_DATAGRAM  PRcvDGEvent;
typedef PTDI_IND_RECEIVE_EXPEDITED PRcvExpEvent;
#endif // !MILLEN



#endif  // ifndef _TDINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\cache.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    cache.h

Abstract:

    This module contains declarations for a simple cache system.
    Cache entries are stored as void pointers with 32-bit keys.

Author:

    Abolade Gbadegesin (aboladeg)   19-Feb-1998

Revision History:

--*/

#ifndef _CACHE_H_
#define _CACHE_H_

#define CACHE_SHIFT     4
#define CACHE_SIZE      (1 << (8 - CACHE_SHIFT))
#define CACHE_INDEX(k)  ((unsigned char)(k) & (0xFF >> CACHE_SHIFT))

typedef struct _CACHE_ENTRY {
    unsigned long Key;
    void* Value;
    long Hits;
    long Misses;
} CACHE_ENTRY, *PCACHE_ENTRY;


__inline
void
InitializeCache(
    CACHE_ENTRY Cache[]
    )
{
    memset(Cache, 0, CACHE_SIZE * sizeof(CACHE_ENTRY));
}

__inline
void
ClearCache(
    CACHE_ENTRY Cache[],
    unsigned long Key
    )
{
    long Index = CACHE_INDEX(Key);
    Cache[Index].Key = 0;
    Cache[Index].Value = 0;
    Cache[Index].Hits = 0;
    Cache[Index].Misses = 0;
}


__inline
void*
ProbeCache(
    CACHE_ENTRY Cache[],
    unsigned long Key
    )
{
    long Index = CACHE_INDEX(Key);
    if (Key == Cache[Index].Key) {
        Cache[Index].Hits++;
        return Cache[Index].Value;
    }
    Cache[Index].Misses++;
    return NULL;
}

__inline
int
UpdateCache(
    CACHE_ENTRY Cache[],
    unsigned long Key,
    void* Value
    )
{
    long Index = CACHE_INDEX(Key);
    if (Key == Cache[Index].Key ||
        Cache[Index].Hits >=
            (Cache[Index].Misses - (Cache[Index].Misses >> 2))) { return 0; }
    Cache[Index].Key = Key;
    Cache[Index].Value = Value;
    Cache[Index].Hits = 0;
    Cache[Index].Misses = 0;
    return 1;
}


__inline
void
InterlockedClearCache(
    CACHE_ENTRY Cache[],
    unsigned long Key
    )
{
    long Index = CACHE_INDEX(Key);
    InterlockedExchange(&Cache[Index].Key, 0);
    InterlockedExchangePointer(&Cache[Index].Value, 0);
    InterlockedExchange(&Cache[Index].Hits, 0);
    InterlockedExchange(&Cache[Index].Misses, 0);
}


__inline
void*
InterlockedProbeCache(
    CACHE_ENTRY Cache[],
    unsigned long Key
    )
{
    long Index = CACHE_INDEX(Key);
    if (Key == Cache[Index].Key) {
        InterlockedIncrement(&Cache[Index].Hits);
        return Cache[Index].Value;
    }
    InterlockedIncrement(&Cache[Index].Misses);
    return NULL;
}

__inline
int
InterlockedUpdateCache(
    CACHE_ENTRY Cache[],
    unsigned long Key,
    void* Value
    )
{
    long Index = CACHE_INDEX(Key);
    if (Key == Cache[Index].Key ||
        Cache[Index].Hits >=
            (Cache[Index].Misses - (Cache[Index].Misses >> 2))) { return 0; }
    InterlockedExchange(&Cache[Index].Key, Key);
    InterlockedExchangePointer(&Cache[Index].Value, Value);
    InterlockedExchange(&Cache[Index].Hits, 0);
    InterlockedExchange(&Cache[Index].Misses, 0);
    return 1;
}

#endif // _CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nsdebug.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsConn.h
    
Abstract:

    IpSec NAT shim debug code

Author:

    Jonathan Burstein (jonburs) 23-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#pragma once

//
// Kernel-debugger output definitions
//

#if DBG
#define TRACE(Class,Args) \
    if ((TRACE_CLASS_ ## Class) & (NsTraceClassesEnabled)) { DbgPrint Args; }
#define ERROR(Args)             TRACE(ERRORS, Args)
#define CALLTRACE(Args)         TRACE(CALLS, Args)
#else
#define TRACE(Class,Args)
#define ERROR(Args)
#define CALLTRACE(Args)
#endif


#define TRACE_CLASS_CALLS           0x00000001
#define TRACE_CLASS_CONN_LIFETIME   0x00000002
#define TRACE_CLASS_CONN_LOOKUP     0x00000004
#define TRACE_CLASS_PORT_ALLOC      0x00000008
#define TRACE_CLASS_PACKET          0x00000010
#define TRACE_CLASS_TIMER           0x00000020
#define TRACE_CLASS_ICMP            0x00000040
#define TRACE_CLASS_ERRORS          0x00000080


//
// Pool-tag value definitions, sorted by tag value
//

#define NS_TAG_ICMP                 'cIsN'
#define NS_TAG_CONNECTION           'eCsN'
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nsinit.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsInit.h
    
Abstract:

    Declarations for IpSec NAT shim initialization and shutdown routines

Author:

    Jonathan Burstein (jonburs) 11-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#pragma once

//
// Macros for handling network-order shorts and longs
//

#define ADDRESS_BYTES(a) \
    ((a) & 0x000000FF), (((a) & 0x0000FF00) >> 8), \
    (((a) & 0x00FF0000) >> 16), (((a) & 0xFF000000) >> 24)

//
// Define a macro version of ntohs which can be applied to constants,
// and which can thus be computed at compile time.
//

#define NTOHS(p)    ((((p) & 0xFF00) >> 8) | (((UCHAR)(p) << 8)))

//
// Global Variables
//

extern PDEVICE_OBJECT NsIpSecDeviceObject;

#if DBG
extern ULONG NsTraceClassesEnabled;
#endif

//
// Function Prototypes
//

NTSTATUS
NsCleanupShim(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\kdext\rtkmext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    net\routing\rtext\rtext.h

Abstract:


Revision History:



--*/

#include "precomp.h"
#pragma  hdrstop

#define __FILE_SIG__
#include <ipsec.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nsicmp.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsIcmp.c
    
Abstract:

    IpSec NAT shim ICMP management

Author:

    Jonathan Burstein (jonburs) 11-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global Variables
//

LIST_ENTRY NsIcmpList;
KSPIN_LOCK NsIcmpLock;
NPAGED_LOOKASIDE_LIST NsIcmpLookasideList;

//
// Function Prototypes
//

NTSTATUS
NspCreateIcmpEntry(
    ULONG64 ul64AddressKey,
    USHORT usOriginalIdentifier,
    PVOID pvIpSecContext,
    BOOLEAN fIdConflicts,
    PLIST_ENTRY pInsertionPoint,
    PNS_ICMP_ENTRY *ppNewEntry
    );

NTSTATUS
FASTCALL
NspHandleInboundIcmpError(
    PNS_PACKET_CONTEXT pContext,
    PVOID pvIpSecContext
    );

NTSTATUS
FASTCALL
NspHandleOutboundIcmpError(
    PNS_PACKET_CONTEXT pContext,
    PVOID *ppvIpSecContext
    );

PNS_ICMP_ENTRY
NspLookupInboundIcmpEntry(
    ULONG64 ul64AddressKey,
    USHORT usOriginalIdentifier,
    PVOID pvIpSecContext,
    BOOLEAN *pfIdentifierConflicts,
    PLIST_ENTRY *ppInsertionPoint
    );

PNS_ICMP_ENTRY
NspLookupOutboundIcmpEntry(
    ULONG64 ul64AddressKey,
    USHORT usTranslatedIdentifier
    );


NTSTATUS
NsInitializeIcmpManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the ICMP management module.

Arguments:

    none.

Return Value:

    NTSTATUS.

--*/

{
    CALLTRACE(("NsInitializeIcmpManagement\n"));
    
    InitializeListHead(&NsIcmpList);
    KeInitializeSpinLock(&NsIcmpLock);
    ExInitializeNPagedLookasideList(
        &NsIcmpLookasideList,
        NULL,
        NULL,
        0,
        sizeof(NS_ICMP_ENTRY),
        NS_TAG_ICMP,
        NS_ICMP_LOOKASIDE_DEPTH
        );
    
    return STATUS_SUCCESS;
} // NsInitializeIcmpManagement

NTSTATUS
FASTCALL
NspHandleInboundIcmpError(
    PNS_PACKET_CONTEXT pContext,
    PVOID pvIpSecContext
    )

/*++

Routine Description:

    This routine is called to process inbound ICMP error messages. Based
    on the protocol of the embedded packet it will attempt to find a
    matching connection entry (for TCP, UDP, or ICMP) and perform any
    necessary translations.
    
Arguments:

    pContext - the context information for the packet.

    pvIpSecContext - the IpSec context for this packet; this is considered
        an opaque value.

Return Value:

    NTSTATUS.

--*/

{
    KIRQL Irql;
    PNS_CONNECTION_ENTRY pEntry;
    PNS_ICMP_ENTRY pIcmpEntry;
    ICMP_HEADER UNALIGNED *pIcmpHeader;
    UCHAR ucProtocol;
    ULONG64 ul64AddressKey;
    ULONG ulChecksum;
    ULONG ulChecksumDelta;
    ULONG ulChecksumDelta2;
    ULONG ulPortKey;

    ASSERT(NULL != pContext);

    //
    // Make sure that the buffer is large enough to contain the
    // encapsulated packet.
    //

    if (pContext->ulProtocolHeaderLength < sizeof(ICMP_HEADER))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the embedded header is not TCP, UDP, or ICMP exit quickly,
    // as we have nothing to do.
    //

    pIcmpHeader = pContext->pIcmpHeader;
    ucProtocol = pIcmpHeader->EncapsulatedIpHeader.Protocol;
    if (NS_PROTOCOL_TCP != ucProtocol
        && NS_PROTOCOL_UDP != ucProtocol
        && NS_PROTOCOL_ICMP != ucProtocol
        )
    {
        return STATUS_SUCCESS;
    }

    //
    // See if the embedded packet belongs to a known conection. Notice that
    // the order of the addresses here -- since the embedded packet is one
    // that we sent, the source address is local and the destination address
    // is remote.
    //

    MAKE_ADDRESS_KEY(
        ul64AddressKey,
        pIcmpHeader->EncapsulatedIpHeader.SourceAddress,
        pIcmpHeader->EncapsulatedIpHeader.DestinationAddress
        );

    if (NS_PROTOCOL_ICMP == ucProtocol)
    {
        KeAcquireSpinLock(&NsIcmpLock, &Irql);

        pIcmpEntry =
            NspLookupInboundIcmpEntry(
                ul64AddressKey,
                pIcmpHeader->EncapsulatedIcmpHeader.Identifier,
                pvIpSecContext,
                NULL,
                NULL
                );

        if (NULL != pIcmpEntry)
        {
            KeQueryTickCount((PLARGE_INTEGER)&pIcmpEntry->l64LastAccessTime);
            
            if (pIcmpEntry->usTranslatedId != pIcmpEntry->usOriginalId)
            {
                //
                // We found an ICMP entry for the embedded packet that
                // has a translated ID. This means that we need to:
                //
                // 1) Change the ID in the embedded packet.
                // 2) Update the ICMP checksum of the embedded packet.
                // 3) Update the ICMP checksum of the original packet, based
                //    on the previous changes.
                //

                pIcmpHeader->EncapsulatedIcmpHeader.Identifier =
                    pIcmpEntry->usTranslatedId;

                ulChecksumDelta = 0;
                CHECKSUM_LONG(ulChecksumDelta, ~pIcmpEntry->usOriginalId);
                CHECKSUM_LONG(ulChecksumDelta, pIcmpEntry->usTranslatedId);

                ulChecksumDelta2 = ulChecksumDelta;
                CHECKSUM_LONG(
                    ulChecksumDelta2,
                    ~pIcmpHeader->EncapsulatedIcmpHeader.Checksum
                    );
                CHECKSUM_UPDATE(pIcmpHeader->EncapsulatedIcmpHeader.Checksum);
                CHECKSUM_LONG(
                    ulChecksumDelta2,
                    pIcmpHeader->EncapsulatedIcmpHeader.Checksum
                    );
                ulChecksumDelta = ulChecksumDelta2;
                CHECKSUM_UPDATE(pIcmpHeader->Checksum);
            }
        }

        KeReleaseSpinLock(&NsIcmpLock, Irql);
    }
    else
    {
        MAKE_PORT_KEY(
            ulPortKey,
            pIcmpHeader->EncapsulatedUdpHeader.SourcePort,
            pIcmpHeader->EncapsulatedUdpHeader.DestinationPort
            );

        KeAcquireSpinLock(&NsConnectionLock, &Irql);

        pEntry =
            NsLookupInboundConnectionEntry(
                ul64AddressKey,
                ulPortKey,
                ucProtocol,
                pvIpSecContext,
                NULL,
                NULL
                );

        if (NULL != pEntry
            && pEntry->ulPortKey[NsInboundDirection]
                != pEntry->ulPortKey[NsOutboundDirection])
        {
            //
            // We found a connection entry that contains a translated
            // port. This means we need to:
            //
            // 1) Change the remote (destination) port in the
            //    embedded packet.
            // 2) Update the checksum of the embedded packet, if it's
            //    UDP. (An embedded TCP packet is not long enough to
            //    contain the checksum.)
            // 3) Update the ICMP checksum of the original packet, based
            //    on the previous changes.
            //

            pIcmpHeader->EncapsulatedUdpHeader.DestinationPort =
                CONNECTION_REMOTE_PORT(pEntry->ulPortKey[NsOutboundDirection]);

            ulChecksumDelta = 0;
            CHECKSUM_LONG(
                ulChecksumDelta,
                ~CONNECTION_REMOTE_PORT(pEntry->ulPortKey[NsInboundDirection])
                );
            CHECKSUM_LONG(
                ulChecksumDelta,
                CONNECTION_REMOTE_PORT(pEntry->ulPortKey[NsOutboundDirection])
                );

            if (NS_PROTOCOL_UDP == ucProtocol)
            {
                ulChecksumDelta2 = ulChecksumDelta;
                CHECKSUM_LONG(
                    ulChecksumDelta2,
                    ~pIcmpHeader->EncapsulatedUdpHeader.Checksum
                    );
                CHECKSUM_UPDATE(pIcmpHeader->EncapsulatedUdpHeader.Checksum);
                CHECKSUM_LONG(
                    ulChecksumDelta2,
                    pIcmpHeader->EncapsulatedUdpHeader.Checksum
                    );
                ulChecksumDelta = ulChecksumDelta2;
            }

            CHECKSUM_UPDATE(pIcmpHeader->Checksum);
        }

        KeReleaseSpinLock(&NsConnectionLock, Irql);
    }
    
    return STATUS_SUCCESS;
} // NspHandleInboundIcmpError

NTSTATUS
FASTCALL
NspHandleOutboundIcmpError(
    PNS_PACKET_CONTEXT pContext,
    PVOID *ppvIpSecContext
    )

/*++

Routine Description:

    This routine is called to process outbound ICMP error messages. Based
    on the protocol of the embedded packet it will attempt to find a
    matching connection entry (for TCP, UDP, or ICMP), obtain the IpSec
    context for the embedded packet, and perform any necessary translations.
    
Arguments:

    pContext - the context information for the packet.

    ppvIpSecContext - receives the IpSec context for this packet, if any;
        receives NULL if no context exists.

Return Value:

    NTSTATUS.

--*/

{
    KIRQL Irql;
    PNS_CONNECTION_ENTRY pEntry;
    PNS_ICMP_ENTRY pIcmpEntry;
    ICMP_HEADER UNALIGNED *pIcmpHeader;
    UCHAR ucProtocol;
    ULONG64 ul64AddressKey;
    ULONG ulChecksum;
    ULONG ulChecksumDelta;
    ULONG ulChecksumDelta2;
    ULONG ulPortKey;

    ASSERT(NULL != pContext);
    ASSERT(NULL != ppvIpSecContext);

    //
    // Make sure that the buffer is large enough to contain the
    // encapsulated packet.
    //

    if (pContext->ulProtocolHeaderLength < sizeof(ICMP_HEADER))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the embedded header is not TCP, UDP, or ICMP exit quickly,
    // as we have nothing to do.
    //

    pIcmpHeader = pContext->pIcmpHeader;
    ucProtocol = pIcmpHeader->EncapsulatedIpHeader.Protocol;
    if (NS_PROTOCOL_TCP != ucProtocol
        && NS_PROTOCOL_UDP != ucProtocol
        && NS_PROTOCOL_ICMP != ucProtocol
        )
    {
        return STATUS_SUCCESS;
    }

    //
    // See if the embedded packet belongs to a known conection. Notice that
    // the order of the addresses here -- since the embedded packet is one
    // that we received, the source address is remote and the destination
    // address is local.
    //

    MAKE_ADDRESS_KEY(
        ul64AddressKey,
        pIcmpHeader->EncapsulatedIpHeader.DestinationAddress,
        pIcmpHeader->EncapsulatedIpHeader.SourceAddress
        );

    if (NS_PROTOCOL_ICMP == ucProtocol)
    {
        KeAcquireSpinLock(&NsIcmpLock, &Irql);

        pIcmpEntry =
            NspLookupOutboundIcmpEntry(
                ul64AddressKey,
                pIcmpHeader->EncapsulatedIcmpHeader.Identifier
                );

        if (NULL != pIcmpEntry)
        {
            *ppvIpSecContext = pIcmpEntry->pvIpSecContext;
            KeQueryTickCount((PLARGE_INTEGER)&pIcmpEntry->l64LastAccessTime);
            
            if (pIcmpEntry->usTranslatedId != pIcmpEntry->usOriginalId)
            {
                //
                // We found an ICMP entry for the embedded packet that
                // has a translated ID. This means that we need to:
                //
                // 1) Change the ID in the embedded packet.
                // 2) Update the ICMP checksum of the embedded packet.
                // 3) Update the ICMP checksum of the original packet, based
                //    on the previous changes.
                //

                pIcmpHeader->EncapsulatedIcmpHeader.Identifier =
                    pIcmpEntry->usOriginalId;

                ulChecksumDelta = 0;
                CHECKSUM_LONG(ulChecksumDelta, ~pIcmpEntry->usTranslatedId);
                CHECKSUM_LONG(ulChecksumDelta, pIcmpEntry->usOriginalId);

                ulChecksumDelta2 = ulChecksumDelta;
                CHECKSUM_LONG(
                    ulChecksumDelta2,
                    ~pIcmpHeader->EncapsulatedIcmpHeader.Checksum
                    );
                CHECKSUM_UPDATE(pIcmpHeader->EncapsulatedIcmpHeader.Checksum);
                CHECKSUM_LONG(
                    ulChecksumDelta2,
                    pIcmpHeader->EncapsulatedIcmpHeader.Checksum
                    );
                ulChecksumDelta = ulChecksumDelta2;
                CHECKSUM_UPDATE(pIcmpHeader->Checksum);
            }
        }

        KeReleaseSpinLock(&NsIcmpLock, Irql);
    }
    else
    {
        MAKE_PORT_KEY(
            ulPortKey,
            pIcmpHeader->EncapsulatedUdpHeader.DestinationPort,
            pIcmpHeader->EncapsulatedUdpHeader.SourcePort
            );

        KeAcquireSpinLock(&NsConnectionLock, &Irql);

        pEntry =
            NsLookupOutboundConnectionEntry(
                ul64AddressKey,
                ulPortKey,
                ucProtocol,
                NULL
                );

        if (NULL != pEntry)
        {
            *ppvIpSecContext = pEntry->pvIpSecContext;
            
            if (pEntry->ulPortKey[NsInboundDirection]
                != pEntry->ulPortKey[NsOutboundDirection])
            {
                //
                // We found a connection entry that contains a translated
                // port. This means we need to:
                //
                // 1) Change the remote (source) port in the
                //    embedded packet.
                // 2) Update the checksum of the embedded packet, if it's
                //    UDP. (An embedded TCP packet is not long enough to
                //    contain the checksum.)
                // 3) Update the ICMP checksum of the original packet, based
                //    on the previous changes.
                //

                pIcmpHeader->EncapsulatedUdpHeader.SourcePort =
                    CONNECTION_REMOTE_PORT(pEntry->ulPortKey[NsInboundDirection]);

                ulChecksumDelta = 0;
                CHECKSUM_LONG(
                    ulChecksumDelta,
                    ~CONNECTION_REMOTE_PORT(pEntry->ulPortKey[NsOutboundDirection])
                    );
                CHECKSUM_LONG(
                    ulChecksumDelta,
                    CONNECTION_REMOTE_PORT(pEntry->ulPortKey[NsInboundDirection])
                    );

                if (NS_PROTOCOL_UDP == ucProtocol)
                {
                    ulChecksumDelta2 = ulChecksumDelta;
                    CHECKSUM_LONG(
                        ulChecksumDelta2,
                        ~pIcmpHeader->EncapsulatedUdpHeader.Checksum
                        );
                    CHECKSUM_UPDATE(pIcmpHeader->EncapsulatedUdpHeader.Checksum);
                    CHECKSUM_LONG(
                        ulChecksumDelta2,
                        pIcmpHeader->EncapsulatedUdpHeader.Checksum
                        );
                    ulChecksumDelta = ulChecksumDelta2;
                }

                CHECKSUM_UPDATE(pIcmpHeader->Checksum);
            }
        }

        KeReleaseSpinLock(&NsConnectionLock, Irql);
    }
    
    return STATUS_SUCCESS;
} // NspHandleOutboundIcmpError



NTSTATUS
NspCreateIcmpEntry(
    ULONG64 ul64AddressKey,
    USHORT usOriginalIdentifier,
    PVOID pvIpSecContext,
    BOOLEAN fIdConflicts,
    PLIST_ENTRY pInsertionPoint,
    PNS_ICMP_ENTRY *ppNewEntry
    )

/*++

Routine Description:

    Creates an ICMP entry (for request / response message types). If
    necessary this routine will allocate a new identifier.

Arguments:

    ul64AddressKey - the addressing information for the entry

    usOriginalIdentifier - the original ICMP identifier for the entry

    pvIpSecContext - the IpSec context for the entry

    fIdConflicts - TRUE if the original identifier is known to conflict
        with an existing entry on the inbound path

    pInsertionPoint - the insertion point for the new entry

    ppNewEntry - receives the newly created entry on success

Return Value:

    NTSTATUS

Environment:

    Invoked with 'NsIcmpLock' held by the caller.

--*/

{
    PNS_ICMP_ENTRY pEntry;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    USHORT usTranslatedId;

    TRACE(ICMP, ("NspCreateIcmpEntry\n"));

    ASSERT(NULL != pInsertionPoint);
    ASSERT(NULL != ppNewEntry);

    //
    // Determine what translated ID should be used for this
    // entry
    //

    if (fIdConflicts)
    {
        usTranslatedId = (USHORT) -1;
    }
    else
    {
        usTranslatedId = usOriginalIdentifier;
    }

    do
    {
        if (NULL == NspLookupOutboundIcmpEntry(ul64AddressKey, usTranslatedId))
        {
            //
            // This identifier does not conflict.
            //

            Status = STATUS_SUCCESS;
            break;
        }

        if (fIdConflicts)
        {
            usTranslatedId -= 1;
        }
        else
        {
            fIdConflicts = TRUE;
            usTranslatedId = (USHORT) -1;    
        }
    }
    while (usTranslatedId > 0);

    if (STATUS_SUCCESS == Status)
    {
        //
        // Allocate and initialize the new entry
        //

        pEntry = ALLOCATE_ICMP_BLOCK();
        if (NULL != pEntry)
        {
            RtlZeroMemory(pEntry, sizeof(*pEntry));
            pEntry->ul64AddressKey = ul64AddressKey;
            pEntry->usOriginalId = usOriginalIdentifier;
            pEntry->usTranslatedId = usTranslatedId;
            pEntry->pvIpSecContext = pvIpSecContext;
            InsertTailList(pInsertionPoint, &pEntry->Link);

            *ppNewEntry = pEntry;
        }
        else
        {
            ERROR(("NspCreateIcmpEntry: Allocation Failed\n"));
            Status = STATUS_NO_MEMORY;
        }
    }
    
    return Status;
} // NspCreateIcmpEntry


PNS_ICMP_ENTRY
NspLookupInboundIcmpEntry(
    ULONG64 ul64AddressKey,
    USHORT usOriginalIdentifier,
    PVOID pvIpSecContext,
    BOOLEAN *pfIdentifierConflicts,
    PLIST_ENTRY *ppInsertionPoint
    )

/*++

Routine Description:

    Called to lookup an inbound ICMP entry.

Arguments:

    ul64AddressKey - the addressing information for the entry

    usOriginalIdentifier - the original ICMP identifier for the entry

    pvIpSecContext - the IpSec context for the entry

    pfIdentifierConflicts - on failure, receives a boolean the indicates why
        the lookup failed: TRUE if the lookup failed because there is
        an identical entry w/ different IpSec context, FALSE
        otherwise. (optional)

    ppInsertionPoint - receives the insertion point if not found (optional)

Return Value:

    PNS_ICMP_ENTRY - a pointer to the connection entry, if found, or
        NULL otherwise.

Environment:

    Invoked with 'NsIcmpLock' held by the caller.

--*/

{
    PNS_ICMP_ENTRY pEntry;
    PLIST_ENTRY pLink;

    if (pfIdentifierConflicts)
    {
        *pfIdentifierConflicts = FALSE;
    }

    for (pLink = NsIcmpList.Flink; pLink != &NsIcmpList; pLink = pLink->Flink)
    {
        pEntry = CONTAINING_RECORD(pLink, NS_ICMP_ENTRY, Link);

        //
        // For inbound entries the search order is:
        // 1) address key
        // 2) original identifier
        // 3) IpSec context
        //

        if (ul64AddressKey > pEntry->ul64AddressKey)
        {
            continue;
        }
        else if (ul64AddressKey < pEntry->ul64AddressKey)
        {
            break;
        }
        else if (usOriginalIdentifier > pEntry->usOriginalId)
        {
            continue;
        }
        else if (usOriginalIdentifier < pEntry->usOriginalId)
        {
            break;
        }
        else if (pvIpSecContext > pEntry->pvIpSecContext)
        {
            //
            // This entry matches everything requested except
            // for the IpSec context. Inform the caller of this
            // fact (if desired).
            //

            if (pfIdentifierConflicts)
            {
                *pfIdentifierConflicts = TRUE;
            }
            continue;
        }
        else if (pvIpSecContext < pEntry->pvIpSecContext)
        {
            //
            // This entry matches everything requested except
            // for the IpSec context. Inform the caller of this
            // fact (if desired).
            //

            if (pfIdentifierConflicts)
            {
                *pfIdentifierConflicts = TRUE;
            }
            break;
        }

        //
        // This is the requested entry.
        //

        return pEntry;        
    }

    //
    // Entry not found -- set insertion point if so requested.
    //

    if (ppInsertionPoint)
    {
        *ppInsertionPoint = pLink;
    }    
    
    return NULL;
} // NspLookupInboundIcmpEntry


PNS_ICMP_ENTRY
NspLookupOutboundIcmpEntry(
    ULONG64 ul64AddressKey,
    USHORT usTranslatedIdentifier
    )

/*++

Routine Description:

    Called to lookup an outbound ICMP entry.

Arguments:

    ul64AddressKey - the addressing information for the entry

    usTranslatedIdentifier - the translated ICMP identifier for the entry

Return Value:

    PNS_ICMP_ENTRY - a pointer to the entry, if found, or NULL otherwise.

Environment:

    Invoked with 'NsIcmpLock' held by the caller.

--*/

{
    PNS_ICMP_ENTRY pEntry;
    PLIST_ENTRY pLink;

    for (pLink = NsIcmpList.Flink; pLink != &NsIcmpList; pLink = pLink->Flink)
    {
        pEntry = CONTAINING_RECORD(pLink, NS_ICMP_ENTRY, Link);

        //
        // When searching for an outbound entry, we can depend on the
        // ordering of address keys. However, we cannot depend on the
        // order of the translated identifiers, so we have to perform
        // an exhaustive search of all entries with the proper
        // address key.
        //

        if (ul64AddressKey > pEntry->ul64AddressKey)
        {
            continue;
        }
        else if (ul64AddressKey < pEntry->ul64AddressKey)
        {
            break;
        }
        else if (usTranslatedIdentifier == pEntry->usTranslatedId)
        {
            //
            // This is the requested entry.
            //

            return pEntry;
        }
    }

    //
    // Entry not found.
    //
    
    return NULL;
} // NspLookupOutboundIcmpEntry


NTSTATUS
FASTCALL    
NsProcessIncomingIcmpPacket(
    PNS_PACKET_CONTEXT pContext,
    PVOID pvIpSecContext
    )

/*++

Routine Description:

    This routine is invoked by IpSec for each incoming ICMP packet.
    
Arguments:

    pContext - the context information for the packet.

    pvIpSecContext - the IpSec context for this packet; this is considered
        an opaque value.

Return Value:

    NTSTATUS.

--*/

{
    BOOLEAN fIdConflicts;
    KIRQL Irql;
    PNS_ICMP_ENTRY pIcmpEntry;
    PLIST_ENTRY pInsertionPoint;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG64 ul64AddressKey;
    ULONG ulChecksum;
    ULONG ulChecksumDelta;
    
    ASSERT(NULL != pContext);
    
    TRACE(
        ICMP,
        ("NsProcessIncomingIcmpPacket: %d.%d.%d.%d -> %d.%d.%d.%d : %d, %d : %d\n",
            ADDRESS_BYTES(pContext->ulSourceAddress),
            ADDRESS_BYTES(pContext->ulDestinationAddress),
            pContext->pIcmpHeader->Type,
            pContext->pIcmpHeader->Code,
            pvIpSecContext
            ));

    //
    // Branch to proper behavior based on ICMP Type
    //

    switch (pContext->pIcmpHeader->Type)
    {
        case ICMP_ROUTER_REPLY:
        case ICMP_MASK_REPLY:    
        case ICMP_ECHO_REPLY:
        case ICMP_TIMESTAMP_REPLY:
        {
            //
            // No action is needed for inbound replies.
            //
            
            break;
        }

        case ICMP_ROUTER_REQUEST:
        case ICMP_MASK_REQUEST:
        case ICMP_ECHO_REQUEST:
        case ICMP_TIMESTAMP_REQUEST:
        {
            //
            // See if we have an ICMP entry that matches this packet.
            //

            MAKE_ADDRESS_KEY(
                ul64AddressKey,
                pContext->ulDestinationAddress,
                pContext->ulSourceAddress
                );

            KeAcquireSpinLock(&NsIcmpLock, &Irql);

            pIcmpEntry =
                NspLookupInboundIcmpEntry(
                    ul64AddressKey,
                    pContext->pIcmpHeader->Identifier,
                    pvIpSecContext,
                    &fIdConflicts,
                    &pInsertionPoint
                    );

            if (NULL == pIcmpEntry)
            {
                //
                // No entry was found; attempt to create a new
                // one. (The creation function will allocate
                // a new ID, if necessary.)
                //
                
                Status =
                    NspCreateIcmpEntry(
                        ul64AddressKey,
                        pContext->pIcmpHeader->Identifier,
                        pvIpSecContext,
                        fIdConflicts,
                        pInsertionPoint,
                        &pIcmpEntry
                        );
            }

            if (STATUS_SUCCESS == Status)
            {
                ASSERT(NULL != pIcmpEntry);
                KeQueryTickCount((PLARGE_INTEGER)&pIcmpEntry->l64LastAccessTime);
                
                if (pIcmpEntry->usTranslatedId != pIcmpEntry->usOriginalId)
                {
                    //
                    // Need to translate the ICMP ID for this packet, and
                    // adjust the checksum accordingly.
                    //

                    pContext->pIcmpHeader->Identifier =
                        pIcmpEntry->usTranslatedId;

                    ulChecksumDelta = 0;
                    CHECKSUM_LONG(ulChecksumDelta, ~pIcmpEntry->usOriginalId);
                    CHECKSUM_LONG(ulChecksumDelta, pIcmpEntry->usTranslatedId);
                    CHECKSUM_UPDATE(pContext->pIcmpHeader->Checksum);
                }
            }

            KeReleaseSpinLock(&NsIcmpLock, Irql);
            
            break;
        }

        case ICMP_TIME_EXCEED:
        case ICMP_PARAM_PROBLEM:
        case ICMP_DEST_UNREACH:
        case ICMP_SOURCE_QUENCH:
        {
            Status = NspHandleInboundIcmpError(pContext, pvIpSecContext);
            break;
        }

        default:
        {
            break;
        }
    }

    
    return Status;
} // NsProcessIncomingIcmpPacket


NTSTATUS
FASTCALL    
NsProcessOutgoingIcmpPacket(
    PNS_PACKET_CONTEXT pContext,
    PVOID *ppvIpSecContext
    )

/*++

Routine Description:

    This routine is invoked by IpSec for each outgoing ICMP packet.
    
Arguments:

    pContext - the context information for the packet.

    ppvIpSecContext - receives the IpSec context for this packet, if any;
        receives NULL if no context exists.

Return Value:

    NTSTATUS.

--*/

{
    KIRQL Irql;
    PNS_ICMP_ENTRY pIcmpEntry;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG64 ul64AddressKey;
    ULONG ulChecksum;
    ULONG ulChecksumDelta;
    
    ASSERT(NULL != pContext);
    ASSERT(NULL != ppvIpSecContext);
    
    TRACE(
        ICMP,
        ("NsProcessOutgoingIcmpPacket: %d.%d.%d.%d -> %d.%d.%d.%d : %d, %d\n",
            ADDRESS_BYTES(pContext->ulSourceAddress),
            ADDRESS_BYTES(pContext->ulDestinationAddress),
            pContext->pIcmpHeader->Type,
            pContext->pIcmpHeader->Code
            ));

    //
    // Set context to the default value
    //

    *ppvIpSecContext = NULL;

    //
    // Branch to proper behavior based on ICMP Type
    //

    switch (pContext->pIcmpHeader->Type)
    {
        case ICMP_ROUTER_REPLY:
        case ICMP_MASK_REPLY:    
        case ICMP_ECHO_REPLY:
        case ICMP_TIMESTAMP_REPLY:
        {
            //
            // See if we have an ICMP entry that matches this packet.
            //

            MAKE_ADDRESS_KEY(
                ul64AddressKey,
                pContext->ulSourceAddress,
                pContext->ulDestinationAddress
                );

            KeAcquireSpinLock(&NsIcmpLock, &Irql);

            pIcmpEntry =
                NspLookupOutboundIcmpEntry(
                    ul64AddressKey,
                    pContext->pIcmpHeader->Identifier
                    );

            if (NULL != pIcmpEntry)
            {
                *ppvIpSecContext = pIcmpEntry->pvIpSecContext;
                KeQueryTickCount((PLARGE_INTEGER)&pIcmpEntry->l64LastAccessTime);

                if (pIcmpEntry->usTranslatedId != pIcmpEntry->usOriginalId)
                {
                    //
                    // Need to translate the ICMP ID for this packet, and
                    // adjust the checksum accordingly.
                    //

                    pContext->pIcmpHeader->Identifier =
                        pIcmpEntry->usOriginalId;

                    ulChecksumDelta = 0;
                    CHECKSUM_LONG(ulChecksumDelta, ~pIcmpEntry->usTranslatedId);
                    CHECKSUM_LONG(ulChecksumDelta, pIcmpEntry->usOriginalId);
                    CHECKSUM_UPDATE(pContext->pIcmpHeader->Checksum);
                }
            }

            KeReleaseSpinLock(&NsIcmpLock, Irql);
            
            break;
        }

        case ICMP_ROUTER_REQUEST:
        case ICMP_MASK_REQUEST:
        case ICMP_ECHO_REQUEST:
        case ICMP_TIMESTAMP_REQUEST:
        {
            //
            // No action is needed for outgoing requests.
            //
            
            break;
        }

        case ICMP_TIME_EXCEED:
        case ICMP_PARAM_PROBLEM:
        case ICMP_DEST_UNREACH:
        case ICMP_SOURCE_QUENCH:
        {
            Status = NspHandleOutboundIcmpError(pContext, ppvIpSecContext);
            break;
        }

        default:
        {
            break;
        }
    }
    
    return Status;
} // NsProcessOutgoingIcmpPacket



VOID
NsShutdownIcmpManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the ICMP management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    KIRQL Irql;
    PNS_ICMP_ENTRY pEntry;

    CALLTRACE(("NsShutdownIcmpManagement\n"));

    KeAcquireSpinLock(&NsIcmpLock, &Irql);
    
    while (!IsListEmpty(&NsIcmpList))
    {
        pEntry =
            CONTAINING_RECORD(
                RemoveHeadList(&NsIcmpList),
                NS_ICMP_ENTRY,
                Link
                );

        FREE_ICMP_BLOCK(pEntry);
    }

    KeReleaseSpinLock(&NsIcmpLock, Irql);
    
    ExDeleteNPagedLookasideList(&NsIcmpLookasideList);
} // NsShutdownIcmpManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nsconn.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsConn.c
    
Abstract:

    IpSec NAT shim connection entry management

Author:

    Jonathan Burstein (jonburs) 11-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global Variables
//

CACHE_ENTRY NsConnectionCache[CACHE_SIZE];
ULONG NsConnectionCount;
LIST_ENTRY NsConnectionList;
KSPIN_LOCK NsConnectionLock;
NPAGED_LOOKASIDE_LIST NsConnectionLookasideList;
PNS_CONNECTION_ENTRY NsConnectionTree[NsMaximumDirection];
USHORT NsNextSourcePort;

//
// Function Prototypes
//

PNS_CONNECTION_ENTRY
NspInsertInboundConnectionEntry(
    PNS_CONNECTION_ENTRY pParent,
    PNS_CONNECTION_ENTRY pEntry
    );

PNS_CONNECTION_ENTRY
NspInsertOutboundConnectionEntry(
    PNS_CONNECTION_ENTRY pParent,
    PNS_CONNECTION_ENTRY pEntry
    );


NTSTATUS
NsAllocateSourcePort(
    ULONG64 ul64AddressKey,
    ULONG ulPortKey,
    UCHAR ucProtocol,
    BOOLEAN fPortConflicts,
    PNS_CONNECTION_ENTRY *ppOutboundInsertionPoint,
    PULONG pulTranslatedPortKey
    )

/*++

Routine Description:

    Called to allocate a source port for a connection entry. If the original
    port does not conflict with any existing connection entry it will be used.

Arguments:

    ul64AddressKey - the addressing information for the connection

    ulPortKey - the original port information for the connection

    ucProtocol - the protocol for the connection

    fPortConflicts - if TRUE, indicates that the caller knows that the original
        port information conflicts w/ an existing connection. If FALSE the
        caller does not know whether or not a conflict definately exists.

    ppOutboundInsertionPoint - receives the insertion point for the
        outbound path

    pulTranslatedPortKey - on success, receives the allocated port information.    

Return Value:

    NTSTATUS.

Environment:

    Invoked with NsConnectionLock held by the caller.

--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    ULONG ulOutboundPortKey;
    USHORT usLocalPort;
    USHORT usStopPort;
    
    ASSERT(NULL != ppOutboundInsertionPoint);
    ASSERT(NULL != pulTranslatedPortKey);

    TRACE(
        PORT_ALLOC,
        ("NsAllocateSourcePort: %d: %d.%d.%d.%d/%d -> %d.%d.%d.%d/%d\n",
            ucProtocol,
            ADDRESS_BYTES(CONNECTION_REMOTE_ADDRESS(ul64AddressKey)),
            NTOHS(CONNECTION_REMOTE_PORT(ulPortKey)),
            ADDRESS_BYTES(CONNECTION_LOCAL_ADDRESS(ul64AddressKey)),
            NTOHS(CONNECTION_LOCAL_PORT(ulPortKey))
            ));

    usLocalPort = CONNECTION_LOCAL_PORT(ulPortKey);

    if (FALSE == fPortConflicts)
    {
        //
        // The caller indicates that the remote port does not
        // conflict on the inbound path, so we'll first attempt
        // to use the original port.
        //

        ulOutboundPortKey = ulPortKey;
        usStopPort =
            (NS_SOURCE_PORT_END == NsNextSourcePort
                ? NS_SOURCE_PORT_BASE
                : NsNextSourcePort + 1);
    }
    else
    {
        //
        // The caller indicates that the remote port conflicts
        // on the inbound path, so we'll assume that it also
        // conflicts on the outbound path and start by trying
        // out a new port.
        //
        
        usStopPort = NsNextSourcePort--;
        
        MAKE_PORT_KEY(
            ulOutboundPortKey,
            usLocalPort,
            usStopPort
            );

        if (NsNextSourcePort < NS_SOURCE_PORT_BASE)
        {
            NsNextSourcePort = NS_SOURCE_PORT_END;
        }
    }

    do
    {
        //
        // Check to see if our current candidate conflicts
        // with any connection entries on the outbound path.
        //
        
        if (NULL ==
                NsLookupOutboundConnectionEntry(
                    ul64AddressKey,
                    ulOutboundPortKey,
                    ucProtocol,
                    ppOutboundInsertionPoint
                    ))
        {
            //
            // No conflict was found -- break out of the loop and
            // return this info to the caller.
            //

            TRACE(PORT_ALLOC, ("NsAllocateSourcePort: Assigning %d\n",
                NTOHS(CONNECTION_REMOTE_PORT(ulOutboundPortKey))));

            *pulTranslatedPortKey = ulOutboundPortKey;
            Status = STATUS_SUCCESS;
            break;
        }

        //
        // This candidate conflicted; move on to the next.
        //

        MAKE_PORT_KEY(
            ulOutboundPortKey,
            usLocalPort,
            NsNextSourcePort--
            );

        if (NsNextSourcePort < NS_SOURCE_PORT_BASE)
        {
            NsNextSourcePort = NS_SOURCE_PORT_END;
        }
    }
    while (usStopPort != CONNECTION_REMOTE_PORT(ulOutboundPortKey));

    TRACE(PORT_ALLOC, ("NsAllocateSourcePort: No port available\n"));
    
    return Status;
} // NsAllocateSourcePort


VOID
NsCleanupConnectionEntry(
    PNS_CONNECTION_ENTRY pEntry
    )

/*++

Routine Description:

    Called to perform final cleanup for a connection entry.

Arguments:

    pEntry - the connection entry to be deleted.

Return Value:

    none.

Environment:

    Invoked with the last reference to the connection entry released.

--*/

{
    TRACE(CONN_LIFETIME, ("NsCleanupConnectionEntry\n"));
    ASSERT(NULL != pEntry);
    
    FREE_CONNECTION_BLOCK(pEntry);
} // NsCleanupConnectionEntry


NTSTATUS
NsCreateConnectionEntry(
    ULONG64 ul64AddressKey,
    ULONG ulInboundPortKey,
    ULONG ulOutboundPortKey,
    UCHAR ucProtocol,
    PVOID pvIpSecContext,
    PNS_CONNECTION_ENTRY pInboundInsertionPoint,
    PNS_CONNECTION_ENTRY pOutboundInsertionPoint,
    PNS_CONNECTION_ENTRY *ppNewEntry
    )

/*++

Routine Description:

    Called to create a connection entry. On success, the connection entry
    will have been referenced twice -- the initial reference for the entry
    (which is released in NsDeleteConnectionEntry) and a reference for the
    caller. Thus, the caller must call NsDereferenceConnectionEntry on the
    new entry.

Arguments:

    ul64AddressKey - the addressing information for this entry

    ulInboundPortKey - the inbound (original) ports for this entry

    ulOutboundPortKey - the outbound (translated) ports for this entry

    ucProtocol - the protocol for this entry

    pvIpSecContext - the IpSec context for this entry

    p*InsertionPoint - the inbound and outbound insertion points (normally
        obtained through NsAllocateSourcePort).

    ppEntry - receives a pointer to the newley-created connection entry. The
        caller must call NsDereferenceConnectionEntry on this pointer.

Return Value:

    NTSTATUS - indicates success/failure.

Environment:

    Invoked with 'NsConnectionLock' held by the caller.

--*/

{
    PNS_CONNECTION_ENTRY pEntry;

    TRACE(
        CONN_LIFETIME,
        ("NsCreateConnectionEntry: %d: %d.%d.%d.%d/%d/%d -> %d.%d.%d.%d/%d : %d\n",
            ucProtocol,
            ADDRESS_BYTES(CONNECTION_REMOTE_ADDRESS(ul64AddressKey)),
            NTOHS(CONNECTION_REMOTE_PORT(ulInboundPortKey)),
            NTOHS(CONNECTION_REMOTE_PORT(ulOutboundPortKey)),
            ADDRESS_BYTES(CONNECTION_LOCAL_ADDRESS(ul64AddressKey)),
            NTOHS(CONNECTION_LOCAL_PORT(ulInboundPortKey)),
            pvIpSecContext
            ));

    ASSERT(NULL != ppNewEntry);
    ASSERT(NS_PROTOCOL_TCP == ucProtocol || NS_PROTOCOL_UDP == ucProtocol);

    pEntry = ALLOCATE_CONNECTION_BLOCK();
    if (NULL == pEntry)
    {
        ERROR(("NsCreateConnectionEntry: Unable to allocate entry\n"));
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(pEntry, sizeof(*pEntry));
    KeInitializeSpinLock(&pEntry->Lock);
    pEntry->ulReferenceCount = 1;
    pEntry->ul64AddressKey = ul64AddressKey;
    pEntry->ulPortKey[NsInboundDirection] = ulInboundPortKey;
    pEntry->ulPortKey[NsOutboundDirection] = ulOutboundPortKey;    
    pEntry->ucProtocol = ucProtocol;
    pEntry->pvIpSecContext = pvIpSecContext;
    pEntry->ulAccessCount[NsInboundDirection] = NS_CONNECTION_RESPLAY_THRESHOLD;
    pEntry->ulAccessCount[NsOutboundDirection] = NS_CONNECTION_RESPLAY_THRESHOLD;
    InitializeListHead(&pEntry->Link);
    RtlInitializeSplayLinks(&pEntry->SLink[NsInboundDirection]);
    RtlInitializeSplayLinks(&pEntry->SLink[NsOutboundDirection]);

    //
    // Incremeent the reference count on the connection; the caller
    // is required to do a dereference.
    //

    pEntry->ulReferenceCount += 1;

    //
    // Setup checksum deltas (if necessary) and per-packet routines
    //

    if (ulInboundPortKey != ulOutboundPortKey)
    {
        //
        // This connection entry is translating the remote port, so 
        // precompute the checksum deltas (see RFC 1624).
        //

        pEntry->ulProtocolChecksumDelta[NsInboundDirection] =
            (USHORT)~CONNECTION_REMOTE_PORT(ulInboundPortKey)
            + (USHORT)CONNECTION_REMOTE_PORT(ulOutboundPortKey);

        pEntry->ulProtocolChecksumDelta[NsOutboundDirection] =
            (USHORT)~CONNECTION_REMOTE_PORT(ulOutboundPortKey)
            + (USHORT)CONNECTION_REMOTE_PORT(ulInboundPortKey);

        if (NS_PROTOCOL_TCP == ucProtocol)
        {
            pEntry->PacketRoutine[NsInboundDirection] =
                NsInboundTcpTranslatePortPacketRoutine;
            pEntry->PacketRoutine[NsOutboundDirection] =
                NsOutboundTcpTranslatePortPacketRoutine;
        }
        else
        {
            pEntry->PacketRoutine[NsInboundDirection] =
                NsInboundUdpTranslatePortPacketRoutine;
            pEntry->PacketRoutine[NsOutboundDirection] =
                NsOutboundUdpTranslatePortPacketRoutine;
        }
    }
    else if (NS_PROTOCOL_TCP == ucProtocol)
    {
        pEntry->PacketRoutine[NsInboundDirection] = NsInboundTcpPacketRoutine;
        pEntry->PacketRoutine[NsOutboundDirection] = NsOutboundTcpPacketRoutine;
    }
    else
    {
        pEntry->PacketRoutine[NsInboundDirection] = NsInboundUdpPacketRoutine;
        pEntry->PacketRoutine[NsOutboundDirection] = NsOutboundUdpPacketRoutine;
    }

    NsConnectionTree[NsInboundDirection] =
        NspInsertInboundConnectionEntry(pInboundInsertionPoint, pEntry);

    NsConnectionTree[NsOutboundDirection] =
        NspInsertOutboundConnectionEntry(pOutboundInsertionPoint, pEntry);

    InsertTailList(&NsConnectionList, &pEntry->Link);
    InterlockedIncrement(&NsConnectionCount);
    
    *ppNewEntry = pEntry;

    return STATUS_SUCCESS;    
} // NsCreateConnectionEntry


NTSTATUS
NsDeleteConnectionEntry(
    PNS_CONNECTION_ENTRY pEntry
    )

/*++

Routine Description:

    Called to delete a connection entry. The initial reference to the entry
    is released, so that cleanup occurs whenever the last reference is released.

Arguments:

    pEntry - the connection entry to be deleted.

Return Value:

    NTSTATUS - indicates success/failure.

Environment:

    Invoked with 'NsConnectionLock' held by the caller.

--*/

{
    PRTL_SPLAY_LINKS SLink;

    TRACE(CONN_LIFETIME, ("NsDeleteConnectionEntry\n"));

    ASSERT(NULL != pEntry);

    if (NS_CONNECTION_DELETED(pEntry))
    {
        return STATUS_PENDING;
    }

    //
    // Mark the entry as deleted so attempts to reference it
    // will fail from now on.
    //

    pEntry->ulFlags |= NS_CONNECTION_FLAG_DELETED;

    //
    // Take the entry off the list and splay-trees
    //

    InterlockedDecrement(&NsConnectionCount);
    RemoveEntryList(&pEntry->Link);

    SLink = RtlDelete(&pEntry->SLink[NsInboundDirection]);
    NsConnectionTree[NsInboundDirection] =
        (SLink
            ? CONTAINING_RECORD(SLink,NS_CONNECTION_ENTRY,SLink[NsInboundDirection])
            : NULL);

    SLink = RtlDelete(&pEntry->SLink[NsOutboundDirection]);
    NsConnectionTree[NsOutboundDirection] =
        (SLink
            ? CONTAINING_RECORD(SLink,NS_CONNECTION_ENTRY,SLink[NsOutboundDirection])
            : NULL);

    //
    // Clear the entry from the connection cache
    //

    ClearCache(
        NsConnectionCache,
        (ULONG)pEntry->ul64AddressKey
        );
    
    if (0 != InterlockedDecrement(&pEntry->ulReferenceCount)) {

        //
        // The entry is in use, defer final cleanup
        //

        return STATUS_PENDING;
    }

    //
    // Go ahead with final cleanup
    //

    NsCleanupConnectionEntry(pEntry);

    return STATUS_SUCCESS;
} // NsDeleteConnectionEntry


NTSTATUS
NsInitializeConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the connection management module.

Arguments:

    none.

Return Value:

    NTSTATUS.

--*/

{
    CALLTRACE(("NsInitializeConnectionManagement\n"));
    
    InitializeCache(NsConnectionCache);
    NsConnectionCount = 0;
    InitializeListHead(&NsConnectionList);
    KeInitializeSpinLock(&NsConnectionLock);
    ExInitializeNPagedLookasideList(
        &NsConnectionLookasideList,
        NULL,
        NULL,
        0,
        sizeof(NS_CONNECTION_ENTRY),
        NS_TAG_CONNECTION,
        NS_CONNECTION_LOOKASIDE_DEPTH
        );
    NsConnectionTree[NsInboundDirection] = NULL;
    NsConnectionTree[NsOutboundDirection] = NULL;
    NsNextSourcePort = NS_SOURCE_PORT_END;
    
    return STATUS_SUCCESS;
} // NsInitializeConnectionManagement


PNS_CONNECTION_ENTRY
NsLookupInboundConnectionEntry(
    ULONG64 ul64AddressKey,
    ULONG ulPortKey,
    UCHAR ucProtocol,
    PVOID pvIpSecContext,
    BOOLEAN *pfPortConflicts OPTIONAL,
    PNS_CONNECTION_ENTRY *ppInsertionPoint OPTIONAL
    )

/*++

Routine Description:

    Called to lookup an inbound connection entry.

Arguments:

    ul64AddressKey - the addressing information for the connection

    ulPortKey - the port information for the connection

    ucProtocol - the protocol for the connection

    pvIpSecContext - the IpSec context for the connection

    pfPortConflicts - on failure, receives a boolean the indicates why
        the lookup failed: TRUE if the lookup failed because there is
        an identical connection entry w/ different IpSec context, FALSE
        otherwise.

    ppInsertionPoint - receives the insertion point if not found

Return Value:

    PNS_CONNECTION_ENTRY - a pointer to the connection entry, if found, or
        NULL otherwise.

Environment:

    Invoked with NsConnectionLock held by the caller.

--*/

{
    PNS_CONNECTION_ENTRY pRoot;
    PNS_CONNECTION_ENTRY pEntry;
    PNS_CONNECTION_ENTRY pParent = NULL;
    PRTL_SPLAY_LINKS SLink;

    TRACE(
        CONN_LOOKUP,
        ("NsLookupInboundConnectionEntry: %d: %d.%d.%d.%d/%d -> %d.%d.%d.%d/%d : %d\n",
            ucProtocol,
            ADDRESS_BYTES(CONNECTION_REMOTE_ADDRESS(ul64AddressKey)),
            NTOHS(CONNECTION_REMOTE_PORT(ulPortKey)),
            ADDRESS_BYTES(CONNECTION_LOCAL_ADDRESS(ul64AddressKey)),
            NTOHS(CONNECTION_LOCAL_PORT(ulPortKey)),
            pvIpSecContext
            ));
            
    //
    // First look in the cache
    //

    pEntry = (PNS_CONNECTION_ENTRY)
        ProbeCache(
            NsConnectionCache,
            (ULONG)ul64AddressKey
            );

    if (NULL != pEntry
        && pEntry->ul64AddressKey == ul64AddressKey
        && pEntry->ucProtocol == ucProtocol
        && pEntry->ulPortKey[NsInboundDirection] == ulPortKey
        && pEntry->pvIpSecContext == pvIpSecContext)
    {
        TRACE(CONN_LOOKUP, ("NsLookupInboundConnectionEntry: Cache Hit\n"));
        return pEntry;
    }

    if (pfPortConflicts)
    {
        *pfPortConflicts = FALSE;
    }

    //
    // Search the full tree.  Keys are checked in the
    // following order:
    //
    // 1. Address Key
    // 2. Protocol
    // 3. Inbound port key
    // 4. IpSec context
    //

    pRoot = NsConnectionTree[NsInboundDirection];
    for (SLink = (pRoot ? &pRoot->SLink[NsInboundDirection] : NULL ); SLink; )
    {
        pEntry =
            CONTAINING_RECORD(SLink, NS_CONNECTION_ENTRY, SLink[NsInboundDirection]);

        if (ul64AddressKey < pEntry->ul64AddressKey)
        {
            pParent = pEntry;
            SLink = RtlLeftChild(SLink);
            continue;
        }
        else if (ul64AddressKey > pEntry->ul64AddressKey)
        {
            pParent = pEntry;
            SLink = RtlRightChild(SLink);
            continue;
        }
        else if (ucProtocol < pEntry->ucProtocol)
        {
            pParent = pEntry;
            SLink = RtlLeftChild(SLink);
            continue;
        }
        else if (ucProtocol > pEntry->ucProtocol)
        {
            pParent = pEntry;
            SLink = RtlRightChild(SLink);
            continue;
        }
        else if (ulPortKey < pEntry->ulPortKey[NsInboundDirection])
        {
            pParent = pEntry;
            SLink = RtlLeftChild(SLink);
            continue;
        }
        else if (ulPortKey > pEntry->ulPortKey[NsInboundDirection])
        {
            pParent = pEntry;
            SLink = RtlRightChild(SLink);
            continue;
        }
        else if (pvIpSecContext < pEntry->pvIpSecContext)
        {
            //
            // Everything matched w/ the exception of the IpSec
            // context -- we have a port conflict.
            //

            if (pfPortConflicts)
            {
                *pfPortConflicts = TRUE;
            }

            pParent = pEntry;
            SLink = RtlLeftChild(SLink);
            continue;
        }
        else if (pvIpSecContext > pEntry->pvIpSecContext)
        {
            //
            // Everything matched w/ the exception of the IpSec
            // context -- we have a port conflict.
            //

            if (pfPortConflicts)
            {
                *pfPortConflicts = TRUE;
            }

            pParent = pEntry;
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // We found the entry -- update cache and return
        //

        UpdateCache(
            NsConnectionCache,
            (ULONG)ul64AddressKey,
            (PVOID)pEntry
            );

        return pEntry;
    }

    //
    // Not found -- provide insertion point if requested
    //

    if (ppInsertionPoint)
    {
        *ppInsertionPoint = pParent;
    }

    return NULL;
} // NsLookupInboundConnectionEntry


PNS_CONNECTION_ENTRY
NsLookupOutboundConnectionEntry(
    ULONG64 ul64AddressKey,
    ULONG ulPortKey,
    UCHAR ucProtocol,
    PNS_CONNECTION_ENTRY *ppInsertionPoint OPTIONAL
    )

/*++

Routine Description:

    Called to lookup an outbound connection entry.

Arguments:

    ul64AddressKey - the addressing information for the connection

    ulPortKey - the port information for the connection

    ucProtocol - the protocol for the connection

    ppInsertionPoint - receives the insertion point if not found

Return Value:

    PNS_CONNECTION_ENTRY - a pointer to the connection entry, if found, or
        NULL otherwise.

Environment:

    Invoked with NsConnectionLock held by the caller.

--*/

{
    PNS_CONNECTION_ENTRY pRoot;
    PNS_CONNECTION_ENTRY pEntry;
    PNS_CONNECTION_ENTRY pParent = NULL;
    PRTL_SPLAY_LINKS SLink;

    TRACE(
        CONN_LOOKUP,
        ("NsLookupOutboundConnectionEntry: %d: %d.%d.%d.%d/%d -> %d.%d.%d.%d/%d\n",
            ucProtocol,
            ADDRESS_BYTES(CONNECTION_LOCAL_ADDRESS(ul64AddressKey)),
            NTOHS(CONNECTION_LOCAL_PORT(ulPortKey)),
            ADDRESS_BYTES(CONNECTION_REMOTE_ADDRESS(ul64AddressKey)),
            NTOHS(CONNECTION_REMOTE_PORT(ulPortKey))
            ));

    //
    // First look in the cache
    //

    pEntry = (PNS_CONNECTION_ENTRY)
        ProbeCache(
            NsConnectionCache,
            (ULONG)ul64AddressKey
            );

    if (NULL != pEntry
        && pEntry->ul64AddressKey == ul64AddressKey
        && pEntry->ucProtocol == ucProtocol
        && pEntry->ulPortKey[NsOutboundDirection] == ulPortKey)
    {
        TRACE(CONN_LOOKUP, ("NsLookupOutboundConnectionEntry: Cache Hit\n"));
        return pEntry;
    }

    //
    // Search the full tree.  Keys are checked in the
    // following order:
    //
    // 1. Address Key
    // 2. Protocol
    // 3. Outbound port key
    //

    pRoot = NsConnectionTree[NsOutboundDirection];
    for (SLink = (pRoot ? &pRoot->SLink[NsOutboundDirection] : NULL ); SLink; )
    {
        pEntry =
            CONTAINING_RECORD(SLink, NS_CONNECTION_ENTRY, SLink[NsOutboundDirection]);

        if (ul64AddressKey < pEntry->ul64AddressKey)
        {
            pParent = pEntry;
            SLink = RtlLeftChild(SLink);
            continue;
        }
        else if (ul64AddressKey > pEntry->ul64AddressKey)
        {
            pParent = pEntry;
            SLink = RtlRightChild(SLink);
            continue;
        }
        else if (ucProtocol < pEntry->ucProtocol)
        {
            pParent = pEntry;
            SLink = RtlLeftChild(SLink);
            continue;
        }
        else if (ucProtocol > pEntry->ucProtocol)
        {
            pParent = pEntry;
            SLink = RtlRightChild(SLink);
            continue;
        }
        else if (ulPortKey < pEntry->ulPortKey[NsOutboundDirection])
        {
            pParent = pEntry;
            SLink = RtlLeftChild(SLink);
            continue;
        }
        else if (ulPortKey > pEntry->ulPortKey[NsOutboundDirection])
        {
            pParent = pEntry;
            SLink = RtlRightChild(SLink);
            continue;
        }

        //
        // We found the entry -- update cache and return
        //

        UpdateCache(
            NsConnectionCache,
            (ULONG)ul64AddressKey,
            (PVOID)pEntry
            );

        return pEntry;
    }

    //
    // Not found -- provide insertion point if requested
    //

    if (ppInsertionPoint)
    {
        *ppInsertionPoint = pParent;
    }

    return NULL;
} // NsLookupOutboundConnectionEntry


PNS_CONNECTION_ENTRY
NspInsertInboundConnectionEntry(
    PNS_CONNECTION_ENTRY pParent,
    PNS_CONNECTION_ENTRY pEntry
    )

/*++

Routine Description:

    This routine inserts a connection entry into the tree.

Arguments:

    pParent - the node to be the parent for the new connection entry.
        If NULL, the new entry becomes the root.

    pEntry - the new connection entry to be inserted.

Return Value:

    PNS_CONNECTION_ENTRY - The new root of the tree.
        If insertion fails, returns NULL.

Environment:

    Invoked with 'NsConnectionLock' held by the caller.

--*/

{
    PRTL_SPLAY_LINKS pRoot;
    
    ASSERT(NULL != pEntry);

    if (NULL == pParent)
    {
        //
        // The new entry is to be the root.
        //
        
        return pEntry;
    }

    //
    // Insert as left or right child. Keys are checked in the
    // following order:
    //
    // 1. Address Key
    // 2. Protocol
    // 3. Inbound port key
    // 4. IpSec context
    //

    if (pEntry->ul64AddressKey < pParent->ul64AddressKey)
    {
        RtlInsertAsLeftChild(
            &pParent->SLink[NsInboundDirection],
            &pEntry->SLink[NsInboundDirection]
            );
    }
    else if (pEntry->ul64AddressKey > pParent->ul64AddressKey)
    {
        RtlInsertAsRightChild(
            &pParent->SLink[NsInboundDirection],
            &pEntry->SLink[NsInboundDirection]
            );

    }
    else if (pEntry->ucProtocol < pParent->ucProtocol)
    {
        RtlInsertAsLeftChild(
            &pParent->SLink[NsInboundDirection],
            &pEntry->SLink[NsInboundDirection]
            );
    }
    else if (pEntry->ucProtocol > pParent->ucProtocol)
    {
        RtlInsertAsRightChild(
            &pParent->SLink[NsInboundDirection],
            &pEntry->SLink[NsInboundDirection]
            );
    }
    else if (pEntry->ulPortKey[NsInboundDirection] < pParent->ulPortKey[NsInboundDirection])
    {
        RtlInsertAsLeftChild(
            &pParent->SLink[NsInboundDirection],
            &pEntry->SLink[NsInboundDirection]
            );
    }
    else if (pEntry->ulPortKey[NsInboundDirection] > pParent->ulPortKey[NsInboundDirection])
    {
        RtlInsertAsRightChild(
            &pParent->SLink[NsInboundDirection],
            &pEntry->SLink[NsInboundDirection]
            );
    }
    else if (pEntry->pvIpSecContext < pParent->pvIpSecContext)
    {
        RtlInsertAsLeftChild(
            &pParent->SLink[NsInboundDirection],
            &pEntry->SLink[NsInboundDirection]
            );
    }
    else if (pEntry->pvIpSecContext > pParent->pvIpSecContext)
    {
        RtlInsertAsRightChild(
            &pParent->SLink[NsInboundDirection],
            &pEntry->SLink[NsInboundDirection]
            );
    }
    else
    {
        //
        // Duplicate entry -- this should not happen.
        //

        ASSERT(FALSE);
        return NULL;
    }

    //
    // Splay the new node and return the resulting root.
    //

    pRoot = RtlSplay(&pEntry->SLink[NsInboundDirection]);
    return CONTAINING_RECORD(pRoot, NS_CONNECTION_ENTRY, SLink[NsInboundDirection]);
} // NspInsertInboundConnectionEntry


PNS_CONNECTION_ENTRY
NspInsertOutboundConnectionEntry(
    PNS_CONNECTION_ENTRY pParent,
    PNS_CONNECTION_ENTRY pEntry
    )

/*++

Routine Description:

    This routine inserts a connection entry into the tree.

Arguments:

    pParent - the node to be the parent for the new connection entry.
        If NULL, the new entry becomes the root.

    pEntry - the new connection entry to be inserted.

Return Value:

    PNS_CONNECTION_ENTRY - The new root of the tree.
        If insertion fails, returns NULL.

Environment:

    Invoked with 'NsConnectionLock' held by the caller.

--*/

{
    PRTL_SPLAY_LINKS pRoot;
    
    ASSERT(NULL != pEntry);

    if (NULL == pParent)
    {
        //
        // The new entry is to be the root.
        //
        
        return pEntry;
    }

    //
    // Insert as left or right child. Keys are checked in the
    // following order:
    //
    // 1. Address Key
    // 2. Protocol
    // 3. Outbound port key
    //

    if (pEntry->ul64AddressKey < pParent->ul64AddressKey)
    {
        RtlInsertAsLeftChild(
            &pParent->SLink[NsOutboundDirection],
            &pEntry->SLink[NsOutboundDirection]
            );
    }
    else if (pEntry->ul64AddressKey > pParent->ul64AddressKey)
    {
        RtlInsertAsRightChild(
            &pParent->SLink[NsOutboundDirection],
            &pEntry->SLink[NsOutboundDirection]
            );

    }
    else if (pEntry->ucProtocol < pParent->ucProtocol)
    {
        RtlInsertAsLeftChild(
            &pParent->SLink[NsOutboundDirection],
            &pEntry->SLink[NsOutboundDirection]
            );
    }
    else if (pEntry->ucProtocol > pParent->ucProtocol)
    {
        RtlInsertAsRightChild(
            &pParent->SLink[NsOutboundDirection],
            &pEntry->SLink[NsOutboundDirection]
            );
    }
    else if (pEntry->ulPortKey[NsOutboundDirection] < pParent->ulPortKey[NsOutboundDirection])
    {
        RtlInsertAsLeftChild(
            &pParent->SLink[NsOutboundDirection],
            &pEntry->SLink[NsOutboundDirection]
            );
    }
    else if (pEntry->ulPortKey[NsOutboundDirection] > pParent->ulPortKey[NsOutboundDirection])
    {
        RtlInsertAsRightChild(
            &pParent->SLink[NsOutboundDirection],
            &pEntry->SLink[NsOutboundDirection]
            );
    }
    else
    {
        //
        // Duplicate entry -- this should not happen.
        //

        ASSERT(FALSE);
        return NULL;
    }

    //
    // Splay the new node and return the resulting root.
    //

    pRoot = RtlSplay(&pEntry->SLink[NsOutboundDirection]);
    return CONTAINING_RECORD(pRoot, NS_CONNECTION_ENTRY, SLink[NsOutboundDirection]);
} // NspInsertOutboundConnectionEntry



VOID
NsShutdownConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to shutdown the connection management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked with no references made to any connection entry.

--*/

{
    KIRQL Irql;
    PNS_CONNECTION_ENTRY pEntry;

    CALLTRACE(("NsShutdownConnectionManagement\n"));

    KeAcquireSpinLock(&NsConnectionLock, &Irql);

    while (!IsListEmpty(&NsConnectionList))
    {
        pEntry =
            CONTAINING_RECORD(
                RemoveHeadList(&NsConnectionList),
                NS_CONNECTION_ENTRY,
                Link
                );

        NsCleanupConnectionEntry(pEntry);
    }

    NsConnectionTree[NsInboundDirection] = NULL;
    NsConnectionTree[NsOutboundDirection] = NULL;

    KeReleaseSpinLock(&NsConnectionLock, Irql);

    ExDeleteNPagedLookasideList(&NsConnectionLookasideList);
} // NsShutdownConnectionManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nsconn.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsConn.h
    
Abstract:

    Declarations for IpSec NAT shim connection entry management

Author:

    Jonathan Burstein (jonburs) 10-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#pragma once

//
// Structure:   _NS_CONNECTION_ENTRY
//
// This structure holds information about a specific active session.
// Each instance is held on the global connection list as well as
// on the global connection trees for inbound and outbound access.
//
// Each connection entry contains 5 pieces of identifying information:
// 1) the address key (local and remote IP addresses)
// 2) the protocol for the connection (TCP or UDP)
// 3) the IpSec context
// 4) the inbound (original) port key
// 5) the outbound (translated) port key
//
// Each time a packet is processed for a connection, the 'l64AccessOrExpiryTime'
// is set to the number of ticks since system-start (KeQueryTickCount).
// This value is used by our timer routine to eliminate expired connections.
//
// For TCP connections, 'l64AccessOrExpiryTime' will no longer be updated once
// FINs are seen in both direction. This is necessary for the timer routine
// to correctly evaluate whether or not the connection has left the time_wait
// state, and thus to prevent premature port reuse.
//
// Synchronization rules:
//
//  We use a reference count to ensure the existence of a connection entry,
//  and a spin-lock to ensure its consistency.
//
//  The fields of a connection entry are only consistent while the spinlock is
//  held (with the exception of fields such as 'ul64AddressKey' which are
//  read-only and fields such as 'ulReferenceCount' that are interlocked-access
//  only.)
//
//  The spinlock can only be acquired if
//      (a) the reference-count has been incremented, or
//      (b) the connection list lock is already held.
//

typedef struct _NS_CONNECTION_ENTRY
{
    LIST_ENTRY Link;
    RTL_SPLAY_LINKS SLink[NsMaximumDirection];
    KSPIN_LOCK Lock;
    ULONG ulReferenceCount;                         // interlocked-access only
    ULONG ulFlags;

    ULONG64 ul64AddressKey;                         // read-only
    ULONG ulPortKey[NsMaximumDirection];            // read-only
    PVOID pvIpSecContext;                           // read-only
    UCHAR ucProtocol;                               // read-only

    LONG64 l64AccessOrExpiryTime;
    ULONG ulAccessCount[NsMaximumDirection];        // interlocked-access only
    ULONG ulProtocolChecksumDelta[NsMaximumDirection];
    PNS_PACKET_ROUTINE PacketRoutine[NsMaximumDirection];   // read-only
} NS_CONNECTION_ENTRY, *PNS_CONNECTION_ENTRY;

//
// Set after a connection entry has been deleted; when the last
// reference is released the entry will be freed
//

#define NS_CONNECTION_FLAG_DELETED	0x80000000
#define NS_CONNECTION_DELETED(c) \
    ((c)->ulFlags & NS_CONNECTION_FLAG_DELETED)

//
// Set when a connection entry is expired
//

#define NS_CONNECTION_FLAG_EXPIRED	0x00000001
#define NS_CONNECTION_EXPIRED(c) \
    ((c)->ulFlags & NS_CONNECTION_FLAG_EXPIRED)

//
// Set when inbound / outbound FIN for a TCP session is seen
//

#define NS_CONNECTION_FLAG_OB_FIN	0x00000002
#define NS_CONNECTION_FLAG_IB_FIN	0x00000004
#define NS_CONNECTION_FIN(c) \
    (((c)->ulFlags & NS_CONNECTION_FLAG_OB_FIN) \
     && ((c)->ulFlags & NS_CONNECTION_FLAG_IB_FIN))

//
// Connection entry key manipulation macros
//

#define MAKE_ADDRESS_KEY(Key, ulLocalAddress, ulRemoteAddress) \
    ((Key) = ((ULONG64)(ulLocalAddress) << 32) | (ulRemoteAddress))

#define CONNECTION_LOCAL_ADDRESS(ul64AddressKey) \
    ((ULONG)(((ul64AddressKey) >> 32) & 0xFFFFFFFF))

#define CONNECTION_REMOTE_ADDRESS(ul64AddressKey) \
    ((ULONG)((ul64AddressKey)))

#define MAKE_PORT_KEY(Key, usLocalPort, usRemotePort) \
    ((Key) = ((ULONG)(usLocalPort & 0xFFFF) << 16) | (usRemotePort & 0xFFFF))

#define CONNECTION_LOCAL_PORT(ulPortKey) \
    ((USHORT)(((ulPortKey) >> 16) & 0xFFFF))

#define CONNECTION_REMOTE_PORT(ulPortKey) \
    ((USHORT)(ulPortKey))

//
// Resplay threshold; the entry is resplayed every time its access-count
// passes this value.
//

#define NS_CONNECTION_RESPLAY_THRESHOLD   5

//
// Defines the depth of the lookaside list for allocating connection entries
//

#define NS_CONNECTION_LOOKASIDE_DEPTH     20

//
// Connection entry allocation macros
//

#define ALLOCATE_CONNECTION_BLOCK() \
    ExAllocateFromNPagedLookasideList(&NsConnectionLookasideList)

#define FREE_CONNECTION_BLOCK(Block) \
    ExFreeToNPagedLookasideList(&NsConnectionLookasideList,(Block))

//
// Port range boundaries
//

#define NS_SOURCE_PORT_BASE             6000
#define NS_SOURCE_PORT_END              65534

//
// GLOBAL VARIABLE DECLARATIONS
//

extern CACHE_ENTRY NsConnectionCache[CACHE_SIZE];
extern ULONG NsConnectionCount;
extern LIST_ENTRY NsConnectionList;
extern KSPIN_LOCK NsConnectionLock;
extern NPAGED_LOOKASIDE_LIST NsConnectionLookasideList;
extern PNS_CONNECTION_ENTRY NsConnectionTree[NsMaximumDirection];
extern USHORT NsNextSourcePort;

//
// Function Prototypes
//

NTSTATUS
NsAllocateSourcePort(
    ULONG64 ul64AddressKey,
    ULONG ulPortKey,
    UCHAR ucProtocol,
    BOOLEAN fPortConflicts,
    PNS_CONNECTION_ENTRY *ppOutboundInsertionPoint,
    PULONG pulTranslatedPortKey
    );

VOID
NsCleanupConnectionEntry(
    PNS_CONNECTION_ENTRY pEntry
    );

NTSTATUS
NsCreateConnectionEntry(
    ULONG64 ul64AddressKey,
    ULONG ulInboundPortKey,
    ULONG ulOutboundPortKey,
    UCHAR ucProtocol,
    PVOID pvIpSecContext,
    PNS_CONNECTION_ENTRY pInboundInsertionPoint,
    PNS_CONNECTION_ENTRY pOutboundInsertionPoint,
    PNS_CONNECTION_ENTRY *ppNewEntry
    );

NTSTATUS
NsDeleteConnectionEntry(
    PNS_CONNECTION_ENTRY pEntry
    );

__forceinline
VOID
NsDereferenceConnectionEntry(
    PNS_CONNECTION_ENTRY pEntry
    )
{
    if (0 == InterlockedDecrement(&pEntry->ulReferenceCount))
    {
        NsCleanupConnectionEntry(pEntry);
    }
}

NTSTATUS
NsInitializeConnectionManagement(
    VOID
    );

PNS_CONNECTION_ENTRY
NsLookupInboundConnectionEntry(
    ULONG64 ul64AddressKey,
    ULONG ulPortKey,
    UCHAR ucProtocol,
    PVOID pvIpSecContext,
    BOOLEAN *pfPortConflicts OPTIONAL,
    PNS_CONNECTION_ENTRY *ppInsertionPoint OPTIONAL
    );

PNS_CONNECTION_ENTRY
NsLookupOutboundConnectionEntry(
    ULONG64 ul64AddressKey,
    ULONG ulPortKey,
    UCHAR ucProtocol,
    PNS_CONNECTION_ENTRY *ppInsertionPoint OPTIONAL
    );

__forceinline
BOOLEAN
NsReferenceConnectionEntry(
    PNS_CONNECTION_ENTRY pEntry
    )
{
    if (NS_CONNECTION_DELETED(pEntry))
    {
        return FALSE;
    }
    else
    {
        InterlockedIncrement(&pEntry->ulReferenceCount);
        return TRUE;
    }
}

__forceinline
VOID
NsResplayConnectionEntry(
    PNS_CONNECTION_ENTRY pEntry,
    IPSEC_NATSHIM_DIRECTION Direction
    )
{
    PRTL_SPLAY_LINKS SLink;

    KeAcquireSpinLockAtDpcLevel(&NsConnectionLock);

    if (!NS_CONNECTION_DELETED(pEntry))
    {
        SLink = RtlSplay(&pEntry->SLink[Direction]);
        NsConnectionTree[Direction] =
            CONTAINING_RECORD(SLink, NS_CONNECTION_ENTRY, SLink[Direction]);
    }
    
    KeReleaseSpinLockFromDpcLevel(&NsConnectionLock);
}

VOID
NsShutdownConnectionManagement(
    VOID
    );

__forceinline
VOID
NsTryToResplayConnectionEntry(
    PNS_CONNECTION_ENTRY pEntry,
    IPSEC_NATSHIM_DIRECTION Direction
    )
{
    if (0 == InterlockedDecrement(&pEntry->ulAccessCount[Direction]))
    {
        NsResplayConnectionEntry(pEntry, Direction);
        InterlockedExchangeAdd(
            &pEntry->ulAccessCount[Direction],
            NS_CONNECTION_RESPLAY_THRESHOLD
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nsicmp.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsIcmp.h
    
Abstract:

    Declarations for IpSec NAT shim ICMP management
    
Author:

    Jonathan Burstein (jonburs) 11-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#pragma once

//
// Structure:   NS_ICMP_ENTRY
//
// This structure stores the information needed to process ICMP
// request-response messages. An entry will be created for an
// inbound request message.
//
// If necessary the ICMP logic will translate the ICMP identifier
// to avoid conflicts.
//
// The timer routine removes entries from the ICMP list when they
// have surpassed the inactivity threshold.
//
// All access to the ICMP list or entires must happen while holding
// the ICMP list lock.
//

typedef struct _NS_ICMP_ENTRY
{
	LIST_ENTRY Link;
	LONG64 l64LastAccessTime;
	ULONG64 ul64AddressKey;
	USHORT usOriginalId;
	USHORT usTranslatedId;
	PVOID pvIpSecContext;
} NS_ICMP_ENTRY, *PNS_ICMP_ENTRY;

//
// Defines the depth of the lookaside list for allocating ICMP entries
//

#define NS_ICMP_LOOKASIDE_DEPTH        10


//
// Global Variables
//

extern LIST_ENTRY NsIcmpList;
extern KSPIN_LOCK NsIcmpLock;
extern NPAGED_LOOKASIDE_LIST NsIcmpLookasideList;

//
// ICMP mapping allocation macros
//

#define ALLOCATE_ICMP_BLOCK() \
    ExAllocateFromNPagedLookasideList(&NsIcmpLookasideList)

#define FREE_ICMP_BLOCK(Block) \
    ExFreeToNPagedLookasideList(&NsIcmpLookasideList,(Block))


//
// Function Prototypes
//

NTSTATUS
NsInitializeIcmpManagement(
    VOID
    );

NTSTATUS
FASTCALL    
NsProcessIncomingIcmpPacket(
    PNS_PACKET_CONTEXT pContext,
    PVOID pvIpSecContext
    );

NTSTATUS
FASTCALL    
NsProcessOutgoingIcmpPacket(
    PNS_PACKET_CONTEXT pContext,
    PVOID *ppvIpSecContext
    );

VOID
NsShutdownIcmpManagement(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nsinit.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsInit.c
    
Abstract:

    IpSec NAT shim initialization and shutdown routines

Author:

    Jonathan Burstein (jonburs) 11-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global Variables
//

PDEVICE_OBJECT NsIpSecDeviceObject;

#if DBG
ULONG NsTraceClassesEnabled;
WCHAR NsTraceClassesRegistryPath[] = 
    L"MACHINE\\System\\CurrentControlSet\\Services\\IpNat\\Parameters";
WCHAR NsTraceClassesEnabledName[] = 
    L"NatShimTraceClassesEnabled";
#endif


NTSTATUS
NsCleanupShim(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to shutdown the shim.

Arguments:

    none.

Return Value:

    NTSTATUS.

Environment:

    Must be called at PASSIVE_LEVEL.

--*/

{
    CALLTRACE(("NsCleanupShim\n"));
    
    NsShutdownTimerManagement();
    NsShutdownIcmpManagement();
    NsShutdownPacketManagement();
    NsShutdownConnectionManagement();

    NsIpSecDeviceObject = NULL;
    
    return STATUS_SUCCESS;
} // NsCleanupShim


NTSTATUS
NsInitializeShim(
    PDEVICE_OBJECT pIpSecDeviceObject,
    PIPSEC_NATSHIM_FUNCTIONS pShimFunctions
    )

/*++

Routine Description:

    This routine is invoked to initialize the shim.

Arguments:

    pIpSecDeviceObject - a pointer to the IpSec device object

    pShimFunctions - a pointer to an allocated strcture. This routine will
        fill out the function pointers w/in the structure

Return Value:

    NTSTATUS.

Environment:

    Must be called at PASSIVE_LEVEL.

--*/

{
    NTSTATUS status;
#if DBG
    HANDLE hKey;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING String;
#endif

    CALLTRACE(("NsInitializeShim\n"));

    if (NULL == pIpSecDeviceObject
        || NULL == pShimFunctions)
    {
        return STATUS_INVALID_PARAMETER;
    }

#if DBG
    //
    // Open the registry key containing debug tracing informatin.
    //

    RtlInitUnicodeString(&String, NsTraceClassesRegistryPath);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &String,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey(&hKey, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(status))
    {
        UCHAR Buffer[32];
        ULONG BytesRead;
        PKEY_VALUE_PARTIAL_INFORMATION Value;
        
        RtlInitUnicodeString(&String, NsTraceClassesEnabledName);
        status =
            ZwQueryValueKey(
                hKey,
                &String,
                KeyValuePartialInformation,
                (PKEY_VALUE_PARTIAL_INFORMATION)Buffer,
                sizeof(Buffer),
                &BytesRead
                );
        
        ZwClose(hKey);
        
        if (NT_SUCCESS(status)
            && ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Type == REG_DWORD)
        {
            NsTraceClassesEnabled =
                *(PULONG)((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data;
        }
    }
#endif

    status = NsInitializeConnectionManagement();
    if (!NT_SUCCESS(status))
    {
        return status;
    }

    status = NsInitializePacketManagement();
    if (!NT_SUCCESS(status))
    {
        NsShutdownConnectionManagement();
        return status;
    }

    status = NsInitializeIcmpManagement();
    if (!NT_SUCCESS(status))
    {
        NsShutdownPacketManagement();
        NsShutdownConnectionManagement();
        return status;
    }

    status = NsInitializeTimerManagement();
    if (!NT_SUCCESS(status))
    {
        NsShutdownIcmpManagement();
        NsShutdownPacketManagement();
        NsShutdownConnectionManagement();
        return status;
    }
    
    NsIpSecDeviceObject = pIpSecDeviceObject;
    pShimFunctions->pCleanupRoutine = NsCleanupShim;
    pShimFunctions->pIncomingPacketRoutine = NsProcessIncomingPacket;
    pShimFunctions->pOutgoingPacketRoutine = NsProcessOutgoingPacket;

    return STATUS_SUCCESS;        
} // NsInitializeShim
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nstimer.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsTimer.h
    
Abstract:

    Declarations for IpSec NAT shim timer management
    
Author:

    Jonathan Burstein (jonburs) 11-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#pragma once

//
// Macro used to convert from seconds to tick-count units
//

#define SECONDS_TO_TICKS(s) \
    ((LONG64)(s) * 10000000 / NsTimeIncrement)

#define TICKS_TO_SECONDS(t) \
    ((LONG64)(t) * NsTimeIncrement / 10000000)


//
// Global Variables
//

extern ULONG NsTimeIncrement;
extern ULONG NsTcpTimeoutSeconds;
extern ULONG NsUdpTimeoutSeconds;

//
// Function Prototypes
//

NTSTATUS
NsInitializeTimerManagement(
    VOID
    );

VOID
NsShutdownTimerManagement(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nspacketroutines.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsPacketRoutines.h
    
Abstract:

    This file contains the code for the packet-routines used for
    connection routines.

    The inbound routines have the exact same logic as the outbound routines.
    However, for reasons of efficiency the two are separate routines,
    to avoid the cost of indexing on 'NsDirection' for every packet
    processed.

    To avoid duplicating the code, then, this header file consolidates the code
    in one location. This file is included twice in NsPacket.c, and before each
    inclusion, either 'NS_INBOUND' or 'NS_OUTBOUND' is defined.

    This causes the compiler to generate the code for separate functions,
    as desired, while avoiding the unpleasantness of code-duplication.

    Each routine is invoked from 'NsProcess*Packet' at dispatch level
    with no locks held and with a reference acquired for the connection
    entry.

Author:

    Jonathan Burstein (jonburs) 20-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#ifdef NS_INBOUND
#define NS_POSITIVE                     NsInboundDirection
#define NS_NEGATIVE                     NsOutboundDirection
#define NS_TCP_ROUTINE                  NsInboundTcpPacketRoutine
#define NS_UDP_ROUTINE                  NsInboundUdpPacketRoutine
#define NS_TCP_TRANSLATE_PORT_ROUTINE   NsInboundTcpTranslatePortPacketRoutine
#define NS_UDP_TRANSLATE_PORT_ROUTINE   NsInboundUdpTranslatePortPacketRoutine
#define NS_PACKET_FIN                   NS_CONNECTION_FLAG_IB_FIN
#define NS_TRANSLATE_PORTS_TCP() \
    pContext->pTcpHeader->SourcePort = \
        CONNECTION_REMOTE_PORT(pConnection->ulPortKey[NsOutboundDirection])
#define NS_TRANSLATE_PORTS_UDP() \
    pContext->pUdpHeader->SourcePort = \
        CONNECTION_REMOTE_PORT(pConnection->ulPortKey[NsOutboundDirection])
#else
#define NS_POSITIVE                     NsOutboundDirection
#define NS_NEGATIVE                     NsInboundDirection
#define NS_TCP_ROUTINE                  NsOutboundTcpPacketRoutine
#define NS_UDP_ROUTINE                  NsOutboundUdpPacketRoutine
#define NS_TCP_TRANSLATE_PORT_ROUTINE   NsOutboundTcpTranslatePortPacketRoutine
#define NS_UDP_TRANSLATE_PORT_ROUTINE   NsOutboundUdpTranslatePortPacketRoutine
#define NS_PACKET_FIN                   NS_CONNECTION_FLAG_OB_FIN
#define NS_TRANSLATE_PORTS_TCP() \
    pContext->pTcpHeader->DestinationPort = \
        CONNECTION_REMOTE_PORT(pConnection->ulPortKey[NsInboundDirection])
#define NS_TRANSLATE_PORTS_UDP() \
    pContext->pUdpHeader->DestinationPort = \
        CONNECTION_REMOTE_PORT(pConnection->ulPortKey[NsInboundDirection])
#endif

NTSTATUS
FASTCALL
NS_TCP_ROUTINE(
    PNS_CONNECTION_ENTRY pConnection,
    PNS_PACKET_CONTEXT pContext
    )

{
    KeAcquireSpinLockAtDpcLevel(&pConnection->Lock);

    //
    // Update the connection state based on the flags in the packet:
    //
    // When a RST is seen, mark the connection for deletion
    // When a FIN is seen, mark the connection appropriately
    // When both FINs have been seen, mark the connection for deletion
    //

    if (TCP_FLAG(pContext->pTcpHeader, RST))
    {
        pConnection->ulFlags |= NS_CONNECTION_FLAG_EXPIRED;
    }
    else if (TCP_FLAG(pContext->pTcpHeader, FIN))
    {
        pConnection->ulFlags |= NS_PACKET_FIN;
        if (NS_CONNECTION_FIN(pConnection))
        {
            pConnection->ulFlags |= NS_CONNECTION_FLAG_EXPIRED;

            //
            // Perform a final update of the timestamp for the connection.
            // From this point on the timestamp is used to determine when
            // this connection has left the time-wait state.
            //
            
            KeQueryTickCount((PLARGE_INTEGER)&pConnection->l64AccessOrExpiryTime);
        }
    }

    //
    // Update the timestamp for the connection (if this connection is not in
    // a timer-wait state -- i.e., both FINs have not been seen).
    //

    if (!NS_CONNECTION_FIN(pConnection))
    {
        KeQueryTickCount((PLARGE_INTEGER)&pConnection->l64AccessOrExpiryTime);
    }
    
    KeReleaseSpinLockFromDpcLevel(&pConnection->Lock);

    //
    // Periodically resplay the connection entry
    //

    NsTryToResplayConnectionEntry(pConnection, NS_POSITIVE);

    return STATUS_SUCCESS;    
} // NS_TCP_ROUTINE

NTSTATUS
FASTCALL
NS_UDP_ROUTINE(
    PNS_CONNECTION_ENTRY pConnection,
    PNS_PACKET_CONTEXT pContext
    )

{
    KeAcquireSpinLockAtDpcLevel(&pConnection->Lock);

    //
    // Update the timestamp for the connection
    //

    KeQueryTickCount((PLARGE_INTEGER)&pConnection->l64AccessOrExpiryTime);

    KeReleaseSpinLockFromDpcLevel(&pConnection->Lock);

    //
    // Periodically resplay the connection entry
    //

    NsTryToResplayConnectionEntry(pConnection, NS_POSITIVE);

    return STATUS_SUCCESS;    
} // NS_UDP_ROUTINE

NTSTATUS
FASTCALL
NS_TCP_TRANSLATE_PORT_ROUTINE(
    PNS_CONNECTION_ENTRY pConnection,
    PNS_PACKET_CONTEXT pContext
    )

{
    ULONG ulChecksumDelta;

    //
    // Translate the port information in the packet
    //

    NS_TRANSLATE_PORTS_TCP();

    //
    // Update the protocol checksum
    //

    CHECKSUM_XFER(ulChecksumDelta, pContext->pTcpHeader->Checksum);
    ulChecksumDelta += pConnection->ulProtocolChecksumDelta[NS_POSITIVE];
    CHECKSUM_FOLD(ulChecksumDelta);
    CHECKSUM_XFER(pContext->pTcpHeader->Checksum, ulChecksumDelta);
    
    KeAcquireSpinLockAtDpcLevel(&pConnection->Lock);

    //
    // Update the connection state based on the flags in the packet:
    //
    // When a RST is seen, mark the connection for deletion
    // When a FIN is seen, mark the connection appropriately
    // When both FINs have been seen, mark the connection for deletion
    //

    if (TCP_FLAG(pContext->pTcpHeader, RST))
    {
        pConnection->ulFlags |= NS_CONNECTION_FLAG_EXPIRED;
    }
    else if (TCP_FLAG(pContext->pTcpHeader, FIN))
    {
        pConnection->ulFlags |= NS_PACKET_FIN;
        if (NS_CONNECTION_FIN(pConnection))
        {
            pConnection->ulFlags |= NS_CONNECTION_FLAG_EXPIRED;

            //
            // Perform a final update of the timestamp for the connection.
            // From this point on the timestamp is used to determine when
            // this connection has left the time-wait state.
            //
            
            KeQueryTickCount((PLARGE_INTEGER)&pConnection->l64AccessOrExpiryTime);
        }
    }

    //
    // Update the timestamp for the connection (if this connection is not in
    // a timer-wait state -- i.e., both FINs have not been seen).
    //

    if (!NS_CONNECTION_FIN(pConnection))
    {
        KeQueryTickCount((PLARGE_INTEGER)&pConnection->l64AccessOrExpiryTime);
    }

    KeReleaseSpinLockFromDpcLevel(&pConnection->Lock);

    //
    // Periodically resplay the connection entry
    //

    NsTryToResplayConnectionEntry(pConnection, NS_POSITIVE);

    return STATUS_SUCCESS;    
} // NS_TCP_TRANSLATE_PORT_ROUTINE

NTSTATUS
FASTCALL
NS_UDP_TRANSLATE_PORT_ROUTINE(
    PNS_CONNECTION_ENTRY pConnection,
    PNS_PACKET_CONTEXT pContext
    )

{
    ULONG ulChecksumDelta;

    //
    // Translate the port information in the packet
    //

    NS_TRANSLATE_PORTS_UDP();

    //
    // Update the protocol checksum if the original packet contained
    // a checksum (UDP checksum is optional)
    //

    if (0 != pContext->pUdpHeader->Checksum)
    {
        CHECKSUM_XFER(ulChecksumDelta, pContext->pUdpHeader->Checksum);
        ulChecksumDelta += pConnection->ulProtocolChecksumDelta[NS_POSITIVE];
        CHECKSUM_FOLD(ulChecksumDelta);
        CHECKSUM_XFER(pContext->pUdpHeader->Checksum, ulChecksumDelta);
    }
    
    KeAcquireSpinLockAtDpcLevel(&pConnection->Lock);

    //
    // Update the timestamp for the connection
    //

    KeQueryTickCount((PLARGE_INTEGER)&pConnection->l64AccessOrExpiryTime);

    KeReleaseSpinLockFromDpcLevel(&pConnection->Lock);

    //
    // Periodically resplay the connection entry
    //

    NsTryToResplayConnectionEntry(pConnection, NS_POSITIVE);

    return STATUS_SUCCESS;    
} // NS_UDP_TRANSLATE_PORT_ROUTINE



#undef NS_POSITIVE
#undef NS_NEGATIVE
#undef NS_TCP_ROUTINE
#undef NS_UDP_ROUTINE
#undef NS_TCP_TRANSLATE_PORT_ROUTINE
#undef NS_UDP_TRANSLATE_PORT_ROUTINE
#undef NS_PACKET_FIN
#undef NS_TRANSLATE_PORTS_TCP
#undef NS_TRANSLATE_PORTS_UDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nspacket.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsPacket.h
    
Abstract:

    IpSec NAT shim packet handling routines

Author:

    Jonathan Burstein (jonburs) 11-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
NsInitializePacketManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the packet management module.

Arguments:

    none.

Return Value:

    NTSTATUS.

--*/

{
    CALLTRACE(("NsInitializePacketManagement\n"));
    
    return STATUS_SUCCESS;
} // NsInitializePacketManagement


NTSTATUS
NsProcessOutgoingPacket(
    IPHeader UNALIGNED *pIpHeader,
    PVOID pvProtocolHeader,
    ULONG ulProtocolHeaderSize,
    PVOID *ppvIpSecContext
    )

/*++

Routine Description:

    This routine is invoked by IpSec for each outgoing packet. If this
    packet matches a known connection the remote port will be translated
    (if necessary), and the IpSec context will be returned to the caller.
    
Arguments:

    pIpHeader - points to the IP header for the packet

    pvProtocolHeader - points to the upper level protocol header (i.e., TCP,
        UDP, or ICMP) for the packet. Will be NULL if this is not a TCP, UDP,
        or ICMP packet.

    ulProtocolHeaderSize - the length of the buffer pointed to by
        pvProtocolHeader

    ppvIpSecContext - receives the IpSec context for this packet; will
        receive NULL if this packet does not belong to a known connection.

Return Value:

    NTSTATUS.

--*/

{
    NS_PACKET_CONTEXT Context;
    KIRQL Irql;
    NTSTATUS Status;
    PNS_CONNECTION_ENTRY pEntry;
    ULONG64 ul64AddressKey;
    ULONG ulPortKey;

    ASSERT(NULL != pIpHeader);
    ASSERT(NULL != ppvIpSecContext);

    //
    // Set context to default value
    //
    
    *ppvIpSecContext = NULL;

    Status =
        NsBuildPacketContext(
            pIpHeader,
            pvProtocolHeader,
            ulProtocolHeaderSize,
            &Context
            );

    //
    // Return immediately if the packet is malformed, or if it
    // is not TCP, UDP, or ICMP
    //

    if (!NT_SUCCESS(Status)
        || (NS_PROTOCOL_ICMP != Context.ucProtocol
            && NS_PROTOCOL_TCP != Context.ucProtocol
            && NS_PROTOCOL_UDP != Context.ucProtocol))
    {
        TRACE(PACKET,
            ("NsProcessOutgoingPacket: Bad or non-TCP/UDP/ICMP packet\n"));
        return Status;
    }

    TRACE(
        PACKET,
        ("NsProcessOutgoingPacket: %d: %d.%d.%d.%d/%d -> %d.%d.%d.%d/%d\n",
            Context.ucProtocol,
            ADDRESS_BYTES(Context.ulSourceAddress),
            NTOHS(Context.usSourcePort),
            ADDRESS_BYTES(Context.ulDestinationAddress),
            NTOHS(Context.usDestinationPort)
            ));

    if (NS_PROTOCOL_ICMP != Context.ucProtocol)
    {
        //
        // Build the connection lookup keys
        //

        MAKE_ADDRESS_KEY(
            ul64AddressKey,
            Context.ulSourceAddress,
            Context.ulDestinationAddress
            );

        MAKE_PORT_KEY(
            ulPortKey,
            Context.usSourcePort,
            Context.usDestinationPort
            );

        //
        // See if this packet matches an existing connection entry
        //

        KeAcquireSpinLock(&NsConnectionLock, &Irql);

        pEntry =
            NsLookupOutboundConnectionEntry(
                ul64AddressKey,
                ulPortKey,
                Context.ucProtocol,
                NULL
                );

        if (NULL != pEntry
            && NsReferenceConnectionEntry(pEntry))
        {
            KeReleaseSpinLockFromDpcLevel(&NsConnectionLock);

            *ppvIpSecContext = pEntry->pvIpSecContext;
            Status =
                pEntry->PacketRoutine[NsOutboundDirection](pEntry, &Context);

            NsDereferenceConnectionEntry(pEntry);
            KeLowerIrql(Irql);
        }
        else
        {
            //
            // No match (or entry already deleted) -- nothing more to do.
            //

            KeReleaseSpinLock(&NsConnectionLock, Irql);
        }
        
    }
    else
    {
        //
        // Branch to ICMP logic
        //

        Status = NsProcessOutgoingIcmpPacket(&Context, ppvIpSecContext);
    }
    
    return Status;
} // NsProcessOutgoingPacket


NTSTATUS
NsProcessIncomingPacket(
    IPHeader UNALIGNED *pIpHeader,
    PVOID pvProtocolHeader,
    ULONG ulProtocolHeaderSize,
    PVOID pvIpSecContext
    )

/*++

Routine Description:

    This routine is invoked by IpSec for each incoming packet. It
    will record the connection information and context for the
    packet (if such information does not yet exist), and, if necessary,
    allocate a new remote port and modify the packet accordingly.
    
Arguments:

    pIpHeader - points to the IP header for the packet

    pvProtocolHeader - points to the upper level protocol header (i.e., TCP,
        UDP, or ICMP) for the packet. Will be NULL if this is not a TCP, UDP,
        or ICMP packet.

    ulProtocolHeaderSize - the length of the buffer pointed to by
        pvProtocolHeader

    pvIpSecContext - the IpSec context for this packet; this is considered
        an opaque value.

Return Value:

    NTSTATUS.

--*/
    
{
    NS_PACKET_CONTEXT Context;
    BOOLEAN fPortConflicts;
    KIRQL Irql;
    NTSTATUS Status;
    PNS_CONNECTION_ENTRY pEntry;
    PNS_CONNECTION_ENTRY pInboundInsertionPoint;
    PNS_CONNECTION_ENTRY pOutboundInsertionPoint;
    ULONG64 ul64AddressKey;
    ULONG ulPortKey;
    ULONG ulTranslatedPortKey;

    ASSERT(NULL != pIpHeader);

    Status =
        NsBuildPacketContext(
            pIpHeader,
            pvProtocolHeader,
            ulProtocolHeaderSize,
            &Context
            );

    //
    // Return immediately if the packet is malformed, or if it
    // is not TCP, UDP, or ICMP
    //

    if (!NT_SUCCESS(Status)
        || (NS_PROTOCOL_ICMP != Context.ucProtocol
            && NS_PROTOCOL_TCP != Context.ucProtocol
            && NS_PROTOCOL_UDP != Context.ucProtocol))
    {
        TRACE(PACKET,
            ("NsProcessIncomingPacket: Bad or non-TCP/UDP/ICMP packet\n"));
        return Status;
    }

    TRACE(
        PACKET,
        ("NsProcessIncomingPacket: %d: %d.%d.%d.%d/%d -> %d.%d.%d.%d/%d\n",
            Context.ucProtocol,
            ADDRESS_BYTES(Context.ulSourceAddress),
            NTOHS(Context.usSourcePort),
            ADDRESS_BYTES(Context.ulDestinationAddress),
            NTOHS(Context.usDestinationPort)
            ));

    if (NS_PROTOCOL_ICMP != Context.ucProtocol)
    {
        //
        // Build the connection lookup keys
        //

        MAKE_ADDRESS_KEY(
            ul64AddressKey,
            Context.ulDestinationAddress,
            Context.ulSourceAddress
            );

        MAKE_PORT_KEY(
            ulPortKey,
            Context.usDestinationPort,
            Context.usSourcePort
            );

        KeAcquireSpinLock(&NsConnectionLock, &Irql);

        //
        // See if this packet matches an existing connection entry
        //

        pEntry =
            NsLookupInboundConnectionEntry(
                ul64AddressKey,
                ulPortKey,
                Context.ucProtocol,
                pvIpSecContext,
                &fPortConflicts,
                &pInboundInsertionPoint
                );

        if (NULL != pEntry
            && NsReferenceConnectionEntry(pEntry))
        {
            KeReleaseSpinLockFromDpcLevel(&NsConnectionLock);

            Status =
                pEntry->PacketRoutine[NsInboundDirection](pEntry, &Context);

            NsDereferenceConnectionEntry(pEntry);
            KeLowerIrql(Irql);
        }
        else
        {            
            //
            // No valid connection entry was found for this packet. Allocate
            // a new source port for the connection (if necessary).
            //

            Status =
                NsAllocateSourcePort(
                    ul64AddressKey,
                    ulPortKey,
                    Context.ucProtocol,
                    fPortConflicts,
                    &pOutboundInsertionPoint,
                    &ulTranslatedPortKey
                    );

            if (NT_SUCCESS(Status))
            {
                //
                // Create the new connection entry
                //

                Status =
                    NsCreateConnectionEntry(
                        ul64AddressKey,
                        ulPortKey,
                        ulTranslatedPortKey,
                        Context.ucProtocol,
                        pvIpSecContext,
                        pInboundInsertionPoint,
                        pOutboundInsertionPoint,
                        &pEntry
                        );

                KeReleaseSpinLockFromDpcLevel(&NsConnectionLock);

                if (NT_SUCCESS(Status))
                {
                    Status = 
                        pEntry->PacketRoutine[NsInboundDirection](
                            pEntry,
                            &Context
                            );

                    NsDereferenceConnectionEntry(pEntry);
                }

                KeLowerIrql(Irql);
            }
            else
            {
                KeReleaseSpinLock(&NsConnectionLock, Irql);
            }
        }
    }
    else
    {
        //
        // Branch to ICMP logic
        //

        Status = NsProcessIncomingIcmpPacket(&Context, pvIpSecContext);
    }
    
    return Status;
} // NsProcessIncomingPacket


VOID
NsShutdownPacketManagement(
   VOID
   )

/*++

Routine Description:

    This routine is invoked to shutdown the packet management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NsShutdownPacketManagement\n"));
} // NsShutdownPacketManagement

//
// Now include the code for the per-packet routines --
// see NsPacketRoutines.h for details
//

#define NS_INBOUND
#include "NsPacketRoutines.h"
#undef NS_INBOUND

#define NS_OUTBOUND
#include "NsPacketRoutines.h"
#undef NS_OUTBOUND
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nstimer.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsTimer.c
    
Abstract:

    IpSec NAT shim timer management

Author:

    Jonathan Burstein (jonburs) 11-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Defines the interval at which the timer fires, in 100-nanosecond intervals
//

#define NS_TIMER_INTERVAL              (60 * 1000 * 1000 * 10)

//
// Return-value of KeQueryTimeIncrement, used for normalizing tick-counts
//

ULONG NsTimeIncrement;

//
// DPC object for NsTimerRoutine
//

KDPC NsTimerDpcObject;

//
// Timer object for NsTimerRoutine
//

KTIMER NsTimerObject;

//
// Protocol timeouts
//

ULONG NsTcpTimeoutSeconds;
ULONG NsTcpTimeWaitSeconds;
ULONG NsUdpTimeoutSeconds;

//
// Function Prototypes
//

VOID
NsTimerRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );


NTSTATUS
NsInitializeTimerManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the timer management module.

Arguments:

    none.

Return Value:

    NTSTATUS.

--*/

{
    LARGE_INTEGER DueTime;

    CALLTRACE(("NsInitializeTimerManagement\n"));
    
    NsTimeIncrement = KeQueryTimeIncrement();
    KeInitializeDpc(&NsTimerDpcObject, NsTimerRoutine, NULL);
    KeInitializeTimer(&NsTimerObject);

    DueTime.LowPart = NS_TIMER_INTERVAL;
    DueTime.HighPart = 0;
    DueTime = RtlLargeIntegerNegate(DueTime);
    KeSetTimerEx(
        &NsTimerObject,
        DueTime,
        NS_TIMER_INTERVAL / 10000,
        &NsTimerDpcObject
        );

    NsTcpTimeoutSeconds = 60 * 60 * 24;
    NsTcpTimeWaitSeconds = 60 * 4;
    NsUdpTimeoutSeconds = 60;
    
    return STATUS_SUCCESS;
} // NsInitializeTimerManagement


VOID
NsShutdownTimerManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the timer management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    CALLTRACE(("NsShutdownTimerManagement\n"));
    
    KeCancelTimer(&NsTimerObject);
} // NsShutdownTimerManagement


VOID
NsTimerRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is invoked periodically to garbage-collect expired mappings.

Arguments:

    Dpc - associated DPC object

    DeferredContext - unused.

    SystemArgument1 - unused.

    SystemArgument2 - unused.

Return Value:

    none.

--*/

{
    LONG64 CurrentTime;
    KIRQL Irql;
    PLIST_ENTRY Link;
    PNS_CONNECTION_ENTRY pConnectionEntry;
    PNS_ICMP_ENTRY pIcmpEntry;
    LONG64 Timeout;
    LONG64 TcpMinAccessTime;
    LONG64 TcpMinTimeWaitExpiryTime;
    LONG64 UdpMinAccessTime;

    TRACE(TIMER, ("NsTimerRoutine\n"));

    //
    // Compute the minimum values allowed in TCP/UDP 'LastAccessTime' fields;
    // any mappings last accessed before these thresholds will be eliminated.
    //

    KeQueryTickCount((PLARGE_INTEGER)&CurrentTime);
    TcpMinAccessTime = CurrentTime - SECONDS_TO_TICKS(NsTcpTimeoutSeconds);
    TcpMinTimeWaitExpiryTime =
        CurrentTime - SECONDS_TO_TICKS(NsTcpTimeWaitSeconds);
    UdpMinAccessTime = CurrentTime - SECONDS_TO_TICKS(NsUdpTimeoutSeconds);

    //
    // Clean out expired connection entries,
    // using the above precomputed minimum access times
    //

    KeAcquireSpinLock(&NsConnectionLock, &Irql);
    for (Link = NsConnectionList.Flink;
         Link != &NsConnectionList;
         Link = Link->Flink)
    {

        pConnectionEntry = CONTAINING_RECORD(Link, NS_CONNECTION_ENTRY, Link);
        
        //
        // See if the connection has expired
        //

        KeAcquireSpinLockAtDpcLevel(&pConnectionEntry->Lock);
        if (!NS_CONNECTION_EXPIRED(pConnectionEntry))
        {
            //
            // The entry is not explicitly marked for expiration;
            // see if its last access time is too long ago
            //
            
            if (NS_PROTOCOL_TCP == pConnectionEntry->ucProtocol)
            {
                if (pConnectionEntry->l64AccessOrExpiryTime >= TcpMinAccessTime)
                {
                    KeReleaseSpinLockFromDpcLevel(&pConnectionEntry->Lock);
                    continue;
                }
            }
            else if (pConnectionEntry->l64AccessOrExpiryTime >= UdpMinAccessTime)
            {
                KeReleaseSpinLockFromDpcLevel(&pConnectionEntry->Lock);
                continue;
            }
        }
        else if (NS_CONNECTION_FIN(pConnectionEntry)
                 && pConnectionEntry->l64AccessOrExpiryTime >= TcpMinTimeWaitExpiryTime)
        {
            //
            // This connection was marked as expired because FINs were
            // seen in both directions, but has not yet left the time-wait
            // period.
            //

            KeReleaseSpinLockFromDpcLevel(&pConnectionEntry->Lock);
            continue;
        }
        KeReleaseSpinLockFromDpcLevel(&pConnectionEntry->Lock);

        //
        // The entry has expired; remove it
        //

        Link = Link->Blink;
        NsDeleteConnectionEntry(pConnectionEntry);
    }
    KeReleaseSpinLockFromDpcLevel(&NsConnectionLock);

    //
    // Traverse the ICMP list and remove each expired entry.
    //

    KeAcquireSpinLockAtDpcLevel(&NsIcmpLock);
    for (Link = NsIcmpList.Flink;
         Link != &NsIcmpList;
         Link = Link->Flink)
    {
        pIcmpEntry = CONTAINING_RECORD(Link, NS_ICMP_ENTRY, Link);
        if (pIcmpEntry->l64LastAccessTime>= UdpMinAccessTime) { continue; }
        Link = Link->Blink;
        RemoveEntryList(&pIcmpEntry->Link);
        FREE_ICMP_BLOCK(pIcmpEntry);
    }
    KeReleaseSpinLock(&NsIcmpLock, Irql);

} // NsTimerRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nsprot.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsProt.h
    
Abstract:

    Protocol definitions for IpSec NAT shim

Author:

    Jonathan Burstein (jonburs) 10-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#pragma once

//
// IP Protocol Numbers
//

#define NS_PROTOCOL_ICMP       0x01
#define NS_PROTOCOL_TCP        0x06
#define NS_PROTOCOL_UDP        0x11

//
// ICMP message-type constants
//

#define ICMP_ECHO_REPLY             0
#define ICMP_DEST_UNREACH           3
#define ICMP_SOURCE_QUENCH          4
#define ICMP_REDIRECT               5
#define ICMP_ECHO_REQUEST           8
#define ICMP_ROUTER_REPLY           9
#define ICMP_ROUTER_REQUEST         10
#define ICMP_TIME_EXCEED            11
#define ICMP_PARAM_PROBLEM          12
#define ICMP_TIMESTAMP_REQUEST      13
#define ICMP_TIMESTAMP_REPLY        14
#define ICMP_MASK_REQUEST           17
#define ICMP_MASK_REPLY             18

//
// ICMP message-code constants
//

#define ICMP_CODE_NET_UNREACH       0
#define ICMP_CODE_HOST_UNREACH      1
#define ICMP_CODE_PROTOCOL_UNREACH  2
#define ICMP_CODE_PORT_UNREACH      3
#define ICMP_CODE_FRAG_NEEDED       4
#define ICMP_SOURCE_ROUTE_FAILED    5

//
// Macro for extracting the data-offset from the field IPHeader.verlen
//

#define IP_DATA_OFFSET(h) \
    ((ULONG)((((IPHeader*)(h))->iph_verlen & 0x0F) << 2))

//
// Mask for extracting the fragment-offset from the IPHeader structure's
// combined flags/fragment-offset field
//

#define IP_FRAGMENT_OFFSET_MASK     ~0x00E0

//
// Macro for extracting the data-offset from the field TCP_HEADER.OffsetAndFlags
// The offset is in 32-bit words, so shifting by 2 gives the value in bytes.
//

#define TCP_DATA_OFFSET(h)          (((h)->OffsetAndFlags & 0x00F0) >> 2)

//
// Masks for extracting flags from the field TCP_HEADER.OffsetAndFlags
//

#define TCP_FLAG_FIN                0x0100
#define TCP_FLAG_SYN                0x0200
#define TCP_FLAG_RST                0x0400
#define TCP_FLAG_PSH                0x0800
#define TCP_FLAG_ACK                0x1000
#define TCP_FLAG_URG                0x2000

#define TCP_FLAG(h,f)               ((h)->OffsetAndFlags & TCP_FLAG_ ## f)
#define TCP_ALL_FLAGS(h)            ((h)->OffsetAndFlags & 0x3f00)
#define TCP_RESERVED_BITS(h)        ((h)->OffsetAndFlags & 0xc00f)

#include <packon.h>

typedef struct _IP_HEADER {
    UCHAR VersionAndHeaderLength;
    UCHAR TypeOfService;
    USHORT TotalLength;
    USHORT Identification;
    USHORT OffsetAndFlags;
    UCHAR TimeToLive;
    UCHAR Protocol;
    USHORT Checksum;
    ULONG SourceAddress;
    ULONG DestinationAddress;
} IP_HEADER, *PIP_HEADER;


typedef struct _TCP_HEADER {
    USHORT SourcePort;
    USHORT DestinationPort;
    ULONG SequenceNumber;
    ULONG AckNumber;
    USHORT OffsetAndFlags;
    USHORT WindowSize;
    USHORT Checksum;
    USHORT UrgentPointer;
} TCP_HEADER, *PTCP_HEADER;


typedef struct _UDP_HEADER {
    USHORT SourcePort;
    USHORT DestinationPort;
    USHORT Length;
    USHORT Checksum;
} UDP_HEADER, *PUDP_HEADER;


typedef struct _ICMP_HEADER {
    UCHAR Type;
    UCHAR Code;
    USHORT Checksum;
    USHORT Identifier;                  // valid only for ICMP request/reply
    USHORT SequenceNumber;              // valid only for ICMP request/reply
    IP_HEADER EncapsulatedIpHeader;     // valid only for ICMP errors
    union {
        struct _ENCAPSULATED_TCP_HEADER {
            USHORT SourcePort;
            USHORT DestinationPort;
            ULONG SequenceNumber;
        } EncapsulatedTcpHeader;
        struct _ENCAPSULATED_UDP_HEADER {
            USHORT SourcePort;
            USHORT DestinationPort;
            USHORT Length;
            USHORT Checksum;
        } EncapsulatedUdpHeader;
        struct _ENCAPSULATED_ICMP_HEADER {
            UCHAR Type;
            UCHAR Code;
            USHORT Checksum;
            USHORT Identifier;
            USHORT SequenceNumber;
        } EncapsulatedIcmpHeader;
    };
} ICMP_HEADER, *PICMP_HEADER;

#include <packoff.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nspacket.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsPacket.h
    
Abstract:

    Declarations for IpSec NAT shim packet handling routines

Author:

    Jonathan Burstein (jonburs) 10-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#pragma once

typedef enum
{
    NsInboundDirection = 0,
    NsOutboundDirection,
    NsMaximumDirection
} IPSEC_NATSHIM_DIRECTION, *PIPSEC_NATSHIM_DIRECTION;

//
// Structure: NS_PACKET_CONTEXT
//
// This structure holds context information for a packet as it is
// passed through the processing code. The majority of packet parsing
// and verification is done when this structure is filled out. 
//

typedef struct _NS_PACKET_CONTEXT
{
	IPHeader UNALIGNED *pIpHeader;
	ULONG ulSourceAddress;
	ULONG ulDestinationAddress;
	USHORT usSourcePort;
	USHORT usDestinationPort;
	union {
		TCP_HEADER UNALIGNED *pTcpHeader;
		UDP_HEADER UNALIGNED *pUdpHeader;
		ICMP_HEADER UNALIGNED *pIcmpHeader;
		PVOID pvProtocolHeader;
	};
	ULONG ulProtocolHeaderLength;
	UCHAR ucProtocol;
} NS_PACKET_CONTEXT, *PNS_PACKET_CONTEXT;

//
// Forward Declarations
//

struct _NS_CONNECTION_ENTRY;
#define PNS_CONNECTION_ENTRY struct _NS_CONNECTION_ENTRY*

//
// Functional signature macro
//

#define PACKET_ROUTINE(Name) \
    NTSTATUS \
    Name( \
        PNS_CONNECTION_ENTRY pConnection, \
        PNS_PACKET_CONTEXT pContext \
        );

typedef PACKET_ROUTINE((FASTCALL*PNS_PACKET_ROUTINE));

//
// Prototypes: NS_PACKET_ROUTINE
//
// These routines are called for each packet that matches a
// connection entry. During connection entry initialization
// the PacketRoutine fileds are filled in based on the specifics
// of the connnection.
//
// By using separate routines in this manner it will never be
// necessary to branch on such things as protocol, path, or whether
// or not remote port translation is needed on the main packet
// processing path. Such decisions are made only during connection
// entry creation.
//

PACKET_ROUTINE(FASTCALL NsInboundTcpPacketRoutine)
PACKET_ROUTINE(FASTCALL NsOutboundTcpPacketRoutine)
PACKET_ROUTINE(FASTCALL NsInboundUdpPacketRoutine)
PACKET_ROUTINE(FASTCALL NsOutboundUdpPacketRoutine)
PACKET_ROUTINE(FASTCALL NsInboundTcpTranslatePortPacketRoutine)
PACKET_ROUTINE(FASTCALL NsOutboundTcpTranslatePortPacketRoutine)
PACKET_ROUTINE(FASTCALL NsInboundUdpTranslatePortPacketRoutine)
PACKET_ROUTINE(FASTCALL NsOutboundUdpTranslatePortPacketRoutine)

//
// Checksum manipulation macros
//

//
// Fold carry-bits of a checksum into the low-order word
//
#define CHECKSUM_FOLD(xsum) \
    (xsum) = (USHORT)(xsum) + ((xsum) >> 16); \
    (xsum) += ((xsum) >> 16)

//
// Sum the words of a 32-bit value into a checksum
//
#define CHECKSUM_LONG(xsum,l) \
    (xsum) += (USHORT)(l) + (USHORT)((l) >> 16)

//
// Transfer a checksum to or from the negated format sent on the network
//
#define CHECKSUM_XFER(dst,src) \
    (dst) = (USHORT)~(src)

//
// Update the checksum field 'x' using standard variables 'ulChecksum' and
// 'ulChecksumDelta'
//
#define CHECKSUM_UPDATE(x) \
    CHECKSUM_XFER(ulChecksum, (x)); \
    ulChecksum += ulChecksumDelta; \
    CHECKSUM_FOLD(ulChecksum); \
    CHECKSUM_XFER((x), ulChecksum)



//
// Function Prototypes
//

__forceinline
NTSTATUS
NsBuildPacketContext(
    IPHeader UNALIGNED *pIpHeader,
    PVOID pvProtocolHeader,
    ULONG ulProtocolHeaderLength,
    PNS_PACKET_CONTEXT pContext
    )
{
    if (NULL == pIpHeader)
    {
        return STATUS_INVALID_PARAMETER;
    }

    pContext->pIpHeader = pIpHeader;
    pContext->ulSourceAddress = pIpHeader->iph_src;
    pContext->ulDestinationAddress = pIpHeader->iph_dest;
    pContext->ulProtocolHeaderLength = ulProtocolHeaderLength;
    pContext->ucProtocol = pIpHeader->iph_protocol;

    switch (pContext->ucProtocol)
    {
        case NS_PROTOCOL_ICMP:
        {
            if (NULL == pvProtocolHeader
                || ulProtocolHeaderLength < FIELD_OFFSET(ICMP_HEADER, EncapsulatedIpHeader))
            {
                return STATUS_INVALID_PARAMETER;
            }

            pContext->pIcmpHeader = pvProtocolHeader;

            break;
        }

        case NS_PROTOCOL_TCP:
        {
            if (NULL == pvProtocolHeader
                || ulProtocolHeaderLength < sizeof(TCP_HEADER))
            {
                return STATUS_INVALID_PARAMETER;
            }

            pContext->pTcpHeader = pvProtocolHeader;
            pContext->usSourcePort = pContext->pTcpHeader->SourcePort;
            pContext->usDestinationPort = pContext->pTcpHeader->DestinationPort;            
            break;
        }

        case NS_PROTOCOL_UDP:
        {
            if (NULL == pvProtocolHeader
                || ulProtocolHeaderLength < sizeof(UDP_HEADER))
            {
                return STATUS_INVALID_PARAMETER;
            }

            pContext->pUdpHeader = pvProtocolHeader;
            pContext->usSourcePort = pContext->pUdpHeader->SourcePort;
            pContext->usDestinationPort = pContext->pUdpHeader->DestinationPort; 
            break;
        }

        default:
        {
            pContext->pvProtocolHeader = pvProtocolHeader;
            break;
        }
    }

    return STATUS_SUCCESS;
} // NsBuildPacketContext

NTSTATUS
NsInitializePacketManagement(
    VOID
    );

NTSTATUS
NsProcessOutgoingPacket(
    IPHeader UNALIGNED *pIpHeader,
    PVOID pvProtocolHeader,
    ULONG ulProtocolHeaderSize,
    PVOID *ppvIpSecContext
    );

NTSTATUS
NsProcessIncomingPacket(
    IPHeader UNALIGNED *pIpHeader,
    PVOID pvProtocolHeader,
    ULONG ulProtocolHeaderSize,
    PVOID pvIpSecContext
    );

VOID
NsShutdownPacketManagement(
   VOID
   );

#undef PNS_CONNECTION_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\nsipsec.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    NsIpSec.h
    
Abstract:

    External interface declarations for IpSec NAT shim

Author:

    Jonathan Burstein (jonburs) 10-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#pragma once

//
// Function Type Definitions
//

typedef NTSTATUS
(*PNS_PROCESS_OUTGOING_PACKET)(
    IN IPHeader UNALIGNED *pIpHeader,
    IN PVOID pvProtocolHeader,
    IN ULONG ulProtocolHeaderSize,
    OUT PVOID *ppvIpSecContext
    );

typedef NTSTATUS
(*PNS_PROCESS_INCOMING_PACKET)(
    IN IPHeader UNALIGNED *pIpHeader,
    IN PVOID pvProtocolHeader,
    IN ULONG ulProtocolHeaderSize,
    IN PVOID pvIpSecContext
    );

typedef NTSTATUS
(*PNS_CLEANUP_SHIM)(
    VOID
    );

//
// Structure Definitions
//

typedef struct _IPSEC_NATSHIM_FUNCTIONS
{
    OUT PNS_PROCESS_OUTGOING_PACKET pOutgoingPacketRoutine;
    OUT PNS_PROCESS_INCOMING_PACKET pIncomingPacketRoutine;
    OUT PNS_CLEANUP_SHIM pCleanupRoutine;
} IPSEC_NATSHIM_FUNCTIONS, *PIPSEC_NATSHIM_FUNCTIONS;

//
// Function Prototypes
//

NTSTATUS
NsInitializeShim(
    IN PDEVICE_OBJECT pIpSecDeviceObject,
    IN PIPSEC_NATSHIM_FUNCTIONS pShimFunctions
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\shim\precomp.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    precomp.h
    
Abstract:

    Precompilation header file for IpSec NAT shim

Author:

    Jonathan Burstein (jonburs) 10-July-2001
    
Environment:

    Kernel mode

Revision History:

--*/

#include <ntosp.h>
#include <zwapi.h>
#include <tcpipbase.h>

#include "NsDebug.h"
#include "NsProt.h"
#include "cache.h"
#include "NsPacket.h"
#include "NsConn.h"
#include "NsIcmp.h"
#include "NsInit.h"
#include "NsIpSec.h"
#include "NsTimer.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\acquire.h ===
VOID
IPSecCompleteIrp(
    PIRP pIrp,
    NTSTATUS ntStatus
    );

VOID
IPSecInvalidateHandle(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext
    );

NTSTATUS
IPSecValidateHandle(
	ULONG AcquireId,
    PIPSEC_ACQUIRE_CONTEXT *pIpsecAcquireContext,
    SA_STATE SAState
    );

VOID
IPSecAbortAcquire(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext
    );

NTSTATUS
IPSecCheckSetCancelRoutine(
    PIRP pIrp,
    PVOID pCancelRoutine
    );

NTSTATUS
IPSecSubmitAcquire(
    PSA_TABLE_ENTRY pLarvalSA,
    KIRQL OldIrq,
    BOOLEAN PostAcquire
    );

NTSTATUS
IPSecHandleAcquireRequest(
    PIRP pIrp,
    PIPSEC_POST_FOR_ACQUIRE_SA pIpsecPostAcquireSA
    );

VOID
IPSecAcquireIrpCancel(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    );

NTSTATUS
IPSecNotifySAExpiration(
    PSA_TABLE_ENTRY pInboundSA,
    PIPSEC_NOTIFY_EXPIRE pNotifyExpire,
    KIRQL OldIrq,
    BOOLEAN PostAcquire
    );

VOID
IPSecFlushSAExpirations(
    );

ULONG IPSecGetAcquireId( );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\ahxforms.h ===
NTSTATUS ah_nullinit (PALGO_STATE, ULONG);
NTSTATUS ah_nullupdate (PALGO_STATE, PUCHAR, ULONG);
NTSTATUS ah_nullfinish (PALGO_STATE, PUCHAR, ULONG);

NTSTATUS ah_hmacmd5init (PALGO_STATE, ULONG);
NTSTATUS ah_hmacmd5update (PALGO_STATE, PUCHAR, ULONG);
NTSTATUS ah_hmacmd5finish (PALGO_STATE, PUCHAR, ULONG);

NTSTATUS ah_hmacshainit (PALGO_STATE, ULONG);
NTSTATUS ah_hmacshaupdate (PALGO_STATE, PUCHAR, ULONG);
NTSTATUS ah_hmacshafinish (PALGO_STATE, PUCHAR, ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\acquire.c ===
#include "precomp.h"

#ifdef RUN_WPP
#include "acquire.tmh"
#endif

#pragma hdrstop


VOID
IPSecCompleteIrp(
    PIRP pIrp,
    NTSTATUS ntStatus
    )
/*++

Routine Description:

    This Routine handles calling the NT I/O system to complete an I/O.

Arguments:

    pIrp - Irp which needs to be completed.

    ntStatus - The completion status for the Irp.

Return Value:

    None.

--*/
{
    KIRQL kIrql;


#if DBG
    if (!NT_SUCCESS(ntStatus)) {
        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("IPSecCompleteIrp: Completion status = %X", ntStatus));
    }
#endif

    pIrp->IoStatus.Status = ntStatus;

    //
    // Set the cancel routine for the Irp to NULL or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP.
    //

    IoAcquireCancelSpinLock(&kIrql);
    IoSetCancelRoutine(pIrp, NULL);
    IoReleaseCancelSpinLock(kIrql);

    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    return;
}


VOID
IPSecInvalidateHandle(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext
    )
/*++

Routine Description:

    This routine invalidates an acquire handle by freeing the memory location.

Arguments:

    pIpsecAcquireContext - The Acquire context.

Return Value:

    None.

--*/
{
    ASSERT(pIpsecAcquireContext);

    if (pIpsecAcquireContext) {

        ASSERT(pIpsecAcquireContext->pSA);
        ASSERT(
            pIpsecAcquireContext->pSA->sa_AcquireId ==
            pIpsecAcquireContext->AcquireId
            );

        pIpsecAcquireContext->AcquireId = 0;

        IPSecFreeMemory(pIpsecAcquireContext);

    }

    return;
}


NTSTATUS
IPSecValidateHandle(
	ULONG AcquireId,
    PIPSEC_ACQUIRE_CONTEXT *pIpsecAcquireContext,
    SA_STATE SAState
    )
/*++

Routine Description:

    This routine validates an acquire handle by matching the unique signature
    in the handle with that in the SA and ensuring that the SA state matches 
    the SA state in the input.
    Called with Larval List Lock held; returns with it.

Arguments:

    pIpsecAcquireContext - The Acquire context.

    SAState - State in which the SA is expected to be in.

Return Value:

    NTSTATUS - Status after the validation.

--*/
{
    PSA_TABLE_ENTRY pSA = NULL;
    BOOL bFound = FALSE;
    PLIST_ENTRY pEntry = NULL;


    if (AcquireId < MIN_ACQUIRE_ID) {
        return  STATUS_UNSUCCESSFUL;
    }

    //
    // Walk through the larval SA list to see if there is an SA
    // with this context value.
    //

    for (pEntry = g_ipsec.LarvalSAList.Flink;
         pEntry != &g_ipsec.LarvalSAList;
         pEntry = pEntry->Flink) {

        pSA = CONTAINING_RECORD(
                  pEntry,
                  SA_TABLE_ENTRY,
                  sa_LarvalLinkage
                  );

        if (pSA->sa_AcquireId == AcquireId) {
            bFound = TRUE;
            break;
        }

    }

    if (bFound) {

	    *pIpsecAcquireContext = pSA->sa_AcquireCtx;

		if (!(*pIpsecAcquireContext)) {
            return  STATUS_UNSUCCESSFUL;
		}

        if (!(*pIpsecAcquireContext)->pSA) {
            return  STATUS_UNSUCCESSFUL;
        }

		if ((*pIpsecAcquireContext)->pSA != pSA) {
		   return STATUS_UNSUCCESSFUL;

		}

        if (pSA->sa_Signature == IPSEC_SA_SIGNATURE) {
            if (pSA->sa_State == SAState) {
                return  STATUS_SUCCESS;
            }
        }

    }

    return STATUS_UNSUCCESSFUL;
}


VOID
IPSecAbortAcquire(
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireContext
    )
/*++

Routine Description:

    This routine aborts the acquire operation because of insufficient
    resources or invalid parameters.

Arguments:

    pIpsecAcquireContext - The acquire context.

    Called with both the SADB and the LarvalSAList locks held; returns with them.

Return Value:

    None.

--*/
{
    PSA_TABLE_ENTRY pSA = NULL;
    PSA_TABLE_ENTRY pOutboundSA = NULL;
    BOOL bIsTimerStopped = FALSE;
    KIRQL kSPIIrql;


    pSA = pIpsecAcquireContext->pSA;

    ASSERT(pSA->sa_Flags & FLAGS_SA_TIMER_STARTED);

    bIsTimerStopped = IPSecStopTimer(&pSA->sa_Timer);

    if (!bIsTimerStopped) {
        return;
    }

    pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;

    //
    // The larval list is already locked so that this SA does not go away.
    //
    ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

    if (pSA->sa_AcquireCtx) {
        IPSecInvalidateHandle(pSA->sa_AcquireCtx);
        pSA->sa_AcquireCtx = NULL;
    }

    //
    // Remove from the larval list.
    //
    IPSecRemoveEntryList(&pSA->sa_LarvalLinkage);
    IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);

    //
    // Flush all the queued packets for this SA.
    //
    IPSecFlushQueuedPackets(pSA, STATUS_TIMEOUT);

    //
    // Remove the SA from the inbound SA list.
    //
    AcquireWriteLock(&g_ipsec.SPIListLock, &kSPIIrql);
    IPSecRemoveSPIEntry(pSA);
    ReleaseWriteLock(&g_ipsec.SPIListLock, kSPIIrql);

    //
    // Also remove the SA from the filter list.
    //
    if (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
        pSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
        IPSecRemoveEntryList(&pSA->sa_FilterLinkage);
    }

    if (pSA->sa_RekeyOriginalSA) {
        ASSERT(pSA->sa_Flags & FLAGS_SA_REKEY);
        ASSERT(pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA == pSA);
        ASSERT(pSA->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

        pSA->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
        pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
        pSA->sa_RekeyOriginalSA = NULL;
    }

    //
    // Invalidate the associated cache entry.
    //
    IPSecInvalidateSACacheEntry(pSA);

    pOutboundSA = pSA->sa_AssociatedSA;

    if (pOutboundSA) {
        pSA->sa_AssociatedSA = NULL;
        if (pOutboundSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
            pOutboundSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
            IPSecRemoveEntryList(&pOutboundSA->sa_FilterLinkage);
        }

        //
        // Invalidate the associated cache entry.
        //
        IPSecInvalidateSACacheEntry(pOutboundSA);

        IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
        IPSEC_DEC_TUNNELS(pOutboundSA);
        IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

        IPSEC_DEBUG(LL_A,DBF_REF, ("IPSecAbortAcquire: Outbound SA Dereference."));

        IPSecStopTimerDerefSA(pOutboundSA);
    } else {
        ASSERT (pSA->sa_State == STATE_SA_LARVAL_ACTIVE || pSA->sa_State == STATE_SA_LARVAL);
    }

    IPSecDerefSA(pSA);

    return;
}


NTSTATUS
IPSecCheckSetCancelRoutine(
    PIRP pIrp,
    PVOID pCancelRoutine
    )
/*++

Routine Description:

    This Routine sets the cancel routine for an Irp.

Arguments:

    pIrp - Irp for which the cancel routine is to be set.

    pCancelRoutine - Cancel routine to be set in the Irp.

Return Value:

    NTSTATUS - Status for the request.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Check if the irp has been cancelled and if not, then set the
    // irp cancel routine.
    //

    IoAcquireCancelSpinLock(&pIrp->CancelIrql);

    if (pIrp->Cancel) {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        ntStatus = STATUS_CANCELLED;
    }
    else {
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp, pCancelRoutine);
        ntStatus = STATUS_SUCCESS;
    }

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    return (ntStatus);
}


NTSTATUS
IPSecSubmitAcquire(
    PSA_TABLE_ENTRY pLarvalSA,
    KIRQL OldIrq,
    BOOLEAN PostAcquire
    )
/*++

Routine Description:

    This function is used to submit an Acquire request to the key manager

Arguments:

    pLarvalSA - larval SA that needs to be negotiated

    OldIrq - prev irq - lock released here.

    NOTE: called with AcquireInfo lock held.

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    NTSTATUS                status;
    PIRP                    pIrp;

    if (!g_ipsec.AcquireInfo.Irp) {
        //
        // the irp either never made it down here, or it was cancelled,
        // so drop all frames
        //
        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("IPSecSubmitAcquire: Irp is NULL, returning\r"));
        if (!PostAcquire) {
                RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
            }

        return  STATUS_BAD_NETWORK_PATH;
    } else if (!g_ipsec.AcquireInfo.ResolvingNow) {
        PIPSEC_ACQUIRE_CONTEXT  pAcquireCtx;
        PVOID   pvIoBuffer;

        //
        // Irp is free now - use it
        //
        pIrp = g_ipsec.AcquireInfo.Irp;

        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Using Irp.. : %p", pIrp));

        //
        // Get the Acquire Context and associate with the Larval SA
        //
        pAcquireCtx = IPSecGetAcquireContext();

        if (!pAcquireCtx) {
            IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Failed to get acquire ctx"));
            if (!PostAcquire){
                    RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock,OldIrq);
                }
            return  STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Set ResolvingNow only after memory allocation (282645).
        //
        g_ipsec.AcquireInfo.ResolvingNow = TRUE;

        pAcquireCtx->AcquireId = IPSecGetAcquireId();
        pAcquireCtx->pSA = pLarvalSA;
        pLarvalSA->sa_AcquireCtx = pAcquireCtx;
        pLarvalSA->sa_AcquireId = pAcquireCtx->AcquireId;

        //
        // Set up the Irp params
        //
        pvIoBuffer = pIrp->AssociatedIrp.SystemBuffer;

        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->IdentityInfo = NULL;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->Context = UlongToHandle(pAcquireCtx->AcquireId);
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->PolicyId = pLarvalSA->sa_Filter->PolicyId;

        //
        // Instead of reversing, use the originating filters addresses
        //
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->SrcAddr = pLarvalSA->SA_DEST_ADDR;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->SrcMask = pLarvalSA->SA_DEST_MASK;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestAddr = pLarvalSA->SA_SRC_ADDR;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestMask = pLarvalSA->SA_SRC_MASK;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->Protocol = pLarvalSA->SA_PROTO;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->TunnelFilter = pLarvalSA->sa_Filter->TunnelFilter;
        //
        // the tunnel addr is in the corresp. outbound filter.
        //
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->TunnelAddr = pLarvalSA->sa_Filter->TunnelAddr;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->InboundTunnelAddr = pLarvalSA->sa_TunnelAddr;

        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->SrcPort = SA_DEST_PORT(pLarvalSA);
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestPort = SA_SRC_PORT(pLarvalSA);
        
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestType = 0;
        if (IS_BCAST_DEST(pLarvalSA->sa_DestType)) {
            ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestType |= IPSEC_BCAST;
        }
        if (IS_MCAST_DEST(pLarvalSA->sa_DestType)) {
            ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestType |= IPSEC_MCAST;
        }
        
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->SrcEncapPort = pLarvalSA->sa_EncapContext.wSrcEncapPort;
        ((PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer)->DestEncapPort = pLarvalSA->sa_EncapContext.wDesEncapPort;

        pIrp->IoStatus.Information = sizeof(IPSEC_POST_FOR_ACQUIRE_SA);

        g_ipsec.AcquireInfo.InMe = FALSE;

        pLarvalSA->sa_Flags &= ~FLAGS_SA_PENDING;

        

        if (PostAcquire) {
            status = STATUS_SUCCESS;
        } else {
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock,OldIrq);
            IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Completing Irp.. : %p", pIrp));
            IPSecCompleteIrp(pIrp, STATUS_SUCCESS);
            status = STATUS_PENDING;
        }

        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("IPSecSubmitAcquire: submitted context: %p, SA: %p",
                            pAcquireCtx,
                            pLarvalSA));
    } else {
        //
        // The irp is busy negotiating another SA
        // Queue the Larval SA
        //
        InsertTailList( &g_ipsec.AcquireInfo.PendingAcquires,
                        &pLarvalSA->sa_PendingLinkage);

        pLarvalSA->sa_Flags |= FLAGS_SA_PENDING;

        status = STATUS_PENDING;
        if (!PostAcquire){
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
            }

        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("IPSecSubmitAcquire: queued SA: %p", pLarvalSA));
    }

    return  status;
}


NTSTATUS
IPSecHandleAcquireRequest(
    PIRP pIrp,
    PIPSEC_POST_FOR_ACQUIRE_SA pIpsecPostAcquireSA
    )
/*++

Routine Description:

    This routine receives an acquire request from the key manager and
    either completes it instantly to submit a new SA negotiation or pends
    it for further negotiations.

Arguments:

    pIrp - The Irp.

    pIpsecPostAcquireSA - Buffer for filling in the policy ID for forcing
                          an SA negotiation.

Return Value:

    STATUS_PENDING - If the buffer is to be held on to, the normal case.

--*/
{
    NTSTATUS        status = STATUS_PENDING;
    KIRQL           OldIrq;
    PVOID           Context;
    BOOLEAN         fIrpCompleted = FALSE;
    PSA_TABLE_ENTRY pLarvalSA;

    // Make sure this lock is not released till the end of
    // this function
    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);

    if (g_ipsec.AcquireInfo.InMe) {
        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Irp re-submited!: %p", g_ipsec.AcquireInfo.Irp));
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
        return  STATUS_INVALID_PARAMETER;
    }

    g_ipsec.AcquireInfo.Irp = pIrp;

    // ASSERT(g_ipsec.AcquireInfo.ResolvingNow);

    g_ipsec.AcquireInfo.ResolvingNow = FALSE;

    //
    // if there are pending SA negotiations, submit next
    //
    while (TRUE) {
        if (!IsListEmpty(&g_ipsec.AcquireInfo.PendingAcquires)) {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&g_ipsec.AcquireInfo.PendingAcquires);

            pLarvalSA = CONTAINING_RECORD(  pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_PendingLinkage);

            ASSERT(pLarvalSA->sa_State == STATE_SA_LARVAL);
            ASSERT(pLarvalSA->sa_Flags & FLAGS_SA_PENDING);

            pLarvalSA->sa_Flags &= ~FLAGS_SA_PENDING;

            //
            // submit... will not release the AcquireInfo lock if PostAcquire is true
            //
            status = IPSecSubmitAcquire(pLarvalSA, OldIrq, TRUE);

            //
            // if it failed then complete the irp now
            //
            if (NT_SUCCESS(status)) {              
                fIrpCompleted = TRUE;
                IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Acquire Irp completed inline"));
                break;
            }
        } else if (!IsListEmpty(&g_ipsec.AcquireInfo.PendingNotifies)) {
            PLIST_ENTRY     pEntry;
            PIPSEC_NOTIFY_EXPIRE pNotifyExpire;

            pEntry = RemoveHeadList(&g_ipsec.AcquireInfo.PendingNotifies);


            pNotifyExpire = CONTAINING_RECORD(  pEntry,
                                                IPSEC_NOTIFY_EXPIRE,
                                                notify_PendingLinkage);

            ASSERT(pNotifyExpire);

            //
            // submit... releases the AcquireInfo lock
            //
            status = IPSecNotifySAExpiration(NULL, pNotifyExpire, OldIrq, TRUE);

            //
            // if it failed then complete the irp now
            //
            if (NT_SUCCESS(status)) {
                fIrpCompleted = TRUE;
                IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Acquire Irp completed inline"));
                break;
            }


        } else {
            break;
        }
    }

    //
    // We are holding onto the Irp, so set the cancel routine.
    //
    if (!fIrpCompleted) {
        
        status = IPSecCheckSetCancelRoutine(pIrp, IPSecAcquireIrpCancel);

        if (!NT_SUCCESS(status)) {
            //
            // the irp got cancelled so complete it now
            //
            g_ipsec.AcquireInfo.Irp = NULL;
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);

            // IPSecCompleteIrp(pIrp, status);
        } else {
            g_ipsec.AcquireInfo.InMe = TRUE;
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
            status = STATUS_PENDING;
        }
    } else {
        g_ipsec.AcquireInfo.InMe = FALSE;
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
    }

    return  status;
}


VOID
IPSecAcquireIrpCancel(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    )
/*++

Routine Description:

    This is the cancel routine for the Acquire Irp.
    It is called with IoCancelSpinLock held - must release this lock before exit.

Arguments:

    pDeviceObject - Device object for the Irp.

    pIrp - The irp itself.

Return Value:

    None.

--*/
{
    KIRQL kIrql;
    KIRQL kAcquireIrql;


    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("IPSecAcquireIrpCancel: Acquire Irp cancelled"));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);
    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &kAcquireIrql);

    if (g_ipsec.AcquireInfo.Irp && g_ipsec.AcquireInfo.InMe) {

        pIrp->IoStatus.Status = STATUS_CANCELLED;
        g_ipsec.AcquireInfo.Irp = NULL;
        g_ipsec.AcquireInfo.InMe = FALSE;

        //
        // Flush larval SAs.
        //

        IPSecFlushLarvalSAList();

        //
        // Flush SA expiration notifies.
        //

        IPSecFlushSAExpirations();

        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, kAcquireIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    }
    else {

        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, kAcquireIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    }

    return;
}


NTSTATUS
IPSecNotifySAExpiration(
    PSA_TABLE_ENTRY pInboundSA,
    PIPSEC_NOTIFY_EXPIRE pNotifyExpire,
    KIRQL OldIrq,
    BOOLEAN PostAcquire
    )
/*++

Routine Description:

    Notify Oakley through Acquire that SA has expired.

Arguments:

    SA that is to expire

Return Value:

    None

--*/
{
    PIPSEC_NOTIFY_EXPIRE    pNewNotifyExpire;
    NTSTATUS                status;
    PIRP                    pIrp;

#if DBG
    if ((IPSecDebug & DBF_EXTRADIAGNOSTIC) && pInboundSA) {
        LARGE_INTEGER   CurrentTime;

        NdisGetCurrentSystemTime(&CurrentTime);
        IPSEC_DEBUG(LL_A, DBF_REKEY,
            ("NotifySAExpiration: %lx, %lx, %lx, %lx, %lx",
                CurrentTime.LowPart,
                pInboundSA->SA_DEST_ADDR,
                pInboundSA->SA_SRC_ADDR,
                pInboundSA->sa_SPI,
                pInboundSA->sa_AssociatedSA? pInboundSA->sa_AssociatedSA->sa_SPI: 0));
    }
#endif

    //
    // Check if there is a need to notify.
    //
    if (pInboundSA &&
        ((pInboundSA->sa_Flags & FLAGS_SA_NOTIFY_PERFORMED) ||
         (pInboundSA->sa_State == STATE_SA_LARVAL))) {
        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("IPSecSubmitAcquire: already notified, returning"));
        if (!PostAcquire){
                RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
            }

        return  STATUS_UNSUCCESSFUL;
    }

    //
    // Set the flag so we won't notify again - only set flag in non-queued case.
    //
    if (pInboundSA) {
        pInboundSA->sa_Flags |= FLAGS_SA_NOTIFY_PERFORMED;
    }

    if (!g_ipsec.AcquireInfo.Irp) {
        //
        // the irp either never made it down here, or it was cancelled,
        // so drop all frames
        //
        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("IPSecSubmitAcquire: Irp is NULL, returning\r"));
        if (!PostAcquire){
                RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
            }

        return  STATUS_BAD_NETWORK_PATH;
    } else if (!g_ipsec.AcquireInfo.ResolvingNow) {
        PIPSEC_POST_EXPIRE_NOTIFY   pNotify;

        //
        // Irp is free now - use it
        //
        g_ipsec.AcquireInfo.ResolvingNow = TRUE;
        pIrp = g_ipsec.AcquireInfo.Irp;

        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Using Irp.. : %p", pIrp));

        pNotify = (PIPSEC_POST_EXPIRE_NOTIFY)pIrp->AssociatedIrp.SystemBuffer;

        pNotify->IdentityInfo = NULL;
        pNotify->Context = NULL;

        if (pInboundSA) {
            // Reverse everything since notifies notify for Outbound SAs

            pNotify->SrcAddr = pInboundSA->SA_DEST_ADDR;
            pNotify->SrcMask = pInboundSA->SA_DEST_MASK;
            pNotify->DestAddr = pInboundSA->SA_SRC_ADDR;
            pNotify->DestMask = pInboundSA->SA_SRC_MASK;
            pNotify->Protocol = pInboundSA->SA_PROTO;
            pNotify->SrcPort = SA_DEST_PORT(pInboundSA);
            pNotify->DestPort = SA_SRC_PORT(pInboundSA);
            pNotify->InboundSpi = pInboundSA->sa_SPI;
            pNotify->SrcEncapPort= pInboundSA->sa_EncapContext.wDesEncapPort;
            pNotify->DestEncapPort= pInboundSA->sa_EncapContext.wSrcEncapPort;
            pNotify->PeerPrivateAddr =pInboundSA->sa_PeerPrivateAddr;

            RtlCopyMemory(  &pNotify->CookiePair,
                            &pInboundSA->sa_CookiePair,
                            sizeof(IKE_COOKIE_PAIR));

            if (pInboundSA->sa_Flags & FLAGS_SA_DELETE_BY_IOCTL) {
                pNotify->Flags = IPSEC_SA_INTERNAL_IOCTL_DELETE;
            } else {
                pNotify->Flags = 0;
            }

            if (pInboundSA->sa_AssociatedSA) {
                pNotify->OutboundSpi = pInboundSA->sa_AssociatedSA->sa_SPI;

                if (pInboundSA->sa_AssociatedSA->sa_Filter) {
                    pNotify->TunnelAddr = pInboundSA->sa_AssociatedSA->sa_Filter->TunnelAddr;
                    pNotify->InboundTunnelAddr = pInboundSA->sa_TunnelAddr;
                } else {
                    pNotify->TunnelAddr = IPSEC_INVALID_ADDR;
                }
            } else {
                ASSERT (pInboundSA->sa_State == STATE_SA_LARVAL_ACTIVE ||
                        pInboundSA->sa_State == STATE_SA_LARVAL);
                pNotify->OutboundSpi = IPSEC_INVALID_SPI;
                pNotify->TunnelAddr = IPSEC_INVALID_ADDR;
            }
        } else {
            ASSERT(pNotifyExpire);

            if (pNotifyExpire) {
                pNotify->SrcAddr = pNotifyExpire->SA_DEST_ADDR;
                pNotify->SrcMask = pNotifyExpire->SA_DEST_MASK;
                pNotify->DestAddr = pNotifyExpire->SA_SRC_ADDR;
                pNotify->DestMask = pNotifyExpire->SA_SRC_MASK;
                pNotify->Protocol = pNotifyExpire->SA_PROTO;

                pNotify->TunnelAddr = pNotifyExpire->sa_TunnelAddr;
                pNotify->InboundTunnelAddr = pNotifyExpire->sa_TunnelAddr;

                pNotify->SrcPort = SA_DEST_PORT(pNotifyExpire);
                pNotify->DestPort = SA_SRC_PORT(pNotifyExpire);

                pNotify->InboundSpi = pNotifyExpire->InboundSpi;
                pNotify->OutboundSpi = pNotifyExpire->OutboundSpi;

                pNotify->SrcEncapPort = pNotifyExpire->sa_EncapContext.wDesEncapPort;
                pNotify->DestEncapPort = pNotifyExpire->sa_EncapContext.wSrcEncapPort;
                pNotify->PeerPrivateAddr =pNotifyExpire->sa_PeerPrivateAddr;

                RtlCopyMemory(  &pNotify->CookiePair,
                                &pNotifyExpire->sa_CookiePair,
                                sizeof(IKE_COOKIE_PAIR));
                pNotify->Flags = pNotifyExpire->Flags;

                IPSecFreeMemory(pNotifyExpire);
            }
        }

        pIrp->IoStatus.Information = sizeof(IPSEC_POST_FOR_ACQUIRE_SA);

        g_ipsec.AcquireInfo.InMe = FALSE;

        

        if (PostAcquire) {
            IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Completing Irp in driver.c.. : %p", pIrp));
            status = STATUS_SUCCESS;
        } else {
            RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock,OldIrq);
            IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Completing Irp.. : %p", pIrp));
            IPSecCompleteIrp(pIrp, STATUS_SUCCESS);
            status = STATUS_PENDING;
        }

        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("IPSecSubmitAcquire(Notify)"));
    } else {
        ASSERT(pInboundSA);

        //
        // The irp is busy negotiating another SA
        // Queue the Larval SA
        //
        if (pNotifyExpire) {
            //
            // Somethings bad.  We've already queued up once, and we still
            // can't send.  Just drop it.
            //
            IPSecFreeMemory(pNotifyExpire);
            if (!PostAcquire){
                    RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
                }
            return STATUS_UNSUCCESSFUL;
        }

        pNewNotifyExpire = IPSecGetNotifyExpire();

        if (!pNewNotifyExpire || !pInboundSA) {
            IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("Failed to get Notify Memory"));
            if (!PostAcquire){
                    RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock,OldIrq);
                }
            return  STATUS_INSUFFICIENT_RESOURCES;
        }

        pNewNotifyExpire->sa_uliSrcDstAddr = pInboundSA->sa_uliSrcDstAddr;
        pNewNotifyExpire->sa_uliSrcDstMask = pInboundSA->sa_uliSrcDstMask;
        pNewNotifyExpire->sa_uliProtoSrcDstPort=pInboundSA->sa_uliProtoSrcDstPort;

        pNewNotifyExpire->InboundSpi = pInboundSA->sa_SPI;
        pNewNotifyExpire->sa_InboundTunnelAddr = pInboundSA->sa_TunnelAddr;

        RtlCopyMemory(&pNewNotifyExpire->sa_EncapContext,
                      &pInboundSA->sa_EncapContext,
                      sizeof(IPSEC_UDP_ENCAP_CONTEXT));

        RtlCopyMemory(  &pNewNotifyExpire->sa_CookiePair,
                        &pInboundSA->sa_CookiePair,
                        sizeof(IKE_COOKIE_PAIR));

        if (pInboundSA->sa_Flags & FLAGS_SA_DELETE_BY_IOCTL) {
            pNewNotifyExpire->Flags = IPSEC_SA_INTERNAL_IOCTL_DELETE;
        } else {
            pNewNotifyExpire->Flags = 0;
        }

        if (pInboundSA->sa_AssociatedSA) {
            pNewNotifyExpire->OutboundSpi = pInboundSA->sa_AssociatedSA->sa_SPI;

            if (pInboundSA->sa_AssociatedSA->sa_Filter) {
                pNewNotifyExpire->sa_TunnelAddr = pInboundSA->sa_AssociatedSA->sa_Filter->TunnelAddr;
            } else {
                pNewNotifyExpire->sa_TunnelAddr = IPSEC_INVALID_ADDR;
            }
        } else {
            ASSERT (pInboundSA->sa_State == STATE_SA_LARVAL_ACTIVE ||
                    pInboundSA->sa_State == STATE_SA_LARVAL);
            pNewNotifyExpire->OutboundSpi = IPSEC_INVALID_SPI;
            pNewNotifyExpire->sa_TunnelAddr = IPSEC_INVALID_ADDR;
        }

        InsertTailList( &g_ipsec.AcquireInfo.PendingNotifies,
                        &pNewNotifyExpire->notify_PendingLinkage);

        status = STATUS_PENDING;
        if (!PostAcquire){
                RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
            }

        IPSEC_DEBUG(LL_A,DBF_ACQUIRE, ("IPSecSubmitAcquire(Notify): queue SA"));
    }

    return  status;
}

 
VOID
IPSecFlushSAExpirations(
    )
/*++

Routine Description:

    When the Acquire Irp is cancelled, this routine is called to flush all the 
    pending SA expiration notifies.

    Called with SADB lock held (first acquisition); returns with it.
    Called with AcquireInfo.Lock held (second acquisition); returns with it.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIPSEC_NOTIFY_EXPIRE pIpsecNotifyExpire = NULL;
    PLIST_ENTRY pListEntry = NULL;


    while (!IsListEmpty(&g_ipsec.AcquireInfo.PendingNotifies)) {

        pListEntry = RemoveHeadList(
                         &g_ipsec.AcquireInfo.PendingNotifies
                         );

        pIpsecNotifyExpire = CONTAINING_RECORD(
                                 pListEntry,
                                 IPSEC_NOTIFY_EXPIRE,
                                 notify_PendingLinkage
                                 );

        IPSecFreeMemory(pIpsecNotifyExpire);

    }

    return;
}


ULONG IPSecGetAcquireId()
{

   static ULONG LocalAcquireId = MIN_ACQUIRE_ID;  
   ULONG NewAcquireId;
   
   NewAcquireId = IPSEC_INCREMENT(LocalAcquireId);

	while (NewAcquireId < MIN_ACQUIRE_ID) {
		NewAcquireId = IPSEC_INCREMENT(LocalAcquireId);   
	}

   return NewAcquireId;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\debug.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains all the debugging related structures/macros.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/

#define DBF_EXTRADIAGNOSTIC 0x80000000

#ifdef RUN_WPP

#include "ipsecwpp.h"

#if DBG

#define IPSEC_DEBUG_KD_ONLY(_Flag, _Print) { \
    if (IPSecDebug & (_Flag)) { \
        DbgPrint ("IPSEC: "); \
        DbgPrint _Print; \
        DbgPrint ("\n"); \
    } \
}

#define IPSEC_PRINT_CONTEXT(_Context) 
#define IPSEC_PRINT_MDL(_Mdl)

#else // DBG

#define IPSEC_DEBUG_KD_ONLY(_Flag, _Print)

#endif

#else // RUN_WPP

#if DBG

#define DBF_LOAD        0x00000001
#define DBF_AH          0x00000002
#define DBF_IOCTL       0x00000004
#define DBF_HUGHES      0x00000008
#define DBF_ESP         0x00000010
#define DBF_AHEX        0x00000020
#define DBF_PATTERN     0x00000040
#define DBF_SEND        0x00000080
#define DBF_PARSE       0x00000100
#define DBF_PMTU        0x00000200
#define DBF_ACQUIRE     0x00000400
#define DBF_HASH        0x00000800
#define DBF_CLEARTEXT   0x00001000
#define DBF_TIMER       0x00002000
#define DBF_REF         0x00004000
#define DBF_SA          0x00008000
#define DBF_ALL         0x00010000
#define DBF_POOL        0x00020000
#define DBF_TUNNEL      0x00040000
#define DBF_HW          0x00080000
#define DBF_COMP        0x00100000
#define DBF_SAAPI       0x00200000
#define DBF_CACHE       0x00400000
#define DBF_TRANS       0x00800000
#define DBF_MDL         0x01000000
#define DBF_REKEY       0x02000000
#define DBF_GENHASH     0x04000000
#define DBF_HWAPI       0x08000000
#define DBF_GPC         0x10000000
#define DBF_NATSHIM     0x20000000
#define DBF_BOOTTIME     0x40000000

#define IPSEC_DEBUG(_Level,_Flag, _Print) { \
    if (IPSecDebug & (_Flag)) { \
        DbgPrint ("IPSEC: "); \
        DbgPrint _Print; \
        DbgPrint ("\n"); \
    } \
}

#define IPSEC_DEBUG_KD_ONLY(_Flag, _Print) { \
    if (IPSecDebug & (_Flag)) { \
        DbgPrint ("IPSEC: "); \
        DbgPrint _Print; \
        DbgPrint ("\n"); \
    } \
}

#define IPSEC_PRINT_MDL(_Mdl) { \
    if ((_Mdl) == NULL) {   \
        IPSEC_DEBUG(LL_A, DBF_MDL, ("IPSEC Mdl is NULL"));     \
    }   \
    if (IPSecDebug & DBF_MDL) { \
        PNDIS_BUFFER pBuf = _Mdl;   \
        while (pBuf != NULL) {  \
            IPSEC_DEBUG(LL_A, DBF_MDL, ("pBuf: %lx, size: %d", pBuf, pBuf->ByteCount));     \
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);   \
        }   \
    }   \
}

#define IPSEC_PRINT_CONTEXT(_Context) { \
    PIPSEC_SEND_COMPLETE_CONTEXT pC = (PIPSEC_SEND_COMPLETE_CONTEXT)(_Context);   \
    if (pC == NULL) {   \
        IPSEC_DEBUG(LL_A, DBF_MDL, ("IPSEC Context is NULL"));     \
    } else if (IPSecDebug & DBF_MDL) { \
        DbgPrint("IPSEC: Context->Flags: %lx", pC->Flags);    \
        if (pC->OptMdl) \
            DbgPrint("IPSEC: Context->OptMdl: %lx", pC->OptMdl);  \
        if (pC->OriAHMdl) \
            DbgPrint("IPSEC: Context->OriAHMdl: %lx", pC->OriAHMdl);  \
        if (pC->OriHUMdl) \
            DbgPrint("IPSEC: Context->OriHUMdl: %lx", pC->OriHUMdl);  \
        if (pC->OriTuMdl) \
            DbgPrint("IPSEC: Context->OriTuMdl: %lx", pC->OriTuMdl);  \
        if (pC->PrevMdl) \
            DbgPrint("IPSEC: Context->PrevMdl: %lx", pC->PrevMdl);    \
        if (pC->PrevTuMdl) \
            DbgPrint("IPSEC: Context->PrevTuMdl: %lx", pC->PrevTuMdl);\
        if (pC->AHMdl) \
            DbgPrint("IPSEC: Context->AHMdl: %lx", pC->AHMdl);    \
        if (pC->AHTuMdl) \
            DbgPrint("IPSEC: Context->AHTuMdl: %lx", pC->AHTuMdl);\
        if (pC->PadMdl) \
            DbgPrint("IPSEC: Context->PadMdl: %lx", pC->PadMdl);  \
        if (pC->PadTuMdl) \
            DbgPrint("IPSEC: Context->PadTuMdl: %lx", pC->PadTuMdl);  \
        if (pC->HUMdl) \
            DbgPrint("IPSEC: Context->HUMdl: %lx", pC->HUMdl);    \
        if (pC->HUTuMdl) \
            DbgPrint("IPSEC: Context->HUTuMdl: %lx", pC->HUTuMdl);\
        if (pC->BeforePadMdl) \
            DbgPrint("IPSEC: Context->BeforePadMdl: %lx", pC->BeforePadMdl);  \
        if (pC->BeforePadTuMdl) \
            DbgPrint("IPSEC: Context->BeforePadTuMdl: %lx", pC->BeforePadTuMdl);  \
        if (pC->HUHdrMdl) \
            DbgPrint("IPSEC: Context->HUHdrMdl: %lx", pC->HUHdrMdl);  \
        if (pC->OriAHMdl2) \
            DbgPrint("IPSEC: Context->OriAHMdl2: %lx", pC->OriAHMdl2);\
        if (pC->PrevAHMdl2) \
            DbgPrint("IPSEC: Context->PrevAHMdl2: %lx", pC->PrevAHMdl2);  \
        if (pC->AHMdl2) \
            DbgPrint("IPSEC: Context->AHMdl2: %lx", pC->AHMdl2);  \
    }   \
}

#else // DBG

#define IPSEC_DEBUG_KD_ONLY(_Flag, _Print)
#define IPSEC_DEBUG(_Level, _Flag, _Print)
#define IPSEC_PRINT_MDL(_Mdl)
#define IPSEC_PRINT_CONTEXT(_Context)

#endif // DBG

#define WPP_INIT_TRACING(x,y)
#define WPP_CLEANUP(x)

#endif // else RUN_WPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\ah.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ah.c

Abstract:

    This module contains the code to create/verify Authentication Headers.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"

#ifdef RUN_WPP
#include "ah.tmh"
#endif

//
// This array assumes one-to-one correspondence with the algoIds and
// their order in ipsec.h.
//
#ifndef _TEST_PERF
AUTH_ALGO  auth_algorithms[] = {
{ ah_nullinit, ah_nullupdate, ah_nullfinish, MD5DIGESTLEN},
{ ah_hmacmd5init, ah_hmacmd5update, ah_hmacmd5finish, MD5DIGESTLEN},
{ ah_hmacshainit, ah_hmacshaupdate, ah_hmacshafinish, A_SHA_DIGEST_LEN},
};
#else
AUTH_ALGO  auth_algorithms[] = {
{ ah_nullinit, ah_nullupdate, ah_nullfinish, MD5DIGESTLEN},
{ ah_nullinit, ah_nullupdate, ah_nullfinish, MD5DIGESTLEN},
{ ah_nullinit, ah_nullupdate, ah_nullfinish, A_SHA_DIGEST_LEN},
};
#endif


NTSTATUS
IPSecCreateAH(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PVOID           IPContext,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PVOID           *ppNewData,
    OUT     PVOID           *ppSCContext,
    OUT     PULONG          pExtraBytes,
    IN      ULONG           HdrSpace,
    IN      BOOLEAN         fSrcRoute,
    IN      BOOLEAN         fCryptoOnly
    )
/*++

Routine Description:

    Create the AH, given the packet. On the send side.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header. PNDIS_BUFFER

    pSA - Sec. Assoc. entry

    ppNewData - the new MDL chain to be used by TCPIP

    ppSCContext - send complete context used to clean up IPSEC headers

    pExtraBytes - the header expansion caused by this IPSEC header

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PNDIS_BUFFER    pAHBuffer;
    PNDIS_BUFFER    pHdrBuf = NULL;
    PNDIS_BUFFER    pOptBuf = NULL;
    AH          UNALIGNED         *pAH;
    IPHeader UNALIGNED * pIPH;
    ULONG       hdrLen;
    PIPSEC_SEND_COMPLETE_CONTEXT pContext;
    PAUTH_ALGO  pAlgo;
    ULONG       ahLen;
    ULONG       ipNext;
    IPHeader UNALIGNED * pIPH2;
    UCHAR       pAHData[MAX_AH_OUTPUT_LEN];
    ULONG       totalBytes = 0;
    ULONG       saveFlags = 0;
    ULONG       Seq;
    USHORT      IPLength;   
    PNDIS_BUFFER    pSaveDataLinkage = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
    PNDIS_BUFFER    pSaveOptLinkage = NULL;
    BOOLEAN fOuterAH = ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                        (((Index == 1) && !pSA->COMP_ALGO(0)) || (Index == 2)));
    BOOLEAN fTunnel = ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                       ((Index == 0) || ((Index == 1) && pSA->COMP_ALGO(0))));
    BOOLEAN fMuteDest = fSrcRoute && !fTunnel;
    Interface * DestIF = (Interface *) IPContext;


    IPSEC_DEBUG(LL_A, DBF_AH, ("Entering IPSecCreateAH"));

#if DBG
    IPSEC_DEBUG(LL_A,DBF_MDL, ("Entering IPSecCreateAH"));
    IPSEC_PRINT_CONTEXT(*ppSCContext);
    IPSEC_PRINT_MDL(pData);
#endif

    ASSERT(pSA->sa_Operation[Index] == Auth);

    if (pSA->INT_ALGO(Index) > NUM_AUTH_ALGOS) {
        return  STATUS_INVALID_PARAMETER;
    }
    pAlgo = &(auth_algorithms[pSA->INT_ALGO(Index)]);

    ahLen = sizeof(AH) + pSA->sa_TruncatedLen * sizeof(UCHAR);

    //
    // If ESP was done previously, then dont alloc the context since we
    // can use the one alloced in ESP processing
    //
    if (*ppSCContext == NULL) {
        pContext = IPSecAllocateSendCompleteCtx(IPSEC_TAG_AH);

        if (!pContext) {
            IPSEC_DEBUG(LL_A,DBF_AH, ("Failed to alloc. SendCtx"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IPSEC_INCREMENT(g_ipsec.NumSends);

        IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));

#if DBG
        RtlCopyMemory(pContext->Signature, "ISC1", 4);
#endif
        *ppSCContext = pContext;
    } else {
        //
        // Piggybacking on ESP Context
        //
        pContext = *ppSCContext;
        saveFlags = pContext->Flags;
    }

    //
    // Get buffer for AH since no space reserved in the stack.  Allocate enough for
    // the full hash, but hack the len to only truncated length.
    //
    IPSecAllocateBuffer(&status,
                        &pAHBuffer,
                        (PUCHAR *)&pAH,
                        ahLen+(pAlgo->OutputLen - pSA->sa_TruncatedLen),
                        IPSEC_TAG_AH);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A,DBF_AH, ("Failed to alloc. AH MDL"));
        pContext->Flags = saveFlags;
        return status;
    }

    NdisAdjustBufferLength(pAHBuffer, ahLen);

    pIPH = (IPHeader UNALIGNED *)pIPHeader;
    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    if (fTunnel) {
        PNDIS_BUFFER    pSrcOptBuf;
        PUCHAR          pOpt;
        PUCHAR          pSrcOpt;
        ULONG           optLen = 0;

        IPSEC_DEBUG(LL_A,DBF_AH, ("AH Tunnel mode..."));

        //
        // Allocate an MDL for the new cleartext IP  header
        //
        IPSecAllocateBuffer(&status,
                            &pHdrBuf,
                            (PUCHAR *)&pIPH2,
                            sizeof(IPHeader),
                            IPSEC_TAG_AH);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(LL_A,DBF_AH, ("Failed to alloc. PAD MDL"));
            IPSecFreeBuffer(&ntstatus, pAHBuffer);
            pContext->Flags = saveFlags;
            return status;
        }

        *pExtraBytes += ahLen + sizeof(IPHeader);

        //
        // if we are going to fragment, and were tunneling, then, copy over the options, if present.
        // Also, use the original IP header on the outside and the new fabricated on the inside.
        // This is to make sure we free headers appropriately on the send completes.
        //
        //

        //
        // Now hookup the MDLs
        //
        pContext->Flags |= SCF_AH_TU;
        pContext->AHTuMdl = pAHBuffer;
        pContext->PrevTuMdl = (PNDIS_BUFFER)pData;
        pContext->OriTuMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);

        NDIS_BUFFER_LINKAGE(pAHBuffer) = pHdrBuf;

        if (hdrLen > sizeof(IPHeader)) {
            if (HdrSpace < *pExtraBytes) {

                IPSEC_DEBUG(LL_A,DBF_AH, ("Going to frag."));

                pSrcOptBuf = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pSaveOptLinkage = NDIS_BUFFER_LINKAGE(pSrcOptBuf);
                IPSecQueryNdisBuf(pSrcOptBuf, &pSrcOpt, &optLen);
                IPSecAllocateBuffer(&status,
                                    &pOptBuf,
                                    (PUCHAR *)&pOpt,
                                    hdrLen - sizeof(IPHeader),
                                    IPSEC_TAG_AH);

                if (!NT_SUCCESS(status)) {
                    NTSTATUS    ntstatus;
                    IPSEC_DEBUG(LL_A,DBF_AH, ("Failed to alloc. PAD MDL"));
                    NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
                    IPSecFreeBuffer(&ntstatus, pAHBuffer);
                    IPSecFreeBuffer(&ntstatus, pHdrBuf);
                    pContext->Flags = saveFlags;
                    return status;
                }

                RtlCopyMemory(pOpt, pSrcOpt, hdrLen-sizeof(IPHeader));
                pContext->OptMdl = pOptBuf;

                IPSEC_DEBUG(LL_A,DBF_AH, ("Copying options. S: %p, D: %p",pSrcOptBuf, pOptBuf));

                //
                // replace the original Opt Mdl with ours.
                //
                NDIS_BUFFER_LINKAGE(pOptBuf) = NDIS_BUFFER_LINKAGE(pSrcOptBuf);
                NDIS_BUFFER_LINKAGE(pHdrBuf) = pOptBuf;

                IPSEC_DEBUG(LL_A,DBF_AH, ("Options; pointed Hdrbuf: %p to pOptBuf: %p", pHdrBuf, pOptBuf));
                *pExtraBytes += hdrLen-sizeof(IPHeader);

            } else {
                IPSEC_DEBUG(LL_A,DBF_AH, ("Options; pointed Hdrbuf: %p to link(pData): %p", pHdrBuf, NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)));

                NDIS_BUFFER_LINKAGE(pHdrBuf) = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
            }
        } else {
            IPSEC_DEBUG(LL_A,DBF_AH, ("No options; pointed Hdrbuf: %p to link(pData): %p", pHdrBuf, NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)));

            NDIS_BUFFER_LINKAGE(pHdrBuf) = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
        }

        NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pAHBuffer;

        //
        // xsum the new IP header since we expect that to be the case
        // at this stage in tpt mode.
        //
        RtlCopyMemory(pIPH2, pIPH, sizeof(IPHeader));

        //
        // no options in the outer header; reset the len.
        //
        pIPH->iph_verlen = IP_VERSION + (sizeof(IPHeader) >> 2);

        //
        // also reset the frag. params.
        //
        pIPH->iph_offset &= ~(IP_MF_FLAG | IP_OFFSET_MASK);

        if (DestIF->if_dfencap == ClearDfEncap) {
            pIPH->iph_offset &= ~(IP_DF_FLAG | IP_OFFSET_MASK);
        }

        ASSERT(pSA->sa_TunnelAddr);

        //
        // Tunnel starts here; replace dest addr to point to Tunnel end if specified
        // else tunnel ends at final dest
        //
        pIPH->iph_dest = pSA->sa_TunnelAddr;

        //
        // The first pended packet on a gateway (proxy negotiating for two subnets)
        // would come via the transmit path. Hence the source address would not be
        // kosher. We need to replace the src address in that case also.
        // We get this from the corresponding inbound SA's tunnel addr.
        //
        pIPH->iph_src = pSA->sa_SrcTunnelAddr;

        pIPH->iph_id = (ushort) TCPIP_GEN_IPID();
        pIPH->iph_xsum = 0;
        pIPH->iph_xsum = ~xsum(pIPH, sizeof(IPHeader));

        //
        // Set up headers so CreateHash works as in Tpt mode.
        //
        pIPHeader = (PUCHAR)pIPH;
        *ppNewData = (PVOID)pData;
        ipNext = ((UNALIGNED IPHeader *)pIPHeader)->iph_protocol;
        pAH->ah_next = (UCHAR)IP_IN_IP;
    } else {
        *pExtraBytes += ahLen;

        if (hdrLen > sizeof(IPHeader)) {
            //
            // Options present - chain AH after options
            //
            if (fOuterAH) {
                pContext->Flags |= SCF_AH_2;
                pContext->OriAHMdl2 = NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData));
                pContext->PrevAHMdl2 = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pAHBuffer->Next = pContext->OriAHMdl2;
            } else {
                pContext->Flags |= SCF_AH;
                pContext->OriAHMdl = NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData));
                pContext->PrevMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pAHBuffer->Next = pContext->OriAHMdl;
            }
            NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pAHBuffer;
        } else {
            //
            // Chain the AH buffer after IP header
            //
            if (fOuterAH) {
                pContext->Flags |= SCF_AH_2;
                pContext->OriAHMdl2 = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pContext->PrevAHMdl2 = (PNDIS_BUFFER)pData;
                pAHBuffer->Next = pContext->OriAHMdl2;
            } else {
                pContext->Flags |= SCF_AH;
                pContext->OriAHMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pContext->PrevMdl = (PNDIS_BUFFER)pData;
                pAHBuffer->Next = pContext->OriAHMdl;
            }
            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pAHBuffer;
        }
        if (fOuterAH) {
            pContext->AHMdl2 = pAHBuffer;
        } else {
            pContext->AHMdl = pAHBuffer;
        }

        pAH->ah_next = ((UNALIGNED IPHeader *)pIPHeader)->iph_protocol;
    }

    //
    // Initialize the other fields of the AH header
    //
    pAH->ah_len = (UCHAR)((pSA->sa_TruncatedLen + pSA->sa_ReplayLen) >> 2);
    pAH->ah_reserved = 0;
    pAH->ah_spi = HOST_TO_NET_LONG(pSA->sa_OtherSPIs[Index]);
    Seq = IPSEC_INCREMENT(pSA->sa_ReplaySendSeq[Index]);
    pAH->ah_replay = HOST_TO_NET_LONG(Seq);

    //
    // Update the IP total length to reflect the AH header
    //
    IPLength = NET_SHORT(pIPH->iph_length) + (USHORT)ahLen;
    if (fTunnel) {
        IPLength += sizeof(IPHeader);
    }

    UpdateIPLength(pIPH, NET_SHORT(IPLength));
    UpdateIPProtocol(pIPH, PROTOCOL_AH);

    ADD_TO_LARGE_INTEGER(
        &pSA->sa_Stats.AuthenticatedBytesSent,
        NET_SHORT(pIPH->iph_length));

    ADD_TO_LARGE_INTEGER(
        &g_ipsec.Statistics.uAuthenticatedBytesSent,
        NET_SHORT(pIPH->iph_length));

    //
    // Generate the Hash.
    //
    if (!fCryptoOnly) {
        status = IPSecGenerateHash( pIPHeader,
                                    (PVOID)pData,
                                    pSA,
                                    (PUCHAR)(pAH + 1),
                                    fMuteDest,
                                    FALSE,          // not on recv path
                                    pAlgo,
                                    Index);
        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(LL_A,DBF_AH, ("Failed to hash, pAH: %p", pAH));
            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
            if (pSaveOptLinkage) {
                NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pSaveOptLinkage;
            }
            IPSecFreeBuffer(&ntstatus, pAHBuffer);
            if (pHdrBuf) {
                IPSecFreeBuffer(&ntstatus, pHdrBuf);
            }
            if (pOptBuf) {
                IPSecFreeBuffer(&ntstatus, pOptBuf);
            }
            pContext->Flags = saveFlags;
            *ppNewData = NULL;
            return status;
        }
    } else {
        //
        // Zero out the hash.
        //
        IPSecZeroMemory((PUCHAR)(pAH + 1), pSA->sa_TruncatedLen);
    }

    //
    // Bump up the bytes transformed count.
    //
    ADD_TO_LARGE_INTEGER(
        &pSA->sa_TotalBytesTransformed,
        NET_SHORT(pIPH->iph_length));

    //
    // Return modified packet.
    //
    IPSEC_DEBUG(LL_A,DBF_AH, ("Exiting IPSecCreateAH, ahLen: %lx, status: %lx", ahLen, status));

#if DBG
    IPSEC_DEBUG(LL_A,DBF_MDL, ("Exiting IPSecCreateAH"));
    IPSEC_PRINT_CONTEXT(*ppSCContext);
    if (*ppNewData) {
        IPSEC_PRINT_MDL(*ppNewData);
    }
    else {
        IPSEC_PRINT_MDL(pData);
    }
#endif

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecVerifyAH(
    IN      PUCHAR          *pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PULONG          pExtraBytes,
    IN      BOOLEAN         fSrcRoute,
    IN      BOOLEAN         fCryptoDone,
    IN      BOOLEAN         fFastRcv
    )
/*++

Routine Description:

    Verify the AH, given the packet. If AH kosher, strips off the AH from
    pData.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header.

    pSA - Sec. Assoc. entry

    pExtraBytes - out param to inform IP on recv path how many bytes IPSEC took off.

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_UNSUCCESSFUL (packet not kosher - bad AH)
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PUCHAR      pPyld;
    ULONG       Len;
    LONG        ahLen;
    LONG        totalLen;
    UCHAR       Buf[MAX_AH_OUTPUT_LEN];
    PUCHAR      pAHData = Buf;
	IPHeader UNALIGNED *pIPH = (IPHeader UNALIGNED *)*pIPHeader;
    ULONG       extraBytes = 0;
    ULONG       hdrLen;
    PAUTH_ALGO  pAlgo;
    USHORT      FilterFlags;
    BOOLEAN fTunnel = ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                       ((Index == 0) ||
                        ((Index == 1) && (pSA->sa_Operation[0] == Compress))));

    IPSEC_DEBUG(LL_A,DBF_AH, ("Entering IPSecVerifyAH"));

    ASSERT(pSA->sa_Operation[Index] == Auth);

    if (pSA->INT_ALGO(Index) > NUM_AUTH_ALGOS) {
        return  STATUS_INVALID_PARAMETER;
    }

    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    pAlgo = &(auth_algorithms[pSA->INT_ALGO(Index)]);

    ahLen = sizeof(AH) + pSA->sa_TruncatedLen * sizeof(UCHAR);

    IPSEC_GET_TOTAL_LEN_RCV_BUF(pData, &totalLen);

    //
    // Do we have enough in the buffer?
    //
    if (totalLen < ahLen) {
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // Compare the hash with the AH from packet
    // First buffer has the AH
    //
    IPSecQueryRcvBuf(pData, &pPyld, &Len);

    //
    // Size OK?
    //
    if (((UNALIGNED AH *)pPyld)->ah_len !=
            (UCHAR)((pSA->sa_TruncatedLen + pSA->sa_ReplayLen) >> 2)) {
        IPSEC_DEBUG(LL_A,DBF_AH, ("Failed size check: in: %x, need: %x",
                        ((UNALIGNED AH *)pPyld)->ah_len,
                        (UCHAR)((pSA->sa_TruncatedLen + pSA->sa_ReplayLen) >> 2)));
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // Generate the Hash
    //
    if (!fCryptoDone) {
        status = IPSecGenerateHash( *pIPHeader,
                                    pData,
                                    pSA,
                                    pAHData,
                                    fSrcRoute,
                                    TRUE,
                                    pAlgo,
                                    Index); // on recv path

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A,DBF_AH, ("Failed to hash, pData: %p", pData));
            return status;
        }

        if (!IPSecEqualMemory(  pAHData,
                                pPyld + sizeof(AH),
                                pSA->sa_TruncatedLen)) {

            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                1,
                                TRUE);

            IPSEC_DEBUG(LL_A,DBF_AH, ("Failed to compare, pPyld: %p, pAHData: %p", pPyld, pAHData));
            IPSEC_DEBUG(LL_A,DBF_GENHASH, ("AHData: %lx-%lx-%lx",
                        *(ULONG *)&(pAHData)[0],
                        *(ULONG *)&(pAHData)[4],
                        *(ULONG *)&(pAHData)[8]));
            IPSEC_DEBUG(LL_A,DBF_GENHASH, ("PyldHash: %lx-%lx-%lx",
                        *(ULONG *)&((UCHAR *)(pPyld + sizeof(AH)))[0],
                        *(ULONG *)&((UCHAR *)(pPyld + sizeof(AH)))[4],
                        *(ULONG *)&((UCHAR *)(pPyld + sizeof(AH)))[8]));
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);

            return IPSEC_INVALID_AH;
        }
    }

    ADD_TO_LARGE_INTEGER(
        &pSA->sa_Stats.AuthenticatedBytesReceived,
        NET_SHORT(pIPH->iph_length));

    ADD_TO_LARGE_INTEGER(
        &g_ipsec.Statistics.uAuthenticatedBytesReceived,
        NET_SHORT(pIPH->iph_length));

    //
    // Check the replay window
    //
    status=IPSecChkReplayWindow(
        NET_TO_HOST_LONG(((UNALIGNED AH *)pPyld)->ah_replay),
        pSA,
        Index); 
    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A,DBF_AH, ("Replay check failed, pPyld: %p, pAHData: %p", pPyld, pAHData));
        IPSEC_INC_STATISTIC(dwNumPacketsWithReplayDetection);
        return status;
    }

    IPSEC_DEBUG(LL_A,DBF_AH, ("IP Len: %lx", pIPH->iph_length));

    pIPH->iph_length = NET_SHORT(NET_SHORT(pIPH->iph_length) - (USHORT)ahLen);

    IPSEC_DEBUG(LL_A,DBF_AH, ("IP Len: %lx", pIPH->iph_length));

    //
    // Restore the protocol from AH header
    //
    pIPH->iph_protocol = ((UNALIGNED AH *)pPyld)->ah_next;

    IPSEC_DEBUG(LL_A,DBF_AH, ("Matched!! Restored protocol %x", pIPH->iph_protocol));

    //
    // Remove the AH from the packet
    //
    IPSEC_SET_OFFSET_IN_BUFFER(pData, ahLen);

    //
    // Move the IP header forward for filter/firewall hook, fast path only.
    //
    if (fFastRcv) {
        IPSecMoveMemory(((PUCHAR)pIPH) + ahLen, (PUCHAR)pIPH, hdrLen);
        *pIPHeader=(PUCHAR)pIPH+ahLen;
        pIPH = (IPHeader UNALIGNED *)*pIPHeader;
    }

    extraBytes += ahLen;

    //
    // Bump up the bytes transformed count.
    //
    ADD_TO_LARGE_INTEGER(
        &pSA->sa_TotalBytesTransformed,
        NET_SHORT(pIPH->iph_length));

    if (fTunnel) {
        if (pIPH->iph_protocol != IP_IN_IP) {
            IPSEC_DEBUG(LL_A,DBF_AH, ("BAD protocol in IP: %x", pIPH->iph_protocol));
            return STATUS_INVALID_PARAMETER;
        }
    }

    *pExtraBytes += extraBytes;

    IPSEC_DEBUG(LL_A,DBF_AH, ("Exiting IPSecVerifyAH"));

    return status;
}


NTSTATUS
IPSecGenerateHash(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      PUCHAR          pAHData,
    IN      BOOLEAN         fMuteDest,
    IN      BOOLEAN         fIncoming,
    IN      PAUTH_ALGO      pAlgo,
    IN      ULONG           Index
    )
/*++

Routine Description:

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the entire IP datagram, starting at the IP Header

    pSA - Sec. Assoc. entry

    pAHData - buffer to contain the generated hash

    fIncoming - TRUE if on recv path.

    pAlgo - the auth_algo being used

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_UNSUCCESSFUL (packet not kosher - bad AH)
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    ULONG   numBytesPayload;
    ULONG   i;
    PUCHAR  pPayload;
    IPHeader    UNALIGNED   *pIPH = (UNALIGNED IPHeader *)pIPHeader;
    PUCHAR      pOptions;
    PNDIS_BUFFER    pBuf = (PNDIS_BUFFER)pData;
    ULONG       hdrLen;
    ULONG       ahLen;
    NTSTATUS    status;
    ALGO_STATE  State = {0};
    BOOLEAN fTunnel = ( (pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                        ((Index == 0) ||
                            ((Index == 1) && (pSA->sa_Operation[0] == Compress))));

    //
    // These are saved since they can change enroute
    //
    //
    // Scratch array used for AH calculation
    //
    UCHAR       zero[MAX_IP_OPTION_SIZE];
	UCHAR		savetos;				// Type of service.
	USHORT		saveoffset;				// Flags and fragment offset.
	UCHAR		savettl;				// Time to live.
	USHORT		savexsum;				// Header checksum.
	IPAddr		savedest;				// Dest address.

    IPSEC_DEBUG(LL_A,DBF_AH, ("Entering IPSecGenerateHash"));

    ahLen = sizeof(AH) + pSA->sa_TruncatedLen * sizeof(UCHAR);

    State.as_sa = pSA;
    IPSecZeroMemory(zero, sizeof(zero));

    status = pAlgo->init(&State, Index);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A,DBF_AH, ("init failed: %lx", status));
    }

    //
    // Save, then zero out fields that can change enroute
    //
    savetos = pIPH->iph_tos;
    saveoffset = pIPH->iph_offset;
    savettl = pIPH->iph_ttl;
    savexsum = pIPH->iph_xsum;

    pIPH->iph_tos = 0;
    pIPH->iph_offset = 0;
    pIPH->iph_ttl = 0;
    pIPH->iph_xsum = 0;

    //
    // Mute dest address as well if source routing
    //
    if (fMuteDest) {
        savedest = pIPH->iph_dest;
        pIPH->iph_dest = 0;
    }

    //
    // Call MD5 to create the header hash
    //
    pAlgo->update(&State, pIPHeader, sizeof(IPHeader));

#if DBG
    if (fIncoming) {
        IPSEC_DEBUG(LL_A,DBF_GENHASH, ("IPHeader to Hash: %lx-%lx-%lx-%lx-%lx",
                    *(ULONG *)&(pIPHeader)[0],
                    *(ULONG *)&(pIPHeader)[4],
                    *(ULONG *)&(pIPHeader)[8],
                    *(ULONG *)&(pIPHeader)[12],
                    *(ULONG *)&(pIPHeader)[16]));
    }
#endif

    //
    // Restore the zeroed fields
    //
    pIPH->iph_tos = savetos;
    pIPH->iph_offset = saveoffset;
    pIPH->iph_ttl = savettl;
    pIPH->iph_xsum = savexsum;

    //
    // Restore dest address as well for source routing
    //
    if (fMuteDest) {
        pIPH->iph_dest = savedest;
    }

    //
    // Now, do the options if they exist
    //
    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    if (hdrLen > sizeof(IPHeader)) {
        UCHAR   cLength;
        ULONG   uIndex = 0;
        ULONG   uOptLen = hdrLen - sizeof(IPHeader);

        ASSERT(!fTunnel);

        if (fIncoming) {
            pOptions = (PUCHAR)(pIPH + 1);
        } else {
            //
            // Options are in second MDL... on send side
            //
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
            IPSecQueryNdisBuf(pBuf, &pOptions, &uOptLen);
        }

        IPSEC_DEBUG(LL_A,DBF_AH, ("Got options: %p", pOptions));

        //
        // Some options may need to be zeroed out...
        //
        while (uIndex < uOptLen) {
            switch (*pOptions) {
            case IP_OPT_EOL:
                pAlgo->update(&State, zero, 1);
                uIndex = uOptLen;
                break;

            //
            // Zeroed for AH calculation
            //
            case IP_OPT_NOP:
                pAlgo->update(&State, zero, 1);
                uIndex++;
                pOptions++;
                break;

            case IP_OPT_LSRR:
            case IP_OPT_SSRR:
            case IP_OPT_RR:
            case IP_OPT_TS:
                cLength = pOptions[IP_OPT_LENGTH];
                pAlgo->update(&State, zero, cLength);
                uIndex += cLength;
                pOptions += cLength;
                break;

            //
            // Assumed invariant; used for AH calc
            //
            case IP_OPT_ROUTER_ALERT:
            case IP_OPT_SECURITY:
            default:
                cLength = pOptions[IP_OPT_LENGTH];
                pAlgo->update(&State, pOptions, cLength);
                uIndex += cLength;
                pOptions += cLength;
                break;
            }
        }
    }

    //
    // Go over the remaining payload, creating the hash
    //
    // NOTE: We differentiate between the send and recv since the
    // buffer formats are different
    //
    if (fIncoming) {
        IPRcvBuf    *pRcvBuf = (IPRcvBuf *)pData;
        ULONG       Len;
        LONG        remainLen;

        UCHAR UNALIGNED   *pPyld;

        //
        // First buffer shd be the AH itself
        //
        IPSecQueryRcvBuf(pRcvBuf, &pPyld, &Len);

        //
        // Do the first portion of the header.
        //
        pAlgo->update(&State, pPyld, sizeof(AH));

#if DBG
    if (fIncoming) {
        IPSEC_DEBUG(LL_A,DBF_GENHASH, ("AHHeader to Hash: %lx-%lx-%lx",
                    *(ULONG *)&(pPyld)[0],
                    *(ULONG *)&(pPyld)[4],
                    *(ULONG *)&(pPyld)[8]));
    }
#endif

        //
        // The authentication data should be considered as 0.
        // In our case, the data length is fixed at pSA->sa_TruncatedLen bytes
        //
        pAlgo->update(&State, zero, pSA->sa_TruncatedLen);

        //
        // Jump over the remaining AH: need to take care of situations
        // where ICV is chained (Raid 146275).
        //
        if (((LONG)Len - (LONG)ahLen) >= 0) {
            pPyld += ahLen;
            IPSEC_DEBUG(LL_A,DBF_AH, ("Jumped over IPSEC res: %p, len: %lx", pPyld, Len));

            //
            // Tpt header is right after AH
            //
            pAlgo->update(&State, pPyld, Len - ahLen);
        } else {
            //
            // Need to jump over ICV if it expands over multiple buffers
            //
            remainLen = pSA->sa_TruncatedLen - (Len - sizeof(AH));
            IPSEC_DEBUG(LL_A,DBF_AH, ("Jumped over IPSEC res: %p, remainlen: %lx", pPyld, remainLen));
            while (remainLen > 0 && (pRcvBuf = IPSEC_BUFFER_LINKAGE(pRcvBuf))) {
                IPSecQueryRcvBuf(pRcvBuf, &pPyld, &Len);
                remainLen -= Len;
            }

            //
            // Do the possible partial data after AH
            //
            if (remainLen < 0 && pRcvBuf) {
                pPyld += Len + remainLen;
                pAlgo->update(&State, pPyld, -remainLen);
            }
        }

        //
        // Now do the remaining chain
        //
        while (pRcvBuf = IPSEC_BUFFER_LINKAGE(pRcvBuf)) {
            IPSecQueryRcvBuf(pRcvBuf, &pPyld, &Len);
            pAlgo->update(&State, pPyld, Len);
        }
    } else {
        UCHAR UNALIGNED   *pPyld;
        ULONG   Len;

        //
        // Second (or third if options present) buffer shd be the AH itself
        //
        pBuf = NDIS_BUFFER_LINKAGE(pBuf);
        IPSecQueryNdisBuf(pBuf, &pPyld, &Len);

        //
        // Do the first portion of the header.
        //
        pAlgo->update(&State, pPyld, sizeof(AH));

        //
        // The authentication data should be considered as 0.
        // In our case, the data length is fixed at pSA->sa_TruncatedLen bytes
        //
        pAlgo->update(&State, zero, pSA->sa_TruncatedLen);

        //
        // Skip over the remaining AH section
        //
        pPyld += ahLen;

        IPSEC_DEBUG(LL_A,DBF_AH, ("Jumped over IPSEC Len: %lx, hdrlen: %lx", Len, hdrLen));

        pAlgo->update(&State, pPyld, Len - ahLen);

        //
        // Now do the remaining chain
        //
        while (pBuf = NDIS_BUFFER_LINKAGE(pBuf)) {
            IPSecQueryNdisBuf(pBuf, &pPyld, &Len);
            pAlgo->update(&State, pPyld, Len);
        }
    }

    pAlgo->finish(&State, pAHData, Index);

    //
    // Copy out the hash - get the truncated hash out, then zero out the rest
    //
    TRUNCATE(pAHData, pAHData, pSA->sa_TruncatedLen, MD5DIGESTLEN);

    IPSEC_DEBUG(LL_A,DBF_AH, ("Exiting IPSecGenerateMD5"));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\ah.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ah.h

Abstract:

    Contains AH specific structures

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef _AH_
#define _AH_


#define MD5DIGESTLEN    16
#define SHADIGESTLEN    20
#define AH_SIZE (sizeof(AH) + MD5DIGESTLEN * sizeof(UCHAR))

//
// State buffers for the individual algorithms
//
typedef struct  _AlgoState {
    union {             // internal algo state
        MD5_CTX             as_md5ctx;
        A_SHA_CTX           as_shactx;
    };
    PSA_TABLE_ENTRY     as_sa;
} ALGO_STATE, *PALGO_STATE;

typedef NTSTATUS
(*PALGO_INIT) (
    PALGO_STATE pEntry,
    ULONG       Index
);

typedef NTSTATUS
(*PALGO_UPDATE) (
    PALGO_STATE   State,
    PUCHAR  Data,
    ULONG   Length
);

typedef NTSTATUS
(*PALGO_FINISH) (
    PALGO_STATE State,
    PUCHAR      Data,
    ULONG       Index
);


//
// Array of function ptrs for the AH authentication algorithms
//
typedef struct _auth_algorithm {
  PALGO_INIT    init;       // ptr to init fn for alg.
  PALGO_UPDATE  update;     // ptr to update fn for alg
  PALGO_FINISH  finish;     // ptr to finish fn for alg
  ULONG OutputLen;          // Length (in u_int8s) of output
					        // data. MUST be a multiple of 4
} AUTH_ALGO, *PAUTH_ALGO;


#define NUM_AUTH_ALGOS (sizeof(auth_algorithms)/sizeof(AUTH_ALGO)-1)


//
// The IPSEC AH payload
//
typedef struct  _AH {
    UCHAR   ah_next;
    UCHAR   ah_len;
    USHORT  ah_reserved;
    tSPI    ah_spi;
    ULONG   ah_replay;
} AH, *PAH;

NTSTATUS
IPSecCreateAH(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PVOID           IPContext,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PVOID           *ppNewData,
    OUT     PVOID           *ppSCContext,
    OUT     PULONG          pExtraBytes,
    IN      ULONG           HdrSpace,
    IN      BOOLEAN         fSrcRoute,
    IN      BOOLEAN         fCryptoOnly
    );

NTSTATUS
IPSecVerifyAH(
    IN      PUCHAR          *pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PULONG          pExtraBytes,
    IN      BOOLEAN         fSrcRoute,
    IN      BOOLEAN         fCryptoDone,
    IN      BOOLEAN         fFastRcv
    );

NTSTATUS
IPSecGenerateHash(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      PUCHAR          pAHData,
    IN      BOOLEAN         fMuteDest,
    IN      BOOLEAN         fIncoming,
    IN      PAUTH_ALGO      pAlgo,
    IN      ULONG           Index
    );

#endif _AH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\driver.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module contains the DriverEntry and other initialization
    code for the IPSEC module of the Tcpip transport.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"

#ifdef RUN_WPP
#include "driver.tmh"
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, IPSecGeneralInit)
#pragma alloc_text(PAGE, IPSecBindToIP)
#pragma alloc_text(PAGE, IPSecUnbindFromIP)
#pragma alloc_text(PAGE, IPSecFreeConfig)
#pragma alloc_text(PAGE, IPSecInitMdlPool)
#pragma alloc_text(PAGE, AllocateCacheStructures)
#pragma alloc_text(PAGE, FreeExistingCache)
#pragma alloc_text(PAGE, FreePatternDbase)
#pragma alloc_text(PAGE, OpenRegKey)
#pragma alloc_text(PAGE, GetRegDWORDValue)
#pragma alloc_text(PAGE, IPSecCryptoInitialize)
#pragma alloc_text(PAGE, IPSecCryptoDeinitialize)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine performs initialization of the IPSEC module.
    It creates the device object for the transport
    provider and performs other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of IPSEC's node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    PDEVICE_OBJECT  deviceObject = NULL;
    WCHAR           deviceNameBuffer[] = DD_IPSEC_DEVICE_NAME;
    WCHAR           symbolicLinkBuffer[] = DD_IPSEC_SYM_NAME;
    UNICODE_STRING  symbolicLinkName;
    UNICODE_STRING  deviceNameUnicodeString;
    NTSTATUS        status;
    NTSTATUS        status1;

    //DbgBreakPoint();

    // WPP tracing
    //
    WPP_INIT_TRACING(DriverObject, RegistryPath);

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering DriverEntry"));

    //
    // Init g_ipsec structure and read reg keys.
    //


    IPSecZeroMemory(&g_ipsec, sizeof(g_ipsec));

    //
    // Create the device - do we need a device at all?
    //
    // Setup the handlers.
    //
    //
    // Initialize the driver object with this driver's entry points.
    //
    g_ipsec.IPSecDriverObject = DriverObject;

    IPSecReadRegistry();


    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] =
    DriverObject->MajorFunction [IRP_MJ_CLEANUP] =
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] =
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = IPSecDispatch;

    DriverObject->DriverUnload = IPSecUnload;

    RtlInitUnicodeString (&deviceNameUnicodeString, deviceNameBuffer);

    status = IoCreateDevice(
                    DriverObject,
                    0,                          // DeviceExtensionSize
                    &deviceNameUnicodeString,   // DeviceName
                    FILE_DEVICE_NETWORK,        // DeviceType
                    FILE_DEVICE_SECURE_OPEN,    // DeviceCharacteristics
                    FALSE,                      // Exclusive
                    &deviceObject);             // *DeviceObject

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to create device: %lx", status));

        LOG_EVENT(
            DriverObject,
            EVENT_IPSEC_CREATE_DEVICE_FAILED,
            1,
            1,
            &deviceNameUnicodeString.Buffer,
            0,
            NULL);

        goto err;
    }

    deviceObject->Flags |= DO_BUFFERED_IO;

    IPSecDevice = deviceObject;

    RtlInitUnicodeString (&symbolicLinkName, symbolicLinkBuffer);

    status = IoCreateSymbolicLink(&symbolicLinkName, &deviceNameUnicodeString);

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to create symbolic link: %lx", status));

        LOG_EVENT(
            DriverObject,
            EVENT_IPSEC_CREATE_DEVICE_FAILED,
            2,
            1,
            &deviceNameUnicodeString.Buffer,
            0,
            NULL);

        IoDeleteDevice(DriverObject->DeviceObject);

        goto err;
    }

    //
    // General structs init here.
    // Allocates the SA Table etc.
    //
    status = IPSecGeneralInit();

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to init general structs: %lx", status));

        //
        // Free the general structs and SA Table etc.
        //
        status1 = IPSecGeneralFree();

        if (!NT_SUCCESS (status1)) {
            IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to free config: %lx", status1));
        }

        LOG_EVENT(
            DriverObject,
            EVENT_IPSEC_NO_RESOURCES_FOR_INIT,
            1,
            0,
            NULL,
            0,
            NULL);

        IoDeleteSymbolicLink(&symbolicLinkName);

        IoDeleteDevice(DriverObject->DeviceObject);

        goto err;
    }

    //
    // Wait for TCP/IP to load and call IOCTL_IPSEC_SET_TCPIP_STATUS where we
    // would finish the initialization.
    //

    status = STATUS_SUCCESS;

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting DriverEntry; SUCCESS"));

err:
    return status;
}


VOID
IPSecUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Called when the driver is unloaded.

Arguments:

    DriverObject

Return Value:

    None

--*/
{
    UNICODE_STRING  IPSecLinkName;
    KIRQL           OldIrq;
    KIRQL           kIrql;
    NTSTATUS        status;
    INT             class;

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering IPSecUnload"));

    //
    // Set IPSEC_DRIVER_UNLOADING bit.
    //
    IPSEC_DRIVER_UNLOADING() = TRUE;

    AcquireWriteLock(&g_ipsec.SADBLock,&kIrql);
    if (g_ipsec.BootStatefulHT){
         IPSecFreeMemory(g_ipsec.BootStatefulHT);
         g_ipsec.BootStatefulHT = NULL;
        }
    if (g_ipsec.BootBufferPool){
        IPSecFreeMemory(g_ipsec.BootBufferPool);
        g_ipsec.BootBufferPool = NULL;
        }
    if (g_ipsec.BootExemptList){
        IPSecFreeMemory(g_ipsec.BootExemptList);
        g_ipsec.BootExemptList = NULL;
        }
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);


    //
    // Stop the reaper timer.
    //
    IPSecStopTimer(&g_ipsec.ReaperTimer);

    //
    // Stop the EventLog timer.
    //
    IPSecStopTimer(&g_ipsec.EventLogTimer);

    //
    // Complete the Acquire Irp with error status
    //
    if (g_ipsec.AcquireInfo.Irp) {
        IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Unload: Completing Irp.."));
        if (g_ipsec.AcquireInfo.InMe) {
            IoAcquireCancelSpinLock(&g_ipsec.AcquireInfo.Irp->CancelIrql);
            IPSecAcquireIrpCancel(NULL, g_ipsec.AcquireInfo.Irp);
        }
    }

    //
    // Stop timers for all SAs (of all states)
    //
    IPSecStopSATimers();

    if (g_ipsec.ShimFunctions.pCleanupRoutine) {
        (g_ipsec.ShimFunctions.pCleanupRoutine)();
    }

    //
    // Wait for all timers to clear before going further
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumTimers) != 0) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Cleanup any larval SAs
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);
    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
    IPSecFlushLarvalSAList();
    IPSecFlushSAExpirations();
    RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, OldIrq);
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    //
    // Free the SA Table.
    //
    status = IPSecFreeConfig();

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to free config: %lx", status));
    }

    //
    // Free the MDL pools and run down all buffered packets.
    //
    status = IPSecQuiesce();

    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to reach quiescent state: %lx", status));
    }

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);
    ASSERT (gpParserIfEntry == NULL);
    FlushAllParserEntries();
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    //
    // Destroy timer structures
    //
    ACQUIRE_LOCK(&g_ipsec.TimerLock, &kIrql);

    for (class = 0; class < IPSEC_CLASS_MAX; class++) {
        ASSERT(g_ipsec.TimerList[class].TimerCount == 0);
        IPSecFreeMemory(g_ipsec.TimerList[class].pTimers);
    }

    RELEASE_LOCK(&g_ipsec.TimerLock, kIrql);

    IPSecCryptoDeinitialize();

#if GPC
    IPSecGpcDeinitialize();
#endif

    RtlInitUnicodeString(&IPSecLinkName, DD_IPSEC_SYM_NAME);

    IoDeleteSymbolicLink(&IPSecLinkName);

    WPP_CLEANUP(DriverObject);
    
    IoDeleteDevice(DriverObject->DeviceObject);

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting IPSecUnload"));
}


NTSTATUS
IPSecDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:

    Dispatch Routine for the driver. Gets the current irp stack location, validates
    the parameters and routes the calls

Arguments:

    DeviceObject
    Irp

Return Value:

    Status as returned by the worker functions

--*/
{
    PIO_STACK_LOCATION  irpStack;
    PVOID               pvIoBuffer;
    LONG                inputBufferLength;
    LONG                outputBufferLength;
    ULONG               ioControlCode;
    NTSTATUS            status = STATUS_SUCCESS;
    LONG                dwSize = 0;

    PAGED_CODE();

    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("Entering IPSecDispath"));
    
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and its length.
    //
    pvIoBuffer         = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    switch (irpStack->MajorFunction) {
        case IRP_MJ_CREATE: {
            IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IRP_MJ_CREATE"));
            break;
        }

        case IRP_MJ_CLOSE: {
            IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IRP_MJ_CLOSE"));
            break;
        }

        case IRP_MJ_DEVICE_CONTROL: {
            ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

            IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IRP_MJ_DEVICE_CONTROL: %lx", ioControlCode));

            if (ioControlCode != IOCTL_IPSEC_SET_TCPIP_STATUS) {
                if (IPSEC_DRIVER_IS_INACTIVE()) {
                    status = STATUS_INVALID_DEVICE_STATE;
                    break;
                }

                if (!IPSecCryptoInitialize()) {
                    status = STATUS_CRYPTO_SYSTEM_INVALID;
                    break;
                }
            }

            IPSEC_INCREMENT(g_ipsec.NumIoctls);

            switch (ioControlCode) {
                case IOCTL_IPSEC_ADD_FILTER: {
                    PIPSEC_ADD_FILTER   pAddFilter = (PIPSEC_ADD_FILTER)pvIoBuffer;

                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IOCTL_IPSEC_ADD_FILTER"));

                    dwSize = sizeof(IPSEC_ADD_FILTER);

                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    //
                    // Check the size of the entry
                    //
                    if (pAddFilter->NumEntries == 0) {
                        status = STATUS_SUCCESS;
                    } else {
                        dwSize = FIELD_OFFSET(IPSEC_ADD_FILTER, pInfo[0]) +
                                    pAddFilter->NumEntries * sizeof(IPSEC_FILTER_INFO);

                        if (dwSize < FIELD_OFFSET(IPSEC_ADD_FILTER, pInfo[0]) ||
                            inputBufferLength < dwSize) {
                            status = STATUS_BUFFER_TOO_SMALL;
                            IPSEC_DEBUG(LL_A, DBF_IOCTL, ("returning: %lx", status));
                            break;
                        }
                        status = IPSecAddFilter(pAddFilter);
                    }

                    break;
                }

                case IOCTL_IPSEC_DELETE_FILTER: {
                    PIPSEC_DELETE_FILTER    pDelFilter = (PIPSEC_DELETE_FILTER)pvIoBuffer;

                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IOCTL_IPSEC_DELETE_FILTER"));

                    dwSize = sizeof(IPSEC_DELETE_FILTER);

                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    //
                    // Check the size of the entry
                    //
                    if (pDelFilter->NumEntries == 0) {
                        status = STATUS_SUCCESS;
                    } else {
                        dwSize = FIELD_OFFSET(IPSEC_DELETE_FILTER, pInfo[0]) +
                                    pDelFilter->NumEntries * sizeof(IPSEC_FILTER_INFO);

                        if (dwSize < FIELD_OFFSET(IPSEC_DELETE_FILTER, pInfo[0]) ||
                            inputBufferLength < dwSize) {
                            status = STATUS_BUFFER_TOO_SMALL;
                            break;
                        }

                        status = IPSecDeleteFilter(pDelFilter);
                    }

                    break;
                }

                case IOCTL_IPSEC_ENUM_SAS: {

                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IOCTL_IPSEC_ENUM_SAS"));
                    dwSize = sizeof(IPSEC_ENUM_SAS);

                    //
                    // Output/Input in the same buffer at MdlAddress
                    //
                    // This functions accesses Irp->MdlAddress 
                    // and checks if it is NULL too.

                    status = IPSecEnumSAs(Irp, &dwSize);
                    break;
                }

                case IOCTL_IPSEC_ENUM_FILTERS: {
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IOCTL_IPSEC_ENUM_FILTERS"));
                    dwSize = sizeof(IPSEC_ENUM_FILTERS);

                    //
                    // Output/Input in the same buffer at MdlAddress
                    //
                    // This functions accesses Irp->MdlAddress 
                    // and checks if it is NULL too.

                    status = IPSecEnumFilters(Irp, &dwSize);
                    break;
                }

                case IOCTL_IPSEC_QUERY_STATS: {
                    //
                    // The minimum size is without any Keys
                    //
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IOCTL_IPSEC_QUERY_STATS"));
                    dwSize = sizeof(IPSEC_QUERY_STATS);

                    if (outputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    *((PIPSEC_QUERY_STATS)pvIoBuffer) = g_ipsec.Statistics;

                    status = STATUS_SUCCESS;
                    break;
                }

                case IOCTL_IPSEC_ADD_SA: {
                    //
                    // Adds the SA to the relevant database.
                    // Typically used to add outbound SAs to the DB.
                    //
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IOCTL_IPSEC_ADD_SA"));

                    //
                    // The minimum size is without any Keys
                    //
                    dwSize = IPSEC_ADD_SA_NO_KEY_SIZE;

                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecAddSA((PIPSEC_ADD_SA)pvIoBuffer, inputBufferLength);

                    ASSERT(status != STATUS_PENDING);

                    if (outputBufferLength >= sizeof(NTSTATUS)) {
                        (*(NTSTATUS *)pvIoBuffer) = status;
                        dwSize = sizeof(NTSTATUS);
                    } else {
                        dwSize = 0;
                    }

                    status = STATUS_SUCCESS;
                    break;
                }

                case IOCTL_IPSEC_UPDATE_SA: {
                    //
                    // This completes the negotiation kicked off via the Acquire.
                    //
                    // Adds the SA to the relevant database.
                    // Typically used to complete inbound SA acquisitions.
                    //
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IOCTL_IPSEC_UPDATE_SA"));

                    //
                    // The minimum size is without any Keys
                    //
                    dwSize = IPSEC_UPDATE_SA_NO_KEY_SIZE;
                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecUpdateSA((PIPSEC_UPDATE_SA)pvIoBuffer, inputBufferLength);

                    ASSERT(status != STATUS_PENDING);

                    if (outputBufferLength >= sizeof(NTSTATUS)) {
                        (*(NTSTATUS *)pvIoBuffer)=status;
                        dwSize = sizeof(NTSTATUS);
                    } else {
                        dwSize = 0;
                    }

                    status = STATUS_SUCCESS;
                    break;
                }

                case IOCTL_IPSEC_EXPIRE_SA: {
                    //
                    // Deref the particular SA - delete when ref cnt drops to 0.
                    //
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IOCTL_IPSEC_EXPIRE_SA"));

                    dwSize = sizeof(IPSEC_EXPIRE_SA);
                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecExpireSA((PIPSEC_EXPIRE_SA)pvIoBuffer);
                    break;
                }

                case IOCTL_IPSEC_GET_SPI: {
                    //
                    // returns the SPI for an inbound SA
                    //
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IOCTL_IPSEC_GET_SPI"));

                    dwSize = sizeof(IPSEC_GET_SPI);
                    if (outputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecGetSPI((PIPSEC_GET_SPI)pvIoBuffer);
                    break;
                }

                case IOCTL_IPSEC_POST_FOR_ACQUIRE_SA: {
                    //
                    // The SAAPI client posts a request that we complete when
                    // an SA needs to be initialized or updated (due to
                    // re-key).
                    // We keep the Irp around until we need an SA to be
                    // negotiated.
                    //
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_POST_FOR_ACQUIRE_SA"));

                    dwSize = sizeof(IPSEC_POST_FOR_ACQUIRE_SA);
                    if (outputBufferLength < dwSize) {
                        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_POST_FOR_ACQUIRE_SA: bad size: dwSize: %lx, input: %lx",
                                          dwSize, inputBufferLength));

                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    Irp->IoStatus.Status = STATUS_PENDING;

                    status = IPSecHandleAcquireRequest( Irp,
                                                        (PIPSEC_POST_FOR_ACQUIRE_SA)pvIoBuffer);

                    if (status == STATUS_PENDING) {
                        IPSEC_DECREMENT(g_ipsec.NumIoctls);
                        return  status;
                    }

                    break;
                }

                case IOCTL_IPSEC_QUERY_EXPORT: {
                    //
                    // Queries whether the driver is built for export. Used by the IPSEC components
                    // to decide what key lengths to use for encryption.
                    //
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_QUERY_EXPORT"));

                    dwSize = sizeof(IPSEC_QUERY_EXPORT);
                    if (outputBufferLength < dwSize) {
                        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_QUERY_EXPORT: bad size: dwSize: %lx, input: %lx",
                                          dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    ((PIPSEC_QUERY_EXPORT)pvIoBuffer)->Export = FALSE;

                    status = STATUS_SUCCESS;
                    break;
                }

                case IOCTL_IPSEC_QUERY_SPI: {
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("Entered Query SPI"));

                    dwSize = sizeof(IPSEC_QUERY_SPI);
                    if (inputBufferLength < dwSize) {
                        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_QUERY_SPI: bad size: dwSize: %lx, input: %lx",
                        dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecQuerySpi((PIPSEC_QUERY_SPI)pvIoBuffer);
                    break;
                }

                case IOCTL_IPSEC_DELETE_SA: {
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("Entered Delete SA"));

                    dwSize = sizeof(IPSEC_DELETE_SA);
                    if (inputBufferLength < dwSize) {
                        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_DELETE_SA: bad size: dwSize: %lx, input: %lx",
                        dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecDeleteSA((PIPSEC_DELETE_SA)pvIoBuffer);
                    break;
                }

                case IOCTL_IPSEC_SET_OPERATION_MODE: {
                    OPERATION_MODE LastMode = g_ipsec.OperationMode;
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("Entered Set Operation Mode"));

                    dwSize = sizeof(IPSEC_SET_OPERATION_MODE);
                    if (inputBufferLength < dwSize) {
                        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_SET_OPERATION_MODE: bad size: dwSize: %lx, input: %lx",
                        dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecSetOperationMode((PIPSEC_SET_OPERATION_MODE)pvIoBuffer);
                    if (IPSEC_BOOTTIME_STATEFUL_MODE == LastMode)
					{
					   LARGE_INTEGER CurTime;
					   LARGE_INTEGER Delta;
                                      NdisGetCurrentSystemTime(&CurTime);
                                      IPSecCleanupBoottimeStatefulStructs();
                                      Delta = RtlLargeIntegerSubtract(CurTime,g_ipsec.StartTimeDelta);
					   IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("Delta %d %d",Delta.HighPart,Delta.LowPart));

					}

                    break;
                }


                case IOCTL_IPSEC_GET_OPERATION_MODE: {
                         OPERATION_MODE CurrentMode = g_ipsec.OperationMode;
                        dwSize = sizeof(IPSEC_GET_OPERATION_MODE);                        
                        if (outputBufferLength< dwSize) {
                            IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_SET_OPERATION_MODE: bad size: dwSize: %lx, input: %lx",
                            dwSize, inputBufferLength));
                            status = STATUS_BUFFER_TOO_SMALL;
                            break;
                        }
                        ((PIPSEC_SET_OPERATION_MODE)pvIoBuffer)->OperationMode = CurrentMode;
                        break;
                    }


                case IOCTL_IPSEC_SET_DIAGNOSTIC_MODE: {
                	DWORD Mode;
                	DWORD LogInterval;
                	// Initialize the return status
                	status = STATUS_SUCCESS;
                	dwSize = sizeof (IPSEC_SET_DIAGNOSTIC_MODE);
                	// Check Input Buffer Length
                	if (inputBufferLength < dwSize) {
                		IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_SET_DIAGNOSTIC_MODE : bad size: dwSize : %lx, input %lx",
                			dwSize, inputBufferLength));
                		status = STATUS_BUFFER_TOO_SMALL;
                		break;
                		}
                	// Get the input Parameters
                	Mode = ((PIPSEC_SET_DIAGNOSTIC_MODE)pvIoBuffer)->Mode;
                	LogInterval = ((PIPSEC_SET_DIAGNOSTIC_MODE)pvIoBuffer)->LogInterval;

                	// Validate the diagnostic mode : Fail IOCTL if invalid
                	if (Mode > IPSEC_DIAGNOSTIC_MAX ){
                		status = STATUS_INVALID_PARAMETER;
                		break;
                		}
                	// Set the Diagnostic Mode
                     g_ipsec.DiagnosticMode = Mode;

                	// If LogInterval = 0 then dont change log interval
                     if ( IPSEC_NOCHANGE_LOG_INTERVAL == LogInterval){
                		break;
                     	}
                     // Default to MIN and MAX limits
                	if (IPSEC_MIN_LOG_INTERVAL > LogInterval ){
                		LogInterval = IPSEC_MIN_LOG_INTERVAL;
                		}
                	if (IPSEC_MAX_LOG_INTERVAL < LogInterval ){
                		LogInterval = IPSEC_MAX_LOG_INTERVAL;
                		}
                	// Set the Log Interval
	               g_ipsec.LogInterval = LogInterval;
	               break;
                	}
                	

                	
                		
                case IOCTL_IPSEC_SET_TCPIP_STATUS: {
                    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("Entered Set Tcpip Status"));

                    if (Irp->RequestorMode != KernelMode) {
                        status = STATUS_ACCESS_DENIED;
                        break;
                    }

                    dwSize = sizeof(IPSEC_SET_TCPIP_STATUS);
                    if (inputBufferLength < dwSize) {
                        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC_SET_TCPIP_STATUS: bad size: dwSize: %lx, input: %lx",
                        dwSize, inputBufferLength));
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecSetTcpipStatus((PIPSEC_SET_TCPIP_STATUS)pvIoBuffer);

                    break;
                }

                case IOCTL_IPSEC_REGISTER_PROTOCOL: {

                    dwSize = sizeof(IPSEC_REGISTER_PROTOCOL);
                    if (inputBufferLength < dwSize) {
                        status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }

                    status = IPSecRegisterProtocols(
                                 (PIPSEC_REGISTER_PROTOCOL) pvIoBuffer
                                 );
                    break;
                }

                default: {

                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
            }

            IPSEC_DECREMENT(g_ipsec.NumIoctls);

            break ;
        }

        default: {
            IPSEC_DEBUG(LL_A, DBF_IOCTL, ("IPSEC: unknown IRP_MJ_XXX: %lx", irpStack->MajorFunction));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    ASSERT(status != STATUS_PENDING);
    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = MIN(dwSize, outputBufferLength);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("Exiting IPSecDispath"));

    return  status;
}


NTSTATUS
IPSecBindToIP()
/*++

Routine Description:

    This bind exchanges a number of entrypoints with IP so that

        - packets relevant to IPSEC can be handed over from the IP driver.
        - buffered packets can be flushed.
        - SA Table indices can be plumbed.
        - ....

Arguments:

    NONE

Return Value:

    The function value is the final status from the bind operation.

--*/
{
    NTSTATUS   status;
    IPSEC_FUNCTIONS ipsecFns;

    PAGED_CODE();

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering IPSecBindToIP"));

    ipsecFns.Version = IP_IPSEC_BIND_VERSION;
    ipsecFns.IPSecHandler = IPSecHandlePacket;
    ipsecFns.IPSecQStatus = IPSecQueryStatus;
    ipsecFns.IPSecSendCmplt = IPSecSendComplete;
    ipsecFns.IPSecNdisStatus = IPSecNdisStatus;
    ipsecFns.IPSecRcvFWPacket = IPSecRcvFWPacket;

    status = TCPIP_SET_IPSEC(&ipsecFns);

    if (status != IP_SUCCESS) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to bind to IP: %lx", status));
    } else {
        IPSEC_DRIVER_BOUND() = TRUE;
        IPSEC_DRIVER_SEND_BOUND() = TRUE;
    }

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting IPSecBindToIP"));

    return status;
}


NTSTATUS
IPSecUnbindFromIP()
/*++

Routine Description:

    This unbinds from the Filter Driver

Arguments:

    NONE

Return Value:

    The function value is the final status from the bind operation.

--*/
{
    NTSTATUS    status;
    IPSEC_FUNCTIONS ipsecFns={0};

    PAGED_CODE();

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering IPSecUnbindFromIP"));

    ipsecFns.Version = IP_IPSEC_BIND_VERSION;

    status = TCPIP_UNSET_IPSEC(&ipsecFns);

    if (status != IP_SUCCESS) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to bind to IP: %lx", status));
    } else {
        IPSEC_DRIVER_BOUND() = FALSE;
    }

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting IPSecUnbindFromIP"));

    return status;
}


NTSTATUS
IPSecUnbindSendFromIP()
/*++

Routine Description:

    Unbinds just the send handler from IP

Arguments:

    NONE

Return Value:

    The function value is the final status from the bind operation.

--*/
{
    NTSTATUS    status;
    IPSEC_FUNCTIONS ipsecFns={0};

    PAGED_CODE();

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering IPSecUnbindSendFromIP"));

    ipsecFns.Version = IP_IPSEC_BIND_VERSION;

    status = TCPIP_UNSET_IPSEC_SEND(&ipsecFns);

    if (status != IP_SUCCESS) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to bind to IP: %lx", status));
    } else {
        IPSEC_DRIVER_SEND_BOUND() = FALSE;
    }

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting IPSecUnbindSendFromIP"));

    return status;
}


NTSTATUS
OpenRegKey(
    PHANDLE          HandlePtr,
    PWCHAR           KeyName
    )
/*++

Routine Description:

    Opens a Registry key and returns a handle to it.

Arguments:

    HandlePtr - The varible into which to write the opened handle.
    KeyName   - The name of the Registry key to open.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UKeyName;

    PAGED_CODE();

    RtlInitUnicodeString(&UKeyName, KeyName);

    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&ObjectAttributes,
                               &UKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(HandlePtr,
                       KEY_READ,
                       &ObjectAttributes);

    return Status;
}


NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    )
/*++

Routine Description:

    Reads a REG_DWORD value from the registry into the supplied variable.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - The variable into which to read the data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR                       keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING              UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));


    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);

    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_DWORD) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((ULONG UNALIGNED *)((PCHAR)keyValueFullInformation +
                             keyValueFullInformation->DataOffset));
        }
    }

    return status;
}


NTSTATUS
GetRegStringValue(
    HANDLE                         KeyHandle,
    PWCHAR                          ValueName,
    PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
    PUSHORT                         ValueSize
    )

/*++

Routine Description:

    Reads a REG_*_SZ string value from the Registry into the supplied
    key value buffer. If the buffer string buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination for the read data.
    ValueSize  - Size of the ValueData buffer. Updated on output.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    UNICODE_STRING              UValueName;


    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwQueryValueKey(
                 KeyHandle,
                 &UValueName,
                 KeyValuePartialInformation,
                 *ValueData,
                 (ULONG) *ValueSize,
                 &resultLength
    			 );

    if ( (status == STATUS_BUFFER_OVERFLOW) ||
         (status == STATUS_BUFFER_TOO_SMALL)
       )
    {
        PVOID temp;

        //
        // Free the old buffer and allocate a new one of the
        // appropriate size.
        //

        ASSERT(resultLength > (ULONG) *ValueSize);

        if (resultLength <= 0xFFFF) {

            temp = IPSecAllocateMemory(resultLength, IPSEC_TAG_IOCTL);

            if (temp != NULL) {

                if (*ValueData != NULL) {
                    IPSecFreeMemory(*ValueData);
                }

                *ValueData = temp;
                *ValueSize = (USHORT) resultLength;

                status = ZwQueryValueKey(KeyHandle,
                                         &UValueName,
                                         KeyValuePartialInformation,
                                         *ValueData,
                                         *ValueSize,
                                         &resultLength
                						 );

                ASSERT( (status != STATUS_BUFFER_OVERFLOW) &&
                        (status != STATUS_BUFFER_TOO_SMALL)
                      );
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    }

    return  status;
}

NTSTATUS
GetRegBinaryValue(
    HANDLE                          KeyHandle,
    PWCHAR                          ValueName,
    PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
    PUSHORT                         ValueSize
    )

/*++

Routine Description:

    Reads a binary from the Registry into the supplied
    key value buffer. If the buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination for the read data.
    ValueSize  - Size of the ValueData buffer. Updated on output.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    UNICODE_STRING              UValueName;


    PAGED_CODE();

	RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwQueryValueKey(
                 KeyHandle,
                 &UValueName,
                 KeyValuePartialInformation,
                 *ValueData,
                 (ULONG) *ValueSize,
                 &resultLength
    			 );

    if ( (status == STATUS_BUFFER_OVERFLOW) ||
         (status == STATUS_BUFFER_TOO_SMALL)
       )
    {
        PVOID temp;

        //
        // Free the old buffer and allocate a new one of the
        // appropriate size.
        //

        ASSERT(resultLength > (ULONG) *ValueSize);

        if (resultLength <= 0xFFFF) {

            temp = IPSecAllocateMemory(resultLength, IPSEC_TAG_IOCTL);

            if (temp != NULL) {

                if (*ValueData != NULL) {
                    IPSecFreeMemory(*ValueData);
                }

                *ValueData = temp;
                *ValueSize = (USHORT) resultLength;

                status = ZwQueryValueKey(KeyHandle,
                                         &UValueName,
                                         KeyValuePartialInformation,
                                         *ValueData,
                                         *ValueSize,
                                         &resultLength
                						 );

                ASSERT( (status != STATUS_BUFFER_OVERFLOW) &&
                        (status != STATUS_BUFFER_TOO_SMALL)
                      );
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    }

    return  status;
}



 

NTSTATUS
GetRegMultiSZValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PUNICODE_STRING  ValueData
    )

/*++

Routine Description:

    Reads a REG_MULTI_SZ string value from the Registry into the supplied
    Unicode string. If the Unicode string buffer is not large enough,
    it is reallocated.

Arguments:

    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination Unicode string for the value data.

Return Value:

    STATUS_SUCCESS or an appropriate failure code.

--*/
{
    NTSTATUS                       status;
    ULONG                          resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
    UNICODE_STRING                 UValueName;


    PAGED_CODE();

    ValueData->Length = 0;

    status = GetRegStringValue(
                 KeyHandle,
                 ValueName,
                 (PKEY_VALUE_PARTIAL_INFORMATION *) &(ValueData->Buffer),
                 &(ValueData->MaximumLength)
                 );

    if (NT_SUCCESS(status)) {

        keyValuePartialInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION) ValueData->Buffer;

        if (keyValuePartialInformation->Type == REG_MULTI_SZ) {

            ValueData->Length = (USHORT)
                                keyValuePartialInformation->DataLength;

            RtlCopyMemory(
                ValueData->Buffer,
                &(keyValuePartialInformation->Data),
                ValueData->Length
                );
        }
        else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }

    return status;

} // GetRegMultiSZValue


VOID
IPSecReadRegistry()
/*++

Routine Description:

    Reads config info from registry into g_ipsec

Arguments:


Return Value:

    status of the read.

--*/
{
    NTSTATUS        status;
    HANDLE          hRegKey;
    WCHAR           IPSecParametersRegistryKey[] = IPSEC_REG_KEY;
    BOOLEAN         isAs = MmIsThisAnNtAsSystem();

    g_ipsec.EnableOffload = IPSEC_DEFAULT_ENABLE_OFFLOAD;
    g_ipsec.DefaultSAIdleTime = IPSEC_DEFAULT_SA_IDLE_TIME;
    g_ipsec.LogInterval = IPSEC_DEFAULT_LOG_INTERVAL;
    g_ipsec.EventQueueSize = IPSEC_DEFAULT_EVENT_QUEUE_SIZE;
    g_ipsec.RekeyTime = IPSEC_DEFAULT_REKEY;
    g_ipsec.NoDefaultExempt = IPSEC_DEFAULT_NO_DEFAULT_EXEMPT;
    g_ipsec.OperationMode = IPSEC_BLOCK_MODE;
    g_ipsec.DiagnosticMode = IPSEC_DEFAULT_ENABLE_DIAGNOSTICS;    
    
    if (isAs) {
        g_ipsec.CacheSize = IPSEC_DEFAULT_AS_CACHE_SIZE;
        g_ipsec.SAHashSize = IPSEC_DEFAULT_AS_SA_HASH_SIZE;
    } else {
        g_ipsec.CacheSize = IPSEC_DEFAULT_CACHE_SIZE;
        g_ipsec.SAHashSize = IPSEC_DEFAULT_SA_HASH_SIZE;
    }
    
    status = OpenRegKey(&hRegKey,
                        IPSecParametersRegistryKey);


    if (NT_SUCCESS(status)) {
        //
        // Expected configuration values. We use reasonable defaults if they
        // aren't available for some reason.
        //
        IPSecRegReadDword(   hRegKey,
                                IPSEC_REG_PARAM_ENABLE_OFFLOAD,
                                &g_ipsec.EnableOffload,
                                IPSEC_DEFAULT_ENABLE_OFFLOAD,
                                IPSEC_MAX_ENABLE_OFFLOAD,
                                IPSEC_MIN_ENABLE_OFFLOAD);

        IPSecRegReadDword(   hRegKey,
                                IPSEC_REG_PARAM_SA_IDLE_TIME,
                                &g_ipsec.DefaultSAIdleTime,
                                IPSEC_DEFAULT_SA_IDLE_TIME,
                                IPSEC_MAX_SA_IDLE_TIME,
                                IPSEC_MIN_SA_IDLE_TIME);

        IPSecRegReadDword(   hRegKey,
                                IPSEC_REG_PARAM_EVENT_QUEUE_SIZE,
                                &g_ipsec.EventQueueSize,
                                IPSEC_DEFAULT_EVENT_QUEUE_SIZE,
                                IPSEC_MAX_EVENT_QUEUE_SIZE,
                                IPSEC_MIN_EVENT_QUEUE_SIZE);

        IPSecRegReadDword(   hRegKey,
                                IPSEC_REG_PARAM_LOG_INTERVAL,
                                &g_ipsec.LogInterval,
                                IPSEC_DEFAULT_LOG_INTERVAL,
                                IPSEC_MAX_LOG_INTERVAL,
                                IPSEC_MIN_LOG_INTERVAL);

        IPSecRegReadDword(   hRegKey,
                                IPSEC_REG_PARAM_REKEY_TIME,
                                &g_ipsec.RekeyTime,
                                IPSEC_DEFAULT_REKEY,
                                IPSEC_MAX_REKEY,
                                IPSEC_MIN_REKEY);

        IPSecRegReadDword(   hRegKey,
                                IPSEC_REG_PARAM_CACHE_SIZE,
                                &g_ipsec.CacheSize,
                                isAs? IPSEC_DEFAULT_AS_CACHE_SIZE:
                                      IPSEC_DEFAULT_CACHE_SIZE,
                                IPSEC_MAX_CACHE_SIZE,
                                IPSEC_MIN_CACHE_SIZE);

        IPSecRegReadDword(   hRegKey,
                                IPSEC_REG_PARAM_SA_HASH_SIZE,
                                &g_ipsec.SAHashSize,
                                isAs? IPSEC_DEFAULT_AS_SA_HASH_SIZE:
                                      IPSEC_DEFAULT_SA_HASH_SIZE,
                                IPSEC_MAX_SA_HASH_SIZE,
                                IPSEC_MIN_SA_HASH_SIZE);

        IPSecRegReadDword(   hRegKey,
                                IPSEC_REG_PARAM_NO_DEFAULT_EXEMPT,
                                &g_ipsec.NoDefaultExempt,
                                IPSEC_DEFAULT_NO_DEFAULT_EXEMPT,
                                IPSEC_MAX_NO_DEFAULT_EXEMPT,
                                IPSEC_MIN_NO_DEFAULT_EXEMPT);

        IPSecRegReadDword(   hRegKey,
                                IPSEC_REG_PARAM_ENABLE_DIAGNOSTICS,
                                &g_ipsec.DiagnosticMode,
                                IPSEC_DEFAULT_ENABLE_DIAGNOSTICS,
                                IPSEC_MAX_ENABLE_DIAGNOSTICS,
                                IPSEC_MIN_ENABLE_DIAGNOSTICS);

        IPSecRegReadDwordEx( hRegKey,  
                                IPSEC_REG_PARAM_OPERATION_MODE, 
                                &(ULONG)g_ipsec.OperationMode, 
                                IPSEC_OPERATION_MODE_MAX-1, // Max valid value
                                0, //Min valid value
                                IPSEC_BYPASS_MODE,//Key not exist
                                IPSEC_BLOCK_MODE, // Error in reading the key
                                IPSEC_BLOCK_MODE);// Key value out of range
        IPSecRegReadDwordEx(hRegKey,
                                                IPSEC_REG_PARAM_DFLT_FWDING_BEHAVIOR,
                                                &(ULONG)g_ipsec.DefaultForwardingBehavior,
                                                IPSEC_FORWARD_MAX-1,//Max valid
                                                0,
                                                IPSEC_FORWARD_BLOCK,//Key not exist
                                                IPSEC_FORWARD_BLOCK,// Error in reading
                                                IPSEC_FORWARD_BLOCK);//Value out of range

        ZwClose(hRegKey);
    }

    g_ipsec.CacheHalfSize = g_ipsec.CacheSize / 2;

    //
    // Init SAIdleTime for low memory reaper
    //
    IPSEC_CONVERT_SECS_TO_100NS(g_ipsec.SAIdleTime, g_ipsec.DefaultSAIdleTime);

    	if (IS_DRIVER_BLOCK() || IS_DRIVER_BOOTSTATEFUL()) {
	   // Make sure SPD will be starting 
  	    ULONG SPDStart=0;
	    WCHAR SPDParametersRegistryKey[] = SPD_REG_KEY;

	   status = OpenRegKey(&hRegKey,
					SPDParametersRegistryKey);
	   
		if (NT_SUCCESS(status)) {
			IPSecRegReadDword(   hRegKey,
									SPD_REG_PARAM_START,
									&SPDStart,
									0,  
									4,        
									0);
		  
			if (SPDStart != 2) {
				g_ipsec.OperationMode = IPSEC_BYPASS_MODE;
			}

			ZwClose(hRegKey);

		} else {
			g_ipsec.OperationMode = IPSEC_BYPASS_MODE;

		}

	}
    IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("IPSEC BOOT MODE %d\n",g_ipsec.OperationMode));
    //
    // Log the boot mode to the system event log
    //
    IPSecLogBootOperationMode();
}

NTSTATUS IPSecConvertRegExemptPolicy(
    PKEY_VALUE_PARTIAL_INFORMATION pKeyData,
    PIPSEC_EXEMPT_ENTRY *pBootExemptList,
    ULONG *pBootExemptListSize
)
{

	ULONG i;
	LONG DataLeft = pKeyData->DataLength;
	PIPSEC_EXEMPT_ENTRY pCurEntry;
	ULONG TotalEntries=0;
	ULONG CurIndex=0;


	pCurEntry = (PIPSEC_EXEMPT_ENTRY)&(pKeyData->Data[0]);
	while (DataLeft >= (LONG)sizeof(IPSEC_EXEMPT_ENTRY)) {
		
		if ((pCurEntry->Type == EXEMPT_TYPE_PDP) &&
		    ((pCurEntry->Direction == EXEMPT_DIRECTION_INBOUND) ||
		        (pCurEntry->Direction == EXEMPT_DIRECTION_OUTBOUND)) &&
		        (pCurEntry->Size == sizeof(IPSEC_EXEMPT_ENTRY))) {
			TotalEntries++;
		}
		DataLeft -= pCurEntry->Size;
		if (pCurEntry->Size == 0) {
		   break;
		}
		pCurEntry = (PIPSEC_EXEMPT_ENTRY) ((PBYTE)pCurEntry + pCurEntry->Size);
	}

    if (0 != TotalEntries ){ 
	*pBootExemptList = (PIPSEC_EXEMPT_ENTRY)IPSecAllocateMemory(TotalEntries * sizeof(IPSEC_EXEMPT_ENTRY),
																IPSEC_TAG_INIT);
	}
     else {
        *pBootExemptList = NULL;
        *pBootExemptListSize=0;
        return STATUS_SUCCESS;
        }

	if (*pBootExemptList == NULL) {
	       *pBootExemptListSize=0;
		return STATUS_INSUFFICIENT_RESOURCES;
	}

    pCurEntry = (PIPSEC_EXEMPT_ENTRY)&(pKeyData->Data[0]);
	DataLeft = pKeyData->DataLength;
	while (DataLeft >= (LONG)sizeof(IPSEC_EXEMPT_ENTRY)) {

		if ((pCurEntry->Type == EXEMPT_TYPE_PDP) &&
		    ((pCurEntry->Direction == EXEMPT_DIRECTION_INBOUND) ||
		        (pCurEntry->Direction == EXEMPT_DIRECTION_OUTBOUND)) &&
		        (pCurEntry->Size == sizeof(IPSEC_EXEMPT_ENTRY))){
			RtlCopyMemory(&((*pBootExemptList)[CurIndex]),pCurEntry,sizeof(IPSEC_EXEMPT_ENTRY));
			IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("RegSrcPort %x : RegDstPort %x",
			    (*pBootExemptList)[CurIndex].DestPort,(*pBootExemptList)[CurIndex].SrcPort));
			(*pBootExemptList)[CurIndex].DestPort = NET_SHORT((*pBootExemptList)[CurIndex].DestPort);
			(*pBootExemptList)[CurIndex].SrcPort = NET_SHORT((*pBootExemptList)[CurIndex].SrcPort);
			IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("Post swap RegSrcPort %x : RegDstPort %x",
			    (*pBootExemptList)[CurIndex].DestPort,(*pBootExemptList)[CurIndex].SrcPort));
			CurIndex++;
		}
		DataLeft -= pCurEntry->Size;
		if (pCurEntry->Size == 0) {
		   break;
		}
		pCurEntry = (PIPSEC_EXEMPT_ENTRY) ((PBYTE)pCurEntry + pCurEntry->Size);
		
	}
	*pBootExemptListSize = TotalEntries;
	return STATUS_SUCCESS;
}



NTSTATUS IPSecReadExemptPolicy()
{

	WCHAR IPSecParametersRegistryKey[] = IPSEC_REG_KEY;
	HANDLE          hRegKey = NULL;
	USHORT BlobSize=0;
	NTSTATUS Status;
	PKEY_VALUE_PARTIAL_INFORMATION pKeyData=NULL;


	Status = OpenRegKey(&hRegKey,
						IPSecParametersRegistryKey);

	if (!NT_SUCCESS(Status)) {
		goto err;
	}

	Status = GetRegBinaryValue(hRegKey,
							   IPSEC_REG_PARAM_EXEMPT_LIST,
							   &pKeyData,
							   &BlobSize);

	if (!NT_SUCCESS(Status)) {
		goto err;
	}

	if (pKeyData->Type != REG_BINARY) {
		Status = STATUS_INVALID_PARAMETER;
		goto err;
	}

	Status = IPSecConvertRegExemptPolicy(pKeyData,
										 &g_ipsec.BootExemptList,
										 &g_ipsec.BootExemptListSize);

	if (!NT_SUCCESS(Status)) {
		goto err;
	}

 err:
	if (hRegKey) {
		ZwClose(hRegKey);
	}
	if (pKeyData) {
		IPSecFreeMemory(pKeyData);
	}

	return Status;


}


NTSTATUS
IPSecGeneralInit()
/*++

Routine Description:

    General structures are initialized here.

Arguments:

    None

Return Value:


--*/
{
    PSA_TABLE_ENTRY pSA;
    LONG            i;
    NTSTATUS        status = STATUS_SUCCESS;

    PAGED_CODE();

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering IPSecGeneralInit"));

    
    NdisGetCurrentSystemTime(&g_ipsec.StartTimeDelta);

    IPSEC_DEBUG(LL_A,DBF_LOAD, ("Entering IPSecGeneralInit\n"));
   //
   // Initialize our counters
   //
   g_ipsec.dwPacketsOnWrongSA = 0;


   

    //
    // init the acquireinfo struct
    //
    InitializeListHead(&g_ipsec.AcquireInfo.PendingAcquires);
    InitializeListHead(&g_ipsec.AcquireInfo.PendingNotifies);
    InitializeListHead(&g_ipsec.LarvalSAList);
    INIT_LOCK(&g_ipsec.LarvalListLock);
    INIT_LOCK(&g_ipsec.AcquireInfo.Lock);

    //
    // Set up the hashes/tables
    //
    InitializeMRSWLock(&g_ipsec.SADBLock);
    InitializeMRSWLock(&g_ipsec.SPIListLock);

    g_ipsec.IPProtInfo.pi_xmitdone = IPSecProtocolSendComplete;
    g_ipsec.IPProtInfo.pi_protocol = PROTOCOL_ESP;

    //
    // init filter linked lists
    //
    for (i = MIN_FILTER; i <= MAX_FILTER; i++) {
        InitializeListHead(&g_ipsec.FilterList[i]);
    }

    //
    // SAs in a hash table, hashed by <SPI, Dest addr>
    //
    g_ipsec.pSADb = IPSecAllocateMemory(g_ipsec.SAHashSize * sizeof(SA_HASH), IPSEC_TAG_INIT);

    if (!g_ipsec.pSADb) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to alloc SADb hash"));
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_SA_DATABASE;

    IPSecZeroMemory(g_ipsec.pSADb, g_ipsec.SAHashSize * sizeof(SA_HASH));

    for (i = 0; i < g_ipsec.SAHashSize; i++) {
        PSA_HASH  Entry = &g_ipsec.pSADb[i];
        InitializeListHead(&Entry->SAList);
    }

    //
    // Initialize the MDL pools.
    //
    status = IPSecInitMdlPool();
    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to alloc MDL pools"));
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_MDL_POOLS;

    //
    // Initialize the cache structures.
    //
    if (!AllocateCacheStructures()) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to alloc cache structs"));
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_CACHE_STRUCT;

    //
    // Allocate EventQueue memory.
    //
    g_ipsec.IPSecLogMemory = IPSecAllocateMemory( g_ipsec.EventQueueSize * sizeof(IPSEC_EVENT_CTX),
                                            IPSEC_TAG_EVT_QUEUE);

    if (!g_ipsec.IPSecLogMemory) {
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_DEBUG_MEMORY;

    g_ipsec.IPSecLogMemoryLoc = &g_ipsec.IPSecLogMemory[0];
    g_ipsec.IPSecLogMemoryEnd = &g_ipsec.IPSecLogMemory[g_ipsec.EventQueueSize * sizeof(IPSEC_EVENT_CTX)];

    //
    // Init the timer stuff.
    //
    if (!IPSecInitTimer()) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to init timer"));
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecInitFlag |= INIT_TIMERS;

#if GPC
    status = IPSecGpcInitialize();
    if (status != STATUS_SUCCESS) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to register GPC clients"));
    }
#endif

    //
    // Arm the reaper timer
    //
    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Starting ReaperTimer"));
    IPSecStartTimer(&g_ipsec.ReaperTimer,
                    IPSecReaper,
                    IPSEC_REAPER_TIME,
                    (PVOID)NULL);

    //
    // Start EventLog timer
    //
    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Starting EventLogTimer"));
    IPSecStartTimer(&g_ipsec.EventLogTimer,
                    IPSecFlushEventLog,
                    g_ipsec.LogInterval,
                    (PVOID)NULL);

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting IPSecGeneralInit"));

    status = NsInitializeShim(IPSecDevice,
                              &g_ipsec.ShimFunctions);
    if (status != STATUS_SUCCESS) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to init natshim"));
        return status;
    }  
    
    status = IPSecReadExemptPolicy();
    if (!NT_SUCCESS (status)) {
        IPSEC_DEBUG(LL_A,DBF_LOAD, ("Failed to read exempt policy\n"));
        status = STATUS_SUCCESS;
    }

    //
    // Initialize the boot data structures
    //
    g_ipsec.BootBufferPool = NULL;
    g_ipsec.BootStatefulHT = NULL;
        

    if (IPSEC_BOOTTIME_STATEFUL_MODE == g_ipsec.OperationMode){
      //
      // Allocate the boot time stateful exemption hash table
      //
      g_ipsec.BootStatefulHT = (PIPSEC_STATEFUL_HASH_TABLE)IPSecAllocateMemory(sizeof(IPSEC_STATEFUL_HASH_TABLE),
																		IPSEC_TAG_STATEFUL_HT);
      if(g_ipsec.BootStatefulHT == NULL){
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto exit;
      }

      //
      // Allocate the memory pool for hash table entries
      //
      g_ipsec.BootBufferPool = (PIPSEC_HASH_BUFFER_POOL)IPSecAllocateMemory(sizeof(IPSEC_HASH_BUFFER_POOL),IPSEC_TAG_HASH_POOL);
      if(g_ipsec.BootBufferPool == NULL){
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto exit;
      }
       
      for (i=0;i<IPSEC_STATEFUL_HASH_TABLE_SIZE;i++){
	  InitializeListHead(&(g_ipsec.BootStatefulHT->Entry[i]));
      }

      RtlZeroMemory(g_ipsec.BootBufferPool,sizeof(IPSEC_HASH_BUFFER_POOL));
    }
        

    return STATUS_SUCCESS;
    exit:         
           return status;
}


NTSTATUS
IPSecGeneralFree()
/*++

Routine Description:

    Free general structures if IPSecGeneralInit fails.

Arguments:

    None

Return Value:


--*/
{
    INT index;
    KIRQL kIrql;

    //
    // Free SA database.
    //
    if (IPSecInitFlag & INIT_SA_DATABASE) {
        if (g_ipsec.pSADb) {
            IPSecFreeMemory(g_ipsec.pSADb);
        }
    }

    //
    // Free MDL pool.
    //
    if (IPSecInitFlag & INIT_MDL_POOLS) {
        IPSecDeinitMdlPool();
    }

    //
    // Free cache struct.
    //
    if (IPSecInitFlag & INIT_CACHE_STRUCT) {
        FreeExistingCache();
    }

    //
    // Free EventQueue memory.
    //
    if (IPSecInitFlag & INIT_DEBUG_MEMORY) {
        if (g_ipsec.IPSecLogMemory) {
            IPSecFreeMemory(g_ipsec.IPSecLogMemory);
        }
    }

    //
    // Free timers allocated.
    //
    if (IPSecInitFlag & INIT_TIMERS) {
        for (index = 0; index < IPSEC_CLASS_MAX; index++) {
            IPSecFreeMemory(g_ipsec.TimerList[index].pTimers);
        }
    }

    AcquireWriteLock(&g_ipsec.SADBLock,&kIrql);

    if (g_ipsec.BootStatefulHT){
         IPSecFreeMemory(g_ipsec.BootStatefulHT);
         g_ipsec.BootStatefulHT = NULL;
        }
    if (g_ipsec.BootBufferPool){
        IPSecFreeMemory(g_ipsec.BootBufferPool);
        g_ipsec.BootBufferPool = NULL;
        }
    if (g_ipsec.BootExemptList){
        IPSecFreeMemory(g_ipsec.BootExemptList);
        g_ipsec.BootExemptList = NULL;
        }
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecFreeConfig()
/*++

Routine Description:

    Free the SA table etc.

Arguments:

    None

Return Value:


--*/
{
    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering IPSecFreeConfig"));

    PAGED_CODE();

    FreeExistingCache();
    FreePatternDbase();

    if (g_ipsec.IPSecLogMemory) {
        IPSecFreeMemory(g_ipsec.IPSecLogMemory);
    }

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting IPSecFreeConfig"));
    return STATUS_SUCCESS;

}


NTSTATUS
IPSecInitMdlPool()
/*++

Routine Description:

    Create the MDL pool for AH and ESP headers.

Arguments:

    None

Return Value:


--*/
{
    PAGED_CODE();
    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering IPSecInitMdlPool"));

    g_ipsec.IPSecSmallBufferSize = IPSEC_SMALL_BUFFER_SIZE;
    g_ipsec.IPSecLargeBufferSize = IPSEC_LARGE_BUFFER_SIZE;
    g_ipsec.IPSecSendCompleteCtxSize = sizeof(IPSEC_SEND_COMPLETE_CONTEXT);

    g_ipsec.IPSecSmallBufferListDepth = IPSEC_LIST_DEPTH;
    g_ipsec.IPSecLargeBufferListDepth = IPSEC_LIST_DEPTH;
    g_ipsec.IPSecSendCompleteCtxDepth = IPSEC_LIST_DEPTH;

    g_ipsec.IPSecCacheLineSize = IPSEC_CACHE_LINE_SIZE;

    //
    // Initialize the lookaside lists.
    //

    g_ipsec.IPSecLookasideLists = IPSecAllocateMemory(
                                    sizeof(*g_ipsec.IPSecLookasideLists),
                                    IPSEC_TAG_LOOKASIDE_LISTS);

    if (g_ipsec.IPSecLookasideLists == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the IPSEC buffer lookaside lists.
    //
    ExInitializeNPagedLookasideList(&g_ipsec.IPSecLookasideLists->LargeBufferList,
                                    IPSecAllocateBufferPool,
                                    NULL,
                                    0,
                                    g_ipsec.IPSecLargeBufferSize,
                                    IPSEC_TAG_BUFFER_POOL,
                                    (USHORT)g_ipsec.IPSecLargeBufferListDepth);

    ExInitializeNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SmallBufferList,
                                    IPSecAllocateBufferPool,
                                    NULL,
                                    0,
                                    g_ipsec.IPSecSmallBufferSize,
                                    IPSEC_TAG_BUFFER_POOL,
                                    (USHORT)g_ipsec.IPSecSmallBufferListDepth);

    ExInitializeNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SendCompleteCtxList,
                                    NULL,
                                    NULL,
                                    0,
                                    g_ipsec.IPSecSendCompleteCtxSize,
                                    IPSEC_TAG_SEND_COMPLETE,
                                    (USHORT)g_ipsec.IPSecSendCompleteCtxDepth);

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting IPSecInitMdlPool"));
    return STATUS_SUCCESS;
}


VOID
IPSecDeinitMdlPool()
/*++

Routine Description:

    Free the MDL pool for AH and ESP headers.

Arguments:

    None

Return Value:


--*/
{
    PAGED_CODE();
    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering IPSecDeinitMdlPool"));

    //
    // Destroy the lookaside lists.
    //

    if (g_ipsec.IPSecLookasideLists != NULL) {
        ExDeleteNPagedLookasideList(&g_ipsec.IPSecLookasideLists->LargeBufferList);
        ExDeleteNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SmallBufferList);
        ExDeleteNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SendCompleteCtxList);

        IPSecFreeMemory(g_ipsec.IPSecLookasideLists);
    }

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting IPSecDeinitMdlPool"));
}


NTSTATUS
IPSecQuiesce()
/*++

Routine Description:

    Destroy MDL pools and run down all driver activity

Arguments:

    None

Return Value:


--*/
{
    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Entering IPSecQuiesce"));
    IPSecDeinitMdlPool();
    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Exiting IPSecQuiesce"));
    return  STATUS_SUCCESS;
}


BOOLEAN
AllocateCacheStructures()
/*++

Routine Description:

    Allocates the necessary memory for cache (which is an array of pointers to
    cache entries)
    Allocates necessary number of cache entries (but doesnt initialize them)
    Allocates a small number of entries and puts them on the free list (doesnt
    initialize these either)

Arguments:

    None

Return Value:

    True if the function completely succeeds, else FALSE.  If FALSE, it is upto
    the CALLER to do a rollback and clear any allocated memory


--*/
{
    ULONG   i;

    PAGED_CODE();

    g_ipsec.ppCache = IPSecAllocateMemory(g_ipsec.CacheSize * sizeof(PFILTER_CACHE), IPSEC_TAG_INIT);

    if (!g_ipsec.ppCache) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Couldnt allocate memory for Input Cache"));
        return FALSE;
    }

    IPSecZeroMemory(g_ipsec.ppCache, g_ipsec.CacheSize * sizeof(PFILTER_CACHE));

    for (i = 0; i < g_ipsec.CacheSize; i++) {
        PFILTER_CACHE  pTemp1;

        pTemp1 = IPSecAllocateMemory(sizeof(FILTER_CACHE), IPSEC_TAG_INIT);

        if (!pTemp1) {
            FreeExistingCache();
            return FALSE;
        }

        IPSecZeroMemory(pTemp1, sizeof(FILTER_CACHE));

        g_ipsec.ppCache[i] = pTemp1;

    }

    return TRUE;
}


VOID
FreeExistingCache()
/*++

Routine Description

    Frees all the cache entries, free entries and cache pointer array

Arguments

    None

Return Value

    None

--*/
{
    ULONG   i;

    PAGED_CODE();

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Freeing existing cache..."));

    IPSecResetCacheTable();

    if (g_ipsec.ppCache) {
        for (i = 0; i < g_ipsec.CacheSize; i++) {
            if (g_ipsec.ppCache[i]) {
                ExFreePool(g_ipsec.ppCache[i]);
            }
        }

        ExFreePool(g_ipsec.ppCache);
        g_ipsec.ppCache = NULL;
    }
}


VOID
FreePatternDbase()
/*++

Routine Description

    Frees all filters and SAs.

Arguments

    None

Return Value

    None

--*/
{
    PLIST_ENTRY     pEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    LONG            i, j;

    PAGED_CODE();

    //
    // Free all masked filters and associated (outbound) SAs
    //
    for (i = MIN_FILTER; i <= MAX_FILTER; i++) {

        while (!IsListEmpty(&g_ipsec.FilterList[i])) {

            pEntry = RemoveHeadList(&g_ipsec.FilterList[i]);

            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            IPSEC_DEBUG(LL_A, DBF_LOAD, ("Freeing filter: %p", pFilter));

            //
            // Free each SA under it.
            //
            for (j = 0; j < pFilter->SAChainSize; j++) {

                while (!IsListEmpty(&pFilter->SAChain[j])) {

                    pEntry = RemoveHeadList(&pFilter->SAChain[j]);

                    pSA = CONTAINING_RECORD(pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Freeing SA: %p", pSA));

                    //
                    // Remove SA from miniport if plumbed
                    //
                    if (pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
                        IPSecDelHWSA(pSA);
                    }

                    //
                    // Also remove the inbound SAs from their SPI list
                    // so we dont double free them below.
                    //
                    IPSecRemoveSPIEntry(pSA);

                    //
                    // Stop the timer if armed and deref SA.
                    //
                    IPSecStopTimerDerefSA(pSA);
                }
            }

#if GPC
            IPSecUninstallGpcFilter(pFilter);
#endif

            IPSecFreeFilter(pFilter);
        }
    }

    //
    // Free all SAs under the SPI hashes.
    //
    for (i = 0; i < g_ipsec.SAHashSize; i++) {
        PSA_HASH  pHash = &g_ipsec.pSADb[i];

        while (!IsListEmpty(&pHash->SAList)) {

            pEntry = RemoveHeadList(&pHash->SAList);

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_SPILinkage);

            IPSEC_DEBUG(LL_A, DBF_LOAD, ("Freeing SA: %p", pSA));

            if (pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
                IPSecDelHWSA(pSA);
            }

            IPSecStopTimerDerefSA(pSA);
        }
    }

    IPSecFreeMemory(g_ipsec.pSADb);

    IPSEC_DEBUG(LL_A, DBF_LOAD, ("Freed filters/SAs"));
}


SIZE_T
IPSecCalculateBufferSize(
    IN SIZE_T BufferDataSize
    )
/*++

Routine Description:

    Determines the size of an AFD buffer structure given the amount of
    data that the buffer contains.

Arguments:

    BufferDataSize - data length of the buffer.

    AddressSize - length of address structure for the buffer.

Return Value:

    Number of bytes needed for an IPSEC_LA_BUFFER structure for data of
    this size.

--*/
{
    SIZE_T mdlSize;
    SIZE_T bufferSize;

    ASSERT(BufferDataSize != 0);

    ASSERT(g_ipsec.IPSecCacheLineSize < 100);

    //
    // Determine the sizes of the various components of an IPSEC_LA_BUFFER
    // structure.  Note that these are all worst-case calculations--
    // actual sizes of the MDL and the buffer may be smaller.
    //
    bufferSize = BufferDataSize + g_ipsec.IPSecCacheLineSize;
    mdlSize = MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), bufferSize );

    return ((sizeof(IPSEC_LA_BUFFER) + mdlSize + bufferSize + 3) & ~3);

}


VOID
IPSecInitializeBuffer(
    IN PIPSEC_LA_BUFFER IPSecBuffer,
    IN SIZE_T BufferDataSize
    )
/*++

Routine Description:

    Initializes an IPSec buffer.  Sets up fields in the actual IPSEC_LA_BUFFER
    structure and initializes the MDL associated with the buffer.  This routine
    assumes that the caller has properly allocated sufficient space for all this.

Arguments:

    IPSecBuffer - points to the IPSEC_LA_BUFFER structure to initialize.

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

Return Value:

    None

--*/
{
    SIZE_T mdlSize;

    //
    // Set up the MDL pointer but don't build it yet.  We have to wait
    // until after the data buffer is built to build the MDL.
    //
    mdlSize = MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), BufferDataSize );
    IPSecBuffer->Mdl = (PMDL)&IPSecBuffer->Data[0];

    IPSEC_DEBUG(LL_A, DBF_POOL, ("IPSecBuffer: %p, MDL: %p", IPSecBuffer, IPSecBuffer->Mdl));

    //
    // Set up the data buffer pointer and length.  Note that the buffer
    // MUST begin on a cache line boundary so that we can use the fast
    // copy routines like RtlCopyMemory on the buffer.
    //
    IPSecBuffer->Buffer = (PVOID)
        (((ULONG_PTR)((PCHAR)IPSecBuffer->Mdl + mdlSize) +
                g_ipsec.IPSecCacheLineSize - 1 ) & ~((ULONG_PTR)(g_ipsec.IPSecCacheLineSize - 1)));

    IPSecBuffer->BufferLength = (ULONG)BufferDataSize;  // Sundown - FIX

    //
    // Now build the MDL and set up a pointer to the MDL in the IRP.
    //
    MmInitializeMdl( IPSecBuffer->Mdl, IPSecBuffer->Buffer, BufferDataSize );
    MmBuildMdlForNonPagedPool( IPSecBuffer->Mdl );

}


PVOID
IPSecAllocateBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    IPSec buffer structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the data buffer
        portion of the IPSec buffer.

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized PIPSEC_LA_BUFFER, or NULL if the allocation
            attempt fails.

--*/
{
    PIPSEC_LA_BUFFER IPSecBuffer;
    SIZE_T bytesRequired;

    //
    // The requested length must be the same as one of the standard
    // IPSec buffer sizes.
    //

    ASSERT( NumberOfBytes == g_ipsec.IPSecSmallBufferSize ||
            NumberOfBytes == g_ipsec.IPSecLargeBufferSize );

    //
    // Determine how much data we'll actually need for the buffer.
    //

    bytesRequired = IPSecCalculateBufferSize(NumberOfBytes);

    //
    // Get nonpaged pool for the buffer.
    //

    IPSecBuffer = IPSecAllocateMemory( bytesRequired, Tag );
    if ( IPSecBuffer == NULL ) {
        return NULL;
    }

    //
    // Initialize the buffer and return a pointer to it.
    //

    IPSecInitializeBuffer( IPSecBuffer, NumberOfBytes );

    return IPSecBuffer;


}


PIPSEC_LA_BUFFER
IPSecGetBuffer(
    IN CLONG BufferDataSize,
    IN ULONG Tag
    )
/*++

Routine Description:

    Obtains a buffer of the appropriate size for the caller.  Uses
    the preallocated buffers if possible, or else allocates a new buffer
    structure if required.

Arguments:

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

Return Value:

    PIPSEC_LA_BUFFER - a pointer to an IPSEC_LA_BUFFER structure, or NULL if one
        was not available or could not be allocated.

--*/
{
    PIPSEC_LA_BUFFER IPSecBuffer;
    SIZE_T bufferSize;
    PLIST_ENTRY listEntry;
    PNPAGED_LOOKASIDE_LIST lookasideList;

    //
    // If possible, allocate the buffer from one of the lookaside lists.
    //
    if (BufferDataSize <= g_ipsec.IPSecLargeBufferSize) {

        if ( BufferDataSize <= g_ipsec.IPSecSmallBufferSize ) {

            lookasideList = &g_ipsec.IPSecLookasideLists->SmallBufferList;
            BufferDataSize = g_ipsec.IPSecSmallBufferSize;

        } else {

            lookasideList = &g_ipsec.IPSecLookasideLists->LargeBufferList;
            BufferDataSize = g_ipsec.IPSecLargeBufferSize;

        }

        IPSecBuffer = ExAllocateFromNPagedLookasideList( lookasideList );

        if (!IPSecBuffer) {
            return  NULL;
        }

        IPSecBuffer->Tag = Tag;

        return IPSecBuffer;
    }

    //
    // Couldn't find an appropriate buffer that was preallocated.
    // Allocate one manually.  If the buffer size requested was
    // zero bytes, give them four bytes.  This is because some of
    // the routines like MmSizeOfMdl() cannot handle getting passed
    // in a length of zero.
    //
    // !!! It would be good to ROUND_TO_PAGES for this allocation
    //     if appropriate, then use entire buffer size.
    //
    if ( BufferDataSize == 0 ) {
        BufferDataSize = sizeof(ULONG);
    }

    bufferSize = IPSecCalculateBufferSize(BufferDataSize);

    IPSecBuffer = IPSecAllocateMemory(bufferSize, IPSEC_TAG_BUFFER_POOL);

    if ( IPSecBuffer == NULL ) {
        return NULL;
    }

    //
    // Initialize the IPSec buffer structure and return it.
    //
    IPSecInitializeBuffer(IPSecBuffer, BufferDataSize);

    IPSecBuffer->Tag = Tag;

    return IPSecBuffer;
}


VOID
IPSecReturnBuffer (
    IN PIPSEC_LA_BUFFER IPSecBuffer
    )
/*++

Routine Description:

    Returns an IPSec buffer to the appropriate global list, or frees
    it if necessary.

Arguments:

    IPSecBufferHeader - points to the IPSec_BUFFER_HEADER structure to return or free.

Return Value:

    None

--*/
{
    PNPAGED_LOOKASIDE_LIST lookasideList;

    //
    // If appropriate, return the buffer to one of the IPSec buffer
    // lookaside lists.
    //
    if (IPSecBuffer->BufferLength <= g_ipsec.IPSecLargeBufferSize) {

        if (IPSecBuffer->BufferLength==g_ipsec.IPSecSmallBufferSize) {
            lookasideList = &g_ipsec.IPSecLookasideLists->SmallBufferList;
        } else {
            ASSERT (IPSecBuffer->BufferLength==g_ipsec.IPSecLargeBufferSize);
            lookasideList = &g_ipsec.IPSecLookasideLists->LargeBufferList;
        }

        ExFreeToNPagedLookasideList( lookasideList, IPSecBuffer );

        return;

    }

    IPSecFreeMemory(IPSecBuffer);
}

    
NTSTATUS
IPSecWriteEvent(
    PDRIVER_OBJECT IPSecDriverObject,
    IN ULONG    EventCode,
    IN NTSTATUS NtStatusCode,
    IN ULONG    OffloadStatus,
    IN ULONG    ExtraStatus1,
    IN ULONG    ExtraStatus2,
    IN PVOID    RawDataBuffer,
    IN USHORT   RawDataLength,
    IN USHORT   NumberOfInsertionStrings,
    ...
    )

#define LAST_NAMED_ARGUMENT NumberOfInsertionStrings


/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/
{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    va_list                 ParmPtr;                    // Pointer to stack parms.
    PCHAR                   DumpData;
    LONG                    Length;
    ULONG                   i, SizeOfRawData, RemainingSpace, TotalErrorLogEntryLength;
    ULONG                   SizeOfStringData = 0;
    PWSTR                   StringOffset, InsertionString;

    if (NumberOfInsertionStrings != 0)
    {
        va_start (ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0; i < NumberOfInsertionStrings; i += 1)
        {
            InsertionString = va_arg (ParmPtr, PWSTR);
            Length = wcslen (InsertionString);
            while ((Length > 0) && (InsertionString[Length-1] == L' '))
            {
                Length--;
            }

            SizeOfStringData += (Length + 1) * sizeof(WCHAR);
        }
    }

    //
    //  Ideally we want the packet to hold the servername and ExtraInformation.
    //  Usually the ExtraInformation gets truncated.
    //

    TotalErrorLogEntryLength = min (RawDataLength + sizeof(IO_ERROR_LOG_PACKET) + 1 + SizeOfStringData,
                                    ERROR_LOG_MAXIMUM_SIZE);

    RemainingSpace = TotalErrorLogEntryLength - FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
    if (RemainingSpace > SizeOfStringData)
    {
        SizeOfRawData = RemainingSpace - SizeOfStringData;
    }
    else
    {
        SizeOfStringData = RemainingSpace;
        SizeOfRawData = 0;
    }

    ErrorLogEntry = IoAllocateErrorLogEntry (IPSecDriverObject, (UCHAR) TotalErrorLogEntryLength);
    if (ErrorLogEntry == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Fill in the error log entry
    //
    ErrorLogEntry->ErrorCode                = EventCode;
    ErrorLogEntry->UniqueErrorValue         = OffloadStatus;
    ErrorLogEntry->FinalStatus              = NtStatusCode;
    ErrorLogEntry->MajorFunctionCode        = 0;
    ErrorLogEntry->RetryCount               = 0;
    ErrorLogEntry->IoControlCode            = 0;
    ErrorLogEntry->DeviceOffset.LowPart     = ExtraStatus1;
    ErrorLogEntry->DeviceOffset.HighPart    = ExtraStatus2;
    ErrorLogEntry->DumpDataSize             = 0;
    ErrorLogEntry->NumberOfStrings          = 0;
    ErrorLogEntry->SequenceNumber           = 0;
    ErrorLogEntry->StringOffset = (USHORT) (ROUND_UP_COUNT (FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                                                            + SizeOfRawData, ALIGN_WORD));


    //
    // Append the dump data.  This information is typically an SMB header.
    //
    if ((RawDataBuffer) && (SizeOfRawData))
    {
        DumpData = (PCHAR) ErrorLogEntry->DumpData;
        Length = min (RawDataLength, (USHORT)SizeOfRawData);
        RtlCopyMemory (DumpData, RawDataBuffer, Length);
        ErrorLogEntry->DumpDataSize = (USHORT)Length;
    }

    //
    // Add the debug informatuion strings
    //
    if (NumberOfInsertionStrings)
    {
        StringOffset = (PWSTR) ((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);

        //
        // Set up ParmPtr to point to first of the caller's parameters.
        //
        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0 ; i < NumberOfInsertionStrings ; i+= 1)
        {
            InsertionString = va_arg(ParmPtr, PWSTR);
            Length = wcslen(InsertionString);
            while ( (Length > 0) && (InsertionString[Length-1] == L' '))
            {
                Length--;
            }

            if (((Length + 1) * sizeof(WCHAR)) > SizeOfStringData)
            {
                Length = (SizeOfStringData/sizeof(WCHAR)) - 1;
            }

            if (Length > 0)
            {
                RtlCopyMemory (StringOffset, InsertionString, Length*sizeof(WCHAR));
                StringOffset += Length;
                *StringOffset++ = L'\0';

                SizeOfStringData -= (Length + 1) * sizeof(WCHAR);

                ErrorLogEntry->NumberOfStrings += 1;
            }
        }
    }

    IoWriteErrorLogEntry(ErrorLogEntry);

    return(STATUS_SUCCESS);
}


VOID
IPSecLogEvents(
    IN  PVOID   Context
    )
/*++

Routine Description:

    Dumps events from the  circular buffer to the eventlog when the
    circular buffer overflows.

Arguments:

    Context - unused.

Return Value:

    None

--*/
{
    PIPSEC_LOG_EVENT    pLogEvent;
    LONG                LogSize;
    PUCHAR              pLog;

    pLogEvent = (PIPSEC_LOG_EVENT)Context;
    LogSize = 0;
    pLog = (PUCHAR)pLogEvent + FIELD_OFFSET(IPSEC_LOG_EVENT, pLog[0]);

    while (LogSize < pLogEvent->LogSize) {
        PIPSEC_EVENT_CTX    ctx = (PIPSEC_EVENT_CTX)pLog;

        if (ctx->EventCode == EVENT_IPSEC_DROP_PACKET_INBOUND ||
            ctx->EventCode == EVENT_IPSEC_DROP_PACKET_OUTBOUND) {
            WCHAR   IPAddrBufferS[(sizeof(IPAddr) * 4) + 1];
            WCHAR   IPAddrBufferD[(sizeof(IPAddr) * 4) + 1];
            WCHAR   IPProtocolBuffer[(sizeof(IPAddr) * 4) + 1];
            WCHAR   IPSPortBuffer[(sizeof(IPAddr) * 4) + 1];
            WCHAR   IPDPortBuffer[(sizeof(IPAddr) * 4) + 1];
            
            PWCHAR  stringlist[5];
            IPHeader UNALIGNED  *pIPH;            
            USHORT SrcPort=0;
            USHORT DestPort=0;
            ULONG HeaderLen;

            pIPH = (IPHeader UNALIGNED *)ctx->pPacket;
            HeaderLen=(pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;
            IPSecIPAddrToUnicodeString( pIPH->iph_src,
                                        IPAddrBufferS);
            IPSecIPAddrToUnicodeString( pIPH->iph_dest,
                                        IPAddrBufferD);
            IPSecCountToUnicodeString ( pIPH->iph_protocol,
                                        IPProtocolBuffer);

            if (pIPH->iph_protocol == PROTOCOL_TCP ||
                pIPH->iph_protocol == PROTOCOL_UDP) {
                RtlCopyMemory(&SrcPort,&ctx->pPacket[HeaderLen],sizeof(USHORT));
                RtlCopyMemory(&DestPort,&ctx->pPacket[HeaderLen+sizeof(USHORT)],sizeof(USHORT));
            }

            IPSecCountToUnicodeString ( NET_SHORT(SrcPort),
                                        IPSPortBuffer);

            IPSecCountToUnicodeString ( NET_SHORT(DestPort),
                                        IPDPortBuffer);

            IPSecWriteEvent(
                g_ipsec.IPSecDriverObject,
                ctx->EventCode,
                ctx->DropStatus.IPSecStatus,
                ctx->DropStatus.OffloadStatus,
                ctx->DropStatus.Flags,
                0,
                ctx->pPacket,
                (USHORT)ctx->PacketSize,
                5,
                IPAddrBufferS,
                IPAddrBufferD,
                IPProtocolBuffer,
                IPSPortBuffer,
                IPDPortBuffer);
                
        } else if (ctx->Addr && ctx->EventCount > 0) {
            WCHAR   IPAddrBuffer[(sizeof(IPAddr) * 4) + 1];
            WCHAR   CountBuffer[MAX_COUNT_STRING_LEN + 1];
            PWCHAR  stringList[2];

            IPSecIPAddrToUnicodeString( ctx->Addr,
                                        IPAddrBuffer);
            IPSecCountToUnicodeString(  ctx->EventCount,
                                        CountBuffer);
            stringList[0] = CountBuffer;
            stringList[1] = IPAddrBuffer;
            LOG_EVENT(
                g_ipsec.IPSecDriverObject,
                ctx->EventCode,
                ctx->UniqueEventValue,
                2,
                stringList,
                0,
                NULL);
        } else if (ctx->Addr) {
            WCHAR   IPAddrBuffer[(sizeof(IPAddr) * 4) + 1];
            PWCHAR  stringList[1];

            IPSecIPAddrToUnicodeString( ctx->Addr,
                                        IPAddrBuffer);
            stringList[0] = IPAddrBuffer;
            LOG_EVENT(
                g_ipsec.IPSecDriverObject,
                ctx->EventCode,
                ctx->UniqueEventValue,
                1,
                stringList,
                0,
                NULL);
        } else {
            LOG_EVENT(
                g_ipsec.IPSecDriverObject,
                ctx->EventCode,
                ctx->UniqueEventValue,
                0,
                NULL,
                0,
                NULL);
        }

        if (ctx->pPacket) {
            IPSecFreeLogBuffer(ctx->pPacket);
            ctx->pPacket=NULL;
        }
        pLog += sizeof(IPSEC_EVENT_CTX);
        LogSize += sizeof(IPSEC_EVENT_CTX);
    }

    IPSecFreeMemory(pLogEvent);

    IPSEC_DECREMENT(g_ipsec.NumWorkers);
}


VOID
IPSecBufferEvent(
    IN  IPAddr  Addr,
    IN  ULONG   EventCode,
    IN  ULONG   UniqueEventValue,
    IN  BOOLEAN fBufferEvent
    )
/*++

Routine Description:

    Buffers events in a circular buffer; dumps them to the eventlog when the
    circular buffer overflows.

Arguments:

    Addr - [OPTIONAL] the source IP addr of the offending peer.

    EventCode         - Identifies the error message.

    UniqueEventValue  - Identifies this instance of a given error message.

Return Value:

    None

--*/
{
    KIRQL   kIrql;

    if (!(g_ipsec.DiagnosticMode & IPSEC_DIAGNOSTIC_ENABLE_LOG)) {
        return;
    }

    ACQUIRE_LOCK(&g_ipsec.EventLogLock, &kIrql);

    if (fBufferEvent) {
        PIPSEC_EVENT_CTX    ctx;

        g_ipsec.IPSecBufferedEvents++;

        ctx = (PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc;
        ctx--;
        while (ctx >= (PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemory) {
            if (ctx->Addr == Addr &&
                ctx->EventCode == EventCode &&
                ctx->UniqueEventValue == UniqueEventValue) {
                //
                // Found a duplicate; update count and exit.
                //
                ctx->EventCount++;
        
                if (g_ipsec.IPSecBufferedEvents >= g_ipsec.EventQueueSize) {
                    goto logit;
                }

                RELEASE_LOCK(&g_ipsec.EventLogLock, kIrql);
                return;
            }
            ctx--;
        }
    }

    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->Addr = Addr;
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCode = EventCode;
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->UniqueEventValue = UniqueEventValue;

    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->pPacket=NULL;
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->PacketSize=0;
    

    if (fBufferEvent) {
        ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCount = 1;
    } else {
        ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCount = 0;
    }

    g_ipsec.IPSecLogMemoryLoc += sizeof(IPSEC_EVENT_CTX);

logit:
    if (!fBufferEvent ||
        g_ipsec.IPSecLogMemoryLoc >= g_ipsec.IPSecLogMemoryEnd ||
        g_ipsec.IPSecBufferedEvents >= g_ipsec.EventQueueSize) {
        //
        // Flush the logs.
        //
        IPSecQueueLogEvent();
    }

    RELEASE_LOCK(&g_ipsec.EventLogLock, kIrql);
}


NTSTATUS
CopyOutboundPacketToBuffer(
    IN PUCHAR pIPHeader,
    IN PVOID pData,
    OUT PUCHAR * pPacket,
    OUT ULONG * PacketSize
    )
{
    PNDIS_BUFFER pTemp;
    ULONG Length;
    ULONG dataLength=0;
    IPHeader UNALIGNED  *pIPH;
    ULONG HeaderLen=0;
    PUCHAR pBuffer;
    ULONG CopyPos=0;
    PUCHAR pPacketData;

    pIPH = (IPHeader UNALIGNED *)pIPHeader;

    pTemp = (PNDIS_BUFFER)pData;

    while (pTemp) {
        pBuffer = NULL;
        Length = 0;

        NdisQueryBufferSafe(pTemp,
                            &pBuffer,
                            &Length,
                            NormalPagePriority);

        if (!pBuffer) {
            return  STATUS_UNSUCCESSFUL;
        }

        dataLength += Length;

        pTemp = NDIS_BUFFER_LINKAGE(pTemp);
    }
    
    HeaderLen=(pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    dataLength += HeaderLen;

    if (dataLength > IPSEC_LOG_PACKET_SIZE) {
        dataLength = IPSEC_LOG_PACKET_SIZE;
    }

    if (dataLength < sizeof(IPHeader)) {
        // doesn't even have a full ip header
        return  STATUS_UNSUCCESSFUL;
    }
    if ((pIPH->iph_protocol == PROTOCOL_TCP) ||
        (pIPH->iph_protocol == PROTOCOL_UDP)) {
        if (dataLength - HeaderLen < 8) {
            // not enough room for ports
            return STATUS_UNSUCCESSFUL;
        }
    }

    *pPacket = IPSecAllocateLogBuffer(dataLength);
    if (! (*pPacket)) {
        return STATUS_UNSUCCESSFUL;
    }
    *PacketSize=dataLength;

    pTemp = (PNDIS_BUFFER)pData;
    CopyPos=0;

    while (pTemp && CopyPos < dataLength) {
        IPSecQueryNdisBuf(pTemp,&pPacketData,&Length);
        if (CopyPos + Length > dataLength) {
            Length = (dataLength - CopyPos);
        }
        RtlCopyMemory(*pPacket+CopyPos,pPacketData,Length);
        CopyPos += Length;
        pTemp = NDIS_BUFFER_LINKAGE(pTemp);
    }

    return STATUS_SUCCESS;
}


//
// pData is data after IPHeader, IPRcvBuf.
//

NTSTATUS
CopyInboundPacketToBuffer(
    IN PUCHAR pIPHeader,
    IN PVOID pData,
    OUT PUCHAR * pPacket,
    OUT ULONG * PacketSize
    )
{
    IPRcvBuf *pTemp;
    ULONG Length;
    ULONG dataLength=0;
    IPHeader UNALIGNED  *pIPH;
    ULONG HeaderLen=0;
    PUCHAR pBuffer;
    ULONG CopyPos=0;
    PUCHAR pPacketData;

    pIPH = (IPHeader UNALIGNED *)pIPHeader;

    pTemp = (IPRcvBuf*)pData;

    while (pTemp) {
        pBuffer = NULL;
        Length = 0;

        IPSecQueryRcvBuf(pTemp,
                         &pBuffer,
                         &Length);

        if (!pBuffer) {
            return  STATUS_UNSUCCESSFUL;
        }

        dataLength += Length;

        pTemp = IPSEC_BUFFER_LINKAGE(pTemp);
    }
    
    HeaderLen=(pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    dataLength += HeaderLen;

    if (dataLength > IPSEC_LOG_PACKET_SIZE) {
        dataLength = IPSEC_LOG_PACKET_SIZE;
    }

    // Sanity check length
    if (dataLength < sizeof(IPHeader)) {
        // doesn't even have a full ip header
        return  STATUS_UNSUCCESSFUL;
    }
    if ((pIPH->iph_protocol == PROTOCOL_TCP) ||
        (pIPH->iph_protocol == PROTOCOL_UDP)) {
        if (dataLength - HeaderLen < 8) {
            // not enough room for ports
            return STATUS_UNSUCCESSFUL;
        }
    }

    *pPacket = IPSecAllocateLogBuffer(dataLength);
    if (! (*pPacket)) {
        return STATUS_UNSUCCESSFUL;
    }
    *PacketSize=dataLength;

    pTemp = (IPRcvBuf*)pData;

    RtlCopyMemory(*pPacket,pIPH,HeaderLen);
    CopyPos=HeaderLen;

    while (pTemp && CopyPos < dataLength) {
        IPSecQueryRcvBuf(pTemp,&pPacketData,&Length);
        if (CopyPos + Length > dataLength) {
            Length = (dataLength - CopyPos);
        }
        RtlCopyMemory(*pPacket+CopyPos,pPacketData,Length);
        CopyPos += Length;
        pTemp = IPSEC_BUFFER_LINKAGE(pTemp);
    }

    return STATUS_SUCCESS;
}


VOID
IPSecBufferPacketDrop(
    IN  PUCHAR              pIPHeader,
    IN  PVOID               pData,
    IN OUT PULONG           pIpsecFlags,
    IN  PIPSEC_DROP_STATUS  pDropStatus
    )
/*++

Routine Description:

    Buffers events in a circular buffer; dumps them to the eventlog when the
    circular buffer overflows.

Arguments:

    EventCode         - Identifies the error message.

Return Value:

    None

--*/
{
    KIRQL   kIrql;
    PIPSEC_EVENT_CTX    ctx;
    IPHeader UNALIGNED  *pIPH;
    PNDIS_BUFFER pTemp;
    PUCHAR pPacket=NULL;
    ULONG PacketSize=0;
    ULONG Status;
    BOOL bLockHeld=FALSE;


    pIPH = (IPHeader UNALIGNED *)pIPHeader;

    if (*pIpsecFlags & IPSEC_FLAG_INCOMING) {
        if (!(g_ipsec.DiagnosticMode & IPSEC_DIAGNOSTIC_INBOUND)) {
            // Don't log
            goto out;
        }
        Status=CopyInboundPacketToBuffer(pIPHeader,
                                         pData,
                                         &pPacket,
                                         &PacketSize);
    } else {
        if (!(g_ipsec.DiagnosticMode & IPSEC_DIAGNOSTIC_OUTBOUND)) {
            //Don't log
            goto out;
        }
        Status=CopyOutboundPacketToBuffer(pIPHeader,
                                          pData,
                                          &pPacket,
                                          &PacketSize);
    }
    
    if (Status != STATUS_SUCCESS) {
        goto out;
    }

    ACQUIRE_LOCK(&g_ipsec.EventLogLock, &kIrql);
    bLockHeld=TRUE;

    g_ipsec.IPSecBufferedEvents++;
    
    ctx = (PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc;
    ctx--;

    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->Addr=pIPH->iph_src;

    if (*pIpsecFlags & IPSEC_FLAG_INCOMING) {
        ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCode = EVENT_IPSEC_DROP_PACKET_INBOUND;
    } else {
        ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCode = EVENT_IPSEC_DROP_PACKET_OUTBOUND;
    }
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->EventCount = 1;


    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->pPacket = pPacket;
    ((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->PacketSize = PacketSize;
    
    if (pDropStatus) {
        RtlCopyMemory(&(((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->DropStatus),
                      pDropStatus,sizeof(IPSEC_DROP_STATUS));
    } else {
        RtlZeroMemory(&(((PIPSEC_EVENT_CTX)g_ipsec.IPSecLogMemoryLoc)->DropStatus),
                      sizeof(IPSEC_DROP_STATUS));
    }

    g_ipsec.IPSecLogMemoryLoc += sizeof(IPSEC_EVENT_CTX);


    if (g_ipsec.IPSecLogMemoryLoc >= g_ipsec.IPSecLogMemoryEnd ||
        g_ipsec.IPSecBufferedEvents >= g_ipsec.EventQueueSize) {
        //
        // Flush the logs.
        //
        IPSecQueueLogEvent();
    }

out:
    if (bLockHeld) {
        RELEASE_LOCK(&g_ipsec.EventLogLock, kIrql);
    }
}


VOID
IPSecQueueLogEvent(
    VOID
    )
/*++

Routine Description:

    Copies the LogMemory to a temporary buffer and schedule an event to
    flush logs.

Arguments:

    None

Return Value:

    None

Notes:

    Called with EventLogLock held.

--*/
{
    PIPSEC_LOG_EVENT    pLogEvent;
    LONG                LogSize;
    PUCHAR              pLog;

    LogSize = (LONG)(g_ipsec.IPSecLogMemoryLoc - g_ipsec.IPSecLogMemory);

    //
    // Reset the log memory so we can record again.
    // 
    g_ipsec.IPSecLogMemoryLoc = g_ipsec.IPSecLogMemory;
    g_ipsec.IPSecBufferedEvents = 0;

    if (LogSize <= 0) {
        ASSERT(FALSE);
        return;
    }

    pLogEvent = IPSecAllocateMemory(LogSize + FIELD_OFFSET(IPSEC_LOG_EVENT, pLog[0]),
                                    IPSEC_TAG_EVT_QUEUE);

    if (!pLogEvent) {
        return;
    }

    pLogEvent->LogSize = LogSize;

    pLog = (PUCHAR)pLogEvent + FIELD_OFFSET(IPSEC_LOG_EVENT, pLog[0]);
    RtlCopyMemory(pLog, g_ipsec.IPSecLogMemory, LogSize);

    //
    // Queue work item to dump these into the eventlog.
    //
    ExInitializeWorkItem(&pLogEvent->LogQueueItem, IPSecLogEvents, pLogEvent);
    ExQueueWorkItem(&pLogEvent->LogQueueItem, DelayedWorkQueue);

    IPSEC_INCREMENT(g_ipsec.NumWorkers);
}


#if FIPS
BOOLEAN
IPSecFipsInitialize(
    VOID
    )
/*++

Routine Description:

	Initialize the FIPS library table.

Arguments:

    Called at PASSIVE level.

Return Value:

    TRUE/FALSE.

--*/
{
    UNICODE_STRING  DeviceName;
    PDEVICE_OBJECT  pFipsDeviceObject = NULL;
    PIRP            pIrp;
    IO_STATUS_BLOCK StatusBlock;
    KEVENT          Event;
    NTSTATUS        status;

    PAGED_CODE();

    //
    // Return success if FIPS already initialized.
    //
    if (IPSEC_DRIVER_INIT_FIPS()) {
        return  TRUE;
    }

    RtlInitUnicodeString(&DeviceName, FIPS_DEVICE_NAME);

    //
    // Get the file and device objects for FIPS.
    //
    status = IoGetDeviceObjectPointer(  &DeviceName,
                                        FILE_ALL_ACCESS,
                                        &g_ipsec.FipsFileObject,
                                        &pFipsDeviceObject);

    if (!NT_SUCCESS(status)) {
        g_ipsec.FipsFileObject = NULL;
        return  FALSE;
    }

    //
    // Build the request to send to FIPS to get library table.
    //
    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(   IOCTL_FIPS_GET_FUNCTION_TABLE,
                                            pFipsDeviceObject,
                                            NULL,
                                            0,
                                            &g_ipsec.FipsFunctionTable,
                                            sizeof(FIPS_FUNCTION_TABLE),
                                            FALSE,
                                            &Event,
                                            &StatusBlock);
    
    if (pIrp == NULL) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("IoBuildDeviceIoControlRequest IOCTL_FIPS_GET_FUNCTION_TABLE failed."));

        ObDereferenceObject(g_ipsec.FipsFileObject);
        g_ipsec.FipsFileObject = NULL;

        return  FALSE;
    }
    
    status = IoCallDriver(pFipsDeviceObject, pIrp);
    
    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
        if (status == STATUS_SUCCESS) {
            status = StatusBlock.Status;
        }
    }

    if (status != STATUS_SUCCESS) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("IoCallDriver: IOCTL_FIPS_GET_FUNCTION_TABLE failed %#x", status));

        ObDereferenceObject(g_ipsec.FipsFileObject);
        g_ipsec.FipsFileObject = NULL;

        return  FALSE;
    }
    
    IPSEC_DRIVER_INIT_FIPS() = TRUE;

    return  TRUE;
}
#endif


BOOLEAN
IPSecCryptoInitialize(
    VOID
    )
/*++

Routine Description:

	Initialize RNG and FIPS library table.

Arguments:

    None

Return Value:

    TRUE/FALSE

--*/
{
    PAGED_CODE();

    if (IPSEC_DRIVER_INIT_CRYPTO()) {
        return  TRUE;
    }

#if FIPS
    //
    // Init the FIPS crypto library.
    //
    if (!IPSecFipsInitialize()) {
        return  FALSE;
    }
#endif

    //
    // Init the RC4 key for RNG.
    //
    if (!IPSEC_DRIVER_INIT_RNG()) {
        InitializeRNG(NULL);

        if (!IPSecInitRandom()) {
            ShutdownRNG(NULL);
            return  FALSE;
        }

        IPSEC_DRIVER_INIT_RNG() = TRUE;
    }

    IPSEC_DRIVER_INIT_CRYPTO() = TRUE;

    return  TRUE;
}


BOOLEAN
IPSecCryptoDeinitialize(
    VOID
    )
/*++

Routine Description:

	Deinitialize RNG and dereference FipsFileObject.

Arguments:

    None

Return Value:

    TRUE/FALSE

--*/
{
    PAGED_CODE();

    //
    // Don't forget to shutdown RNG or we will leak memory.
    //
    if (IPSEC_DRIVER_INIT_RNG()) {
        ShutdownRNG(NULL);
    }

#if FIPS
    //
    // Dereference FipsFileObject.
    //
    if (g_ipsec.FipsFileObject) {
        ObDereferenceObject(g_ipsec.FipsFileObject);
    }
#endif

    return  TRUE;
}


NTSTATUS
IPSecRegisterProtocols(
    PIPSEC_REGISTER_PROTOCOL pIpsecRegisterProtocol
    )
{
    KIRQL           kIrql = 0;

    if (pIpsecRegisterProtocol->RegisterProtocol == IPSEC_REGISTER_PROTOCOLS) {
        if (!IPSEC_GET_VALUE(gdwInitEsp)) {
            if (TCPIP_REGISTER_PROTOCOL(
                    PROTOCOL_ESP,
                    NULL,
                    NULL,
                    IPSecESPStatus,
                    NULL,
                    NULL,
                    NULL
                    )) {
                IPSEC_SET_VALUE(gdwInitEsp, 1);
            }
            else {
                ASSERT(FALSE);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
        }
        if (!IPSEC_GET_VALUE(gdwInitAh)) {
            if (TCPIP_REGISTER_PROTOCOL(
                    PROTOCOL_AH,
                    NULL,
                    NULL,
                    IPSecAHStatus,
                    NULL,
                    NULL,
                    NULL
                    )) {
                IPSEC_SET_VALUE(gdwInitAh, 1);
            }
            else {
                ASSERT(FALSE);
                TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_ESP);
                IPSEC_SET_VALUE(gdwInitEsp, 0);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    }
    else if (pIpsecRegisterProtocol->RegisterProtocol == IPSEC_DEREGISTER_PROTOCOLS) {
        if (IPSEC_GET_VALUE(gdwInitEsp)) {
            TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_ESP);
            IPSEC_SET_VALUE(gdwInitEsp, 0);
        }
        if (IPSEC_GET_VALUE(gdwInitAh)) {
            TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_AH);
            IPSEC_SET_VALUE(gdwInitAh, 0);
        }
        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);
        ASSERT (gpParserIfEntry == NULL);
        FlushAllParserEntries();
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
    }
    else {
        return (STATUS_INVALID_PARAMETER);
    }

    return (STATUS_SUCCESS);
}



VOID IPSecCleanupBoottimeStatefulStructs(VOID)
{
	KIRQL kIrql;					   
	IPSEC_DEBUG(LL_A,DBF_BOOTTIME,
        ("Number of connections %d",
        g_ipsec.BootBufferPool->ulEntriesUsed));
      

       AcquireWriteLock(&g_ipsec.SADBLock,&kIrql);
        //Release memory used for the boottime stateful
        //mode operation
        if (g_ipsec.BootStatefulHT){
             IPSecFreeMemory(g_ipsec.BootStatefulHT);
             g_ipsec.BootStatefulHT = NULL;
            }
        if (g_ipsec.BootBufferPool){
            IPSecFreeMemory(g_ipsec.BootBufferPool);
            g_ipsec.BootBufferPool = NULL;
            }
        //Let the exemptlist hang around
        //We will use it only if someone
        //moves us back into block mode.
        //We dont expect it to be too big
        //anyway.
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);                                                                          
      
}


VOID IPSecLogBootOperationMode(VOID)
{
    NDIS_STATUS status;
    switch (g_ipsec.OperationMode){
    		case IPSEC_BOOTTIME_STATEFUL_MODE:
			    status= LOG_EVENT(
       		     			g_ipsec.IPSecDriverObject,
            					EVENT_IPSEC_BOOT_STATEFUL_MODE,
            					1,
            					0,
            					NULL,
            					0,
            					NULL);       			
			    break;
		case IPSEC_BYPASS_MODE:
		case IPSEC_SECURE_MODE:
			   status = LOG_EVENT(
       		     			g_ipsec.IPSecDriverObject,
            					EVENT_IPSEC_BOOT_BYPASS_MODE,
            					1,
            					0,
            					NULL,
            					0,
            					NULL);       			
			    break;
		case IPSEC_BLOCK_MODE:
			     status = LOG_EVENT(
       		     			g_ipsec.IPSecDriverObject,
            					EVENT_IPSEC_BOOT_BLOCK_MODE,
            					1,
            					0,
            					NULL,
            					0,
            					NULL);       			
			    break;
		default:
			break;
    	}
    	IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("Boot Operation Mode = %d\n",g_ipsec.OperationMode));
}


VOID IPSecLogChangeOperationMode(VOID)
{
	switch (g_ipsec.OperationMode){      	
      	case IPSEC_BLOCK_MODE:
       		LOG_EVENT(
            			g_ipsec.IPSecDriverObject,
            			EVENT_IPSEC_SET_BLOCK_MODE,
            			1,
            			0,
            			NULL,
            			0,
            			NULL);       			
	       	break;
       case IPSEC_SECURE_MODE:
       		LOG_EVENT(
            			g_ipsec.IPSecDriverObject,
            			EVENT_IPSEC_SET_SECURE_MODE,
            			1,
            			0,
            			NULL,
            			0,
            			NULL);
       		break;
         case IPSEC_BYPASS_MODE:
         		LOG_EVENT(
            			g_ipsec.IPSecDriverObject,
            			EVENT_IPSEC_SET_BYPASS_MODE,
            			1,
            			0,
            			NULL,
            			0,
            			NULL);
       		break;
          default:          		
          		break;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\ahxforms.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ahxforms.c

Abstract:

    This module contains the code to create various AH transforms

Author:
   
    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"

#ifdef RUN_WPP
#include "ahxforms.tmh"
#endif

#define MAX_LEN_PAD     65


NTSTATUS
ah_nullinit(
    IN  PALGO_STATE pState,
    IN  ULONG       Index
    )
/*++

Routine Description:

    Init the MD5 context for keyed MD5

Arguments:

    pState - state buffer which needs to be passed into the update/finish functions

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    return  STATUS_SUCCESS;
}


NTSTATUS
ah_nullupdate(
    IN  PALGO_STATE pState,
    IN  PUCHAR      pData,
    IN  ULONG       Len
    )
/*++

Routine Description:

    Continue MD5 over the data passed in; as a side-effect, updates the bytes
    transformed count in the SA (for key-expiration)

Arguments:

    pState - algo state buffer

    pData  - data to be hashed

    Len    - length of above data

Return Value:

    STATUS_SUCCESS
--*/
{
    return STATUS_SUCCESS;
}


NTSTATUS
ah_nullfinish(
    IN  PALGO_STATE pState,
    OUT PUCHAR      pHash,
    IN  ULONG       Index
    )
/*++

Routine Description:

    Finish the MD5 calculation

Arguments:

    pState - algo state buffer

    pHash  - pointer to final hash data

Return Value:

    STATUS_SUCCESS

--*/
{
    RtlCopyMemory(pHash, "0123456789012345", MD5DIGESTLEN);

    return STATUS_SUCCESS;
}


/*++
    The ah_hmac* family:

    Generates the actual hash using HMAC-MD5 or HMAC-SHA according to RFC 2104
    which works as under:

    We define two fixed and different strings ipad and opad as follows
    (the 'i' and 'o' are mnemonics for inner and outer):

                 ipad = the byte 0x36 repeated B times
                 opad = the byte 0x5C repeated B times.

    To compute HMAC over the data `text' we perform

          H(K XOR opad, H(K XOR ipad, text))
--*/
NTSTATUS
ah_hmacmd5init(
    IN PALGO_STATE  pState,
    IN ULONG        Index
    )
/*++

Routine Description:

    Init the MD5 context for HMAC.

Arguments:

    pState - state buffer which needs to be passed into the update/finish functions

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    PSA_TABLE_ENTRY pSA = pState->as_sa;
    PUCHAR      key = pSA->INT_KEY(Index);
    ULONG       key_len = pSA->INT_KEYLEN(Index);
    UCHAR       k_ipad[MAX_LEN_PAD];    /* inner padding - key XORd with ipad */
    UCHAR       tk[MD5DIGESTLEN];
    ULONG       i;

    IPSEC_HMAC_MD5_INIT(&(pState->as_md5ctx),
                        key,
                        key_len);

    IPSEC_DEBUG(LL_A,DBF_AHEX, ("MD5init: %lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx",
                       *(ULONG *)&(pState->as_md5ctx).in[0],
                       *(ULONG *)&(pState->as_md5ctx).in[4],
                       *(ULONG *)&(pState->as_md5ctx).in[8],
                       *(ULONG *)&(pState->as_md5ctx).in[12],
                       *(ULONG *)&(pState->as_md5ctx).in[16],
                       *(ULONG *)&(pState->as_md5ctx).in[20],
                       *(ULONG *)&(pState->as_md5ctx).in[24],
                       *(ULONG *)&(pState->as_md5ctx).in[28]));

    return  STATUS_SUCCESS;
}


NTSTATUS
ah_hmacmd5update(
    IN  PALGO_STATE pState,
    IN  PUCHAR      pData,
    IN  ULONG       Len
    )
/*++

Routine Description:

    Continue MD5 over the data passed in; as a side-effect, updates the bytes
    transformed count in the SA (for key-expiration)

Arguments:

    pState - algo state buffer

    pData  - data to be hashed

    Len    - length of above data

Return Value:

    STATUS_SUCCESS

--*/
{
    PSA_TABLE_ENTRY pSA = pState->as_sa;

    IPSEC_HMAC_MD5_UPDATE(&(pState->as_md5ctx), pData, Len);

    IPSEC_DEBUG(LL_A,DBF_AHEX, ("MD5update: %lx-%lx-%lx-%lx-%lx-%lx-%lx-%lx",
                            *(ULONG *)&(pState->as_md5ctx).in[0],
                            *(ULONG *)&(pState->as_md5ctx).in[4],
                            *(ULONG *)&(pState->as_md5ctx).in[8],
                            *(ULONG *)&(pState->as_md5ctx).in[12],
                            *(ULONG *)&(pState->as_md5ctx).in[16],
                            *(ULONG *)&(pState->as_md5ctx).in[20],
                            *(ULONG *)&(pState->as_md5ctx).in[24],
                            *(ULONG *)&(pState->as_md5ctx).in[28]));
    return STATUS_SUCCESS;
}


NTSTATUS
ah_hmacmd5finish(
    IN  PALGO_STATE pState,
    OUT PUCHAR      pHash,
    IN  ULONG           Index
    )
/*++

Routine Description:

    Finish the MD5 calculation

Arguments:

    pState - algo state buffer

    pHash  - pointer to final hash data

Return Value:

    STATUS_SUCCESS

--*/
{
    UCHAR       k_opad[MAX_LEN_PAD];    /* outer padding - key XORd with opad */
    UCHAR       tk[MD5DIGESTLEN];
    PSA_TABLE_ENTRY pSA = pState->as_sa;
    PUCHAR      key = pSA->INT_KEY(Index);
    ULONG       key_len = pSA->INT_KEYLEN(Index);
    ULONG       i;

    IPSEC_HMAC_MD5_FINAL(&(pState->as_md5ctx),key,key_len,pHash);

    return STATUS_SUCCESS;

}


NTSTATUS
ah_hmacshainit(
    IN PALGO_STATE           pState,
    IN ULONG        Index
    )
/*++

Routine Description:

    Init the SHA context for HMAC.

Arguments:

    pState - state buffer which needs to be passed into the update/finish functions

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    PSA_TABLE_ENTRY pSA = pState->as_sa;
    PUCHAR      key = pSA->INT_KEY(Index);
    ULONG       key_len = pSA->INT_KEYLEN(Index);
    UCHAR       k_ipad[MAX_LEN_PAD];    /* inner padding - key XORd with ipad */
    UCHAR       tk[A_SHA_DIGEST_LEN];
    ULONG       i;

    IPSEC_HMAC_SHA_INIT(&(pState->as_shactx),key,key_len);

    return  STATUS_SUCCESS;
}


NTSTATUS
ah_hmacshaupdate(
    IN  PALGO_STATE pState,
    IN  PUCHAR      pData,
    IN  ULONG       Len
    )
/*++

Routine Description:

    Continue A_SHA_ over the data passed in; as a side-effect, updates the bytes
    transformed count in the SA (for key-expiration)

Arguments:

    pState - algo state buffer

    pData  - data to be hashed

    Len    - length of above data

Return Value:

    STATUS_SUCCESS

--*/
{
    PSA_TABLE_ENTRY pSA = pState->as_sa;

    IPSEC_HMAC_SHA_UPDATE(&(pState->as_shactx), pData, Len);

    return STATUS_SUCCESS;
}


NTSTATUS
ah_hmacshafinish(
    IN  PALGO_STATE pState,
    OUT PUCHAR      pHash,
    IN  ULONG           Index
    )
/*++

Routine Description:

    Finish the A_SHA_ calculation

Arguments:

    pState - algo state buffer

    pHash  - pointer to final hash data

Return Value:

    STATUS_SUCCESS

--*/
{
    UCHAR       k_opad[MAX_LEN_PAD];    /* outer padding - key XORd with opad */
    UCHAR       tk[A_SHA_DIGEST_LEN];
    PSA_TABLE_ENTRY pSA = pState->as_sa;
    PUCHAR      key = pSA->INT_KEY(Index);
    ULONG       key_len = pSA->INT_KEYLEN(Index);
    ULONG       i;

    IPSEC_HMAC_SHA_FINAL(&(pState->as_shactx),key,key_len, pHash);

    return  STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\encap-hw.h ===
VOID
IPSecFillHwAddEncapSa(
    PSA_TABLE_ENTRY pSwSa,
    PPARSER_IFENTRY pParserIfEntry,
    PUCHAR pucBuffer,
    ULONG uBufLen
    );

PPARSER_IFENTRY
FindParserIfEntry (
    PPARSER_IFENTRY pParserIfEntry,
    PSA_TABLE_ENTRY pSa,
    Interface * pInterface
    );

NTSTATUS
CreateParserIfEntry(
    PSA_TABLE_ENTRY pSa,
    Interface * pInterface,
    PPARSER_IFENTRY * ppParserIfEntry
    );

NTSTATUS
GetParserEntry(
    PSA_TABLE_ENTRY pSa,
    Interface * pInterface,
    PPARSER_IFENTRY * ppParserIfEntry
    );

VOID
RemoveParserEntry (
    PPARSER_IFENTRY pParserIfEntry
    );

VOID
DerefParserEntry(
    PPARSER_IFENTRY pParserIfEntry
    );

HANDLE
UploadParserEntryAndGetHandle(
    PSA_TABLE_ENTRY pSa,
    Interface * pInterface
    );

VOID
FlushParserEntriesForInterface(
    Interface * pInterface
    );

VOID
FlushAllParserEntries(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\driver.h ===
//
// Constants used to identify what general structure has been initialized. 
//

#define INIT_SA_DATABASE    0x00000001

#define INIT_MDL_POOLS      0x00000002

#define INIT_CACHE_STRUCT   0x00000004

#define INIT_DEBUG_MEMORY   0x00000008

#define INIT_TIMERS         0x00000010

#define WORK_BUFFER_SIZE  256


#define IPSEC_REG_KEY                       L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\IPSEC"
#define SPD_REG_KEY                       L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\PolicyAgent"


#define IPSEC_REG_PARAM_ENABLE_OFFLOAD      L"EnableOffload"
#define IPSEC_REG_PARAM_SA_IDLE_TIME        L"SAIdleTime"
#define IPSEC_REG_PARAM_EVENT_QUEUE_SIZE    L"EventQueueSize"
#define IPSEC_REG_PARAM_LOG_INTERVAL        L"LogInterval"
#define IPSEC_REG_PARAM_REKEY_TIME          L"RekeyTime"
#define IPSEC_REG_PARAM_CACHE_SIZE          L"CacheSize"
#define IPSEC_REG_PARAM_SA_HASH_SIZE        L"SAHashSize"
#define IPSEC_REG_PARAM_NO_DEFAULT_EXEMPT   L"NoDefaultExempt"
#define IPSEC_REG_PARAM_ENABLE_DIAGNOSTICS  L"EnableDiagnostics"
#define IPSEC_REG_PARAM_OPERATION_MODE      L"OperationMode"
#define IPSEC_REG_PARAM_EXEMPT_LIST         L"BootExemptList"
#define IPSEC_REG_PARAM_DFLT_FWDING_BEHAVIOR L"DefaultForwardingBehavior"
#define SPD_REG_PARAM_START                 L"Start"


//
// Enable offload.
//
#define IPSEC_DEFAULT_ENABLE_OFFLOAD    1
#define IPSEC_MIN_ENABLE_OFFLOAD        0
#define IPSEC_MAX_ENABLE_OFFLOAD        1

//
// SA idle time.
//
#define IPSEC_DEFAULT_SA_IDLE_TIME      (5 * 60)
#define IPSEC_MIN_SA_IDLE_TIME          (5 * 60)
#define IPSEC_MAX_SA_IDLE_TIME          (60 * 60)

//
// Log interval.
//
#define IPSEC_DEFAULT_LOG_INTERVAL      (60 * 60)
#define IPSEC_MIN_LOG_INTERVAL          (60)
#define IPSEC_MAX_LOG_INTERVAL          (24 * 60 * 60)
#define IPSEC_NOCHANGE_LOG_INTERVAL (0)

//
// Event queue size.
//
#define IPSEC_DEFAULT_EVENT_QUEUE_SIZE  50
#define IPSEC_MIN_EVENT_QUEUE_SIZE      10
#define IPSEC_MAX_EVENT_QUEUE_SIZE      500

//
// Rekey time.
//
#define IPSEC_DEFAULT_REKEY             600
#define IPSEC_MIN_REKEY                 300
#define IPSEC_MAX_REKEY                 1500

//
// No kerberos exempt.
//
#define IPSEC_DEFAULT_NO_DEFAULT_EXEMPT 0
#define IPSEC_MIN_NO_DEFAULT_EXEMPT     0
#define IPSEC_MAX_NO_DEFAULT_EXEMPT     3



#define IPSEC_DEFAULT_ENABLE_DIAGNOSTICS 0
#define IPSEC_MIN_ENABLE_DIAGNOSTICS     0
#define IPSEC_MAX_ENABLE_DIAGNOSTICS        0x00000007


//
// First level (IP header based) cache size.
//
#define IPSEC_DEFAULT_CACHE_SIZE        64
#define IPSEC_DEFAULT_AS_CACHE_SIZE     1024
#define IPSEC_MIN_CACHE_SIZE            64
#define IPSEC_MAX_CACHE_SIZE            4096

//
// Size of the <SPI, Dest> hash table for inbound SAs.
//
#define IPSEC_DEFAULT_SA_HASH_SIZE      64
#define IPSEC_DEFAULT_AS_SA_HASH_SIZE   1024
#define IPSEC_MIN_SA_HASH_SIZE          64
#define IPSEC_MAX_SA_HASH_SIZE          4096


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
IPSecUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IPSecDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IPSecBindToIP(
    );

NTSTATUS
IPSecUnbindFromIP(
    );

NTSTATUS
IPSecUnbindSendFromIP(
    );

NTSTATUS
OpenRegKey(
    PHANDLE          HandlePtr,
    PWCHAR           KeyName
    );

NTSTATUS
GetRegDWORDValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PULONG           ValueData
    );

NTSTATUS
GetRegStringValue(
    HANDLE                         KeyHandle,
    PWCHAR                          ValueName,
    PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
    PUSHORT                         ValueSize
    );

NTSTATUS
GetRegMultiSZValue(
    HANDLE           KeyHandle,
    PWCHAR           ValueName,
    PUNICODE_STRING  ValueData
    );

VOID
IPSecReadRegistry(
    );

NTSTATUS
IPSecGeneralInit(
    );

NTSTATUS
IPSecGeneralFree(
    );

NTSTATUS
IPSecFreeConfig(
    );

NTSTATUS
IPSecInitMdlPool(
    );

VOID
IPSecDeinitMdlPool(
    );

NTSTATUS
IPSecQuiesce(
    );

BOOLEAN
AllocateCacheStructures(
    );

VOID
FreeExistingCache(
    );

VOID
FreePatternDbase(
    );

SIZE_T
IPSecCalculateBufferSize(
    IN SIZE_T BufferDataSize
    );

VOID
IPSecInitializeBuffer(
    IN PIPSEC_LA_BUFFER IPSecBuffer,
    IN SIZE_T BufferDataSize
    );

PVOID
IPSecAllocateBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

PIPSEC_LA_BUFFER
IPSecGetBuffer(
    IN CLONG BufferDataSize,
    IN ULONG Tag
    );

VOID
IPSecReturnBuffer (
    IN PIPSEC_LA_BUFFER IPSecBuffer
    );

NTSTATUS
IPSecWriteEvent(
    PDRIVER_OBJECT IPSecDriverObject,
    IN ULONG    EventCode,
    IN NTSTATUS NtStatusCode,
    IN ULONG    OffloadStatus,
    IN ULONG    ExtraStatus1,
    IN ULONG    ExtraStatus2,
    IN PVOID    RawDataBuffer,
    IN USHORT   RawDataLength,
    IN USHORT   NumberOfInsertionStrings,
    ...
    );

VOID
IPSecLogEvents(
    IN  PVOID   Context
    );

VOID
IPSecBufferEvent(
    IN  IPAddr  Addr,
    IN  ULONG   EventCode,
    IN  ULONG   UniqueEventValue,
    IN  BOOLEAN fBufferEvent
    );

NTSTATUS
CopyOutboundPacketToBuffer(
    IN PUCHAR pIPHeader,
    IN PVOID pData,
    OUT PUCHAR * pPacket,
    OUT ULONG * PacketSize
    );

NTSTATUS
CopyInboundPacketToBuffer(
    IN PUCHAR pIPHeader,
    IN PVOID pData,
    OUT PUCHAR * pPacket,
    OUT ULONG * PacketSize
    );

VOID
IPSecBufferPacketDrop(
    IN  PUCHAR              pIPHeader,
    IN  PVOID               pData,
    IN OUT PULONG           pIpsecFlags,
    IN  PIPSEC_DROP_STATUS  pDropStatus
    );

VOID
IPSecQueueLogEvent(
    VOID
    );

#if FIPS
BOOLEAN
IPSecFipsInitialize(
    VOID
    );
#endif

BOOLEAN
IPSecCryptoInitialize(
    VOID
    );

BOOLEAN
IPSecCryptoDeinitialize(
    VOID
    );

NTSTATUS
IPSecRegisterProtocols(
    PIPSEC_REGISTER_PROTOCOL pIpsecRegisterProtocol
    );

VOID
IPSecCleanupBoottimeStatefulStructs(
VOID
);

VOID 
IPSecLogBootOperationMode(
VOID
);


VOID 
IPSecLogChangeOperationMode(
VOID
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\esp.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ah.h

Abstract:

    Contains ESP specific structures

Author:

    Sanjay Anand (SanjayAn) 11-November-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef _ESP_
#define _ESP_


typedef struct _CONF_STATE_BUFFER {
    union {
        DESTable    desTable;
        DES3TABLE   des3Table;
    };
} CONF_STATE_BUFFER, *PCONF_STATE_BUFFER;


typedef VOID
(*PCONF_ALGO_INIT) (
    PVOID   pState,
    PUCHAR  pKey
);

typedef NTSTATUS
(*PCONF_ALGO_ENCRYPT) (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
);

VOID        esp_nullinit       (PVOID, PUCHAR);
NTSTATUS    esp_nullencrypt    (PVOID, PUCHAR, PUCHAR, PUCHAR);
NTSTATUS    esp_nulldecrypt    (PVOID, PUCHAR, PUCHAR, PUCHAR);

VOID        esp_desinit        (PVOID, PVOID);
NTSTATUS    esp_desencrypt     (PVOID, PUCHAR, PUCHAR, PUCHAR);
NTSTATUS    esp_desdecrypt     (PVOID, PUCHAR, PUCHAR, PUCHAR);

VOID        esp_3_desinit      (PVOID, PVOID);
NTSTATUS    esp_3_desencrypt   (PVOID, PUCHAR, PUCHAR, PUCHAR);
NTSTATUS    esp_3_desdecrypt   (PVOID, PUCHAR, PUCHAR, PUCHAR);


//
// Array of function ptrs for the ESP confidentiality algorithms
//
typedef struct  _confid_algorithm {
  PCONF_ALGO_INIT       init;       // ptr to init fn for alg.
  PCONF_ALGO_ENCRYPT    encrypt;    // ptr to encrypt fn for alg
  PCONF_ALGO_ENCRYPT    decrypt;    // ptr to encrypt fn for alg
  ULONG                 blocklen;   // Length (in u_int8s) of output
                                    // data. MUST be a multiple of 4
} CONFID_ALGO, *PCONFID_ALGO;


#define NUM_CONF_ALGOS (sizeof(conf_algorithms)/sizeof(CONFID_ALGO)-1)


IPRcvBuf *
CopyToRcvBuf(
    IN  IPRcvBuf        *DestBuf,
    IN  PUCHAR          SrcBuf,
    IN  ULONG           Size,
    IN  PULONG          StartOffset
    );

NTSTATUS
IPSecEncryptBuffer(
    IN  PVOID           pData,
    IN  PNDIS_BUFFER    *ppNewMdl,
    IN  PSA_TABLE_ENTRY pSA,
    IN  PNDIS_BUFFER    pPadBuf,
    OUT PULONG          pPadLen,
    IN  ULONG           PayloadType,
    IN  ULONG           Index,
    IN  PUCHAR          feedback
    );

NTSTATUS
IPSecDecryptBuffer(
    IN  PVOID           pData,
    IN  PSA_TABLE_ENTRY pSA,
    OUT PUCHAR          pPadLen,
    OUT PUCHAR          pPayloadType,
    IN  ULONG           Index,
    IN  ULONG           EspOffset
    );

NTSTATUS
IPSecFindAndSetMdlByOffset(IN IPRcvBuf *pData,
                           IN ULONG Offset,
                           OUT IPRcvBuf **OutMdl,
                           OUT PUCHAR *savePtr,
                           OUT PLONG saveLen);

#endif _ESP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\externs.h ===
extern ULONG IPSecNumResets;

#if DBG

extern ULONG NumAddSA;
extern ULONG NumAddSU;
extern ULONG NumAddFA;
extern ULONG NumDelSA;
extern ULONG NumDelSU;
extern ULONG NumDelFA;

extern ULONG NumReset;

extern ULONG NumAddEncapSA;
extern ULONG NumAddEncapSU;
extern ULONG NumAddEncapFA;
extern ULONG NumDelEncapSA;
extern ULONG NumDelEncapSU;
extern ULONG NumDelEncapFA;

#endif

//
//  Max timeout value (in seconds) for each class.
//
extern ULONG IPSecMaxTimerValue[];

//
//  Size of each timer wheel.
//
extern ULONG IPSecTimerListSize[];

//
//  Interval between ticks, in seconds, for each class.
//
extern ULONG IPSecTimerPeriod[];

#if GPC
extern ULONG DebugGPC;
#endif

extern AUTH_ALGO auth_algorithms[];

extern CONFID_ALGO conf_algorithms[];

#if DBG
extern ULONG IPSecDebug;
#endif

extern UCHAR DefaultPad[];


#if DBG
extern IPAddr DebugSrc;
extern IPAddr DebugDst;
extern UCHAR DebugPro;
extern ULONG DebugPkt;
extern ULONG DebugOff;
extern ULONG DebugQry;
#endif

extern RC4_KEYSTRUCT IPSecRngKey;

extern WORK_QUEUE_ITEM IPSecRngQueueItem;

extern ULONG IPSecRngBytes;

#if DBG
extern ULONG IPSecRngInRekey;
#endif


extern unsigned char weak_keys[][DES_BLOCKLEN];

extern PDEVICE_OBJECT IPSecDevice;

extern ULONG IPSecInitFlag;

extern IPSEC_GLOBAL g_ipsec;

extern LARGE_INTEGER IPSecDelayInterval;

extern DWORD gdwInitEsp;

extern DWORD gdwInitAh;

extern PPARSER_IFENTRY gpParserIfEntry;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\encap-hw.c ===
/*++


Copyright (c) 2001 Microsoft Corporation


Module Name:

    encap-hw.c

Abstract:

    This module contains all the IPSec routines for UDP ESP encapsulation
    SA and parsing entry offload.

Author:

    AbhisheV

Environment:

    Kernel Level

Revision History:


--*/


#include "precomp.h"


VOID
IPSecFillHwAddEncapSa(
    PSA_TABLE_ENTRY pSwSa,
    PPARSER_IFENTRY pParserIfEntry,
    PUCHAR pucBuffer,
    ULONG uBufLen
    )
/*++

Routine Description:

    Fills in the hardware add encapsulation sa buffer from the passed in
    software encapsulation sa.

Arguments:

    pSwSa - Pointer to the software encapsulation sa structure.

    pParserIfEntry - Pointer to the parser interface entry.

    pucBuffer - Pointer to the hardware add encapsulation sa buffer.

    uBufLen - Length of the buffer.

Return Value:

    None - VOID.

--*/
{
    POFFLOAD_IPSEC_ADD_UDPESP_SA pHwSa = (POFFLOAD_IPSEC_ADD_UDPESP_SA) pucBuffer;
    POFFLOAD_SECURITY_ASSOCIATION pHwSaInfo = NULL;
    LONG lIndex = 0;
    ULONG uOffset = 0;


    pHwSa->SrcAddr = pSwSa->SA_SRC_ADDR;
    pHwSa->SrcMask = pSwSa->SA_SRC_MASK;

    pHwSa->DstAddr = pSwSa->SA_DEST_ADDR;
    pHwSa->DstMask = pSwSa->SA_DEST_MASK;

    pHwSa->Protocol = pSwSa->SA_PROTO;

    pHwSa->SrcPort = SA_SRC_PORT(pSwSa);
    pHwSa->DstPort = SA_DEST_PORT(pSwSa);

    pHwSa->SrcTunnelAddr = 0;
    pHwSa->DstTunnelAddr = 0;
    if (pSwSa->sa_Flags & FLAGS_SA_TUNNEL) {
        pHwSa->SrcTunnelAddr = pSwSa->sa_SrcTunnelAddr;
        pHwSa->DstTunnelAddr = pSwSa->sa_TunnelAddr;
    }

    pHwSa->Flags = 0;
    if (pSwSa->sa_Flags & FLAGS_SA_OUTBOUND) {
        pHwSa->Flags |= OFFLOAD_OUTBOUND_SA;
    }
    else {
        pHwSa->Flags |= OFFLOAD_INBOUND_SA;
    }

    pHwSa->NumSAs = (SHORT) pSwSa->sa_NumOps;

    ASSERT(OFFLOAD_MAX_SAS >= pSwSa->sa_NumOps);

    pHwSa->KeyLen = 0;

    for (lIndex = 0; lIndex < pSwSa->sa_NumOps; lIndex++) {

        pHwSaInfo = &pHwSa->SecAssoc[lIndex];

        pHwSaInfo->Operation = pSwSa->sa_Operation[lIndex];
        pHwSaInfo->SPI = pSwSa->sa_OtherSPIs[lIndex];

        pHwSaInfo->EXT_INT_ALGO = pSwSa->INT_ALGO(lIndex);
        pHwSaInfo->EXT_INT_KEYLEN = pSwSa->INT_KEYLEN(lIndex);
        pHwSaInfo->EXT_INT_ROUNDS = pSwSa->INT_ROUNDS(lIndex);

        pHwSaInfo->EXT_CONF_ALGO = pSwSa->CONF_ALGO(lIndex);
        pHwSaInfo->EXT_CONF_KEYLEN = pSwSa->CONF_KEYLEN(lIndex);
        pHwSaInfo->EXT_CONF_ROUNDS = pSwSa->CONF_ROUNDS(lIndex);

        ASSERT(
            (uBufLen >= (sizeof(OFFLOAD_IPSEC_ADD_UDPESP_SA) +
                        pHwSa->KeyLen +
                        pSwSa->INT_KEYLEN(lIndex) +
                        pSwSa->CONF_KEYLEN(lIndex)))
            );

        RtlCopyMemory(
            pHwSa->KeyMat + uOffset,
            pSwSa->CONF_KEY(lIndex),
            pSwSa->CONF_KEYLEN(lIndex)
            );

        RtlCopyMemory(
            pHwSa->KeyMat + uOffset + pSwSa->CONF_KEYLEN(lIndex),
            pSwSa->INT_KEY(lIndex),
            pSwSa->INT_KEYLEN(lIndex)
            );

        uOffset += pSwSa->INT_KEYLEN(lIndex) + pSwSa->CONF_KEYLEN(lIndex);
        pHwSa->KeyLen += uOffset;

    }

    pHwSa->OffloadHandle = NULL;

    if (NULL != pParserIfEntry) {

        ASSERT (!(pSwSa->sa_Flags & FLAGS_SA_OUTBOUND));

        pHwSa->EncapTypeEntry.UdpEncapType = pParserIfEntry->UdpEncapType;
        pHwSa->EncapTypeEntry.DstEncapPort = pParserIfEntry->usDstEncapPort;
        pHwSa->EncapTypeEntryOffldHandle = pParserIfEntry->hParserIfOffload;

    } else {

        ASSERT (pSwSa->sa_Flags & FLAGS_SA_OUTBOUND); 

        if (SA_UDP_ENCAP_TYPE_IKE == pSwSa->sa_EncapType) {
            pHwSa->EncapTypeEntry.UdpEncapType = OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_IKE;
        } else if (SA_UDP_ENCAP_TYPE_OTHER == pSwSa->sa_EncapType) {
            pHwSa->EncapTypeEntry.UdpEncapType = OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_OTHER;
        } else {
            ASSERT (0);
        }

        pHwSa->EncapTypeEntry.DstEncapPort = pSwSa->sa_EncapContext.wSrcEncapPort;
        pHwSa->EncapTypeEntryOffldHandle = NULL;

    }

    return;
}


PPARSER_IFENTRY
FindParserIfEntry (
    PPARSER_IFENTRY pParserIfEntry,
    PSA_TABLE_ENTRY pSa,
    Interface * pInterface
    )
{
    ASSERT (!(pSa->sa_Flags & FLAGS_SA_OUTBOUND));

    while (NULL != pParserIfEntry) {

        if ( SA_UDP_ENCAP_TYPE_IKE == pSa->sa_EncapType ) {

            if (pParserIfEntry->UdpEncapType == OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_IKE &&
                pParserIfEntry->usDstEncapPort == pSa->sa_EncapContext.wDesEncapPort &&
                pParserIfEntry->hInterface == pInterface) {
                break;
            }

        } else if (SA_UDP_ENCAP_TYPE_OTHER == pSa->sa_EncapType ) {

            if (pParserIfEntry->UdpEncapType == OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_OTHER &&
                pParserIfEntry->usDstEncapPort == pSa->sa_EncapContext.wDesEncapPort &&
                pParserIfEntry->hInterface == pInterface) {
                break;
            }

        } else {
            ASSERT (0);
        }

        pParserIfEntry = pParserIfEntry->pNext;
    }

    return pParserIfEntry;
}


NTSTATUS
CreateParserIfEntry(
    PSA_TABLE_ENTRY pSa,
    Interface * pInterface,
    PPARSER_IFENTRY * ppParserIfEntry
    )
{
    PPARSER_IFENTRY pParserIfEntry = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pParserIfEntry = IPSecAllocateMemory(sizeof(PARSER_IFENTRY), IPSEC_TAG_PARSER);
    if (NULL == pParserIfEntry) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        BAIL_ON_NTSTATUS_ERROR(ntStatus);
    }

    RtlZeroMemory (pParserIfEntry, sizeof(PARSER_IFENTRY));

    ASSERT (!(pSa->sa_Flags & FLAGS_SA_OUTBOUND));

    if (SA_UDP_ENCAP_TYPE_IKE == pSa->sa_EncapType ) {
        pParserIfEntry->UdpEncapType = OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_IKE;
    } else if (SA_UDP_ENCAP_TYPE_OTHER == pSa->sa_EncapType ) {
        pParserIfEntry->UdpEncapType = OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_OTHER;
    } else {
        ASSERT (0);
    }

    pParserIfEntry->usDstEncapPort = pSa->sa_EncapContext.wDesEncapPort;
    pParserIfEntry->hInterface = pInterface;
    pParserIfEntry->hParserIfOffload = NULL;
    pParserIfEntry->uRefCnt = 1;

    *ppParserIfEntry = pParserIfEntry;
    return ntStatus;

error:

    *ppParserIfEntry = NULL;
    return ntStatus;
}


NTSTATUS
GetParserEntry(
    PSA_TABLE_ENTRY pSa,
    Interface * pInterface,
    PPARSER_IFENTRY * ppParserIfEntry
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PPARSER_IFENTRY pParserIfEntry = NULL;

    pParserIfEntry = FindParserIfEntry(
                         gpParserIfEntry,
                         pSa,
                         pInterface
                         );
    if (NULL == pParserIfEntry) {
        ntStatus = CreateParserIfEntry(pSa, pInterface, &pParserIfEntry);
        BAIL_ON_NTSTATUS_ERROR(ntStatus);

        pParserIfEntry->pNext = gpParserIfEntry;
        gpParserIfEntry = pParserIfEntry;
    }

    IPSEC_INCREMENT(pParserIfEntry->uRefCnt);
    *ppParserIfEntry = pParserIfEntry;
    return (ntStatus);

error:

    *ppParserIfEntry = NULL;
    return (ntStatus);
}


VOID
RemoveParserEntry (
    PPARSER_IFENTRY pParserIfEntry
    )
{
    PPARSER_IFENTRY * ppTemp = NULL;

    ppTemp = &gpParserIfEntry;

    while (*ppTemp) {

        if (*ppTemp == pParserIfEntry) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pParserIfEntry->pNext;
    } else {
        ASSERT (0);
    }

    return;
}


VOID
DerefParserEntry(
    PPARSER_IFENTRY pParserIfEntry
    )
{
    if (1 == IPSEC_DECREMENT(pParserIfEntry->uRefCnt)) {
        RemoveParserEntry (pParserIfEntry);
        IPSecFreeMemory (pParserIfEntry);
    }
}


HANDLE
UploadParserEntryAndGetHandle(
    PSA_TABLE_ENTRY pSa,
    Interface * pInterface
    )
{
    PPARSER_IFENTRY pParserIfEntry = NULL;
    HANDLE hOffloadHandle = NULL;

    pParserIfEntry = FindParserIfEntry(
                         gpParserIfEntry,
                         pSa,
                         pInterface
                         );
    if (NULL != pParserIfEntry) {
        if (IPSEC_GET_VALUE(pParserIfEntry->uRefCnt) == 2) {
            hOffloadHandle = pParserIfEntry->hParserIfOffload;
        }
        DerefParserEntry (pParserIfEntry);
    }

    return hOffloadHandle;
}


VOID
FlushParserEntriesForInterface(
    Interface * pInterface
    )
{
    PPARSER_IFENTRY pParserIfEntry = gpParserIfEntry;
    PPARSER_IFENTRY pPrevParserIfEntry = NULL;
    PPARSER_IFENTRY pTemp = NULL;

    while (NULL != pParserIfEntry) {

        if (pParserIfEntry->hInterface == pInterface) {
            pTemp = pParserIfEntry;
            pParserIfEntry = pParserIfEntry->pNext;

            if (NULL != pPrevParserIfEntry) {
                pPrevParserIfEntry->pNext = pParserIfEntry;
            } else {
                gpParserIfEntry = pParserIfEntry;
            }
            IPSecFreeMemory (pTemp);
        } else {

            pPrevParserIfEntry = pParserIfEntry;
            pParserIfEntry = pParserIfEntry->pNext;
        }
    }

    return;
}


VOID
FlushAllParserEntries(
    )
{
    PPARSER_IFENTRY pParserIfEntry = gpParserIfEntry;
    PPARSER_IFENTRY pTemp = NULL;

    while (NULL != pParserIfEntry) {
        pTemp = pParserIfEntry;
        pParserIfEntry = pParserIfEntry->pNext;
        IPSecFreeMemory (pTemp);
    }

    gpParserIfEntry = NULL;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\esp.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    esp.c

Abstract:

    This module contains the code to create/verify the ESP headers.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"

#ifdef RUN_WPP
#include "esp.tmh"
#endif

#ifndef _TEST_PERF
CONFID_ALGO  conf_algorithms[] = {
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
{ esp_desinit, esp_desencrypt, esp_desdecrypt, DES_BLOCKLEN},
{ esp_desinit, esp_desencrypt, esp_desdecrypt, DES_BLOCKLEN},
{ esp_3_desinit, esp_3_desencrypt, esp_3_desdecrypt, DES_BLOCKLEN},
};
#else
CONFID_ALGO  conf_algorithms[] = {
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
{ esp_nullinit, esp_nullencrypt, esp_nulldecrypt, DES_BLOCKLEN},
};
#endif


VOID
esp_nullinit (
    IN  PVOID   pState,
    IN  PUCHAR  pKey
    )
{
    return;
}


NTSTATUS
esp_nullencrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    RtlCopyMemory(pOut, pIn, DES_BLOCKLEN);

    return STATUS_SUCCESS;
}


NTSTATUS
esp_nulldecrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    return STATUS_SUCCESS;
}


VOID
esp_desinit (
    IN  PVOID   pState,
    IN  PUCHAR  pKey
    )
{
    DESTable    *Table = &((PCONF_STATE_BUFFER)pState)->desTable;

    IPSEC_DES_KEY(Table, pKey);
}


NTSTATUS
esp_desencrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    DESTable    *Table = &((PCONF_STATE_BUFFER)pState)->desTable;

    if (IPSEC_CBC(IPSEC_DES_ALGO,
        pOut,
        pIn,    //  pChunk,
        Table,
        ENCRYPT,
        pIV)) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_UNSUCCESSFUL;
    }
}


NTSTATUS
esp_desdecrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    DESTable    *Table = &((PCONF_STATE_BUFFER)pState)->desTable;

    if (IPSEC_CBC(IPSEC_DES_ALGO,
        pOut,
        pIn,    //  pChunk,
        Table,
        DECRYPT,
        pIV)) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_UNSUCCESSFUL;
    }
}


VOID
esp_3_desinit (
    IN  PVOID   pState,
    IN  PUCHAR  pKey
    )
{
    DES3TABLE    *Table = &((PCONF_STATE_BUFFER)pState)->des3Table;

    IPSEC_3DES_KEY(Table, pKey);
}


NTSTATUS
esp_3_desencrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    DES3TABLE    *Table = &((PCONF_STATE_BUFFER)pState)->des3Table;

    if (IPSEC_CBC(IPSEC_3DES_ALGO,
        pOut,
        pIn,    //  pChunk,
        Table,
        ENCRYPT,
        pIV)) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_UNSUCCESSFUL;
    }
}


NTSTATUS
esp_3_desdecrypt (
    PVOID   pState,
    PUCHAR  pOut,
    PUCHAR  pIn,
    PUCHAR  pIV
    )
{
    DES3TABLE    *Table = &((PCONF_STATE_BUFFER)pState)->des3Table;

    if (IPSEC_CBC(IPSEC_3DES_ALGO,
        pOut,
        pIn,    //  pChunk,
        Table,
        DECRYPT,
        pIV)) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_UNSUCCESSFUL;
    }
}


IPRcvBuf *
CopyToRcvBuf(
    IN  IPRcvBuf        *DestBuf,
    IN  PUCHAR          SrcBuf,
    IN  ULONG           Size,
    IN  PULONG          StartOffset
    )
/*++

    Copy a flat buffer to an IPRcvBuf chain.

    A utility function to copy a flat buffer to an NDIS buffer chain. We
    assume that the NDIS_BUFFER chain is big enough to hold the copy amount;
    in a debug build we'll  debugcheck if this isn't true. We return a pointer
    to the buffer where we stopped copying, and an offset into that buffer.
    This is useful for copying in pieces into the chain.

  	Input:

        DestBuf     - Destination IPRcvBuf chain.
        SrcBuf      - Src flat buffer.
        Size        - Size in bytes to copy.
        StartOffset - Pointer to start of offset into first buffer in
                        chain. Filled in on return with the offset to
                        copy into next.

  	Returns:

        Pointer to next buffer in chain to copy into.

--*/
{
    UINT        CopySize;
    UCHAR       *DestPtr;
    UINT        DestSize;
    UINT        Offset = *StartOffset;
    UCHAR      *VirtualAddress;
    UINT        Length;

    if (DestBuf == NULL || SrcBuf == NULL) {
        ASSERT(FALSE);
        return  NULL;
    }

    IPSecQueryRcvBuf(DestBuf, &VirtualAddress, &Length);
    ASSERT(Length >= Offset);
    DestPtr = VirtualAddress + Offset;
    DestSize = Length - Offset;

    for (;;) {
        CopySize = MIN(Size, DestSize);
        RtlCopyMemory(DestPtr, SrcBuf, CopySize);

        DestPtr += CopySize;
        SrcBuf += CopySize;

        if ((Size -= CopySize) == 0)
            break;

        if ((DestSize -= CopySize) == 0) {
            DestBuf = IPSEC_BUFFER_LINKAGE(DestBuf);
            
            if (DestBuf == NULL) {
                ASSERT(FALSE);
                break;
            }

            IPSecQueryRcvBuf(DestBuf, &VirtualAddress, &Length);

            DestPtr = VirtualAddress;
            DestSize = Length;
        }
    }

    *StartOffset = (ULONG)(DestPtr - VirtualAddress);

    return  DestBuf;

}


NTSTATUS
IPSecEncryptBuffer(
    IN  PVOID           pData,
    IN  PNDIS_BUFFER    *ppNewMdl,
    IN  PSA_TABLE_ENTRY pSA,
    IN  PNDIS_BUFFER    pPadBuf,
    OUT PULONG          pPadLen,
    IN  ULONG           PayloadType,
    IN  ULONG           Index,
    IN  PUCHAR          feedback
    )
{
    CONF_STATE_BUFFER   Key;
    PCONFID_ALGO        pConfAlgo;
    UCHAR   scratch[MAX_BLOCKLEN];  // scratch buffer for the encrypt
    UCHAR   scratch1[MAX_BLOCKLEN];  // scratch buffer for the encrypt
    PUCHAR  pDest=NULL;
    PNDIS_BUFFER    pEncryptMdl;
    ULONG   len;
    ULONG   blockLen;
    NTSTATUS    status, dummystatus;

    IPSEC_DEBUG(LL_A, DBF_ESP, ("Entering IPSecEncryptBuffer: pData: %p", pData));

    if (pSA->CONF_ALGO(Index) > NUM_CONF_ALGOS) {
        ASSERT(FALSE);
        return  STATUS_INVALID_PARAMETER;
    }

    pConfAlgo = &(conf_algorithms[pSA->CONF_ALGO(Index)]);
    blockLen = pConfAlgo->blocklen;

    //
    // set up the state buffer
    //
    pConfAlgo->init((PVOID)&Key, pSA->CONF_KEY(Index));

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("pConfAlgo: %p, blockLen: %lx IV: %lx-%lx", pConfAlgo, blockLen, *(PULONG)&feedback[0], *(PULONG)&feedback[4]));

    if (*ppNewMdl == NULL) {
        //
        // We should not encrypt in place: so we alloc a new buffer
        // Count up the total size and allocate the new buffer.
        // use that buffer as the dest of the encrypt.
        //
        IPSEC_GET_TOTAL_LEN(pData, &len);
#if DBG
        if ((len % 8) != 0) {
            DbgPrint("Length not kosher: pData: %p, len: %d, pPadBuf: %p, pPadLen: %d", pData, len, pPadBuf, pPadLen);
            DbgBreakPoint();
        }
#endif
        IPSecAllocateBuffer(&status, &pEncryptMdl, &pDest, len, IPSEC_TAG_ESP);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            //ASSERT(FALSE);
            IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. encrypt MDL"));
            return status;
        }

        IPSEC_DEBUG(LL_A, DBF_ESP, ("Alloc. MDL: %p, pDest: %p, len: %d, pData: %p", pEncryptMdl, pDest, len, pData));
    } else {
        ASSERT(FALSE);
        IPSecQueryNdisBuf(*ppNewMdl, &pDest, &len);
        pEncryptMdl = *ppNewMdl;
    }

    //
    // Now, send 64 bit (8 octet) chunks to CBC. We need to make sure
    // that the data is divided on contiguous 8 byte boundaries across
    // different buffers.
    //
    {
        PNDIS_BUFFER    pBuf = (PNDIS_BUFFER)pData;
        ULONG   bytesDone = 0;
        ULONG   bytesLeft;
        PUCHAR  pChunk;

        while (pBuf) {

            IPSecQueryNdisBuf(pBuf, &pChunk, &bytesLeft);

            pChunk += bytesDone;
            bytesLeft -= bytesDone;

            IPSEC_DEBUG(LL_A, DBF_ESP, ("ESP: pChunk: %p, bytesLeft: %d, bytesDone: %d", pChunk, bytesLeft, bytesDone));

            bytesDone = 0;

            while (bytesLeft >= blockLen) {
                //
                // Create the cipher.
                //
                status = pConfAlgo->encrypt( (PVOID)&Key,
                                    pDest,
                                    pChunk,
                                    feedback);
                if (!NT_SUCCESS(status)) {
                    IPSecFreeBuffer(&dummystatus, pEncryptMdl);
                    return status;
                }

                pChunk += blockLen;
                bytesLeft -= blockLen;
                pDest += blockLen;
            }

            //
            // Check here if we need to collate blocks
            //
            if (NDIS_BUFFER_LINKAGE(pBuf) != NULL) {
                PUCHAR  pNextChunk;
                ULONG   nextSize;

                //
                // If some left over from prev. buffer, collate with next
                // block
                //
                if (bytesLeft) {
                    ULONG   offset = bytesLeft; // offset into scratch
                    ULONG   bytesToCollect = blockLen - bytesLeft;  // # of bytes to collect from next few MDLs
                    IPSEC_DEBUG(LL_A, DBF_ESP, ("ESP: pChunk: %p, bytesLeft: %d", pChunk, bytesLeft));

                    ASSERT(bytesLeft < blockLen);

                    //
                    // Copy into a scratch buffer
                    //
                    RtlCopyMemory(  scratch,
                                    pChunk,
                                    bytesLeft);

                    do {
                        ASSERT(NDIS_BUFFER_LINKAGE(pBuf));
                        IPSecQueryNdisBuf(NDIS_BUFFER_LINKAGE(pBuf), &pNextChunk, &nextSize);

                        if (nextSize >= (blockLen - offset)) {
                            RtlCopyMemory(  scratch+offset,
                                            pNextChunk,
                                            blockLen - offset);
                            bytesDone = blockLen - offset;

                            bytesToCollect -= (blockLen - offset);
                            ASSERT(bytesToCollect == 0);
                        } else {
                            IPSEC_DEBUG(LL_A, DBF_ESP, ("special case, offset: %d, bytesLeft: %d, nextSize: %d, pNextChunk: %p",
                                        offset, bytesLeft, nextSize, pNextChunk));

                            RtlCopyMemory(  scratch+offset,
                                            pNextChunk,
                                            nextSize);

                            bytesToCollect -= nextSize;
                            ASSERT(bytesToCollect);

                            offset += nextSize;
                            ASSERT(offset < blockLen);

                            ASSERT(bytesDone == 0);
                            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
                        }
                    } while (bytesToCollect);

                    status = pConfAlgo->encrypt( (PVOID)&Key,
                                        pDest,
                                        scratch,
                                        feedback);
                    if (!NT_SUCCESS(status)) {
                        IPSecFreeBuffer(&dummystatus, pEncryptMdl);
                        return status;
                    }

                    pDest += blockLen;
                }
            } else {
                PUCHAR  pPad;
                ULONG   padLen;
                ULONG   bufLen;

                //
                // End of the chain; pad with length and type to 8 byte boundary
                //
                ASSERT(bytesLeft < blockLen);

                // if ((pSA->sa_eOperation == HUGHES_TRANSPORT) ||
                   //  (pSA->sa_eOperation == HUGHES_TUNNEL)) {

                //
                // since only hughes is done now, this shd be always true.
                //
                if (TRUE) {
                    ASSERT(bytesLeft == 0);

                    //
                    // DONE: break out
                    //
                    break;
                }
            }
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
        }

        //
        // save IV for next encrypt cycle
        //
        RtlCopyMemory(  pSA->sa_iv[Index],
                        feedback,
                        pSA->sa_ivlen);

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("IV: %lx-%lx", *(PULONG)&feedback[0], *(PULONG)&feedback[4]));
    }
#if DBG
    {
        ULONG   totalLen;

        IPSEC_GET_TOTAL_LEN(pEncryptMdl, &totalLen);
        ASSERT((totalLen % 8) == 0);
        IPSEC_DEBUG(LL_A, DBF_ESP, ("total len: %lx", totalLen));
    }
#endif
    IPSEC_DEBUG(LL_A, DBF_ESP, ("Exiting IPSecEncryptBuffer"));

    *ppNewMdl = pEncryptMdl;

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecDecryptBuffer(
    IN  PVOID           pData,
    IN  PSA_TABLE_ENTRY pSA,
    OUT PUCHAR          pPadLen,
    OUT PUCHAR          pPayloadType,
    IN  ULONG           Index,
    IN  ULONG           ESPOffset         // offset from start of pData where ESP header starts
    )
{
    CONF_STATE_BUFFER   Key;
    PCONFID_ALGO        pConfAlgo;
    UCHAR   feedback[MAX_BLOCKLEN];
    UCHAR   scratch[MAX_BLOCKLEN];  // scratch buffer for the encrypt
    UCHAR   scratch1[MAX_BLOCKLEN];  // scratch buffer for the encrypt
    LONG    Len;
    UCHAR   padLen;
    UCHAR   payloadType;
    LONG    hdrLen;
	IPHeader UNALIGNED *pIPH;
    ESP UNALIGNED   *pEsp;
    PUCHAR  savePtr;
    LONG    saveLen;
    LONG    espLen = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ESPOffset;
    LONG    blockLen;
    NTSTATUS status;
    IPRcvBuf TmpRcvBuf;
    IPRcvBuf    *pBuf,*SavedMdl=NULL;
    

    if (pSA->CONF_ALGO(Index) > NUM_CONF_ALGOS) {
        return  STATUS_INVALID_PARAMETER;
    }

    pConfAlgo = &(conf_algorithms[pSA->CONF_ALGO(Index)]);
    blockLen = pConfAlgo->blocklen;

    //
    // set up the state buffer
    //
    pConfAlgo->init((PVOID)&Key, pSA->CONF_KEY(Index));

    IPSecQueryRcvBuf(pData, (PUCHAR)&pEsp, &Len);

    //
    // Init the CBC feedback from the IV in the packet
    //
    // Actually if the sa_ivlen is 0, use the pSA one
    //
    if (pSA->sa_ivlen) {
        if (Len >=(LONG)(sizeof(ESP) + pSA->sa_ReplayLen + pSA->sa_ivlen + ESPOffset)) {
            RtlCopyMemory(  feedback,
                            ((PUCHAR)(pEsp + 1) + pSA->sa_ReplayLen + ESPOffset),
                            pSA->sa_ivlen);
        } else {
            status = IPSecGetRecvBytesByOffset(pData,
                                               sizeof(ESP)+pSA->sa_ReplayLen + ESPOffset,
                                               feedback,
                                               pSA->sa_ivlen);
            if (!NT_SUCCESS(status)) {
                return status;
            }
        }

        IPSEC_DEBUG(LL_A, DBF_ESP, ("IV: %lx-%lx", *(PULONG)&feedback[0], *(PULONG)&feedback[4]));
    } else {
        RtlCopyMemory(  feedback,
                        pSA->sa_iv[Index],
                        DES_BLOCKLEN);
    }

    //
    // Bump the current pointer to after the ESP header
    //
    if (((IPRcvBuf *)pData)->ipr_size >= (ULONG)espLen) {
        ((IPRcvBuf *)pData)->ipr_size -= (ULONG)espLen;
        savePtr = ((IPRcvBuf *)pData)->ipr_buffer;
        saveLen = espLen;

        ((IPRcvBuf *)pData)->ipr_buffer = savePtr + espLen;
    } else {
        status = IPSecFindAndSetMdlByOffset((IPRcvBuf*)pData,(ULONG)espLen,&(IPRcvBuf*)pData,&savePtr,&saveLen);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // Now, send 64 bit (8 octet) chunks to CBC. We need to make sure
    // that the data is divided on contiguous 8 byte boundaries across
    // different buffers.
    // NOTE: the algo below assumes that there are a minimum of 8 bytes
    // per buffer in the chain.
    //
    {
        LONG    bytesDone = 0;
        LONG    bytesLeft;
        LONG    saveBytesLeft;
        PUCHAR  pChunk;
        PUCHAR  pSaveChunk;

        pBuf=(IPRcvBuf *)pData;

        while (pBuf) {

            if (IPSEC_BUFFER_LEN(pBuf) == 0) {
                pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
                continue;
            }

            IPSecQueryRcvBuf(pBuf, &pSaveChunk, &saveBytesLeft);

            bytesLeft = saveBytesLeft - bytesDone;
            pChunk = pSaveChunk + bytesDone;

            IPSEC_DEBUG(LL_A, DBF_ESP, ("ESP: 1.pChunk: %p, bytesLeft: %d, bytesDone: %d", pChunk, bytesLeft, bytesDone));
            bytesDone = 0;

            while (bytesLeft >= blockLen) {

                //
                // Decrypt the cipher.
                //
                status = pConfAlgo->decrypt( (PVOID)&Key,
                                    pChunk,
                                    pChunk,
                                    feedback);
                if (!NT_SUCCESS(status)) {
                    return status;
                }

                pChunk += blockLen;
                bytesLeft -= blockLen;
            }

            IPSEC_DEBUG(LL_A, DBF_ESP, ("ESP: 2.pChunk: %p, bytesLeft: %d, bytesDone: %d", pChunk, bytesLeft, bytesDone));

            //
            // Check here if we need to collate blocks
            //
            if (IPSEC_BUFFER_LINKAGE(pBuf) != NULL) {
                PUCHAR  pNextChunk;
                LONG    nextSize;

                if (IPSEC_BUFFER_LEN(IPSEC_BUFFER_LINKAGE(pBuf)) == 0) {
                    pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
                }

                //
                // If some left over from prev. buffer, collate with next
                // block
                //
                if (bytesLeft) {
                    LONG    offset = bytesLeft;
                    IPSEC_DEBUG(LL_A, DBF_ESP, ("ESP: 3.pChunk: %p, bytesLeft: %d, bytesDone: %d", pChunk, bytesLeft, bytesDone));

                    ASSERT(bytesLeft < blockLen);

                    //
                    // Copy into a scratch buffer
                    //
                    RtlCopyMemory(  scratch,
                                    pChunk,
                                    bytesLeft);

                    IPSecQueryRcvBuf(IPSEC_BUFFER_LINKAGE(pBuf), &pNextChunk, &nextSize);

                    if (nextSize >= (blockLen - bytesLeft)) {
                        //
                        // Copy remaining bytes into scratch
                        //
                        RtlCopyMemory(  scratch+bytesLeft,
                                        pNextChunk,
                                        blockLen - bytesLeft);

                        status = pConfAlgo->decrypt( (PVOID)&Key,
                                            scratch,
                                            scratch,
                                            feedback);
                        if (!NT_SUCCESS(status)) {
                            return status;
                        }

                        //
                        // Copy cipher back into the payload
                        //
                        RtlCopyMemory(  pChunk,
                                        scratch,
                                        bytesLeft);

                        RtlCopyMemory(  pNextChunk,
                                        scratch+bytesLeft,
                                        blockLen - bytesLeft);

                        bytesDone = blockLen - bytesLeft;
                    } else {
                        //
                        // Ugh! Collect the remaining bytes from the chain and redistribute them
                        // after the decryption.
                        //
                        LONG    bytesToCollect = blockLen - bytesLeft;  // # of bytes to collect from next few MDLs
                        IPRcvBuf    *pFirstBuf = IPSEC_BUFFER_LINKAGE(pBuf); // to know where to start the distribution post decryption

                        do {
                            ASSERT(IPSEC_BUFFER_LINKAGE(pBuf));
                            IPSecQueryRcvBuf(IPSEC_BUFFER_LINKAGE(pBuf), &pNextChunk, &nextSize);

                            if (nextSize >= (blockLen - offset)) {
                                RtlCopyMemory(  scratch+offset,
                                                pNextChunk,
                                                blockLen - offset);
                                bytesDone = blockLen - offset;

                                bytesToCollect -= (blockLen - offset);
                                ASSERT(bytesToCollect == 0);
                            } else {
                                IPSEC_DEBUG(LL_A, DBF_ESP, ("special case, offset: %d, bytesLeft: %d, nextSize: %d, pNextChunk: %p",
                                            offset, bytesLeft, nextSize, pNextChunk));

                                RtlCopyMemory(  scratch+offset,
                                                pNextChunk,
                                                nextSize);

                                bytesToCollect -= nextSize;
                                ASSERT(bytesToCollect);

                                offset += nextSize;
                                ASSERT(offset < blockLen);

                                ASSERT(bytesDone == 0);
                                pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
                            }
                        } while (bytesToCollect);

                        status = pConfAlgo->decrypt( (PVOID)&Key,
                                            scratch,
                                            scratch,
                                            feedback);
                        if (!NT_SUCCESS(status)) {
                            return status;
                        }

                        //
                        // Now distribute the bytes back to the MDLs
                        //
                        RtlCopyMemory(  pChunk,
                                        scratch,
                                        bytesLeft);

                        pBuf = CopyToRcvBuf(pFirstBuf,
                                            scratch+bytesLeft,
                                            blockLen - bytesLeft,
                                            &bytesDone);
                        continue;

                    }
                }
            } else {
                //
                // end of chain.
                // should never come here with bytes left over since the
                // sender should pad to 8 byte boundary.
                //
                ASSERT(bytesLeft == 0);

                IPSEC_DEBUG(LL_A, DBF_ESP, ("ESP: 4.pChunk: %p, saveBytesLeft: %d, bytesDone: %d", pChunk, saveBytesLeft, bytesDone));

                IPSEC_DEBUG(LL_A, DBF_ESP, ("ESP: HUGHES: will remove pad later"));
                break;
            }

            pBuf = (IPRcvBuf *)IPSEC_BUFFER_LINKAGE(pBuf);
        }
    }

    //
    // Restore the first MDL
    //
    ((IPRcvBuf *)pData)->ipr_size += saveLen;
    ((IPRcvBuf *)pData)->ipr_buffer = savePtr;

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecFindAndSetMdlByOffset(IN IPRcvBuf *pData,
                           IN ULONG Offset,
                           OUT IPRcvBuf **OutMdl,
                           OUT PUCHAR *savePtr,
                           OUT PLONG saveLen)
{
    
    ULONG TotalStartOffset=0;       //Total start offset into data thus far 
    BYTE *pBuffer;
    ULONG CurBufLen;

    while (pData) {
        IPSecQueryRcvBuf(pData,&pBuffer,&CurBufLen);
        
        if (Offset < CurBufLen+TotalStartOffset) {
            
            // Make the OutMdl start from the given offset
            *OutMdl=pData;
            *saveLen=(Offset - TotalStartOffset);
            *savePtr=pData->ipr_buffer;
            
            (*OutMdl)->ipr_size -= (Offset - TotalStartOffset);
            (*OutMdl)->ipr_buffer += (Offset - TotalStartOffset);

            
            return STATUS_SUCCESS;
        }
        TotalStartOffset +=CurBufLen;
        pData=IPSEC_BUFFER_LINKAGE(pData);
    }
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\filter.h ===
VOID
IPSecPopulateFilter(
    IN  PFILTER         pFilter,
    IN  PIPSEC_FILTER   pIpsecFilter
    );

NTSTATUS
IPSecCreateFilter(
    IN  PIPSEC_FILTER_INFO  pFilterInfo,
    OUT PFILTER             *ppFilter
    );

NTSTATUS
IPSecInsertFilter(
    IN PFILTER             pFilter
    );

NTSTATUS
IPSecRemoveFilter(
    IN PFILTER             pFilter
    );

NTSTATUS
IPSecSearchFilter(
    IN  PFILTER MatchFilter,
    OUT PFILTER *ppFilter
    );

__inline
VOID
IPSecDeleteTempFilters(
    PLIST_ENTRY pTempFilterList
    );

NTSTATUS
IPSecAddFilter(
    IN  PIPSEC_ADD_FILTER   pAddFilter
    );

NTSTATUS
IPSecDeleteFilter(
    IN  PIPSEC_DELETE_FILTER    pDelFilter
    );

VOID
IPSecFillFilterInfo(
    IN  PFILTER             pFilter,
    OUT PIPSEC_FILTER_INFO  pBuf
    );

NTSTATUS
IPSecEnumFilters(
    IN  PIRP    pIrp,
    OUT PULONG  pBytesCopied
    );

//
// PNDIS_BUFFER
// REQUEST_NDIS_BUFFER(
//     IN PREQUEST Request
//     );
//
// Returns the NDIS buffer chain associated with a request.
//

#define REQUEST_NDIS_BUFFER(_Request) \
    ((PNDIS_BUFFER)((_Request)->MdlAddress))

PNDIS_BUFFER
CopyToNdis(
    IN  PNDIS_BUFFER    DestBuf,
    IN  PUCHAR          SrcBuf,
    IN  ULONG           Size,
    IN  PULONG          StartOffset
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\filter.c ===
#include "precomp.h"

#ifdef RUN_WPP
#include "filter.tmh"
#endif

VOID
IPSecPopulateFilter(
    IN  PFILTER         pFilter,
    IN  PIPSEC_FILTER   pIpsecFilter
    )
/*++

Routine Description

    Populates a Filter block with IpsecFilter info sent in

Arguments


Return Value


--*/
{
    pFilter->SRC_ADDR = pIpsecFilter->SrcAddr;
    pFilter->DEST_ADDR = pIpsecFilter->DestAddr;
    pFilter->SRC_MASK = pIpsecFilter->SrcMask;
    pFilter->DEST_MASK = pIpsecFilter->DestMask;

    pFilter->TunnelFilter = pIpsecFilter->TunnelFilter;
    pFilter->TunnelAddr = pIpsecFilter->TunnelAddr;
    pFilter->Flags = pIpsecFilter->Flags;

    //
    // Now the network ordering stuff - tricky part
    // LP0    LP1 LP2 LP3 HP0 HP1 HP2 HP3
    // Proto  00  00  00  SrcPort DstPort
    //

    //
    // For addresses, ANY_ADDR is given by 0.0.0.0 and the MASK must be 0.0.0.0
    // For proto and ports 0 means any and the mask is generated as follows
    // If the proto is O then LP0 for Mask is 0xff else its 0x00
    // If a port is 0, the corresponding XP0XP1 is 0x0000 else its 0xffff
    //

    //
    // The protocol is in the low byte of the dwProtocol, so we take that out and
    // make a dword out of it
    //

    pFilter->uliProtoSrcDstPort.LowPart =
      MAKELONG(MAKEWORD(LOBYTE(LOWORD(pIpsecFilter->Protocol)),0x00),0x0000);

    pFilter->uliProtoSrcDstMask.LowPart = MAKELONG(MAKEWORD(0xff,0x00),0x0000);

    switch(pIpsecFilter->Protocol) {
        case FILTER_PROTO_ANY: {
            pFilter->uliProtoSrcDstPort.HighPart = 0x00000000;
            pFilter->uliProtoSrcDstMask.LowPart = 0x00000000;
            pFilter->uliProtoSrcDstMask.HighPart = 0x00000000;

            break;
        }
        case FILTER_PROTO_ICMP: {
            WORD wTypeCode = 0x0000;
            WORD wTypeCodeMask = 0x0000;

            pFilter->uliProtoSrcDstPort.HighPart = MAKELONG(wTypeCode,0x0000);
            pFilter->uliProtoSrcDstMask.HighPart = MAKELONG(wTypeCodeMask,0x0000);

            break;
        }
        case FILTER_PROTO_TCP:
        case FILTER_PROTO_UDP: {
            DWORD dwSrcDstPort = 0x00000000;
            DWORD dwSrcDstMask = 0x00000000;

            if(pIpsecFilter->SrcPort != FILTER_TCPUDP_PORT_ANY) {
                dwSrcDstPort |= MAKELONG(NET_TO_HOST_SHORT(pIpsecFilter->SrcPort), 0x0000);
                dwSrcDstMask |= MAKELONG(0xffff, 0x0000);
            }

            if(pIpsecFilter->DestPort != FILTER_TCPUDP_PORT_ANY) {
                dwSrcDstPort |= MAKELONG(0x0000, NET_TO_HOST_SHORT(pIpsecFilter->DestPort));
                dwSrcDstMask |= MAKELONG(0x0000, 0xffff);
            }

            pFilter->uliProtoSrcDstPort.HighPart = dwSrcDstPort;
            pFilter->uliProtoSrcDstMask.HighPart = dwSrcDstMask;

            break;
        }
        default: {
            //
            // All other protocols have no use for the port field
            //
            pFilter->uliProtoSrcDstPort.HighPart = 0x00000000;
            pFilter->uliProtoSrcDstMask.HighPart = 0x00000000;
        }
    }
}


NTSTATUS
IPSecCreateFilter(
    IN  PIPSEC_FILTER_INFO  pFilterInfo,
    OUT PFILTER             *ppFilter
    )
/*++

Routine Description

    Creates a Filter block

Arguments

    PIPSEC_ADD_FILTER

Return Value


--*/
{
    PFILTER         pFilter;
    PIPSEC_FILTER   pIpsecFilter = &pFilterInfo->AssociatedFilter;
    LONG            FilterSize, SAChainSize;
    LONG            NumberOfOnes;
    LONG            i;

    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Entering CreateFilterBlock"));

    if (pFilterInfo->AssociatedFilter.TunnelFilter) {
        SAChainSize = 1;
    } else {
        if (pFilterInfo->AssociatedFilter.Flags & FILTER_FLAGS_INBOUND) {
            NumberOfOnes = CountNumberOfOnes(pFilterInfo->AssociatedFilter.SrcMask);
        } else {
            NumberOfOnes = CountNumberOfOnes(pFilterInfo->AssociatedFilter.DestMask);
        }

        SAChainSize = 1 << (((sizeof(IPMask) * 8) - NumberOfOnes) / SA_CHAIN_WIDTH);
    }

    FilterSize = FIELD_OFFSET(FILTER, SAChain[0]) + SAChainSize * sizeof(LIST_ENTRY);

    pFilter = IPSecAllocateMemory(FilterSize, IPSEC_TAG_FILTER);

    if (!pFilter) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPFILTER: Couldnt allocate memory for in filter set"));
        *ppFilter = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecZeroMemory(pFilter, FilterSize);

    pFilter->Signature = IPSEC_FILTER_SIGNATURE;

    pFilter->SAChainSize = SAChainSize;

    for (i = 0; i < SAChainSize; i++) {
        InitializeListHead(&pFilter->SAChain[i]);
    }

    pFilter->PolicyId = pFilterInfo->PolicyId;
    pFilter->FilterId = pFilterInfo->FilterId;

    pFilter->Reference = 1;

    pFilter->Index = pFilterInfo->Index;

    IPSecPopulateFilter(pFilter, pIpsecFilter);

    *ppFilter = pFilter;

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInsertFilter(
    IN PFILTER             pFilter
    )
/*++

Routine Description

    Inserts a filter into one of the two databases - specific/general pattern
    database.

Arguments

    PFILTER

Return Value


--*/
{
    NTSTATUS    status;
    PFILTER     pTempFilter;
    BOOL        InsertedFilter = FALSE;
    PLIST_ENTRY pEntry, pPrev;
    PLIST_ENTRY pFilterList;

    pFilterList = IPSecResolveFilterList(   IS_TUNNEL_FILTER(pFilter),
                                            IS_OUTBOUND_FILTER(pFilter));

    pEntry = pFilterList->Flink;
    pPrev = pFilterList;

    while (pEntry != pFilterList) {
        pTempFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

        if (pFilter->Index > pTempFilter->Index) {
            //
            // found the spot, insert it before pTempFilter
            //
            InsertHeadList(pPrev, &pFilter->MaskedLinkage);
            pFilter->LinkedFilter = TRUE;
            InsertedFilter = TRUE;
            break;
        }

        pPrev = pEntry;
        pEntry = pEntry->Flink;
    }

    if (!InsertedFilter) {
        //
        // didn't find spot, stick it in the end
        //
        InsertTailList(pFilterList, &pFilter->MaskedLinkage);
        pFilter->LinkedFilter = TRUE;
    }

    if (IS_TUNNEL_FILTER(pFilter)) {
        g_ipsec.NumTunnelFilters++;
    } else {
        g_ipsec.NumMaskedFilters++;
    }

    if (IS_MULTICAST_FILTER(pFilter)) {
        IPSEC_INCREMENT(g_ipsec.NumMulticastFilters);
    }
    ++g_ipsec.NumPolicies;

    if (g_ipsec.NumPolicies == 1) {
        TCPIP_SET_IPSEC_STATUS(TRUE);
    }

    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecInsertFilter: inserted into filter list %p", pFilter));

    IPSecResetCacheTable();

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecRemoveFilter(
    IN PFILTER             pFilter
    )
/*++

Routine Description

    Deletes a filter from one of the two databases - specific/general pattern
    database.
    Runs down the SAs then blows away the memory.

Arguments

    PFILTER

Return Value


--*/
{
    IPSEC_DEBUG(LL_A, DBF_IOCTL, ("In IPSecRemoveFilter!"));

    IPSecPurgeFilterSAs(pFilter);

    IPSecResetCacheTable();

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecSearchFilter(
    IN  PFILTER MatchFilter,
    OUT PFILTER *ppFilter
    )
/*++

Routine Description

    Utility routine to search for a filter in the database.

    NOTE: MUST be called with the SADB lock held.

Arguments

    MatchFilter -   the criteria to match

    ppFilter    -   return the filter matched

Return Value


--*/
{
    BOOLEAN         fFound = FALSE;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pFilterList;
    PFILTER         pFilter;
    NTSTATUS        status = STATUS_NOT_FOUND;

    *ppFilter = NULL;

    pFilterList = IPSecResolveFilterList(   IS_TUNNEL_FILTER(MatchFilter),
                                            IS_OUTBOUND_FILTER(MatchFilter));

    //
    // Search in the filter list that the filter corresponds to.
    //
    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        if ((MatchFilter->uliSrcDstAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (MatchFilter->uliSrcDstMask.QuadPart == pFilter->uliSrcDstMask.QuadPart) &&
            (MatchFilter->uliProtoSrcDstPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart) &&
            (MatchFilter->uliProtoSrcDstMask.QuadPart == pFilter->uliProtoSrcDstMask.QuadPart)) {
            IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pFilter));

            status = STATUS_SUCCESS;
            *ppFilter = pFilter;
            fFound = TRUE;
            break;
        }
    }

    return status;
}


__inline
VOID
IPSecDeleteTempFilters(
    PLIST_ENTRY pTempFilterList
    )
{
    PLIST_ENTRY pEntry;
    PFILTER     pFilter;

    while (!IsListEmpty(pTempFilterList)) {
        pEntry = RemoveHeadList(pTempFilterList);

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

#if GPC
        IPSecUninstallGpcFilter(pFilter);
#endif

        IPSecFreeFilter(pFilter);
    }
}


NTSTATUS
IPSecAddFilter(
    IN  PIPSEC_ADD_FILTER   pAddFilter
    )
/*++

Routine Description

    Called by the Policy Agent, sets up the input policies. A list of
    filters is sent down with associated PolicyIds (GUIDs) that make
    sense to the Key Management layer up above (e.g. ISAKMP).

Arguments

    PIPSEC_ADD_FILTER

Return Value


--*/
{
    PIPSEC_FILTER_INFO  pFilterInfo = pAddFilter->pInfo;
    ULONG               numPolicies = pAddFilter->NumEntries;
    ULONG               i;
    PFILTER             pFilter;
    PFILTER             pTempFilter;
    LIST_ENTRY          TempFilterList;
    PLIST_ENTRY         pEntry;
    NTSTATUS            status;
    KIRQL               kIrql;

#if GPC
    //
    // Temporarily disable GPC while add is pending.  Re-enable when done.
    //
    IPSecDisableGpc();
#endif

    //
    // Pre-allocate memory for filters plumbed.  Return right away if failed.
    //
    InitializeListHead(&TempFilterList);

    for (i = 0; i < numPolicies; i++) {
        status = IPSecCreateFilter(pFilterInfo, &pFilter);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecCreateFilter failed: %lx", status));

            IPSecDeleteTempFilters(&TempFilterList);

#if GPC
            IPSecEnableGpc();
#endif

            return  status;
        }

        InsertTailList(&TempFilterList, &pFilter->MaskedLinkage);

        AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

        status = IPSecSearchFilter(pFilter, &pTempFilter);

        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

        if (NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecSearchFilter returns duplicate: %lx", status));

            IPSecDeleteTempFilters(&TempFilterList);

#if GPC
            IPSecEnableGpc();
#endif

            return  STATUS_DUPLICATE_OBJECTID;
        }

#if GPC
        status = IPSecInstallGpcFilter(pFilter);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecInstallGpcFilter failed: %lx", status));

            IPSecDeleteTempFilters(&TempFilterList);

            IPSecEnableGpc();

            return  status;
        }
#endif

        pFilterInfo++;
    }

    //
    // Iterate through the filters, adding each to the Filter database
    //
    while (!IsListEmpty(&TempFilterList)) {
        pEntry = RemoveHeadList(&TempFilterList);

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        status = IPSecInsertFilter(pFilter);

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecInsertFilter failed: %lx", status));
            ASSERT(FALSE);
        }
    }

#if GPC
    //
    // Re-enable GPC for fast lookup.
    //
    IPSecEnableGpc();
#endif

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecDeleteFilter(
    IN  PIPSEC_DELETE_FILTER    pDelFilter
    )
/*++

Routine Description

    Called by the Policy Agent to delete a set of filters. we delete
    all associated outbound filters first and expire the inbound ones.

Arguments

    PIPSEC_DELETE_FILTER

Return Value


--*/
{
    PIPSEC_FILTER_INFO  pFilterInfo = pDelFilter->pInfo;
    ULONG               numPolicies = pDelFilter->NumEntries;
    ULONG               i;
    PFILTER             pFilter;
    FILTER              matchFilter = {0};
    NTSTATUS            status = STATUS_SUCCESS;
    KIRQL               kIrql;

#if GPC
    //
    // Temporarily disable GPC while delete is pending.  Re-enable when done.
    //
    IPSecDisableGpc();
#endif

    //
    // iterate through the filters, deleting each from the Filter database
    //
    for (i = 0; i < numPolicies; i++) {
        PIPSEC_FILTER   pIpsecFilter = &pFilterInfo->AssociatedFilter;

        IPSecPopulateFilter(&matchFilter, pIpsecFilter);

        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        status = IPSecSearchFilter(&matchFilter, &pFilter);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecDeletePolicy: Filter not found "));
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
            break;
        }

        //
        // remove from list
        //
        IPSecRemoveEntryList(&pFilter->MaskedLinkage);
        pFilter->LinkedFilter = FALSE;

        if (IS_TUNNEL_FILTER(pFilter)) {
            g_ipsec.NumTunnelFilters--;
        } else {
            g_ipsec.NumMaskedFilters--;
        }
        --g_ipsec.NumPolicies;

        if (IS_MULTICAST_FILTER(pFilter)) {
            IPSEC_DECREMENT(g_ipsec.NumMulticastFilters);
        }

        if (g_ipsec.NumPolicies == 0) {
            TCPIP_SET_IPSEC_STATUS(FALSE);
        }

        IPSecRemoveFilter(pFilter);

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

#if GPC
        IPSecUninstallGpcFilter(pFilter);
#endif

        IPSecDerefFilter(pFilter);

        pFilterInfo++;
    }

#if GPC
    //
    // Re-enable GPC for fast lookup.
    //
    IPSecEnableGpc();
#endif

    return status;
}


VOID
IPSecFillFilterInfo(
    IN  PFILTER             pFilter,
    OUT PIPSEC_FILTER_INFO  pBuf
    )
/*++

Routine Description:

    Fill out the FILTER_INFO structure.

Arguments:

    pFilter - filter to be filled in
    pBuf    - where to fill in

Returns:

    None.

--*/
{
    //
    // now fill in the buffer
    //
    pBuf->FilterId = pFilter->FilterId;
    pBuf->PolicyId = pFilter->PolicyId;
    pBuf->Index = pFilter->Index;

    pBuf->AssociatedFilter.SrcAddr = pFilter->SRC_ADDR;
    pBuf->AssociatedFilter.DestAddr = pFilter->DEST_ADDR;
    pBuf->AssociatedFilter.SrcMask = pFilter->SRC_MASK;
    pBuf->AssociatedFilter.DestMask = pFilter->DEST_MASK;

    pBuf->AssociatedFilter.Protocol = pFilter->PROTO;
    pBuf->AssociatedFilter.SrcPort = FI_SRC_PORT(pFilter);
    pBuf->AssociatedFilter.DestPort = FI_DEST_PORT(pFilter);

    pBuf->AssociatedFilter.TunnelAddr = pFilter->TunnelAddr;
    pBuf->AssociatedFilter.TunnelFilter = pFilter->TunnelFilter;

    pBuf->AssociatedFilter.Flags = pFilter->Flags;
}


NTSTATUS
IPSecEnumFilters(
    IN  PIRP    pIrp,
    OUT PULONG  pBytesCopied
    )
/*++

Routine Description:

    Fills in the request to enumerate Filters.

Arguments:

    pIrp            - The actual Irp
    pBytesCopied    - the number of bytes copied.

Returns:

    Status of the operation.

--*/
{
    PNDIS_BUFFER        NdisBuffer = NULL;
    PIPSEC_ENUM_FILTERS pEnum = NULL;
    ULONG               BufferLength = 0;
    KIRQL               kIrql;
    PLIST_ENTRY         pEntry;
    IPSEC_FILTER_INFO   InfoBuff = {0};
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               BytesCopied = 0;
    ULONG               Offset = 0;
    IPSEC_FILTER_INFO   infoBuff;
    LONG                FilterIndex;
    PFILTER             pFilter;

    //
    // Get at the IO buffer - its in the MDL
    //
    NdisBuffer = REQUEST_NDIS_BUFFER(pIrp);
    if (NdisBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    NdisQueryBufferSafe(NdisBuffer,
                        (PVOID *)&pEnum,
                        &BufferLength,
                        NormalPagePriority);

    //
    // Make sure NdisQueryBufferSafe succeeds.
    //
    if (!pEnum) {
        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("EnumFilters failed, no resources"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make sure we have enough room for just the header not
    // including the data.
    //
    if (BufferLength < (UINT)(FIELD_OFFSET(IPSEC_ENUM_FILTERS, pInfo[0]))) {
        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("EnumFilters failed, buffer too small"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Make sure we are naturally aligned.
    //
    if (((ULONG_PTR)(pEnum)) & (TYPE_ALIGNMENT(IPSEC_ENUM_FILTERS) - 1)) {
        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("EnumFilters failed, alignment"));
        return STATUS_DATATYPE_MISALIGNMENT_ERROR;
    }

    pEnum->NumEntries = 0;
    pEnum->NumEntriesPresent = 0;

    AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

    //
    // Now copy over the filter data into the user buffer.
    //
    if (g_ipsec.NumPolicies) {
        //
        // see how many we can fit in the output buffer
        //
        BufferLength -= FIELD_OFFSET(IPSEC_ENUM_FILTERS, pInfo[0]);
        Offset = FIELD_OFFSET(IPSEC_ENUM_FILTERS, pInfo[0]);

        for (   FilterIndex = MIN_FILTER;
                FilterIndex <= MAX_FILTER;
                FilterIndex++) {

            for (   pEntry = g_ipsec.FilterList[FilterIndex].Flink;
                    pEntry != &g_ipsec.FilterList[FilterIndex];
                    pEntry = pEntry->Flink) {

                pFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            MaskedLinkage);

                pEnum->NumEntriesPresent++;

                if ((INT)(BufferLength - BytesCopied) >= (INT)sizeof(IPSEC_FILTER_INFO)) {
                    IPSecFillFilterInfo(pFilter, &infoBuff);
                    BytesCopied += sizeof(IPSEC_FILTER_INFO);
                    NdisBuffer = CopyToNdis(NdisBuffer, (UCHAR *)&infoBuff, sizeof(IPSEC_FILTER_INFO), &Offset);
                    if (!NdisBuffer) {
                        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }
        }

        pEnum->NumEntries = BytesCopied / sizeof(IPSEC_FILTER_INFO);

        *pBytesCopied = BytesCopied + FIELD_OFFSET(IPSEC_ENUM_FILTERS, pInfo[0]);

        if (pEnum->NumEntries < pEnum->NumEntriesPresent) {
            status = STATUS_BUFFER_OVERFLOW;
        }
    }

    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

    return status;
}


PNDIS_BUFFER
CopyToNdis(
    IN  PNDIS_BUFFER    DestBuf,
    IN  PUCHAR          SrcBuf,
    IN  ULONG           Size,
    IN  PULONG          StartOffset
    )
/*++

    Copy a flat buffer to an NDIS_BUFFER chain.

    A utility function to copy a flat buffer to an NDIS buffer chain. We
    assume that the NDIS_BUFFER chain is big enough to hold the copy amount;
    in a debug build we'll  debugcheck if this isn't true. We return a pointer
    to the buffer where we stopped copying, and an offset into that buffer.
    This is useful for copying in pieces into the chain.

  	Input:

        DestBuf     - Destination NDIS_BUFFER chain.
        SrcBuf      - Src flat buffer.
        Size        - Size in bytes to copy.
        StartOffset - Pointer to start of offset into first buffer in
                        chain. Filled in on return with the offset to
                        copy into next.

  	Returns:

        Pointer to next buffer in chain to copy into.
--*/
{
    UINT        CopySize;
    UCHAR       *DestPtr;
    UINT        DestSize;
    UINT        Offset = *StartOffset;
    UCHAR      *VirtualAddress = NULL;
    UINT        Length = 0;

    if (DestBuf == NULL || SrcBuf == NULL) {
        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("CopyToNdis failed, DestBuf or SrcBuf is NULL"));
        ASSERT(FALSE);
        return  NULL;
    }

    NdisQueryBufferSafe(DestBuf,
                        (PVOID *)&VirtualAddress,
                        &Length,
                        NormalPagePriority);

    if (!VirtualAddress) {
        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("CopyToNdis failed, NdisQueryBuffer returns NULL"));
        return  NULL;
    }

    ASSERT(Length >= Offset);
    DestPtr = VirtualAddress + Offset;
    DestSize = Length - Offset;

    for (;;) {
        CopySize = MIN(Size, DestSize);
        RtlCopyMemory(DestPtr, SrcBuf, CopySize);

        DestPtr += CopySize;
        SrcBuf += CopySize;

        if ((Size -= CopySize) == 0)
            break;

        if ((DestSize -= CopySize) == 0) {
            DestBuf = NDIS_BUFFER_LINKAGE(DestBuf);

            if (DestBuf == NULL) {
                ASSERT(FALSE);
                break;
            }

            VirtualAddress = NULL;
            Length = 0;

            NdisQueryBufferSafe(DestBuf,
                                (PVOID *)&VirtualAddress,
                                &Length,
                                NormalPagePriority);

            if (!VirtualAddress) {
                IPSEC_DEBUG(LL_A, DBF_IOCTL, ("CopyToNdis failed, NdisQueryBuffer returns NULL"));
                return  NULL;
            }

            DestPtr = VirtualAddress;
            DestSize = Length;
        }
    }

    *StartOffset = (ULONG)(DestPtr - VirtualAddress);

    return DestBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\hughes.h ===
NTSTATUS
IPSecHashMdlChainSend(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pBuffer,
    IN  PUCHAR          pHash,
    IN  AH_ALGO         eAlgo,
    OUT PULONG          pLen,
    IN  ULONG           Index,
    IN  ULONG           StartOffset
    );

NTSTATUS
IPSecHashMdlChainRecv(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pBuffer,
    IN  PUCHAR          pHash,
    IN  AH_ALGO         eAlgo,
    OUT PULONG          pLen,
    IN  ULONG           Index,
    IN  ULONG           StartOffset
    );

NTSTATUS
IPSecCreateHughes(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PVOID           IPContext,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PVOID           *ppNewData,
    OUT     PVOID           *ppSCContext,
    OUT     PULONG          pExtraBytes,
    IN      ULONG           HdrSpace,
    IN      PNDIS_PACKET    pNdisPacket,
    IN      BOOLEAN         fCryptoOnly
    );

NTSTATUS
IPSecVerifyHughes(
    IN      PUCHAR          *pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PULONG          pExtraBytes,
    IN      BOOLEAN         fCryptoDone,
    IN      BOOLEAN         fFastRcv
    );


NTSTATUS
IPSecGetRecvByteByOffset(IPRcvBuf *pData,
                         LONG Offset,
                         BYTE *OutByte);

NTSTATUS
IPSecGetRecvBytesByOffset(IPRcvBuf *pData,
                          LONG Offset,
                          BYTE *pOutBuffer,
                          ULONG BufLen);
NTSTATUS
IPSecSetRecvByteByOffset(IPRcvBuf *pData,
                         LONG Offset,
                         BYTE InByte);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\globals.c ===
#include "precomp.h"


ULONG IPSecNumResets = 0;

#if DBG

ULONG NumAddSA = 0;
ULONG NumAddSU = 0;
ULONG NumAddFA = 0;
ULONG NumDelSA = 0;
ULONG NumDelSU = 0;
ULONG NumDelFA = 0;

ULONG NumReset = 0;

ULONG NumAddEncapSA = 0;
ULONG NumAddEncapSU = 0;
ULONG NumAddEncapFA = 0;
ULONG NumDelEncapSA = 0;
ULONG NumDelEncapSU = 0;
ULONG NumDelEncapFA = 0;

#endif


//
// Max timeout value (in seconds) for each class.
//
ULONG   IPSecMaxTimerValue[IPSEC_CLASS_MAX] = {
            IPSEC_MAX_TIMER_SHORT_DURATION,
            IPSEC_MAX_TIMER_LONG_DURATION,
            IPSEC_MAX_TIMER_SUPER_LONG_DURATION
        };

//
// Size of each timer wheel.
//
ULONG   IPSecTimerListSize[IPSEC_CLASS_MAX] = {
            SECONDS_TO_SHORT_TICKS(IPSEC_MAX_TIMER_SHORT_DURATION),
            SECONDS_TO_LONG_TICKS(IPSEC_MAX_TIMER_LONG_DURATION),
            SECONDS_TO_SUPER_LONG_TICKS(IPSEC_MAX_TIMER_SUPER_LONG_DURATION)
        };

//
// Interval between ticks, in seconds, for each class.
//
ULONG   IPSecTimerPeriod[IPSEC_CLASS_MAX] = {
            IPSEC_SHORT_DURATION_TIMER_PERIOD,
            IPSEC_LONG_DURATION_TIMER_PERIOD,
            IPSEC_SUPER_LONG_DURATION_TIMER_PERIOD
        };

#if GPC
ULONG DebugGPC = 0;
#endif

#if DBG
ULONG IPSecDebug = 0;
#endif

UCHAR DefaultPad[MAX_PAD_LEN] = {1, 2, 3, 4, 5, 6, 7, 8, 9};


#if DBG
IPAddr DebugSrc = 0;
IPAddr DebugDst = 0;
UCHAR DebugPro = 0;
ULONG DebugPkt = 0;
ULONG DebugOff = 0;
ULONG DebugQry = 1;
#endif


RC4_KEYSTRUCT IPSecRngKey;

WORK_QUEUE_ITEM IPSecRngQueueItem;

ULONG IPSecRngBytes = 0;

#if DBG
ULONG IPSecRngInRekey = 0;
#endif

unsigned char weak_keys[][DES_BLOCKLEN] = {
		/* the weak keys */
	{ 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
	{ 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe },
	{ 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f },
	{ 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0 },
		/* the semi-weak keys */
	{ 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfe },
	{ 0x1f, 0xe0, 0x1f, 0xe0, 0x1f, 0xe0, 0x1f, 0xe0 },
	{ 0x01, 0xe0, 0x01, 0xe0, 0x01, 0xe0, 0x01, 0xe0 },
	{ 0x1f, 0xfe, 0x1f, 0xfe, 0x1f, 0xfe, 0x1f, 0xfe },
	{ 0x01, 0x1f, 0x01, 0x1f, 0x01, 0x1f, 0x01, 0x1f },
	{ 0xe0, 0xfe, 0xe0, 0xfe, 0xe0, 0xfe, 0xe0, 0xfe },
	{ 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01 },
	{ 0xe0, 0x1f, 0xe0, 0x1f, 0xe0, 0x1f, 0xe0, 0x1f },
	{ 0xe0, 0x01, 0xe0, 0x01, 0xe0, 0x01, 0xe0, 0x01 },
	{ 0xfe, 0x1f, 0xfe, 0x1f, 0xfe, 0x1f, 0xfe, 0x1f },
	{ 0x1f, 0x01, 0x1f, 0x01, 0x1f, 0x01, 0x1f, 0x01 },
	{ 0xfe, 0xe0, 0xfe, 0xe0, 0xfe, 0xe0, 0xfe, 0xe0 }
};


PDEVICE_OBJECT IPSecDevice = NULL;

ULONG IPSecInitFlag = 0;

IPSEC_GLOBAL g_ipsec;

LARGE_INTEGER IPSecDelayInterval;

DWORD gdwInitEsp = 0;

DWORD gdwInitAh = 0;

PPARSER_IFENTRY gpParserIfEntry = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\hughes.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    hughes.c

Abstract:

    This module contains the code to create/verify the Hughes transform.

Author:

    Sanjay Anand (SanjayAn) 13-March-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"

#ifdef RUN_WPP
#include "hughes.tmh"
#endif

NTSTATUS
IPSecHashMdlChainSend(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pBuffer,
    IN  PUCHAR          pHash,
    IN  AH_ALGO         eAlgo,
    OUT PULONG          pLen,
    IN  ULONG           Index,
    IN  ULONG           StartOffset
    )
/*++

Routine Description:

    Hash the entire chain using the algo passed in

Arguments:

    pSA - the security association

    pBuffer - chain of MDLs (if fIncoming is FALSE) or RcvBufs (if fIncoming is TRUE)

    pHash - where to put the hash

    fIncoming - TRUE if on recv path

    eAlgo - the algorithm index

    pLen - returns length hashed

    StartOffset - offset from start from which to start hashing
Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    ALGO_STATE  State = {0};
    NTSTATUS    status;
    PAUTH_ALGO  pAlgo=&(auth_algorithms[eAlgo]);
    PUCHAR      pPyld;
    ULONG       Len=0,TmpLen=0;
    ULONG  CurOffset=0;
    PNDIS_BUFFER    pBuf = (PNDIS_BUFFER)pBuffer;


    State.as_sa = pSA;

    status = pAlgo->init(&State, Index);

    if (StartOffset == 0) {
        while (pBuf) {
            IPSecQueryNdisBuf(pBuf, &pPyld, &Len);
            pAlgo->update(&State, pPyld, Len);
            *pLen += Len;
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
        }
    } else {
        // gotta get to correct offset before starting hash
        if (pBuf) {
            IPSecQueryNdisBuf(pBuf, &pPyld, &Len);
        }
        // walk to StartOffset
        while (pBuf && Len + CurOffset < StartOffset) {
            CurOffset += Len;
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
            if (pBuf) {
                IPSecQueryNdisBuf(pBuf, &pPyld, &Len);
            }
        }
        while (pBuf) {
            IPSecQueryNdisBuf(pBuf, &pPyld, &Len);
                
            if (StartOffset >  CurOffset) {
                pPyld += (StartOffset - CurOffset);
                TmpLen = Len-(StartOffset - CurOffset);
            } else {
                TmpLen = Len;
            }

            pAlgo->update(&State, pPyld, TmpLen);
            *pLen += TmpLen;
            CurOffset += Len;
            pBuf = NDIS_BUFFER_LINKAGE(pBuf);
        }
    }
        

    pAlgo->finish(&State, pHash, Index);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecHashMdlChainRecv(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pBuffer,
    IN  PUCHAR          pHash,
    IN  AH_ALGO         eAlgo,
    OUT PULONG          pLen,
    IN  ULONG           Index,
    IN  ULONG           StartOffset
    )
/*++

Routine Description:

    Hash the entire chain using the algo passed in

Arguments:

    pSA - the security association

    pBuffer - chain of MDLs (if fIncoming is FALSE) or RcvBufs (if fIncoming is TRUE)

    pHash - where to put the hash

    fIncoming - TRUE if on recv path

    eAlgo - the algorithm index

    pLen - returns length hashed

    StartOffset - offset from start from which to start hashing
Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    ALGO_STATE  State = {0};
    NTSTATUS    status;
    PAUTH_ALGO  pAlgo=&(auth_algorithms[eAlgo]);
    PUCHAR      pPyld;
    ULONG       Len=0,TmpLen=0;
    IPRcvBuf    *pBuf = (IPRcvBuf *)pBuffer;

    ULONG  CurOffset=0;

    State.as_sa = pSA;

    status = pAlgo->init(&State, Index);

    if (StartOffset == 0) {
        // Hash it all
        while (pBuf) {
            IPSecQueryRcvBuf(pBuf, &pPyld, &Len);
            pAlgo->update(&State, pPyld, Len);
            *pLen += Len;
            pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
        }
    } else {
        // gotta get to correct offset before starting hash
        if (pBuf) {
            IPSecQueryRcvBuf(pBuf, &pPyld, &Len);
        }
        // walk to StartOffset
        while (pBuf && Len + CurOffset < StartOffset) {
            CurOffset += Len;
            pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
            if (pBuf) {
                IPSecQueryRcvBuf(pBuf, &pPyld, &Len);
            }
        }
        while (pBuf) {
            IPSecQueryRcvBuf(pBuf, &pPyld, &Len);
            
            if (StartOffset >  CurOffset) {
                pPyld += (StartOffset - CurOffset);
                TmpLen = Len-(StartOffset - CurOffset);
            } else {
                TmpLen = Len;
            }
            
            pAlgo->update(&State, pPyld, TmpLen);
            *pLen += TmpLen;
            CurOffset += Len;
            pBuf = IPSEC_BUFFER_LINKAGE(pBuf);
        }
        
    }
    pAlgo->finish(&State, pHash, Index);
    
    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecCreateHughes(
    IN      PUCHAR          pIPHeader,
    IN      PVOID           pData,
    IN      PVOID           IPContext,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PVOID           *ppNewData,
    OUT     PVOID           *ppSCContext,
    OUT     PULONG          pExtraBytes,
    IN      ULONG           HdrSpace,
    IN      PNDIS_PACKET    pNdisPacket,
    IN      BOOLEAN         fCryptoOnly
    )
/*++

Routine Description:

    Create the combined esp-des-* transform, as outlined in
    draft-ietf-ipsec-esp-v2-00, on the send side.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ----
   |               Security Parameters Index (SPI)                 | ^
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Auth.
   |                      Sequence Number                          | |Coverage
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | -----
   |                    Payload Data* (variable)                   | |   ^
   ~                                                               ~ |   |
   |                                                               | |   |
   +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Confid.
   |               |     Padding (0-255 bytes)                     | |Coverage*
   +-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |   |
   |                               |  Pad Length   | Next Header   | v   v
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -------
   |                 Authentication Data (variable)                |
   ~                                                               ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        * If included in the Payload field, cryptographic synchronization
          data, e.g., an IV, usually is not encrypted per se, although it
          often is referred to as being part of the ciphertext.

    The payload field, as defined in [ESP], is broken down according to
    the following diagram:

      +---------------+---------------+---------------+---------------+
      |                                                               |
      +                   Initialization Vector (IV)                  +
      |                                                               |
      +---------------+---------------+---------------+---------------+
      |                                                               |
      ~              Encrypted Payload (variable length)              ~
      |                                                               |
      +---------------------------------------------------------------+
       1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header. PNDIS_BUFFER

    pSA - Sec. Assoc. entry

    ppNewData - the new MDL chain to be used by TCPIP

    ppSCContext - send complete context used to clean up IPSEC headers

    pExtraBytes - the header expansion caused by this IPSEC header

Return Value:

    STATUS_SUCCESS
    Others:
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL (error in algo.)

--*/
{
    ESP UNALIGNED   *pESP;
    VOID UNALIGNED *pTmpNat;
    NATENCAP UNALIGNED *pNat;
    NATENCAP_OTHER UNALIGNED *pNatOther;
    NTSTATUS    status = STATUS_SUCCESS;
    PNDIS_BUFFER    pESPBuffer = NULL;
    PNDIS_BUFFER    pPadBuf = NULL;
    PNDIS_BUFFER    pOptBuf = NULL;
    ULONG   espLen;
    ULONG   padLen;
    ULONG   totalLen = 0;
    IPHeader UNALIGNED * pIPH;
    PIPSEC_SEND_COMPLETE_CONTEXT pContext;
    PNDIS_BUFFER    pNewMdl = NULL;
    PNDIS_BUFFER    pSaveMdl;
    PAUTH_ALGO      pAlgo = &(auth_algorithms[pSA->INT_ALGO(Index)]);
    ULONG   PayloadType;
    ULONG   hdrLen;
    PUCHAR  pPad;
    ULONG   TruncatedLen = (pSA->INT_ALGO(Index) != IPSEC_AH_NONE)? pSA->sa_TruncatedLen: 0;
    BOOLEAN fTunnel = ( (pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                        ((Index == 0) ||
                            ((Index == 1) && (pSA->sa_Operation[0] == Compress))));
    ULONG   tag = (!fTunnel) ?
                    IPSEC_TAG_HUGHES :
                    IPSEC_TAG_HUGHES_TU;
    IPHeader UNALIGNED * pIPH2;
    PNDIS_BUFFER    pHdrBuf=NULL;
    ULONG       bytesLeft;
    ULONG       hashBytes=0;
    ULONG       saveFlags=0;
    ULONG       Seq;
    USHORT      IPLength;
    PNDIS_BUFFER    pSaveDataLinkage = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
    PNDIS_BUFFER    pSaveOptLinkage = NULL;
    PNDIS_BUFFER    pSaveBeforePad = NULL;
    PIPSEC_MTU_CONTEXT pMTUContext=NULL;

    ULONG ExtraTransportNat=0;

    BOOLEAN bNATEncap = FALSE;
    Interface * DestIF = (Interface *) IPContext;

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Entering IPSecCreateHughes"));

#if DBG
    IPSEC_DEBUG(LL_A, DBF_MDL, ("Entering IPSecCreateHughes"));
    IPSEC_PRINT_CONTEXT(*ppSCContext);
    IPSEC_PRINT_MDL(pData);
#endif

    ASSERT(pSA->sa_Operation[Index] == Encrypt);

    if (*ppSCContext == NULL) {
        pContext = IPSecAllocateSendCompleteCtx(tag);

        if (!pContext) {
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to alloc. SendCtx"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IPSEC_INCREMENT(g_ipsec.NumSends);

        IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));
#if DBG
        RtlCopyMemory(pContext->Signature, "ISC4", 4);
#endif
        //
        // Send complete context
        //
        *ppSCContext = pContext;
    } else {
        pContext = *ppSCContext;
        saveFlags = pContext->Flags;
    }

    //
    // get the pad len -> total length + replay prevention field len + padlen + payloadtype needs to be padded to
    // 8 byte boundary.
    //
    pIPH = (IPHeader UNALIGNED *)pIPHeader;
    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    //
    // Transport mode: payload is after IP header => payloadlen is total len - hdr len
    // Tunnel modes: payload starts at IP header => payloadlen is total len
    //
    totalLen = (!fTunnel) ?
                NET_SHORT(pIPH->iph_length) - hdrLen :
                NET_SHORT(pIPH->iph_length);

    if ((pSA->CONF_ALGO(Index) == IPSEC_ESP_NONE) || fCryptoOnly) {
        if (fTunnel) {
            pContext->Flags |= SCF_NOE_TU;
        } else {
            pContext->Flags |= SCF_NOE_TPT;
        }
    }

    {
        PCONFID_ALGO        pConfAlgo;
        ULONG   blockLen;

        pConfAlgo = &(conf_algorithms[pSA->CONF_ALGO(Index)]);
        blockLen = pConfAlgo->blocklen;

        bytesLeft = (totalLen) % blockLen;

        if (bytesLeft <= blockLen - NUM_EXTRA) {
            //
            // we can now fit the leftover + Pad length + Payload Type in a single
            // chunk
            //
            padLen = blockLen - bytesLeft;
        } else {
            //
            // we pad the bytesleft to next octet boundary, then attach the length/type
            //
            padLen = (blockLen << 1) - bytesLeft;
        }
    }

    //
    // Get buffer for trailing PAD and signature (MD5 signature len)
    //
    IPSecAllocateBuffer(&status,
                        &pPadBuf,
                        &pPad,
                        padLen + pAlgo->OutputLen,
                        tag);

    if (!NT_SUCCESS(status)) {
        NTSTATUS    ntstatus;
        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to alloc. PAD MDL"));
        pContext->Flags = saveFlags;
        return status;
    }

    //
    // the padding should contain 1, 2, 3, 4.... (latest ESP draft - draft-ietf-ipsec-esp-v2-02.txt)
    // for any algo that doesn't specify its own padding - right now all implemented algos go with
    // the default.
    //
    RtlCopyMemory(pPad, DefaultPad, padLen);

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("IP Len: %lx, pPad: %p, PadLen: %lx", NET_SHORT(pIPH->iph_length), pPad, padLen));

    //
    // Link in the pad buffer at end of the data chain
    //
    {
        PNDIS_BUFFER    temp = pData;
        while (NDIS_BUFFER_LINKAGE(temp)) {
            temp = NDIS_BUFFER_LINKAGE(temp);
        }
        NDIS_BUFFER_LINKAGE(temp) = pPadBuf;
        pSaveBeforePad = temp;
        if (fTunnel) {
            pContext->BeforePadTuMdl = temp;
            pContext->PadTuMdl = pPadBuf;
        } else {
            pContext->BeforePadMdl = temp;
            pContext->PadMdl = pPadBuf;
        }
    }
    NDIS_BUFFER_LINKAGE(pPadBuf) = NULL;

    switch(pSA->sa_EncapType) {
    case SA_UDP_ENCAP_TYPE_NONE:
        break;
    case SA_UDP_ENCAP_TYPE_IKE:
        ExtraTransportNat= sizeof(NATENCAP);
        break;
    case SA_UDP_ENCAP_TYPE_OTHER:
        ExtraTransportNat=sizeof(NATENCAP_OTHER);
        break;
    }

    espLen = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ExtraTransportNat;


    //
    // Get buffer for Hughes header
    //
    IPSecAllocateBuffer(&status,
                        &pESPBuffer,
                        (PUCHAR *)&pESP,
                        espLen,
                        tag);

    if (!NT_SUCCESS(status)) {
        NTSTATUS    ntstatus;
        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to alloc. ESP MDL"));
        NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
        IPSecFreeBuffer(&ntstatus, pPadBuf);
        pContext->Flags = saveFlags;
        return status;
    }


	if (pSA->sa_EncapType == SA_UDP_ENCAP_TYPE_IKE ||
		pSA->sa_EncapType == SA_UDP_ENCAP_TYPE_OTHER) {

		pTmpNat=pESP;
		pESP=(ESP*)(((PUCHAR)pESP)+ExtraTransportNat);

		// Alloc MTU adjust context
		if (!pContext->pMTUContext) {
			pContext->pMTUContext=IPSecAllocateMemory(sizeof(IPSEC_MTU_CONTEXT),IPSEC_TAG_SEND_COMPLETE);
		}
        pMTUContext=pContext->pMTUContext;
        if (pMTUContext) {
            IPSecZeroMemory(pMTUContext,sizeof(IPSEC_MTU_CONTEXT));
            pContext->Flags |= SCF_MTU;
            saveFlags |= SCF_MTU;

            pMTUContext->Src = pIPH->iph_src;

            if (fTunnel) {
                pMTUContext->TunnelSPI = HOST_TO_NET_LONG(pSA->sa_OtherSPIs[Index]);
                pMTUContext->TunnelDest = pSA->sa_TunnelAddr;
            } else {
                pMTUContext->TransportSPI = HOST_TO_NET_LONG(pSA->sa_OtherSPIs[Index]);
                pMTUContext->TransportDest = pIPH->iph_dest;
            }
        }
    }

    
    if (fTunnel) {
        PNDIS_BUFFER    pSrcOptBuf;
        PUCHAR          pOpt;
        PUCHAR          pSrcOpt;
        ULONG           optLen = 0;

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Hughes Tunnel mode..."));

        //
        // Allocate an MDL for the new cleartext IP  header
        //
        IPSecAllocateBuffer(&status,
                            &pHdrBuf,
                            (PUCHAR *)&pIPH2,
                            sizeof(IPHeader),
                            IPSEC_TAG_AH);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to alloc. PAD MDL"));
            NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
            IPSecFreeBuffer(&ntstatus, pPadBuf);
            IPSecFreeBuffer(&ntstatus, pESPBuffer);
            pContext->Flags = saveFlags;
            return status;
        }

        *pExtraBytes += espLen + padLen + TruncatedLen + sizeof(IPHeader);

        //
        // Now hookup the MDLs
        //
        pContext->Flags |= SCF_HU_TU;
        pContext->HUTuMdl = pESPBuffer;
        pContext->PrevTuMdl = (PNDIS_BUFFER)pData;
        pContext->HUHdrMdl = pHdrBuf;
        pContext->OriTuMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);

        NDIS_BUFFER_LINKAGE(pESPBuffer) = pHdrBuf;

        if (hdrLen > sizeof(IPHeader)) {
            if (HdrSpace < *pExtraBytes) {

                IPSEC_DEBUG(LL_A, DBF_AH, ("Going to frag."));

                pSrcOptBuf = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
                pSaveOptLinkage = NDIS_BUFFER_LINKAGE(pSrcOptBuf);
                IPSecQueryNdisBuf(pSrcOptBuf, &pSrcOpt, &optLen);
                IPSecAllocateBuffer(&status,
                                    &pOptBuf,
                                    (PUCHAR *)&pOpt,
                                    hdrLen - sizeof(IPHeader),
                                    IPSEC_TAG_AH);

                if (!NT_SUCCESS(status)) {
                    NTSTATUS    ntstatus;
                    IPSEC_DEBUG(LL_A, DBF_AH, ("Failed to alloc. PAD MDL"));
                    NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
                    NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
                    IPSecFreeBuffer(&ntstatus, pESPBuffer);
                    if (pHdrBuf) {
                        IPSecFreeBuffer(&ntstatus, pHdrBuf);
                    }
                    IPSecFreeBuffer(&ntstatus, pPadBuf);
                    pContext->Flags = saveFlags;
                    return status;
                }

                RtlCopyMemory(pOpt, pSrcOpt, hdrLen-sizeof(IPHeader));
                pContext->OptMdl = pOptBuf;

                IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Copying options. S: %p, D: %p", pSrcOptBuf, pOptBuf));

                //
                // replace the original Opt Mdl with ours.
                //
                NDIS_BUFFER_LINKAGE(pOptBuf) = NDIS_BUFFER_LINKAGE(pSrcOptBuf);
                NDIS_BUFFER_LINKAGE(pHdrBuf) = pOptBuf;

                IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Options; pointed Hdrbuf: %p to pOptBuf: %p", pHdrBuf, pOptBuf));
                *pExtraBytes += hdrLen-sizeof(IPHeader);

            } else {
                NDIS_BUFFER_LINKAGE(pHdrBuf) = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
            }
        } else {
            NDIS_BUFFER_LINKAGE(pHdrBuf) = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
        }

        NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pESPBuffer;

        //
        // xsum the new IP header since we expect that to be the case
        // at this stage in tpt mode.
        //
        RtlCopyMemory(pIPH2, pIPH, sizeof(IPHeader));

        //
        // no options in the outer header; reset the len.
        //
        pIPH->iph_verlen = IP_VERSION + (sizeof(IPHeader) >> 2);

        //
        // also reset the frag. params.
        //
        pIPH->iph_offset &= ~(IP_MF_FLAG | IP_OFFSET_MASK);

        if (DestIF->if_dfencap == ClearDfEncap) {
            pIPH->iph_offset &= ~(IP_DF_FLAG | IP_OFFSET_MASK);
        }

        ASSERT(pSA->sa_TunnelAddr);

        //
        // Tunnel starts here; replace dest addr to point to Tunnel end if specified
        // else tunnel ends at final dest
        //
        pIPH->iph_dest = pSA->sa_TunnelAddr;

        //
        // The first pended packet on a gateway (proxy negotiating for two subnets)
        // would come via the transmit path. Hence the source address would not be
        // kosher. We need to replace the src address in that case also.
        // We get this from the corresponding inbound SA's tunnel addr.
        //
        pIPH->iph_src = pSA->sa_SrcTunnelAddr;

        pIPH->iph_id = (ushort) TCPIP_GEN_IPID();
        pIPH->iph_xsum = 0;
        pIPH->iph_xsum = ~xsum(pIPH, sizeof(IPHeader));

        //
        // Set up headers so CreateHash works as in Tpt mode.
        //
        pIPHeader = (PUCHAR)pIPH;
        *ppNewData = pData;
        PayloadType = IP_IN_IP;
    } else {
        *pExtraBytes += espLen + padLen + TruncatedLen;

        if (hdrLen > sizeof(IPHeader)) {
            //
            // Options present - chain ESP after options
            //
            pSaveMdl = pContext->OriHUMdl = NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData));
            pContext->PrevMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);

            NDIS_BUFFER_LINKAGE(pESPBuffer) = pContext->OriHUMdl;
            NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pESPBuffer;
            pContext->Flags |= SCF_HU_TPT;
        } else {
            //
            // Chain the ESP buffer after IP header
            //
            pSaveMdl = pContext->OriHUMdl = NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData);
            pContext->PrevMdl = (PNDIS_BUFFER)pData;

            NDIS_BUFFER_LINKAGE(pESPBuffer) = pContext->OriHUMdl;
            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pESPBuffer;
            pContext->Flags |= SCF_HU_TPT;
        }

        //
        // Save the MDL pointer so we can hook it in place on SendComplete
        //
        pContext->HUMdl = pESPBuffer;
        PayloadType = ((UNALIGNED IPHeader *)pIPH)->iph_protocol;
    }

    //
    // Fill in the padlen at start of pad + padlen - NUM_EXTRA
    //
    *(pPad + padLen - NUM_EXTRA) = (UCHAR)padLen - NUM_EXTRA;

    //
    // Set the Payload Type
    //
    *(pPad + padLen + sizeof(UCHAR) - NUM_EXTRA) = (UCHAR)PayloadType;

    //
    // Initialize the other fields of the ESP header
    //
    pESP->esp_spi = HOST_TO_NET_LONG(pSA->sa_OtherSPIs[Index]);

    //
    // Copy the Replay field into the Hughes header
    //
    Seq = IPSEC_INCREMENT(pSA->sa_ReplaySendSeq[Index]);
    *(UNALIGNED ULONG *)(pESP + 1) = HOST_TO_NET_LONG(Seq);

    //IPSEC_DEBUG(LL_A, DBF_HUGHES, ("SPI %lx Seq &lx", pESP->esp_spi, HOST_TO_NET_LONG(Seq)));    

    if ((pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) && !fCryptoOnly) {
        UCHAR   feedback[MAX_BLOCKLEN];
        KIRQL   kIrql;

        //
        // Pad is included in the chain, so prevent double free by NULL'ing
        // the ref.
        //
        if (fTunnel) {
            pContext->PadTuMdl = NULL;
        } else {
            pContext->PadMdl = NULL;
        }

        //
        // NOTE: The way the IV is supposed to work is that initially, the IV
        // is a random value. The IV is then updated with the residue of the
        // last encryption block of a packet. This is used as the starting IV
        // for the next block. This assures a fairly random IV sample and
        // introduces some notion of IV chaining.
        //
        // The only way for this to work is to make the entire encryption atomic,
        // which would be a performance drag. So, we take a less strict approach here.
        //
        // We just ensure that each packet starts at a random value, and also do the
        // chaining.
        //

        //
        // Copy the IV into the Hughes header
        //
        ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);
        RtlCopyMemory(  ((PUCHAR)(pESP + 1) + pSA->sa_ReplayLen),
                        pSA->sa_iv[Index],
                        pSA->sa_ivlen);

        //
        // Init the CBC feedback
        //
        RtlCopyMemory(  feedback,
                        pSA->sa_iv[Index],
                        DES_BLOCKLEN);

        IPSecGenerateRandom((PUCHAR)&pSA->sa_iv[Index][0], DES_BLOCKLEN);
        RELEASE_LOCK(&pSA->sa_Lock, kIrql);

        //
        // Encrypt the entire block, starting after the IV (if it exists)
        //

        //
        // Make it appear that pESPMdl points to after Replay field
        //
        NdisBufferLength((PNDIS_BUFFER)pESPBuffer) -= (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ExtraTransportNat);
        (PUCHAR)((PNDIS_BUFFER)pESPBuffer)->MappedSystemVa += (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ExtraTransportNat);

        //
        // Remove the Hash bytes since we dont want to encrypt them
        //
        NdisBufferLength((PNDIS_BUFFER)pPadBuf) -= pAlgo->OutputLen;

        ASSERT(NdisBufferLength((PNDIS_BUFFER)pESPBuffer) == 0);

        status = IPSecEncryptBuffer((PVOID)pESPBuffer,
                                    &pNewMdl,
                                    pSA,
                                    pPadBuf,
                                    &padLen,
                                    0,
                                    Index,
                                    feedback);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to encrypt, pESP: %p", pESP));

            //
            // Don't forget we need to restore ESP MDL since SystemVa has been
            // changed.  If not, we have trouble later if the same buffer is
            // used during reinject since we use the buffer as a real MDL
            // there.
            //
            NdisBufferLength((PNDIS_BUFFER)pESPBuffer) += (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ExtraTransportNat);
            (PUCHAR)((PNDIS_BUFFER)pESPBuffer)->MappedSystemVa -= (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ExtraTransportNat);

            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
            NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
            if (pSaveOptLinkage) {
                NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pSaveOptLinkage;
            }
            IPSecFreeBuffer(&ntstatus, pESPBuffer);
            if (pHdrBuf) {
                IPSecFreeBuffer(&ntstatus, pHdrBuf);
            }
            if (pOptBuf) {
                IPSecFreeBuffer(&ntstatus, pOptBuf);
            }
            IPSecFreeBuffer(&ntstatus, pPadBuf);

            pContext->Flags = saveFlags;
            return status;
        }

        NdisBufferLength((PNDIS_BUFFER)pPadBuf) += pAlgo->OutputLen;

        NdisBufferLength((PNDIS_BUFFER)pESPBuffer) += (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ExtraTransportNat);
        (PUCHAR)((PNDIS_BUFFER)pESPBuffer)->MappedSystemVa -= (sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ExtraTransportNat);
        NDIS_BUFFER_LINKAGE(pESPBuffer) = pNewMdl;

        //
        // HMAC the entire block - starting at the SPI field => start of pESPBuffer
        //
        status = IPSecHashMdlChainSend( pSA,
                                    (PVOID)pESPBuffer,  // source
                                    pPad,               // dest
                                    pSA->INT_ALGO(Index),      // algo
                                    &hashBytes,
                                    Index,
                                    ExtraTransportNat);

        // Check return of HashMdlChain
        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to hash, pAH: %p", pESP));


            NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
            NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
            if (pSaveOptLinkage) {
                NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pSaveOptLinkage;
            }
            IPSecFreeBuffer(&ntstatus, pESPBuffer);
            if (pHdrBuf) {
                IPSecFreeBuffer(&ntstatus, pHdrBuf);
            }
            if (pOptBuf) {
                IPSecFreeBuffer(&ntstatus, pOptBuf);
            }
            IPSecFreeBuffer(&ntstatus, pPadBuf);
            IPSecFreeBuffer(&ntstatus, pNewMdl);

            pContext->Flags = saveFlags;
            return status;
        }

        //
        // hook up the pad mdl which contains the final hash (the pad mdl was copied into
        // newMdl returned by EncryptDESCBC). Also, set the length of the Pad mdl to hash len.
        //
        // Remember we need to truncate this to 96 bits, so make it appear
        // as if we have only 96 bits.
        //
        NdisBufferLength(pPadBuf) = TruncatedLen;
        NDIS_BUFFER_LINKAGE(pNewMdl) = pPadBuf;

        pNdisPacket->Private.Tail = pPadBuf;

    } else {
        //
        // HMAC the entire block - starting at the SPI field => start of pESPBuffer
        //
        //
        // Remove the Hash bytes since we dont want to hash them
        //

        if (!fCryptoOnly) {

            NdisBufferLength((PNDIS_BUFFER)pPadBuf) -= pAlgo->OutputLen;
            status = IPSecHashMdlChainSend( pSA,
                                        (PVOID)pESPBuffer,  // source
                                        (PUCHAR)(pPad + padLen),               // dest
                                        pSA->INT_ALGO(Index),      // algo
                                        &hashBytes,
                                        Index,
                                        ExtraTransportNat);


            NdisBufferLength((PNDIS_BUFFER)pPadBuf) += pAlgo->OutputLen;

            if (!NT_SUCCESS(status)) {
                NTSTATUS    ntstatus;
                IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to hash, pAH: %p", pESP));

                NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData) = pSaveDataLinkage;
                NDIS_BUFFER_LINKAGE(pSaveBeforePad) = NULL;
                if (pSaveOptLinkage) {
                    NDIS_BUFFER_LINKAGE(NDIS_BUFFER_LINKAGE((PNDIS_BUFFER)pData)) = pSaveOptLinkage;
                }
                IPSecFreeBuffer(&ntstatus, pESPBuffer);
                if (pHdrBuf) {
                    IPSecFreeBuffer(&ntstatus, pHdrBuf);
                }
                if (pOptBuf) {
                    IPSecFreeBuffer(&ntstatus, pOptBuf);
                }
                IPSecFreeBuffer(&ntstatus, pPadBuf);
                IPSecFreeBuffer(&ntstatus, pNewMdl);

                pContext->Flags = saveFlags;
                return status;
            }
        } else {
            IPSEC_GET_TOTAL_LEN(pESPBuffer, &hashBytes);
        }

        if (fCryptoOnly) {
            //
            // Zero out the hash.
            //
            IPSecZeroMemory(pPad + padLen, TruncatedLen);
            IPSecZeroMemory((PUCHAR)(pESP + 1) + pSA->sa_ReplayLen, pSA->sa_ivlen);
        }

        NdisBufferLength(pPadBuf) = padLen + TruncatedLen;

        pNdisPacket->Private.Tail = pPadBuf;
    }

    if (pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.ConfidentialBytesSent,
            totalLen);

        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uConfidentialBytesSent,
            totalLen);
    }

    if (pSA->INT_ALGO(Index) != IPSEC_AH_NONE) {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.AuthenticatedBytesSent,
            hashBytes);

        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uAuthenticatedBytesSent,
            hashBytes);
    }

    //
    // Bump up the bytes transformed count.
    //
    ADD_TO_LARGE_INTEGER(
        &pSA->sa_TotalBytesTransformed,
        totalLen);

    //
    // Update the IP header length to reflect the Hughes header
    //
	switch (pSA->sa_EncapType) {
	case SA_UDP_ENCAP_TYPE_NONE:

		UpdateIPProtocol(pIPH, PROTOCOL_ESP);
		break;
	case SA_UDP_ENCAP_TYPE_IKE:
		UpdateIPProtocol(pIPH, 17);
		pNat=(NATENCAP UNALIGNED *)pTmpNat;
		memset(pNat,0,sizeof(NATENCAP));

		pNat->uh_src=pSA->sa_EncapContext.wSrcEncapPort;
		pNat->uh_dest=pSA->sa_EncapContext.wDesEncapPort;

		// UDP len = totalLen(original data len) + all new headers
		pNat->uh_length= NET_SHORT((USHORT)(totalLen + espLen + padLen + TruncatedLen));                                  
		break;
	case SA_UDP_ENCAP_TYPE_OTHER:
		UpdateIPProtocol(pIPH, 17);
		pNatOther=(NATENCAP_OTHER UNALIGNED *)pTmpNat; 
		memset(pNatOther,0,sizeof(NATENCAP_OTHER));

		pNatOther->uh_src=pSA->sa_EncapContext.wSrcEncapPort;
		pNatOther->uh_dest=pSA->sa_EncapContext.wDesEncapPort;

		// UDP len = totalLen(original data len) + all new headers
		pNatOther->uh_length= NET_SHORT((USHORT)(totalLen + espLen + padLen + TruncatedLen));                                  
		break;
	}
	
 
    
    IPLength = NET_SHORT(pIPH->iph_length) + (USHORT)(espLen + padLen + TruncatedLen);
    if (fTunnel) {
        IPLength += sizeof(IPHeader);
    }

    UpdateIPLength(pIPH, NET_SHORT(IPLength));

   

    //
    // Return modified packet.
    //
    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Exiting IPSecCreateHughes, espLen: %lx, padLen: %lx, status: %lx", espLen, padLen, status));

#if DBG
    IPSEC_DEBUG(LL_A, DBF_MDL, ("Exiting IPSecCreateHughes"));
    IPSEC_PRINT_CONTEXT(*ppSCContext);
    if (*ppNewData) {
        IPSEC_PRINT_MDL(*ppNewData);
    }
    else {
        IPSEC_PRINT_MDL(pData);
    }
#endif

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecVerifyHughes(
    IN      PUCHAR          *pIPHeader,
    IN      PVOID           pData,
    IN      PSA_TABLE_ENTRY pSA,
    IN      ULONG           Index,
    OUT     PULONG          pExtraBytes,
    IN      BOOLEAN         fCryptoDone,
    IN      BOOLEAN         fFastRcv
    )
/*++

  Routine Description:

  Verify the combined esp-des-md5 transform, as outlined in
  draft-ietf-ipsec-esp-des-md5, on the send side.

  Arguments:

  pIPHeader - points to start of IP header.

  pData - points to the data after the IP header. IPRcvBuf*

  pSA - Sec. Assoc. entry

  pExtraBytes - out param to inform IP on recv path how many bytes IPSEC took off.

  Return Value:

  STATUS_SUCCESS
  Others:
  STATUS_INSUFFICIENT_RESOURCES
  STATUS_UNSUCCESSFUL (error in algo.)

  --*/
{
    PESP    pESP;
    NTSTATUS    status = STATUS_SUCCESS;
    PNDIS_BUFFER    pESPBuffer;
    PNDIS_BUFFER    pPadBuffer;
    LONG    espLen;
    UCHAR   padLen;
    UCHAR   payloadType;
    ULONG   uTotalLen = 0;
    LONG   totalLen;
    ULONG   safetyLen;
    ULONG   hdrLen;
    PUCHAR  pHash;
    UCHAR   tempHash[SAFETY_LEN+1];
    ULONG   Len;
    UCHAR   Buf[MAX_AH_OUTPUT_LEN];
    PUCHAR  pAHData = Buf;
    PAUTH_ALGO      pAlgo = &(auth_algorithms[pSA->INT_ALGO(Index)]);
    ULONG   hashBytes = 0;
    IPRcvBuf    *temp = (IPRcvBuf *)pData;
    IPHeader UNALIGNED *pIPH = (IPHeader UNALIGNED *)*pIPHeader;
    ULONG   extraBytes = 0;
    USHORT  FilterFlags;
    BOOLEAN fTunnel = ((pSA->sa_Flags & FLAGS_SA_TUNNEL) &&
                       ((Index == 0) ||
                        ((Index == 1) && (pSA->sa_Operation[0] == Compress))));
    ULONG   TruncatedLen = (pSA->INT_ALGO(Index) != IPSEC_AH_NONE)? pSA->sa_TruncatedLen: 0;
    ULONG uPadLen = 0;
    IPRcvBuf * temp_pre = NULL;
    PUCHAR  data;
    ULONG ExtraTransportNat=0;
    BOOLEAN bNatMdlChange=FALSE;

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Entering IPSecVerifyHughes"));


    ASSERT(pSA->sa_Operation[Index] == Encrypt);

    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    //
    // Transport mode: payload is after IP header => payloadlen is total len - hdr len
    // Tunnel mode: payload starts at IP header => payloadlen is total len
    //
    IPSEC_GET_TOTAL_LEN_RCV_BUF(pData, &totalLen);

	switch(pSA->sa_EncapType) {
    case SA_UDP_ENCAP_TYPE_NONE:
        break;
    case SA_UDP_ENCAP_TYPE_IKE:
        ExtraTransportNat= sizeof(NATENCAP);
        break;
    case SA_UDP_ENCAP_TYPE_OTHER:
        ExtraTransportNat=sizeof(NATENCAP_OTHER);
        break;
	}
    //
    // Do we have enough in the buffer?
    //
    // BUG:566887 : Adding 8 bytes of minimum payload which have to be preent
    // The reason we have 8 bytes is because this function is specifically for
    // des-md5 and des has blocklen of 8 bytes
    Len = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + TruncatedLen + 
             ExtraTransportNat + 
             ((pSA->CONF_ALGO(Index) == IPSEC_ESP_NONE) ? 4: DES_BLOCKLEN);




    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: iph_len %d & hdrLen %d", NET_SHORT(pIPH->iph_length), hdrLen));
    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: DataLen %d & IPSecLen %d", totalLen, Len));

    if (totalLen < (LONG)Len || totalLen != (NET_SHORT(pIPH->iph_length) - hdrLen)) {
        ASSERT(FALSE);
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // See if the signature matches the hash
    // First get the *&*&* hash - its at the end of the packet...
    //
    //
    IPSecQueryRcvBuf((IPRcvBuf *)pData, &pESP, &espLen);

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: First buffer %p", temp));

    //
    // Travel to the end of the packet and then backup TruncatedLen bytes
    //
    while (IPSEC_BUFFER_LINKAGE(temp)) {
        temp = IPSEC_BUFFER_LINKAGE(temp);
    }

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: Last buffer %p", temp));

    //
    // See if we have at least the full hash and padding in this one. Else go thru'
    // the slow path.
    //
    IPSecQueryRcvBuf(temp, &pHash, &Len);

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: Last buffer length %d", Len));

    safetyLen = MAX_PAD_LEN + TruncatedLen + 1;

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: Safety length %d", safetyLen));

    if (Len >= safetyLen) {
        //
        // now read the hash out of the buffer
        //
        pHash = pHash + Len - TruncatedLen;

        //
        // also remove the hash from the buffer
        //
        IPSEC_ADJUST_BUFFER_LEN (temp, Len - TruncatedLen);
        extraBytes += TruncatedLen;
        Len -= TruncatedLen;

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: Modified Last buffer length %d", Len));

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("pHash: %p", pHash));
    } else {
        //
        // out of luck; need to grovel the lists for the TRUNC_LEN + MAX_PAD_LEN (SAFETY_LEN) bytes of data.
        // we copy out the last SAFETY_LEN bytes into another buffer and plug that into the list at the end
        // by re-allocing the last RcvBuf. We also zap the lengths of the remaining RcvBufs that contain these
        // special bytes.
        // NOTE: We also remove the hash from the buffer chain.
        //
        ULONG   length;
        ULONG   offset=0;   // offset within the current buffer
        ULONG   off=0;      // offset in the dest buffer (tempHash)
        ULONG   bytesLeft = safetyLen;
        IPRcvBuf    tmpRcvBuf={0};
        LONG    len = NET_SHORT(pIPH->iph_length) - safetyLen - hdrLen;

        temp = (IPRcvBuf *)pData;

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: pData %p & Len %lx", pData, len));

        //
        // first travel to the buffer that points to a chain containing the
        // last SAFETY_LEN bytes by skipping (Total - SAFETY_LEN) bytes.
        //
        while (temp) {
            IPSecQueryRcvBuf(temp, &data, &length);
            len -= length;
            if (len < 0) {
                break;
            }
            temp = IPSEC_BUFFER_LINKAGE(temp);
        }

        if (!temp) {
            return  STATUS_UNSUCCESSFUL;
        }

        //
        // pTemp now points to the last SAFETY_LEN bytes. Note that the last SAFETY_LEN bytes
        // might be in as many buffers and that there might be an offset in the current temp
        // where the last set of bytes starts.
        //
        len = -len;
        offset = length - len;

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("After skip temp: %p, Len: %d, offset: %d", temp, len, offset));

        do {
            RtlCopyMemory(  tempHash+off,
                            data+offset,
                            len);
            off += len;
            bytesLeft -= len;

            //
            // Also remove the hash bytes from the chain as we traverse it.
            //
            IPSEC_ADJUST_BUFFER_LEN (temp, length - len);

            if (bytesLeft == 0) {
                ASSERT(off == safetyLen);
                break;
            }

            temp = IPSEC_BUFFER_LINKAGE(temp);

            if (!temp) {
                return  STATUS_UNSUCCESSFUL;
            }

            IPSecQueryRcvBuf(temp, &data, &length);
            offset = 0;
            len = length;
        } while (TRUE);

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("After copy tempHash: %p", tempHash));

        //
        // Now we have an IPRcvBuf chain which has had SAFETY_LEN bytes removed.
        // We reallocate these SAFETY_LEN bytes in the last buffer with help from IP.
        //
        tmpRcvBuf = *temp;

        if (!TCPIP_ALLOC_BUFF(temp, safetyLen)) {
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to realloc last 22 bytes"));
            return  STATUS_INSUFFICIENT_RESOURCES;
        }

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Alloc'ed new temp: %p", temp));

        //
        // Now temp points to the new buffer with SAFETY_LEN number of bytes.
        // Free the Original buffer.
        //
        TCPIP_FREE_BUFF(&tmpRcvBuf);

        //
        // Copy over the bytes into the buffer just allocated.
        //
        IPSEC_ADJUST_BUFFER_LEN (temp, safetyLen);
        IPSecQueryRcvBuf(temp, &data, &Len);
        ASSERT(Len == safetyLen);

        RtlCopyMemory(  data,
                        tempHash,
                        safetyLen);

        //
        // now read the hash out of the buffer
        //
        pHash = data + Len - TruncatedLen;

        //
        // also remove the hash from the buffer
        //
        IPSEC_ADJUST_BUFFER_LEN (temp, Len - TruncatedLen);

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Len in temp: %d", temp->ipr_size));

        extraBytes += TruncatedLen;
        Len -= TruncatedLen;

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("pHash: %p, Len: %d", pHash, Len));
    }


    //
    // Hash is generated starting after the IPHeader, ie at start of pData
    //
    if (!fCryptoDone) {
        status = IPSecHashMdlChainRecv( pSA,
                                    (PVOID)pData,       // source
                                    pAHData,            // dest
                                    pSA->INT_ALGO(Index),           // algo
                                    &hashBytes,
                                    Index,
                                    ExtraTransportNat);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to hash, pData: %p", pData));
            goto out;
        }

        if (!IPSecEqualMemory(  pAHData,
                                pHash,
                                TruncatedLen * sizeof(UCHAR))) {

            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                2,
                                TRUE);

            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed to compare, pPyld: %p, pAHData: %p", pHash, pAHData));
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);

            status=IPSEC_INVALID_ESP;
            goto out;
        }
    } else {
        hashBytes = totalLen - TruncatedLen;
    }

    //
    //BUG: 566887
    //Requery the receive buf containing the ESP header
    //In the process of removing the hash we may have removed
    //some bytes from this buffer too
    IPSecQueryRcvBuf((IPRcvBuf *)pData, &pESP, &espLen);


    if (espLen < (LONG)(ExtraTransportNat + sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen)) {
        // Slow path
        BYTE Replay[4];
        int i;
        
        for (i=0;i<4;i++) {
            IPSecGetRecvByteByOffset(pData,sizeof(ESP)+ExtraTransportNat+i,&Replay[i]);
		}
		status=IPSecChkReplayWindow(
								   NET_TO_HOST_LONG(*(ULONG UNALIGNED *)(Replay)),
								   pSA,
								   Index);
	} else {
		if (pSA->sa_EncapType != SA_UDP_ENCAP_TYPE_NONE) {

			pESP = (PESP)(((UCHAR*)pESP) + ExtraTransportNat);
		}
		status=IPSecChkReplayWindow(
								   NET_TO_HOST_LONG(*(ULONG UNALIGNED *)(pESP + 1)),
								   pSA,
								   Index);
	}

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Replay check failed, pSA: %p", pSA));
        IPSEC_INC_STATISTIC(dwNumPacketsWithReplayDetection);
        return status;
    }



    if (pSA->INT_ALGO(Index) != IPSEC_AH_NONE) {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.AuthenticatedBytesReceived,
            hashBytes);

        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uAuthenticatedBytesReceived,
            hashBytes);
    }

    espLen = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ExtraTransportNat;

    if ((pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) && !fCryptoDone) {
        PCONFID_ALGO    pConfAlgo;
        ULONG           blockLen;

        pConfAlgo = &(conf_algorithms[pSA->CONF_ALGO(Index)]);
        blockLen = pConfAlgo->blocklen;

        //
        // Make sure the data is aligned to 8 byte boundary.
        //
        if ((hashBytes - espLen) % blockLen) {
            IPSEC_DEBUG(LL_A, DBF_ESP, ("ESP data not aligned: hashBytes %d, totalLen %d, espLen %d, blockLen %d", hashBytes, totalLen, espLen, blockLen));
            return  STATUS_UNSUCCESSFUL;
        }

        //
        // Decrypt the entire block
        //
        status = IPSecDecryptBuffer(pData,
                                    pSA,
                                    &padLen,
                                    &payloadType,
                                    Index,
                                    ExtraTransportNat); 
        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Failed the decrypt"));
            goto out;
        }


    }

    //
    // Now remove the Pad too since it was not removed in Decrypt
    //
    padLen = *(pHash - (sizeof(UCHAR) << 1));

    payloadType = *(pHash - sizeof(UCHAR));

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("ESP: PadLen: %d, PayloadType: %lx, pHash: %p, Len: %d", padLen, payloadType, pHash, Len));

    //
    // Entire pad may not be in this buffer.
    //

    uPadLen = padLen + NUM_EXTRA;

    //
    //BUG:566887
    //Cant Receive a bogus padlen
    //
    if (totalLen-(LONG)(padLen +TruncatedLen+NUM_EXTRA) < (LONG)(sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + ExtraTransportNat))
        {
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Bogus Padlen\n"));
            status=STATUS_INVALID_PARAMETER;
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Total size of all the buffers is smaller than the esp pad length"));
			ASSERT(FALSE);
            goto out;
        }

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Total pad length = %d", uPadLen));

    while (Len < uPadLen) {

        IPSEC_ADJUST_BUFFER_LEN (temp, 0);

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Buffer: %p  has a length %d - setting it to 0", temp, Len));

        uPadLen -= Len;

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Net pad length = %d", uPadLen));

        temp_pre = (IPRcvBuf *) pData;

        while (temp_pre->ipr_next != temp) {
            temp_pre = IPSEC_BUFFER_LINKAGE(temp_pre);
            if (!temp_pre) {
                IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Total size of all the buffers is smaller than the esp pad length"));
                ASSERT(temp_pre);
                status= STATUS_UNSUCCESSFUL;
                goto out;
            }
        }

        IPSecQueryRcvBuf(temp_pre, &data, &Len);

        temp = temp_pre;
    }

    IPSEC_ADJUST_BUFFER_LEN (temp, Len - uPadLen);

    IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Buffer: %p  has a length %d - setting it to %d", temp, Len, Len - uPadLen));

    extraBytes += (padLen + NUM_EXTRA);

    if (pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.ConfidentialBytesReceived,
            totalLen - (extraBytes + espLen));

        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uConfidentialBytesReceived,
            totalLen - (extraBytes + espLen));
    }

    //
    // Bump up the bytes transformed count.
    //
    ADD_TO_LARGE_INTEGER(
        &pSA->sa_TotalBytesTransformed,
        totalLen);

    if (!fTunnel) {
        //
        // Update the IP header length to reflect removal of the ESP header
        //
        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: iph_len %d, padLen %d, truncLen %d & espLen %d", NET_SHORT(pIPH->iph_length), uPadLen, TruncatedLen, espLen));

        pIPH->iph_length =
            NET_SHORT(
                NET_SHORT(pIPH->iph_length) -
                (USHORT)(espLen + uPadLen + TruncatedLen));

        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: iph_len %d", NET_SHORT(pIPH->iph_length)));

        //
        // set the payload type in the IP header
        //
        pIPH->iph_protocol = payloadType;

        //
        // Remove the ESP header from the packet; pad was removed in Decrypt
        //
        IPSEC_SET_OFFSET_IN_BUFFER(pData, espLen);

        //
        // Move the IP header forward for filter/firewall hook, fast path only.
        //
        if (fFastRcv) {
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: fast receive true - "));
            IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Moving the IP header forward from %p by espLen %d", pIPH, espLen));
            IPSecMoveMemory(((PUCHAR)pIPH) + espLen, (PUCHAR)pIPH, hdrLen);
            *pIPHeader=(PUCHAR)pIPH+espLen;
            pIPH = (IPHeader UNALIGNED *)*pIPHeader;
        }

        extraBytes += espLen;

        //
        // Return modified packet.
        //
        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("Exiting VerifyHughes: extra bytes %d & status: %lx", extraBytes, status));

        *pExtraBytes += extraBytes;

#if DBG
        IPSEC_GET_TOTAL_LEN_RCV_BUF(pData, &uTotalLen);
        IPSEC_DEBUG(LL_A, DBF_HUGHES, ("VerifyHughes: iph_length %d & buflen %d", NET_SHORT(pIPH->iph_length), uTotalLen));
#endif

        status= STATUS_SUCCESS;
        goto out;
    } else {
        //
        // set the payload type in the IP header
        //
        pIPH->iph_protocol = payloadType;

        //
        // Remove the ESP header from the packet
        //
        IPSEC_SET_OFFSET_IN_BUFFER(pData, espLen);

        //
        // Move the IP header forward for filter/firewall hook, fast path only.
        //
        if (fFastRcv) {
            IPSecMoveMemory(((PUCHAR)pIPH) + espLen, (PUCHAR)pIPH, hdrLen);
            *pIPHeader=(PUCHAR)pIPH+espLen;
            pIPH = (IPHeader UNALIGNED *)*pIPHeader;
        }

        extraBytes += espLen;

        //
        // Return modified packet.
        //
        IPSEC_DEBUG(LL_A, DBF_ESP, ("Exiting IPSecVerifyHughes, espLen: %lx, status: %lx", espLen, status));

        if (payloadType != IP_IN_IP) {
            IPSEC_INC_STATISTIC(dwNumPacketsNotDecrypted);
            IPSEC_DEBUG(LL_A, DBF_ESP, ("Bad payloadtype: %c", payloadType));
            status = STATUS_INVALID_PARAMETER;
        }

        *pExtraBytes += extraBytes;

        //
        // Drop the original packet
        //
        // return status
    }

out:

	if (status == STATUS_SUCCESS &&
		pSA->sa_EncapType != SA_UDP_ENCAP_TYPE_NONE) {
		return IPSEC_SUCCESS_NAT_DECAPSULATE;
	}
    return status;
    
}

NTSTATUS
IPSecGetRecvByteByOffset(IPRcvBuf *pData,
                         LONG Offset,
                         BYTE *OutByte)
{

    LONG TotalStartOffset=0;       //Total start offset into data thus far 
    BYTE *pBuffer;
    LONG CurBufLen;

    while (pData) {
        IPSecQueryRcvBuf(pData,&pBuffer,&CurBufLen);
        
        if (Offset < CurBufLen+TotalStartOffset) {
            *OutByte=pBuffer[Offset-TotalStartOffset];
            return STATUS_SUCCESS;
        }
        TotalStartOffset +=CurBufLen;
        pData=IPSEC_BUFFER_LINKAGE(pData);
    }
    return STATUS_UNSUCCESSFUL;

}

NTSTATUS
IPSecGetRecvBytesByOffset(IPRcvBuf *pData,
                          LONG Offset,
                          BYTE *pOutBuffer,
                          ULONG BufLen)
{
    ULONG i;
    NTSTATUS status;

    for (i=0;i < BufLen; i++) {
        status=IPSecGetRecvByteByOffset(pData,
                                        Offset+i,
                                        &pOutBuffer[i]);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }
    return STATUS_SUCCESS;

}


NTSTATUS
IPSecSetRecvByteByOffset(IPRcvBuf *pData,
                         LONG Offset,
                         BYTE InByte)
{

    LONG TotalStartOffset=0;       //Total start offset into data thus far 
    BYTE *pBuffer;
    LONG CurBufLen;

    while (pData) {
        IPSecQueryRcvBuf(pData,&pBuffer,&CurBufLen);
        
        if (Offset < CurBufLen+TotalStartOffset) {
            pBuffer[Offset-TotalStartOffset]=InByte;
            return STATUS_SUCCESS;
        }
        TotalStartOffset +=CurBufLen;
        pData=IPSEC_BUFFER_LINKAGE(pData);
    }
    return STATUS_UNSUCCESSFUL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\intirspn.h ===
NTSTATUS
IPSecGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    );

NTSTATUS
IPSecInitiatorGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    );

NTSTATUS
IPSecResponderGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    );

NTSTATUS
IPSecResponderCreateLarvalSA(
    PIPSEC_GET_SPI pIpsecGetSPI,
    ULARGE_INTEGER uliAddr,
    PSA_TABLE_ENTRY * ppSA
    );

NTSTATUS
IPSecInitiatorCreateLarvalSA(
    PFILTER pFilter,
    ULARGE_INTEGER uliAddr,
    PSA_TABLE_ENTRY * ppSA,
    UCHAR DestType,
    PIPSEC_UDP_ENCAP_CONTEXT pEncapContext
    );

NTSTATUS
IPSecFindSA(
    BOOLEAN bTunnelFilter,
    ULARGE_INTEGER uliSrcDstAddr,
    ULARGE_INTEGER uliProtoSrcDstPort,
    PFILTER * ppFilter,
    PSA_TABLE_ENTRY * ppSA,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    );

NTSTATUS
IPSecResponderInsertInboundSA(
    PSA_TABLE_ENTRY pSA,
    PIPSEC_GET_SPI pIpsecGetSPI,
    BOOLEAN bTunnelFilter
    );

NTSTATUS
IPSecInitiatorInsertInboundSA(
    PSA_TABLE_ENTRY pSA,
    BOOLEAN bTunnelFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\globals.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This is the main header file for IPSEC. Contains all the globals.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef  _GLOBALS_H
#define  _GLOBALS_H

#include "NsIpsec.h"


#define MAX_COUNT_STRING_LEN    32

#define MAX_IP_OPTION_SIZE      40



// 64 bytes
#define MAX_KEYLEN_SHA  64
#define MAX_KEYLEN_MD5  64

// 8 bytes
#define MAX_KEYLEN_DES  8
#define MAX_IV_LEN      DES_BLOCKLEN

#define MAX_KEY_LEN     MAX(MAX_KEYLEN_MD5, MAX_KEYLEN_DES)

//
// we set aside SPIs between 256 and 65536 (64K) for hardware offload
//
#define LOWER_BOUND_SPI     256
#define UPPER_BOUND_SPI     ((ULONG) -1)    // MAX_ULONG

#define INVALID_INDEX       0xffffffff

#define RNG_KEY_SIZE        256         // 2048 bits
#define RNG_REKEY_THRESHOLD 65536       // 64K raw bytes

//
// Constants related to filter lists
//
#define INBOUND_TRANSPORT_FILTER    0
#define OUTBOUND_TRANSPORT_FILTER   1
#define INBOUND_TUNNEL_FILTER       2
#define OUTBOUND_TUNNEL_FILTER      3

#define MIN_FILTER                  INBOUND_TRANSPORT_FILTER
#define MAX_FILTER                  OUTBOUND_TUNNEL_FILTER

#define MIN_TRANSPORT_FILTER        INBOUND_TRANSPORT_FILTER
#define MAX_TRANSPORT_FILTER        OUTBOUND_TRANSPORT_FILTER

#define MIN_TUNNEL_FILTER           INBOUND_TUNNEL_FILTER
#define MAX_TUNNEL_FILTER           OUTBOUND_TUNNEL_FILTER

#define INBOUND_OUTBOUND_INCREMENT  1
#define TRANSPORT_TUNNEL_INCREMENT  2

#define NUM_FILTERS                 (MAX_FILTER - MIN_FILTER + 1)

//
// Number of extra bytes when we pad - one for padlen and other for payloadtype
//
#define NUM_EXTRA   2

#define ESP_SIZE (sizeof(ESP) + DES_BLOCKLEN * sizeof(UCHAR))

#define TRUNCATED_HASH_LEN  12 // 96 bits
#define REPLAY_WINDOW_SIZE  64

#define MAX_PAD_LEN         (DES_BLOCKLEN + NUM_EXTRA - 1)

#define IPSEC_SMALL_BUFFER_SIZE 50
#define IPSEC_LARGE_BUFFER_SIZE 200

#define IPSEC_CACHE_LINE_SIZE   16

#define IPSEC_LIST_DEPTH    5

typedef ULONG tSPI;

#define MAX_BLOCKLEN    MAX(DES_BLOCKLEN, 0)

#define IPSEC_TAG_INIT              'ISpI'
#define IPSEC_TAG_AH                'TApI'
#define IPSEC_TAG_AH_TU             'UApI'
#define IPSEC_TAG_ESP               'TEpI'
#define IPSEC_TAG_ESP_TU            'UEpI'
#define IPSEC_TAG_HUGHES            'THpI'
#define IPSEC_TAG_HUGHES_TU         'UHpI'
#define IPSEC_TAG_ACQUIRE_CTX       'XApI'
#define IPSEC_TAG_FILTER            'IFpI'
#define IPSEC_TAG_SA                'ASpI'
#define IPSEC_TAG_KEY               'EKpI'
#define IPSEC_TAG_TIMER             'ITpI'
#define IPSEC_TAG_STALL_QUEUE       'QSpI'
#define IPSEC_TAG_LOOKASIDE_LISTS   'ALpI'
#define IPSEC_TAG_BUFFER_POOL       'PBpI'
#define IPSEC_TAG_SEND_COMPLETE     'CSpI'
#define IPSEC_TAG_EVT_QUEUE         'QEpI'
#define IPSEC_TAG_HW                'WHpI'
#define IPSEC_TAG_HW_PKTINFO        'KPpI'
#define IPSEC_TAG_HW_PKTEXT         'XEpI'
#define IPSEC_TAG_HW_ADDSA          'SApI'
#define IPSEC_TAG_HW_DELSA          'SDpI'
#define IPSEC_TAG_HW_PLUMB          'LPpI'
#define IPSEC_TAG_COMP              'OCpI'
#define IPSEC_TAG_REINJECT          'ERpI'
#define IPSEC_TAG_IOCTL             'OIpI'
#define IPSEC_TAG_LOG               'OLpI'
#define IPSEC_TAG_PARSER            'sPpI'
#define IPSEC_TAG_ICMP              'cIpI'
#define IPSEC_TAG_STATEFUL_ENTRY    'ESpI'
#define IPSEC_TAG_STATEFUL_HT       'HSpI'
#define IPSEC_TAG_HASH_POOL       'PHpI'



#define IPSEC_LOG_PACKET_SIZE 128 //Size in bytes of stored packet in troubleshoot mode


//
// The IPSEC ESP payload
//
typedef struct  _ESP {
    tSPI   esp_spi;
} ESP, *PESP;

typedef struct  _NATENCAP {
    ushort      uh_src;             // Source port.
    ushort      uh_dest;            // Destination port.
    ushort      uh_length;          // Length
    ushort      uh_xsum;            // Checksum.
    UCHAR  Zero[8];
} NATENCAP, *PNATENCAP;

typedef struct  _NATENCAP_OTHER {
    ushort      uh_src;             // Source port.
    ushort      uh_dest;            // Destination port.
    ushort      uh_length;          // Length
    ushort      uh_xsum;            // Checksum.
} NATENCAP_OTHER, *PNATENCAP_OTHER;


//
// SA Flags - Not mutually exclusive
//
#define FLAGS_SA_INITIATOR          0x00000001  // use Initiator keys? might be deprecated soon
#define FLAGS_SA_OUTBOUND           0x00000002  // outbound SA?
#define FLAGS_SA_TUNNEL             0x00000004  // tunnel mode? sa_TunnelAddr is significant
#define FLAGS_SA_REKEY              0x00000010  // is this rekeyed LarvalSA?
#define FLAGS_SA_REKEY_ORI          0x00000020  // did this kick off a rekey?
#define FLAGS_SA_MANUAL             0x00000040  // manual keyed?
#define FLAGS_SA_MTU_BUMPED         0x00000080  // was MTU bumped down on this SA?
#define FLAGS_SA_PENDING            0x00000100  // this is on the pending queue.
#define FLAGS_SA_TIMER_STARTED      0x00000200  // timer started on this SA
#define FLAGS_SA_HW_PLUMBED         0x00000400  // hw acceleration plumbed successfully
#define FLAGS_SA_HW_PLUMB_FAILED    0x00000800  // hw acceleration plumbing failed
#define FLAGS_SA_HW_DELETE_SA       0x00001000  // hw acceleration - this is the pending delete.
#define FLAGS_SA_HW_CRYPTO_ONLY     0x00002000  // hw acceleration - this is a crypto-only provider.
#define FLAGS_SA_HW_RESET           0x00004000  // hw acceleration - this offload SA has been reset
#define FLAGS_SA_HW_DELETE_QUEUED   0x00008000  // hw acceleration - this SA delete is queued so make sure reset doesn't touch it
#define FLAGS_SA_REFERENCED         0x00010000  // is this SA the next of another?
#define FLAGS_SA_NOTIFY_PERFORMED   0x00020000  // For inbound only.  Notification performed
#define FLAGS_SA_ON_FILTER_LIST     0x00040000  // used on inbound SAs to indicate they are on filter lists
#define FLAGS_SA_ON_SPI_HASH        0x00080000  // used on inbound SAs to indicate they are on spi hash lists
#define FLAGS_SA_EXPIRED            0x00100000  // has this SA expired?
#define FLAGS_SA_IDLED_OUT          0x00200000  // has this SA idled out?
#define FLAGS_SA_HIBERNATED         0x00400000  // has this SA been hibernated?
#define FLAGS_SA_DELETE_BY_IOCTL    0x00800000  // sa delete initiated by external source
#define FLAGS_SA_OFFLOADABLE        0x01000000  // is this SA offloadable?
#define FLAGS_SA_PASSTHRU_FILTER    0x02000000  // sa derived from a pass-thru filter
#define FLAGS_SA_DISABLE_IDLE_OUT          0x04000000  // don't idle out
#define FLAGS_SA_DISABLE_ANTI_REPLAY_CHECK 0x08000000  // don't check anti-replay
#define FLAGS_SA_DISABLE_LIFETIME_CHECK    0x10000000  // don't check lifetimes
#define FLAGS_SA_ENABLE_NLBS_IDLE_CHECK    0x20000000  // Idle out faster




//
// SA States - Mutually exclusive
//
typedef enum    _SA_STATE   {
    STATE_SA_CREATED =   1,     // when created
    STATE_SA_LARVAL,            // Key negotiation going on - outbound SAs only
    STATE_SA_ACTIVE,            // outbound SA completely setup
    STATE_SA_LARVAL_ACTIVE,     // inbound active SA without the associated outbound SA
    STATE_SA_ZOMBIE             // SAs flushed, ready to be deleted
} SA_STATE, *PSA_STATE;

#define IPSEC_SA_SIGNATURE  0x4601
#define IPSEC_FILTER_SIGNATURE  0x4602

#if DBG
#define IPSEC_SA_D_1    'SAD1'
#define IPSEC_SA_D_2    'SAD2'
#define IPSEC_SA_D_3    'SAD3'
#define IPSEC_SA_D_4    'SAD4'
#endif

typedef struct _FILTER  FILTER, *PFILTER;

typedef    struct    _INTERNAL_ALGO_INFO {
    ULONG   algoIdentifier;
    PUCHAR  algoKey;
    ULONG   algoKeylen;
    ULONG   algoRounds;
} INTERNAL_ALGO_INFO, *PINTERNAL_ALGO_INFO;

typedef struct    _INTERNAL_ALGO {
    INTERNAL_ALGO_INFO    integrityAlgo;
    INTERNAL_ALGO_INFO    confAlgo;
    INTERNAL_ALGO_INFO    compAlgo;
} INTERNAL_ALGO, *PINTERNAL_ALGO;

typedef struct  _IPSEC_ACQUIRE_CONTEXT  IPSEC_ACQUIRE_CONTEXT, *PIPSEC_ACQUIRE_CONTEXT;
typedef struct  _FILTER_CACHE           FILTER_CACHE, *PFILTER_CACHE;

//
// Security Association Table (SATable)
//
// Indexed by the following:
//
// Sender maps {Src Addr, Dest Addr, User Context} to the index
//
// Receiver maps {Dest Addr, SPI} to the index
// SPI values are unique when generated manually, so can be used directly
// to index into the SATable for
//
typedef struct  _SATableEntry   {
    LIST_ENTRY      sa_SPILinkage;      // linkage in SPI hash table list
    LIST_ENTRY      sa_FilterLinkage;   // linkage in Filter table list
    LIST_ENTRY      sa_LarvalLinkage;   // linkage in Larval SA list
    LIST_ENTRY      sa_PendingLinkage;  // linkage in pending SA list - waiting for Acquire Irp

    struct  _SATableEntry *sa_AssociatedSA;    // outbound -> inbound link
    struct  _SATableEntry *sa_RekeyLarvalSA;   // points to the Larval SA on a rekey
    struct  _SATableEntry *sa_RekeyOriginalSA; // Rekey Larval SA points to the original SA that kicked off the rekey

    ULONG           sa_Signature;       // contains 4601

    ULONG           sa_AcquireId;       // cross-check with the Acquire Irp context
    PIPSEC_ACQUIRE_CONTEXT  sa_AcquireCtx;  // actual acquire context - used to invalidate the context.

    ULONG           sa_Flags;           // flags as defined above
    SA_STATE        sa_State;           // states as defined above

    ULONG           sa_Reference;       // ref count
    PFILTER         sa_Filter;          // assoc filter entry
    PFILTER_CACHE   sa_FilterCache;     // back pointer to cache entry so we can disable it when an SA goes away

    KSPIN_LOCK      sa_Lock;            // lock to protect the FilterCache ptr.

#if DBG
    ULONG           sa_d1;
#endif

    ULARGE_INTEGER  sa_uliSrcDstAddr;
    ULARGE_INTEGER  sa_uliSrcDstMask;
    ULARGE_INTEGER  sa_uliProtoSrcDstPort;

    IPAddr          sa_TunnelAddr;      // Tunnel dest end IP Addr
    IPAddr          sa_SrcTunnelAddr;   // Tunnel src end IP Addr

    // SPI - host order -   if outbound, SPI for remote,
    //                      else inbound (our) SPI

    tSPI            sa_SPI;                 // Inbound: in the multiple ops case, this is the SPI of the last operation.
                                            // Outbound: order is as specified in the update.

    LONG            sa_NumOps;              // the total number of operations to be done

    tSPI            sa_OtherSPIs[MAX_OPS];  // the other alternate SPIs.

    OPERATION_E     sa_Operation[MAX_OPS];
    INTERNAL_ALGO   sa_Algorithm[MAX_OPS];

    ULONG           sa_ReplayStartPoint;        // corresponds to RP_Key_I/R
    ULONG           sa_ReplayLastSeq[MAX_OPS];  // for replay detection - last seq recd
    ULONGLONG       sa_ReplayBitmap[MAX_OPS];   // for replay detection - 64 packet window
    ULONG           sa_ReplaySendSeq[MAX_OPS];  // for replay detection - next seq # to send
    ULONG           sa_ReplayLen;               // for replay detection - length of replay field - 32 bits

#if DBG
    ULONG           sa_d2;
#endif

    UCHAR           sa_iv[MAX_OPS][DES_BLOCKLEN];      // IV_Key_I/R
    ULONG           sa_ivlen;

    ULONG           sa_TruncatedLen;    // length of final hash after truncation

    LARGE_INTEGER   sa_KeyExpirationTime;   // time till re-key
    LARGE_INTEGER   sa_KeyExpirationBytes;  // max # of KBytes xformed till re-key
    LARGE_INTEGER   sa_TotalBytesTransformed; // running total
    LARGE_INTEGER   sa_KeyExpirationTimeWithPad;
    LARGE_INTEGER   sa_KeyExpirationBytesWithPad;

    LARGE_INTEGER   sa_IdleTime;            // total time this SA can sit idle
    LARGE_INTEGER   sa_LastUsedTime;        // time this SA was used last

#if DBG
    ULONG           sa_d3;
#endif

    LIFETIME        sa_Lifetime;

    ULONG           sa_BlockedDataLen;  // amount of pended data
    PNDIS_BUFFER    sa_BlockedBuffer;   // stall queue of 1 Mdl chain

#if DBG
    ULONG           sa_d4;
#endif

    Interface       *sa_IPIF;

    IPSEC_TIMER     sa_Timer;           // Timer struct for timer queue

    ULONG           sa_ExpiryTime;      // time until this SA expires
    NDIS_HANDLE     sa_OffloadHandle;
    LONG            sa_NumSends;
    WORK_QUEUE_ITEM sa_QueueItem;

    ULONG           sa_IPSecOverhead;
    ULONG           sa_NewMTU;

    DWORD           sa_QMPFSGroup;
    IKE_COOKIE_PAIR sa_CookiePair;
    IPSEC_SA_STATS  sa_Stats;
    UCHAR           sa_DestType;
    IPSEC_SA_UDP_ENCAP_TYPE sa_EncapType;

    IPSEC_UDP_ENCAP_CONTEXT sa_EncapContext;
    IPAddr          sa_PeerPrivateAddr;

} SA_TABLE_ENTRY, *PSA_TABLE_ENTRY;

//
// Context used between Key manager and IPSEC. Points to the Larval SA basically.
//
typedef struct  _IPSEC_ACQUIRE_CONTEXT {
    ULONG           AcquireId;      // unique ID to represent this transaction
    PSA_TABLE_ENTRY pSA;            // larval SA should contain this ID
} IPSEC_ACQUIRE_CONTEXT, *PIPSEC_ACQUIRE_CONTEXT;

//
// Packet Classification/Policy Setting is similar to that of the
// Filter Driver. We dont have filters per interface, however.
//
typedef struct _FILTER {
    ULONG           Signature;      // contains 4602
    BOOLEAN         TunnelFilter;
    BOOLEAN         LinkedFilter;   // true if on linked list
    USHORT          Flags;
    PFILTER_CACHE   FilterCache;    // back pointer to cache entry so we can disable it when filter is deleted
    LIST_ENTRY      MaskedLinkage;
    ULARGE_INTEGER  uliSrcDstAddr;
    ULARGE_INTEGER  uliSrcDstMask;
    ULARGE_INTEGER  uliProtoSrcDstPort;
    ULARGE_INTEGER  uliProtoSrcDstMask;
    IPAddr          TunnelAddr;
    ULONG           Reference;      // ref count
    LONG            SAChainSize;    // number of entries for SA chain hash
    ULONG           Index;          // hinted index
    GUID            PolicyId;       // policy GUID
    GUID            FilterId;       // filter GUID
#if GPC
    union {
        LIST_ENTRY          GpcLinkage;
        struct _GPC_FILTER {
            GPC_HANDLE      GpcCfInfoHandle;
            GPC_HANDLE      GpcPatternHandle;
        } GpcFilter;
    };
#endif
    LIST_ENTRY      SAChain[1];     // chain of SAs associated with this Filter
} FILTER, *PFILTER;

//
// a first level cache, contains IP headers cached for fast lookups
//
typedef struct _FILTER_CACHE {
    ULARGE_INTEGER  uliSrcDstAddr;
    ULARGE_INTEGER  uliProtoSrcDstPort;
    BOOLEAN         FilterEntry;    // if TRUE, the next one is a Filter
    union {
        PSA_TABLE_ENTRY pSAEntry;   // points to the associated SAEntry
        PFILTER         pFilter;    // points to the (drop/PassThru filter)
    };
    PSA_TABLE_ENTRY pNextSAEntry;   // points to the associated NextSAEntry
#if DBG
    ULARGE_INTEGER  CacheHitCount;
#endif
} FILTER_CACHE, *PFILTER_CACHE;

//
// Hash tables for specific SAs
//
typedef struct  _SA_HASH {
    LIST_ENTRY  SAList;
} SA_HASH, *PSA_HASH;

//
// This structure is used to hold on to an Irp from the Key manager.
// The Irp is completed to kick off an SA negotiation.
//
typedef struct _IPSEC_ACQUIRE_INFO {
    PIRP        Irp;     // irp passed down from Key manager
    LIST_ENTRY  PendingAcquires;    // linked list of pending acquire requests
    LIST_ENTRY  PendingNotifies;    // linked list of pending notifications
    KSPIN_LOCK  Lock;
    BOOLEAN     ResolvingNow;       // irp is in user mode doing a resolve
    BOOLEAN     InMe;       // irp is in user mode doing a resolve
} IPSEC_ACQUIRE_INFO, *PIPSEC_ACQUIRE_INFO;

//
// Buffer for lookaside list descriptors. Lookaside list descriptors
// cannot be statically allocated, as they need to ALWAYS be nonpageable,
// even when the entire driver is paged out.
//
typedef struct _IPSEC_LOOKASIDE_LISTS {
    NPAGED_LOOKASIDE_LIST SendCompleteCtxList;
    NPAGED_LOOKASIDE_LIST LargeBufferList;
    NPAGED_LOOKASIDE_LIST SmallBufferList;
} IPSEC_LOOKASIDE_LISTS, *PIPSEC_LOOKASIDE_LISTS;

//
// Data is organized as an MDL followed by the actual buffer being described by
// the mdl.
//
// !!NOTE: In the struct below, Data should be quadaligned since MDLs are always
// quad-aligned.
//
typedef struct _IPSEC_LA_BUFFER {
    ULONG   Tag;            // the actual tag this was used for
    PVOID   Buffer;         // the actual buffer
    ULONG   BufferLength;   // length of the buffer pointed by MDL
    PMDL    Mdl;            // pointer to an MDL describing the buffer
    UCHAR   Data[1];        // the real data starts here
} IPSEC_LA_BUFFER, *PIPSEC_LA_BUFFER;






#define IPSEC_STATEFUL_HASH_TABLE_SIZE 1000


typedef struct _IPSEC_STATEFUL_HASH_TABLE{
    // Array of lists
    // Lists of IPSEC_STATEFUL_ENTRY
    LIST_ENTRY   Entry[IPSEC_STATEFUL_HASH_TABLE_SIZE];
}IPSEC_STATEFUL_HASH_TABLE, *PIPSEC_STATEFUL_HASH_TABLE;

   

// Always stored outbound
// Allocated from IPSEC_HASH_BUFFER_POOL
// Stored in IPSEC_STATEFUL_HASH_TABLE
typedef struct _IPSEC_STATEFUL_ENTRY {
   LIST_ENTRY CollisionLinkage;
   IPAddr SrcAddr;
   IPAddr DestAddr;
   BYTE Protocol;
   USHORT SrcPort;
   USHORT DestPort;
} IPSEC_STATEFUL_ENTRY, *PIPSEC_STATEFUL_ENTRY;

#define TOTAL_STATEFUL_ENTRY_COUNT 10000

//Write access to SADBLock required for allocation
//Cycle around when full.
//Use list entries in the IPSEC_STATEFUL_ENTRY 
//to remove from hash table.
typedef struct _IPSEC_HASH_BUFFER_POOL {
   ULONG ulEntriesUsed;
   ULONG ulCurrentPosition;
   IPSEC_STATEFUL_ENTRY  PoolEntry[TOTAL_STATEFUL_ENTRY_COUNT];
} IPSEC_HASH_BUFFER_POOL, * PIPSEC_HASH_BUFFER_POOL;

    


typedef struct _IPSEC_GLOBAL {
    BOOLEAN     DriverUnloading;    // Is driver being unloaded?
    BOOLEAN     BoundToIP;          // Are we bound to IP yet?
    BOOLEAN     SendBoundToIP;      // Is IPSecHandler bound to IP?
    BOOLEAN     InitCrypto;         // Are crypto routines initialized?
    BOOLEAN     InitRNG;            // Is RNG initialized?
    BOOLEAN     InitTcpip;          // Is TCP/IP loaded?
#if FIPS
    BOOLEAN     InitFips;           // Is Fips driver loaded and function table set?
#endif
#if GPC
    BOOLEAN     InitGpc;            // Is GPC driver loaded and function table set?
#endif

    LONG        NumSends;           // counts the number of pending sends
    LONG        NumThreads;         // counts the number of threads in driver
    LONG        NumWorkers;         // counts the number of worker threads
    LONG        NumTimers;          // counts the number of active timers
    LONG        NumIoctls;          // counts the number of active IOCTLs

    LIST_ENTRY  LarvalSAList;
    KSPIN_LOCK  LarvalListLock;     // protects the larval SA list

    MRSW_LOCK   SADBLock;           // protects the Filter/SA DB
    MRSW_LOCK   SPIListLock;        // protects the SPI list

    //
    // We partition the filters into tunnel/masked and inbound/outbound filters.
    //
    LIST_ENTRY  FilterList[NUM_FILTERS];

    ULONG       NumPolicies;        // number of filters plumbed in the driver
    ULONG       NumTunnelFilters;
    ULONG       NumMaskedFilters;
    ULONG       NumOutboundSAs;
    ULONG       NumMulticastFilters;

    //
    // Inbound <SPI, dest> hash
    //
    PSA_HASH    pSADb;
    LONG        NumSA;
    LONG        SAHashSize;

    PFILTER_CACHE   *ppCache;
    ULONG           CacheSize;
    ULONG           CacheHalfSize;

    //
    // SA negotiate context
    //
    IPSEC_ACQUIRE_INFO  AcquireInfo;

    //
    // timers
    //
    KSPIN_LOCK          TimerLock;
    IPSEC_TIMER_LIST    TimerList[IPSEC_CLASS_MAX];

    IPSEC_TIMER         ReaperTimer;    // reaper thread runs here.

    //
    // Global lookaside lists. These must always be in nonpaged pool,
    // even when the driver is paged out.
    //
    PIPSEC_LOOKASIDE_LISTS IPSecLookasideLists;

    ULONG   IPSecLargeBufferSize;
    ULONG   IPSecLargeBufferListDepth;

    ULONG   IPSecSmallBufferSize;
    ULONG   IPSecSmallBufferListDepth;

    ULONG   IPSecSendCompleteCtxSize;
    ULONG   IPSecSendCompleteCtxDepth;

    ULONG   IPSecCacheLineSize;

    PDEVICE_OBJECT  IPSecDevice;
    PDRIVER_OBJECT  IPSecDriverObject;

    ProtInfo    IPProtInfo;
    IPOptInfo   OptInfo;

    //
    // stats
    //
    IPSEC_QUERY_STATS   Statistics;


    DWORD 	dwPacketsOnWrongSA;  
    ULONG       EnableOffload;
    ULONG       DefaultSAIdleTime;
    ULONG       LogInterval;
    ULONG       EventQueueSize;
    ULONG       RekeyTime;
    ULONG       NoDefaultExempt;

    KSPIN_LOCK  EventLogLock;   // lock to protect event queue
    IPSEC_TIMER EventLogTimer;
    ULONG       IPSecBufferedEvents;
    PUCHAR      IPSecLogMemory;
    PUCHAR      IPSecLogMemoryLoc;
    PUCHAR      IPSecLogMemoryEnd;


    LARGE_INTEGER   SAIdleTime;

#if DBG
    ULARGE_INTEGER  CacheHitCount;
#endif
   
    OPERATION_MODE  OperationMode;
    IPSEC_FORWARDING_BEHAVIOR DefaultForwardingBehavior;
    ULONG DiagnosticMode;

#if GPC
    GPC_EXPORTED_CALLS  GpcEntries;
    GPC_HANDLE          GpcClients[GPC_CF_MAX];
    ULONG               GpcActive;
    ULONG               GpcNumFilters[GPC_CF_MAX];
    LIST_ENTRY          GpcFilterList[NUM_FILTERS];
#if DBG
    LARGE_INTEGER       GpcTotalPassedIn;
    LARGE_INTEGER       GpcClassifyNeeded;
    LARGE_INTEGER       GpcReClassified;
#endif
#endif

#if FIPS
    PFILE_OBJECT        FipsFileObject;
    FIPS_FUNCTION_TABLE FipsFunctionTable;
#endif

    PIPSEC_EXEMPT_ENTRY BootExemptList;
    ULONG	 BootExemptListSize;		//Entry count

    // Pointer to the Hash table 
    // Initialized in DriverEntry
    PIPSEC_STATEFUL_HASH_TABLE BootStatefulHT;
    PIPSEC_HASH_BUFFER_POOL     BootBufferPool;
     
    LARGE_INTEGER StartTimeDelta;



    IPSEC_NATSHIM_FUNCTIONS ShimFunctions;

    VOID        (*TcpipFreeBuff)(struct IPRcvBuf *);
    INT         (*TcpipAllocBuff)(struct IPRcvBuf *, UINT);
    UCHAR       (*TcpipGetAddrType)(IPAddr);
    IP_STATUS   (*TcpipGetInfo)(IPInfo *, INT);
    NDIS_STATUS (*TcpipNdisRequest)(PVOID, NDIS_REQUEST_TYPE, NDIS_OID, PVOID, UINT, PUINT);
    PVOID       (*TcpipRegisterProtocol)(UCHAR, PVOID, PVOID, PVOID, PVOID, PVOID, PVOID);
    NTSTATUS    (*TcpipSetIPSecStatus)(BOOLEAN);
    IP_STATUS   (*TcpipIPTransmit)(PVOID, PVOID, PNDIS_BUFFER, UINT, IPAddr, IPAddr, IPOptInfo *, RouteCacheEntry *, UCHAR, PIRP);
    IP_STATUS   (*TcpipSetIPSecPtr)(PIPSEC_FUNCTIONS);
    IP_STATUS   (*TcpipUnSetIPSecPtr)(PIPSEC_FUNCTIONS);
    IP_STATUS   (*TcpipUnSetIPSecSendPtr)(PIPSEC_FUNCTIONS);
    UINT        (*TcpipTCPXsum)(UINT, PVOID, UINT);
    USHORT      (*TcpipGenIpId)();
    PVOID       (*TcpipDeRegisterProtocol)(UCHAR);
    IP_STATUS   (*TcpipGetPInfo)(IPAddr, IPAddr, uint *, uint *, RouteCacheEntry *);
    IP_STATUS   (*TcpipSendICMPErr)(IPAddr, IPHeader UNALIGNED *, uchar, uchar, ulong, uchar);
} IPSEC_GLOBAL, *PIPSEC_GLOBAL;


//
// Contexts used to store eventlog contexts.
//
#define IPSEC_DROP_STATUS_CRYPTO_DONE      0x00000001
#define IPSEC_DROP_STATUS_NEXT_CRYPTO_DONE 0x00000002
#define IPSEC_DROP_STATUS_SA_DELETE_REQ    0x00000004
#define IPSEC_DROP_STATUS_DONT_LOG         0x00000008

typedef struct _IPSEC_DROP_STATUS {
    ULONG           IPSecStatus;
    ULONG           OffloadStatus;
    ULONG           Flags;
} IPSEC_DROP_STATUS, *PIPSEC_DROP_STATUS;

typedef struct  _IPSEC_EVENT_CTX {
    IPAddr  Addr;
    ULONG   EventCode;
    ULONG   UniqueEventValue;
    ULONG   EventCount;
    PUCHAR  pPacket;
    ULONG   PacketSize;
    IPSEC_DROP_STATUS DropStatus;
} IPSEC_EVENT_CTX, *PIPSEC_EVENT_CTX;

typedef struct _IPSEC_NOTIFY_EXPIRE {
    LIST_ENTRY      notify_PendingLinkage;  // linkage in pending SA list - waiting for Acquire Irp
    ULARGE_INTEGER  sa_uliSrcDstAddr;
    ULARGE_INTEGER  sa_uliSrcDstMask;
    ULARGE_INTEGER  sa_uliProtoSrcDstPort;

    IPAddr          sa_TunnelAddr;  // Tunnel end IP Addr
    IPAddr          sa_InboundTunnelAddr;  // Tunnel end IP Addr

    tSPI            InboundSpi;                 // Inbound: in the multiple ops case, this is the SPI of the last operation.
    tSPI            OutboundSpi;

    IKE_COOKIE_PAIR sa_CookiePair;
    DWORD           Flags;
    IPSEC_UDP_ENCAP_CONTEXT sa_EncapContext;
    IPAddr          sa_PeerPrivateAddr;
} IPSEC_NOTIFY_EXPIRE, *PIPSEC_NOTIFY_EXPIRE;


typedef IPSEC_ADD_UPDATE_SA IPSEC_ADD_SA, *PIPSEC_ADD_SA;
typedef IPSEC_ADD_UPDATE_SA IPSEC_UPDATE_SA, *PIPSEC_UPDATE_SA;

#define IPSEC_ADD_SA_NO_KEY_SIZE    FIELD_OFFSET(IPSEC_ADD_SA, SAInfo.KeyMat[0])
#define IPSEC_UPDATE_SA_NO_KEY_SIZE FIELD_OFFSET(IPSEC_UPDATE_SA, SAInfo.KeyMat[0])

typedef struct _PARSER_IFENTRY {
    struct _PARSER_IFENTRY * pNext;
    UDP_ENCAP_TYPE UdpEncapType;
    USHORT usDstEncapPort;
    HANDLE hInterface;
    HANDLE hParserIfOffload;
    ULONG uRefCnt;
} PARSER_IFENTRY, * PPARSER_IFENTRY;


//
// Contexts used to store SA plumbing contexts.
//
typedef struct _IPSEC_PLUMB_SA {
    Interface       *DestIF;
    PSA_TABLE_ENTRY pSA;
    PPARSER_IFENTRY pParserIfEntry;
    PUCHAR          Buf;
    ULONG           Len;
    WORK_QUEUE_ITEM PlumbQueueItem;
} IPSEC_PLUMB_SA, *PIPSEC_PLUMB_SA;


typedef struct _IPSEC_MTU_CONTEXT {
    IPAddr Src;
    IPAddr TransportDest;
    IPAddr TunnelDest;
    tSPI TransportSPI;
    tSPI TunnelSPI;
} IPSEC_MTU_CONTEXT, *PIPSEC_MTU_CONTEXT;


//
// Contexts used to log events
//
typedef struct _IPSEC_LOG_EVENT {
    LONG            LogSize;
    WORK_QUEUE_ITEM LogQueueItem;
    UCHAR           pLog[1];
} IPSEC_LOG_EVENT, *PIPSEC_LOG_EVENT;

#define PROTOCOL_UDP 17


#define TCP_HEADER_SIZE 20
#define UDP_HEADER_SIZE 8

#define MIN_ACQUIRE_ID 5
#endif  _GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\gpc.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    gpc.c

Abstract:

    This module contains the GPC implementation

Author:

    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"

#ifdef RUN_WPP
#include "gpc.tmh"
#endif

#if GPC


NTSTATUS
IPSecGpcInitialize()
{
    NTSTATUS    status;
    INT         cf, i;

    PAGED_CODE();

    //
    // Initialize FilterList for patterns that are not installed in GPC.
    //
    for (i = MIN_FILTER; i <= MAX_FILTER; i++) {
        InitializeListHead(&g_ipsec.GpcFilterList[i]);
    }

    //
    // Start with inactive state for the error path.
    //
    IPSEC_DRIVER_INIT_GPC() = FALSE;
    IPSEC_UNSET_GPC_ACTIVE();

    //
    // GPC registration.
    //
    status = GpcInitialize(&g_ipsec.GpcEntries);

    if (status == STATUS_SUCCESS) {
        for (cf = GPC_CF_IPSEC_MIN; cf <= GPC_CF_IPSEC_MAX; cf++) {
            status = GPC_REGISTER_CLIENT(   cf,
                                            0,
                                            GPC_PRIORITY_IPSEC,
                                            NULL,
                                            NULL,
                                            &g_ipsec.GpcClients[cf]);

            if (status != STATUS_SUCCESS) {
                IPSEC_DEBUG(LL_A, DBF_LOAD, ("GPC failed to register cf %d", cf));

                g_ipsec.GpcClients[cf] = NULL;
                IPSecGpcDeinitialize();

                return  status;
            }
        }
    } else {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("Failed to init GPC structures"));
        return  status;
    }

    IPSEC_SET_GPC_ACTIVE();
    IPSEC_DRIVER_INIT_GPC() = TRUE;

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecGpcDeinitialize()
{
    INT cf;

    PAGED_CODE();

    IPSEC_UNSET_GPC_ACTIVE();

    //
    // GPC deregistration.
    //
    for (cf = GPC_CF_IPSEC_MIN; cf <= GPC_CF_IPSEC_MAX; cf++) {
        if (g_ipsec.GpcClients[cf]) {
            GPC_DEREGISTER_CLIENT(g_ipsec.GpcClients[cf]);
        }
    }

    GpcDeinitialize(&g_ipsec.GpcEntries);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecEnableGpc()
{
    KIRQL   kIrql;

    PAGED_CODE();

    if (IPSEC_DRIVER_INIT_GPC()) {
        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        IPSEC_SET_GPC_ACTIVE();

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecDisableGpc()
{
    KIRQL   kIrql;

    PAGED_CODE();

    if (IPSEC_DRIVER_INIT_GPC()) {
        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        IPSEC_UNSET_GPC_ACTIVE();

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInitGpcFilter(
    IN  PFILTER         pFilter,
    IN  PGPC_IP_PATTERN pPattern,
    IN  PGPC_IP_PATTERN pMask
    )
{
    PAGED_CODE();

    RtlZeroMemory(pPattern, sizeof(GPC_IP_PATTERN));
    RtlZeroMemory(pMask, sizeof(GPC_IP_PATTERN));

    pPattern->SrcAddr = pFilter->SRC_ADDR;
    pPattern->DstAddr = pFilter->DEST_ADDR;
    pPattern->ProtocolId = (UCHAR)pFilter->PROTO;
    pPattern->gpcSrcPort = FI_SRC_PORT(pFilter);
    pPattern->gpcDstPort = FI_DEST_PORT(pFilter);

    pMask->SrcAddr = pFilter->SRC_MASK;
    pMask->DstAddr = pFilter->DEST_MASK;
    pMask->ProtocolId = (UCHAR)IPSEC_GPC_MASK_ALL;
    pMask->gpcSrcPort = IPSEC_GPC_MASK_NONE;
    pMask->gpcDstPort = IPSEC_GPC_MASK_NONE;

    switch (pFilter->PROTO) {
        case FILTER_PROTO_ANY:
            if (FI_SRC_PORT(pFilter) != FILTER_TCPUDP_PORT_ANY) {
                RtlFillMemory(  &pMask->gpcSrcPort,
                                sizeof(pMask->gpcSrcPort),
                                IPSEC_GPC_MASK_ALL);
            }
            if (FI_DEST_PORT(pFilter) != FILTER_TCPUDP_PORT_ANY) {
                RtlFillMemory(  &pMask->gpcDstPort,
                                sizeof(pMask->gpcDstPort),
                                IPSEC_GPC_MASK_ALL);
            }
            pMask->ProtocolId = (UCHAR)IPSEC_GPC_MASK_NONE;
            break;

        case FILTER_PROTO_TCP:
        case FILTER_PROTO_UDP:
            if (FI_SRC_PORT(pFilter) != FILTER_TCPUDP_PORT_ANY) {
                RtlFillMemory(  &pMask->gpcSrcPort,
                                sizeof(pMask->gpcSrcPort),
                                IPSEC_GPC_MASK_ALL);
            }
            if (FI_DEST_PORT(pFilter) != FILTER_TCPUDP_PORT_ANY) {
                RtlFillMemory(  &pMask->gpcDstPort,
                                sizeof(pMask->gpcDstPort),
                                IPSEC_GPC_MASK_ALL);
            }
            break;

        default:
            break;
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInsertGpcPattern(
    IN  PFILTER pFilter
    )
{
    CLASSIFICATION_HANDLE   GpcHandle;
    GPC_IP_PATTERN          GpcPattern;
    GPC_IP_PATTERN          GpcMask;
    ULONG                   GpcPriority;
    INT                     GpcCf;
    NTSTATUS                status;

    PAGED_CODE();

    GpcCf = IPSecResolveGpcCf(IS_OUTBOUND_FILTER(pFilter));

    //
    // Add the filter as a CfInfo
    //
    status = GPC_ADD_CFINFO(g_ipsec.GpcClients[GpcCf],
                            sizeof(PFILTER),
                            (PVOID)&pFilter,
                            (GPC_CLIENT_HANDLE)pFilter,
                            &pFilter->GpcFilter.GpcCfInfoHandle);

    if (status == STATUS_SUCCESS) {
        //
        // Now add the filter as a pattern
        //
        IPSecInitGpcFilter(pFilter, &GpcPattern, &GpcMask);

        if (FI_DEST_PORT(pFilter) == FILTER_TCPUDP_PORT_ANY) {
            GpcPriority = 1;
        } else {
            GpcPriority = 0;
        }

        ASSERT(GpcPriority < GPC_PRIORITY_IPSEC);

        status = GPC_ADD_PATTERN(   g_ipsec.GpcClients[GpcCf],
                                    GPC_PROTOCOL_TEMPLATE_IP,
                                    &GpcPattern,
                                    &GpcMask,
                                    GpcPriority,
                                    pFilter->GpcFilter.GpcCfInfoHandle,
                                    &pFilter->GpcFilter.GpcPatternHandle,
                                    &GpcHandle);

        if (status != STATUS_SUCCESS) {
            IPSEC_DEBUG(LL_A, DBF_GPC, ("GpcAddPattern: failed with status %lx", status));

            GPC_REMOVE_CFINFO(  g_ipsec.GpcClients[GpcCf],
                                pFilter->GpcFilter.GpcCfInfoHandle);

            pFilter->GpcFilter.GpcCfInfoHandle = NULL;
            pFilter->GpcFilter.GpcPatternHandle = NULL;
        } else {
            g_ipsec.GpcNumFilters[GpcPriority]++;
        }
    }

    return  status;
}


NTSTATUS
IPSecDeleteGpcPattern(
    IN  PFILTER pFilter
    )
{
    ULONG   GpcPriority;
    INT     GpcCf = IPSecResolveGpcCf(IS_OUTBOUND_FILTER(pFilter));

    PAGED_CODE();

    if (pFilter->GpcFilter.GpcPatternHandle) {
        GPC_REMOVE_PATTERN( g_ipsec.GpcClients[GpcCf],
                            pFilter->GpcFilter.GpcPatternHandle);

        pFilter->GpcFilter.GpcPatternHandle = NULL;

        ASSERT(pFilter->GpcFilter.GpcCfInfoHandle);

        if (pFilter->GpcFilter.GpcCfInfoHandle) {
            GPC_REMOVE_CFINFO(  g_ipsec.GpcClients[GpcCf],
                                pFilter->GpcFilter.GpcCfInfoHandle);

            pFilter->GpcFilter.GpcCfInfoHandle = NULL;
        }

        if (FI_DEST_PORT(pFilter) == FILTER_TCPUDP_PORT_ANY) {
            GpcPriority = 1;
        } else {
            GpcPriority = 0;
        }

        ASSERT(GpcPriority < GPC_PRIORITY_IPSEC);

        g_ipsec.GpcNumFilters[GpcPriority]--;
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInsertGpcFilter(
    IN PFILTER  pFilter
    )
{
    NTSTATUS    status;
    PFILTER     pTempFilter;
    BOOL        InsertedFilter = FALSE;
    PLIST_ENTRY pEntry, pPrev;
    PLIST_ENTRY pFilterList;
    KIRQL       kIrql;

    PAGED_CODE();

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    pFilterList = IPSecResolveGpcFilterList(IS_TUNNEL_FILTER(pFilter),
                                            IS_OUTBOUND_FILTER(pFilter));

    pEntry = pFilterList->Flink;
    pPrev = pFilterList;

    while (pEntry != pFilterList) {
        pTempFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        GpcLinkage);
            
        if (pFilter->Index > pTempFilter->Index) {
            //
            // found the spot, insert it before pTempFilter
            //
            InsertHeadList(pPrev, &pFilter->GpcLinkage);
            InsertedFilter = TRUE;
            break;
        }   

        pPrev = pEntry;
        pEntry = pEntry->Flink;
    }

    if (!InsertedFilter) {
        //
        // didn't find spot, stick it in the end
        //
        InsertTailList(pFilterList, &pFilter->GpcLinkage);
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecDeleteGpcFilter(
    IN PFILTER  pFilter
    )
{
    KIRQL   kIrql;

    PAGED_CODE();

    if (!pFilter->GpcLinkage.Flink || !pFilter->GpcLinkage.Blink) {
        return  STATUS_SUCCESS;
    }

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    IPSecRemoveEntryList(&pFilter->GpcLinkage);

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecInstallGpcFilter(
    IN PFILTER  pFilter
    )
{
    PAGED_CODE();

    if (IS_TUNNEL_FILTER(pFilter)) {
        return  STATUS_SUCCESS;
    }

    if (IS_GPC_FILTER(pFilter)) {
        return  IPSecInsertGpcPattern(pFilter);
    } else {
        return  IPSecInsertGpcFilter(pFilter);
    }
}


NTSTATUS
IPSecUninstallGpcFilter(
    IN PFILTER  pFilter
    )
{
    PAGED_CODE();

    if (IS_TUNNEL_FILTER(pFilter)) {
        return  STATUS_SUCCESS;
    }

    if (IS_GPC_FILTER(pFilter)) {
        return  IPSecDeleteGpcPattern(pFilter);
    } else {
        return  IPSecDeleteGpcFilter(pFilter);
    }
}


NTSTATUS
IPSecLookupGpcSA(
    IN  ULARGE_INTEGER          uliSrcDstAddr,
    IN  ULARGE_INTEGER          uliProtoSrcDstPort,
    IN  CLASSIFICATION_HANDLE   GpcHandle,
    OUT PFILTER                 *ppFilter,
    OUT PSA_TABLE_ENTRY         *ppSA,
    OUT PSA_TABLE_ENTRY         *ppNextSA,
    OUT PSA_TABLE_ENTRY         *ppTunnelSA,
    IN  BOOLEAN                 fOutbound,
    IN BOOLEAN                  fVerify,
    IN PIPSEC_UDP_ENCAP_CONTEXT  pNatContext
    )
{
    PFILTER                 pFilter;
    PFILTER                 pTempFilter;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PSA_TABLE_ENTRY         pSA;
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    BOOLEAN                 fFound = FALSE;
    INT                     GpcCf;
    CLASSIFICATION_HANDLE   TempGpcHandle;

    *ppSA = NULL;
    *ppFilter = NULL;
    *ppTunnelSA = NULL;

    //
    // Search in Tunnel filters list first.
    //
    pFilterList = IPSecResolveFilterList(TRUE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {
            //
            // Found filter
            //
            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        //
        // Search for the particular SA now.
        //
        fFound = FALSE;

        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            ASSERT(pSA->sa_Flags & FLAGS_SA_TUNNEL);

            if (pFilter->TunnelAddr != 0 && EQUAL_NATENCAP(pNatContext,pSA)) {
                //
                // match the outbound flag also
                //
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                fFound = TRUE;
                *ppTunnelSA = pSA;
                break;
            }
        }

        if (fFound) {
            fFound = FALSE;
            *ppFilter = pFilter;
        } else {
            //
            // Found a filter entry, but need to negotiate keys.
            //
            *ppFilter = pFilter;
            return  STATUS_PENDING;
        }
    }

#if DBG
    if (fOutbound) {
        ADD_TO_LARGE_INTEGER(&g_ipsec.GpcTotalPassedIn, 1);
    }
#endif

    GpcCf = IPSecResolveGpcCf(fOutbound);

    TempGpcHandle = 0;

    if (GpcHandle == 0) {
#if DBG
        if (fOutbound) {
            ADD_TO_LARGE_INTEGER(&g_ipsec.GpcClassifyNeeded, 1);
        }
#endif

        //
        // Classify directly if no GpcHandle passed in.
        //
        IPSEC_CLASSIFY_PACKET(  GpcCf,
                                uliSrcDstAddr,
                                uliProtoSrcDstPort,
                                &pFilter,
                                &TempGpcHandle);
    } else {
        NTSTATUS    status;

        //
        // Or we use GpcHandle directly to get the filter installed.
        //
        pFilter = NULL;

        status = GPC_GET_CLIENT_CONTEXT(g_ipsec.GpcClients[GpcCf],
                                        GpcHandle,
                                        &pFilter);

        if (status == STATUS_INVALID_HANDLE) {
            //
            // Re-classify if handle is invalid.
            //
            IPSEC_CLASSIFY_PACKET(  GpcCf,
                                    uliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    &pFilter,
                                    &TempGpcHandle);
        }
    }

#if DBG
    if (IPSecDebug & DBF_EXTRADIAGNOSTIC) {
        PFILTER pDbgFilter = NULL;

        pFilterList = IPSecResolveFilterList(FALSE, fOutbound);

        for (   pEntry = pFilterList->Flink;
                pEntry != pFilterList;
                pEntry = pEntry->Flink) {

            pTempFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            MaskedLinkage);

            uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pTempFilter->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pTempFilter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pTempFilter->uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pTempFilter->uliProtoSrcDstPort.QuadPart)) {
                pDbgFilter = pTempFilter;
                break;
            }
        }

        if (pFilter != pDbgFilter &&
            (!pDbgFilter || IS_GPC_FILTER(pDbgFilter))) {
            IPSEC_DEBUG(LL_A, DBF_GPC, ("LookupGpcSA: pFilter %p, pDbgFilter %p, GpcHandle %lx, TempGpcHandle %lx", pFilter, pDbgFilter, GpcHandle, TempGpcHandle));
            IPSEC_DEBUG(LL_A, DBF_GPC, ("LookupGpcSA: Src %lx, Dest %lx, Protocol %d, SPort %lx, DPort %lx", SRC_ADDR, DEST_ADDR, PROTO, SRC_PORT, DEST_PORT));

            if (DebugGPC) {
                DbgBreakPoint();
            }
        }
    }
#endif

    //
    // Continue searching the local GPC filter list if not found.
    //
    if (!pFilter) {
        pFilterList = IPSecResolveGpcFilterList(FALSE, fOutbound);

        for (   pEntry = pFilterList->Flink;
                pEntry != pFilterList;
                pEntry = pEntry->Flink) {

            pTempFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            GpcLinkage);

            uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pTempFilter->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pTempFilter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pTempFilter->uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pTempFilter->uliProtoSrcDstPort.QuadPart)) {
                pFilter = pTempFilter;
                break;
            }
        }
    }


    if (pFilter) {
        //
        // Search for the particular SA now.
        //

        fFound=FALSE;
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);


            if (IS_CLASSD(NET_LONG(pSA->SA_SRC_ADDR))
                || IS_CLASSD(NET_LONG(pSA->SA_DEST_ADDR))) {
                uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pSA->sa_uliSrcDstMask.QuadPart;
           
                IPSEC_DEBUG(LL_A, DBF_HASH, ("MCAST: %d %d %d %d", uliAddr.LowPart, uliAddr.HighPart,
                            pSA->sa_uliSrcDstAddr.LowPart,pSA->sa_uliSrcDstAddr.HighPart));

                if (uliAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                    fFound=TRUE;
                }
            } else if (uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart && EQUAL_NATENCAP(pNatContext,pSA)) {
                fFound=TRUE;
            }
            if (fFound) {
                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                
                //
                // if there is also a tunnel SA, associate it here.
                //
                if (*ppTunnelSA && (fOutbound || fVerify)) {
                    *ppNextSA = *ppTunnelSA;
                    *ppTunnelSA = NULL;
                }
                
                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        // Also, ppTunnelSA is set to the proper tunnel SA we need
        // to hook to this end-2-end SA once it is negotiated.
        //
        *ppFilter = pFilter;

        return  STATUS_PENDING;
    } else {
        //
        // if only tunnel SA found, return that as the SA found.
        //
        if (*ppTunnelSA) {
            *ppSA = *ppTunnelSA;
            *ppTunnelSA = NULL;
            return  STATUS_SUCCESS;
        }
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;

}


NTSTATUS
IPSecLookupGpcMaskedSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    )
/*++

Routine Description:

    Looks up the SA given the relevant addresses.

Arguments:

    uliSrcDstAddr - src/dest IP addr
    uliProtoSrcDstPort - protocol, src/dest port
    ppFilter - filter found
    ppSA - SA found
    fOutbound - direction flag

Return Value:

    STATUS_SUCCESS - both filter and SA found
    STATUS_UNSUCCESSFUL - none found
    STATUS_PENDING - filter found, but no SA

Notes:

    Called with SADBLock held.

--*/
{
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    PFILTER                 pFilter;
    PFILTER                 pTempFilter;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PLIST_ENTRY             pEntry;
    PSA_TABLE_ENTRY         pSA;
    CLASSIFICATION_HANDLE   GpcHandle;
    INT                     GpcCf;

    *ppSA = NULL;
    *ppFilter = NULL;

    GpcCf = IPSecResolveGpcCf(fOutbound);

    GpcHandle = 0;

    IPSEC_CLASSIFY_PACKET(  GpcCf,
                            uliSrcDstAddr,
                            uliProtoSrcDstPort,
                            &pFilter,
                            &GpcHandle);

#if DBG
    if (IPSecDebug & DBF_EXTRADIAGNOSTIC) {
        PFILTER pDbgFilter = NULL;

        pFilterList = IPSecResolveFilterList(FALSE, fOutbound);

        for (   pEntry = pFilterList->Flink;
                pEntry != pFilterList;
                pEntry = pEntry->Flink) {

            pTempFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            MaskedLinkage);

            uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pTempFilter->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pTempFilter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pTempFilter->uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pTempFilter->uliProtoSrcDstPort.QuadPart)) {
                pDbgFilter = pTempFilter;
                break;
            }
        }

        if (pFilter != pDbgFilter &&
            (!pDbgFilter || IS_GPC_FILTER(pDbgFilter))) {
            IPSEC_DEBUG(LL_A, DBF_GPC, ("LookupMaskedSA: pFilter %p, pDbgFilter %p, GpcHandle %lx", pFilter, pDbgFilter, GpcHandle));
            IPSEC_DEBUG(LL_A, DBF_GPC, ("LookupMaskedSA: Src %lx, Dest %lx, Protocol %d, SPort %lx, DPort %lx", SRC_ADDR, DEST_ADDR, PROTO, SRC_PORT, DEST_PORT));

            if (DebugGPC) {
                DbgBreakPoint();
            }
        }
    }
#endif

    //
    // Continue searching the local GPC filter list if not found.
    //
    if (!pFilter) {
        pFilterList = IPSecResolveGpcFilterList(FALSE, fOutbound);

        for (   pEntry = pFilterList->Flink;
                pEntry != pFilterList;
                pEntry = pEntry->Flink) {

            pTempFilter = CONTAINING_RECORD(pEntry,
                                            FILTER,
                                            GpcLinkage);

            uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pTempFilter->uliSrcDstMask.QuadPart;
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pTempFilter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pTempFilter->uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pTempFilter->uliProtoSrcDstPort.QuadPart)) {
                pFilter = pTempFilter;
                break;
            }
        }
    }

    if (pFilter) {
        //
        // Search for the particular SA now.
        //
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            if (uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart && EQUAL_NATENCAP(pNatContext,pSA)  ) {

                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        //
        *ppFilter = pFilter;
        return  STATUS_PENDING;
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\gpc.h ===
#if GPC


NTSTATUS
IPSecGpcInitialize(
    );

NTSTATUS
IPSecGpcDeinitialize(
    );

NTSTATUS
IPSecEnableGpc(
    );

NTSTATUS
IPSecDisableGpc(
    );

NTSTATUS
IPSecInitGpcFilter(
    IN  PFILTER         pFilter,
    IN  PGPC_IP_PATTERN pPattern,
    IN  PGPC_IP_PATTERN pMask
    );

NTSTATUS
IPSecInsertGpcPattern(
    IN  PFILTER pFilter
    );

NTSTATUS
IPSecDeleteGpcPattern(
    IN  PFILTER pFilter
    );

NTSTATUS
IPSecInsertGpcFilter(
    IN PFILTER  pFilter
    );

NTSTATUS
IPSecDeleteGpcFilter(
    IN PFILTER  pFilter
    );

NTSTATUS
IPSecInstallGpcFilter(
    IN PFILTER  pFilter
    );

NTSTATUS
IPSecUninstallGpcFilter(
    IN PFILTER  pFilter
    );

NTSTATUS
IPSecLookupGpcSA(
    IN  ULARGE_INTEGER          uliSrcDstAddr,
    IN  ULARGE_INTEGER          uliProtoSrcDstPort,
    IN  CLASSIFICATION_HANDLE   GpcHandle,
    OUT PFILTER                 *ppFilter,
    OUT PSA_TABLE_ENTRY         *ppSA,
    OUT PSA_TABLE_ENTRY         *ppNextSA,
    OUT PSA_TABLE_ENTRY         *ppTunnelSA,
    IN  BOOLEAN                 fOutbound,
    IN BOOLEAN                  fVerify,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    );

NTSTATUS
IPSecLookupGpcMaskedSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\intirspn.c ===
#include "precomp.h"

#pragma hdrstop


NTSTATUS
IPSecGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    )
/*++

Routine Description:

    This routine returns the SPI.

Arguments:

    pIpsecGetSPI - Pointer to the ipsec get spi structure.

Return Value:

    NTSTATUS - The status code from this routine.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // If context was passed in, then there's a larval SA already setup.
    // This is the case for the initiator.
    //

    if (pIpsecGetSPI->Context) {
        ntStatus = IPSecInitiatorGetSPI(
                       pIpsecGetSPI
                       );
    }
    else {
        ntStatus = IPSecResponderGetSPI(
                       pIpsecGetSPI
                       );
    }

    return (ntStatus);
}


NTSTATUS
IPSecInitiatorGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireCtx = NULL;
    KIRQL kIrql;


    //
    // Sanity check the incoming context to see if it is actually
    // an SA block.
    //

    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    if (!NT_SUCCESS(IPSecValidateHandle(HandleToUlong(pIpsecGetSPI->Context),&pIpsecAcquireCtx, STATE_SA_LARVAL))) {
        ntStatus = STATUS_INVALID_PARAMETER;
        BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus);
    }

    pIpsecGetSPI->SPI = pIpsecAcquireCtx->pSA->sa_SPI;

    pIpsecAcquireCtx->pSA->sa_Flags |= FLAGS_SA_INITIATOR;

    ntStatus = STATUS_SUCCESS;

lock:

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    return (ntStatus);
}


NTSTATUS
IPSecResponderGetSPI(
    PIPSEC_GET_SPI pIpsecGetSPI
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL kIrql;
    PSA_TABLE_ENTRY pInboundSA = NULL;
    ULARGE_INTEGER uliSrcDstAddr = {0};
    PSA_TABLE_ENTRY pSA = NULL;
    PIPSEC_ACQUIRE_CONTEXT pIpsecAcquireCtx = NULL;


    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    if (pIpsecGetSPI->SPI) {

        if (!(pIpsecGetSPI->InstantiatedFilter.TunnelFilter)) {
            pInboundSA = IPSecLookupSABySPI(
                             pIpsecGetSPI->SPI,
                             pIpsecGetSPI->InstantiatedFilter.DestAddr
                             );
        }
        else {
            pInboundSA = IPSecLookupSABySPI(
                             pIpsecGetSPI->SPI,
                             pIpsecGetSPI->InstantiatedFilter.TunnelAddr
                             );
        }

        if (pInboundSA) {
            ntStatus = STATUS_UNSUCCESSFUL;
            BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus);
        }

    }

    ntStatus = IPSecResponderCreateLarvalSA(
                   pIpsecGetSPI,
                   uliSrcDstAddr,
                   &pSA
                   );
    BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus);

    //
    // Get the acquire Context and associate it with the larval SA.
    //

    pIpsecAcquireCtx = IPSecGetAcquireContext();

    if (!pIpsecAcquireCtx) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus);
    }

    pIpsecAcquireCtx->AcquireId = IPSecGetAcquireId();

    pIpsecAcquireCtx->pSA = pSA;
    pSA->sa_AcquireId = pIpsecAcquireCtx->AcquireId;

    pIpsecGetSPI->Context = UlongToHandle(pIpsecAcquireCtx->AcquireId);
    pSA->sa_AcquireCtx = pIpsecAcquireCtx;

    pIpsecGetSPI->SPI = pSA->sa_SPI;

    ntStatus = STATUS_SUCCESS;

lock:

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return (ntStatus);
}


NTSTATUS
IPSecResponderCreateLarvalSA(
    PIPSEC_GET_SPI pIpsecGetSPI,
    ULARGE_INTEGER uliAddr,
    PSA_TABLE_ENTRY * ppSA
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PSA_TABLE_ENTRY pSA = NULL;
    KIRQL kIrql;


    ntStatus = IPSecCreateSA(&pSA);
    BAIL_ON_NTSTATUS_ERROR(ntStatus);

    pSA->sa_Filter = NULL;
    pSA->sa_State = STATE_SA_LARVAL;

    IPSEC_BUILD_SRC_DEST_ADDR(
        pSA->sa_uliSrcDstAddr,
        pIpsecGetSPI->InstantiatedFilter.SrcAddr,
        pIpsecGetSPI->InstantiatedFilter.DestAddr
        );

    IPSEC_BUILD_SRC_DEST_MASK(
        pSA->sa_uliSrcDstMask,
        pIpsecGetSPI->InstantiatedFilter.SrcMask,
        pIpsecGetSPI->InstantiatedFilter.DestMask
        );

    IPSEC_BUILD_PROTO_PORT_LI(
        pSA->sa_uliProtoSrcDstPort,
        pIpsecGetSPI->InstantiatedFilter.Protocol,
        pIpsecGetSPI->InstantiatedFilter.SrcPort,
        pIpsecGetSPI->InstantiatedFilter.DestPort
        );

    ntStatus = IPSecResponderInsertInboundSA(
                   pSA,
                   pIpsecGetSPI,
                   pIpsecGetSPI->InstantiatedFilter.TunnelFilter
                   );
    BAIL_ON_NTSTATUS_ERROR(ntStatus);

    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    InsertTailList(&g_ipsec.LarvalSAList, &pSA->sa_LarvalLinkage);

    IPSEC_INC_STATISTIC(dwNumPendingKeyOps);

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);

    IPSecStartSATimer(
        pSA,
        IPSecSAExpired,
        pSA->sa_ExpiryTime
        );

    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    *ppSA = pSA;

    return (ntStatus);

error:

    if (pSA) {
        IPSecFreeSA(pSA);
    }

    *ppSA = NULL;
    return (ntStatus);
}


NTSTATUS
IPSecInitiatorCreateLarvalSA(
    PFILTER pFilter,
    ULARGE_INTEGER uliAddr,
    PSA_TABLE_ENTRY * ppSA,
    UCHAR DestType,
    PIPSEC_UDP_ENCAP_CONTEXT pEncapContext
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PSA_TABLE_ENTRY pSA = NULL;
    ULARGE_INTEGER uliSrcDstAddr = {0};
    ULARGE_INTEGER uliSrcDstMask = {0};
    ULARGE_INTEGER uliProtoSrcDstPort = {0};
    KIRQL kIrql;


    ntStatus = IPSecCreateSA(&pSA);
    BAIL_ON_NTSTATUS_ERROR(ntStatus);

    pSA->sa_Filter = pFilter;
    pSA->sa_State = STATE_SA_LARVAL;

    uliSrcDstAddr = uliAddr;
    uliSrcDstMask = pFilter->uliSrcDstMask;
    uliProtoSrcDstPort = pFilter->uliProtoSrcDstPort;

    IPSEC_BUILD_SRC_DEST_ADDR(
        pSA->sa_uliSrcDstAddr,
        DEST_ADDR,
        SRC_ADDR
        );

    IPSEC_BUILD_SRC_DEST_MASK(
        pSA->sa_uliSrcDstMask,
        DEST_MASK,
        SRC_MASK
        );

    IPSEC_BUILD_PROTO_PORT_LI(
        pSA->sa_uliProtoSrcDstPort,
        PROTO,
        DEST_PORT,
        SRC_PORT
        );

    pSA->sa_DestType=DestType;

    if (pEncapContext) { 
        RtlCopyMemory(&pSA->sa_EncapContext,pEncapContext,sizeof(IPSEC_UDP_ENCAP_CONTEXT));
    }

    ntStatus = IPSecInitiatorInsertInboundSA(
                   pSA,
                   pFilter->TunnelFilter
                   );
    BAIL_ON_NTSTATUS_ERROR(ntStatus);

    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    InsertTailList(&g_ipsec.LarvalSAList, &pSA->sa_LarvalLinkage);

    IPSEC_INC_STATISTIC(dwNumPendingKeyOps);

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);

    IPSecStartSATimer(
        pSA,
        IPSecSAExpired,
        pSA->sa_ExpiryTime
        );

    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    *ppSA = pSA;

    return (ntStatus);

error:

    if (pSA) {
        IPSecFreeSA(pSA);
    }

    *ppSA = NULL;
    return (ntStatus);
}


NTSTATUS
IPSecFindSA(
    BOOLEAN bTunnelFilter,
    ULARGE_INTEGER uliSrcDstAddr,
    ULARGE_INTEGER uliProtoSrcDstPort,
    PFILTER * ppFilter,
    PSA_TABLE_ENTRY * ppSA,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;


    if (bTunnelFilter) {
        ntStatus = IPSecLookupTunnelSA(
                       uliSrcDstAddr,
                       uliProtoSrcDstPort,
                       ppFilter,
                       ppSA,
                       FALSE,
                       pNatContext
                       );
    }
    else {

#if GPC

        if (IS_GPC_ACTIVE()) {
            ntStatus = IPSecLookupGpcMaskedSA(
                           uliSrcDstAddr,
                           uliProtoSrcDstPort,
                           ppFilter,
                           ppSA,
                           FALSE,
                           pNatContext
                           );
        }
        else {
            ntStatus = IPSecLookupMaskedSA(
                           uliSrcDstAddr,
                           uliProtoSrcDstPort,
                           ppFilter,
                           ppSA,
                           FALSE,
                           pNatContext
                           );
        }
#else

        ntStatus = IPSecLookupMaskedSA(
                       uliSrcDstAddr,
                       uliProtoSrcDstPort,
                       ppFilter,
                       ppSA,
                       FALSE,
                       pNatContext
                       );

#endif

    }

    return (ntStatus);
}


NTSTATUS
IPSecResponderInsertInboundSA(
    PSA_TABLE_ENTRY pSA,
    PIPSEC_GET_SPI pIpsecGetSPI,
    BOOLEAN bTunnelFilter
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFILTER pFilter = NULL;
    PSA_TABLE_ENTRY pInboundSA = NULL;
    PLIST_ENTRY pSAChain = NULL;
    KIRQL kIrql;
    tSPI tSpi = 0;
    PSA_HASH pHash = NULL;


    ntStatus = IPSecFindSA(
                   bTunnelFilter,
                   pSA->sa_uliSrcDstAddr,
                   pSA->sa_uliProtoSrcDstPort,
                   &pFilter,
                   &pInboundSA,
                   NULL
                   );
    if (!NT_SUCCESS(ntStatus)) {
        IPSecBufferEvent(
            pSA->SA_SRC_ADDR,
            EVENT_IPSEC_NEG_FAILURE,
            1,
            FALSE
            );
        return (ntStatus);
    }

    ASSERT(pFilter);

    if (pIpsecGetSPI->InstantiatedFilter.Protocol != pFilter->PROTO ||
        pIpsecGetSPI->InstantiatedFilter.SrcPort != FI_SRC_PORT(pFilter) ||
        pIpsecGetSPI->InstantiatedFilter.DestPort != FI_DEST_PORT(pFilter)) {
        ntStatus = STATUS_OBJECT_TYPE_MISMATCH;
        return (ntStatus);
    }

    pSAChain = IPSecResolveSAChain(pFilter, pSA->SA_SRC_ADDR);

    InsertHeadList(pSAChain, &pSA->sa_FilterLinkage);

    pSA->sa_Flags |= FLAGS_SA_ON_FILTER_LIST;

    if (pFilter->Flags & FILTER_FLAGS_PASS_THRU) {
        pSA->sa_Flags |= FLAGS_SA_PASSTHRU_FILTER;
    }

    if (pFilter->TunnelFilter) {
        pSA->sa_Flags |= FLAGS_SA_TUNNEL;
        pSA->sa_TunnelAddr = pFilter->TunnelAddr;
    }

    //
    // Flush this filter from the cache table so that the SA instead of the
    // filter is matched on the next lookup.
    //

    if (IS_EXEMPT_FILTER(pFilter)) {
        IPSecInvalidateFilterCacheEntry(pFilter);
    }

    AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);

    tSpi = pIpsecGetSPI->SPI;

    ntStatus = IPSecAllocateSPI(&tSpi, pSA);

    if (!NT_SUCCESS(ntStatus)) {
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);
        return (ntStatus);
    }

    pSA->sa_SPI = tSpi;

    IPSEC_HASH_SPI(
        (pSA->sa_TunnelAddr) ? pSA->sa_TunnelAddr : pSA->SA_DEST_ADDR,
        tSpi,
        pHash
        );

    InsertHeadList(&pHash->SAList, &pSA->sa_SPILinkage);

    pSA->sa_Flags |= FLAGS_SA_ON_SPI_HASH;

    ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

    return (STATUS_SUCCESS);
}


NTSTATUS
IPSecInitiatorInsertInboundSA(
    PSA_TABLE_ENTRY pSA,
    BOOLEAN bTunnelFilter
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFILTER pFilter = NULL;
    PSA_TABLE_ENTRY pInboundSA = NULL;
    PLIST_ENTRY pSAChain = NULL;
    KIRQL kIrql;
    tSPI tSpi = 0;
    PSA_HASH pHash = NULL;


    ntStatus = IPSecFindSA(
                   bTunnelFilter,
                   pSA->sa_uliSrcDstAddr,
                   pSA->sa_uliProtoSrcDstPort,
                   &pFilter,
                   &pInboundSA,
                   NULL
                   );
    if (!NT_SUCCESS(ntStatus)) {
        IPSecBufferEvent(
            pSA->SA_SRC_ADDR,
            EVENT_IPSEC_NEG_FAILURE,
            1,
            FALSE
            );
        return (ntStatus);
    }

    if (ntStatus == STATUS_SUCCESS) {
        if (pInboundSA->sa_State == STATE_SA_LARVAL) {
            ntStatus = STATUS_DUPLICATE_OBJECTID;
            return (ntStatus);
        }
    }

    ASSERT(pFilter);

    pSAChain = IPSecResolveSAChain(pFilter, pSA->SA_SRC_ADDR);

    InsertHeadList(pSAChain, &pSA->sa_FilterLinkage);

    pSA->sa_Flags |= FLAGS_SA_ON_FILTER_LIST;

    if (pFilter->Flags & FILTER_FLAGS_PASS_THRU) {
        pSA->sa_Flags |= FLAGS_SA_PASSTHRU_FILTER;
    }

    if (pFilter->TunnelFilter) {
        pSA->sa_Flags |= FLAGS_SA_TUNNEL;
        pSA->sa_TunnelAddr = pFilter->TunnelAddr;
    }

    //
    // Flush this filter from the cache table so that the SA instead of the
    // filter is matched on the next lookup.
    //

    if (IS_EXEMPT_FILTER(pFilter)) {
        IPSecInvalidateFilterCacheEntry(pFilter);
    }

    AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);

    tSpi = 0;

    ntStatus = IPSecAllocateSPI(&tSpi, pSA);

    if (!NT_SUCCESS(ntStatus)) {
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);
        return (ntStatus);
    }

    pSA->sa_SPI = tSpi;

    IPSEC_HASH_SPI(
        (pSA->sa_TunnelAddr) ? pSA->sa_TunnelAddr : pSA->SA_DEST_ADDR,
        tSpi,
        pHash
        );

    InsertHeadList(&pHash->SAList, &pSA->sa_SPILinkage);

    pSA->sa_Flags |= FLAGS_SA_ON_SPI_HASH;

    ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\locks.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    locks.h

Abstract:

    Contains all the lock related macros.

Author:

    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef _LOCKS_H
#define _LOCKS_H

#define IPSEC_READ_LOCK     1
#define IPSEC_WRITE_LOCK    2

#define INIT_LOCK(l)        KeInitializeSpinLock(l)
#define ACQUIRE_LOCK(l, q)  KeAcquireSpinLock(l, q)
#define RELEASE_LOCK(l, q)  KeReleaseSpinLock(l, q)

//
// The Filter/SA database is protected by a single-writer (infrequent) and
// multiple-reader (frequent) locking scheme.
//
typedef struct _MRSW_LOCK
{
    KSPIN_LOCK  SpinLock;
    ULONG       RefCount;
#if DBG
    ULONG       LastLockLine;
    ULONG       LastLockType;
#endif
} MRSW_LOCK, *PMRSW_LOCK;

__inline
VOID
InitializeMRSWLock(
    PMRSW_LOCK  pRWLock
    )
{
    pRWLock->RefCount = 0;
    KeInitializeSpinLock(&pRWLock->SpinLock);
#if DBG
    pRWLock->LastLockLine = 0;
    pRWLock->LastLockType = 0;
#endif
}

__inline
VOID
AcquireReadLock(
    PMRSW_LOCK  pRWLock,
    PKIRQL      pIrql
    )
{
    KeAcquireSpinLock(&pRWLock->SpinLock, pIrql);
    InterlockedIncrement(&pRWLock->RefCount);
    KeReleaseSpinLockFromDpcLevel(&pRWLock->SpinLock);
#if DBG
    pRWLock->LastLockLine = __LINE__;
    pRWLock->LastLockType = 1;
#endif
}

__inline
VOID
ReleaseReadLock(
    PMRSW_LOCK  pRWLock,
    KIRQL       Irql
    )
{
    InterlockedDecrement(&pRWLock->RefCount);
    KeLowerIrql(Irql);
}

__inline
VOID
AcquireReadLockAtDpc(
    PMRSW_LOCK  pRWLock
    )
{
    KeAcquireSpinLockAtDpcLevel(&pRWLock->SpinLock);
    InterlockedIncrement(&pRWLock->RefCount);
    KeReleaseSpinLockFromDpcLevel(&pRWLock->SpinLock);
#if DBG
    pRWLock->LastLockLine = __LINE__;
    pRWLock->LastLockType = IPSEC_READ_LOCK;
#endif
}

__inline
VOID
ReleaseReadLockFromDpc(
    PMRSW_LOCK  pRWLock
    )
{
    InterlockedDecrement(&pRWLock->RefCount);
}

__inline
VOID
AcquireWriteLock(
    PMRSW_LOCK  pRWLock,
    PKIRQL      pIrql
    )
{
    KeAcquireSpinLock(&pRWLock->SpinLock, pIrql);
    while (*((volatile *)&pRWLock->RefCount));
#if DBG
    pRWLock->LastLockLine = __LINE__;
    pRWLock->LastLockType = IPSEC_WRITE_LOCK;
#endif
}

__inline
VOID
ReleaseWriteLock(
    PMRSW_LOCK  pRWLock,
    KIRQL       Irql
    )
{
    KeReleaseSpinLock(&pRWLock->SpinLock, Irql);
}

__inline
VOID
AcquireWriteLockAtDpc(
    PMRSW_LOCK  pRWLock
    )
{
    KeAcquireSpinLockAtDpcLevel(&pRWLock->SpinLock);
    while (*((volatile *)&pRWLock->RefCount));
#if DBG
    pRWLock->LastLockLine = __LINE__;
    pRWLock->LastLockType = IPSEC_WRITE_LOCK;
#endif
}

__inline
VOID
ReleaseWriteLockFromDpc(
    PMRSW_LOCK  pRWLock
    )
{
    KeReleaseSpinLockFromDpcLevel(&pRWLock->SpinLock);
}

#endif  _LOCKS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\ipseceng.h ===
#define IPSEC_ISAKMP_PORT2   0x9411  // 4500 in NBO
#define IPSEC_ISAKMP_PORT   0xf401  // 500 in NBO
#define IPSEC_KERBEROS_PORT 0x5800  // 88 in NBO
#define IPSEC_LDAP_PORT     0x8501  // 389 in NBO
#define IPSEC_L2TP_PORT     0xa506

IPSEC_ACTION
IPSecHandlePacket(
    IN  PUCHAR          pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pMTU,
    OUT PVOID           *pNewData,
    IN OUT PULONG       pIpsecFlags,
    IN  UCHAR           DestType
    );

IPSEC_ACTION
IPSecSendPacket(
    IN  PUCHAR          pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pMTU,
    OUT PVOID           *pNewData,
    IN OUT PULONG       pIpsecFlags,
    OUT PIPSEC_DROP_STATUS pDropStatus,
    IN  UCHAR           DestType
    );

IPSEC_ACTION
IPSecRecvPacket(
    IN  PUCHAR          *pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pIpsecFlags,
    OUT PIPSEC_DROP_STATUS pDropStatus,
    IN  UCHAR           DestType
    );


NTSTATUS
IPSecVerifyIncomingFilterSA(IN  PUCHAR   *       pIPHeader,
    IN  PVOID           pData,
    IN PSA_TABLE_ENTRY pSA,    
    IN  UCHAR           DestType,   
    BOOLEAN             fLoopback,
    BOOLEAN             fReinject,
    IN PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    );
    
VOID
IPSecCalcHeaderOverheadFromSA(
    IN  PSA_TABLE_ENTRY pSA,
    OUT PULONG          pOverhead
    );

NTSTATUS
IPSecParsePacket(
    IN  PUCHAR      pIPHeader,
    IN  PVOID       *pData,
    OUT tSPI        *pSPI,
    OUT BOOLEAN     *bNatEncap,
    OUT IPSEC_UDP_ENCAP_CONTEXT *pNatContext
    );

PSA_TABLE_ENTRY
IPSecLookupSAInLarval(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort
    );

NTSTATUS
IPSecClassifyPacket(
    IN  PUCHAR          pHeader,
    IN  PVOID           pData,
    OUT PSA_TABLE_ENTRY *ppSA,
    OUT PSA_TABLE_ENTRY *ppNextSA,
    OUT USHORT          *pFilterFlags,
#if GPC
    IN  CLASSIFICATION_HANDLE   GpcHandle,
#endif
    IN  BOOLEAN         fOutbound,
    IN  BOOLEAN         fFWPacket,
    IN  BOOLEAN         fDoBypassCheck,
    IN BOOLEAN          fRecvReinject,
    IN BOOLEAN          fVerify,
    IN  UCHAR           DestType,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    );

VOID
IPSecSendComplete(
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           pData,
    IN  PIPSEC_SEND_COMPLETE_CONTEXT  pContext,
    IN  IP_STATUS       Status,
    OUT PVOID           *ppNewData
    );

VOID
IPSecProtocolSendComplete (
    IN  PVOID           pContext,
    IN  PNDIS_BUFFER    pMdl,
    IN  IP_STATUS       Status
    );

NTSTATUS
IPSecChkReplayWindow(
    IN  ULONG           Seq,
    IN  PSA_TABLE_ENTRY pSA,
    IN  ULONG           Index
    );


NTSTATUS
IPSecPrepareReinjectPacket(
    IN  PVOID                   pData,
    IN  PNDIS_PACKET_EXTENSION  pPktExt,
    OUT PNDIS_BUFFER        * ppHdrMdl,
    OUT PUCHAR                  * ppIPH,
    OUT PNDIS_BUFFER        * ppOptMdl,
    OUT PNDIS_BUFFER        * ppDataMdl,
    OUT PIPSEC_SEND_COMPLETE_CONTEXT * ppContext,
    OUT PULONG                  pLen
    );

NTSTATUS 
IPSecReinjectPreparedPacket(
    IN PNDIS_BUFFER pHdrMdl,
    IN PIPSEC_SEND_COMPLETE_CONTEXT pContext,
    IN ULONG len,
    IN PUCHAR  pIPHeader
    );

NTSTATUS
IPSecReinjectPacket(
    IN  PVOID                   pData,
    IN  PNDIS_PACKET_EXTENSION  pPktExt
    );

NTSTATUS
IPSecQueuePacket(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pDataBuf
    );

VOID
IPSecIPAddrToUnicodeString(
    IN  IPAddr  Addr,
    OUT PWCHAR  UCIPAddrBuffer
    );

VOID
IPSecCountToUnicodeString(
    IN  ULONG   Count,
    OUT PWCHAR  UCCountBuffer
    );

VOID
IPSecESPStatus(
    IN  UCHAR       StatusType,
    IN  IP_STATUS   StatusCode,
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  IPAddr      Src,
    IN  ULONG       Param,
    IN  PVOID       Data
    );

VOID
IPSecAHStatus(
    IN  UCHAR       StatusType,
    IN  IP_STATUS   StatusCode,
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  IPAddr      Src,
    IN  ULONG       Param,
    IN  PVOID       Data
    );

VOID
IPSecProcessPMTU(
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  tSPI        SPI,
    IN  OPERATION_E Operation,
    IN  ULONG       NewMTU
    );

IPSEC_ACTION
IPSecRcvFWPacket(
    IN  PCHAR   pIPHeader,
    IN  PVOID   pData,
    IN  UINT    DataLength,
    IN  UCHAR   DestType
    );


NTSTATUS
IPSecRekeyInboundSA(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecRekeyOutboundSA(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecPuntInboundSA(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecPuntOutboundSA(
    IN  PSA_TABLE_ENTRY pSA
    );

BOOLEAN
IPSecQueryStatus(
    IN  CLASSIFICATION_HANDLE   GpcHandle
    );

NTSTATUS IPSecDisableUdpXsum(
    IN IPRcvBuf *pData
);


NTSTATUS AddShimContext(IN PUCHAR *pIpHeader,
                        IN PVOID pData,
                        IPSEC_UDP_ENCAP_CONTEXT *pNatContext);

NTSTATUS
GetIpBufferForICMP(
    PUCHAR pucIPHeader,
    PVOID pvData,
    PUCHAR * ppucIpBuffer,
    PUCHAR * ppucStorage
    );

NTSTATUS
IPSecGetSendBuffer(
    PMDL * ppMdlChain,
    ULONG uOffset,
    ULONG uBytesNeeded,
    PVOID pvStorage,
    PULONG puLastWalkedMdlOffset,
    PUCHAR * ppucReturnBuf
    );

NTSTATUS
IPSecCopyMdlToBuffer(
    PMDL * ppMdlChain,
    ULONG uOffset,
    PVOID pvBuffer,
    ULONG uBytesToCopy,
    PULONG puLastWalkedMdlOffset,
    PULONG puBytesCopied
    );

IPSEC_ACTION IPSecProcessBoottime(IN PUCHAR pIPHeader,
                                  IN PVOID   pData,
                                  IN PNDIS_PACKET Packet,
                                  IN ULONG IpsecFlags,
                                  IN UCHAR DestType);


BOOLEAN 
IPSecIsGenericPortsProtocolOf(
    ULARGE_INTEGER uliGenericPortProtocol, 
    ULARGE_INTEGER uliSpecificPortProtocol
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\offload.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    offload.c

Abstract:

    This module contains the code that handles offload.

Author:

    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"

#ifdef RUN_WPP
#include "offload.tmh"
#endif


VOID
IPSecFillHwAddSA(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PUCHAR          Buf,
    IN  ULONG           Len
    )
/*++

Routine Description:

    Fills in the ADD_SA hw request from pSA

Arguments:

    pSA - the SA
    Buf - buffer to set info
    Len - length

Return Value:

    status of the operation

--*/
{
    POFFLOAD_IPSEC_ADD_SA           pAddSA = (POFFLOAD_IPSEC_ADD_SA)Buf;
    POFFLOAD_SECURITY_ASSOCIATION   pSAInfo;
    LONG    Index;
    ULONG   Offset = 0;

    pAddSA->NumSAs = (SHORT)pSA->sa_NumOps;
    pAddSA->SrcAddr = pSA->SA_SRC_ADDR;
    pAddSA->SrcMask = pSA->SA_SRC_MASK;
    pAddSA->DestAddr = pSA->SA_DEST_ADDR;
    pAddSA->DestMask = pSA->SA_DEST_MASK;
    pAddSA->Protocol = pSA->SA_PROTO;
    pAddSA->SrcPort = SA_SRC_PORT(pSA);
    pAddSA->DestPort = SA_DEST_PORT(pSA);

    if (pSA->sa_Flags & FLAGS_SA_OUTBOUND) {
        pAddSA->Flags |= OFFLOAD_OUTBOUND_SA;
    } else {
        pAddSA->Flags |= OFFLOAD_INBOUND_SA;
    }

    if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
        pAddSA->DestTunnelAddr = pSA->sa_TunnelAddr;
        pAddSA->SrcTunnelAddr = pSA->sa_SrcTunnelAddr;
    }

    for (Index = 0; Index < pSA->sa_NumOps; Index++) {
        pSAInfo = &pAddSA->SecAssoc[Index];

        pSAInfo->Operation = pSA->sa_Operation[Index];
        pSAInfo->SPI = pSA->sa_OtherSPIs[Index];
        pSAInfo->EXT_INT_ALGO = pSA->INT_ALGO(Index);
        pSAInfo->EXT_INT_KEYLEN = pSA->INT_KEYLEN(Index);
        pSAInfo->EXT_INT_ROUNDS = pSA->INT_ROUNDS(Index);

        pSAInfo->EXT_CONF_ALGO = pSA->CONF_ALGO(Index);
        pSAInfo->EXT_CONF_KEYLEN = pSA->CONF_KEYLEN(Index);
        pSAInfo->EXT_CONF_ROUNDS = pSA->CONF_ROUNDS(Index);

        //
        // now get the keys in
        //
        ASSERT(Len >= sizeof(OFFLOAD_IPSEC_ADD_SA) + pSA->INT_KEYLEN(Index) + pSA->CONF_KEYLEN(Index));

        RtlCopyMemory(  pAddSA->KeyMat + Offset,
                        pSA->CONF_KEY(Index),
                        pSA->CONF_KEYLEN(Index));

        RtlCopyMemory(  pAddSA->KeyMat + Offset + pSA->CONF_KEYLEN(Index),
                        pSA->INT_KEY(Index),
                        pSA->INT_KEYLEN(Index));

        Offset += pSA->INT_KEYLEN(Index) + pSA->CONF_KEYLEN(Index);
        pAddSA->KeyLen += Offset;

        IPSEC_DEBUG(LL_A, DBF_HW, ("pAddSA: %p, keylen: %lx, KeyMat: %p", pAddSA, pAddSA->KeyLen, pAddSA->KeyMat));
    }
}


NDIS_STATUS
IPSecPlumbHw(
    IN  PVOID           DestIF,
    IN  PVOID           Buf,
    IN  ULONG           Len,
    IN  NDIS_OID        Oid
    )
/*++

Routine Description:

    Plumbs the input outbound and its corresponding inbound SA
    into the hw accelerator.

Arguments:

    DestIF - the IP Interface
    Buf - buffer to set info
    Len - length

Return Value:

    status of the operation

--*/
{
#if DBG
    NTSTATUS    status;

    if (Oid == OID_TCP_TASK_IPSEC_ADD_SA) {
        IPSEC_INCREMENT(NumAddSA);
    }
    if (Oid == OID_TCP_TASK_IPSEC_DELETE_SA) {
        IPSEC_INCREMENT(NumDelSA);
    }
    if (Oid == OID_TCP_TASK_IPSEC_ADD_UDPESP_SA) {
        IPSEC_INCREMENT(NumAddEncapSA);
    }
    if (Oid == OID_TCP_TASK_IPSEC_DELETE_UDPESP_SA) {
        IPSEC_INCREMENT(NumDelEncapSA);
    }

    status = TCPIP_NDIS_REQUEST(DestIF,
                                NdisRequestSetInformation,
                                Oid,
                                Buf,
                                Len,
                                NULL);

    if (status == STATUS_SUCCESS) {
        if (Oid == OID_TCP_TASK_IPSEC_ADD_SA) {
            IPSEC_INCREMENT(NumAddSU);
        }
        if (Oid == OID_TCP_TASK_IPSEC_DELETE_SA) {
            IPSEC_INCREMENT(NumDelSU);
        }
        if (Oid == OID_TCP_TASK_IPSEC_ADD_UDPESP_SA) {
            IPSEC_INCREMENT(NumAddEncapSU);
        }
        if (Oid == OID_TCP_TASK_IPSEC_DELETE_UDPESP_SA) {
            IPSEC_INCREMENT(NumDelEncapSU);
        }
    } else {
        if (Oid == OID_TCP_TASK_IPSEC_ADD_SA) {
            IPSEC_INCREMENT(NumAddFA);
        }
        if (Oid == OID_TCP_TASK_IPSEC_DELETE_SA) {
            IPSEC_INCREMENT(NumDelFA);
        }
        if (Oid == OID_TCP_TASK_IPSEC_ADD_UDPESP_SA) {
            IPSEC_INCREMENT(NumAddEncapFA);
        }
        if (Oid == OID_TCP_TASK_IPSEC_DELETE_UDPESP_SA) {
            IPSEC_INCREMENT(NumDelEncapFA);
        }
    }

    return  status;
#else
    return TCPIP_NDIS_REQUEST(  DestIF,
                                NdisRequestSetInformation,
                                Oid,
                                Buf,
                                Len,
                                NULL);
#endif
}


NTSTATUS
IPSecSendOffload(
    IN  IPHeader UNALIGNED  *pIPHeader,
    IN  PNDIS_PACKET        Packet,
    IN  Interface           *DestIF,
    IN  PSA_TABLE_ENTRY     pSA,
    IN  PSA_TABLE_ENTRY     pNextSA,
    IN  PVOID               *ppSCContext,
    IN  BOOLEAN             *pfCryptoOnly
    )
{
    KIRQL                           kIrql;
    BOOLEAN                         fRefBumped = FALSE;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    PSA_TABLE_ENTRY                 pSaveSA = NULL;
    PIPSEC_SEND_COMPLETE_CONTEXT    pContext = NULL;
    PNDIS_IPSEC_PACKET_INFO         IPSecPktInfo = NULL;
    PNDIS_PACKET_EXTENSION          PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
    BOOL                            bTptOverTunCheckDone = FALSE;


    IPSEC_DEBUG(LL_A, DBF_HW, ("IPSecSendOffload: DestIF: %p, DestIF->Flags: %lx", DestIF, DestIF->if_IPSecOffloadFlags));

    *pfCryptoOnly = FALSE;

    //
    // See if options are supported.
    //
    if (((pIPHeader->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2) > sizeof(IPHeader) &&
        !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_V4_OPTIONS)) {
        status = STATUS_UNSUCCESSFUL;
        IPSEC_DEBUG(LL_A, DBF_HW, ("Options present - not offloading the packet. HdrLen %d",
                    ((pIPHeader->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2)));
        return (status);
    }

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    do {
        if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
            pSA->sa_IPIF == DestIF) {

            if (*ppSCContext == NULL) {
                pContext = IPSecAllocateSendCompleteCtx(IPSEC_TAG_HW);

                if (!pContext) {
                    IPSEC_DEBUG(LL_A, DBF_HW, ("Failed to alloc. SendCtx"));
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    *ppSCContext = NULL;
                    break;
                }

                IPSEC_INCREMENT(g_ipsec.NumSends);

                IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));

#if DBG
                RtlCopyMemory(pContext->Signature, "ISC5", 4);
#endif
                *ppSCContext = pContext;
            } else {
                pContext = *ppSCContext;
            }

            if (IPSecPktInfo == NULL) {
                if (IPSecPktInfo = IPSecAllocatePktInfo(IPSEC_TAG_HW_PKTINFO)) {
                    IPSecZeroMemory(IPSecPktInfo, sizeof(NDIS_IPSEC_PACKET_INFO));

                    pContext->Flags |= SCF_PKTINFO;
                    pContext->PktInfo = IPSecPktInfo;
                } else {
                    IPSEC_DEBUG(LL_A, DBF_HW, ("Failed to alloc. PktInfo"));
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }

            PktExt->NdisPacketInfo[IpSecPacketInfo] = IPSecPktInfo;

            //
            // if this is the nextOperationSA
            //
            if (fRefBumped) {
                IPSEC_DEBUG(LL_A, DBF_HW, ("Offloading... pSA: %p, NextOffloadHandle %p", pSA, pSA->sa_OffloadHandle));
                IPSecPktInfo->Transmit.NextOffloadHandle = pSA->sa_OffloadHandle;
            } else {
                IPSEC_DEBUG(LL_A, DBF_HW, ("Offloading... pSA: %p, OffloadHandle %p", pSA, pSA->sa_OffloadHandle));
                IPSecPktInfo->Transmit.OffloadHandle = pSA->sa_OffloadHandle;
            }

            *pfCryptoOnly = TRUE;

            IPSEC_DEBUG(LL_A, DBF_HW, ("Using Hw for SA->handle: %p on IF: %p IPSecPktInfo: %p *pfCryptoOnly %d", pSA->sa_OffloadHandle, DestIF, IPSecPktInfo, *pfCryptoOnly));

            status = STATUS_SUCCESS;
        } else if (!(pSA->sa_Flags & FLAGS_SA_HW_PLUMB_FAILED) && !pSA->sa_IPIF) {
            PUCHAR  outBuf;
            ULONG   outLen;
            LONG    Index;

            pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;
		
	    /* DELETE 
	    if ((SA_UDP_ENCAP_TYPE_OTHER == pSA->sa_EncapType ) ||
                (pNextSA && (SA_UDP_ENCAP_TYPE_OTHER == pNextSA->sa_EncapType ))) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }*/

            //
            // See if CryptoOnly mode is supported.
            //
            if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_CRYPTO_ONLY)) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // No need to offload soft SAs.
            //
            if (pSA->sa_Operation[0] == None) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // See if transport over tunnel mode is supported.
            //
            if (pNextSA && !bTptOverTunCheckDone) {
                bTptOverTunCheckDone = TRUE;
                ASSERT((pNextSA->sa_Flags & FLAGS_SA_TUNNEL));
                if (SA_UDP_ENCAP_TYPE_IKE ==  pNextSA->sa_EncapType ) {
                    ASSERT((SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType));
                    if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_IKE)) {
                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                }
                else if (SA_UDP_ENCAP_TYPE_OTHER == pNextSA->sa_EncapType){
                	ASSERT((SA_UDP_ENCAP_TYPE_OTHER==pSA->sa_EncapType));
                	if ( !(DestIF->if_IPSecOffloadFlags  & IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_OTHER)){
                		status=STATUS_UNSUCCESSFUL;
                		break;
                		}
                	}
                else {
                    if (SA_UDP_ENCAP_TYPE_IKE==pSA->sa_EncapType ) {
                        if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_IKE)) {
                            status = STATUS_UNSUCCESSFUL;
                            break;
                        }
                    }
                    else
                    	if (SA_UDP_ENCAP_TYPE_OTHER == pSA->sa_EncapType ) {
                        if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_OTHER)) {
                            status = STATUS_UNSUCCESSFUL;
                            break;
                        	}
                    	}
                    else {
                        if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_TUNNEL)) {
                            status = STATUS_UNSUCCESSFUL;
                            break;
                        }
                    }
                }
            }

            //
            // Tunnel required, but not supported, don't plumb.
            //
            if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
                if ((SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType) ||(SA_UDP_ENCAP_TYPE_OTHER == pSA->sa_EncapType)) {
                    ASSERT(IS_AH_SA(pSA) == 0);
                    ASSERT(IS_ESP_SA(pSA));
                    ASSERT(pSA->sa_NumOps == 1);
                    if ((!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TUNNEL_UDPESP_IKE) && (SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType ))
                    	||(!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TUNNEL_UDPESP_OTHER) && (SA_UDP_ENCAP_TYPE_OTHER == pSA->sa_EncapType)))
                    	{
                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                }
                else {
                    if ((IS_AH_SA(pSA) &&
                        !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_TUNNEL)) ||
                        (IS_ESP_SA(pSA) &&
                        !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_TUNNEL))) {
                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                }
            }
            else {
                if ((SA_UDP_ENCAP_TYPE_IKE==pSA->sa_EncapType) ||(SA_UDP_ENCAP_TYPE_OTHER==pSA->sa_EncapType)) {
                    ASSERT(IS_AH_SA(pSA) == 0);
                    ASSERT(IS_ESP_SA(pSA));
                    ASSERT(pSA->sa_NumOps == 1);
                    if (((!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_IKE)) && (SA_UDP_ENCAP_TYPE_IKE==pSA->sa_EncapType))
                    	||((!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_OTHER)) && (SA_UDP_ENCAP_TYPE_OTHER==pSA->sa_EncapType))){
                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                }
                else {
                    if ((IS_AH_SA(pSA) &&
                        !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_TPT)) ||
                        (IS_ESP_SA(pSA) &&
                        !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_TPT))) {
                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                }
            }

            //
            // AH + ESP required, but not supported, don't plumb.
            //
            if (pSA->sa_NumOps > 1 &&
                !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_ESP)) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Check XMT capabilities.
            //
            if ((IS_AH_SA(pSA) &&
                !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_XMT)) ||
                (IS_ESP_SA(pSA) &&
                !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_XMT))) {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            if ((SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType) ||(SA_UDP_ENCAP_TYPE_OTHER==pSA->sa_EncapType )) {
                outLen = sizeof(OFFLOAD_IPSEC_ADD_UDPESP_SA);
            }
            else {
                outLen = sizeof(OFFLOAD_IPSEC_ADD_SA);
            }

            for (Index = 0; Index < pSA->sa_NumOps; Index++) {
                //
                // Check offload capability bits with those in the SA.
                //
                if ((pSA->INT_ALGO(Index) == IPSEC_AH_MD5) &&
                    (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_MD5)) ||
                    ((pSA->INT_ALGO(Index) == IPSEC_AH_SHA) &&
                    (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_SHA_1))) ||
                    ((pSA->CONF_ALGO(Index) == IPSEC_ESP_NONE) &&
                    (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_NONE))) ||
                    ((pSA->CONF_ALGO(Index) == IPSEC_ESP_DES) &&
                    (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_DES))) ||
                    ((pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES) &&
                    (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_3_DES)))) {
                    status = STATUS_UNSUCCESSFUL;
                    goto out;
                }

                outLen += pSA->INT_KEYLEN(Index) + pSA->CONF_KEYLEN(Index);
            }

            //
            // This SA can be offloaded.
            //
            pSA->sa_Flags |= FLAGS_SA_OFFLOADABLE;

            IPSEC_DEBUG(LL_A, DBF_HW, ("outLen: %lx", outLen));

            outBuf = IPSecAllocateMemory(outLen, IPSEC_TAG_HW_ADDSA);

            if (outBuf) {

                IPSecZeroMemory(outBuf, outLen);

                if ((SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType) || (SA_UDP_ENCAP_TYPE_OTHER == pSA->sa_EncapType )){
                    IPSecFillHwAddEncapSa(pSA, NULL, outBuf, outLen);
                }
                else {
                    IPSecFillHwAddSA(pSA, outBuf, outLen);
                }

                //
                // Bump the SA reference count to make sure they won't 
                // go away during the processing of the work item.
                //
                IPSecRefSA(pSA);

                //
                // Plumb the SA by scheduling a work item; the SA will
                // not be used for offload until plumbing succeeds.
                //
                IPSecBufferPlumbSA( DestIF,
                                    pSA,
                                    NULL,
                                    outBuf,
                                    outLen);

                //
                // Return failure here so the caller does it in software.
                //
                status = STATUS_UNSUCCESSFUL;
                break;
            } else {
                IPSEC_DEBUG(LL_A, DBF_HW, ("Memory: Failed to plumb outboundSA: %p on IF: %p", pSA, DestIF));
                status = STATUS_UNSUCCESSFUL;
                break;
            }
        } else {
            status = STATUS_UNSUCCESSFUL;
            break;
        }

        if (pNextSA && !fRefBumped) {
            IPSEC_DEBUG(LL_A, DBF_HW, ("RefBumped on SA: %p", pSA));
            pSaveSA = pSA;
            pSA = pNextSA;
            fRefBumped = TRUE;
        } else {
            break;
        }
    } while (TRUE);

out:
    if (status == STATUS_SUCCESS && (*pfCryptoOnly)) {
        ASSERT(pContext);
        ASSERT(pContext->Flags & SCF_PKTINFO);

        if (fRefBumped) {
            IPSecRefSA(pSaveSA);
            IPSecRefSA(pNextSA);
            IPSEC_INCREMENT(pSaveSA->sa_NumSends);
            IPSEC_INCREMENT(pNextSA->sa_NumSends);
            pContext->pSA = pSaveSA;
            pContext->pNextSA = pNextSA;
        } else {
            IPSecRefSA(pSA);
            IPSEC_INCREMENT(pSA->sa_NumSends);
            pContext->pSA = pSA;
        }
    } else {
        if (IPSecPktInfo) {
            ASSERT(pContext);
            ASSERT(pContext->Flags & SCF_PKTINFO);

            IPSecFreePktInfo(pContext->PktInfo);

            pContext->Flags &= ~SCF_PKTINFO;
            pContext->PktInfo = NULL;

            PktExt->NdisPacketInfo[IpSecPacketInfo] = NULL;
        }

        status = STATUS_UNSUCCESSFUL;
        *pfCryptoOnly = FALSE;
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


NTSTATUS
IPSecRecvOffload(
    IN  IPHeader UNALIGNED  *pIPHeader,
    IN  Interface           *DestIF,
    IN  PSA_TABLE_ENTRY     pSA
    )
{
    KIRQL                           kIrql;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    PPARSER_IFENTRY                 pParserIfEntry = NULL;


    IPSEC_DEBUG(LL_A, DBF_HW, ("IPSecRecvOffload: DestIF: %p, DestIF->Flags: %lx", DestIF, DestIF->if_IPSecOffloadFlags));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    // Make sure SA is fully associated
    if (!pSA->sa_AssociatedSA) {
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    if (!(pSA->sa_Flags & FLAGS_SA_HW_PLUMB_FAILED) &&
        !(pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
        !pSA->sa_IPIF) {
        PUCHAR  inBuf;
        ULONG   inLen;
        LONG    Index;

        pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;

	/* DELETE
	if (SA_UDP_ENCAP_TYPE_OTHER == pSA->sa_EncapType){
		status = STATUS_UNSUCCESSFUL;
            goto out;
        }
	*/	

        //
        // See if CryptoOnly mode is supported.
        //
        if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_CRYPTO_ONLY)) {
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        //
        // No need to offload soft SAs.
        //
        if (pSA->sa_Operation[0] == None) {
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        //
        // Tunnel required, but not supported, don't plumb.
        //
        if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
            if (SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType) {
                ASSERT(IS_AH_SA(pSA) == 0);
                ASSERT(IS_ESP_SA(pSA));
                ASSERT(pSA->sa_NumOps == 1);
                if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TUNNEL_UDPESP_IKE)) {
                    status = STATUS_UNSUCCESSFUL;
                    goto out;
                }
            }
            else
            	if (SA_UDP_ENCAP_TYPE_OTHER== pSA->sa_EncapType) {
                ASSERT(IS_AH_SA(pSA) == 0);
                ASSERT(IS_ESP_SA(pSA));
                ASSERT(pSA->sa_NumOps == 1);
                if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TUNNEL_UDPESP_OTHER )) {
                    status = STATUS_UNSUCCESSFUL;
                    goto out;
                }
            }
            else {
                if ((IS_AH_SA(pSA) &&
                    !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_TUNNEL)) ||
                    (IS_ESP_SA(pSA) &&
                    !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_TUNNEL))) {
                    status = STATUS_UNSUCCESSFUL;
                    goto out;
                }
            }
        }
        else {
            if (SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType) {
                ASSERT(IS_AH_SA(pSA) == 0);
                ASSERT(IS_ESP_SA(pSA));
                ASSERT(pSA->sa_NumOps == 1);
                if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_IKE)) {
                    status = STATUS_UNSUCCESSFUL;
                    goto out;
                }
            }
            else
            	if (SA_UDP_ENCAP_TYPE_OTHER == pSA->sa_EncapType) {
                ASSERT(IS_AH_SA(pSA) == 0);
                ASSERT(IS_ESP_SA(pSA));
                ASSERT(pSA->sa_NumOps == 1);
                if (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_OTHER)) {
                    status = STATUS_UNSUCCESSFUL;
                    goto out;
                }
            }
            else {
                if ((IS_AH_SA(pSA) &&
                    !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_TPT)) ||
                    (IS_ESP_SA(pSA) &&
                    !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_TPT))) {
                    status = STATUS_UNSUCCESSFUL;
                    goto out;
                }
            }
        }

        //
        // AH + ESP required, but not supported, don't plumb.
        //
        if (pSA->sa_NumOps > 1 &&
            !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_ESP)) {
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        //
        // Check RCV capabilities.
        //
        if ((IS_AH_SA(pSA) &&
            !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_RCV)) ||
            (IS_ESP_SA(pSA) &&
            !(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_RCV))) {
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        if ((SA_UDP_ENCAP_TYPE_IKE==pSA->sa_EncapType) || (SA_UDP_ENCAP_TYPE_OTHER==pSA->sa_EncapType)){
            inLen = sizeof(OFFLOAD_IPSEC_ADD_UDPESP_SA);
        }
        else {
            inLen = sizeof(OFFLOAD_IPSEC_ADD_SA);
        }

        for (Index = 0; Index < pSA->sa_NumOps; Index++) {
            //
            // Check offload capability bits with those in the SA
            //
            if ((pSA->INT_ALGO(Index) == IPSEC_AH_MD5) &&
                (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_MD5)) ||
                ((pSA->INT_ALGO(Index) == IPSEC_AH_SHA) &&
                (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_SHA_1))) ||
                ((pSA->CONF_ALGO(Index) == IPSEC_ESP_NONE) &&
                (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_NONE))) ||
                ((pSA->CONF_ALGO(Index) == IPSEC_ESP_DES) &&
                (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_DES))) ||
                ((pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES) &&
                (!(DestIF->if_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_3_DES)))) {
                status = STATUS_UNSUCCESSFUL;
                goto out;
            }

            inLen += pSA->INT_KEYLEN(Index) + pSA->CONF_KEYLEN(Index);
        }

        IPSEC_DEBUG(LL_A, DBF_HW, ("inLen: %lx", inLen));

        inBuf = IPSecAllocateMemory(inLen, IPSEC_TAG_HW_ADDSA);

        if (inBuf) {

            IPSecZeroMemory(inBuf, inLen);

            if ((SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType) || (SA_UDP_ENCAP_TYPE_OTHER==pSA->sa_EncapType)){
                status = GetParserEntry(pSA, DestIF, &pParserIfEntry);
                if (!NT_SUCCESS(status)) {
                    IPSecFreeMemory(inBuf);
                    status = STATUS_UNSUCCESSFUL;
                    goto out;
                }
                IPSecFillHwAddEncapSa(pSA, pParserIfEntry, inBuf, inLen);
            }
            else {
                IPSecFillHwAddSA(pSA, inBuf, inLen);
            }

            //
            // Bump the SA reference count to make sure they won't 
            // go away during the processing of the work item.
            //
            IPSecRefSA(pSA);

            //
            // Plumb the SA by scheduling a work item; the SA will
            // not be used for offload until plumbing succeeds.
            //
            status = IPSecBufferPlumbSA(DestIF,
                                        pSA,
                                        pParserIfEntry,
                                        inBuf,
                                        inLen);

            //
            // Return failure here so the caller does it in software.
            //
            status = STATUS_UNSUCCESSFUL;
            goto out;
        } else {
            IPSEC_DEBUG(LL_A, DBF_HW, ("Memory: Failed to plumb inboundSA: %p on IF: %p", pSA, DestIF));
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }
    }

out:
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


NTSTATUS
IPSecDelHWSA(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    NTSTATUS    status = STATUS_SUCCESS;
    OFFLOAD_IPSEC_DELETE_UDPESP_SA  OffldDelUdpEspSa;
    KIRQL                           kIrql = 0;

    ASSERT(pSA->sa_Flags & FLAGS_SA_HW_PLUMBED);

    pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
    pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;

    if ((pSA->sa_Flags & FLAGS_SA_OUTBOUND) &&
        IPSEC_GET_VALUE(pSA->sa_NumSends) > 0) {
        pSA->sa_Flags |= FLAGS_SA_HW_DELETE_SA;
        return  STATUS_PENDING;
    }

    pSA->sa_Flags &= ~FLAGS_SA_HW_DELETE_SA;
    pSA->sa_Flags |= FLAGS_SA_HW_DELETE_QUEUED;

    ASSERT(pSA->sa_IPIF);

    if (pSA->sa_IPIF) {
    	/* DELETE
    	 ASSERT((SA_UDP_ENCAP_TYPE_OTHER!=pSA->sa_EncapType));
    	 */
        if ((SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType ) || (SA_UDP_ENCAP_TYPE_OTHER == pSA->sa_EncapType)){

            OffldDelUdpEspSa.OffloadHandle = pSA->sa_OffloadHandle;

            if (!(pSA->sa_Flags & FLAGS_SA_OUTBOUND)) {
                AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);
                OffldDelUdpEspSa.EncapTypeEntryOffldHandle = UploadParserEntryAndGetHandle(pSA, pSA->sa_IPIF);
                ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
            } else {
                OffldDelUdpEspSa.EncapTypeEntryOffldHandle = NULL;
            }

            status = IPSecPlumbHw(  pSA->sa_IPIF,
                                    &OffldDelUdpEspSa,
                                    sizeof(OFFLOAD_IPSEC_DELETE_UDPESP_SA),
                                    OID_TCP_TASK_IPSEC_DELETE_UDPESP_SA);

        } else {
            status = IPSecPlumbHw(  pSA->sa_IPIF,
                                    &pSA->sa_OffloadHandle,
                                    sizeof(OFFLOAD_IPSEC_DELETE_SA),
                                    OID_TCP_TASK_IPSEC_DELETE_SA);
        }

        IPSEC_DEBUG(LL_A, DBF_HWAPI, ("DelHWSA %s: %p, handle: %p, status: %lx",
                    (pSA->sa_Flags & FLAGS_SA_OUTBOUND)? "outbound": "inbound",
                    pSA,
                    pSA->sa_OffloadHandle,
                    status));

        IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

        IPSecDerefSA(pSA);
    }

    return status;
}


NTSTATUS
IPSecDelHWSAAtDpc(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    ASSERT(pSA->sa_Flags & (FLAGS_SA_HW_PLUMBED | FLAGS_SA_HW_DELETE_SA));

    pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
    pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;

    if ((pSA->sa_Flags & FLAGS_SA_OUTBOUND) &&
        IPSEC_GET_VALUE(pSA->sa_NumSends) > 0) {
        pSA->sa_Flags |= FLAGS_SA_HW_DELETE_SA;
        return  STATUS_PENDING;
    }

    pSA->sa_Flags &= ~FLAGS_SA_HW_DELETE_SA;
    pSA->sa_Flags |= FLAGS_SA_HW_DELETE_QUEUED;

    ASSERT(pSA->sa_IPIF);

    ExInitializeWorkItem(   &pSA->sa_QueueItem,
                            IPSecProcessDeleteSA,
                            (PVOID)pSA);

    ExQueueWorkItem(&pSA->sa_QueueItem, DelayedWorkQueue);
    
    IPSEC_INCREMENT(g_ipsec.NumWorkers);

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecBufferPlumbSA(
    IN  Interface       *DestIF,
    IN  PSA_TABLE_ENTRY pSA,
    PPARSER_IFENTRY     pParserIfEntry,
    IN  PUCHAR          Buf,
    IN  ULONG           Len
    )
{
    PIPSEC_PLUMB_SA pPlumbSA;

    pPlumbSA = IPSecAllocateMemory(sizeof(IPSEC_PLUMB_SA), IPSEC_TAG_HW_PLUMB);
    if (pPlumbSA == NULL) {
        IPSecFreeMemory(Buf);

        if (pSA) {
            IPSecDerefSA(pSA);
        }

        if (NULL != pParserIfEntry) {
            DerefParserEntry (pParserIfEntry);
        }
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    pPlumbSA->pSA = pSA;
    pPlumbSA->pParserIfEntry = pParserIfEntry;
    pPlumbSA->DestIF = DestIF;
    pPlumbSA->Buf = Buf;
    pPlumbSA->Len = Len;

    ExInitializeWorkItem(   &pPlumbSA->PlumbQueueItem,
                            IPSecProcessPlumbSA,
                            (PVOID)pPlumbSA);

    ExQueueWorkItem(&pPlumbSA->PlumbQueueItem, DelayedWorkQueue);
    
    IPSEC_INCREMENT(g_ipsec.NumWorkers);

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecProcessPlumbSA(
    IN  PVOID   Context
    )
{
    PIPSEC_PLUMB_SA pPlumbSA = (PIPSEC_PLUMB_SA)Context;
    NTSTATUS        status = STATUS_SUCCESS;
    KIRQL           kIrql;
    Interface       *DestIF = pPlumbSA->DestIF;
    PSA_TABLE_ENTRY pSA = pPlumbSA->pSA;
    PUCHAR          Buf = pPlumbSA->Buf;
    ULONG           Len = pPlumbSA->Len;
    PPARSER_IFENTRY pParserIfEntry = pPlumbSA->pParserIfEntry;
    NDIS_OID        Oid = OID_TCP_TASK_IPSEC_ADD_SA;

    //
    // Plumb this SA into the hw if acceleration is enabled
    // on this card and it has not been plumbed already.
    //
    if (pSA) {
        IPSEC_DEBUG(LL_A, DBF_HW, ("About to plumb outbound"));
	/* Delete
        ASSERT(SA_UDP_ENCAP_TYPE_OTHER != pSA->sa_EncapType);
        */
        if ((SA_UDP_ENCAP_TYPE_IKE== pSA->sa_EncapType) || (SA_UDP_ENCAP_TYPE_OTHER== pSA->sa_EncapType)){
            Oid = OID_TCP_TASK_IPSEC_ADD_UDPESP_SA;
        }

        status = IPSecPlumbHw(  DestIF,
                                Buf,
                                Len,
                                Oid);

        IPSEC_DEBUG(LL_A, DBF_HWAPI, ("AddHWSA %s: %p, handle: %p, status: %lx",
                    (pSA->sa_Flags & FLAGS_SA_OUTBOUND)? "outbound": "inbound",
                    pSA,
                    ((POFFLOAD_IPSEC_ADD_SA)Buf)->OffloadHandle,
                    status));

        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        pSA->sa_IPIF = DestIF;

        if (status != STATUS_SUCCESS) {
            IPSEC_DEBUG(LL_A, DBF_HW, ("Failed to plumb SA: %p on IF: %p, status: %lx", pSA, DestIF, status));
            pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;
            IPSecDerefSA(pSA);
            if (NULL != pParserIfEntry) {
                DerefParserEntry(pParserIfEntry);
            }
        } else {
        	/* DELETE
            ASSERT(SA_UDP_ENCAP_TYPE_OTHER != pSA->sa_EncapType);
            */
            if ((SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType) || (SA_UDP_ENCAP_TYPE_OTHER == pSA->sa_EncapType)){

                pSA->sa_OffloadHandle = ((POFFLOAD_IPSEC_ADD_UDPESP_SA)Buf)->OffloadHandle;
                if (NULL != pParserIfEntry) {
                    pParserIfEntry->hParserIfOffload = ((POFFLOAD_IPSEC_ADD_UDPESP_SA)Buf)->EncapTypeEntryOffldHandle;
                    ASSERT (pParserIfEntry->hParserIfOffload != NULL);
                }

            } else {
                pSA->sa_OffloadHandle = ((POFFLOAD_IPSEC_ADD_SA)Buf)->OffloadHandle;
            }


            IPSEC_DEBUG(LL_A, DBF_HW, ("Success plumb SA: %p, pSA->sa_OffloadHandle %p", pSA, pSA->sa_OffloadHandle));

            pSA->sa_Flags |= FLAGS_SA_HW_PLUMBED;
            pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMB_FAILED;

            IPSEC_INC_STATISTIC(dwNumOffloadedSAs);
        }

        if (status == STATUS_SUCCESS &&
            !(pSA->sa_State == STATE_SA_ACTIVE &&
             (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) &&
             pSA->sa_AssociatedSA)) {
            //
            // SA got deleted before we plumb, call DelHWSA now since
            // HW_PLUMBED wasn't set when the SA was deleted.
            //
            IPSecDelHWSAAtDpc(pSA);
        }

        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
    }

    IPSecFreeMemory(Buf);
    IPSecFreeMemory(pPlumbSA);

    IPSEC_DECREMENT(g_ipsec.NumWorkers);

    return status;
}


NTSTATUS
IPSecProcessDeleteSA(
    IN  PVOID   Context
    )
{
    PSA_TABLE_ENTRY pSA = (PSA_TABLE_ENTRY)Context;
    NTSTATUS        status;
    OFFLOAD_IPSEC_DELETE_UDPESP_SA  OffldDelUdpEspSa;
    KIRQL                           kIrql = 0;

    ASSERT(IPSEC_GET_VALUE(pSA->sa_NumSends) == 0);
   /* DELETE
    ASSERT(SA_UDP_ENCAP_TYPE_OTHER != pSA->sa_EncapType);
    */

    if ((SA_UDP_ENCAP_TYPE_IKE == pSA->sa_EncapType) || (SA_UDP_ENCAP_TYPE_OTHER ==pSA->sa_EncapType)) {

        OffldDelUdpEspSa.OffloadHandle = pSA->sa_OffloadHandle;

        if (!(pSA->sa_Flags & FLAGS_SA_OUTBOUND)) {
            AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);
            OffldDelUdpEspSa.EncapTypeEntryOffldHandle = UploadParserEntryAndGetHandle(pSA, pSA->sa_IPIF);
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
        } else {
            OffldDelUdpEspSa.EncapTypeEntryOffldHandle = NULL;
        }

        status = IPSecPlumbHw(  pSA->sa_IPIF,
                                &OffldDelUdpEspSa,
                                sizeof(OFFLOAD_IPSEC_DELETE_UDPESP_SA),
                                OID_TCP_TASK_IPSEC_DELETE_UDPESP_SA);

    } else {

        status = IPSecPlumbHw(  pSA->sa_IPIF,
                                &pSA->sa_OffloadHandle,
                                sizeof(OFFLOAD_IPSEC_DELETE_SA),
                                OID_TCP_TASK_IPSEC_DELETE_SA);

    }

    IPSEC_DEBUG(LL_A, DBF_HWAPI, ("ProcessDeleteSA %s: %p, handle: %p, status: %lx",
                (pSA->sa_Flags & FLAGS_SA_OUTBOUND)? "outbound": "inbound",
                pSA,
                pSA->sa_OffloadHandle,
                status));

    IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

    IPSecDerefSA(pSA);

    IPSEC_DECREMENT(g_ipsec.NumWorkers);

    return status;
}


NTSTATUS
IPSecNdisStatus(
    IN  PVOID       IPContext,
    IN  UINT        Status
    )
/*++

Routine Description:

    Notify Interface has a NDIS status change.

Arguments:

    IPContext   - This is the Interface notified of status change.

Return Value:

--*/
{
    IPSEC_DEBUG(LL_A, DBF_HWAPI, ("IPSecNdisStatus %lx called for interface %p", Status, IPContext));

    switch (Status) {
        case NDIS_STATUS_NETWORK_UNREACHABLE:
            IPSecDeleteIF(IPContext);
            break;

        case NDIS_STATUS_RESET_START:
            IPSecResetStart(IPContext);
            break;

        case NDIS_STATUS_RESET_END:
            IPSecResetEnd(IPContext);
            break;

        case NDIS_STATUS_INTERFACE_UP:
            IPSecWakeUp(IPContext);
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    return  STATUS_SUCCESS;
}


VOID
IPSecDeleteIF(
    IN  PVOID       IPContext
    )
/*++

Routine Description:

    Notify Interface is deleted so need to clean up SA's that are offloaded
    on the deleted interface.

Arguments:

    IPContext   - This is the Interface being deleted.

Return Value:

--*/
{
    Interface       *DestIF = (Interface *)IPContext;
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(LL_A, DBF_HWAPI, ("IPSecDeleteIF called for interface %p", DestIF));

    //
    // Go through all SA's and unmark the offload bits.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                        (DestIF == pSA->sa_IPIF)) {

                        pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
                        pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;
                        pSA->sa_Flags &= ~FLAGS_SA_HW_DELETE_SA;

                        IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

#if DBG
                        NumReset++;
#endif

                        IPSecDerefSA(pSA);
                    }
                }
            }
        }
    }

    FlushParserEntriesForInterface(DestIF);

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


VOID
IPSecResetStart(
    IN  PVOID       IPContext
    )
/*++

Routine Description:

    Notify Interface is being reset.

Arguments:

    IPContext   - This is the Interface being reset.

Return Value:

--*/
{
    Interface       *DestIF = (Interface *)IPContext;
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(LL_A, DBF_HWAPI, ("IPSecResetStart called for interface %p", DestIF));

    //
    // Go through all SA's and unmark the offload bits.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                        (DestIF == pSA->sa_IPIF)) {

                        pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
                        pSA->sa_Flags |= FLAGS_SA_HW_PLUMB_FAILED;
                        pSA->sa_Flags &= ~FLAGS_SA_HW_DELETE_SA;
                        pSA->sa_Flags |= FLAGS_SA_HW_RESET;

                        IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

#if DBG
                        NumReset++;
#endif

                        IPSecDerefSA(pSA);
                    }
                }
            }
        }
    }

    IPSecNumResets++;

    FlushParserEntriesForInterface(DestIF);

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


VOID
IPSecResetEnd(
    IN  PVOID       IPContext
    )
/*++

Routine Description:

    Notify Interface reset is completed.

Arguments:

    IPContext   - This is the Interface being reset.

Return Value:

--*/
{
    Interface       *DestIF = (Interface *)IPContext;
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(LL_A, DBF_HWAPI, ("IPSecResetEnd called for interface %p", DestIF));

    //
    // Go through all SA's and unmark the offload bits.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMB_FAILED) &&
                        !(pSA->sa_Flags & FLAGS_SA_HW_DELETE_QUEUED) &&
                        (DestIF == pSA->sa_IPIF)) {

                        pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMB_FAILED;
                        pSA->sa_IPIF = NULL;
                    }
                }
            }
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


VOID
IPSecWakeUp(
    IN  PVOID       IPContext
    )
/*++

Routine Description:

    Notify Interface has waken up from hibernate.

Arguments:

    IPContext   - This is the Interface that wakes up.

Return Value:

--*/
{
    Interface       *DestIF = (Interface *)IPContext;
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(LL_A, DBF_HWAPI, ("IPSecWakeUp called for interface %p", DestIF));

    //
    // Go through all SA's and unmark the offload bits.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                        (DestIF == pSA->sa_IPIF)) {

                        pSA->sa_Flags &= ~FLAGS_SA_HW_PLUMBED;
                        pSA->sa_IPIF = NULL;
                        pSA->sa_Flags |= FLAGS_SA_HIBERNATED;

                        IPSEC_DEC_STATISTIC(dwNumOffloadedSAs);

                        IPSecDerefSA(pSA);
                    }
                }
            }
        }
    }

    FlushParserEntriesForInterface(DestIF);

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


VOID
IPSecBufferOffloadEvent(
    IN  IPHeader UNALIGNED      *pIPH,
    IN  PNDIS_IPSEC_PACKET_INFO IPSecPktInfo
    )
/*++

Routine Description:

    Log an event for offload failures.

Arguments:

    pIPH            - The IP header of the problem packet.
    IPSecPktInfo    - The per-packet IPSec offload info.

Return Value:

    None

--*/
{
    switch (IPSecPktInfo->Receive.CryptoStatus) {
        case CRYPTO_TRANSPORT_AH_AUTH_FAILED:
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                3,
                                TRUE);
            break;

        case CRYPTO_TRANSPORT_ESP_AUTH_FAILED:
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                4,
                                TRUE);
            break;

        case CRYPTO_TUNNEL_AH_AUTH_FAILED:
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                5,
                                TRUE);
            break;

        case CRYPTO_TUNNEL_ESP_AUTH_FAILED:
            IPSEC_INC_STATISTIC(dwNumPacketsNotAuthenticated);
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_AUTH_FAILURE,
                                6,
                                TRUE);
            break;

        case CRYPTO_INVALID_PACKET_SYNTAX:
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_BAD_PACKET_SYNTAX,
                                1,
                                TRUE);
            break;

        case CRYPTO_INVALID_PROTOCOL:
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_BAD_PROTOCOL_RECEIVED,
                                3,
                                TRUE);
            break;

        case CRYPTO_GENERIC_ERROR:
        default:
            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_GENERIC_FAILURE,
                                1,
                                TRUE);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\precomp.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompilation header file for IPSEC

Author:

    ChunYe

Revision History:

--*/

#include <ntosp.h>

#include <tcpipbase.h>

#if GPC
#include <gpcifc.h>
#endif

#include <ipfilter.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <llipif.h>
#include <ffp.h>
#include <ipinit.h>
#include <ipdef.h>
#include <ntddtcp.h>

#if FIPS
#include <fipsapi.h>
#endif

#include "windef.h"
#include <zwapi.h>
#include "align.h"

#include <des.h>
#include <md5.h>
#include <modes.h>
#include <ntddksec.h>
#include <randlib.h>
#include <rc4.h>
#include <sha.h>
#include <tripldes.h>



#include "ipsec.h"
#include "debug.h"
#include "timer.h"
#include "locks.h"
#include "globals.h"
#include "ah.h"
#include "esp.h"
#include "externs.h"
#include "ahxforms.h"
#include "filter.h"
#include "acquire.h"
#include "intirspn.h"
#include "driver.h"
#include "saapi.h"
#include "ipseceng.h"
#include "gpc.h"
#include "offload.h"
#include "encap-hw.h"
#include "hughes.h"
#include "macros.h"
#include "iperrs.h"
#include "ipsecshr.h"
#include "NsIpsec.h"


#define BAIL_ON_NTSTATUS_ERROR(ntStatus) \
    if (!NT_SUCCESS(ntStatus)) {         \
        goto error;                      \
    }

#define BAIL_ON_LOCK_NTSTATUS_ERROR(ntStatus) \
    if (!NT_SUCCESS(ntStatus)) {              \
        goto lock;                            \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\ipsecwpp.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ipsecwpp.h

Abstract:

    This file contains definitions included for WPP tracing support in the
    ipsec driver.

Author:

    pmay 4-April-2002

Environment:

    Kernel mode

Revision History:

--*/

#undef offsetof
#include <evntrace.h>
#include <stdarg.h>

#define LL_A 0x1

#define IpSecTraceLevelDefine \
    WPP_DEFINE_BIT( DBF_LOAD )      \
    WPP_DEFINE_BIT( DBF_AH )        \
    WPP_DEFINE_BIT( DBF_IOCTL )     \
    WPP_DEFINE_BIT( DBF_HUGHES )    \
    WPP_DEFINE_BIT( DBF_ESP )       \
    WPP_DEFINE_BIT( DBF_AHEX )      \
    WPP_DEFINE_BIT( DBF_PATTERN )   \
    WPP_DEFINE_BIT( DBF_SEND )      \
    WPP_DEFINE_BIT( DBF_PARSE )     \
    WPP_DEFINE_BIT( DBF_PMTU )      \
    WPP_DEFINE_BIT( DBF_ACQUIRE )   \
    WPP_DEFINE_BIT( DBF_HASH )      \
    WPP_DEFINE_BIT( DBF_CLEARTEXT ) \
    WPP_DEFINE_BIT( DBF_TIMER )     \
    WPP_DEFINE_BIT( DBF_REF )       \
    WPP_DEFINE_BIT( DBF_SA )        \
    WPP_DEFINE_BIT( DBF_ALL )       \
    WPP_DEFINE_BIT( DBF_POOL )      \
    WPP_DEFINE_BIT( DBF_TUNNEL )    \
    WPP_DEFINE_BIT( DBF_HW )        \
    WPP_DEFINE_BIT( DBF_COMP )      \
    WPP_DEFINE_BIT( DBF_SAAPI )     \
    WPP_DEFINE_BIT( DBF_CACHE )     \
    WPP_DEFINE_BIT( DBF_TRANS )     \
    WPP_DEFINE_BIT( DBF_MDL )       \
    WPP_DEFINE_BIT( DBF_REKEY )     \
    WPP_DEFINE_BIT( DBF_GENHASH )   \
    WPP_DEFINE_BIT( DBF_HWAPI )     \
    WPP_DEFINE_BIT( DBF_GPC )       \
    WPP_DEFINE_BIT( DBF_NATSHIM )   \
    WPP_DEFINE_BIT(DBF_BOOTTIME)  \

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(IpSecTrace, (6537b295, 83c9, 4811, b7fe, e7dbf2f22cec), \
        IpSecTraceLevelDefine                                                       \
      )

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)

NTKERNELAPI
NTSTATUS
WmiTraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN ...
    );

NTKERNELAPI
NTSTATUS
WmiTraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN va_list      MessageArgList
    );

typedef enum _TRACE_INFORMATION_CLASS {
    TraceIdClass,
    TraceHandleClass,
    TraceEnableFlagsClass,
    TraceEnableLevelClass,
    GlobalLoggerHandleClass,
    EventLoggerHandleClass,
    AllLoggerHandlesClass,
    TraceHandleByNameClass
} TRACE_INFORMATION_CLASS;

NTKERNELAPI
NTSTATUS
WmiQueryTraceInformation(
    IN TRACE_INFORMATION_CLASS TraceInformationClass,
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength OPTIONAL,
    IN PVOID Buffer OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\ipsec.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    ipsec.c

Abstract:

    This module contains the code that handles incoming/outgoing packets.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include    "precomp.h"

#ifdef RUN_WPP
#include "ipsec.tmh"
#endif

IPSEC_ACTION
IPSecHandlePacket(
    IN  PUCHAR          pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pMTU,
    OUT PVOID           *pNewData,
    IN OUT PULONG       pIpsecFlags,
    IN  UCHAR           DestType
    )
/*++

Routine Description:

    Called by the Filter Driver to submit a packet for IPSEC processing.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header. On the send side, this is an MDL chain
            On the recv side this is an IPRcvBuf pointer.

    IPContext - contains the destination interface.

    pExtraBytes - IPSEC header expansion value; on coming in, it contains the amount of ipsec
            header space that can fit into the MTU. so, if MTU is 1400, say, and the
            datasize + option size is 1390, this contains 10, meaning that upto
            10 bytes of IPSEC expansion is allowed. This lets IPSEC know when a packet
            would be fragmented, so it can do the right thing on send complete.

    pMTU - passes in the link MTU on send path.

    pNewData - if packet modified, this points to the new data.

    IpsecFlags - flags for SrcRoute, Incoming, Forward and Lookback.

Return Value:

    eFORWARD
    eDROP
    eABSORB

--*/
{
    IPSEC_ACTION    eAction;
    IPSEC_DROP_STATUS DropStatus;
    PIPSEC_DROP_STATUS pDropStatus=NULL;

    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Entering IPSecHandlePacket"));

#if DBG
    {
        IPHeader UNALIGNED  *pIPH;

        pIPH = (IPHeader UNALIGNED *)pIPHeader;
        if ((DebugSrc || DebugDst || DebugPro) &&
            (!DebugSrc || pIPH->iph_src == DebugSrc) &&
            (!DebugDst || pIPH->iph_dest == DebugDst) &&
            (!DebugPro || pIPH->iph_protocol == DebugPro)) {
            DbgPrint("Packet from %lx to %lx with protocol %lx length %lx id %lx",
                    pIPH->iph_src,
                    pIPH->iph_dest,
                    pIPH->iph_protocol,
                    NET_SHORT(pIPH->iph_length),
                    NET_SHORT(pIPH->iph_id));
            if (DebugPkt) {
                DbgBreakPoint();
            }
        }
    }
#endif
    
    
    //
    // Drop all packets if PA sets us so or if the driver is inactive.
    //
    if ( IPSEC_DRIVER_IS_INACTIVE()) {
        eAction=eDROP;
        goto out;
    }

    //
    // Bypass all packets if PA sets us so or no filters are plumbed or the
    // packet is broadcast.  If multicast filter present, process all multicast
    // Once we support any-any tunnels, this check will need to be smarter
    //
    if (IS_DRIVER_BYPASS() || 
        (IS_BCAST_DEST(DestType) && !IPSEC_MANDBCAST_PROCESS())) {
        *pExtraBytes = 0;
        *pMTU = 0;
        eAction= eFORWARD;       
        goto out;
    }

            

       if (IS_DRIVER_BLOCK() || IS_DRIVER_BOOTSTATEFUL()) {
              *pExtraBytes = 0;
              *pMTU = 0;
		eAction = IPSecProcessBoottime(pIPHeader,
									   pData,
									   Packet,
									   *pIpsecFlags,
									   DestType);
		goto out;
	}

	if (IPSEC_DRIVER_IS_EMPTY()) {
	   
		*pExtraBytes = 0;
		*pMTU = 0;
		eAction= eFORWARD;
		goto out;
	}






    ASSERT(IS_DRIVER_SECURE());
    ASSERT(IPContext);

    IPSEC_INCREMENT(g_ipsec.NumThreads);

    if (IS_DRIVER_DIAGNOSTIC()) {
        pDropStatus=&DropStatus;
        RtlZeroMemory(pDropStatus,sizeof(IPSEC_DROP_STATUS));
    }

    if (*pIpsecFlags & IPSEC_FLAG_INCOMING) {
        eAction = IPSecRecvPacket(  &pIPHeader,
                                    pData,
                                    IPContext,
                                    Packet,
                                    pExtraBytes,
                                    pIpsecFlags,
                                    pDropStatus,
                                    DestType);
    } else {
        eAction = IPSecSendPacket(  pIPHeader,
                                    pData,
                                    IPContext,
                                    Packet,
                                    pExtraBytes,
                                    pMTU,
                                    pNewData,
                                    pIpsecFlags,
                                    pDropStatus,
                                    DestType);
    }

    IPSEC_DECREMENT(g_ipsec.NumThreads);

out:

    if (eAction == eDROP) {
        if (IS_DRIVER_DIAGNOSTIC() &&
            (!pDropStatus || (pDropStatus && !(pDropStatus->Flags & IPSEC_DROP_STATUS_DONT_LOG)))) {
            IPSecBufferPacketDrop(
                pIPHeader,
                pData,
                pIpsecFlags,
                pDropStatus);
        }
    }
    return  eAction;
}


IPSEC_ACTION
IPSecSendPacket(
    IN  PUCHAR          pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pMTU,
    OUT PVOID           *pNewData,
    IN OUT PULONG       pIpsecFlags,
    OUT PIPSEC_DROP_STATUS pDropStatus,
    IN UCHAR            DestType
    )
/*++

Routine Description:

    Called by the Filter Driver to submit a packet for IPSEC processing.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header, an MDL chain.

    IPContext - contains the destination interface.

    pExtraBytes - IPSEC header expansion value.

    pMTU - passes in the link MTU on send path.

    pNewData - if packet modified, this points to the new data.

    IpsecFlags - flags for SrcRoute, Incoming, Forward and Lookback.

Return Value:

    eFORWARD
    eDROP
    eABSORB

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    IPSEC_ACTION            eRetAction = eFORWARD;
    PSA_TABLE_ENTRY         pSA = NULL;
    PSA_TABLE_ENTRY         pSaveSA = NULL;
    PSA_TABLE_ENTRY         pNextSA = NULL;
    USHORT                  FilterFlags = 0;
    BOOLEAN                 fLifetime = FALSE;
    ULONG                   ipsecHdrSpace = *pExtraBytes;
    ULONG                   ipsecOverhead = 0;
    ULONG                   ipsecMTU = *pMTU;
    ULONG                   newMTU = MAX_LONG;
    ULONG                   dataLength = 0;
    IPHeader UNALIGNED      *pIPH = (IPHeader UNALIGNED *)pIPHeader;
    Interface               *DestIF = (Interface *)IPContext;
    PNDIS_PACKET_EXTENSION  PktExt = NULL;
    PNDIS_IPSEC_PACKET_INFO IPSecPktInfo = NULL;
    BOOLEAN                 fCryptoOnly = FALSE;
    BOOLEAN                 fFWPacket = FALSE;
    BOOLEAN                 fSrcRoute = FALSE;
    BOOLEAN                 fLoopback = FALSE;
    PVOID                   *ppSCContext;
    KIRQL	                kIrql;
    LONG                    Index;
    PNDIS_BUFFER            pTemp;
    ULONG                   Length;
    PUCHAR                  pBuffer;
    IPSEC_UDP_ENCAP_CONTEXT NatContext;
    BOOLEAN                 fRekeyDone=FALSE;
    IPAddr                  iph_src = 0;
    BOOL                    bSendIcmp = FALSE;
    PUCHAR                  pucIpBufferForICMP = NULL;
    PUCHAR                  pucStorage = NULL;


    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Entering IPSecSendPacket"));

    if (*pIpsecFlags & IPSEC_FLAG_FORWARD) {
        fFWPacket = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_SSRR) {
        fSrcRoute = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_LOOPBACK) {
        fLoopback = TRUE;
    }


    *pExtraBytes = 0;
    *pMTU = 0;

    if (fLoopback) {
        IPSEC_DEBUG(LL_A, DBF_PARSE, ("IPSecSendPacket: Packet on loopback interface - returning"));
        status = STATUS_SUCCESS;
        goto out;
    }

    //
    // Walk through the MDL chain to make sure we have memory locked.
    //
    pTemp = (PNDIS_BUFFER)pData;

    while (pTemp) {
        pBuffer = NULL;
        Length = 0;

        NdisQueryBufferSafe(pTemp,
                            &pBuffer,
                            &Length,
                            NormalPagePriority);

        if (!pBuffer) {
            //
            // QueryBuffer failed, drop the packet.
            //
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

        dataLength += Length;

        pTemp = NDIS_BUFFER_LINKAGE(pTemp);
    }

    dataLength -= sizeof(IPHeader);

    //
    // Set send complete context in the NDIS packet.
    //
    if (Packet) {
        PacketContext   *pContext;

        pContext = (PacketContext *)Packet->ProtocolReserved;
        ppSCContext = &pContext->pc_common.pc_IpsecCtx;
    } else {
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    status = IPSecClassifyPacket(   pIPHeader,
                                    pData,
                                    &pSA,
                                    &pNextSA,
                                    &FilterFlags,
#if GPC
                                    PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ClassificationHandlePacketInfo)),
#endif

                                    TRUE,   // fOutbound
                                    fFWPacket,
                                    TRUE,   // do bypass check
                                    FALSE, //Not a recv reinject
                                    FALSE, // Not a verify Call
                                    DestType,
                                    &NatContext);

    if (status == STATUS_PENDING) {
        //
        // Negotiation kicked off; drop the packet silently.
        //
        return  eABSORB;
    } else if (status != STATUS_SUCCESS) {
        status = STATUS_SUCCESS;
        goto out;
    }

    if (FilterFlags) {
        ASSERT(pSA == NULL);

        //
        // This is either a drop or pass thru filter.
        //
        if (FilterFlags & FILTER_FLAGS_DROP) {
            IPSEC_DEBUG(LL_A, DBF_PARSE, ("Drop filter"));
            status = STATUS_UNSUCCESSFUL;
        } else if (FilterFlags & FILTER_FLAGS_PASS_THRU) {
            IPSEC_DEBUG(LL_A, DBF_PARSE, ("Pass thru' filter"));
            status = STATUS_SUCCESS;
        } else {
            ASSERT(FALSE);
        }

        goto out;
    }

    //
    // Consider only outbound SAs
    //
    ASSERT(pSA);
    ASSERT(pSA->sa_Flags & FLAGS_SA_OUTBOUND);

    //
    // We don't support Source Route with IPSec Tunneling.
    //
    if (fSrcRoute && (pSA->sa_Flags & FLAGS_SA_TUNNEL)) {
        IPSEC_DEBUG(LL_A, DBF_TUNNEL, ("No tunneling source route: pSA: %p", pSA));
        IPSecDerefSANextSA(pSA, pNextSA);
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    if (pSA->sa_Flags & FLAGS_SA_ENABLE_NLBS_IDLE_CHECK) {
        IPSEC_SA_EXPIRED(pSA,fLifetime);
        if (fLifetime) {
            // Idled out.  Force rekey
            IPSecRekeyOutboundSA(pSA);
            fRekeyDone=TRUE;
        }
    }

    //
    // Set the last used time.
    //
    NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);


    if (!(pSA->sa_Flags & FLAGS_SA_DISABLE_LIFETIME_CHECK)) {
        //
        // check if we might expire soon - start rekey operation now.
        //
        IPSEC_CHECK_PADDED_LIFETIME(pSA, fLifetime, pSA->sa_NumOps - 1);

        if (fLifetime == FALSE && !fRekeyDone) {
            IPSecRekeyOutboundSA(pSA);
        }

        //
        // check the real lifetime - if we have expired, ensure that the
        // re-key was submitted and then cancel the current SAs.
        //
        IPSEC_CHECK_LIFETIME(pSA, fLifetime, pSA->sa_NumOps - 1);

        //
        // this time it really expired - we are in trouble since this shd have gone away
        // earlier.
        //
        if (fLifetime == FALSE) {
            IPSecPuntOutboundSA(pSA);
            IPSecDerefSANextSA(pSA, pNextSA);
            status = STATUS_UNSUCCESSFUL;
            goto out;
        }

    }

    //
    // Compute the total IPSec overhead.
    //
    ipsecOverhead = pSA->sa_IPSecOverhead;
    if (pNextSA) {
        ipsecOverhead += pNextSA->sa_IPSecOverhead;
    }

    //
    // Check if total data length exceeds 65535.
    //
    if ((dataLength + ipsecOverhead) > (MAX_IP_DATA_LENGTH - sizeof(IPHeader))) {
        IPSecDerefSANextSA(pSA, pNextSA);
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    //
    // If no enough header space, return right away if DF bit is set.  We also
    // have to adjust for PMTU recorded in the SAs.
    //
    if (pIPH->iph_offset & IP_DF_FLAG) {
        //
        // First get MTU recorded from IPSecStatus.
        //
        if (pNextSA) {
            newMTU = MIN(IPSEC_GET_VALUE(pSA->sa_NewMTU),
                         IPSEC_GET_VALUE(pNextSA->sa_NewMTU));
        } else {
            newMTU = IPSEC_GET_VALUE(pSA->sa_NewMTU);
        }

        //
        // Use the smaller of link MTU and new MTU from SA.
        //
        newMTU = MIN(newMTU, ipsecMTU);

        //
        // See if we have enough header space; if not pass back the new smaller
        // MTU minus IPSec overhead to the upper stack.
        //

        if (newMTU < (ipsecOverhead + dataLength)) {

            *pMTU = newMTU - ipsecOverhead;
            IPSEC_DEBUG(LL_A, DBF_PMTU, ("OldMTU %lx, HdrSpace: %lx, NewMTU: %lx", ipsecMTU, ipsecHdrSpace, *pMTU));

            if (DestIF->if_dfencap == ClearDfEncap) {
                if (pNextSA) {
                    ASSERT((pNextSA->sa_Flags & FLAGS_SA_TUNNEL));
                    iph_src = pNextSA->sa_SrcTunnelAddr;
                    bSendIcmp = TRUE;
                }
                else {
                    if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
                        iph_src = pSA->sa_SrcTunnelAddr;
                        bSendIcmp = TRUE;
                    }
                }
            }

            if (bSendIcmp) {
                status = GetIpBufferForICMP(
                             pIPHeader,
                             pData,
                             &pucIpBufferForICMP,
                             &pucStorage
                             );
                if (!NT_SUCCESS(status)) {
                    IPSecDerefSANextSA(pSA, pNextSA);
                    goto out;
                }
                TCPIP_SEND_ICMP_ERR(
                    iph_src,
                    (IPHeader UNALIGNED *) pucIpBufferForICMP,
                    ICMP_DEST_UNREACH,
                    FRAG_NEEDED,
                    net_long((ulong)(*pMTU + sizeof(IPHeader))),
                    0
                    );
                if (pucStorage) {
                    IPSecFreeMemory(pucStorage);
                }
            }
            else {
                IPSecDerefSANextSA(pSA, pNextSA);
                status = STATUS_UNSUCCESSFUL;
                goto out;
            }

        }
    }

    //
    // See if hardware offload can be arranged here.  If successful, we pass the
    // flag to the create routines so they create only the framing, leaving the
    // core crypto to the hardware.
    //
    if (g_ipsec.EnableOffload && ipsecOverhead <= ipsecHdrSpace) {
        IPSecSendOffload(   pIPH,
                            Packet,
                            DestIF,
                            pSA,
                            pNextSA,
                            ppSCContext,
                            &fCryptoOnly);
    }

    //
    // Make sure IPSecPktInfo is NULL if there is no offload for this
    // packet.  This could be set in reinject path which is then
    // forwarded.
    //
    if (!fCryptoOnly) {
        ASSERT(Packet != NULL);

        PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
        PktExt->NdisPacketInfo[IpSecPacketInfo] = NULL;
    }

    if (fCryptoOnly) {
        ADD_TO_LARGE_INTEGER(
            &g_ipsec.Statistics.uOffloadedBytesSent,
            NET_SHORT(pIPH->iph_length));
        if (pDropStatus) {
            pDropStatus->Flags |= IPSEC_DROP_STATUS_CRYPTO_DONE;
        }

    }

    do {
        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.TotalBytesSent,
            NET_SHORT(pIPH->iph_length));

        if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
            ADD_TO_LARGE_INTEGER(
                &g_ipsec.Statistics.uBytesSentInTunnels,
                NET_SHORT(pIPH->iph_length));
        } else {
            ADD_TO_LARGE_INTEGER(
                &g_ipsec.Statistics.uTransportBytesSent,
                NET_SHORT(pIPH->iph_length));
        }

        if (fCryptoOnly) {
            ADD_TO_LARGE_INTEGER(
                &pSA->sa_Stats.OffloadedBytesSent,
                NET_SHORT(pIPH->iph_length));
        }

        //
        // Multiple ops here - iterate thru the headers. Inner first.
        //
        for (Index = 0; Index < pSA->sa_NumOps; Index++) {
            switch (pSA->sa_Operation[Index]) {
            case Auth:
                status = IPSecCreateAH( pIPHeader,
                                        pData,
                                        IPContext,
                                        pSA,
                                        Index,
                                        pNewData,
                                        ppSCContext,
                                        pExtraBytes,
                                        ipsecHdrSpace,
                                        fSrcRoute,
                                        fCryptoOnly);

                if (!NT_SUCCESS(status)) {
                    IPSEC_DEBUG(LL_A, DBF_PARSE, ("AH failed: pSA: %p, status: %lx",
                                        pSA,
                                        status));
                    IPSecDerefSANextSA(pSA, pNextSA);
                    goto out;
                }

                //
                // Save the new MDL for future operation; also query the new header (if it changed)
                //
                if (*pNewData) {
                    pData = *pNewData;
                    IPSecQueryNdisBuf((PNDIS_BUFFER)pData, &pIPHeader, &Length);
                }

                break;

            case Encrypt:
                status = IPSecCreateHughes( pIPHeader,
                                            pData,
                                            IPContext,
                                            pSA,
                                            Index,
                                            pNewData,
                                            ppSCContext,
                                            pExtraBytes,
                                            ipsecHdrSpace,
                                            Packet,
                                            fCryptoOnly);

                if (!NT_SUCCESS(status)) {
                    IPSEC_DEBUG(LL_A, DBF_PARSE, ("HUGHES failed: pSA: %p, status: %lx",
                                        pSA,
                                        status));
                    IPSecDerefSANextSA(pSA, pNextSA);
                    goto out;
                }

                //
                // Save the new MDL for future operation; also query the new header (if it changed)
                //
                if (*pNewData) {
                    pData = *pNewData;
                    IPSecQueryNdisBuf((PNDIS_BUFFER)pData, &pIPHeader, &Length);
                }

                break;

            case None:
                status = STATUS_SUCCESS;
                break;

            default:
                IPSEC_DEBUG(LL_A, DBF_PARSE, ("No valid operation: %p", pSA->sa_Operation));
                break;
            }
        }

        pSaveSA = pSA;
        pSA = pNextSA;
        if (!pSA) {
            IPSecDerefSA(pSaveSA);
            break;
        }

        pNextSA = NULL;
        IPSecDerefSA(pSaveSA);
    } while (TRUE);

    //
    // Remember if we are going to fragment.
    //
    if (ipsecHdrSpace < *pExtraBytes) {
        IPSEC_DEBUG(LL_A, DBF_PARSE, ("ipsecHdrSpace: FRAG"));
        ((IPSEC_SEND_COMPLETE_CONTEXT *)*ppSCContext)->Flags |= SCF_FRAG;
    }

out:
    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_PARSE, ("IPSecSendPacket failed: %lx", status));
        eRetAction = eDROP;
    }

    if (pDropStatus) {
        pDropStatus->IPSecStatus=status;
    }
    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Exiting IPSecSendPacket; action %lx", eRetAction));

    return  eRetAction;
}


IPSEC_ACTION
IPSecRecvPacket(
    IN  PUCHAR          *pIPHeader,
    IN  PVOID           pData,
    IN  PVOID           IPContext,
    IN  PNDIS_PACKET    Packet,
    IN OUT PULONG       pExtraBytes,
    IN OUT PULONG       pIpsecFlags,
    OUT PIPSEC_DROP_STATUS pDropStatus,
    IN  UCHAR           DestType
    )
/*++

Routine Description:

    This is the IPSecRecvHandler.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header, an IPRcvBuf pointer.

    IPContext - contains the destination interface.

    pExtraBytes - IPSEC header expansion value.

    IpsecFlags - flags for SrcRoute, Incoming, Forward and Lookback.

Return Value:

    eFORWARD
    eDROP

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    IPSEC_ACTION            eRetAction = eFORWARD;
    PSA_TABLE_ENTRY         pSA = NULL;
    PSA_TABLE_ENTRY         pSaveSA = NULL;
    PSA_TABLE_ENTRY         pNextSA = NULL;
    USHORT                  FilterFlags = 0;
    BOOLEAN                 fLifetime = FALSE;
    IPHeader UNALIGNED      *pIPH = (IPHeader UNALIGNED *)*pIPHeader;
    Interface               *DestIF = (Interface *)IPContext;
    PNDIS_PACKET            OrigPacket = NULL;
    PNDIS_PACKET_EXTENSION  PktExt = NULL;
    PNDIS_IPSEC_PACKET_INFO IPSecPktInfo = NULL;
    BOOLEAN                 fCryptoOnly = FALSE;
    BOOLEAN                 fFWPacket = FALSE;
    BOOLEAN                 fSrcRoute = FALSE;
    BOOLEAN                 fLoopback = FALSE;
    BOOLEAN                 fFastRcv = FALSE;
    tSPI                    SPI;
    KIRQL	                kIrql;
    LONG                    Index;
    BOOLEAN                    bNatEncap=FALSE;
    IPSEC_UDP_ENCAP_CONTEXT  NatContext;
    IPSEC_UDP_ENCAP_CONTEXT  SavedNatContext;

    if (*pIpsecFlags & IPSEC_FLAG_FORWARD) {
        fFWPacket = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_SSRR) {
        fSrcRoute = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_LOOPBACK) {
        fLoopback = TRUE;
    }
    if (*pIpsecFlags & IPSEC_FLAG_FASTRCV) {
        fFastRcv = TRUE;
    }

    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Entering IPSecRecvPacket"));

    *pExtraBytes = 0;

    if (Packet) {
        OrigPacket = (PNDIS_PACKET)NDIS_GET_ORIGINAL_PACKET(Packet);
        if (OrigPacket) {
            PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(OrigPacket);
        } else {
            PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);
        }
        IPSecPktInfo = PktExt->NdisPacketInfo[IpSecPacketInfo];
    }

#if DBG
    if (DebugOff) {
        if (pIPH->iph_protocol == PROTOCOL_AH ||
            pIPH->iph_protocol == PROTOCOL_ESP) {
                DbgPrint("Packet %p, OrigPacket %p, CRYPTO %d, CryptoStatus %d",
                    Packet,
                    OrigPacket,
                    IPSecPktInfo? IPSecPktInfo->Receive.CRYPTO_DONE: 0,
                    IPSecPktInfo? IPSecPktInfo->Receive.CryptoStatus: 0);
                if (DebugPkt) {
                    DbgBreakPoint();
                }
        }
    }
#endif

    //
    // If the packet is IPSec protected, set the appropriate flags for firewall/NAT.
    //

    if (pIPH->iph_protocol == PROTOCOL_AH ||
        pIPH->iph_protocol == PROTOCOL_ESP) {
        *pIpsecFlags |= IPSEC_FLAG_TRANSFORMED;
    }

    if (IPSecPktInfo  && pDropStatus) {
        if (IPSecPktInfo->Receive.CRYPTO_DONE) {
            pDropStatus->Flags |= IPSEC_DROP_STATUS_CRYPTO_DONE;
        }
        if (IPSecPktInfo->Receive.NEXT_CRYPTO_DONE) {
            pDropStatus->Flags |= IPSEC_DROP_STATUS_NEXT_CRYPTO_DONE;
        }
        if (IPSecPktInfo->Receive.SA_DELETE_REQ) {
            pDropStatus->Flags |= IPSEC_DROP_STATUS_SA_DELETE_REQ;
        }
        pDropStatus->OffloadStatus=IPSecPktInfo->Receive.CryptoStatus;
    }

    if (IPSecPktInfo &&
        IPSecPktInfo->Receive.CRYPTO_DONE &&
        IPSecPktInfo->Receive.CryptoStatus != CRYPTO_SUCCESS) {
        //
        // Error reported by offload card.  Discard the packet and apply
        // the necessary acountings.
        //
        IPSecBufferOffloadEvent(pIPH, IPSecPktInfo);

        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    //
    // Walk the packet to determine the SPI
    //
    status = IPSecParsePacket(  *pIPHeader,
                                pData,
                                &SPI,
                                &bNatEncap,
                                &NatContext);
    // IPSecParsePacket initializes both ports to zero 
    // if this is not a UDP encapsulation
    SavedNatContext = NatContext; //Struct Copy

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_PARSE, ("IPSecParsePkt no IPSEC headers: %lx", status));

        if (fLoopback) {
            IPSEC_DEBUG(LL_A, DBF_PARSE, ("loopback was on, not doing inbound policy check"));
            status = STATUS_SUCCESS;
            goto out;
        }

        status = IPSecClassifyPacket(   *pIPHeader,
                                        pData,
                                        &pSA,
                                        &pNextSA,
                                        &FilterFlags,
#if GPC
                                        0,
#endif
                                        FALSE,  // fOutbound
                                        fFWPacket,
                                        TRUE,  // do bypass check
				            FALSE, // Not a recv reinject
				            FALSE, // Not a verify Call
                                        DestType,
                                        NULL);


        if (status != STATUS_SUCCESS) {
            ASSERT(pSA == NULL);

            //
            // If we didnt find an SA, but found a filter, bad, drop.
            //
            if (status == STATUS_PENDING) {
                // This is where we allow cleartext on PASSTHRU filter 
                // For an SA which is not up yet

                if (FilterFlags & FILTER_FLAGS_PASS_THRU) {
                    // Allow this clear text traffic in
                    status = STATUS_SUCCESS;
                } else {
                    IPSEC_DEBUG(LL_A, DBF_PARSE, ("IPSecParsePkt cleartext when filter exists: %lx", status));
                    status = IPSEC_NEGOTIATION_PENDING;
                }
            } else {
                status = STATUS_SUCCESS;
            }

            goto out;
        } else {
            if (FilterFlags) {
                ASSERT(pSA == NULL);

                //
                // This is either a drop or pass thru filter.
                //
                if (FilterFlags & FILTER_FLAGS_DROP) {
                    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Drop filter"));
                    status = IPSEC_BLOCK;
                } else if (FilterFlags & FILTER_FLAGS_PASS_THRU) {
                    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Pass thru' filter"));
                    status = STATUS_SUCCESS;
                } else {
                    ASSERT(FALSE);
                }

                goto out;
            }

            ASSERT(pSA);

            //
            // Set the last used time.
            //
            NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);

            //
            // We found an SA; In case the operation is not none
            // or if it is a tunnel SA we have invalid cleartext;
            //
            if (pSA->sa_Operation[0] != None ||
                   (pSA->sa_Flags & FLAGS_SA_TUNNEL)
                ) {

                if (g_ipsec.DiagnosticMode & IPSEC_DIAGNOSTIC_INBOUND) {
                    IPSecBufferEvent(   pIPH->iph_src,
                                        EVENT_IPSEC_UNEXPECTED_CLEARTEXT,
                                        2,
                                        TRUE);
                }

                IPSEC_DEBUG(
                    LL_A, 
                    DBF_CLEARTEXT, 
                    ("Unexpected clear text: src %lx, dest %lx, protocol %lx", pIPH->iph_src, pIPH->iph_dest, pIPH->iph_protocol));
                    
#if DBG
                if (IPSecDebug & DBF_EXTRADIAGNOSTIC) 
                {
                    PUCHAR          pTpt;
                    ULONG           tptLen;
                    UNALIGNED WORD  *pwPort;

                    IPSecQueryRcvBuf(pData, &pTpt, &tptLen);
                    pwPort = (UNALIGNED WORD *)(pTpt);
                    IPSEC_DEBUG(
                        LL_A, 
                        DBF_CLEARTEXT, 
                        ("Unexpected clear text: src sport %lx, dport %lx", pwPort[0], pwPort[1]));
                }
#endif

                IPSEC_DEBUG(LL_A, DBF_PARSE, ("Real SA present"));
                status = IPSEC_INVALID_CLEARTEXT;
            }

            IPSecDerefSA(pSA);
        }
    } else {
        pIPH = (UNALIGNED IPHeader *)*pIPHeader;

        IPSEC_SPI_TO_ENTRY(SPI, &pSA, pIPH->iph_dest);

        //
        // Report Bad SPI event only if there is no matching SA.
        //
        if (!pSA) {
            IPSEC_INC_STATISTIC(dwNumBadSPIPackets);

            IPSecBufferEvent(   pIPH->iph_src,
                                EVENT_IPSEC_BAD_SPI_RECEIVED,
                                1,
                                TRUE);

            IPSEC_DEBUG(LL_A, DBF_PARSE, ("Bad spi: %lx", SPI));

            status = IPSEC_BAD_SPI;
            goto out;
        }

        //
        // If larval SA exits, silently discard the packet.
        //
        if (pSA->sa_State != STATE_SA_ACTIVE && pSA->sa_State != STATE_SA_LARVAL_ACTIVE) {
            IPSecDerefSA(pSA);
            status = STATUS_INVALID_PARAMETER;
            goto out;
        }

        //
        // Set the last used time.
        //
        NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);

        if (!(pSA->sa_Flags & FLAGS_SA_DISABLE_LIFETIME_CHECK)) {

            //
            // Check if we might expire soon - start rekey operation now.
            //
            IPSEC_CHECK_PADDED_LIFETIME(pSA, fLifetime, 0);

            if (fLifetime == FALSE) {
                IPSecRekeyInboundSA(pSA);
            }

            //
            // Check the real lifetime - if we have expired, ensure that the
            // rekey was submitted and then cancel the current SAs.
            //
            IPSEC_CHECK_LIFETIME(pSA, fLifetime, 0);

            if (fLifetime == FALSE) {
                IPSecPuntInboundSA(pSA);
                IPSecDerefSA(pSA);
                status = STATUS_UNSUCCESSFUL;
                goto out;
            }
        }

        if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
            ADD_TO_LARGE_INTEGER(
                &g_ipsec.Statistics.uBytesReceivedInTunnels,
                NET_SHORT(pIPH->iph_length));
        } else {
            ADD_TO_LARGE_INTEGER(
                &g_ipsec.Statistics.uTransportBytesReceived,
                NET_SHORT(pIPH->iph_length));
        }

        ADD_TO_LARGE_INTEGER(
            &pSA->sa_Stats.TotalBytesReceived,
            NET_SHORT(pIPH->iph_length));

        //
        // If this was supposed to be handled by hardware, then make sure he
        // either punted it or this was cryptoonly.
        //
        if (IPSecPktInfo != NULL) {
            if (IPSecPktInfo->Receive.CRYPTO_DONE) {
                //
                // Offload has been applied to this packet so
                // record it.  We are here because CryptoStatus
                // equals CRYPTO_SUCCESS.
                //
                ASSERT(IPSecPktInfo->Receive.CryptoStatus == CRYPTO_SUCCESS);                
                fCryptoOnly = TRUE;

                ADD_TO_LARGE_INTEGER(
                    &pSA->sa_Stats.OffloadedBytesReceived,
                    NET_SHORT(pIPH->iph_length));

                ADD_TO_LARGE_INTEGER(
                    &g_ipsec.Statistics.uOffloadedBytesReceived,
                    NET_SHORT(pIPH->iph_length));
            }

            if (IPSecPktInfo->Receive.SA_DELETE_REQ) {
                //
                // No more offload on this SA and its corresponding
                // outbound SA.
                //
                AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

                if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                    (pSA->sa_IPIF == DestIF)) {
                    IPSecDelHWSAAtDpc(pSA);
                }

                if (pSA->sa_AssociatedSA &&
                    (pSA->sa_AssociatedSA->sa_Flags & FLAGS_SA_HW_PLUMBED) &&
                    (pSA->sa_AssociatedSA->sa_IPIF == DestIF)) {
                    IPSecDelHWSAAtDpc(pSA->sa_AssociatedSA);
                }

                ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
            }
        }

        //
        // If SA is not offloaded, try to offload it now.
        //
        if (!fCryptoOnly && (g_ipsec.EnableOffload)) {
            IPSecRecvOffload(pIPH, DestIF, pSA);
        }

        //
        // With multiple SAs coming in, we need to iterate through the operations,
        // last first.
        //
        for (Index = pSA->sa_NumOps-1; (LONG)Index >= 0; Index--) {

            //
            // Got to keep resetting pIPH since pIPHeader can change in the
            // IPSecVerifyXXX calls
            //
            pIPH = (UNALIGNED IPHeader *)*pIPHeader;

            switch (pSA->sa_Operation[Index]) {
            case Auth:
                //
                // Verify AH
                //
                if (pIPH->iph_protocol != PROTOCOL_AH) {
                    IPSecBufferEvent(   pIPH->iph_src,
                                        EVENT_IPSEC_BAD_PROTOCOL_RECEIVED,
                                        1,
                                        TRUE);
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }

                status = IPSecVerifyAH( pIPHeader,
                                        pData,
                                        pSA,
                                        Index,
                                        pExtraBytes,
                                        fSrcRoute,
                                        fCryptoOnly,
                                        fFastRcv);

                if (!NT_SUCCESS(status)) {
                    IPSEC_DEBUG(LL_A, DBF_PARSE, ("AH failed: pSA: %p, status: %lx",
                                        pSA,
                                        status));
                    IPSecDerefSA(pSA);
                    goto out;
                }

                break;

            case Encrypt:
                //
                // Hughes ..
                //
                if ((pIPH->iph_protocol != PROTOCOL_ESP) &&
                    !((pIPH->iph_protocol == PROTOCOL_UDP) && bNatEncap &&
                    (pSA->sa_EncapType != SA_UDP_ENCAP_TYPE_NONE))) {
                    IPSecBufferEvent(   pIPH->iph_src,
                                        EVENT_IPSEC_BAD_PROTOCOL_RECEIVED,
                                        2,
                                        TRUE);
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }

                status = IPSecVerifyHughes( pIPHeader,
                                            pData,
                                            pSA,
                                            Index,
                                            pExtraBytes,
                                            fCryptoOnly,
                                            fFastRcv);

                if (status == IPSEC_SUCCESS_NAT_DECAPSULATE) {
                    status = STATUS_SUCCESS;

                    // Since xsum will be wrong through the NAT, tell the stack
                    // its correct.

                    if (!(pSA->sa_Flags & FLAGS_SA_TUNNEL)) {

                   	 if (pIPH->iph_protocol == PROTOCOL_TCP) {
                   	     (*pIpsecFlags) |= IPSEC_FLAG_TCP_CHECKSUM_VALID;
                   	 }

                  	  if (pIPH->iph_protocol == PROTOCOL_UDP) {
                     	   status = IPSecDisableUdpXsum((IPRcvBuf*)pData);
                  	  }

                    
                        status=AddShimContext(pIPHeader,
                                              pData,
                                              &NatContext);
                    }

                }

                if (!NT_SUCCESS(status)) {
                    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Hughes failed: pSA: %p, status: %lx",
                                        pSA,
                                        status));
                    IPSecDerefSA(pSA);
                    goto out;
                }

                break;

            case None:
                //
                // None is useful for down-level clients - if the peer is incapable
                // of IPSEC, we might have a system policy to send in clear. in that
                // case, the Operation will be None.
                //
                status = STATUS_SUCCESS;
                break;

            default:
                IPSEC_DEBUG(LL_A, DBF_PARSE, ("Invalid op in SA: %p, Index: %d", pSA, Index));
                ASSERT(FALSE);
                break;
            }
        }

        //
        // If this was a tunnel SA that succeeded in decrypt/auth,
        // drop this packet and re-inject a copy.
        // In any case perform a lookup
        if (status == STATUS_SUCCESS){
            if (!(pSA->sa_Flags & FLAGS_SA_TUNNEL)){
                status = IPSecVerifyIncomingFilterSA(
                                    pIPHeader,
                                    pData,
                                    pSA,
                                    DestType,
                                    fLoopback,
                                    FALSE,
                                    &SavedNatContext);
                }
            else
               {
                    PNDIS_BUFFER pHdrMdl = NULL, pDataMdl = NULL, pOptMdl = NULL;
                    PUCHAR pIPH = NULL;
                    PIPSEC_SEND_COMPLETE_CONTEXT pContext = NULL;                    
                    ULONG DataLen;
                    NTSTATUS ReinjectStatus;
                    // If this function fails it releases memory on it's own
                    ReinjectStatus = IPSecPrepareReinjectPacket(
                                             pData, fCryptoOnly? PktExt: NULL,
                                             &pHdrMdl,
                                             &pIPH,
                                             &pOptMdl,
                                             &pDataMdl,
                                             &pContext,
                                             &DataLen);                 

                    // If we succeeded in creating the new packet
                    if (STATUS_SUCCESS == ReinjectStatus){
                                              
                           status = IPSecVerifyIncomingFilterSA(&pIPH, 
                                                                            pHdrMdl,  
                                                                            pSA, 
                                                                            DestType, 
                                                                            fLoopback, 
                                                                            TRUE,
                                                                            &SavedNatContext);
                           // Drop new packet if verification failed
                           if(STATUS_SUCCESS != status){
                                NTSTATUS ntstatus;
                                IPSecFreeBuffer(&ntstatus, pHdrMdl);
                                IPSecFreeBuffer(&ntstatus, pDataMdl);
                                if (pOptMdl){
                                    IPSecFreeBuffer(&ntstatus, pOptMdl);
                                }
                                if (pContext->PktExt) {
                                    IPSecFreeMemory(pContext->PktExt);
                                }
                                IPSecFreeSendCompleteCtx(pContext);
                           }
                            // New packet creation and filter verfication succeeded
                            else {
                                    // This function always returns success
                                    ReinjectStatus = IPSecReinjectPreparedPacket(
                                                                pHdrMdl,
                                                                pContext,
                                                                DataLen,
                                                                pIPH);
                                }
                        }
                    
                    // Drop the old packet
                   status = STATUS_INVALID_PARAMETER;
                   if (pDropStatus) {
                        pDropStatus->Flags |= IPSEC_DROP_STATUS_DONT_LOG;
                   }
              }
        }

        IPSecDerefSA(pSA);
    }

out:
    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_PARSE, ("IPSecRecvPacket failed: %lx", status));
        eRetAction = eDROP;
    }
    if (pDropStatus) {
        pDropStatus->IPSecStatus=status;
    }

   
   
    	
    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Exiting IPSecRecvPacket; action %lx", eRetAction));

    return  eRetAction;
}

NTSTATUS
IPSecVerifyIncomingFilterSA(IN  PUCHAR   *       pIPHeader,
    IN  PVOID           pData,
    IN PSA_TABLE_ENTRY pSA,    
    IN  UCHAR           DestType,   
    BOOLEAN             fLoopback,
    BOOLEAN             fReinject,
    IN PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    )
/*++

Routine Description:

   Does a filter lookup on a packet after VerifyHughes or
   VerifyAh to make sure the packet did indeed come in
   on the SA it was supposed to come in over.

   Called on Recv Path

Arguments:

    pIPHeader: Pointer to pointer to IP Header
    pData      : RcvBuf corresponding to start of payload
    pSA : pointer to SA we just applied to the packet
    fLoopback: Is this packet on the loopback. 
Return Value:
    Succesful classification and match: STATUS_SUCCESS
    IPSEC_BLOCK otherwise

*/
    {
      PSA_TABLE_ENTRY  pLookupSA = NULL,pLookupNextSA = NULL;
      USHORT FilterFlags;
      NTSTATUS status = STATUS_SUCCESS;
      int dropReason=0;

      if (pNatContext) {
      		if ((0 == pNatContext->wSrcEncapPort  )
      			&& (0 == pNatContext->wDesEncapPort )){
      			pNatContext = NULL;
      			}
      	}
      			
                          
      status = IPSecClassifyPacket(   *pIPHeader,
                                            pData,
                                            &pLookupSA,
                                            &pLookupNextSA,
                                            &FilterFlags,
    #if GPC
                                            0,
    #endif
                                            FALSE,  //foutbound
                                            FALSE, //ffwpacket
                                            TRUE,  // do bypass check
                                            fReinject,
                                            TRUE, //Verify call
                                            DestType,
                                            pNatContext); //NatContext


   
         
    
    if (status!= STATUS_SUCCESS){
            IPSEC_DEBUG(LL_A,DBF_PARSE,("Packet Drop , Classify failed \n"));
            
            //
            // If we didnt find an SA, but found a filter, Rekey in progress.
            //
            if (status == STATUS_PENDING) {                     
                    status = STATUS_SUCCESS;              
            } 
            else 
            if (status == STATUS_UNSUCCESSFUL) {
                     //Happens for bypass traffic in tunnel and traffic for which no filter found
                     status = STATUS_SUCCESS;
            }                    
            else {
                status = IPSEC_BLOCK;
                dropReason = 1;
            }

            goto out;
        }
   if ((pSA->sa_Flags & FLAGS_SA_TUNNEL) && (pLookupNextSA)){
        IPSecDerefSA(pLookupSA);
        pLookupSA = pLookupNextSA;
        pLookupNextSA = NULL;
        FilterFlags = 0;
       
    }    
   if (FilterFlags) {
            
        if (FilterFlags & FILTER_FLAGS_DROP)  {
              IPSEC_DEBUG(LL_A,DBF_PARSE,("Packet Drop , Matched Drop Filter"));
              dropReason = 2;
              status = IPSEC_BLOCK;
              goto out;
        } 
                                     
                    
         if (FilterFlags & FILTER_FLAGS_PASS_THRU) {
           //We have a zero paylength IP packet 
           IPSEC_DEBUG(LL_A, DBF_PARSE, ("Pass thru' filter"));
           status = STATUS_SUCCESS;
           goto out;
         } 
   }

    // If this is cleartext and we matched a tunnel
    // SA too,make sure it is on the loopback path.
    // This ensures (for the time being)
    // that the packet did come over a tunnel
    // by checking that it came from the 
    // loopback interface (i.e it was reinjected.
    if (!(pSA->sa_Flags && FLAGS_SA_TUNNEL) && pLookupNextSA && !fLoopback){
        status = IPSEC_BLOCK;
        dropReason = 3;
        IPSEC_DEBUG(LL_A,DBF_PARSE,("Packet Drop , Transport over tunnel not over loopback"));
        goto out;
        }
        
   if (pLookupSA != pSA){
        //Possible Rekey?
        //Compare Sa fields
        IPSEC_DEBUG(LL_A,DBF_PARSE,("Rekey!!"));
        if (!((pLookupSA->sa_uliSrcDstAddr.QuadPart & 
            pLookupSA->sa_uliSrcDstMask.QuadPart)
            == 
            (pSA->sa_uliSrcDstAddr.QuadPart & 
            pSA->sa_uliSrcDstMask.QuadPart))){
            status = IPSEC_BLOCK;
            IPSEC_DEBUG(LL_A,DBF_PARSE,("Packet drop: Rekey and SA adress dont match"));
            dropReason = 4;
            ASSERT(FALSE);
            goto out;
        }                                                                          
        if (pLookupSA->sa_uliProtoSrcDstPort.QuadPart 
            != pSA->sa_uliProtoSrcDstPort.QuadPart){
            
            //
            // Check if packet came over a generic SA and the Specifc SA has expired
            //
            if ((pLookupSA->sa_Flags & FLAGS_SA_DELETE_BY_IOCTL) && 
               (IPSecIsGenericPortsProtocolOf(pSA->sa_uliProtoSrcDstPort,pLookupSA->sa_uliProtoSrcDstPort))){	           
                IPSEC_DEBUG(LL_A,DBF_PARSE,("Packet came over a generic SA and the specific SA has expired"));
            }
            else{
                status = IPSEC_BLOCK;
                IPSEC_DEBUG(LL_A,DBF_PARSE,("Packet Drop: Rekey and SA ports dont match"));
                dropReason = 5;
                // Fix for RRAS stop problem ; specific filters get deleted first 
                // and traffic now goes over generic filters triggering this assert
                if ((SA_SRC_PORT(pSA) != IPSEC_L2TP_PORT )  && ( SA_DEST_PORT(pSA) != IPSEC_L2TP_PORT)){
                 	ASSERT(FALSE);
                }
                else{
                    IPSEC_DEBUG(LL_A,DBF_PARSE,("RRAS Filter mismatch\n"));
                }
                goto out;
            }
        }
        
        if ((SA_UDP_ENCAP_TYPE_NONE != pLookupSA->sa_EncapType) ||
	   ( SA_UDP_ENCAP_TYPE_NONE != pSA->sa_EncapType))
        {
            if (!((pLookupSA->sa_EncapType == pSA->sa_EncapType)  
                &&
               (pLookupSA->sa_EncapContext.wSrcEncapPort 
                == 
                pSA->sa_EncapContext.wSrcEncapPort )
                &&
                (pLookupSA->sa_EncapContext.wDesEncapPort
                == 
                pSA->sa_EncapContext.wDesEncapPort))){
                    status = IPSEC_BLOCK;
                    IPSEC_DEBUG(LL_A,DBF_PARSE,("Packet Drop: Rekey and UDP encap info dont match "));            
                    dropReason = 6;
                    ASSERT(FALSE);
                    goto out;    
                }
        }
   }

out:
    if (STATUS_SUCCESS != status ) {
              InterlockedIncrement(&g_ipsec.dwPacketsOnWrongSA);   
              IPSEC_DEBUG(LL_A,DBF_PARSE,("Packet from %lx to %lx with protocol %lx length %lx id %lx ",
                    ((IPHeader *)*pIPHeader)->iph_src,
                    ((IPHeader *)*pIPHeader)->iph_dest,
                    ((IPHeader *)*pIPHeader)->iph_protocol,
                    NET_SHORT(((IPHeader*)*pIPHeader)->iph_length),
                    NET_SHORT(((IPHeader *)*pIPHeader)->iph_id)));
             IPSEC_DEBUG(LL_A,DBF_PARSE,("Packets Dropped =%d DropReason=%d",g_ipsec.dwPacketsOnWrongSA,dropReason ));            
        }
    if (pLookupSA){
        IPSecDerefSANextSA(pLookupSA,pLookupNextSA);
        }
    return status;
}                        



VOID
IPSecCalcHeaderOverheadFromSA(
    IN  PSA_TABLE_ENTRY pSA,
    OUT PULONG          pOverhead
    )
/*++

Routine Description:

    Called from IP to query the IPSEC header overhead.

Arguments:

    pIPHeader - points to start of IP header.

    pOverhead - number of bytes in IPSEC header.

Return Value:

    None

--*/
{
	LONG    Index;
	ULONG   AHSize = sizeof(AH) + pSA->sa_TruncatedLen;
	ULONG   ESPSize = sizeof(ESP) + pSA->sa_ivlen + pSA->sa_ReplayLen + MAX_PAD_LEN + pSA->sa_TruncatedLen;
	DWORD dwExtraTransportNat=0;
	//
	// Take the actual SA to get the exact value.
	//
	*pOverhead = 0;

	for (Index = 0; Index < pSA->sa_NumOps; Index++) {
		switch (pSA->sa_Operation[Index]) {
		case Encrypt:
			*pOverhead += ESPSize;

			switch (pSA->sa_EncapType) {
			case SA_UDP_ENCAP_TYPE_NONE:
				break;
			case SA_UDP_ENCAP_TYPE_IKE:
				dwExtraTransportNat= sizeof(NATENCAP);
				break;
			case SA_UDP_ENCAP_TYPE_OTHER:
				dwExtraTransportNat=sizeof(NATENCAP_OTHER);
				break;
			}

			*pOverhead += dwExtraTransportNat;   

			IPSEC_DEBUG(LL_A, DBF_PMTU, ("PROTOCOL_ESP: overhead: %lx", *pOverhead));
			break;

		case Auth:
			*pOverhead += AHSize;
			IPSEC_DEBUG(LL_A, DBF_PMTU, ("PROTOCOL_AH: overhead: %lx", *pOverhead));
			break;

		default:
			IPSEC_DEBUG(LL_A, DBF_PMTU, ("No IPSEC headers"));
			break;
		}
	}

	if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
		*pOverhead += sizeof(IPHeader);
		IPSEC_DEBUG(LL_A, DBF_PMTU, ("TUNNEL: overhead: %lx", *pOverhead));
	}
}


NTSTATUS
IPSecParsePacket(
    IN  PUCHAR      pIPHeader,
    IN  PVOID       *pData,
    OUT tSPI        *pSPI,
    OUT BOOLEAN     *bNatEncap,
    OUT IPSEC_UDP_ENCAP_CONTEXT *pNatContext
    )
/*++

Routine Description:

    Walk the packet to determine the SPI, this also returns the
    next header that might be also an IPSEC component.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header.

    pSPI - to return the SPI value.

Return Value:

--*/
{
	IPHeader UNALIGNED *pIPH = (IPHeader UNALIGNED *)pIPHeader;
    AH      UNALIGNED     *pAH;
    ESP     UNALIGNED     *pEsp;
    NATENCAP UNALIGNED    *pNat;
    NATENCAP_OTHER UNALIGNED *pNatOther;
    NTSTATUS    status = STATUS_NOT_FOUND;
    PUCHAR  pPyld;
    ULONG   Len;
    tSPI TmpSpi;

    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Entering IPSecParsePacket"));

    pNatContext->wSrcEncapPort=0;
    pNatContext->wDesEncapPort=0;

    IPSecQueryRcvBuf(pData, &pPyld, &Len);

    if (pIPH->iph_protocol == PROTOCOL_AH) {
        pAH = (UNALIGNED AH *)pPyld;
        if (Len >= sizeof(AH)) {
            *pSPI = NET_TO_HOST_LONG(pAH->ah_spi);
            status = STATUS_SUCCESS;
        }
    } else if (pIPH->iph_protocol == PROTOCOL_ESP) {
        pEsp = (UNALIGNED ESP *)pPyld;
        if (Len >= sizeof(ESP)) {
            *pSPI = NET_TO_HOST_LONG(pEsp->esp_spi);
            status = STATUS_SUCCESS;
        }
	} else if (pIPH->iph_protocol == PROTOCOL_UDP) {

		if (Len >= sizeof(NATENCAP_OTHER) + sizeof(tSPI)) {

			pNatOther = (UNALIGNED NATENCAP_OTHER *)pPyld;

			pNatContext->wSrcEncapPort=pNatOther->uh_src;
			pNatContext->wDesEncapPort=pNatOther->uh_dest;

			if (pNatOther->uh_dest == IPSEC_ISAKMP_PORT2) {
				if (!(IsAllZero((BYTE*)(pNatOther+1),4))) {
					memcpy(&TmpSpi,pNatOther+1,sizeof(tSPI));
					*pSPI = NET_TO_HOST_LONG(TmpSpi);
					*bNatEncap=TRUE;
					status = STATUS_SUCCESS;
				}
			}


			if (pNatOther->uh_dest == IPSEC_ISAKMP_PORT) {
				pNat = (UNALIGNED NATENCAP *)pPyld;
				if (Len >= sizeof(NATENCAP) + sizeof(tSPI)) {

					if (IsAllZero(pNat->Zero,8)) {
						memcpy(&TmpSpi,pNat+1,sizeof(tSPI));
						*pSPI = NET_TO_HOST_LONG(TmpSpi);
						*bNatEncap=TRUE;
						status = STATUS_SUCCESS;
					}
				}
			}
		}
	}
    


    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Exiting IPSecParsePacket"));

    return status;
}


PSA_TABLE_ENTRY
IPSecLookupSAInLarval(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort
    )
/*++

Routine Description:

    Search for SA (in larval list) matching the input params.

Arguments:

Return Value:

    Pointer to SA matched else NULL

--*/
{
    PLIST_ENTRY     pEntry;
    KIRQL       	kIrql;
    ULARGE_INTEGER  uliAddr;
    ULARGE_INTEGER  uliPort;
    PSA_TABLE_ENTRY pSA = NULL;

    IPSEC_BUILD_SRC_DEST_ADDR(uliAddr, DEST_ADDR, SRC_ADDR);

    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    for (   pEntry = g_ipsec.LarvalSAList.Flink;
            pEntry != &g_ipsec.LarvalSAList;
            pEntry = pEntry->Flink) {

        pSA = CONTAINING_RECORD(pEntry,
                                SA_TABLE_ENTRY,
                                sa_LarvalLinkage);

        //
        // responder inbound has no filter ptr
        //
        if (pSA->sa_Filter) {
            uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pSA->sa_Filter->uliProtoSrcDstMask.QuadPart;

            if ((uliAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) &&
                (uliPort.QuadPart == pSA->sa_Filter->uliProtoSrcDstPort.QuadPart)) {
                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pSA));

                RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
                return  pSA;
            }
        } else {
            if (uliAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pSA));

                RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
                return  pSA;
            }
        }
    }

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    return NULL;
}


NTSTATUS
IPSecClassifyPacket(
    IN  PUCHAR          pHeader,
    IN  PVOID           pData,
    OUT PSA_TABLE_ENTRY *ppSA,
    OUT PSA_TABLE_ENTRY *ppNextSA,
    OUT USHORT          *pFilterFlags,
#if GPC
    IN  CLASSIFICATION_HANDLE   GpcHandle,
#endif
    IN  BOOLEAN         fOutbound,
    IN  BOOLEAN         fFWPacket,
    IN  BOOLEAN         fDoBypassCheck,
    IN  BOOLEAN         fReinjectRecvPacket,
    IN BOOLEAN          fVerify,
    IN  UCHAR           DestType,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    )
/*++

Routine Description:

    Classifies the outgoing packet be matching the Src/Dest Address/Ports
    with the filter database to arrive at an IPSEC_CONTEXT which is a set
    of AH/ESP indices into the SA Table.

    Adapted in most part from the Filter Driver.

Arguments:

    pIPHeader - points to start of IP header.

    pData - points to the data after the IP header.

    ppSA - returns the SA if found.

    pFilterFlags - flags of the filter if found returned here.

    fOutbound  - direction flag used in lookups.

    fDoBypassCheck - if TRUE, we bypass port 500 traffic, else we block it.

Return Value:

    Pointer to IPSEC_CONTEXT if packet matched else NULL

--*/
{
    REGISTER UNALIGNED ULARGE_INTEGER   *puliSrcDstAddr;
    REGISTER ULARGE_INTEGER             uliProtoSrcDstPort;
    UNALIGNED WORD                      *pwPort;
    PUCHAR                              pTpt;
    ULONG                               tptLen;
    REGISTER ULARGE_INTEGER             uliAddr;
    REGISTER ULARGE_INTEGER             uliPort;
    KIRQL                               kIrql;
    REGISTER ULONG                      dwIndex;
    REGISTER PFILTER_CACHE              pCache;
    IPHeader UNALIGNED                  *pIPHeader = (IPHeader UNALIGNED *)pHeader;
    PSA_TABLE_ENTRY                     pSA = NULL;
    PSA_TABLE_ENTRY                     pNextSA = NULL;
    PSA_TABLE_ENTRY                     pTunnelSA = NULL;
    PFILTER                             pFilter = NULL;
    NTSTATUS                            status;
    BOOLEAN                             fBypass;
    PNDIS_BUFFER                        pTempBuf;
    WORD                                wTpt[2];
    PVOID                               OutContext=NULL;
    IPSEC_UDP_ENCAP_CONTEXT             TmpNatContext;
    DWORD                               dwNatContext;

    *ppSA = NULL;
    *ppNextSA = NULL;
    *pFilterFlags = 0;
    wTpt[0] = wTpt[1] = 0;


    //
    // First buffer in pData chain points to start of IP header
    //
    if (fOutbound || fReinjectRecvPacket) {
        if (((pIPHeader->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2) > sizeof(IPHeader)) {
            //
            // Options -> third MDL has Tpt header
            //
            if (!(pTempBuf = IPSEC_NEXT_BUFFER((PNDIS_BUFFER)pData))) {
                ASSERT(FALSE);
                *pFilterFlags |= FILTER_FLAGS_DROP;
                return STATUS_SUCCESS;
            }

            if (!(pTempBuf = IPSEC_NEXT_BUFFER(pTempBuf))) {
                *pFilterFlags |= FILTER_FLAGS_DROP;
                pwPort = (UNALIGNED WORD *) (wTpt);
                tptLen=4;
            }
            else {
                IPSecQueryNdisBuf(pTempBuf, &pTpt, &tptLen);
                //Bug: 550484
                if (tptLen >= 4){
                        pwPort = (UNALIGNED WORD *)(pTpt);
                    }
                else{
                    // Treat this as having zero value for ports
                    pwPort = (UNALIGNED WORD *) (wTpt);
                    tptLen=4;
                }             

            }

        } else {
            //
            // no options -> second MDL has Tpt header
            //
            if (!(pTempBuf = IPSEC_NEXT_BUFFER((PNDIS_BUFFER)pData))) {
                *pFilterFlags |= FILTER_FLAGS_DROP;
                pwPort = (UNALIGNED WORD *) (wTpt);
                tptLen=4;
            }
            else {
                IPSecQueryNdisBuf(pTempBuf, &pTpt, &tptLen);
                // Bug: 550484
                if (tptLen >= 4){
                        pwPort = (UNALIGNED WORD *)(pTpt);
                    }
                else{
                    // Treat this as having zero value for ports
                    pwPort = (UNALIGNED WORD *) (wTpt);
                    tptLen=4;
                }                           

            }
        }

        //
        // We do this because TCPIP does not set the forward flag for reinjected packets
        // which can also be fragments. Nat Shim does not know how to handle fragments
        //
        if (!IPSEC_FORWARD_PATH() && !fReinjectRecvPacket){
        		status=(g_ipsec.ShimFunctions.pOutgoingPacketRoutine)(pIPHeader,
                                                              pwPort,
                                                              tptLen,
                                                              (PVOID)&OutContext);

            if (!NT_SUCCESS(status)) {
              // Must not fail or packets go in clear.  Drop it
              *pFilterFlags |= FILTER_FLAGS_DROP;
              return STATUS_SUCCESS;
             }
	    }

        dwNatContext = HandleToUlong(OutContext);
        memcpy(&TmpNatContext,&dwNatContext,sizeof(IPSEC_UDP_ENCAP_CONTEXT));

        IPSEC_DEBUG(
            LL_A, 
            DBF_NATSHIM,
            ("ProcessOutgoing: PreSwapOutContext %d ret %x",
            *((DWORD*)&TmpNatContext),
            status));

        if (pNatContext) {
            memcpy(pNatContext,&TmpNatContext.wDesEncapPort,sizeof(WORD));
            memcpy(((PBYTE)pNatContext)+sizeof(WORD),&TmpNatContext.wSrcEncapPort,sizeof(WORD));

            if (IsAllZero((BYTE*)&TmpNatContext,sizeof(IPSEC_UDP_ENCAP_CONTEXT))) {
                pNatContext = NULL;
            }
        }


    } else {
        //
        // inbound side;  tpt starts at pData
        //
        IPSecQueryRcvBuf(pData, &pTpt, &tptLen);
        if (pIPHeader->iph_protocol == PROTOCOL_TCP ||
            pIPHeader->iph_protocol == PROTOCOL_UDP) {
            if (tptLen < sizeof(WORD)*2) {
                pwPort = (UNALIGNED WORD *) (wTpt);
            }
            else {
                pwPort = (UNALIGNED WORD *)(pTpt);
            }
        }
        else {
            pwPort = (UNALIGNED WORD *) (wTpt);
        }


    }


    // NAT Keepalive drop
    if (!fOutbound && tptLen >= 6) {
        if (IPSEC_ISAKMP_TRAFFIC() ||
			IPSEC_ISAKMP_TRAFFIC2()) {
 			// Check UDP len for 1 data byte
            if (NET_SHORT(pwPort[2]) == 9) {
                IPSEC_DEBUG(LL_A, DBF_PARSE, ("NAT keep alive,Ports: %d.%d", pwPort[0], pwPort[1]));
                *pFilterFlags |= FILTER_FLAGS_DROP;
                return STATUS_SUCCESS;
            }

        }
    }

    puliSrcDstAddr = (UNALIGNED ULARGE_INTEGER*)(&(pIPHeader->iph_src));

    IPSEC_DEBUG(LL_A, DBF_PARSE, ("Ports: %d.%d", pwPort[0], pwPort[1]));

    IPSEC_BUILD_PROTO_PORT_LI(  uliProtoSrcDstPort,
                                pIPHeader->iph_protocol,
                                pwPort[0],
                                pwPort[1]);

    IPSEC_DEBUG(
        LL_A, DBF_PATTERN,
        ("Addr Large Int: High= %lx Low= %lx", puliSrcDstAddr->HighPart, puliSrcDstAddr->LowPart));

    IPSEC_DEBUG(
        LL_A, DBF_PATTERN,
        ("Packet value is Src: %lx Dst: %lx",pIPHeader->iph_src,pIPHeader->iph_dest));

    IPSEC_DEBUG(
        LL_A, DBF_PATTERN,
        ("Proto/Port:High= %lx Low= %lx",uliProtoSrcDstPort.HighPart,uliProtoSrcDstPort.LowPart));

    IPSEC_DEBUG(LL_A, DBF_PATTERN, ("Iph is %px",pIPHeader));
    IPSEC_DEBUG(LL_A, DBF_PATTERN,("Addr of src is %p",&(pIPHeader->iph_src)));
    IPSEC_DEBUG(LL_A, DBF_PATTERN,("Ptr to LI is %p",puliSrcDstAddr));

    //
    // Determine if this is a packet that needs bypass checking
    //
    if (fDoBypassCheck && IPSEC_BYPASS_TRAFFIC() && !IPSEC_FORWARD_PATH()) {
        fBypass = TRUE;
    } else {
        fBypass = FALSE;
    }



    //
    // Sum up the fields and get the cache index. We make sure the sum
    // is assymetric, i.e. a packet from A->B goes to different bucket
    // than one from B->A
    //
    dwIndex = CalcCacheIndex(   pIPHeader->iph_src,
                                pIPHeader->iph_dest,
                                pIPHeader->iph_protocol,
                                pwPort[0],
                                pwPort[1],
                                fOutbound);

    IPSEC_DEBUG(LL_A, DBF_PATTERN, ("Cache Index is %d", dwIndex));

    AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

    pCache = g_ipsec.ppCache[dwIndex];

    if (!pNatContext) {

        //To do, maybe: Build nat into cache??

        //
        // Try for a quick cache probe
        //
        if (!(*pFilterFlags & FILTER_FLAGS_DROP) && IS_VALID_CACHE_ENTRY(pCache) &&
            CacheMatch(*puliSrcDstAddr, uliProtoSrcDstPort, pCache)) {
            if (!pCache->FilterEntry) {
                pSA = pCache->pSAEntry;
                pNextSA = pCache->pNextSAEntry;

                ASSERT(pSA->sa_State == STATE_SA_ACTIVE);

                if (fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0)) {
                    if (fBypass) {
                        if (pNextSA) {
                            IPSecRefSA(pNextSA);
                            *ppSA = pNextSA;
                            status = STATUS_SUCCESS;
                        } else {
                            status = STATUS_UNSUCCESSFUL;
                        }
                    } else {
                        if (pNextSA) {
                            IPSecRefSA(pNextSA);
                            *ppNextSA = pNextSA;
                        }
                        IPSecRefSA(pSA);
                        *ppSA = pSA;
                        status = STATUS_SUCCESS;
                    }

#if DBG
                    ADD_TO_LARGE_INTEGER(&pCache->CacheHitCount, 1);
                    ADD_TO_LARGE_INTEGER(&g_ipsec.CacheHitCount, 1);
#endif
                    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                    return status;
                }
            } else if (!fBypass) {
                pFilter = pCache->pFilter;
                ASSERT(IS_EXEMPT_FILTER(pFilter));
                *pFilterFlags = pFilter->Flags;
#if DBG
                ADD_TO_LARGE_INTEGER(&pCache->CacheHitCount, 1);
                ADD_TO_LARGE_INTEGER(&g_ipsec.CacheHitCount, 1);
#endif
                ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                return STATUS_SUCCESS;
            }
        }
    }
        //
    // check the non-manual filters first.
    //
#if GPC
    if (fBypass || fFWPacket || !IS_GPC_ACTIVE()) {
        status = IPSecLookupSAByAddr(   *puliSrcDstAddr,
                                        uliProtoSrcDstPort,
                                        &pFilter,
                                        &pSA,
                                        &pNextSA,
                                        &pTunnelSA,
                                        fOutbound,
                                        fFWPacket,
                                        fBypass,
                                        fVerify,
                                        pNatContext);
    } else {
        status = IPSecLookupGpcSA(  *puliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    GpcHandle,
                                    &pFilter,
                                    &pSA,
                                    &pNextSA,
                                    &pTunnelSA,
                                    fOutbound,
                                    fVerify,
                                    pNatContext);
    }
#else
    status = IPSecLookupSAByAddr(   *puliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    &pFilter,
                                    &pSA,
                                    &pNextSA,
                                    &pTunnelSA,
                                    fOutbound,
                                    fFWPacket,
                                    fBypass,
                                    fVerify,
                                    pNatContext);
#endif

    //
    // Special Processing for zero length payload packets.
    //

    if (*pFilterFlags & FILTER_FLAGS_DROP) {
        if (pFilter) {
            if (IS_EXEMPT_FILTER(pFilter)) {
                *pFilterFlags = pFilter->Flags;
            }
        }
        else {
            *pFilterFlags = FILTER_FLAGS_PASS_THRU;
        }
        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
        return STATUS_SUCCESS;
    }

    if (status == STATUS_SUCCESS) {
        if (fBypass) {
            if (pNextSA) {
                if (pNextSA->sa_State == STATE_SA_ACTIVE || pNextSA->sa_State == STATE_SA_LARVAL_ACTIVE) {
                    IPSecRefSA(pNextSA);
                    *ppSA = pNextSA;
                    status = STATUS_SUCCESS;
                } else {
                    *pFilterFlags = pFilter->Flags;
                    status = STATUS_PENDING;
                }
            } else {
                status = STATUS_UNSUCCESSFUL;
            }

            ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
            return status;
        }

        if ((pSA->sa_State != STATE_SA_ACTIVE && pSA->sa_State != STATE_SA_LARVAL_ACTIVE) ||
            (pNextSA && pNextSA->sa_State != STATE_SA_ACTIVE && pNextSA->sa_State != STATE_SA_LARVAL_ACTIVE)) {
            IPSEC_DEBUG(LL_A, DBF_PATTERN, ("State is not active: %p, %lx", pSA, pSA->sa_State));
            *pFilterFlags = pFilter->Flags;
            ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
            return STATUS_PENDING;
        } else {
            if (pNextSA) {
                IPSecRefSA(pNextSA);
                *ppNextSA = pNextSA;
            }
            IPSecRefSA(pSA);
            *ppSA = pSA;
            ReleaseReadLockFromDpc(&g_ipsec.SADBLock);

            AcquireWriteLockAtDpc(&g_ipsec.SADBLock);
            if (pSA->sa_State == STATE_SA_ACTIVE &&
                (!pNextSA ||
                 pNextSA->sa_State == STATE_SA_ACTIVE)) {
                CacheUpdate(*puliSrcDstAddr,
                            uliProtoSrcDstPort,
                            pSA,
                            pNextSA,
                            dwIndex,
                            FALSE);
            }
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

            return STATUS_SUCCESS;
        }
    } else if (status == STATUS_PENDING) {
        if (IS_EXEMPT_FILTER(pFilter)) {
            IPSEC_DEBUG(LL_A, DBF_PARSE, ("Drop or Pass thru flags: %p", pFilter));
            *pFilterFlags = pFilter->Flags;
            IPSecRefFilter(pFilter);
            ReleaseReadLockFromDpc(&g_ipsec.SADBLock);

            AcquireWriteLockAtDpc(&g_ipsec.SADBLock);
            if (pFilter->LinkedFilter) {
                CacheUpdate(*puliSrcDstAddr,
                            uliProtoSrcDstPort,
                            pFilter,
                            NULL,
                            dwIndex,
                            TRUE);
            }
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

            IPSecDerefFilter(pFilter);
            return STATUS_SUCCESS;
        }

        //
        // This is ensure that in a tunnel+tpt mode, the oakley packet for
        // the tpt SA goes thru the tunnel.
        //
        if (pTunnelSA) {
            if (fBypass) {
                if (pTunnelSA->sa_State != STATE_SA_ACTIVE && pTunnelSA->sa_State != STATE_SA_LARVAL_ACTIVE) {
                    IPSEC_DEBUG(LL_A, DBF_PATTERN, ("State is not active: %p, %lx", pTunnelSA, pTunnelSA->sa_State));
                    *pFilterFlags = pFilter->Flags;

                    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                    return STATUS_PENDING;
                } else {
                    IPSecRefSA(pTunnelSA);
                    *ppSA = pTunnelSA;

                    //
                    // we dont update the cache since this SA, once it comes up,
                    // it is the one that is looked up first.
                    //
                    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                    return STATUS_SUCCESS;
                }
            }
        }

        if (fBypass) {
            ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // We only negotiate outbound SAs.
        //
        if (!fOutbound) {
            *pFilterFlags = pFilter->Flags;
            ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
            return status;
        }

        //
        // need to negotiate the keys - filter exists.
        //
        IPSEC_DEBUG(LL_A, DBF_PATTERN, ("need to negotiate the keys - filter exists: %p", pFilter));

        ASSERT(pSA == NULL);

        IPSecRefFilter(pFilter);

        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

        AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

        //
        // If filter is deleted here we want to discard this packet
        //
        if (!pFilter->LinkedFilter) {
            *pFilterFlags = pFilter->Flags;
            IPSecDerefFilter(pFilter);
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
            return  STATUS_PENDING;
        }

        status = IPSecNegotiateSA(  pFilter,
                                    *puliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    MAX_LONG,
                                    &pSA,
                                    DestType,
                                    pNatContext);

        IPSecDerefFilter(pFilter);

        //
        // Duplicate is returned if a neg is already on. Tell the caller to
        // hold on to his horses.
        //
        if ((status != STATUS_DUPLICATE_OBJECTID) &&
            !NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A, DBF_PATTERN, ("NegotiateSA failed: %lx", status));
            *pFilterFlags = pFilter->Flags;

            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
            return STATUS_PENDING;
        }

        //
        // Pend this packet
        //
        if (pSA) {
            IPSecQueuePacket(pSA, pData);
        }
        IPSEC_DEBUG(LL_A, DBF_PATTERN, ("Packet queued: %p, %p", pSA, pData));
        *pFilterFlags = pFilter->Flags;
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
        return STATUS_PENDING;
    } else {
        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
        return STATUS_UNSUCCESSFUL;
    }
}


VOID
IPSecSendComplete(
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           pData,
    IN  PIPSEC_SEND_COMPLETE_CONTEXT  pContext,
    IN  IP_STATUS       Status,
    OUT PVOID           *ppNewData
    )
/*++

Routine Description:

    Called by the stack on a SendComplete - frees up IPSEC's Mdls

Arguments:

    pData - points to the data after the IP header. On the send side, this is an MDL chain
            On the recv side this is an IPRcvBuf pointer.

    pContext - send complete context
    pNewData - if packet modified, this points to the new data.

Return Value:

    STATUS_SUCCESS  =>   Forward - Filter driver passes packet on to IP
    STATUS_PENDING  =>   Drop, IPSEC will re-inject

    Others:
        STATUS_INSUFFICIENT_RESOURCES => Drop
        STATUS_UNSUCCESSFUL (error in algo./bad packet received) => Drop

--*/
{
    NTSTATUS        status;
    PNDIS_BUFFER    pMdl;
    PNDIS_BUFFER    pNextMdl;
    BOOLEAN         fFreeContext = TRUE;

    *ppNewData = pData;

    if (!pContext) {
        return;
    }

#if DBG
    IPSEC_DEBUG(LL_A, DBF_MDL, ("Entering IPSecSendComplete"));
    IPSEC_PRINT_CONTEXT(pContext);
    IPSEC_PRINT_MDL(*ppNewData);
#endif

    if (pContext->Flags & SCF_PKTINFO) {
        IPSecFreePktInfo(pContext->PktInfo);

        if (pContext->pSA) {
            KIRQL           kIrql;
            PSA_TABLE_ENTRY pSA;

            AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

            pSA = (PSA_TABLE_ENTRY)pContext->pSA;
            IPSEC_DECREMENT(pSA->sa_NumSends);
            if (pSA->sa_Flags & FLAGS_SA_HW_DELETE_SA) {
                IPSecDelHWSAAtDpc(pSA);
            }
            IPSecDerefSA(pSA);

            pSA = (PSA_TABLE_ENTRY)pContext->pNextSA;
            if (pSA) {
                IPSEC_DECREMENT(pSA->sa_NumSends);
                if (pSA->sa_Flags & FLAGS_SA_HW_DELETE_SA) {
                    IPSecDelHWSAAtDpc(pSA);
                }
                IPSecDerefSA(pSA);
            }

            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
        }
    }

    if (pContext->Flags & SCF_PKTEXT) {
        IPSecFreePktExt(pContext->PktExt);
    }

    if (pContext->Flags & SCF_AH_2) {

        IPSEC_DEBUG(LL_A, DBF_SEND, ("SendComplete: Outer AH: pContext: %p", pContext));
        pMdl = pContext->AHMdl2;

        ASSERT(pMdl);

        IPSecFreeBuffer(&status, pMdl);

        //
        // return the older chain
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevAHMdl2) = pContext->OriAHMdl2;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevAHMdl2) = pContext->OriAHMdl2;
            // *ppNewData = (PVOID)(pContext->PrevMdl);
        }
        pContext->OriAHMdl2 = NULL;
    }

    if (pContext->Flags & SCF_AH_TU) {
        IPSEC_DEBUG(LL_A, DBF_SEND, ("SendComplete: AH_TU: pContext: %p", pContext));

        //
        // Free the new IP header and the AH buffer and return the old chain
        //
        pMdl = pContext->AHTuMdl;

        ASSERT(pMdl);

        pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
        IPSecFreeBuffer(&status, pMdl);
        IPSecFreeBuffer(&status, pNextMdl);

        //
        // return the older chain
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevTuMdl) = pContext->OriTuMdl;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevTuMdl) = pContext->OriTuMdl;
        }

        if (pContext->OptMdl) {
            IPSecFreeBuffer(&status, pContext->OptMdl);
        }
    }

    if (pContext->Flags & SCF_HU_TU) {
        IPSEC_DEBUG(LL_A, DBF_SEND, ("SendComplete: HU_TU: pContext: %p", pContext));
        //
        // Free the encrypt chain and return the old chain
        //
        pMdl = pContext->HUTuMdl;
        ASSERT(pMdl);

        //
        // In none case, free the esp header and the IP header.
        //
        if (pContext->Flags & SCF_NOE_TU) {
            IPSecFreeBuffer(&status, pMdl);
            ASSERT(pContext->PadTuMdl);
        } else {
            ASSERT(NDIS_BUFFER_LINKAGE(pMdl));
            while (pMdl) {
                pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
                IPSecFreeBuffer(&status, pMdl);
                pMdl = pNextMdl;
            }
        }

        //
        // Free the Pad mdl
        //
        if (pContext->PadTuMdl) {
            IPSecFreeBuffer(&status, pContext->PadTuMdl);
        }

        if (pContext->HUHdrMdl) {
            IPSecFreeBuffer(&status, pContext->HUHdrMdl);
        }

        if (pContext->OptMdl) {
            IPSecFreeBuffer(&status, pContext->OptMdl);
        }

        NDIS_BUFFER_LINKAGE(pContext->BeforePadTuMdl) = NULL;

        //
        // return the older chain
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevTuMdl) = pContext->OriTuMdl;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevTuMdl) = pContext->OriTuMdl;
        }
    }

    if (pContext->Flags & SCF_AH) {

        IPSEC_DEBUG(LL_A, DBF_SEND, ("SendComplete: AH: pContext: %p", pContext));
        pMdl = pContext->AHMdl;

        ASSERT(pMdl);

        IPSecFreeBuffer(&status, pMdl);

        //
        // return the older chain
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevMdl) = pContext->OriAHMdl;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevMdl) = pContext->OriAHMdl;
            // *ppNewData = (PVOID)(pContext->PrevMdl);
        }
        pContext->OriAHMdl = NULL;
    }

    if (pContext->Flags & SCF_HU_TPT) {
        IPSEC_DEBUG(LL_A, DBF_SEND, ("SendComplete: HU_TPT: pContext: %p", pContext));

        //
        // Hook the older chain into the first buffer
        //
        if (pContext->Flags & SCF_FLUSH) {
            NDIS_BUFFER_LINKAGE(pContext->PrevMdl) = pContext->OriHUMdl;
        } else if (!(pContext->Flags & SCF_FRAG)) {
            NDIS_BUFFER_LINKAGE(pContext->PrevMdl) = pContext->OriHUMdl;
        }

        //
        // Free the encryption buffer chain
        //
        pMdl = pContext->HUMdl;
        ASSERT(pMdl);

        //
        // In none case, free the esp header.
        //
        if (pContext->Flags & SCF_NOE_TPT) {
            IPSecFreeBuffer(&status, pMdl);
            ASSERT(pContext->PadMdl);
        } else {
            ASSERT(NDIS_BUFFER_LINKAGE(pMdl));
            while (pMdl) {
                pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
                IPSecFreeBuffer(&status, pMdl);
                pMdl = pNextMdl;
            }
        }

        //
        // Free the Pad mdl and zero the reference to the pad mdl in the
        // previous (payload) mdl.
        //
        if (pContext->PadMdl) {
            IPSecFreeBuffer(&status, pContext->PadMdl);
        }

        NDIS_BUFFER_LINKAGE(pContext->BeforePadMdl) = NULL;
    }

    //
    // these are freed in IPSecProtocolSendComplete now.
    //
    if (Packet && (pContext->Flags & SCF_FLUSH)) {

        IPSEC_DEBUG(LL_A, DBF_SEND, ("SendComplete: FLUSH: pContext: %p", pContext));
        //
        // Free the encrypt chain and return the old chain
        //
        pMdl = pContext->FlushMdl;

        ASSERT(pMdl);

        //
        // We will be called at ProtocolSendComplete, where we free this chain.
        //
        fFreeContext = FALSE;

        //
        // If this was just a reinjected packet and never IPSEC'ed, then we know
        // that all the buffers are in line - call the ProtocolSendComplete here
        // and NULL the returned buffer.
        //
        // The best way to do this is to do the same trick we apply on fragmented
        // packets (see IPTransmit) viz. attaching another header and 0'ing out
        // the IPSEC header. There is obviously a perf hit when attaching another IP
        // header since we alloc new MDLs, etc. Hence, we take the approach of using
        // the header in the IPSEC buffers directly.
        //
        // So, here we see if the packet was fragmented; in which case, we let
        // ProtocolSendComplete do the freeing. Else, we free the buffers ourselves.
        //
        {
            PacketContext   *PContext = (PacketContext *)Packet->ProtocolReserved;

            if (PContext->pc_br == NULL ||
                (PContext->pc_ipsec_flags & IPSEC_FLAG_FLUSH)) {

                //
                // this will also free the context.
                //
                IPSecProtocolSendComplete(pContext, pMdl, IP_SUCCESS);
                *ppNewData = NULL;
            }
        }
    } else if (!Packet && (pContext->Flags & SCF_FLUSH)) {
        //
        // ProtocolSendComplete will be called next in IPFragment.
        //
        fFreeContext = FALSE;
    } else if ((pContext->Flags & SCF_MTU)) {

        ULONG NewMTU=0;
        IP_STATUS IpStatus;
        PIPSEC_MTU_CONTEXT pMTUContext = (PIPSEC_MTU_CONTEXT)pContext->pMTUContext;

        ASSERT(pMTUContext);

        if (Status == IP_PACKET_TOO_BIG) {

            if (pMTUContext->TunnelSPI) {
                IpStatus = TCPIP_GET_PINFO(pMTUContext->TunnelDest,
                                           pMTUContext->Src,
                                           &NewMTU,
                                           NULL,
                                           NULL);
                if (IpStatus == IP_SUCCESS) {
                    IPSecProcessPMTU(pMTUContext->TunnelDest,
                                     pMTUContext->Src,
                                     NET_TO_HOST_LONG(pMTUContext->TunnelSPI),
                                     Encrypt,
                                     NewMTU);
                }
            }
            if (pMTUContext->TransportSPI) {

                IpStatus = TCPIP_GET_PINFO(pMTUContext->TransportDest,
                                           pMTUContext->Src,
                                           &NewMTU,
                                           NULL,
                                           NULL);

                if (IpStatus == IP_SUCCESS) {
                    IPSecProcessPMTU(pMTUContext->TransportDest,
                                     pMTUContext->Src,
                                     NET_TO_HOST_LONG(pMTUContext->TransportSPI),
                                     Encrypt,
                                     NewMTU);
                }
            }
        }

        IPSecFreeMemory(pMTUContext);
        pContext->pMTUContext = NULL;
    }


    //
    // If context not needed anymore, free it now.
    //
    if (fFreeContext) {
        IPSecFreeSendCompleteCtx(pContext);
    }

#if DBG
    IPSEC_DEBUG(LL_A, DBF_MDL, ("Exiting IPSecSendComplete"));
    IPSEC_PRINT_CONTEXT(pContext);
    IPSEC_PRINT_MDL(*ppNewData);
#endif
}


VOID
IPSecProtocolSendComplete (
    IN  PVOID           pContext,
    IN  PNDIS_BUFFER    pMdl,
    IN  IP_STATUS       Status
    )
/*++

Routine Description:

    Called by the stack on a SendComplete - frees up IPSEC's Mdls.
    This is only called when IPSEC injects packets into the stack.

Arguments:


    pMdl - points to the data after the IP header. On the send side, this is an MDL chain
            On the recv side this is an IPRcvBuf pointer.

Return Value:

    STATUS_SUCCESS  =>   Forward - Filter driver passes packet on to IP
    STATUS_PENDING  =>   Drop, IPSEC will re-inject

    Others:
        STATUS_INSUFFICIENT_RESOURCES => Drop
        STATUS_UNSUCCESSFUL (error in algo./bad packet received) => Drop

--*/
{
    PNDIS_BUFFER    pNextMdl;
    NTSTATUS        status;
    PIPSEC_SEND_COMPLETE_CONTEXT    pSCContext = (PIPSEC_SEND_COMPLETE_CONTEXT)pContext;

    if (!pSCContext->Flags) {
        return;
    }

    ASSERT(pMdl);

    while (pMdl) {
        pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
        IPSecFreeBuffer(&status, pMdl);
        pMdl = pNextMdl;
    }

    IPSecFreeSendCompleteCtx(pSCContext);

    return;
}


NTSTATUS
IPSecChkReplayWindow(
    IN  ULONG           Seq,
    IN  PSA_TABLE_ENTRY pSA,
    IN  ULONG           Index
    )
/*++

Routine Description:

    Checks if the received packet is in the received window to prevent against
    replay attacks.

    We keep track of the last Sequence number received and ensure that the
    received packets is within the packet window (currently 32 packets).

Arguments:

    Seq - received Sequence number

    pSA - points to the security association

Return Value:

    STATUS_SUCCESS  =>   packet in window
    STATUS_UNSUCCESSFUL => packet rejected

--*/
{
    ULONG   diff;
    ULONG   ReplayWindowSize = REPLAY_WINDOW_SIZE;
    ULONG   lastSeq = pSA->sa_ReplayLastSeq[Index];
    ULONGLONG   bitmap = pSA->sa_ReplayBitmap[Index];
    ULONGLONG   dbgbitmap = bitmap;

    if (pSA->sa_Flags & FLAGS_SA_DISABLE_ANTI_REPLAY_CHECK) {
        return STATUS_SUCCESS;
    }

    if (Seq == pSA->sa_ReplayStartPoint) {
        //
        // first == 0 or wrapped
        //
        IPSEC_DEBUG(LL_A, DBF_SEND, ("Replay: out @1 - Seq: %lx, pSA->sa_ReplayStartPoint: %lx",
                            Seq, pSA->sa_ReplayStartPoint));
        return IPSEC_INVALID_REPLAY_WINDOW1;
    }

#if DBG
    IPSEC_DEBUG(LL_A, DBF_SEND, ("Replay: Last Seq.: %lx, Cur Seq.: %lx, window size %d & bit window (in nibbles) %08lx%08lx",
    lastSeq, Seq, sizeof(bitmap)*8, (ULONG) (dbgbitmap >> 32), (ULONG) dbgbitmap));
#endif

    //
    // new larger Sequence number
    //
    if (Seq > lastSeq) {
        diff = Seq - lastSeq;
        if (diff < ReplayWindowSize) {
            //
            // In window
            // set bit for this packet
            bitmap = (bitmap << diff) | 1;
        } else {
            //
            // This packet has a "way larger" Seq
            //
            bitmap = 1;
        }
        lastSeq = Seq;
        pSA->sa_ReplayLastSeq[Index] = lastSeq;
        pSA->sa_ReplayBitmap[Index] = bitmap;

        //
        // larger is good
        //
        return STATUS_SUCCESS;
    }

    diff = lastSeq - Seq;
    if (diff >= ReplayWindowSize) {
        //
        // too old or wrapped
        //
        IPSEC_DEBUG(LL_A, DBF_SEND, ("Replay: out @3 - Seq: %lx, lastSeq: %lx",
                            Seq, lastSeq));
        return IPSEC_INVALID_REPLAY_WINDOW2;
    }

    if (bitmap & ((ULONG64)1 << diff)) {
        //
        // this packet already seen
        //
        IPSEC_DEBUG(LL_A, DBF_SEND, ("Replay: out @4 - Seq: %lx, lastSeq: %lx",
                            Seq, lastSeq));
        return IPSEC_DUPE_PACKET;
    }

    //
    // mark as seen
    //
    bitmap |= ((ULONG64)1 << diff);


    pSA->sa_ReplayLastSeq[Index] = lastSeq;
    pSA->sa_ReplayBitmap[Index] = bitmap;

    //
    // out of order but good
    //
    return STATUS_SUCCESS;
}


NTSTATUS
IPSecPrepareReinjectPacket(
    IN  PVOID                   pData,
    IN  PNDIS_PACKET_EXTENSION  pPktExt,
    OUT PNDIS_BUFFER        * ppHdrMdl,
    OUT PUCHAR                  * ppIPH,
    OUT PNDIS_BUFFER        * ppOptMdl,
    OUT PNDIS_BUFFER        * ppDataMdl,
    OUT PIPSEC_SEND_COMPLETE_CONTEXT * ppContext,
    OUT PULONG                  pLen
    )

{
    
    PNDIS_BUFFER    pOptMdl = NULL;
    PNDIS_BUFFER    pHdrMdl = NULL;
    PNDIS_BUFFER    pDataMdl = NULL;
    ULONG           len, ulOptLen=0;
    ULONG           len1;
    ULONG           hdrLen;
    IPRcvBuf        *pNextData;
    IPHeader UNALIGNED * pIPH;
    IPHeader UNALIGNED * pIPH1;
    ULONG           offset;
    NTSTATUS        status;
    ULONG           tag = IPSEC_TAG_REINJECT;
    PIPSEC_SEND_COMPLETE_CONTEXT        pContext;
    //NDIS_PACKET_EXTENSION               PktExt = {0};
    PNDIS_IPSEC_PACKET_INFO             IPSecPktInfo;

    //
    // Allocate context for IPSecSencComplete use
    //
    pContext = IPSecAllocateSendCompleteCtx(tag);

    if (!pContext) {
        IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. SendCtx"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSEC_INCREMENT(g_ipsec.NumSends);

    IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));

#if DBG
    RtlCopyMemory(pContext->Signature, "ISC5", 4);
#endif

    //
    // Pass along IPSEC_PKT_INFO for transport offload if needed
    //
    if (pPktExt) {
        IPSecPktInfo = pPktExt->NdisPacketInfo[IpSecPacketInfo];

        if (IPSecPktInfo) {
            ASSERT(IPSecPktInfo->Receive.CryptoStatus == CRYPTO_SUCCESS);
            ASSERT(IPSecPktInfo->Receive.CRYPTO_DONE);

            //
            // Only interested in NEXT_CRYPTO_DONE if packet is reinjected.
            //
            if (!(IPSecPktInfo->Receive.NEXT_CRYPTO_DONE)) {
                IPSecPktInfo = NULL;
            }
        }
    } else {
        IPSecPktInfo = NULL;
    }

    if (IPSecPktInfo) {
        //
        // Pass the IPSecPktInfo to IPTransmit.
        //
        pContext->PktExt = IPSecAllocatePktExt(IPSEC_TAG_HW_PKTEXT);

        if (!pContext->PktExt) {
            IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. PktInfo"));
            IPSecFreeSendCompleteCtx(pContext);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pContext->Flags |= SCF_PKTEXT;

        RtlCopyMemory(  pContext->PktExt,
                        IPSecPktInfo,
                        sizeof(NDIS_IPSEC_PACKET_INFO));
        //PktExt.NdisPacketInfo[IpSecPacketInfo] = (PNDIS_IPSEC_PACKET_INFO)(pContext->PktExt);
    }

    //
    // Re-package into MDLs for the send - these will be released on the
    // SendComplete.
    //
    // FUTURE WORK: right now we copy the data out, this shd be optimized
    // by calling IPRcvPacket and using buffer ownership.
    //
    IPSEC_GET_TOTAL_LEN_RCV_BUF(pData, &len);

    //
    // IPH is at head of pData
    //
    IPSecQueryRcvBuf(pData, (PVOID)&pIPH, &len1);

    //
    // Allocate MDL for the IP header
    //
    hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

    if (len <= hdrLen) {
        IPSEC_DEBUG(LL_A, DBF_ESP, ("TotLen of the buffers %d <= hdrLen %d", len, hdrLen));
        if (pContext->PktExt) {
            IPSecFreeMemory(pContext->PktExt);
        }
        IPSecFreeSendCompleteCtx(pContext);
        return STATUS_INVALID_PARAMETER;
    }

    IPSecAllocateBuffer(&status,
                        &pHdrMdl,
                        (PUCHAR *)&pIPH1,
                        sizeof(IPHeader),
                        tag);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. header MDL"));
        if (pContext->PktExt) {
            IPSecFreeMemory(pContext->PktExt);
        }
        IPSecFreeSendCompleteCtx(pContext);
        return status;
    }

    //
    // Copy over the header
    //
    RtlCopyMemory(pIPH1, pIPH, sizeof(IPHeader));

    len -= hdrLen;
    offset = hdrLen;

    IPSecAllocateBuffer(&status,
                        &pDataMdl,
                        NULL,
                        len,
                        tag);

    if (!NT_SUCCESS(status)) {
        NTSTATUS    ntstatus;

        IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. encrypt MDL"));
        IPSecFreeBuffer(&ntstatus, pHdrMdl);
        if (pContext->PktExt) {
            IPSecFreeMemory(pContext->PktExt);
        }
        IPSecFreeSendCompleteCtx(pContext);
        return status;
    }

    if (hdrLen > sizeof(IPHeader)) {
        PUCHAR  Options;
        PUCHAR  pOpt;

        //
        // Options present - another Mdl
        //
        IPSecAllocateBuffer(&status,
                            &pOptMdl,
                            &Options,
                            hdrLen - sizeof(IPHeader),
                            tag);
        ulOptLen = hdrLen - sizeof(IPHeader);
        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;

            IPSecFreeBuffer(&ntstatus, pHdrMdl);
            IPSecFreeBuffer(&ntstatus, pDataMdl);
            if (pContext->PktExt) {
                IPSecFreeMemory(pContext->PktExt);
            }
            IPSecFreeSendCompleteCtx(pContext);
            IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. options MDL"));
            return status;
        }

        //
        // Copy over the options - we need to fish for it - could be in next MDL
        //
        if (len1 >= hdrLen) {
            //
            // all in this buffer - jump over IP header
            //
            RtlCopyMemory(Options, (PUCHAR)(pIPH + 1), hdrLen - sizeof(IPHeader));
        } else {
            //
            // next buffer, copy from next
            //
            pData = IPSEC_BUFFER_LINKAGE(pData);
            IPSecQueryRcvBuf(pData, (PVOID)&pOpt, &len1);
            RtlCopyMemory(Options, pOpt, hdrLen - sizeof(IPHeader));
            offset = hdrLen - sizeof(IPHeader);
        }

        //
        // Link in the Options buffer
        //
        NDIS_BUFFER_LINKAGE(pHdrMdl) = pOptMdl;
        NDIS_BUFFER_LINKAGE(pOptMdl) = pDataMdl;
    } else {
        //
        // Link in the Data buffer
        //
        NDIS_BUFFER_LINKAGE(pHdrMdl) = pDataMdl;
    }

    //
    // Now bulk copy the entire data
    //
    IPSEC_COPY_FROM_RCVBUF( pDataMdl,
                            pData,
                            len,
                            offset);

    //
    // Fill up the SendCompleteContext
    //
    pContext->FlushMdl = pHdrMdl;
    pContext->Flags |= SCF_FLUSH;
    *ppHdrMdl = pHdrMdl;
    *ppOptMdl = pOptMdl;
    *ppDataMdl = pDataMdl;
    *ppContext = pContext;
    //
    // Per SanjayKa (tcpipdev) this should include the option
    // length too
    //
    *pLen   = len + ulOptLen ;
    *ppIPH   = (PUCHAR)pIPH;
    return STATUS_SUCCESS;
}

NTSTATUS 
IPSecReinjectPreparedPacket(
    IN PNDIS_BUFFER pHdrMdl,
    IN PIPSEC_SEND_COMPLETE_CONTEXT pContext,
    IN ULONG len,
    IN PUCHAR  pIPHeader
    )
{
    IPOptInfo       optInfo;
    IPHeader UNALIGNED * pIPH = (IPHeader UNALIGNED *)pIPHeader;
    NTSTATUS status;
    NDIS_PACKET_EXTENSION               PktExt = {0};


    if (pContext->PktExt){
        PktExt.NdisPacketInfo[IpSecPacketInfo] = (PNDIS_IPSEC_PACKET_INFO)(pContext->PktExt);
        }

    //
    // Call IPTransmit with proper Protocol type so it takes this packet
    // at *face* value.
    //
    optInfo = g_ipsec.OptInfo;
    optInfo.ioi_options = (PUCHAR)&PktExt;
    optInfo.ioi_flags |= IP_FLAG_IPSEC;
    status = TCPIP_IP_TRANSMIT( &g_ipsec.IPProtInfo,
                                pContext,
                                pHdrMdl,
                                len,
                                pIPH->iph_dest,
                                pIPH->iph_src,
                                &optInfo,
                                NULL,
                                pIPH->iph_protocol,
                                NULL);

    //
    // IPTransmit may fail to allocate a Packet so it returns
    // IP_NO_RESOURCES.  If this is the case, we need to free the MDL chain.
    // This is taken care of in IPTransmit().
    //
    // Even in the synchronous case, we free the MDL chain in ProtocolSendComplete (called by IPSecSendComplete).
    // So, we dont call anything here.
    //

    return  STATUS_SUCCESS;
}


NTSTATUS 
IPSecReinjectPacket(
    IN  PVOID                   pData,
    IN  PNDIS_PACKET_EXTENSION  pPktExt
    )
/*++

Routine Description:

    Re-injects packet into the stack's send path - makes a copy
    of the packet then calls into IPTransmit, making sure the SendComplete
    Context is setup properly.

Arguments:

    pData - Points to "un-tunneled" data, starting at the encapsulated IP header

    pPktExt - Points to the NDIS Packet extension structure

Return Value:

    Status of copy/transmit operation

--*/    
{
    PNDIS_BUFFER pHdrMdl = NULL, pDataMdl = NULL, pOptMdl = NULL;
    PUCHAR  pIPH = NULL;
    PIPSEC_SEND_COMPLETE_CONTEXT pContext = NULL;                    
    ULONG DataLen;
    NTSTATUS ReinjectStatus;
    // If this function fails it releases memory on it's own
    ReinjectStatus = IPSecPrepareReinjectPacket(
                             pData, 
                             pPktExt,
                             &pHdrMdl,
                             &pIPH,
                             &pOptMdl,
                             &pDataMdl,
                             &pContext
                            ,&DataLen);                 

    if (STATUS_SUCCESS != ReinjectStatus){
        return ReinjectStatus;
        }
    
    // This function always returns success
    ReinjectStatus = IPSecReinjectPreparedPacket(
                                        pHdrMdl,
                                        pContext,
                                        DataLen,
                                        pIPH);    
    return ReinjectStatus;
}


NTSTATUS
IPSecQueuePacket(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PVOID           pDataBuf
    )
/*++

Routine Description:

    Copies the packet into the SAs Stall Queue.

Arguments:

Return Value:

--*/
{
    ULONG   len;
    ULONG   len1;
    PNDIS_BUFFER    pOptMdl;
    PNDIS_BUFFER    pHdrMdl;
    PNDIS_BUFFER    pDataMdl;
    KIRQL   kIrql;
    ULONG   hdrLen;
    IPHeader UNALIGNED * pIPH;
    IPHeader UNALIGNED * pIPH1;
    NTSTATUS    status;
    ULONG       offset;
    ULONG       tag = IPSEC_TAG_STALL_QUEUE;
    PNDIS_BUFFER    pData = (PNDIS_BUFFER)pDataBuf;

    //
    // Queue last packet so if we already have one free it first.
    //
    if (pSA->sa_BlockedBuffer != NULL) {
        IPSecFlushQueuedPackets(pSA, STATUS_ABANDONED);
    }

    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);

    //
    // Need a lock here - sa_Lock.
    //
    if (pSA->sa_State == STATE_SA_LARVAL) {

        IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Pending packet: %p", pSA));

        //
        // Copy over the Mdl chain to this SAs pend queue.
        //
        IPSEC_GET_TOTAL_LEN(pData, &len);

        //
        // IPH is at head of pData
        //
        IPSecQueryNdisBuf(pData, &pIPH, &len1);

        hdrLen = (pIPH->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2;

        IPSecAllocateBuffer(&status,
                            &pHdrMdl,
                            (PUCHAR *)&pIPH1,
                            sizeof(IPHeader),
                            tag);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. header MDL"));
            RELEASE_LOCK(&pSA->sa_Lock, kIrql);
            return status;
        }

        IPSEC_DEBUG(LL_A, DBF_POOL, ("IPSecQueuePacket: pHdrMdl: %p, pIPH1: %p", pHdrMdl, pIPH1));

        //
        // Copy over the header
        //
        RtlCopyMemory(pIPH1, pIPH, sizeof(IPHeader));

        len -= hdrLen;
        offset = hdrLen;

        IPSecAllocateBuffer(&status,
                            &pDataMdl,
                            NULL,
                            len,
                            tag);

        if (!NT_SUCCESS(status)) {
            NTSTATUS    ntstatus;
            IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. encrypt MDL"));
            IPSecFreeBuffer(&status, pHdrMdl);
            RELEASE_LOCK(&pSA->sa_Lock, kIrql);
            return status;
        }

        if (hdrLen > sizeof(IPHeader)) {
            PUCHAR  Options;
            PUCHAR  pOpt;

            //
            // Options present - another Mdl
            //
            IPSecAllocateBuffer(&status,
                                &pOptMdl,
                                &Options,
                                hdrLen - sizeof(IPHeader),
                                tag);

            if (!NT_SUCCESS(status)) {
                IPSecFreeBuffer(&status, pHdrMdl);
                IPSecFreeBuffer(&status, pDataMdl);
                IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. options MDL"));
                RELEASE_LOCK(&pSA->sa_Lock, kIrql);
                return status;
            }

            //
            // Copy over the options - we need to fish for it - could be in next MDL
            //
            if (len1 >= hdrLen) {
                //
                // all in this buffer - jump over IP header
                //
                RtlCopyMemory(Options, (PUCHAR)(pIPH + 1), hdrLen - sizeof(IPHeader));
            } else {
                //
                // next buffer, copy from next
                //
                pData = NDIS_BUFFER_LINKAGE(pData);
                IPSecQueryNdisBuf(pData, &pOpt, &len1);
                RtlCopyMemory(Options, pOpt, hdrLen - sizeof(IPHeader));
                offset = hdrLen - sizeof(IPHeader);
            }

            //
            // Link in the Options buffer
            //
            NDIS_BUFFER_LINKAGE(pHdrMdl) = pOptMdl;
            NDIS_BUFFER_LINKAGE(pOptMdl) = pDataMdl;
        } else {
            //
            // Link in the Data buffer
            //
            NDIS_BUFFER_LINKAGE(pHdrMdl) = pDataMdl;
        }

        //
        // Now bulk copy the entire data
        //
        IPSEC_COPY_FROM_NDISBUF(pDataMdl,
                                pData,
                                len,
                                offset);

        pSA->sa_BlockedBuffer = pHdrMdl;
        pSA->sa_BlockedDataLen = len;

        IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Queued buffer: %p on SA: %p, psa->sa_BlockedBuffer: %p", pHdrMdl, pSA, &pSA->sa_BlockedBuffer));
    }

    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    return  STATUS_SUCCESS;
}


VOID
IPSecIPAddrToUnicodeString(
    IN  IPAddr  Addr,
    OUT PWCHAR  UCIPAddrBuffer
    )
/*++

Routine Description:

    Converts an IP addr into a wchar string

Arguments:

Return Value:

--*/
{
    UINT    IPAddrCharCount=0;
    UINT    i;
    UCHAR   IPAddrBuffer[(sizeof(IPAddr) * 4)];
    UNICODE_STRING   unicodeString;
    ANSI_STRING      ansiString;

    //
	// Convert the IP address into a string.
	//	
	for (i = 0; i < sizeof(IPAddr); i++) {
		UINT    CurrentByte;
		
		CurrentByte = Addr & 0xff;
		if (CurrentByte > 99) {
			IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 100) + '0';
			CurrentByte %= 100;
			IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
			CurrentByte %= 10;
		} else if (CurrentByte > 9) {
			IPAddrBuffer[IPAddrCharCount++] = (CurrentByte / 10) + '0';
			CurrentByte %= 10;
		}
		
		IPAddrBuffer[IPAddrCharCount++] = CurrentByte + '0';
		if (i != (sizeof(IPAddr) - 1))
			IPAddrBuffer[IPAddrCharCount++] = '.';
		
		Addr >>= 8;
	}

	//
	// Unicode the strings.
	//
	*UCIPAddrBuffer = UNICODE_NULL;

	unicodeString.Buffer = UCIPAddrBuffer;
	unicodeString.Length = 0;
	unicodeString.MaximumLength =
        (USHORT)(sizeof(WCHAR) * ((sizeof(IPAddr) * 4) + 1));
	ansiString.Buffer = IPAddrBuffer;
	ansiString.Length = (USHORT)IPAddrCharCount;
	ansiString.MaximumLength = (USHORT)IPAddrCharCount;

	RtlAnsiStringToUnicodeString(   &unicodeString,
	                                &ansiString,
                            	    FALSE);
}


VOID
IPSecCountToUnicodeString(
    IN  ULONG   Count,
    OUT PWCHAR  UCCountBuffer
    )
/*++

Routine Description:

    Converts a count a wchar string

Arguments:

Return Value:

--*/
{
	UNICODE_STRING  unicodeString;

	//
	// Unicode the strings.
	//
	*UCCountBuffer = UNICODE_NULL;

	unicodeString.Buffer = UCCountBuffer;
	unicodeString.Length = 0;
	unicodeString.MaximumLength = (USHORT)sizeof(WCHAR) * (MAX_COUNT_STRING_LEN + 1);

	RtlIntegerToUnicodeString ( Count,
                                10, // Base
	                            &unicodeString);
}


VOID
IPSecESPStatus(
    IN  UCHAR       StatusType,
    IN  IP_STATUS   StatusCode,
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  IPAddr      Src,
    IN  ULONG       Param,
    IN  PVOID       Data
    )
/*++

Routine Description:

    Handle a status indication for ESP, mostly for PMTU handling.

Arguments:

    StatusType  - Type of status.
    StatusCode  - Code identifying IP_STATUS.
    OrigDest    - If this is NET status, the original dest. of DG that
                  triggered it.
    OrigSrc     - The original src corr. OrigDest.
    Src         - IP address of status originator (could be local or remote).
    Param       - Additional information for status - i.e. the param field of
                  an ICMP message.
    Data        - Data pertaining to status - for NET status, this is the
                  first 8 bytes of the original DG.

Return Value:

--*/
{
    IPSEC_DEBUG(LL_A, DBF_PMTU, ("PMTU for ESP recieved from %lx to %lx", OrigSrc, OrigDest));

    if (StatusType == IP_NET_STATUS && StatusCode == IP_SPEC_MTU_CHANGE) {
        IPSecProcessPMTU(   OrigDest,
                            OrigSrc,
                            NET_TO_HOST_LONG(((UNALIGNED ESP *)Data)->esp_spi),
                            Encrypt,
                            Param);
   }
}


VOID
IPSecAHStatus(
    IN  UCHAR       StatusType,
    IN  IP_STATUS   StatusCode,
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  IPAddr      Src,
    IN  ULONG       Param,
    IN  PVOID       Data
    )
/*++

Routine Description:

    Handle a status indication for AH, mostly for PMTU handling.

Arguments:

    StatusType  - Type of status.
    StatusCode  - Code identifying IP_STATUS.
    OrigDest    - If this is NET status, the original dest. of DG that
                  triggered it.
    OrigSrc     - The original src corr. OrigDest.
    Src         - IP address of status originator (could be local or remote).
    Param       - Additional information for status - i.e. the param field of
                  an ICMP message.
    Data        - Data pertaining to status - for NET status, this is the
                  first 8 bytes of the original DG.

Return Value:

--*/
{
    IPSEC_DEBUG(LL_A, DBF_PMTU, ("PMTU for AH recieved from %lx to %lx", OrigSrc, OrigDest));

    if (StatusType == IP_NET_STATUS && StatusCode == IP_SPEC_MTU_CHANGE) {
        IPSecProcessPMTU(   OrigDest,
                            OrigSrc,
                            NET_TO_HOST_LONG(((UNALIGNED AH *)Data)->ah_spi),
                            Auth,
                            Param);
   }
}


VOID
IPSecProcessPMTU(
    IN  IPAddr      OrigDest,
    IN  IPAddr      OrigSrc,
    IN  tSPI        SPI,
    IN  OPERATION_E Operation,
    IN  ULONG       NewMTU
    )
/*++

Routine Description:

    Process PMTU.

Arguments:

    OrigDest    - The original dest. of DG that triggered it.
    OrigSrc     - The original src corr. OrigDest.
    SPI         - SPI of the outer IPSec header.
    Operation   - AH or ESP operation of IPSec.
    NewMTU      - The new MTU indicated by the intermediate gateway.

Return Value:

--*/
{
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    IPAddr          SADest;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;
    BOOLEAN         fFound = FALSE;

    IPSEC_DEBUG(LL_A, DBF_PMTU, ("IPSecProcessPMTU: NewMTU arrived %lx", NewMTU));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // Search Tunnel and Masked filter list for an outbound SA that matches
    // OrigDest, OrigSrc and SPI.  If such an SA is found, update its NewMTU
    // field so that next packet using the SA propogate a smaller MTU
    // back to TCP/IP stack.  Tunnel filter should be searched first because
    // if in the case transport over tunnel operation, the packet going out
    // will have the Tunnel header.
    //
    for (   Index = OUTBOUND_TUNNEL_FILTER;
            (Index >= OUTBOUND_TRANSPORT_FILTER) && !fFound;
            Index -= TRANSPORT_TUNNEL_INCREMENT) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                !fFound && pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    (SAIndex < pFilter->SAChainSize) && !fFound;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    if (pSA->sa_Flags & FLAGS_SA_TUNNEL) {
                        SADest = pSA->sa_TunnelAddr;
                    } else {
                        SADest = pSA->SA_DEST_ADDR;
                    }

                    if (SADest == OrigDest &&
                        pSA->sa_SPI == SPI &&
                        pSA->sa_Operation[pSA->sa_NumOps - 1] == Operation) {
                        //
                        // We matched the triple for a unique SA so this must be it.
                        //
                        fFound = TRUE;
                        break;
                    }
                }
            }
        }
    }

    //
    // Update the NewMTU field of the found SA.  We only do this if the new
    // MTU is lower than the current one.
    //
    if (fFound && NewMTU < pSA->sa_NewMTU && NewMTU > sizeof(IPHeader)) {
        IPSEC_SET_VALUE(pSA->sa_NewMTU, NewMTU);
        IPSEC_DEBUG(LL_A, DBF_PMTU, ("NewMTU %lx for pSA %p", NewMTU, pSA));
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}


IPSEC_ACTION
IPSecRcvFWPacket(
    IN  PCHAR   pIPHeader,
    IN  PVOID   pData,
    IN  UINT    DataLength,
    IN  UCHAR   DestType
    )
/*++

Routine Description:

    To match a inbound tunnel rule for a packet received on the inbound forward path.

Arguments:

    pIPHeader   - the IP header
    pData       - the data portion of the packet
    DataLength  - data length

Return Value:

    eFORWARD
    eDROP

--*/
{
    PSA_TABLE_ENTRY pSA;
    PSA_TABLE_ENTRY pNextSA;
    USHORT          FilterFlags;
    NTSTATUS        status;
    IPSEC_ACTION    action = eFORWARD;
    IPRcvBuf        RcvBuf = {0};

    //
    // We are not interested in non multicast broadcast packets.
    //
    if (IS_BCAST_DEST(DestType) && !IPSEC_MANDBCAST_PROCESS()) {
        return  action;
    }

    //
    // Build a fake IPRcvBuf so we can reuse the classification routine.
    //
    RcvBuf.ipr_buffer = pData;
    RcvBuf.ipr_size = DataLength;

    status = IPSecClassifyPacket(   (PUCHAR)pIPHeader,
                                    &RcvBuf,
                                    &pSA,
                                    &pNextSA,
                                    &FilterFlags,
#if GPC
                                    0,
#endif
                                    FALSE,
                                    TRUE,
                                    TRUE,
                                    FALSE, //Not a recv reinject
                                    FALSE, // Not a verify Call
                                    DestType,
                                    NULL);

    if (status != STATUS_SUCCESS) {
        if (status == STATUS_PENDING) {
            //
            // SA is being negotiated - drop.
            //
            action = eDROP;
        } else {
            //
            // No Filter/SA match found - forward.
            //
            //action = eFORWARD;
        }
    } else {
        if (FilterFlags) {
            if (FilterFlags & FILTER_FLAGS_DROP) {
                //
                // Drop filter matched - drop.
                //
                action = eDROP;
            } else if (FilterFlags & FILTER_FLAGS_PASS_THRU) {
                //
                // Pass-thru filter matched - forward.
                //
                //action = eFORWARD;
            } else {
                ASSERT(FALSE);
            }
        } else {
            ASSERT(pSA);

            //
            // Bug 708118 ; PolicyAgent does not respond
            // fast enough to a local interface going away
            // leading to spurious assert below. 
            // Caused multiple BVT breaks.
            // ASSERT(pSA->sa_Flags & FLAGS_SA_TUNNEL);
            //
            
            //
            // A real SA is matched - drop.
            //
            action = eDROP;
            IPSecDerefSA(pSA);
        }
    }

    return  action;
}


NTSTATUS
IPSecRekeyInboundSA(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Rekey a SA because we hit the rekey threshold.

Arguments:


Return Value:


--*/
{
    PSA_TABLE_ENTRY pLarvalSA;
    PSA_TABLE_ENTRY pOutboundSA;
    NTSTATUS        status;
    KIRQL           kIrql;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // If SA already expired, no rekey is necessary.
    //
    pOutboundSA = pSA->sa_AssociatedSA;

    if (!pOutboundSA) {
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
        return  STATUS_UNSUCCESSFUL;
    }

    if (!(pOutboundSA->sa_Flags & FLAGS_SA_REKEY_ORI)) {
        pOutboundSA->sa_Flags |= FLAGS_SA_REKEY_ORI;

        IPSEC_DEBUG(LL_A, DBF_SA, ("SA: %p expiring soon", pOutboundSA));


        //
        // Rekey, but still continue to use this SA until the actual expiry.
        //
        status = IPSecNegotiateSA(  pOutboundSA->sa_Filter,
                                    pOutboundSA->sa_uliSrcDstAddr,
                                    pOutboundSA->sa_uliProtoSrcDstPort,
                                    pOutboundSA->sa_NewMTU,
                                    &pLarvalSA,
                                    pOutboundSA->sa_DestType,
                                    &pOutboundSA->sa_EncapContext);

        if (!NT_SUCCESS(status) && status != STATUS_DUPLICATE_OBJECTID) {
            pOutboundSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
            status = STATUS_UNSUCCESSFUL;
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


NTSTATUS
IPSecRekeyOutboundSA(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Rekey a SA because we hit the rekey threshold.

Arguments:


Return Value:


--*/
{
    PSA_TABLE_ENTRY pLarvalSA;
    NTSTATUS        status=STATUS_FAIL_CHECK;
    KIRQL           kIrql;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    if (!(pSA->sa_Flags & FLAGS_SA_REKEY_ORI)) {
        pSA->sa_Flags |= FLAGS_SA_REKEY_ORI;

        IPSEC_DEBUG(LL_A, DBF_SA, ("SA: %p expiring soon", pSA));

        //
        // Rekey, but still continue to use this SA until the actual expiry.
        //
        status = IPSecNegotiateSA(  pSA->sa_Filter,
                                    pSA->sa_uliSrcDstAddr,
                                    pSA->sa_uliProtoSrcDstPort,
                                    pSA->sa_NewMTU,
                                    &pLarvalSA,
                                    pSA->sa_DestType,
                                    &pSA->sa_EncapContext);

        if (!NT_SUCCESS(status) && status != STATUS_DUPLICATE_OBJECTID) {
            pSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
            status = STATUS_UNSUCCESSFUL;
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


NTSTATUS
IPSecPuntInboundSA(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Punt a SA because we have exceeded the rekey threshold.

Arguments:


Return Value:


--*/
{
    PSA_TABLE_ENTRY pOutboundSA;
    KIRQL           kIrql;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // If SA already expired, no punt is necessary.
    //
    pOutboundSA = pSA->sa_AssociatedSA;

    if (pOutboundSA && IPSEC_GET_VALUE(pOutboundSA->sa_Reference) > 1 &&
        !(pOutboundSA->sa_Flags & FLAGS_SA_EXPIRED) &&
        pOutboundSA->sa_State == STATE_SA_ACTIVE) {
        pOutboundSA->sa_Flags |= FLAGS_SA_EXPIRED;

        IPSEC_DEBUG(LL_A, DBF_SA, ("SA: %p has expired", pOutboundSA));

        if (pOutboundSA->sa_Flags & FLAGS_SA_REKEY_ORI) {
            pOutboundSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;

            if (pOutboundSA->sa_RekeyLarvalSA) {
                if (pOutboundSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA) {
                    pOutboundSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA = NULL;
                }
            }
        }
    }

    if (NULL == pOutboundSA) {
        if (pSA->sa_State == STATE_SA_LARVAL_ACTIVE) {
            IPSecDeleteLarvalSA(pSA);
        }
    } else {
        //
        // Delete this SA and expire the corresponding inbound SA.
        //
        IPSecDeleteInboundSA(pSA);
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecPuntOutboundSA(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Punt a SA because we have exceeded the rekey threshold.

Arguments:


Return Value:


--*/
{
    KIRQL   kIrql;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    if (IPSEC_GET_VALUE(pSA->sa_Reference) > 1 &&
        !(pSA->sa_Flags & FLAGS_SA_EXPIRED) &&
        pSA->sa_State == STATE_SA_ACTIVE &&
        pSA->sa_AssociatedSA != NULL) {
        pSA->sa_Flags |= FLAGS_SA_EXPIRED;

        IPSEC_DEBUG(LL_A, DBF_SA, ("SA: %p has expired", pSA));

        if (pSA->sa_Flags & FLAGS_SA_REKEY_ORI) {
            pSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;

            if (pSA->sa_RekeyLarvalSA) {
                if (pSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA) {
                    pSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA = NULL;
                }
            }
        }

        //
        // Delete this SA and expire the corresponding inbound SA.
        //
        IPSecExpireInboundSA(pSA->sa_AssociatedSA);
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


BOOLEAN
IPSecQueryStatus(
    IN  CLASSIFICATION_HANDLE   GpcHandle
    )
/*++

Routine Description:

    Query IPSec to see if IPSec applies to this flow.  TCP/IP then decides whether
    to take fast or slow path in IPTransmit.

Arguments:

    GpcHandle

Return Value:

    TRUE    - if IPSec applies to this packet; slow path
    FALSE   - if IPSec doesn't apply to this packet; fast path

--*/
{
    PLIST_ENTRY pFilterList;
    PFILTER     pFilter;
    NTSTATUS    status;

#if DBG
    //
    // This should force all traffic going through IPSecHandlePacket.
    //
    if (DebugQry) {
        return  TRUE;
    }
#endif

    if ((IS_DRIVER_BLOCK()) || (IS_DRIVER_BOOTSTATEFUL()))
        return TRUE;

    if (IS_DRIVER_BYPASS() || IPSEC_DRIVER_IS_EMPTY()) {
        return  FALSE;
    }

    //
    // If no GpcHandle passed in, take slow path.
    //
    if (!GpcHandle) {
        return  TRUE;
    }

    //
    // Search in the tunnel filter list first.
    //
    pFilterList = &g_ipsec.FilterList[OUTBOUND_TUNNEL_FILTER];

    //
    // If any tunnel filters exist, take slow path.
    //
    if (!IsListEmpty(pFilterList)) {
        return  TRUE;
    }

#if GPC
    //
    // Search the local GPC filter list.
    //
    pFilterList = &g_ipsec.GpcFilterList[OUTBOUND_TRANSPORT_FILTER];

    //
    // If any generic filters exist, take slow path.
    //
    if (!IsListEmpty(pFilterList)) {
        return  TRUE;
    }

    pFilter = NULL;

    //
    // Use GpcHandle directly to get the filter installed.
    //
    status = GPC_GET_CLIENT_CONTEXT(g_ipsec.GpcClients[GPC_CF_IPSEC_OUT],
                                    GpcHandle,
                                    &pFilter);

    if (status == STATUS_INVALID_HANDLE) {
        //
        // Handle has expired, take slow path because re-classification will
        // have to be applied to this flow from now on until connection breaks.
        // So why bother performing a re-classification here?
        //
        return  TRUE;
    }

    return  pFilter != NULL;
#else
    return  TRUE;
#endif
}

NTSTATUS IPSecDisableUdpXsum(
    IN IPRcvBuf *pData
)

{

    LONG UdpLen;
    NATENCAP *pUdp;
    NTSTATUS status;


    IPSecQueryRcvBuf(pData, &pUdp, &UdpLen);
    if (UdpLen > 8) {
        pUdp->uh_xsum = 0;
        return STATUS_SUCCESS;
    }
    status=IPSecSetRecvByteByOffset(pData,6,0);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    status=IPSecSetRecvByteByOffset(pData,7,0);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    return status;

}

NTSTATUS AddShimContext(IN PUCHAR *pIpHeader,
                        IN PVOID pData,
                        IPSEC_UDP_ENCAP_CONTEXT *pNatContext)
{

    LONG DataLen;
    PUCHAR pRcvData;
    BYTE Ports[TCP_HEADER_SIZE];
    NTSTATUS status=STATUS_SUCCESS;
    PUCHAR pProtocolData=NULL;
    IPHeader UNALIGNED *pIPH = (IPHeader UNALIGNED *)*pIpHeader;
    BOOL bSlowPath=FALSE;
    int i;
    LONG MinLen;
    DWORD TmpContext;

    IPSecQueryRcvBuf((IPRcvBuf *)pData, &pRcvData, &DataLen);

    if (pIPH->iph_protocol == PROTOCOL_UDP ||
        pIPH->iph_protocol == PROTOCOL_TCP) {

        if (pIPH->iph_protocol == PROTOCOL_UDP) {
            MinLen=UDP_HEADER_SIZE;
        } else {
            MinLen = TCP_HEADER_SIZE;
        }
        if (DataLen >= MinLen) {
            pProtocolData=pRcvData;
        } else {
            pProtocolData=&Ports[0];
            bSlowPath=TRUE;
            DataLen= MinLen;
            status = IPSecGetRecvBytesByOffset(pData,
                                               0,
                                               Ports,
                                               MinLen);
            if (!NT_SUCCESS(status)) {
                return status;
            }
        }
    } else {
        pProtocolData = pRcvData;
    }

    memcpy(&TmpContext,pNatContext,sizeof(DWORD));

    status=(g_ipsec.ShimFunctions.pIncomingPacketRoutine)(pIPH,
                                                          pProtocolData,
                                                          DataLen,
                                                          ULongToHandle(TmpContext));
    IPSEC_DEBUG(LL_A, DBF_NATSHIM,("ProcessIncoming: InContext %x ret %x",TmpContext,status));

    return status;
}


NTSTATUS
GetIpBufferForICMP(
    PUCHAR pucIPHeader,
    PVOID pvData,
    PUCHAR * ppucIpBuffer,
    PUCHAR * ppucStorage
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    IPHeader UNALIGNED * pIPHdr = (IPHeader UNALIGNED *) pucIPHeader;
    PMDL pMdlChain = (PMDL) pvData;
    ULONG uOffset = 0;
    ULONG uDataSize = 0;
    PUCHAR pucStorage = NULL;
    ULONG uLastWalkedMdlOffset = 0;
    PUCHAR pucIpBuffer = NULL;


    uDataSize = ((pIPHdr->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2) + 8;

    ntStatus = IPSecGetSendBuffer(
                   &pMdlChain,
                   uOffset,
                   uDataSize,
                   (PVOID) pucStorage,
                   &uLastWalkedMdlOffset,
                   &pucIpBuffer
                   );
    if (ntStatus == STATUS_BUFFER_OVERFLOW) {

        pucStorage = IPSecAllocateMemory(uDataSize, IPSEC_TAG_ICMP);
        if (!pucStorage) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            BAIL_ON_NTSTATUS_ERROR(ntStatus);
        }
        ntStatus = IPSecGetSendBuffer(
                       &pMdlChain,
                       uOffset,
                       uDataSize,
                       (PVOID) pucStorage,
                       &uLastWalkedMdlOffset,
                       &pucIpBuffer
                       );

    }
    BAIL_ON_NTSTATUS_ERROR(ntStatus);

    *ppucIpBuffer = pucIpBuffer;
    *ppucStorage = pucStorage;
    return (ntStatus);

error:

    if (pucStorage) {
        IPSecFreeMemory(pucStorage);
    }

    *ppucIpBuffer = NULL;
    *ppucStorage = NULL;
    return (ntStatus);
}


NTSTATUS
IPSecGetSendBuffer(
    PMDL * ppMdlChain,
    ULONG uOffset,
    ULONG uBytesNeeded,
    PVOID pvStorage,
    PULONG puLastWalkedMdlOffset,
    PUCHAR * ppucReturnBuf
    )
/*++

Routine Description:

    Provides a flat buffer of the specified size from a MDL chain
    starting at the specified offset.

Arguments:

    ppMdlChain - Pointer to a pointer to a chain of MDLs describing the source
                 data. On successful return, this points to the last walked MDL.

    uOffset - Number of initial bytes to skip in the MDL chain.

    uBytesNeeded - Number of bytes needed from the specified offset.

    pvStorage - Pointer to the flat buffer of uBytesNeeded size.
                Client of this call should free this buffer only when its
                done using *ppucReturnBuf.

    puLastWalkedMdlOffset - Pointer to a location that will contain the offset
                            into the last walked MDL from where the next send
                            buffer can be retrieved.

    ppucReturnBuf - Pointer to a location that will contain the pointer to
                    the flat buffer. Must not be freed by the client.
Return Value:

    Success - STATUS_SUCCESS.

    Failure - NT STATUS FAILURE CODE.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PMDL pMdl = *ppMdlChain;
    ULONG uMdlOffset = uOffset;

    ULONG uMdlByteCount = 0;
    PUCHAR pucVa = NULL;
    PUCHAR pucReturnBuf = NULL;
    ULONG uLastWalkedMdlOffset = 0;
    ULONG uBytesCopied = 0;


    //
    // Find which MDL.
    //

    if (!pMdl) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        BAIL_ON_NTSTATUS_ERROR(ntStatus);
    }

    while (uMdlOffset >= (uMdlByteCount = MmGetMdlByteCount(pMdl))) {
        uMdlOffset -= uMdlByteCount;
        pMdl = pMdl->Next;
        if (!pMdl) {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
            BAIL_ON_NTSTATUS_ERROR(ntStatus);
        }
    }

    //
    // See if the found MDL contains uMdlOffset + uBytesNeeded bytes of data.
    //

    if (uMdlOffset + uBytesNeeded <= uMdlByteCount) {

        pucVa = MmGetSystemAddressForMdlSafe(pMdl, LowPagePriority);
        if (!pucVa) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            BAIL_ON_NTSTATUS_ERROR(ntStatus);
        }
        pucReturnBuf = pucVa + uMdlOffset;

        if (uMdlOffset + uBytesNeeded < uMdlByteCount) {
            uLastWalkedMdlOffset = uMdlOffset + uBytesNeeded;
        }
        else {
            pMdl = pMdl->Next;
            uLastWalkedMdlOffset = 0;
        }

    }
    else {

        if (!pvStorage) {
            ntStatus = STATUS_BUFFER_OVERFLOW;
            BAIL_ON_NTSTATUS_ERROR(ntStatus);
        }

        ntStatus = IPSecCopyMdlToBuffer(
                       &pMdl,
                       uMdlOffset,
                       pvStorage,
                       uBytesNeeded,
                       &uLastWalkedMdlOffset,
                       &uBytesCopied
                       );
        BAIL_ON_NTSTATUS_ERROR(ntStatus);

        if (uBytesCopied != uBytesNeeded) {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
            BAIL_ON_NTSTATUS_ERROR(ntStatus);
        }
        pucReturnBuf = pvStorage;

    }

    *ppMdlChain = pMdl;
    *puLastWalkedMdlOffset = uLastWalkedMdlOffset;
    *ppucReturnBuf = pucReturnBuf;
    return (ntStatus);

error:

    *puLastWalkedMdlOffset = 0;
    *ppucReturnBuf = NULL;
    return (ntStatus);
}


NTSTATUS
IPSecCopyMdlToBuffer(
    PMDL * ppMdlChain,
    ULONG uOffset,
    PVOID pvBuffer,
    ULONG uBytesToCopy,
    PULONG puLastWalkedMdlOffset,
    PULONG puBytesCopied
    )
/*++

Routine Description:

    Copies a maximum of uBytesToCopy bytes of data from an MDL chain
    to a flat buffer.

Arguments:

    ppMdlChain - Pointer to a pointer to a chain of MDLs describing the source
                 data. On successfully copying uBytesToCopy bytes of data, this
                 points to the last walked MDL.

    uOffset - Number of initial bytes to skip in the MDL chain.

    pvBuffer - Pointer to the flat buffer to copy into.

    uBytesToCopy - Number of bytes to copy.

    puLastWalkedMdlOffset - Pointer to a location that will contain the offset
                            into the last walked MDL from where the next send
                            buffer can be retrieved.

    puBytesCopied - Pointer to a location to contain the actual number of bytes
                    copied.

Return Value:

    Success - STATUS_SUCCESS.

    Failure - NT STATUS FAILURE CODE.

--*/
{
    PMDL pMdl = *ppMdlChain;
    ULONG uMdlOffset = uOffset;
    ULONG uMdlByteCount = 0;
    ULONG uNumBytes = uBytesToCopy;
    PUCHAR pucSysVa = NULL;
    ULONG uCopySize = 0;
    PMDL pLastWalkedMdl = NULL;


    *puBytesCopied = 0;

    //
    // Skip the offset bytes in the MDL chain.
    //

    while (pMdl && uMdlOffset >= (uMdlByteCount = MmGetMdlByteCount(pMdl))) {
        uMdlOffset -= uMdlByteCount;
        pMdl = pMdl->Next;
    }

    while (pMdl && (uNumBytes > 0)) {

        uMdlByteCount = MmGetMdlByteCount(pMdl);
        if (uMdlByteCount == 0) {
            pLastWalkedMdl = pMdl;
            pMdl = pMdl->Next;
            continue;
        }

        pucSysVa = MmGetSystemAddressForMdlSafe(pMdl, LowPagePriority);
        if (!pucSysVa) {
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        pucSysVa += uMdlOffset;
        uMdlByteCount -= uMdlOffset;
        uMdlOffset = 0;

        //
        // uMdlByteCount can never be zero because at this point its always
        // greater than uMdlOffset.
        //

        uCopySize = MIN(uNumBytes, uMdlByteCount);
        RtlCopyMemory(pvBuffer, pucSysVa, uCopySize);
        (PUCHAR) pvBuffer += uCopySize;
        uNumBytes -= uCopySize;

        pLastWalkedMdl = pMdl;
        pMdl = pMdl->Next;

    }

    if (!uNumBytes) {

        if (uCopySize < uMdlByteCount) {
            *ppMdlChain = pLastWalkedMdl;
            *puLastWalkedMdlOffset = uCopySize;
        }
        else {
            pLastWalkedMdl = pLastWalkedMdl->Next;
            *ppMdlChain = pLastWalkedMdl;
            *puLastWalkedMdlOffset = 0;
        }

    }

    *puBytesCopied = uBytesToCopy - uNumBytes;

    return (STATUS_SUCCESS);
}


NTSTATUS ConvertPacketToStatefulEntry(IN PUCHAR pHeader,
									  IN PVOID pData,
									  IN BOOL bInbound,
									  OUT PIPSEC_STATEFUL_ENTRY pStatefulEntry)
{

	PNDIS_BUFFER pTempBuf;
	WORD                                wTpt[2];
	UNALIGNED WORD                      *pwPort;
	IPHeader UNALIGNED                  *pIPHeader = (IPHeader UNALIGNED *)pHeader;
	PUCHAR                              pTpt;
	ULONG                               tptLen;

	wTpt[0] = wTpt[1] = 0;
	//
	// First buffer in pData chain points to start of IP header
	//
	if (!bInbound) {
		if (((pIPHeader->iph_verlen & (UCHAR)~IP_VER_FLAG) << 2) > sizeof(IPHeader)) {
			//
			// Options -> third MDL has Tpt header
			//
			if (!(pTempBuf = IPSEC_NEXT_BUFFER((PNDIS_BUFFER)pData))) {
				return STATUS_UNSUCCESSFUL;
			}

			if (!(pTempBuf = IPSEC_NEXT_BUFFER(pTempBuf))) {
				pwPort = (UNALIGNED WORD *) (wTpt);
			} else {
				IPSecQueryNdisBuf(pTempBuf, &pTpt, &tptLen);
				if (tptLen < 4) {
					pwPort = (UNALIGNED WORD *) (wTpt);
				} else {
					pwPort = (UNALIGNED WORD *)(pTpt);
				}
			}

		} else {
			//
			// no options -> second MDL has Tpt header
			//
			if (!(pTempBuf = IPSEC_NEXT_BUFFER((PNDIS_BUFFER)pData))) {
				pwPort = (UNALIGNED WORD *) (wTpt);
			} else {
				IPSecQueryNdisBuf(pTempBuf, &pTpt, &tptLen);
				if (tptLen < 4) {
					pwPort = (UNALIGNED WORD *) (wTpt);
				} else {
					pwPort = (UNALIGNED WORD *)(pTpt);
				}
			}
		}
		if (pIPHeader->iph_protocol != PROTOCOL_TCP &&
			pIPHeader->iph_protocol != PROTOCOL_UDP) {
			pwPort = (UNALIGNED WORD *) (wTpt);
		}

		pStatefulEntry->SrcAddr = pIPHeader->iph_src;
		pStatefulEntry->DestAddr = pIPHeader->iph_dest;
		pStatefulEntry->Protocol = pIPHeader->iph_protocol;
		pStatefulEntry->SrcPort = pwPort[0];
		pStatefulEntry->DestPort = pwPort[1];

		IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("Out Packet: src %x dst %x proto %x sport %x dport %x\n",
					pStatefulEntry->SrcAddr,
					pStatefulEntry->DestAddr,
					pStatefulEntry->Protocol,
					pStatefulEntry->SrcPort,
					pStatefulEntry->DestPort));


	} else {

		IPSecQueryRcvBuf(pData, &pTpt, &tptLen);
		if (pIPHeader->iph_protocol == PROTOCOL_TCP ||
			pIPHeader->iph_protocol == PROTOCOL_UDP) {
			if (tptLen < sizeof(WORD)*2) {
				pwPort = (UNALIGNED WORD *) (wTpt);
			} else {
				pwPort = (UNALIGNED WORD *)(pTpt);
			}
		} else {
			pwPort = (UNALIGNED WORD *) (wTpt);
		}

		pStatefulEntry->SrcAddr = pIPHeader->iph_src;
		pStatefulEntry->DestAddr = pIPHeader->iph_dest;
		pStatefulEntry->Protocol = pIPHeader->iph_protocol;
		pStatefulEntry->SrcPort = pwPort[0];
		pStatefulEntry->DestPort = pwPort[1];

		IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("In Packet: src %x dst %x proto %x sport %x dport %x\n",
					pStatefulEntry->SrcAddr,
					pStatefulEntry->DestAddr,
					pStatefulEntry->Protocol,
					pStatefulEntry->SrcPort,
					pStatefulEntry->DestPort));


	}


	return STATUS_SUCCESS;


}


BOOL EntryMatch(PIPSEC_STATEFUL_ENTRY pSEntry,
				PIPSEC_EXEMPT_ENTRY pEEntry,
				BOOL fIncoming)
/*++

Routine Description:


Arguments:

   pSEntry - stateful entry for packet.  
   PEEntry - exempt entry. 
   fIncoming - Is this an incoming packet?

Return Value:

   TRUE - entry matches

--*/




{
    USHORT srcPort,dstPort;


    // If the direction of the packet is not the same as the direction in which the
    // filter is specified , reverse the ports
    if ((fIncoming && pEEntry->Direction != EXEMPT_DIRECTION_INBOUND) ||
        (!fIncoming && pEEntry->Direction != EXEMPT_DIRECTION_OUTBOUND)){
            return FALSE;
    }
    else
    {
    // Else get the ports 
    srcPort = pSEntry->SrcPort;
    dstPort = pSEntry->DestPort;
    } 



   if (pSEntry->Protocol == pEEntry->Protocol) {
            //Dest port matches or is configured to be any (0)
	  if ((dstPort == pEEntry->DestPort ||pEEntry->DestPort == 0) &&
	     //Source port matches or is configured to be any (0)
	      (srcPort == pEEntry->SrcPort ||pEEntry->SrcPort == 0)) {
		 return TRUE;
	  }
   }
		   
   return FALSE;

}

//Should not hold the g_ipsec.SADBLock when calling this function
BOOL IsEntryExempt(PIPSEC_STATEFUL_ENTRY pSEntry, BOOL fIncoming)

{
   ULONG i;
   KIRQL kIrql;

   AcquireReadLock(&g_ipsec.SADBLock, &kIrql);
   if (g_ipsec.BootExemptList){
       for (i=0; i < g_ipsec.BootExemptListSize; i++) {
	      if (EntryMatch(pSEntry,
		    			 &g_ipsec.BootExemptList[i],fIncoming)) {
	            ReleaseReadLock(&g_ipsec.SADBLock,kIrql);
	  	    return (TRUE);

	    }		
	  
        }
    }
   ReleaseReadLock(&g_ipsec.SADBLock,kIrql);
   return FALSE;

}


ULONG
CalcStatefulCacheIndex(
        PIPSEC_STATEFUL_ENTRY pSEntry,
        BOOL fUnicast
    )
{
    ULONG  dwIndex;
    ULONG  Address;
    USHORT Port;
    IPAddr  SrcAddr;
    IPAddr  DestAddr;
    UCHAR   Protocol;
    USHORT  SrcPort;
    USHORT  DestPort;

    
    if (fUnicast){
            SrcAddr = pSEntry->SrcAddr;
            DestAddr = pSEntry->DestAddr;
        }
    else{
            SrcAddr = 0;
            DestAddr = 0;
        }
        
    SrcPort = pSEntry->SrcPort;
    DestPort = pSEntry->DestPort;
    Protocol = pSEntry->Protocol;
    
    
    Address = SrcAddr ^ DestAddr;
    Port = SrcPort ^ DestPort;
    dwIndex = NET_TO_HOST_LONG(Address);
    dwIndex += Protocol;
    dwIndex += NET_TO_HOST_SHORT(Port);
    dwIndex %= IPSEC_STATEFUL_HASH_TABLE_SIZE;
    return  dwIndex;
}



BOOL SearchCollisionChain(
        IN LIST_ENTRY * pHead,
        IN PIPSEC_STATEFUL_ENTRY pSMatch,
        IN BOOL fUnicast
        )
{
    LIST_ENTRY * pEntry=NULL;
    PIPSEC_STATEFUL_ENTRY pSEntry=NULL;    

    pEntry = pHead;

     for (   pEntry = pHead->Flink;
                pEntry != pHead;
                pEntry = pEntry->Flink) {

                        pSEntry = CONTAINING_RECORD(pEntry,
                                  IPSEC_STATEFUL_ENTRY,
                                  CollisionLinkage);

                        if (fUnicast){
                                if ((pSEntry->SrcAddr != pSMatch->SrcAddr) ||
                                    (pSEntry->DestAddr!= pSMatch->DestAddr)){
                                        continue;
                                    }
                            }
                        else {
                            //Check for destination address it should be the same
                            // multicast / broadcast address both inbound and 
                            // outbound.
                             if (pSEntry->DestAddr != pSMatch->DestAddr){
                                continue;
                                }
                            }
                                
                        if ((pSEntry->SrcPort == pSMatch->SrcPort)&&
                             (pSEntry->DestPort == pSMatch->DestPort) &&
                             (pSEntry->Protocol == pSMatch->Protocol)){
                                return TRUE;
                            }
                    }
               return FALSE;
}

BOOL FindStatefulEntry(PIPSEC_STATEFUL_ENTRY pSEntry,
					   BOOL fOutbound,
					   BOOL fUnicast)
{
	ULONG i;

	PIPSEC_STATEFUL_ENTRY pOutSEntry;
	IPSEC_STATEFUL_ENTRY TmpEntry;
	BOOL fRetValue;
	ULONG index;  
	
       // Acquire multiple reader  single writer lock
       // While the hash table is being read
       // it can not be altered
 
	if (fOutbound) {
		pOutSEntry = pSEntry;
	} else {
	       //Stateful entries are symmetrical
	       //Flip inbound to look like outbound
	       //for lookup.
		pOutSEntry = &TmpEntry;
		TmpEntry.SrcAddr = pSEntry->DestAddr;
		TmpEntry.DestAddr = pSEntry->SrcAddr;
		TmpEntry.Protocol = pSEntry->Protocol;
		TmpEntry.SrcPort = pSEntry->DestPort;
		TmpEntry.DestPort = pSEntry->SrcPort;
	}
	//Calculate the has index in the table
        index = 
            CalcStatefulCacheIndex(pOutSEntry, fUnicast);		
	
        //Do we have a collision chain here?
        if (!IsListEmpty(&(g_ipsec.BootStatefulHT->Entry[index]))){
            
                 // Search the collision chain if it exists
                 fRetValue = SearchCollisionChain
                                    (&(g_ipsec.BootStatefulHT->Entry[index]),
                                                    pOutSEntry,
                                                    fUnicast);                                        
            }
        else{
                fRetValue = FALSE;
            }           

        
        if (fRetValue){
    	        IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("FoundStatefulEntry.\n"));
            }
        
	return fRetValue;
}


NTSTATUS InsertStatefulEntry(PIPSEC_STATEFUL_ENTRY pSEntry,
							 BOOL fUnicast)
{

	NTSTATUS Status = STATUS_SUCCESS;
	ULONG index;
   
        // Else insert the new entry. 
        //
	 index = 
                CalcStatefulCacheIndex(pSEntry, fUnicast);	

       InsertTailList(&(g_ipsec.BootStatefulHT->Entry[index]),&(pSEntry->CollisionLinkage));
	IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("Inserted statefulentry into slot %d \n",index));


       return Status;
}





IPSEC_ACTION IPSecProcessBoottime(IN PUCHAR pIPHeader,
							  IN PVOID   pData,
							  IN PNDIS_PACKET Packet,
							  IN ULONG IpsecFlags,
							  IN UCHAR DestType)

/*++

Routine Description:

	This is the IPSec handler for boottime traffic

Arguments:

	pIPHeader - points to start of IP header.

	pData - points to the data after the IP header, an IPRcvBuf or MDL

	IpsecFlags - flags for SrcRoute, Incoming, Forward and Lookback.


Return Value:

	eFORWARD
	eDROP

--*/

{

	IPSEC_ACTION eAction = eDROP;
	NTSTATUS Status;
	IPSEC_STATEFUL_ENTRY StatefulEntry;
	PIPSEC_STATEFUL_ENTRY pSSaveEntry;
	KIRQL kIrql;


        if (IpsecFlags & IPSEC_FLAG_LOOPBACK) {
            eAction = eFORWARD;
            goto out;
        }
    

        if (IpsecFlags & IPSEC_FLAG_FORWARD){
        if ( IS_DRIVER_FORWARD_BLOCK()){
            goto out ; // Drop the packet
            }
        else{
            eAction = eFORWARD;//bypass traffic on forwarding path
            goto out;
            }
        }
 

	if (IpsecFlags & IPSEC_FLAG_INCOMING) {

		Status = ConvertPacketToStatefulEntry(pIPHeader,
											  pData,
											  TRUE,
											  &StatefulEntry);
		if (!NT_SUCCESS(Status)) {
			goto out;
		}
		

		if (IsEntryExempt(&StatefulEntry,TRUE)) {
			eAction = eFORWARD;
			goto out;
		}

		if (IS_DRIVER_BLOCK()) {
			goto out;
		}

		 AcquireReadLock(&g_ipsec.SADBLock, &kIrql);
               if (g_ipsec.BootBufferPool == NULL){
	              //We have moved out of boot mode
	              ReleaseReadLock(&g_ipsec.SADBLock,kIrql);
	             goto out;
	          }

		if (FindStatefulEntry(&StatefulEntry,FALSE,!IS_BCAST_DEST(DestType))) {
			eAction = eFORWARD;
		}
		
		ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

	} else {


             


		//eAction is eDROP here
		Status = ConvertPacketToStatefulEntry(pIPHeader,
											  pData,
											  FALSE,
											  &StatefulEntry);
            if (!NT_SUCCESS(Status)) {
			goto out;
		}
		
             if (IsEntryExempt(&StatefulEntry,FALSE)) {
			eAction = eFORWARD;
			goto out;
		}

             if (IS_DRIVER_BLOCK()) {
			goto out;
		}
		
              AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);
	       if (g_ipsec.BootBufferPool == NULL){
	           //We have moved out of boot mode
	           ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
	           goto out;
	       }

		// Do we have a preexisting entry?
              //
	       if (FindStatefulEntry(&StatefulEntry,TRUE,!IS_BCAST_DEST(DestType))) {
	                 eAction = eFORWARD;
	                 ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
                	   goto out;
	       }

	       

              // This call cant fail. We recycle memory if we run
              // out of it.
              pSSaveEntry = IPSecAllocateFromHashPool();
              
              RtlCopyMemory(pSSaveEntry,&StatefulEntry,sizeof(IPSEC_STATEFUL_ENTRY));
		Status = InsertStatefulEntry(pSSaveEntry,!IS_BCAST_DEST(DestType));
		
		if (NT_SUCCESS(Status)) {
      		        // Yup we can forward it
			 eAction = eFORWARD;
		    }
		ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
	}

	out:

	IPSEC_DEBUG(LL_A,DBF_BOOTTIME,("Leaving Boottime action %d\n",eAction));
	return eAction;

}


BOOLEAN 
IPSecIsGenericPortsProtocolOf(
    ULARGE_INTEGER uliGenericPortProtocol, 
    ULARGE_INTEGER uliSpecificPortProtocol
)
/*++

Routine Description:

	This routine determines if one unsigned large integer representing 
	port and protocols as commonly used in our SA and FILTER structures
	is more generic than another such value
	

Arguments:

    uliGenericPortProtocol - the unsigned integer that should be more generic.

    uliSpecificPortProtocol - the unsigned integer that should be more specific.

Return Value:

	TRUE: Param1 is more generic than Param2 or at least equal
	FALSE: 

--*/

{
    DWORD dwGenericProtocol , dwSpecificProtocol;
    DWORD dwGenericPorts, dwSpecificPorts;
    dwGenericProtocol = uliGenericPortProtocol.LowPart;
    dwSpecificProtocol = uliSpecificPortProtocol.LowPart;
    dwGenericPorts = uliGenericPortProtocol.HighPart;
    dwSpecificPorts = uliSpecificPortProtocol.HighPart;
    
    if ((dwGenericProtocol != 0) && (dwGenericProtocol != dwSpecificProtocol)){
        return FALSE;
    }
    if  ((dwGenericPorts == dwSpecificPorts) || (0 == dwGenericPorts)) {
        return TRUE;
    }
    if  ((dwSpecificPorts & 0xffff0000) == (dwGenericPorts) ){
        return TRUE;
    }
    if  ((dwSpecificPorts & 0x0000ffff) == (dwGenericPorts) ){
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\offload.h ===
VOID
IPSecFillHwAddSA(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PUCHAR          Buf,
    IN  ULONG           Len
    );

NDIS_STATUS
IPSecPlumbHw(
    IN  PVOID           DestIF,
    IN  PVOID           Buf,
    IN  ULONG           Len,
    IN  NDIS_OID        Oid
    );

NTSTATUS
IPSecSendOffload(
    IN  IPHeader UNALIGNED  *pIPHeader,
    IN  PNDIS_PACKET        Packet,
    IN  Interface           *DestIF,
    IN  PSA_TABLE_ENTRY     pSA,
    IN  PSA_TABLE_ENTRY     pNextSA,
    IN  PVOID               *ppSCContext,
    IN  BOOLEAN             *pfCryptoOnly
    );

NTSTATUS
IPSecRecvOffload(
    IN  IPHeader UNALIGNED  *pIPHeader,
    IN  Interface           *DestIF,
    IN  PSA_TABLE_ENTRY     pSA
    );

NTSTATUS
IPSecDelHWSA(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecDelHWSAAtDpc(
    IN  PSA_TABLE_ENTRY pSA
    );

NTSTATUS
IPSecBufferPlumbSA(
    IN  Interface       *DestIF,
    IN  PSA_TABLE_ENTRY pSA,
    IN  PPARSER_IFENTRY pParserIfEntry,
    IN  PUCHAR          Buf,
    IN  ULONG           Len
    );

NTSTATUS
IPSecProcessPlumbSA(
    IN  PVOID   Context
    );

NTSTATUS
IPSecProcessDeleteSA(
    IN  PVOID   Context
    );

NTSTATUS
IPSecNdisStatus(
    IN  PVOID       IPContext,
    IN  UINT        Status
    );

VOID
IPSecDeleteIF(
    IN  PVOID       IPContext
    );

VOID
IPSecResetStart(
    IN  PVOID       IPContext
    );

VOID
IPSecResetEnd(
    IN  PVOID       IPContext
    );

VOID
IPSecWakeUp(
    IN  PVOID       IPContext
    );

VOID
IPSecBufferOffloadEvent(
    IN  IPHeader UNALIGNED      *pIPH,
    IN  PNDIS_IPSEC_PACKET_INFO IPSecPktInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\macros.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Contains all the macros.

Author:

    Sanjay Anand (SanjayAn) 2-January-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef  _MACROS_H
#define  _MACROS_H

#define REGISTER register

#define EXTENDED_MULTIPLY   RtlExtendedIntegerMultiply


#ifndef MAX
#define MAX(x,y)    ((x) < (y)) ? (y) : (x)
#endif
#ifndef MIN
#define MIN(x,y)    ((x) < (y)) ? (x) : (y)
#endif

#define MAX_IP_DATA_LENGTH  ((USHORT)0xfffff)

#define MAX_AH_OUTPUT_LEN   MAX(MD5DIGESTLEN, A_SHA_DIGEST_LEN)

//
// This macro adds a ULONG to a LARGE_INTEGER.
//

#define ADD_TO_LARGE_INTEGER(_LargeInteger,_Ulong) \
    ExInterlockedAddLargeStatistic((PLARGE_INTEGER)(_LargeInteger),(ULONG)(_Ulong))

#define IPSecEqualMemory(_p1, _p2, _len)  RtlEqualMemory(_p1, _p2, _len)

#define IPSecMoveMemory(_p1, _p2, _len)  RtlMoveMemory(_p1, _p2, _len)

#define IPSecZeroMemory(_p1, _len)  RtlZeroMemory(_p1, _len)

//
// Truncates _src to _numbytes and copies into _dest
// then zeroes out the rest in _dest
//
#define TRUNCATE(_dest, _src, _numbytes, _destlen) {        \
    IPSecZeroMemory ( _dest+_numbytes, _destlen - _numbytes); \
}

//
// Some macros
//
#ifdef  NET_SHORT
#undef  NET_SHORT
#endif
__inline
USHORT
FASTCALL
NET_SHORT(USHORT x)
{
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
    return _byteswap_ushort(x);
#else
    ASSERT(x <= 0xffff);

    return (x << 8) | (x >> 8);
#endif
}

#define NET_TO_HOST_SHORT(Val)  NET_SHORT(Val)
#define HOST_TO_NET_SHORT(Val)  NET_SHORT(Val)

#ifdef  NET_LONG
#undef  NET_LONG
#endif
__inline
ULONG
FASTCALL
NET_LONG(ULONG x)
{
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
    return _byteswap_ulong(x);
#else
    REGISTER ULONG  BytesSwapped;

    BytesSwapped = ((x & 0x00ff00ff) << 8) | ((x & 0xff00ff00) >> 8);
    return (BytesSwapped << 16) | (BytesSwapped >> 16);
#endif
}

#define NET_TO_HOST_LONG(Val)   NET_LONG(Val)
#define HOST_TO_NET_LONG(Val)   NET_LONG(Val)

#define IPSEC_100NS_FACTOR      10000000

#define IPSEC_CONVERT_SECS_TO_100NS(_li, _delta) {      \
    (_li).LowPart = _delta;                             \
    (_li) = EXTENDED_MULTIPLY(_li, IPSEC_100NS_FACTOR); \
}

#define IS_CLASSD(i)            (((long)(i) & 0xf0000000) == 0xe0000000)

//
// Check SA against Lifetime information - we try to anticipate in advance if the
// SA is going to expire and start off a re-key so that when it actually does expire,
// we have the new SA setup.
//

//
// IPSEC_EXPIRE_TIME_PAD is the time before expiration when we start re-keying
//
#define IPSEC_EXPIRE_TIME_PAD_I         (75 * IPSEC_100NS_FACTOR)
#define IPSEC_EXPIRE_TIME_PAD_R         (40 * IPSEC_100NS_FACTOR)
#define IPSEC_EXPIRE_TIME_PAD_OAKLEY    (1 * IPSEC_100NS_FACTOR)

//
// IPSEC_INBOUND_KEEPALIVE_TIME is the time an expired inboundSA will be kept
// alive in the driver
//
#define IPSEC_INBOUND_KEEPALIVE_TIME    (60)

//
// IPSEC_MAX_EXPIRE_TIME is the maximum phase-2 lifetime allowed in driver
//
#define IPSEC_MAX_EXPIRE_TIME           (48 * 3600 - 1)

//
// IPSEC_MIN_EXPIRE_TIME is the minimum phase-2 lifetime allowed in driver
//
#define IPSEC_MIN_EXPIRE_TIME           (60)

#define IPSEC_EXPIRE_THRESHOLD_I        (50)
#define IPSEC_EXPIRE_THRESHOLD_R        (75)

//
// skew the initiator and responder with Pads
//
#define IPSEC_DEFAULT_SA_IDLE_TIME_PAD_I  0
#define IPSEC_DEFAULT_SA_IDLE_TIME_PAD_R  30


#define IPSEC_NLBS_IDLE_TIME 60

//
// The # of packets before which we start reneg. because of replay rollover
// 1M bytes / 1500 packets
//
#define IPSEC_EXPIRE_REPLAY_MASK    (0x80000000)
#define MAX_ULONG                   ((ULONG) -1)
#define MAX_LONG                    (0x7fffffff)

//
// Some constants used for POST_EXPIRE_NOTIFY
//
#define IPSEC_INVALID_SPI           0
#define IPSEC_INVALID_ADDR          (-1)

//
// Check the lifetime (kbytes and seconds) and replay rollover.
// FALSE => expired
//
#define IPSEC_CHECK_PADDED_LIFETIME(__pSA, _status, _index) {   \
    LARGE_INTEGER   __curtime;                                  \
    (_status) = TRUE;                                           \
    if (((__pSA)->sa_ReplaySendSeq[0] &                         \
         IPSEC_EXPIRE_REPLAY_MASK) &&                           \
        ((__pSA)->sa_Flags & FLAGS_SA_OUTBOUND)) {              \
        _status = FALSE;                                        \
    } else {                                                    \
        KeQuerySystemTime(&__curtime);                          \
        if (((__pSA)->sa_KeyExpirationTimeWithPad.QuadPart > 0i64) && \
            ((__pSA)->sa_KeyExpirationTimeWithPad.QuadPart < __curtime.QuadPart)) {\
            _status = FALSE;                                    \
        } else if (((__pSA)->sa_KeyExpirationBytesWithPad.QuadPart > 0i64) &&   \
                   ((__pSA)->sa_KeyExpirationBytesWithPad.QuadPart < (__pSA)->sa_TotalBytesTransformed.QuadPart)) {   \
            _status = FALSE;                                    \
        }                                                       \
    }                                                           \
}

#define IPSEC_CHECK_LIFETIME(__pSA, _status, _index) {          \
    LARGE_INTEGER   __curtime;                                  \
    (_status) = TRUE;                                           \
    if ((__pSA)->sa_ReplaySendSeq[_index] == MAX_ULONG) {       \
        _status = FALSE;                                        \
    } else {                                                    \
        KeQuerySystemTime(&__curtime);                          \
        if (((__pSA)->sa_KeyExpirationTime.QuadPart > 0i64) &&  \
            ((__pSA)->sa_KeyExpirationTime.QuadPart < __curtime.QuadPart)) { \
            _status = FALSE;                                    \
        } else if (((__pSA)->sa_KeyExpirationBytes.QuadPart > 0i64) &&   \
                   ((__pSA)->sa_KeyExpirationBytes.QuadPart < (__pSA)->sa_TotalBytesTransformed.QuadPart)) { \
            _status = FALSE;                                    \
        }                                                       \
    }                                                           \
}

#define IPSEC_SA_EXPIRED(__pSA, __fexpired) {           \
    LARGE_INTEGER   __curtime;                          \
    KeQuerySystemTime(&__curtime);                      \
    (__fexpired) = FALSE;                               \
    __curtime.QuadPart -= pSA->sa_LastUsedTime.QuadPart;\
    if (__pSA->sa_IdleTime.QuadPart < __curtime.QuadPart) { \
        __fexpired = TRUE;                              \
    }                                                   \
}

//
// Max tolerated collisions when trying to allocate SPIs.
//
#define MAX_SPI_RETRIES 50

#define IPSEC_SPI_TO_ENTRY(_spi, _entry, _dst) {        \
    KIRQL   kIrql;                                      \
    AcquireReadLock(&g_ipsec.SPIListLock, &kIrql);      \
    *(_entry) = IPSecLookupSABySPIWithLock(_spi, _dst); \
    if (*(_entry)) {                                    \
        IPSecRefSA((*(_entry)));                        \
    }                                                   \
    ReleaseReadLock(&g_ipsec.SPIListLock, kIrql);       \
}

//
// Generic memory allocators
//
#define IPSecAllocatePktInfo(__tag) \
    IPSecAllocateMemory(sizeof(NDIS_IPSEC_PACKET_INFO), __tag)

#define IPSecFreePktInfo(__p) \
    IPSecFreeMemory(__p)

#define IPSecAllocatePktExt(__tag) \
    IPSecAllocateMemory(sizeof(NDIS_IPSEC_PACKET_INFO), __tag)

#define IPSecFreePktExt(__p) \
    IPSecFreeMemory(__p)

#define IPSecAllocateBuffer(_ntstatus, _ppBuf, _ppData, _size, _tag) {  \
    PIPSEC_LA_BUFFER    __labuf;                                        \
    *(_ntstatus) = STATUS_SUCCESS;                                      \
    __labuf = IPSecGetBuffer(_size, _tag);                              \
    if (__labuf) {                                                      \
        if (ARGUMENT_PRESENT(_ppData)) {                                \
            *(PVOID *)(_ppData) = __labuf->Buffer;                      \
        }                                                               \
        *(_ppBuf) = __labuf->Mdl;                                       \
        NdisAdjustBufferLength(__labuf->Mdl, _size);                    \
        NDIS_BUFFER_LINKAGE(__labuf->Mdl) = NULL;                       \
    } else {                                                            \
        *(_ntstatus) = STATUS_INSUFFICIENT_RESOURCES;                   \
    }                                                                   \
}

#define IPSecFreeBuffer(_ntstatus, _pBuf) {                             \
    PIPSEC_LA_BUFFER    __buffer;                                       \
    *(_ntstatus) = STATUS_SUCCESS;                                      \
    __buffer = CONTAINING_RECORD((_pBuf), IPSEC_LA_BUFFER, Data);       \
    IPSecReturnBuffer(__buffer);                                        \
}

#define IPSecAllocateSendCompleteCtx(__tag)                 \
    ExAllocateFromNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SendCompleteCtxList)

#define IPSecFreeSendCompleteCtx(_buffer)                   \
    ExFreeToNPagedLookasideList(&g_ipsec.IPSecLookasideLists->SendCompleteCtxList, _buffer);    \
    IPSEC_DECREMENT(g_ipsec.NumSends);

#define IPSEC_GET_TOTAL_LEN(_pbuf, _plen)       {           \
    PNDIS_BUFFER _ptemp = (PNDIS_BUFFER)(_pbuf);            \
    *(_plen) = 0;                                           \
    while (_ptemp) {                                        \
        *(_plen) += _ptemp->ByteCount;                      \
        _ptemp = NDIS_BUFFER_LINKAGE(_ptemp);               \
    }                                                       \
}

#define IPSEC_GET_TOTAL_LEN_RCV_BUF(_pbuf, _plen)       {   \
    IPRcvBuf *_ptemp = (_pbuf);                             \
    *(_plen) = 0;                                           \
    while (_ptemp) {                                        \
        *(_plen) += _ptemp->ipr_size;                       \
        _ptemp = IPSEC_BUFFER_LINKAGE(_ptemp);              \
    }                                                       \
}


//
// Copy len bytes from RcvBuf chain to mdl (only one MDL)
//
#define IPSEC_COPY_FROM_RCVBUF(_pMdl, _pRcvBuf, _len, _offset) {                    \
    IPRcvBuf    *__pBuf=(_pRcvBuf);                                                 \
    PMDL        __pMdl=(_pMdl);                                                     \
    ULONG       __srclen;                                                           \
    ULONG       __destlen;                                                          \
    ULONG       __totallen=0;                                                       \
    PUCHAR      __pSrc;                                                             \
    PUCHAR      __pDest;                                                            \
    ULONG       __curroffset = (_offset);                                           \
    IPSecQueryNdisBuf(__pMdl, &__pDest, &__destlen);                                \
    while (__pBuf) {                                                                \
        IPSecQueryRcvBuf(__pBuf, &__pSrc, &__srclen);                               \
        if (__srclen > __curroffset) {                                              \
            RtlCopyMemory(__pDest, __pSrc+__curroffset, __srclen-__curroffset);     \
            __pDest += (__srclen - __curroffset);                                   \
            __totallen += (__srclen - __curroffset);                                \
        }                                                                           \
        __curroffset = 0;                                                           \
        __pBuf = IPSEC_BUFFER_LINKAGE(__pBuf);                                      \
    }                                                                               \
    ASSERT(__totallen == __destlen);                                                \
}

//
// Copy len bytes from Ndis Buffer chain to mdl (only one MDL)
//
#define IPSEC_COPY_FROM_NDISBUF(_pMdl, _pRcvBuf, _len, _offset) {                   \
    NDIS_BUFFER *__pBuf=(_pRcvBuf);                                                 \
    PMDL        __pMdl=(_pMdl);                                                     \
    ULONG       __srclen;                                                           \
    ULONG       __destlen;                                                          \
    ULONG       __totallen=0;                                                       \
    PUCHAR      __pSrc;                                                             \
    PUCHAR      __pDest;                                                            \
    ULONG       __curroffset = (_offset);                                           \
    IPSecQueryNdisBuf(__pMdl, &__pDest, &__destlen);                                \
    while (__pBuf) {                                                                \
        IPSecQueryNdisBuf(__pBuf, &__pSrc, &__srclen);                              \
        if (__srclen > __curroffset) {                                              \
            RtlCopyMemory(__pDest, __pSrc+__curroffset, __srclen-__curroffset);     \
            __pDest += (__srclen - __curroffset);                                   \
            __totallen += (__srclen - __curroffset);                                \
        }                                                                           \
        __curroffset = 0;                                                           \
        __pBuf = NDIS_BUFFER_LINKAGE(__pBuf);                                       \
    }                                                                               \
    ASSERT(__totallen == __destlen);                                                \
}

#define IPSecAllocateMemory(_size, _tag)    \
        ExAllocatePoolWithTag (NonPagedPool, _size, _tag)

#define IPSecAllocateMemoryLowPriority(_size, _tag) \
        ExAllocatePoolWithTagPriority (NonPagedPool, _size, _tag, LowPoolPriority)

#define IPSecFreeMemory(_addr)  ExFreePool (_addr)

#define IPSecQueryNdisBuf(_Buffer, _VirtualAddress, _Length)    \
{                                                               \
    PNDIS_BUFFER    __Mdl = (PNDIS_BUFFER) (_Buffer);           \
    if (ARGUMENT_PRESENT(_VirtualAddress)) {                    \
        *(PVOID *)(_VirtualAddress) = (__Mdl)->MappedSystemVa;  \
    }                                                           \
    *(_Length) = (__Mdl)->ByteCount;                            \
}

#define IPSecQueryRcvBuf(_Buffer, _VirtualAddress, _Length) \
{                                                           \
    IPRcvBuf    *__buf = (IPRcvBuf *) (_Buffer);            \
    if (ARGUMENT_PRESENT(_VirtualAddress)) {                \
        *(PVOID *)(_VirtualAddress) = (__buf)->ipr_buffer;  \
    }                                                       \
    *(_Length) = (__buf)->ipr_size;                         \
}

#define IPSEC_ADJUST_BUFFER_LEN(_pBuf, _len)    \
    ((IPRcvBuf *)(_pBuf))->ipr_size = (_len)

#define IPSEC_ADJUST_BUFFER(_pBuf, _offset) \
    ((IPRcvBuf *)(_pBuf))->ipr_buffer += (_offset)

#define IPSEC_ADJUST_BUFFER_NEG(_pBuf, _offset) \
    ((IPRcvBuf *)(_pBuf))->ipr_buffer -= (_offset)


#define IPSEC_ADJUST_BUFFER_RCVOFFSET(_pBuf, _offset)   \
    ((IPRcvBuf *)(_pBuf))->ipr_RcvOffset += (_offset)

#define IPSEC_BUFFER_LINKAGE(_pBuf) \
    ((IPRcvBuf *)(_pBuf))->ipr_next

#define IPSEC_BUFFER_LEN(_pBuf) \
    ((IPRcvBuf *)(_pBuf))->ipr_size

#define IPSEC_BUFFER_OWNER(_pBuf)   \
    (((IPRcvBuf *)(_pBuf))->ipr_owner)

#define IPSEC_SET_OFFSET_IN_BUFFER(_pBuf, _offset)  {               \
    PUCHAR  _p;                                                     \
    LONG    _len;                                                   \
    IPSecQueryRcvBuf((_pBuf), &(_p), &(_len));                      \
    if ((_offset) > 0 && (_offset) < (_len)) {                      \
        if (IPSEC_BUFFER_OWNER(_pBuf) == IPR_OWNER_FIREWALL) {      \
            IPSecMoveMemory((_p), (_p) + (_offset), (_len) - (_offset));\
        } else {                                                    \
            IPSEC_ADJUST_BUFFER((_pBuf), (_offset));                \
            IPSEC_ADJUST_BUFFER_RCVOFFSET((_pBuf), (_offset));      \
        }                                                           \
        IPSEC_ADJUST_BUFFER_LEN((_pBuf), (_len) - (_offset));       \
    } else {                                                        \
        ASSERT(FALSE);                                              \
        return  STATUS_INVALID_PARAMETER;                           \
    }                                                               \
}

#define IPSEC_ADD_VALUE(_val, _inc) InterlockedExchangeAdd((PULONG)&(_val), _inc)

#define IPSEC_INCREMENT(_val)  InterlockedIncrement(&(_val))
#define IPSEC_DECREMENT(_val)  InterlockedDecrement(&(_val))
#define IPSEC_GET_VALUE(_val)  InterlockedExchangeAdd((PULONG)&(_val), 0)
#define IPSEC_SET_VALUE(_target, _val)  \
    InterlockedExchange((PULONG)&(_target), _val)

#define IPSEC_DRIVER_IS_EMPTY()     (g_ipsec.NumPolicies == 0)
#define IPSEC_DRIVER_IS_INACTIVE()  (g_ipsec.DriverUnloading || !g_ipsec.InitTcpip)

#define IPSEC_DRIVER_UNLOADING()    (g_ipsec.DriverUnloading)
#define IPSEC_DRIVER_BOUND()        (g_ipsec.BoundToIP)
#define IPSEC_DRIVER_SEND_BOUND()   (g_ipsec.SendBoundToIP)
#define IPSEC_DRIVER_INIT_CRYPTO()  (g_ipsec.InitCrypto)
#define IPSEC_DRIVER_INIT_RNG()     (g_ipsec.InitRNG)
#define IPSEC_DRIVER_INIT_TCPIP()   (g_ipsec.InitTcpip)
#if FIPS
#define IPSEC_DRIVER_INIT_FIPS()    (g_ipsec.InitFips)
#endif
#if GPC
#define IPSEC_DRIVER_INIT_GPC()     (g_ipsec.InitGpc)
#endif

#if DBG
#define IPSecRemoveEntryList(_x)                        \
{                                                       \
    RemoveEntryList(_x);                                \
    (_x)->Flink = (_x)->Blink = (PLIST_ENTRY)__LINE__;  \
}
#else
#define IPSecRemoveEntryList(_x)    RemoveEntryList(_x)
#endif

//
// macros for filter list management
//
#define IS_TRANSPORT_FILTER(f)  (!(f)->TunnelFilter)
#define IS_TUNNEL_FILTER(f)     ((f)->TunnelFilter)
#define IS_INBOUND_FILTER(f)    ((f)->Flags & FILTER_FLAGS_INBOUND)
#define IS_OUTBOUND_FILTER(f)   ((f)->Flags & FILTER_FLAGS_OUTBOUND)

#define IS_EXEMPT_FILTER(f)     (((f)->Flags & FILTER_FLAGS_DROP) || ((f)->Flags & FILTER_FLAGS_PASS_THRU))

#define IS_MULTICAST_FILTER(f)  (IS_CLASSD(NET_LONG((f)->SRC_ADDR)) || \
                                 IS_CLASSD(NET_LONG((f)->DEST_ADDR)))

__inline
PLIST_ENTRY
IPSecResolveFilterList(
    IN  BOOLEAN     fTunnel,
    IN  BOOLEAN     fOutbound
    )
{
    PLIST_ENTRY pEntry;

    if (fTunnel) {
        if (fOutbound) {
            pEntry = &g_ipsec.FilterList[OUTBOUND_TUNNEL_FILTER];
        } else {
            pEntry = &g_ipsec.FilterList[INBOUND_TUNNEL_FILTER];
        }
    } else {
        if (fOutbound) {
            pEntry = &g_ipsec.FilterList[OUTBOUND_TRANSPORT_FILTER];
        } else {
            pEntry = &g_ipsec.FilterList[INBOUND_TRANSPORT_FILTER];
        }
    }

    return  pEntry;
}

//
// Filter/SA Cache Table
//
#define CacheMatch(uliAddr, uliPort, pInCache)              \
        ((uliAddr).QuadPart == pInCache->uliSrcDstAddr.QuadPart) &&    \
        ((uliPort).QuadPart == pInCache->uliProtoSrcDstPort.QuadPart)

#define IS_VALID_CACHE_ENTRY(_entry)    ((_entry)->pFilter != NULL)

#define INVALIDATE_CACHE_ENTRY(_entry)              \
{                                                   \
    ((PFILTER_CACHE)(_entry))->pSAEntry = NULL;     \
    ((PFILTER_CACHE)(_entry))->pNextSAEntry = NULL; \
}                                                   \

__inline
ULONG
FASTCALL
CalcCacheIndex(
    IN  IPAddr  SrcAddr,
    IN  IPAddr  DestAddr,
    IN  UCHAR   Protocol,
    IN  USHORT  SrcPort,
    IN  USHORT  DestPort,
    IN  BOOLEAN fOutbound
    )
{
    REGISTER ULONG  dwIndex;
    REGISTER ULONG  Address;
    REGISTER USHORT Port;

    Address = SrcAddr ^ DestAddr;
    Port = SrcPort ^ DestPort;

    dwIndex = NET_TO_HOST_LONG(Address);
    dwIndex += Protocol;
    dwIndex += NET_TO_HOST_SHORT(Port);

    dwIndex %= g_ipsec.CacheHalfSize;
    if (fOutbound) {
        dwIndex += g_ipsec.CacheHalfSize;
    }

    return  dwIndex;
}

__inline
VOID
CacheUpdate(
    IN  ULARGE_INTEGER  uliAddr,
    IN  ULARGE_INTEGER  uliPort,
    IN  PVOID           _pCtxt1,
    IN  PVOID           _pCtxt2,
    IN  ULONG           dwId,
    IN  BOOLEAN         fFilter
    )
{
    PFILTER_CACHE   __pCache;
    PFILTER_CACHE   __pTempCache;
    PFILTER         __pFilter;
    PSA_TABLE_ENTRY __pSA;
    PSA_TABLE_ENTRY __pNextSA;

    __pCache = g_ipsec.ppCache[(dwId)];

    if (IS_VALID_CACHE_ENTRY(__pCache)) {
        if (__pCache->FilterEntry) {
            __pCache->pFilter->FilterCache = NULL;
        } else {
            __pCache->pSAEntry->sa_FilterCache = NULL;
            if (__pCache->pNextSAEntry) {
                __pCache->pNextSAEntry->sa_FilterCache = NULL;
                __pCache->pNextSAEntry = NULL;
            }
        }
    }

    if (fFilter) {
        __pFilter = (PFILTER)(_pCtxt1);

        if (__pFilter->FilterCache) {
            INVALIDATE_CACHE_ENTRY(__pFilter->FilterCache);
            __pFilter->FilterCache = NULL;
        }

        __pCache->uliSrcDstAddr = (uliAddr);
        __pCache->uliProtoSrcDstPort = (uliPort);
        __pCache->FilterEntry = TRUE;
        __pCache->pFilter = __pFilter;
        __pFilter->FilterCache = __pCache;
    } else {
        __pSA = (PSA_TABLE_ENTRY)(_pCtxt1);
        __pNextSA = (PSA_TABLE_ENTRY)(_pCtxt2);

        if (__pSA->sa_FilterCache) {
		__pTempCache = __pSA->sa_FilterCache;
            __pTempCache->pSAEntry->sa_FilterCache = NULL;
            if (__pTempCache->pNextSAEntry) {
                __pTempCache->pNextSAEntry->sa_FilterCache = NULL;
            }
            INVALIDATE_CACHE_ENTRY(__pTempCache);
        }

        if (__pNextSA && __pNextSA->sa_FilterCache) {
	   	__pTempCache = __pNextSA->sa_FilterCache;
            __pTempCache->pSAEntry->sa_FilterCache = NULL;
            if (__pTempCache->pNextSAEntry) {
                __pTempCache->pNextSAEntry->sa_FilterCache = NULL;
            }
            INVALIDATE_CACHE_ENTRY(__pTempCache);
        }

        __pCache->uliSrcDstAddr = (uliAddr);
        __pCache->uliProtoSrcDstPort = (uliPort);
        __pCache->FilterEntry = FALSE;
        __pCache->pSAEntry = __pSA;
        __pSA->sa_FilterCache = __pCache;
        if (__pNextSA) {
            __pCache->pNextSAEntry = __pNextSA;
            __pNextSA->sa_FilterCache = __pCache;
        }
    }
}

__inline
VOID
IPSecInvalidateSACacheEntry(
    IN  PSA_TABLE_ENTRY     pSA
    )
{
    PFILTER_CACHE   pCache;

    pCache = pSA->sa_FilterCache;

    if (pCache) {
        ASSERT(IS_VALID_CACHE_ENTRY(pCache));
        ASSERT(pSA == pCache->pSAEntry || pSA == pCache->pNextSAEntry);
        pCache->pSAEntry->sa_FilterCache = NULL;
        if (pCache->pNextSAEntry) {
            pCache->pNextSAEntry->sa_FilterCache = NULL;
        }
        INVALIDATE_CACHE_ENTRY(pCache);
    }
}

__inline
VOID
IPSecInvalidateFilterCacheEntry(
    IN  PFILTER         pFilter
    )
{
    PFILTER_CACHE   pCache;

    pCache = pFilter->FilterCache;

    if (pCache) {
        ASSERT(IS_VALID_CACHE_ENTRY(pCache));
        ASSERT(IS_EXEMPT_FILTER(pFilter));
        pFilter->FilterCache = NULL;
        INVALIDATE_CACHE_ENTRY(pCache);
    }
}

__inline
VOID
IPSecStartSATimer(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  IPSEC_TIMEOUT_HANDLER   TimeoutHandler,
    IN  ULONG                   SecondsToGo
    )
{
    if (pSA->sa_Flags & FLAGS_SA_TIMER_STARTED) {
        if (IPSecStopTimer(&pSA->sa_Timer)) {
            IPSecStartTimer(&pSA->sa_Timer,
                            TimeoutHandler,
                            SecondsToGo,
                            (PVOID)pSA);
        }
    } else {
        pSA->sa_Flags |= FLAGS_SA_TIMER_STARTED;
        IPSecStartTimer(&pSA->sa_Timer,
                        TimeoutHandler,
                        SecondsToGo,
                        (PVOID)pSA);
    }
}

__inline
VOID
IPSecStopSATimer(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    if (pSA->sa_Flags & FLAGS_SA_TIMER_STARTED) {
        pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
        IPSecStopTimer(&pSA->sa_Timer);
    }
}

__inline
VOID
IPSecStopTimerDerefSA(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    if (pSA->sa_Flags & FLAGS_SA_TIMER_STARTED) {
        if (IPSecStopTimer(&pSA->sa_Timer)) {
            pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
            IPSecDerefSA(pSA);
        }
    } else {
        IPSecDerefSA(pSA);
    }
}

__inline
VOID
IPSecDerefSANextSA(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PSA_TABLE_ENTRY pNextSA
    )
{
    if (pNextSA) {
        IPSecDerefSA(pNextSA);
    }
    IPSecDerefSA(pSA);
}

__inline
VOID
IPSecRemoveSPIEntry(
    IN  PSA_TABLE_ENTRY pSA
    )
{
    if (pSA->sa_Flags & FLAGS_SA_ON_SPI_HASH) {
        IPSecRemoveEntryList(&pSA->sa_SPILinkage);
        pSA->sa_Flags &= ~FLAGS_SA_ON_SPI_HASH;
    }
}

//
// Packs the src/dest IP addrs in a large integer
//
#define IPSEC_BUILD_SRC_DEST_ADDR(_li, _src, _dest) {   \
    (_li).LowPart = _src;                               \
    (_li).HighPart = _dest;                             \
}

#define IPSEC_BUILD_SRC_DEST_MASK   IPSEC_BUILD_SRC_DEST_ADDR

//
// Packs the Proto and Src/Dest ports into a large int
//
//
// Ports make sense only for TCP and UDP
//
//
// TCP/UDP header
// 0                 15 16               31
// |----|----|----|----|----|----|----|----|
// |    Source Port    |    Dst Port       |
//
#define IPSEC_BUILD_PROTO_PORT_LI(_li, _proto, _sport, _dport) {    \
    (_li).LowPart =                                                 \
      MAKELONG(MAKEWORD((_proto),0x00),0x0000);                     \
    switch((_li).LowPart) {                                         \
        case 6:                                                     \
        case 17: {                                                  \
            (_li).HighPart =  MAKELONG((_sport),(_dport));          \
            break;                                                  \
        }                                                           \
        default: {                                                  \
            (_li).HighPart = 0x00000000;                            \
            break;                                                  \
        }                                                           \
    }                                                               \
}

#define IPSecRefFilter(__pfilter)   IPSEC_INCREMENT((__pfilter)->Reference)

#define IPSecFreeFilter(__pfilter)  IPSecFreeMemory(__pfilter)

#define IPSecDerefFilter(__pfilter)                     \
{                                                       \
    if (IPSEC_DECREMENT((__pfilter)->Reference) == 0) { \
        IPSecFreeFilter(__pfilter);                     \
    }                                                   \
}

#define IPSecAllocateKeyBuffer(_size)   IPSecAllocateMemory(_size, IPSEC_TAG_KEY)
#define IPSecFreeKeyBuffer(_key)    IPSecFreeMemory(_key)


#define IPSecAllocateLogBuffer(_size)   IPSecAllocateMemory(_size, IPSEC_TAG_LOG)
#define IPSecFreeLogBuffer(_key)    IPSecFreeMemory(_key)


#define IPSecFreeSA(_sa) {                          \
    LONG    _i;                                     \
    for (_i=0; _i<(_sa)->sa_NumOps; _i++) {         \
        if ((_sa)->INT_KEY(_i)) {                   \
            IPSecFreeKeyBuffer((_sa)->INT_KEY(_i)); \
        }                                           \
        if ((_sa)->CONF_KEY(_i)) {                  \
            IPSecFreeKeyBuffer((_sa)->CONF_KEY(_i));\
        }                                           \
    }                                               \
    IPSecFreeMemory(_sa);                           \
}

#define IPSecGetAcquireContext()        IPSecAllocateMemory(sizeof(IPSEC_ACQUIRE_CONTEXT), IPSEC_TAG_ACQUIRE_CTX)
#define IPSecFreeAcquireContext(_ctx)   IPSecFreeMemory(_ctx)

#define IPSecGetNotifyExpire()        IPSecAllocateMemory(sizeof(IPSEC_NOTIFY_EXPIRE), IPSEC_TAG_ACQUIRE_CTX)

//
// Hashes <SPI, Dest>
//
#define IPSEC_HASH_SPI(_dest, _spi, _phash) {                               \
    DWORD   dwIndex;                                                        \
    dwIndex = NET_TO_HOST_LONG(_dest) + (_spi);                             \
    dwIndex %= g_ipsec.SAHashSize;                                          \
    pHash = &g_ipsec.pSADb[dwIndex];                                        \
    IPSEC_DEBUG_KD_ONLY(                                                    \
        DBF_EXTRADIAGNOSTIC, ("SPI: Index: %lx for S: %lx, D: %lx, pHash: %lx",               \
        dwIndex,                                                            \
        (_spi),                                                             \
        (_dest),                                                            \
        pHash));                                                            \
}

//
// Hashes <Src, Dest>
//
#define IPSEC_HASH_ADDR(_src, _dest,_phash) {                               \
    DWORD   dwIndex;                                                        \
    dwIndex = (_src)+(_dest);                                               \
    dwIndex %= g_ipsec.SpFilterHashSize;                                    \
    pHash = &g_ipsec.pSpFilter[dwIndex];                                    \
    IPSEC_DEBUG_KD_ONLY(                                                    \
        DBF_EXTRADIAGNOSTIC, ("ADDR: Index: %lx for S: %lx, D: %lx, pHash: %lx",              \
        dwIndex,                                                            \
        (_src),                                                             \
        (_dest),                                                            \
        pHash));                                                            \
}

#define SRC_ADDR   uliSrcDstAddr.LowPart
#define DEST_ADDR  uliSrcDstAddr.HighPart
#define SRC_MASK   uliSrcDstMask.LowPart
#define DEST_MASK  uliSrcDstMask.HighPart
#define PROTO      uliProtoSrcDstPort.LowPart
#define SRC_PORT   LOWORD(uliProtoSrcDstPort.HighPart)
#define DEST_PORT  HIWORD(uliProtoSrcDstPort.HighPart)

#define FI_SRC_PORT(_filter)    LOWORD((_filter)->uliProtoSrcDstPort.HighPart)
#define FI_DEST_PORT(_filter)   HIWORD((_filter)->uliProtoSrcDstPort.HighPart)

#define SA_SRC_ADDR  sa_uliSrcDstAddr.LowPart
#define SA_DEST_ADDR sa_uliSrcDstAddr.HighPart
#define SA_SRC_MASK  sa_uliSrcDstMask.LowPart
#define SA_DEST_MASK sa_uliSrcDstMask.HighPart
#define SA_PROTO     sa_uliProtoSrcDstPort.LowPart

#define SA_SRC_PORT(_psa)       LOWORD((_psa)->sa_uliProtoSrcDstPort.HighPart)
#define SA_DEST_PORT(_psa)      HIWORD((_psa)->sa_uliProtoSrcDstPort.HighPart)

#define FILTER_PROTO(ProtoId)   MAKELONG(MAKEWORD((ProtoId),0x00),0x00000)
#define FILTER_PROTO_ANY        FILTER_PROTO(0x00)
#define FILTER_PROTO_ICMP       FILTER_PROTO(0x01)
#define FILTER_PROTO_TCP        FILTER_PROTO(0x06)
#define FILTER_PROTO_UDP        FILTER_PROTO(0x11)

#define FILTER_TCPUDP_PORT_ANY  (WORD)0x0000

#define FILTER_ICMP_TYPE_ANY    (BYTE)0xff
#define FILTER_ICMP_CODE_ANY    (BYTE)0xff

#define FILTER_MASK_ALL         (DWORD)0xffffffff
#define FILTER_MASK_NONE        (DWORD)0x00000000

//
// macros to parse the ALGORITHM structure
//
#define INT_ALGO(_i)    sa_Algorithm[_i].integrityAlgo.algoIdentifier
#define INT_KEY(_i)     sa_Algorithm[_i].integrityAlgo.algoKey
#define INT_KEYLEN(_i)  sa_Algorithm[_i].integrityAlgo.algoKeylen
#define INT_ROUNDS(_i)  sa_Algorithm[_i].integrityAlgo.algoRounds

#define CONF_ALGO(_i)   sa_Algorithm[_i].confAlgo.algoIdentifier
#define CONF_KEY(_i)    sa_Algorithm[_i].confAlgo.algoKey
#define CONF_KEYLEN(_i) sa_Algorithm[_i].confAlgo.algoKeylen
#define CONF_ROUNDS(_i) sa_Algorithm[_i].confAlgo.algoRounds

#define COMP_ALGO(_i)   sa_Algorithm[_i].compAlgo.algoIdentifier

#define EXT_INT_ALGO    IntegrityAlgo.algoIdentifier
#define EXT_INT_KEY     IntegrityAlgo.algoKey
#define EXT_INT_KEYLEN  IntegrityAlgo.algoKeylen
#define EXT_INT_ROUNDS  IntegrityAlgo.algoRounds

#define EXT_CONF_ALGO   ConfAlgo.algoIdentifier
#define EXT_CONF_KEY    ConfAlgo.algoKey
#define EXT_CONF_KEYLEN ConfAlgo.algoKeylen
#define EXT_CONF_ROUNDS ConfAlgo.algoRounds

#define EXT_INT_ALGO_EX(_i)    AlgoInfo[_i].IntegrityAlgo.algoIdentifier
#define EXT_INT_KEYLEN_EX(_i)  AlgoInfo[_i].IntegrityAlgo.algoKeylen
#define EXT_INT_ROUNDS_EX(_i)  AlgoInfo[_i].IntegrityAlgo.algoRounds

#define EXT_CONF_ALGO_EX(_i)   AlgoInfo[_i].ConfAlgo.algoIdentifier
#define EXT_CONF_KEYLEN_EX(_i) AlgoInfo[_i].ConfAlgo.algoKeylen
#define EXT_CONF_ROUNDS_EX(_i) AlgoInfo[_i].ConfAlgo.algoRounds

#define IS_AH_SA(_psa)  ((_psa)->sa_Operation[0] == Auth ||     \
                         (_psa)->sa_Operation[1] == Auth ||     \
                         (_psa)->sa_Operation[2] == Auth)
#define IS_ESP_SA(_psa) ((_psa)->sa_Operation[0] == Encrypt ||  \
                         (_psa)->sa_Operation[1] == Encrypt ||  \
                         (_psa)->sa_Operation[2] == Encrypt)

//
// Increment/decrement statistics
//
#define IPSEC_INC_STATISTIC(_stat) \
    (g_ipsec.Statistics.##_stat)++;

#define IPSEC_DEC_STATISTIC(_stat) \
    (g_ipsec.Statistics.##_stat)--;

#define IPSEC_INC_TUNNELS(_pSA) {           \
    if ((_pSA)->sa_Flags & FLAGS_SA_TUNNEL) \
        g_ipsec.Statistics.dwNumActiveTunnels++; \
}

#define IPSEC_DEC_TUNNELS(_pSA) {           \
    if ((_pSA)->sa_Flags & FLAGS_SA_TUNNEL) \
        g_ipsec.Statistics.dwNumActiveTunnels--; \
}


//
// Function to read a dword from registry and init the variable passed in.
//
__inline
void IPSecRegReadDword(
    HANDLE hRegKey, 
    PWCHAR param,
    PULONG var,
    ULONG def,
    ULONG max,
    ULONG min
)
{
    NTSTATUS status;
    status = GetRegDWORDValue(hRegKey,
                            param,
                            var);
    if (!NT_SUCCESS(status)) {
        *(var) = def;                    
    } else if (*(var) > max) {   
        *(var) = max;                   
    } else if (*(var) <= min) {  
        *(var) = min;                    
    }             
}    

//
// Extended function with different default values for 
// different kind of registry errors.
//
__inline
void IPSecRegReadDwordEx(
    HANDLE  hRegKey,
    PWCHAR param,
    PULONG  var,
    ULONG    max,
    ULONG    min,
    ULONG    NoExist,    
    ULONG    ReadError,
    ULONG    OutOfRange
)
{
    NTSTATUS status;
    status = GetRegDWORDValue(hRegKey,
                        param,
                        var);
    
    if (!NT_SUCCESS(status)){

        if (STATUS_OBJECT_NAME_NOT_FOUND == status){
            (*var) = NoExist;
        }
        else{
            (*var) = ReadError;
        }
    }
    else if (((*var)>max) || ((*var)<min)){
        (*var) = OutOfRange;
    }    
}
    


//
// Macro for computing incremental checksum (RFC 1624)
//
#define UpdateIPLength(_piph, _length)                          \
{                                                               \
    ULONG   _sum;                                               \
    USHORT  _old;                                               \
                                                                \
    _old = NET_SHORT((_piph)->iph_length);                      \
    (_piph)->iph_length = (_length);                            \
    _sum = (~NET_SHORT((_piph)->iph_xsum) & 0xffff) +           \
           (~_old & 0xffff) +                                   \
           NET_SHORT((_piph)->iph_length);                      \
    _sum = (_sum & 0xffff) + (_sum >> 16);                      \
    _sum += (_sum >> 16);                                       \
    (_piph)->iph_xsum = NET_SHORT((USHORT)(~_sum & 0xffff));    \
}

#define UpdateIPProtocol(_piph, _proto)                         \
{                                                               \
    ULONG   _sum;                                               \
    USHORT  _old;                                               \
                                                                \
    _old = NET_SHORT(*(USHORT *)&(_piph)->iph_ttl);             \
    (_piph)->iph_protocol = (_proto);                           \
    _sum = (~NET_SHORT((_piph)->iph_xsum) & 0xffff) +           \
           (~_old & 0xffff) +                                   \
           NET_SHORT(*(USHORT *)&(_piph)->iph_ttl);             \
    _sum = (_sum & 0xffff) + (_sum >> 16);                      \
    _sum += (_sum >> 16);                                       \
    (_piph)->iph_xsum = NET_SHORT((USHORT)(~_sum & 0xffff));    \
}

#define IPSecPrint4Long(_key)               \
    DbgPrint("Key: %lx-%lx-%lx-%lx",        \
            *(ULONG *)&(_key)[0],           \
            *(ULONG *)&(_key)[4],           \
            *(ULONG *)&(_key)[8],           \
            *(ULONG *)&(_key)[12]);

#define IPSEC_DELAY_INTERVAL    ((LONGLONG)(-1 * 1000 * 1000))  // 1/10 sec.

#define IPSEC_DELAY_EXECUTION()                                     \
{                                                                   \
    IPSecDelayInterval.QuadPart = IPSEC_DELAY_INTERVAL;             \
    KeDelayExecutionThread(UserMode, FALSE, &IPSecDelayInterval);   \
}

#define IS_DRIVER_BLOCK()   (g_ipsec.OperationMode == IPSEC_BLOCK_MODE)
#define IS_DRIVER_BYPASS()  (g_ipsec.OperationMode == IPSEC_BYPASS_MODE)
#define IS_DRIVER_SECURE()  (g_ipsec.OperationMode == IPSEC_SECURE_MODE)
#define IS_DRIVER_BOOTSTATEFUL()  (g_ipsec.OperationMode == IPSEC_BOOTTIME_STATEFUL_MODE)
#define IS_DRIVER_FORWARD_BYPASS() (g_ipsec.DefaultForwardingBehavior == IPSEC_FORWARD_BYPASS)
#define IS_DRIVER_FORWARD_BLOCK()(g_ipsec.DefaultForwardingBehavior == IPSEC_FORWARD_BLOCK)

#define IS_DRIVER_DIAGNOSTIC()  (g_ipsec.DiagnosticMode)

#define LOG_EVENT   NdisWriteEventLogEntry

#define IPSEC_NULL_GUIDS    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

#define IPSEC_EQUAL_GUIDS(_A, _B)     \
    ((*(UNALIGNED ULONG *)((PUCHAR)(_A)) == *(UNALIGNED ULONG *)((PUCHAR)(_B))) &&         \
     (*(UNALIGNED ULONG *)(((PUCHAR)(_A))+4) == *(UNALIGNED ULONG *)(((PUCHAR)(_B))+4)) && \
     (*(UNALIGNED ULONG *)(((PUCHAR)(_A))+8) == *(UNALIGNED ULONG *)(((PUCHAR)(_B))+8)) && \
     (*(UNALIGNED ULONG *)(((PUCHAR)(_A))+12) == *(UNALIGNED ULONG *)(((PUCHAR)(_B))+12)))

//
// Get the next non-zero length NDIS buffer.
//
__inline
PNDIS_BUFFER
FASTCALL
IPSEC_NEXT_BUFFER(
    IN  PNDIS_BUFFER    pBuffer
    )
{
    PVOID   *pDummy = NULL;
    ULONG   Length = 0;

    if (!pBuffer) {
        ASSERT(FALSE);
        return  NULL;
    }

    pBuffer = NDIS_BUFFER_LINKAGE(pBuffer);

    while (pBuffer) {
        IPSecQueryNdisBuf(pBuffer, &pDummy, &Length);
        if (Length == 0) {
            pBuffer = NDIS_BUFFER_LINKAGE(pBuffer);
            continue;
        } else {
            return  pBuffer;
        }
    }

    return  NULL;
}

#define SA_CHAIN_WIDTH  4

//
// Count number of 1's in the IP mask
//
__inline
LONG
CountNumberOfOnes(
    IN  IPMask  IpMask
    )
{
    INT     i;
    LONG    NumberOfOnes = 0;
    IPMask  Mask = IpMask;

    for (i = 0; i < sizeof(IPMask) * 8; i++) {
        if ((Mask & 0x1) == 0x1) {
            NumberOfOnes++;
        }

        Mask = Mask >> 1;
    }

    return  NumberOfOnes;
}

__inline
PLIST_ENTRY
FASTCALL
IPSecResolveSAChain(
    IN  PFILTER pFilter,
    IN  IPAddr  IpAddr
    )
{
    PLIST_ENTRY pEntry;
    ULONG       Index;

    if (IS_TUNNEL_FILTER(pFilter)) {
        pEntry = &pFilter->SAChain[0];
    } else {
        Index = NET_TO_HOST_LONG(IpAddr) % pFilter->SAChainSize;
        pEntry = &pFilter->SAChain[Index];
    }

    return  pEntry;
}



// This function should only be called
// when holding SABDlock
__inline
PIPSEC_STATEFUL_ENTRY
IPSecAllocateFromHashPool(
    VOID
    )
{
    PIPSEC_STATEFUL_ENTRY pMem;
    int index;
    BOOL fReuse=FALSE;
    //Get index of buffer to use
    //
    index = 
           g_ipsec.BootBufferPool->ulCurrentPosition;
    //Update index
    //
    if (TOTAL_STATEFUL_ENTRY_COUNT ==
            (++g_ipsec.BootBufferPool->ulCurrentPosition)){
            g_ipsec.BootBufferPool->ulCurrentPosition = 0; 
        }
    //if used up all locations then recycle
    //
    if (g_ipsec.BootBufferPool->ulEntriesUsed < TOTAL_STATEFUL_ENTRY_COUNT){
            g_ipsec.BootBufferPool->ulEntriesUsed++;
        }
    else
        {
            //Reuse this connection. Remove it from it's location in the Hash Table
            //This can result in dropped packets
            //
            IPSecRemoveEntryList(&(g_ipsec.BootBufferPool->PoolEntry[index].CollisionLinkage));
        }
    //Return the buffer selected at location index
    //
    return (&(g_ipsec.BootBufferPool->PoolEntry[index]));
}
    
    
        

#if GPC
#define IPSEC_GPC_MASK_ALL      (0xff)
#define IPSEC_GPC_MASK_NONE     (0x0)

#define GPC_REGISTER_CLIENT     g_ipsec.GpcEntries.GpcRegisterClientHandler
#define GPC_DEREGISTER_CLIENT   g_ipsec.GpcEntries.GpcDeregisterClientHandler
#define GPC_ADD_CFINFO          g_ipsec.GpcEntries.GpcAddCfInfoHandler
#define GPC_REMOVE_CFINFO       g_ipsec.GpcEntries.GpcRemoveCfInfoHandler
#define GPC_ADD_PATTERN         g_ipsec.GpcEntries.GpcAddPatternHandler
#define GPC_REMOVE_PATTERN      g_ipsec.GpcEntries.GpcRemovePatternHandler
#define GPC_CLASSIFY_PATTERN    g_ipsec.GpcEntries.GpcClassifyPatternHandler
#define GPC_GET_CLIENT_CONTEXT  g_ipsec.GpcEntries.GpcGetCfInfoClientContextHandler

#define IPSEC_GPC_ACTIVE        (0x12345678)
#define IPSEC_NUM_GPC_FILTERS() (g_ipsec.NumMaskedFilters)

#define IS_GPC_ACTIVE()         (g_ipsec.GpcActive == IPSEC_GPC_ACTIVE)

#define IPSEC_SET_GPC_ACTIVE()              \
{                                           \
    g_ipsec.GpcActive = IPSEC_GPC_ACTIVE;   \
}

#define IPSEC_UNSET_GPC_ACTIVE()            \
{                                           \
    g_ipsec.GpcActive = 0;                  \
}

__inline
INT
FASTCALL
IPSecResolveGpcCf(
    IN  BOOLEAN fOutbound
    )
{
    return  fOutbound? GPC_CF_IPSEC_OUT: GPC_CF_IPSEC_IN;
}

__inline
PLIST_ENTRY
FASTCALL
IPSecResolveGpcFilterList(
    IN  BOOLEAN     fTunnel,
    IN  BOOLEAN     fOutbound
    )
{
    PLIST_ENTRY pEntry;

    if (fTunnel) {
        if (fOutbound) {
            pEntry = &g_ipsec.GpcFilterList[OUTBOUND_TUNNEL_FILTER];
        } else {
            pEntry = &g_ipsec.GpcFilterList[INBOUND_TUNNEL_FILTER];
        }
    } else {
        if (fOutbound) {
            pEntry = &g_ipsec.GpcFilterList[OUTBOUND_TRANSPORT_FILTER];
        } else {
            pEntry = &g_ipsec.GpcFilterList[INBOUND_TRANSPORT_FILTER];
        }
    }

    return  pEntry;
}

__inline
VOID
IPSEC_CLASSIFY_PACKET(
    IN  INT                     GpcCf,
    IN  ULARGE_INTEGER          uliSrcDstAddr,
    IN  ULARGE_INTEGER          uliProtoSrcDstPort,
    OUT PFILTER                 *ppFilter,
    OUT PCLASSIFICATION_HANDLE  pGpcHandle
    )
{
    GPC_IP_PATTERN  Pattern;

    *ppFilter = NULL;
    *pGpcHandle = 0;

    Pattern.SrcAddr = SRC_ADDR;
    Pattern.DstAddr = DEST_ADDR;
    Pattern.ProtocolId = (UCHAR)PROTO;
    if (PROTO == PROTOCOL_TCP || PROTO == PROTOCOL_UDP) {
        Pattern.gpcSrcPort = SRC_PORT;
        Pattern.gpcDstPort = DEST_PORT;
    } else {
        Pattern.gpcSrcPort = 0;
        Pattern.gpcDstPort = 0;
    }
    Pattern.InterfaceId.InterfaceId = 0;
    Pattern.InterfaceId.LinkId = 0;

    GPC_CLASSIFY_PATTERN(   g_ipsec.GpcClients[GpcCf],
                            GPC_PROTOCOL_TEMPLATE_IP,
                            &Pattern,
                            ppFilter,
                            pGpcHandle,
                            0,
                            NULL,
                            TRUE);
}

#define IS_GPC_FILTER(f)    (g_ipsec.InitGpc &&                 \
                             f->SRC_MASK == FILTER_MASK_ALL &&  \
                             f->DEST_MASK == FILTER_MASK_ALL)
#endif

#if FIPS
#define IPSEC_DES_ALGO      FIPS_CBC_DES
#define IPSEC_3DES_ALGO     FIPS_CBC_3DES
#define IPSEC_SHA_INIT      g_ipsec.FipsFunctionTable.FipsSHAInit
#define IPSEC_SHA_UPDATE    g_ipsec.FipsFunctionTable.FipsSHAUpdate
#define IPSEC_SHA_FINAL     g_ipsec.FipsFunctionTable.FipsSHAFinal
#define IPSEC_DES_KEY       g_ipsec.FipsFunctionTable.FipsDesKey
#define IPSEC_3DES_KEY      g_ipsec.FipsFunctionTable.Fips3Des3Key
#define IPSEC_CBC           g_ipsec.FipsFunctionTable.FipsCBC
#define IPSEC_GEN_RANDOM    g_ipsec.FipsFunctionTable.FIPSGenRandom
#define IPSEC_HMAC_SHA_INIT g_ipsec.FipsFunctionTable.FipsHmacSHAInit
#define IPSEC_HMAC_SHA_UPDATE g_ipsec.FipsFunctionTable.FipsHmacSHAUpdate
#define IPSEC_HMAC_SHA_FINAL g_ipsec.FipsFunctionTable.FipsHmacSHAFinal
#define IPSEC_HMAC_MD5_INIT g_ipsec.FipsFunctionTable.HmacMD5Init
#define IPSEC_HMAC_MD5_UPDATE g_ipsec.FipsFunctionTable.HmacMD5Update
#define IPSEC_HMAC_MD5_FINAL g_ipsec.FipsFunctionTable.HmacMD5Final
#else
#define IPSEC_DES_ALGO      des
#define IPSEC_3DES_ALGO     tripledes
#define IPSEC_SHA_INIT      A_SHAInit
#define IPSEC_SHA_UPDATE    A_SHAUpdate
#define IPSEC_SHA_FINAL     A_SHAFinal
#define IPSEC_DES_KEY       deskey
#define IPSEC_3DES_KEY      tripledes3key
#define IPSEC_CBC(_EncryptionAlgo, _pOut, _pIn, _pKeyTable, _Operation, _pFeedback) \
    CBC(_EncryptionAlgo,    \
        DES_BLOCKLEN,       \
        _pOut,              \
        _pIn,               \
        _pKeyTable,         \
        _Operation,         \
        _pFeedback)
#define IPSEC_GEN_RANDOM(_pBuf, _KeySize)   NewGenRandom(NULL, NULL, _pBuf, _KeySize)
#endif
#define IPSEC_MD5_INIT      MD5Init
#define IPSEC_MD5_UPDATE    MD5Update
#define IPSEC_MD5_FINAL     MD5Final
#define IPSEC_RC4_KEY       rc4_key        
#define IPSEC_RC4           rc4

#define IS_CLASS_D_ADDR(x)  (((x) & 0x000000f0) == 0x000000e0)


#define TCPIP_FREE_BUFF         g_ipsec.TcpipFreeBuff
#define TCPIP_ALLOC_BUFF        g_ipsec.TcpipAllocBuff
#define TCPIP_GET_ADDRTYPE      g_ipsec.TcpipGetAddrType
#define TCPIP_GET_INFO          g_ipsec.TcpipGetInfo
#define TCPIP_NDIS_REQUEST      g_ipsec.TcpipNdisRequest
#define TCPIP_REGISTER_PROTOCOL g_ipsec.TcpipRegisterProtocol
#define TCPIP_SET_IPSEC_STATUS  g_ipsec.TcpipSetIPSecStatus
#define TCPIP_IP_TRANSMIT       g_ipsec.TcpipIPTransmit
#define TCPIP_SET_IPSEC         g_ipsec.TcpipSetIPSecPtr
#define TCPIP_UNSET_IPSEC       g_ipsec.TcpipUnSetIPSecPtr
#define TCPIP_UNSET_IPSEC_SEND  g_ipsec.TcpipUnSetIPSecSendPtr
#define TCPIP_TCP_XSUM          g_ipsec.TcpipTCPXsum
#define TCPIP_GEN_IPID          g_ipsec.TcpipGenIpId
#define TCPIP_DEREGISTER_PROTOCOL g_ipsec.TcpipDeRegisterProtocol
#define TCPIP_GET_PINFO         g_ipsec.TcpipGetPInfo
#define TCPIP_SEND_ICMP_ERR     g_ipsec.TcpipSendICMPErr


#ifdef xsum
#undef xsum
#define xsum(Buffer, Length)    ((USHORT)TCPIP_TCP_XSUM(0, (PUCHAR)(Buffer), (Length)))
#endif


#define SAFETY_LEN  (TRUNCATED_HASH_LEN+MAX_PAD_LEN)


//
// Compares the src/dest ports out of a word with the number input
//
#define IPSEC_COMPARE_SD_PORT(_pport, _port)    \
    (   ((_pport)[0] == (_port)) ||     \
        ((_pport)[1] == (_port)))

#define IPSEC_COMPARE_D_PORT(_pport, _port) ((_pport)[1] == (_port))

//
// Bypass traffic logic for IKE, Kerberos and RSVP
//
#define IPSEC_KERBEROS_TRAFFIC()                            \
    ((pIPHeader->iph_protocol == PROTOCOL_UDP ||            \
      pIPHeader->iph_protocol == PROTOCOL_TCP) &&           \
     IPSEC_COMPARE_SD_PORT(pwPort, IPSEC_KERBEROS_PORT))

#define IPSEC_ISAKMP_TRAFFIC()                              \
    (pIPHeader->iph_protocol == PROTOCOL_UDP &&             \
     IPSEC_COMPARE_D_PORT(pwPort, IPSEC_ISAKMP_PORT))       \

#define IPSEC_ISAKMP_TRAFFIC2()                              \
    (pIPHeader->iph_protocol == PROTOCOL_UDP &&             \
     IPSEC_COMPARE_D_PORT(pwPort, IPSEC_ISAKMP_PORT2))       \


#define IPSEC_RSVP_TRAFFIC()                                \
    (pIPHeader->iph_protocol == PROTOCOL_RSVP)

#define IPSEC_NO_UNICAST_EXEMPT   0x00000001
#define IPSEC_NO_MANDBCAST_EXEMPT 0x00000002

#define IPSEC_NO_DEFAULT_EXEMPT()   (g_ipsec.NoDefaultExempt & IPSEC_NO_UNICAST_EXEMPT)
#define IPSEC_HANDLE_MANDBCAST()   (g_ipsec.NoDefaultExempt & IPSEC_NO_MANDBCAST_EXEMPT)

#define IPSEC_MANDBCAST_PROCESS() (IPSEC_GET_VALUE(g_ipsec.NumMulticastFilters) || \
                                   IPSEC_HANDLE_MANDBCAST())

#define IPSEC_BYPASS_TRAFFIC()                              \
    (IPSEC_ISAKMP_TRAFFIC() || IPSEC_ISAKMP_TRAFFIC2() ||   \
     (!IPSEC_NO_DEFAULT_EXEMPT() &&                         \
      (IPSEC_KERBEROS_TRAFFIC() ||                          \
       IPSEC_RSVP_TRAFFIC())))

//
// Forwarding path is either reinject a detunneled forward packet or route
//
#define IPSEC_FORWARD_PATH()    (fFWPacket || (fOutbound && TCPIP_GET_ADDRTYPE(pIPHeader->iph_src) != DEST_LOCAL))


#define EQUAL_NATENCAP(_pNatContext,_pSA) ((_pNatContext == NULL) || (_pNatContext && (_pSA->sa_EncapContext.wSrcEncapPort == _pNatContext->wSrcEncapPort && _pSA->sa_EncapContext.wDesEncapPort == _pNatContext->wDesEncapPort)))

/*++

Routine Description:

    Fills in the DELETE_SA hw request from pSA

Arguments:

    pSA - the SA
    Buf - buffer to set info
    Len - length

Return Value:

    status of the operation

--*/
#define IPSecFillHwDelSA(_pSA, _Buf, _Len) \
    ((POFFLOAD_IPSEC_DELETE_SA)(_Buf))->OffloadHandle = (_pSA)->sa_OffloadHandle;


#endif  _MACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\arp.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** ARP.H - Exports from ARP.
//
// This file contains the public definitons from ARP.
int ARPInit(void);

#pragma warning(push)
#pragma warning(disable:4115) // named type definition in parenthesis
int ARPRegister(PNDIS_STRING Adapter, uint *Flags,
                struct ARPInterface **Interface);
#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\timer.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Contains timer management structures.

Author:

    Sanjay Anand (SanjayAn) 26-May-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#ifndef  _TIMER_H
#define  _TIMER_H

#if DBG
#define atl_signature		'LTA '
#endif // DBG

/*++
ULONG
SECONDS_TO_LONG_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "long duration timer ticks"
--*/
#define SECONDS_TO_SUPER_LONG_TICKS(Seconds)		((Seconds)/3600)

/*++
ULONG
SECONDS_TO_LONG_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "long duration timer ticks"
--*/
#define SECONDS_TO_LONG_TICKS(Seconds)		((Seconds)/60)

/*++
ULONG
SECONDS_TO_SHORT_TICKS(
	IN	ULONG				Seconds
)
Convert from seconds to "short duration timer ticks"
--*/
#define SECONDS_TO_SHORT_TICKS(Seconds)		(Seconds)

/*++
VOID
IPSEC_INIT_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	PNDIS_TIMER_FUNCTON	pFunc,
	IN	PVOID				Context
)
--*/
#define IPSEC_INIT_SYSTEM_TIMER(pTimer, pFunc, Context)	\
			NdisInitializeTimer(pTimer, (PNDIS_TIMER_FUNCTION)(pFunc), (PVOID)Context)

/*++
VOID
IPSEC_START_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer,
	IN	UINT				PeriodInSeconds
)
--*/
#define IPSEC_START_SYSTEM_TIMER(pTimer, PeriodInSeconds)	\
			NdisSetTimer(pTimer, (UINT)(PeriodInSeconds * 1000))

/*++
VOID
IPSEC_STOP_SYSTEM_TIMER(
	IN	PNDIS_TIMER			pTimer
)
--*/
#define IPSEC_STOP_SYSTEM_TIMER(pTimer)						\
			{												\
				BOOLEAN		WasCancelled;					\
				NdisCancelTimer(pTimer, &WasCancelled);		\
			}

/*++
BOOLEAN
IPSEC_IS_TIMER_ACTIVE(
	IN	PIPSEC_TIMER		pArpTimer
)
--*/
#define IPSEC_IS_TIMER_ACTIVE(pTmr)	((pTmr)->pTimerList != (PIPSEC_TIMER_LIST)NULL)

/*++
ULONG
IPSEC_GET_TIMER_DURATION(
	IN	PIPSEC_TIMER		pTimer
)
--*/
#define IPSEC_GET_TIMER_DURATION(pTmr)	((pTmr)->Duration)

//
// Timer management using Timing Wheels (adapted from IPSEC)
//

struct _IPSEC_TIMER ;
struct _IPSEC_TIMER_LIST ;

//
//  Timeout Handler prototype
//
typedef
VOID
(*IPSEC_TIMEOUT_HANDLER) (
	IN	struct _IPSEC_TIMER *	pTimer,
	IN	PVOID			Context
);

//
//  An IPSEC_TIMER structure is used to keep track of each timer
//  in the IPSEC module.
//
typedef struct _IPSEC_TIMER {
	struct _IPSEC_TIMER *			pNextTimer;
	struct _IPSEC_TIMER *			pPrevTimer;
	struct _IPSEC_TIMER *			pNextExpiredTimer;	// Used to chain expired timers
	struct _IPSEC_TIMER_LIST *		pTimerList;			// NULL iff this timer is inactive
	ULONG							Duration;			// In seconds
	ULONG							LastRefreshTime;
	IPSEC_TIMEOUT_HANDLER			TimeoutHandler;
	PVOID							Context;			// To be passed to timeout handler
} IPSEC_TIMER, *PIPSEC_TIMER;

//
//  NULL pointer to IPSEC Timer
//
#define NULL_PIPSEC_TIMER	((PIPSEC_TIMER)NULL)

//
//  Control structure for a timer wheel. This contains all information
//  about the class of timers that it implements.
//
typedef struct _IPSEC_TIMER_LIST {
#if DBG
	ULONG							atl_sig;
#endif // DBG
	PIPSEC_TIMER					pTimers;		// List of timers
	ULONG							TimerListSize;	// Length of above
	ULONG							CurrentTick;	// Index into above
	ULONG							TimerCount;		// Number of running timers
	ULONG							MaxTimer;		// Max timeout value for this
	NDIS_TIMER						NdisTimer;		// System support
	UINT							TimerPeriod;	// Interval between ticks
	PVOID							ListContext;	// Used as a back pointer to the
													// Interface structure
} IPSEC_TIMER_LIST, *PIPSEC_TIMER_LIST;

//
//  Timer Classes
//
typedef enum {
	IPSEC_CLASS_SHORT_DURATION,
 	IPSEC_CLASS_LONG_DURATION,
    IPSEC_CLASS_SUPER_LONG_DURATION,
	IPSEC_CLASS_MAX
} IPSEC_TIMER_CLASS;

//
//  Timer configuration.
//
#define IPSEC_MAX_TIMER_SHORT_DURATION          (60)        // 60 seconds
#define IPSEC_MAX_TIMER_LONG_DURATION           (60*60)     // 1 hour in secs
#define IPSEC_MAX_TIMER_SUPER_LONG_DURATION     (48*3600)   // 48 hours in secs

#define IPSEC_SHORT_DURATION_TIMER_PERIOD       (1)         // 1 second
#define IPSEC_LONG_DURATION_TIMER_PERIOD        (1*60)      // 1 minute
#define IPSEC_SUPER_LONG_DURATION_TIMER_PERIOD  (1*3600)    // 1 hour

#define IPSEC_SA_EXPIRY_TIME                    (1*60)      // 1 minute in secs
#define IPSEC_REAPER_TIME                       (60)        // 60 secs


BOOLEAN
IPSecInitTimer(
    );

VOID
IPSecStartTimer(
    IN  PIPSEC_TIMER            pTimer,
    IN  IPSEC_TIMEOUT_HANDLER   TimeoutHandler,
    IN  ULONG                   SecondsToGo,
    IN  PVOID                   Context
    );

BOOLEAN
IPSecStopTimer(
    IN  PIPSEC_TIMER    pTimer
    );

VOID
IPSecTickHandler(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   Context,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    );

#endif  _TIMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\saapi.h ===
//
// List of weak and semi-weak DES keys from
// Applied Cryptography: Protocols, Algorithms, and Source Code in C,
// second edition by Bruce Schneier.
//

#define NUM_WEAK_KEYS 16


BOOLEAN
IPSecInitRandom(
    VOID
    );

VOID
IPSecRngRekey(
    IN  PVOID   Context
    );

BOOLEAN
IPSecGenerateRandom(
    IN  PUCHAR  pBuf,
    IN  ULONG   BytesNeeded
    );

VOID
IPSecCleanupOutboundSA(
    IN  PSA_TABLE_ENTRY pInboundSA,
    IN  PSA_TABLE_ENTRY pOutboundSA,
    IN  BOOLEAN         fNoDelete
    );

VOID
IPSecCleanupLarvalSA(
    IN  PSA_TABLE_ENTRY  pSA
    );

VOID
IPSecDeleteLarvalSA(
    IN  PSA_TABLE_ENTRY  pSA
    );

VOID
IPSecDeleteInboundSA(
    IN  PSA_TABLE_ENTRY  pInboundSA
    );

VOID
IPSecExpireInboundSA(
    IN  PSA_TABLE_ENTRY  pInboundSA
    );

NTSTATUS
IPSecCheckInboundSA(
    IN  PSA_STRUCT             pSAStruct,
    IN  PSA_TABLE_ENTRY        pSA
    );

BOOLEAN
IPSecIsWeakDESKey(
    IN  PUCHAR  Key
    );

BOOLEAN
IPSecIsWeak3DESKey(
    IN  PUCHAR  Key
    );

NTSTATUS
IPSecPopulateSA(
    IN  PSA_STRUCT              pSAStruct,
    IN  ULONG                   KeyLen,
    IN  PSA_TABLE_ENTRY         pSA
    );

NTSTATUS
IPSecCreateSA(
    OUT PSA_TABLE_ENTRY         *ppSA
    );

PSA_TABLE_ENTRY
IPSecLookupSABySPI(
    IN  tSPI    SPI,
    IN  IPAddr  DestAddr
    );

PSA_TABLE_ENTRY
IPSecLookupSABySPIWithLock(
    IN  tSPI    SPI,
    IN  IPAddr  DestAddr
    );

NTSTATUS
IPSecLookupSAByAddr(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    OUT PSA_TABLE_ENTRY *ppNextSA,
    OUT PSA_TABLE_ENTRY *ppTunnelSA,
    IN  BOOLEAN         fOutbound,
    IN  BOOLEAN         fFWPacket,
    IN  BOOLEAN         fBypass,
    IN BOOLEAN          fVerify,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    );

NTSTATUS
IPSecLookupTunnelSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    );

NTSTATUS
IPSecLookupMaskedSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    );

NTSTATUS
IPSecAllocateSPI(
    OUT tSPI            * pSpi,
    IN  PSA_TABLE_ENTRY   pSA
    );

NTSTATUS
IPSecNegotiateSA(
    IN  PFILTER         pFilter,
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    IN  ULONG           NewMTU,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN UCHAR            DestType,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pEncapContext
    );

VOID
IPSecFlushQueuedPackets(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  NTSTATUS                status
    );

NTSTATUS
IPSecInsertOutboundSA(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  PIPSEC_ACQUIRE_CONTEXT  pAcquireCtx,
    IN  BOOLEAN                 fTunnelFilter
    );

NTSTATUS
IPSecAddSA(
    IN  PIPSEC_ADD_SA   pAddSA,
    IN  ULONG           TotalSize
    );

NTSTATUS
IPSecUpdateSA(
    IN  PIPSEC_UPDATE_SA    pUpdateSA,
    IN  ULONG               TotalSize
    );

VOID
IPSecRefSA(
    IN  PSA_TABLE_ENTRY         pSA
    );

VOID
IPSecDerefSA(
    IN  PSA_TABLE_ENTRY         pSA
    );

VOID
IPSecStopSATimers(
    );

VOID
IPSecFlushLarvalSAList(
    );

NTSTATUS
IPSecDeleteSA(
    IN  PIPSEC_DELETE_SA    pDeleteSA
    );

NTSTATUS
IPSecExpireSA(
    IN  PIPSEC_EXPIRE_SA    pExpireSA
    );

VOID
IPSecSAExpired(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    );

VOID
IPSecFillSAInfo(
    IN  PSA_TABLE_ENTRY pSA,
    OUT PIPSEC_SA_INFO  pBuf
    );

NTSTATUS
IPSecEnumSAs(
    IN  PIRP    pIrp,
    OUT PULONG  pBytesCopied
    );

VOID
IPSecReaper(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    );

VOID
IPSecReapIdleSAs(
    );

VOID
IPSecFlushEventLog(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    );

NTSTATUS
IPSecQuerySpi(
    IN OUT PIPSEC_QUERY_SPI pQuerySpi
    );

NTSTATUS
IPSecSetOperationMode(
    IN PIPSEC_SET_OPERATION_MODE    pSetOperationMode
    );

NTSTATUS
IPSecInitializeTcpip(
    IN PIPSEC_SET_TCPIP_STATUS  pSetTcpipStatus
    );

NTSTATUS
IPSecDeinitializeTcpip(
    VOID
    );

NTSTATUS
IPSecSetTcpipStatus(
    IN PIPSEC_SET_TCPIP_STATUS  pSetTcpipStatus
    );

NTSTATUS
IPSecResetCacheTable(
    VOID
    );

NTSTATUS
IPSecPurgeFilterSAs(
    IN PFILTER             pFilter
    );

NTSTATUS
IPSecSetupSALifetime(
    IN  PSA_TABLE_ENTRY pSA
    );

BOOLEAN
IPSecMatchSATemplate(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PIPSEC_QM_SA    pSATemplate
    );

VOID ConvertEncapInfo(PSA_TABLE_ENTRY pInSA,
                      PUDP_ENCAP_INFO pEncapInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\saapi.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    saapi.c

Abstract:

    This module contains the SAAPI implementation

Author:

    Sanjay Anand (SanjayAn) 12-May-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"

#ifdef RUN_WPP
#include "saapi.tmh"
#endif

#pragma hdrstop


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, IPSecInitRandom)
#endif


BOOLEAN
IPSecInitRandom(
    VOID
    )
/*++

Routine Description:

	Initialize the IPSecRngKey by calling into ksecdd to get 2048 bits of random
    and create the RC4 key.

Arguments:

    Called at PASSIVE level.

Return Value:

    TRUE/FALSE

--*/
{
    UCHAR   pBuf[RNG_KEY_SIZE];

    PAGED_CODE();

    if (IPSEC_GEN_RANDOM(pBuf, RNG_KEY_SIZE) == FALSE) {
        IPSEC_DEBUG(LL_A, DBF_LOAD, ("IPSEC_GEN_RANDOM failure."));
        return  FALSE;
    }

    //
    // Generate the key control structure.
    //
    IPSEC_RC4_KEY(&IPSecRngKey, RNG_KEY_SIZE, pBuf);

    return  TRUE;
}


VOID
IPSecRngRekey(
    IN  PVOID   Context
    )
/*++

Routine Description:

	Initialize the IPSecRngKey by calling into ksecdd to get 2048 bits of random
    and create the RC4 key.

Arguments:

    Called at PASSIVE level.

Return Value:

    None.

--*/
{
    IPSecInitRandom();

    IPSEC_DECREMENT(g_ipsec.NumWorkers);

#if DBG
    IPSecRngInRekey = 0;
#endif

    IPSEC_SET_VALUE(IPSecRngBytes, 0);
}


BOOLEAN
IPSecGenerateRandom(
    IN  PUCHAR  pBuf,
    IN  ULONG   BytesNeeded
    )
/*++

Routine Description:

	Generate a positive pseudo-random number between Lower and Upper bounds;
    simple linear congruential algorithm. ANSI C "rand()" function. Courtesy JameelH.

Arguments:

	LowerBound, UpperBound - range of random number.

Return Value:

	a random number.

--*/
{
    ULONG   RngBytes;

    IPSEC_RC4(&IPSecRngKey, BytesNeeded, pBuf);

    //
    // Rekey if we have exceeded the threshold.
    //
    RngBytes = IPSEC_ADD_VALUE(IPSecRngBytes, BytesNeeded);
    if (RngBytes <= RNG_REKEY_THRESHOLD &&
        (RngBytes + BytesNeeded) > RNG_REKEY_THRESHOLD) {
        //
        // Create a worker thread to perform the rekey since it has to be done
        // as paged code.
        //
#if DBG
        ASSERT(IPSecRngInRekey == 0);
        IPSecRngInRekey = 1;
#endif

        ExInitializeWorkItem(   &IPSecRngQueueItem,
                                IPSecRngRekey,
                                NULL);

        ExQueueWorkItem(&IPSecRngQueueItem, DelayedWorkQueue);

        IPSEC_INCREMENT(g_ipsec.NumWorkers);
    }

    return  TRUE;
}


VOID
IPSecCleanupOutboundSA(
    IN  PSA_TABLE_ENTRY pInboundSA,
    IN  PSA_TABLE_ENTRY pOutboundSA,
    IN  BOOLEAN         fNoDelete
    )
/*++

Routine Description:

    Deletes an outbound SA.

    Called with SADB lock held, returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL   kIrql;

    IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Deleting assoc (outbound) SA: %p", pOutboundSA));

    pInboundSA->sa_AssociatedSA = NULL;

    //
    // de-link from the Filter lists
    //
    if (pOutboundSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
        pOutboundSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
        IPSecRemoveEntryList(&pOutboundSA->sa_FilterLinkage);
    }

    //
    // So, we dont delete the Rekeyoriginal SA again.
    //
    if (pOutboundSA->sa_Flags & FLAGS_SA_REKEY_ORI) {
        pOutboundSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
        if (pOutboundSA->sa_RekeyLarvalSA) {
            ASSERT(pOutboundSA->sa_RekeyLarvalSA->sa_Flags & FLAGS_SA_REKEY);
            pOutboundSA->sa_RekeyLarvalSA->sa_RekeyOriginalSA = NULL;
        }
    }

    //
    // invalidate the associated cache entry
    //
    IPSecInvalidateSACacheEntry(pOutboundSA);

    pOutboundSA->sa_State = STATE_SA_ZOMBIE;
    pOutboundSA->sa_AssociatedSA = NULL;

    if (pOutboundSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
        IPSecDelHWSAAtDpc(pOutboundSA);
    }

    IPSEC_DEBUG(LL_A, DBF_REF, ("Out Deref IPSecCleanupOutboundSA"));
    IPSecStopTimerDerefSA(pOutboundSA);

    IPSEC_INC_STATISTIC(dwNumKeyDeletions);
}


VOID
IPSecCleanupLarvalSA(
    IN  PSA_TABLE_ENTRY  pSA
    )
/*++

Routine Description:

    Delete the LarvalSA.

    Called with Outbound Lock held, returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PSA_TABLE_ENTRY pOutboundSA;
    KIRQL           kIrql1;
    KIRQL           kIrql2;

    //
    // Also remove from Pending list if queued there.
    //
    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &kIrql1);
    if (pSA->sa_Flags & FLAGS_SA_PENDING) {
        ASSERT(pSA->sa_State == STATE_SA_LARVAL);
        IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecSAExpired: Removed from pending too: %p", pSA));
        IPSecRemoveEntryList(&pSA->sa_PendingLinkage);
        pSA->sa_Flags &= ~FLAGS_SA_PENDING;
    }
    RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, kIrql1);

    //
    // Flush all the queued packets
    //
    IPSecFlushQueuedPackets(pSA, STATUS_TIMEOUT);

    //
    // remove from inbound sa list
    //
    AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql1);
    IPSecRemoveSPIEntry(pSA);
    ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql1);

    //
    // invalidate the associated cache entry
    //
    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql2);
    if (pSA->sa_AcquireCtx) {
        IPSecInvalidateHandle(pSA->sa_AcquireCtx);
        pSA->sa_AcquireCtx = NULL;
    }
    RELEASE_LOCK(&pSA->sa_Lock, kIrql2);

    IPSecInvalidateSACacheEntry(pSA);

    if (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
        pSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
        IPSecRemoveEntryList(&pSA->sa_FilterLinkage);
    }

    if (pSA->sa_RekeyOriginalSA) {
        ASSERT(pSA->sa_Flags & FLAGS_SA_REKEY);
        ASSERT(pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA == pSA);
        ASSERT(pSA->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

        pSA->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
        pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
        pSA->sa_RekeyOriginalSA = NULL;
    }

    ASSERT (NULL == pSA->sa_RekeyLarvalSA);

    if (pOutboundSA = pSA->sa_AssociatedSA) {

        ASSERT (0);

        IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
        IPSEC_DEC_TUNNELS(pOutboundSA);
        IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

        IPSecCleanupOutboundSA(pSA, pOutboundSA, FALSE);
    }

    IPSEC_DEBUG(LL_A, DBF_REF, ("In Deref DeleteLarvalSA"));
    IPSecStopTimerDerefSA(pSA);
}


VOID
IPSecDeleteLarvalSA(
    IN  PSA_TABLE_ENTRY  pSA
    )
/*++

Routine Description:

    Delete the LarvalSA.

    Called with Outbound Lock held, returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL   kIrql;

    ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

    //
    // Remove from larval list
    //
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);
    IPSecRemoveEntryList(&pSA->sa_LarvalLinkage);
    IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);
    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    //
    // Cleanup the rest of larval SA
    //
    IPSecCleanupLarvalSA(pSA);
}


VOID
IPSecDeleteInboundSA(
    IN  PSA_TABLE_ENTRY  pInboundSA
    )
/*++

Routine Description:

    Deletes the corresponding outbound SA, and then deletes itself.

    Called with Outbound Lock held, returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PSA_TABLE_ENTRY pOutboundSA;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    PLIST_ENTRY     pEntry;
    PFILTER         pFilter;

    ASSERT (pInboundSA->sa_State == STATE_SA_ACTIVE);

    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &kIrql);
    IPSecNotifySAExpiration(pInboundSA, NULL, kIrql, FALSE);

    if (pOutboundSA = pInboundSA->sa_AssociatedSA) {

        IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
        IPSEC_DEC_TUNNELS(pOutboundSA);
        IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

        IPSecCleanupOutboundSA(pInboundSA, pOutboundSA, FALSE);
    } 

    IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Deleting inbound SA: %p", pInboundSA));

    //
    // remove from inbound sa list
    //
    AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);
    IPSecRemoveSPIEntry(pInboundSA);
    ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

    //
    // invalidate the associated cache entry
    //
    IPSecInvalidateSACacheEntry(pInboundSA);

    //
    // also remove from the filter list
    //
    if (pInboundSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
        pInboundSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
        IPSecRemoveEntryList(&pInboundSA->sa_FilterLinkage);
    }

    if (pInboundSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
        IPSecDelHWSAAtDpc(pInboundSA);
    }

    ASSERT(pInboundSA->sa_AssociatedSA == NULL);

    IPSEC_DEBUG(LL_A, DBF_REF, ("In Deref DeleteInboundSA"));
    IPSecStopTimerDerefSA(pInboundSA);
}


VOID
IPSecExpireInboundSA(
    IN  PSA_TABLE_ENTRY  pInboundSA
    )
/*++

Routine Description:

    Deletes the corresponding outbound SA, and places itself (inbound) on timer
    Queue for later.

    NOTE: Called with SADB lock held.
Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PSA_TABLE_ENTRY pOutboundSA;
    KIRQL           OldIrq;
    KIRQL           kIrql;

    ASSERT (pInboundSA->sa_State == STATE_SA_ACTIVE);
    if (pInboundSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
        IPSecDelHWSAAtDpc(pInboundSA);
    }

    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
    IPSecNotifySAExpiration(pInboundSA, NULL, OldIrq, FALSE);

    if (pOutboundSA = pInboundSA->sa_AssociatedSA) {

        IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
        IPSEC_DEC_TUNNELS(pOutboundSA);
        IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

        IPSecCleanupOutboundSA(pInboundSA, pOutboundSA, TRUE);
    }

    IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Queueing inbound SA: %p", pInboundSA));

    //
    // Place this on the timer Q so it gets cleared when the next interval hits.
    //
    ACQUIRE_LOCK(&pInboundSA->sa_Lock, &kIrql);

    if (pInboundSA->sa_AcquireCtx) {
        IPSecInvalidateHandle(pInboundSA->sa_AcquireCtx);
        pInboundSA->sa_AcquireCtx = NULL;
    }

    IPSecStartSATimer(  pInboundSA,
                        IPSecSAExpired,
                        IPSEC_INBOUND_KEEPALIVE_TIME);

    RELEASE_LOCK(&pInboundSA->sa_Lock, kIrql);
}


NTSTATUS
IPSecCheckInboundSA(
    IN  PSA_STRUCT             pSAStruct,
    IN  PSA_TABLE_ENTRY        pSA
    )
/*++

Routine Description:

    Ensures that the SA being updated is actually the SA we initially
    kicked off negotiation for.

Arguments:

    pSAInfo - information about the SA

    pSA - SA to be populated.

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    LARGE_INTEGER   uliSrcDstAddr;
    LARGE_INTEGER   uliSrcDstMask;
    LARGE_INTEGER   uliProtoSrcDstPort;
    PSECURITY_ASSOCIATION   pSAInfo = &pSAStruct->SecAssoc[pSAStruct->NumSAs - 1];


    IPSEC_BUILD_SRC_DEST_ADDR(  uliSrcDstAddr,
                                pSAStruct->InstantiatedFilter.SrcAddr,
                                pSAStruct->InstantiatedFilter.DestAddr);

    IPSEC_BUILD_SRC_DEST_MASK(  uliSrcDstMask,
                                pSAStruct->InstantiatedFilter.SrcMask,
                                pSAStruct->InstantiatedFilter.DestMask);

    IPSEC_BUILD_PROTO_PORT_LI(  uliProtoSrcDstPort,
                                pSAStruct->InstantiatedFilter.Protocol,
                                pSAStruct->InstantiatedFilter.SrcPort,
                                pSAStruct->InstantiatedFilter.DestPort);

    IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecCheckInboundSA: S: %lx-%lx, D: %lx-%lx",
                SRC_ADDR, SRC_MASK, DEST_ADDR, DEST_MASK));
    IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecCheckInboundSA: SA->S: %lx-%lx, SA->D: %lx-%lx",
                pSA->SA_SRC_ADDR, pSA->SA_SRC_MASK, pSA->SA_DEST_ADDR, pSA->SA_DEST_MASK));

    if ((pSA->sa_TunnelAddr != 0) || (pSA->sa_Flags & FLAGS_SA_TUNNEL)) {
        if (((SRC_ADDR & pSA->SA_SRC_MASK) ==
             (pSA->SA_SRC_ADDR & pSA->SA_SRC_MASK)) &&
            ((DEST_ADDR & pSA->SA_DEST_MASK) ==
             (pSA->SA_DEST_ADDR & pSA->SA_DEST_MASK)) &&
            (pSA->sa_SPI == pSAInfo->SPI)) {
            return STATUS_SUCCESS;
        }
    } else {
        if ((uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) &&
            (pSA->sa_SPI == pSAInfo->SPI)) {
            return STATUS_SUCCESS;
        }
    }

    return  STATUS_FAIL_CHECK;
}


BOOLEAN
IPSecIsWeakDESKey(
    IN  PUCHAR  Key
    )
/*++

Routine Description:

    Checks for weak DES keys

Arguments:

    Key - the key to be checked.

Return Value:

    TRUE/FALSE

Notes:

--*/
{
    ULONG   j;

    for (j = 0; j < NUM_WEAK_KEYS; j++) {
        if (IPSecEqualMemory(Key, weak_keys[j], DES_BLOCKLEN)) {
            return  TRUE;
        }
    }

    return  FALSE;
}


BOOLEAN
IPSecIsWeak3DESKey(
    IN  PUCHAR  Key
    )
/*++

Routine Description:

    Checks for weak Triple DES keys

Arguments:

    Key - the key to be checked.

Return Value:

    TRUE/FALSE

Notes:

--*/
{
    if (IPSecEqualMemory(Key, Key + DES_BLOCKLEN, DES_BLOCKLEN) ||
        IPSecEqualMemory(Key + DES_BLOCKLEN, Key + 2 * DES_BLOCKLEN, DES_BLOCKLEN)) {
        return  TRUE;
    }

    return  FALSE;
}


NTSTATUS
IPSecPopulateSA(
    IN  PSA_STRUCT              pSAStruct,
    IN  ULONG                   KeyLen,
    IN  PSA_TABLE_ENTRY         pSA
    )
/*++

Routine Description:

    Populates an SA with info passed in the SECURITY_ASSOCIATION block

Arguments:

    pSAInfo - information about the SA

    KeyLen - the length of the composite key (we do the slicing/dicing here)

    pSA - SA to be populated.

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    PSECURITY_ASSOCIATION    pSAInfo = &pSAStruct->SecAssoc[0];
    ULONG   Index;
    ULONG   len = 0;

    IPSEC_BUILD_SRC_DEST_ADDR(  pSA->sa_uliSrcDstAddr,
                                pSAStruct->InstantiatedFilter.SrcAddr,
                                pSAStruct->InstantiatedFilter.DestAddr);

    IPSEC_BUILD_SRC_DEST_MASK(  pSA->sa_uliSrcDstMask,
                                pSAStruct->InstantiatedFilter.SrcMask,
                                pSAStruct->InstantiatedFilter.DestMask);

    IPSEC_BUILD_PROTO_PORT_LI(  pSA->sa_uliProtoSrcDstPort,
                                pSAStruct->InstantiatedFilter.Protocol,
                                pSAStruct->InstantiatedFilter.SrcPort,
                                pSAStruct->InstantiatedFilter.DestPort);

    if ((pSAStruct->NumSAs < 1) ||
        (pSAStruct->NumSAs > MAX_SAS)) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Invalid NumOps count: %d", pSAStruct->NumSAs));
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // If inbound SA, ensure that the last SPI is the one we returned.
    //
    if (!(pSA->sa_Flags & FLAGS_SA_OUTBOUND)) {
        if (pSA->sa_SPI != pSAStruct->SecAssoc[pSAStruct->NumSAs - 1].SPI) {
            IPSEC_DEBUG(LL_A, DBF_SAAPI, ("SPI in invalid location: SPI: %lx, in loc: %lx",
                pSA->sa_SPI,
                pSAStruct->SecAssoc[pSAStruct->NumSAs - 1].SPI));
            return  STATUS_INVALID_PARAMETER;
        }
    }

    if (pSAStruct->Flags & IPSEC_SA_TUNNEL) {
        IPSEC_DEBUG(LL_A, DBF_TUNNEL, ("SA %p tunneled to %lx", pSA, pSAStruct->TunnelAddr));
        pSA->sa_SrcTunnelAddr = pSAStruct->SrcTunnelAddr;
        pSA->sa_TunnelAddr = pSAStruct->TunnelAddr;
        pSA->sa_Flags |= FLAGS_SA_TUNNEL;
    }

    if (pSAStruct->Flags & IPSEC_SA_DISABLE_IDLE_OUT) {
        pSA->sa_Flags |= FLAGS_SA_DISABLE_IDLE_OUT;
    }

    if (pSAStruct->Flags & IPSEC_SA_DISABLE_ANTI_REPLAY_CHECK) {
        pSA->sa_Flags |= FLAGS_SA_DISABLE_ANTI_REPLAY_CHECK;
    }

    if (pSAStruct->Flags & IPSEC_SA_DISABLE_LIFETIME_CHECK) {
        pSA->sa_Flags |= FLAGS_SA_DISABLE_LIFETIME_CHECK;
    }
    
    pSA->sa_EncapType = pSAStruct->EncapType;
	
	
    if (pSAStruct->Flags & IPSEC_SA_ENABLE_NLBS_IDLE_CHECK) {
        pSA->sa_Flags |= FLAGS_SA_ENABLE_NLBS_IDLE_CHECK;
    }

    

    pSA->sa_NumOps = pSAStruct->NumSAs;
    pSA->sa_Lifetime = pSAStruct->Lifetime;
    pSA->sa_TruncatedLen = TRUNCATED_HASH_LEN;
    pSA->sa_ReplayLen = sizeof(ULONG);

    pSA->sa_EncapContext.wSrcEncapPort = pSAStruct->SrcEncapPort;
    pSA->sa_EncapContext.wDesEncapPort = pSAStruct->DestEncapPort;

    pSA->sa_PeerPrivateAddr=pSAStruct->PeerPrivateAddr;

    pSA->sa_QMPFSGroup = pSAStruct->dwQMPFSGroup;
    RtlCopyMemory(  &pSA->sa_CookiePair,
                    &pSAStruct->CookiePair,
                    sizeof(IKE_COOKIE_PAIR));

    for (Index = 0; Index < pSAStruct->NumSAs; Index++) {
        pSAInfo = &pSAStruct->SecAssoc[Index];
        pSA->sa_OtherSPIs[Index] = pSAInfo->SPI;
        pSA->sa_Operation[Index] = pSAInfo->Operation;
        pSA->sa_ReplaySendSeq[Index] = pSA->sa_ReplayStartPoint;
        pSA->sa_ReplayLastSeq[Index] = pSA->sa_ReplayStartPoint + 1;

        //
        // Now parse the Algorithm info..
        //
        switch (pSA->sa_Operation[Index]) {
            case None:
                IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("NULL operation."));
                if (pSA->sa_NumOps > 1) {
                    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Invalid NumOps count; none specified, but more ops than 1"));
                    return  STATUS_INVALID_PARAMETER;
                }
                break;

            case Auth: {
                pSA->INT_ALGO(Index) = pSAInfo->EXT_INT_ALGO;

                if (pSA->INT_ALGO(Index) >= IPSEC_AH_MAX) {
                    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Invalid int algo: %d %d", pSA->INT_ALGO(Index), IPSEC_AH_MAX));
                    return  STATUS_INVALID_PARAMETER;
                }

                pSA->INT_KEYLEN(Index) = pSAInfo->EXT_INT_KEYLEN;
                pSA->INT_ROUNDS(Index) = pSAInfo->EXT_INT_ROUNDS;

                //
                // Make sure the right key len was passed in
                //
                if (KeyLen > 0 && pSAInfo->EXT_INT_KEYLEN == (KeyLen - len)) {
                    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Key len more than reserved, allocing new keys"));

                    if (!(pSA->INT_KEY(Index) = IPSecAllocateKeyBuffer(KeyLen))) {
                        return  STATUS_INSUFFICIENT_RESOURCES;
                    }

                    RtlCopyMemory(  pSA->INT_KEY(Index),
                                    (UCHAR UNALIGNED *)(pSAStruct->KeyMat + len),
                                    pSAInfo->EXT_INT_KEYLEN);
                } else {
                    //
                    // bogus - reject
                    //
                    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("AH: Key len is bogus - extra bytes: %d, keylen in struct: %d.",
                                            KeyLen-len,
                                            pSAInfo->EXT_INT_KEYLEN));

                    return  STATUS_INVALID_PARAMETER;
                }

                len = pSAInfo->EXT_INT_KEYLEN;

                break;
            }

            case Encrypt: {
                pSA->INT_ALGO(Index) = pSAInfo->EXT_INT_ALGO;

                if (pSA->INT_ALGO(Index) >= IPSEC_AH_MAX) {
                    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Invalid int algo: %d %d", pSA->INT_ALGO(Index), IPSEC_AH_MAX));
                    return  STATUS_INVALID_PARAMETER;
                }

                if (pSA->INT_ALGO(Index) == IPSEC_AH_NONE) {
                    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("None Auth algo"));
                    //pSA->sa_TruncatedLen = 0;
                }

                pSA->INT_KEYLEN(Index) = pSAInfo->EXT_INT_KEYLEN;
                pSA->INT_ROUNDS(Index) = pSAInfo->EXT_INT_ROUNDS;

                pSA->CONF_ALGO(Index) = pSAInfo->EXT_CONF_ALGO;

                if (pSA->CONF_ALGO(Index) >= IPSEC_ESP_MAX) {
                    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Invalid conf algo: %d %d", pSA->CONF_ALGO(Index), IPSEC_ESP_MAX));
                    return  STATUS_INVALID_PARAMETER;
                }

                if ((pSA->CONF_ALGO(Index) == IPSEC_ESP_DES) ||
                    (pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES) ||
                    (pSA->CONF_ALGO(Index) == IPSEC_ESP_NONE)) {
                    LARGE_INTEGER   Li;

                    NdisGetCurrentSystemTime(&Li);
                    pSA->sa_ivlen = DES_BLOCKLEN;

                    *(UNALIGNED ULONG *)&pSA->sa_iv[Index][0] = Li.LowPart;
                    *(UNALIGNED ULONG *)&pSA->sa_iv[Index][4] = Li.HighPart;
                    IPSecGenerateRandom((PUCHAR)&pSA->sa_iv[Index][0], DES_BLOCKLEN);

                    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IV: %lx-%lx", *(PULONG)&pSA->sa_iv[Index][0], *(PULONG)&pSA->sa_iv[Index][4]));

                    pSA->CONF_KEYLEN(Index) = pSAInfo->EXT_CONF_KEYLEN;
                    pSA->CONF_ROUNDS(Index) = pSAInfo->EXT_CONF_ROUNDS;

                    //
                    // Make sure the right key len was passed in
                    //
                    if ((KeyLen-len == pSAStruct->KeyLen) &&
                        (pSAInfo->EXT_INT_KEYLEN + pSAInfo->EXT_CONF_KEYLEN <= KeyLen-len)) {

                        //
                        // confKeyMatLen is the amount of conf key material that came down.
                        // this is the reduced (weakened) length for export.
                        // it is expanded to the real length later.
                        //
                        ULONG   confKeyMatLen = pSAInfo->EXT_CONF_KEYLEN;
                        ULONG   realConfKeyLen = 0;

                        realConfKeyLen = confKeyMatLen;

                        if (pSA->CONF_ALGO(Index) == IPSEC_ESP_DES) {
                            if (pSAInfo->EXT_CONF_KEYLEN != DES_BLOCKLEN) {
                                ASSERT(FALSE);
                                IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Bad DES key length: pSAInfo->EXT_CONF_KEYLEN: %lx, conf: %lx, DES_BLOCKLEN: %lx",
                                                            pSAInfo->EXT_CONF_KEYLEN, confKeyMatLen, DES_BLOCKLEN));

                                return  STATUS_INVALID_PARAMETER;
                            }
                        } else if (pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES) {
                            if (pSAInfo->EXT_CONF_KEYLEN != 3 * DES_BLOCKLEN) {
                                ASSERT(FALSE);
                                IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Bad 3DES key length"));
                                return  STATUS_INVALID_PARAMETER;
                            }
                        }

                        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Key len more than reserved, allocing new keys"));
                        if (pSAInfo->EXT_INT_KEYLEN > 0 &&
                            !(pSA->INT_KEY(Index) = IPSecAllocateKeyBuffer(pSAInfo->EXT_INT_KEYLEN))) {
                            return  STATUS_INSUFFICIENT_RESOURCES;
                        }

                        if (realConfKeyLen > 0 &&
                            !(pSA->CONF_KEY(Index) = IPSecAllocateKeyBuffer(realConfKeyLen))) {
                            if (pSA->INT_KEY(Index)) {
                                IPSecFreeKeyBuffer(pSA->INT_KEY(Index));
                                pSA->INT_KEY(Index) = NULL;
                            }
                            return  STATUS_INSUFFICIENT_RESOURCES;
                        }

                        if (pSA->CONF_KEY(Index) && confKeyMatLen) {
                            RtlCopyMemory(  pSA->CONF_KEY(Index),
                                            pSAStruct->KeyMat,
                                            confKeyMatLen);

                            if (confKeyMatLen < realConfKeyLen) {
                                if (pSA->INT_KEY(Index)) {
                                    IPSecFreeKeyBuffer(pSA->INT_KEY(Index));
                                    pSA->INT_KEY(Index) = NULL;
                                }
                                if (pSA->CONF_KEY(Index)) {
                                    IPSecFreeKeyBuffer(pSA->CONF_KEY(Index));
                                    pSA->CONF_KEY(Index) = NULL;
                                }
                                return  STATUS_INVALID_PARAMETER;
                            }

                            if ((pSA->CONF_ALGO(Index) == IPSEC_ESP_DES &&
                                 IPSecIsWeakDESKey(pSA->CONF_KEY(Index))) ||
                                (pSA->CONF_ALGO(Index) == IPSEC_ESP_3_DES &&
                                 IPSecIsWeak3DESKey(pSA->CONF_KEY(Index)))) {
                                PSA_TABLE_ENTRY pLarvalSA;

                                IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Got a weak key!!: %p", pSA->CONF_KEY(Index)));
                                //
                                // if initiator, re-start a new negotiation and throw away this one
                                //
                                if (pSA->sa_Flags & FLAGS_SA_INITIATOR) {
                                    IPSecNegotiateSA(   pSA->sa_Filter,
                                                        pSA->sa_uliSrcDstAddr,
                                                        pSA->sa_uliProtoSrcDstPort,
                                                        pSA->sa_NewMTU,
                                                        &pLarvalSA,
                                                        pSA->sa_DestType,
                                                        &pSA->sa_EncapContext);
                                    IPSecQueuePacket(pLarvalSA, pSA->sa_BlockedBuffer);
                                }

                                return  STATUS_INVALID_PARAMETER;
                            }
                        } else {
                            if (pSA->CONF_ALGO(Index) != IPSEC_ESP_NONE) {
                                //IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Algo: %lx with no keymat!!: %lx", pSA->CONF_ALGO(Index)));
                                ASSERT(FALSE);
                                return  STATUS_INVALID_PARAMETER;
                            }
                            pSA->sa_ivlen = 0;
                        }

                        if (pSAInfo->EXT_INT_KEYLEN > 0) {
                            RtlCopyMemory(  pSA->INT_KEY(Index),
                                            (UCHAR UNALIGNED *)(pSAStruct->KeyMat + pSAInfo->EXT_CONF_KEYLEN),
                                            pSAInfo->EXT_INT_KEYLEN);
                        }

                        len = pSAInfo->EXT_CONF_KEYLEN + pSAInfo->EXT_INT_KEYLEN;
                    } else {
                        //
                        // bogus - reject
                        //
                        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("ESP: Key len is bogus - extra bytes: %lx, keylen in struct: %lx.",
                                                KeyLen-len,
                                                pSAInfo->EXT_INT_KEYLEN + pSAInfo->EXT_CONF_KEYLEN));

                        return  STATUS_INVALID_PARAMETER;
                    }
                }

                break;
            }

            default:
                IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecPopulateSA: Bad operation"));
                break;
        }
    }
    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecCreateSA(
    OUT PSA_TABLE_ENTRY         *ppSA
    )
/*++

Routine Description:

    Creates a Security Association block.

Arguments:

    ppSA - returns the SA pointer

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    PSA_TABLE_ENTRY  pSA;

    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("Entering IPSecCreateSA"));

    pSA = IPSecAllocateMemory(sizeof(SA_TABLE_ENTRY), IPSEC_TAG_SA);

    if (!pSA) {
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    IPSecZeroMemory(pSA, sizeof(SA_TABLE_ENTRY));
    pSA->sa_Signature = IPSEC_SA_SIGNATURE;
    pSA->sa_NewMTU = MAX_LONG;

#if DBG
    pSA->sa_d1 = IPSEC_SA_D_1;
    pSA->sa_d2 = IPSEC_SA_D_2;
    pSA->sa_d3 = IPSEC_SA_D_3;
    pSA->sa_d4 = IPSEC_SA_D_4;
#endif

    INIT_LOCK(&pSA->sa_Lock);

    InitializeListHead(&pSA->sa_SPILinkage);
    InitializeListHead(&pSA->sa_FilterLinkage);
    InitializeListHead(&pSA->sa_LarvalLinkage);
    InitializeListHead(&pSA->sa_PendingLinkage);

    pSA->sa_Reference = 1;
    pSA->sa_State = STATE_SA_CREATED;
    pSA->sa_ExpiryTime = IPSEC_SA_EXPIRY_TIME;

    *ppSA = pSA;
    return  STATUS_SUCCESS;
}


PSA_TABLE_ENTRY
IPSecLookupSABySPI(
    IN  tSPI    SPI,
    IN  IPAddr  DestAddr
    )
/*++

Routine Description:

    Looks up the SA given the SPI and Filter variables.

Arguments:


Return Value:


Notes:

--*/
{
    KIRQL           kIrql;
    PSA_TABLE_ENTRY pSA;

    AcquireReadLock(&g_ipsec.SPIListLock, &kIrql);
    pSA = IPSecLookupSABySPIWithLock(SPI, DestAddr);
    ReleaseReadLock(&g_ipsec.SPIListLock, kIrql);
    return pSA;
}


PSA_TABLE_ENTRY
IPSecLookupSABySPIWithLock(
    IN  tSPI    SPI,
    IN  IPAddr  DestAddr
    )
/*++

Routine Description:

    Looks up the SA given the SPI and Filter variables.

    NOTE: Always call with the SPIListLock held.

Arguments:


Return Value:


Notes:

--*/
{
    PSA_HASH        pHash;
    PLIST_ENTRY     pEntry;
    PSA_TABLE_ENTRY pSA;

    //
    // get to hash bucket
    //
    IPSEC_HASH_SPI(DestAddr, SPI, pHash);

    //
    // search for specific entry in collision chain
    //
    for (   pEntry = pHash->SAList.Flink;
            pEntry != &pHash->SAList;
            pEntry = pEntry->Flink) {

        pSA = CONTAINING_RECORD(pEntry,
                                SA_TABLE_ENTRY,
                                sa_SPILinkage);

        if (pSA->sa_TunnelAddr) {
            if ((DestAddr == pSA->sa_TunnelAddr) &&
                (pSA->sa_SPI == SPI)) {
                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched Tunnel entry: %p", pSA));

                return  pSA;
            }
        } else {
            if ((DestAddr == pSA->SA_DEST_ADDR) &&
                (pSA->sa_SPI == SPI)) {

                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pSA));
                return  pSA;
            }
        }
    }

    //
    // no entry found
    //
    return NULL;
}


NTSTATUS
IPSecLookupSAByAddr(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    OUT PSA_TABLE_ENTRY *ppNextSA,
    OUT PSA_TABLE_ENTRY *ppTunnelSA,
    IN  BOOLEAN         fOutbound,
    IN  BOOLEAN         fFWPacket,
    IN  BOOLEAN         fBypass,
    IN  BOOLEAN          fVerify,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    )
/*++

Routine Description:

    Looks up the SA given the relevant addresses.

Arguments:

    uliSrcDstAddr - src/dest IP addr
    uliProtoSrcDstPort - protocol, src/dest port
    ppFilter - filter found
    ppSA - SA found
    ppTunnelSA - tunnel SA found
    fOutbound - direction flag

Return Value:

    STATUS_SUCCESS - both filter and SA found
    STATUS_UNSUCCESSFUL - none found
    STATUS_PENDING - filter found, but no SA

Notes:

    Called with SADBLock held.

--*/
{
    PFILTER                 pFilter;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PSA_TABLE_ENTRY         pSA;
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    BOOLEAN                 fFound = FALSE;

    *ppSA = NULL;
    *ppFilter = NULL;
    *ppTunnelSA = NULL;

    //
    // Search in Tunnel filters list
    //
    pFilterList = IPSecResolveFilterList(TRUE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        if (fBypass && IS_EXEMPT_FILTER(pFilter)) {
            //
            // Don't search block/pass-thru filters for host bypass traffic
            //
            continue;
        }

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {
            IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pFilter));

            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        fFound = FALSE;
        //
        // Search for the particular SA now.
        //
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            ASSERT(pSA->sa_Flags & FLAGS_SA_TUNNEL);

            if (pFilter->TunnelAddr != 0 && EQUAL_NATENCAP(pNatContext,pSA)) {
                //
                // match the outbound flag also
                //
                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched specific tunnel entry: %p", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                fFound = TRUE;
                *ppTunnelSA = pSA;
                break;
            }
        }

        if (fFound) {
            fFound = FALSE;
            *ppFilter = pFilter;
        } else {
            //
            // Found a filter entry, but need to negotiate keys
            //
            *ppFilter = pFilter;
            return  STATUS_PENDING;
        }
    }

    //
    // Search in Masked filters list
    //
    pFilterList = IPSecResolveFilterList(FALSE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        if (fFWPacket && !IS_EXEMPT_FILTER(pFilter)) {
            //
            // Search only block/pass-thru filters in forward path
            //
            continue;
        }

        if (fBypass && IS_EXEMPT_FILTER(pFilter)) {
            //
            // Don't search block/pass-thru filters for host bypass traffic
            //
            continue;
        }

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {
            IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pFilter));

            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        //
        // Search for the particular SA now.
        //
        fFound=FALSE;
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);
            
            if (IS_CLASSD(NET_LONG(pSA->SA_SRC_ADDR))
                || IS_CLASSD(NET_LONG(pSA->SA_DEST_ADDR))) {
                uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pSA->sa_uliSrcDstMask.QuadPart;
                
                IPSEC_DEBUG(LL_A, DBF_HASH, ("MCAST: %d %d %d %d", uliAddr.LowPart, uliAddr.HighPart,
                            pSA->sa_uliSrcDstAddr.LowPart,pSA->sa_uliSrcDstAddr.HighPart));

                if (uliAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart) {
                    fFound=TRUE;
                }
            } else if (uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart &&
	               EQUAL_NATENCAP(pNatContext,pSA)) {
                fFound=TRUE;
            }
            if (fFound) {
                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));

                //
                // if there is also a tunnel SA, associate it here.
                //
                if (*ppTunnelSA && (fOutbound || fVerify)) {
                    *ppNextSA = *ppTunnelSA;
                    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("linked next sa: %p, next: %p", pSA, *ppTunnelSA));
                    *ppTunnelSA = NULL;
                }

                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        //
        // Also, ppTunnelSA is set to the proper tunnel SA we need
        // to hook to this end-2-end SA once it is negotiated.
        //
        *ppFilter = pFilter;

        return  STATUS_PENDING;
    } else {
        //
        // if only tunnel SA found, return that as the SA
        // found.
        //
        if (*ppTunnelSA) {
            *ppSA = *ppTunnelSA;
            *ppTunnelSA = NULL;
            return  STATUS_SUCCESS;
        }
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;
}


NTSTATUS
IPSecLookupTunnelSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    )
/*++

Routine Description:

    Looks up the SA given the relevant addresses.

Arguments:

    uliSrcDstAddr - src/dest IP addr
    uliProtoSrcDstPort - protocol, src/dest port
    ppFilter - filter found
    ppSA - SA found
    fOutbound - direction flag

Return Value:

    STATUS_SUCCESS - both filter and SA found
    STATUS_UNSUCCESSFUL - none found
    STATUS_PENDING - filter found, but no SA

Notes:

    Called with SADBLock held.

--*/
{
    PFILTER                 pFilter;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PSA_TABLE_ENTRY         pSA;
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    BOOLEAN                 fFound = FALSE;

    *ppSA = NULL;
    *ppFilter = NULL;

    //
    // Search in Tunnel filters list
    //
    pFilterList = IPSecResolveFilterList(TRUE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {

            IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pFilter));
            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        //
        // Search for the particular SA now.
        //
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            ASSERT(pSA->sa_Flags & FLAGS_SA_TUNNEL);

            if (pFilter->TunnelAddr != 0 && EQUAL_NATENCAP(pNatContext,pSA)) {
                //
                // match the outbound flag also
                //
                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched specific tunnel entry: %p", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        //
        *ppFilter = pFilter;
        return  STATUS_PENDING;
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;
}


NTSTATUS
IPSecLookupMaskedSA(
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    OUT PFILTER         *ppFilter,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  BOOLEAN         fOutbound,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pNatContext
    )
/*++

Routine Description:

    Looks up the SA given the relevant addresses.

Arguments:

    uliSrcDstAddr - src/dest IP addr
    uliProtoSrcDstPort - protocol, src/dest port
    ppFilter - filter found
    ppSA - SA found
    fOutbound - direction flag

Return Value:

    STATUS_SUCCESS - both filter and SA found
    STATUS_UNSUCCESSFUL - none found
    STATUS_PENDING - filter found, but no SA

Notes:

    Called with SADBLock held.

--*/
{
    PFILTER                 pFilter;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pFilterList;
    PLIST_ENTRY             pSAChain;
    PSA_TABLE_ENTRY         pSA;
    REGISTER ULARGE_INTEGER uliPort;
    REGISTER ULARGE_INTEGER uliAddr;
    BOOLEAN                 fFound = FALSE;

    *ppSA = NULL;
    *ppFilter = NULL;

    //
    // Search in Masked filters list
    //
    pFilterList = IPSecResolveFilterList(FALSE, fOutbound);

    for (   pEntry = pFilterList->Flink;
            pEntry != pFilterList;
            pEntry = pEntry->Flink) {

        pFilter = CONTAINING_RECORD(pEntry,
                                    FILTER,
                                    MaskedLinkage);

        uliAddr.QuadPart = uliSrcDstAddr.QuadPart & pFilter->uliSrcDstMask.QuadPart;
        uliPort.QuadPart = uliProtoSrcDstPort.QuadPart & pFilter->uliProtoSrcDstMask.QuadPart;

        if ((uliAddr.QuadPart == pFilter->uliSrcDstAddr.QuadPart) &&
            (uliPort.QuadPart == pFilter->uliProtoSrcDstPort.QuadPart)) {

            IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pFilter));
            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        //
        // Search for the particular SA now.
        //
        pSAChain = IPSecResolveSAChain(pFilter, fOutbound? DEST_ADDR: SRC_ADDR);

        for (   pEntry = pSAChain->Flink;
                pEntry != pSAChain;
                pEntry = pEntry->Flink) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            if (uliSrcDstAddr.QuadPart == pSA->sa_uliSrcDstAddr.QuadPart && EQUAL_NATENCAP(pNatContext,pSA)) {

                IPSEC_DEBUG(LL_A, DBF_HASH, ("Matched entry: %p", pSA));
                ASSERT(fOutbound == (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_OUTBOUND) != 0));
                *ppFilter = pFilter;
                *ppSA = pSA;
                return  STATUS_SUCCESS;
            }
        }

        //
        // Found a filter entry, but need to negotiate keys
        //
        *ppFilter = pFilter;
        return  STATUS_PENDING;
    }

    //
    // no entry found
    //
    return  STATUS_NOT_FOUND;
}


NTSTATUS
IPSecAllocateSPI(
    OUT tSPI            * pSpi,
    IN  PSA_TABLE_ENTRY   pSA
    )
/*++

Routine Description:

    Allocates an SPI for an incoming SA - guards against collisions

Arguments:

    pSpi - the SPI allocated is filled in here

    pSA - SA for which SPI is needed

Return Value:


Notes:

--*/
{
    ULONG   rand;
    ULONG   numRetries = 0;
    IPAddr  DestAddr;

    if (pSA->sa_TunnelAddr) {
        DestAddr = pSA->sa_TunnelAddr;
    } else {
        DestAddr = pSA->SA_DEST_ADDR;
    }

    //
    // if SPI passed in, use that spi else allocate one.
    //
    if (*pSpi) {
        if (IPSecLookupSABySPIWithLock(
                                *pSpi,
                                DestAddr)) {
            return STATUS_UNSUCCESSFUL;
        } else {
            return STATUS_SUCCESS;
        }
    } else {
        rand = (ULONG)(ULONG_PTR)pSA;
        IPSecGenerateRandom((PUCHAR)&rand, sizeof(ULONG));
        rand = LOWER_BOUND_SPI + rand % (UPPER_BOUND_SPI - LOWER_BOUND_SPI);

        while (numRetries++ < MAX_SPI_RETRIES) {

            if (!IPSecLookupSABySPIWithLock(
                                    (tSPI)rand,
                                    DestAddr)) {
                *pSpi = (tSPI)rand;
                return STATUS_SUCCESS;
            }

            rand++;

            //
            // Collision, retry
            //
            IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecAllocateSPI: collision for: %lx", rand));
        }
    }

    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
IPSecNegotiateSA(
    IN  PFILTER         pFilter,
    IN  ULARGE_INTEGER  uliSrcDstAddr,
    IN  ULARGE_INTEGER  uliProtoSrcDstPort,
    IN  ULONG           NewMTU,
    OUT PSA_TABLE_ENTRY *ppSA,
    IN  UCHAR           DestType,
    IN  PIPSEC_UDP_ENCAP_CONTEXT pEncapContext
    )
/*++

Routine Description:

    Allocates a Larval Inbound SA block then kicks off key manager to negotiate
    the algorithms/keys.

    Called with SADB lock held, returns with it.

Arguments:

    pFilter - the filter and policy that matched this packet.

    ppSA - returns the SA created here.

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    KIRQL	        kIrql;
    KIRQL	        OldIrq;
    NTSTATUS        status;
    PSA_TABLE_ENTRY pSA;

    //
    // Make sure we dont already have this SA under negotiation
    // walk the LarvalSA list to see if we can find another SA.
    //
    pSA = IPSecLookupSAInLarval(uliSrcDstAddr, uliProtoSrcDstPort);
    if (pSA != NULL) {
        IPSEC_DEBUG(LL_A, DBF_PATTERN, ("Found in Larval: %p", pSA));
        *ppSA = pSA;
        return  STATUS_DUPLICATE_OBJECTID;
    }

    IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecNegotiateSA: SA: %lx, DA: %lx, P: %lx, SP: %lx, DP: %lx", SRC_ADDR, DEST_ADDR, PROTO, SRC_PORT, DEST_PORT));

    //
    // Initiator
    //
    status = IPSecInitiatorCreateLarvalSA(
                 pFilter, 
                 uliSrcDstAddr,
                 ppSA,
                 DestType,
                 pEncapContext
                 );

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecNegotiateSA: IPSecCreateSA failed: %lx", status));
        return status;
    }

    //
    // Save the NewMTU value if this SA has been PMTU'd.
    //
    (*ppSA)->sa_NewMTU = NewMTU;

    //
    // If this is a tunnel filter to be negotiated, save off the tunnel addr in the
    // SA.
    //
    if (pFilter->TunnelFilter) {
        IPSEC_DEBUG(LL_A, DBF_TUNNEL, ("Negotiating tunnel SA: %p", (*ppSA)));
        // (*ppSA)->sa_TunnelAddr = pFilter->TunnelAddr;
    }

    //
    // Now send this up to the Key Manager to negotiate the keys
    //
    ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
    status = IPSecSubmitAcquire(*ppSA, OldIrq, FALSE);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecNegotiateSA: IPSecSubmitAcquire failed: %lx", status));

        ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);
        IPSecRemoveEntryList(&(*ppSA)->sa_LarvalLinkage);
        IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

        AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);
        IPSecRemoveSPIEntry(*ppSA);
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

        //
        // also remove from the filter list
        //
        if ((*ppSA)->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
            (*ppSA)->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
            IPSecRemoveEntryList(&(*ppSA)->sa_FilterLinkage);
            (*ppSA)->sa_Filter = NULL;
        }

        if ((*ppSA)->sa_RekeyOriginalSA) {
            ASSERT((*ppSA)->sa_Flags & FLAGS_SA_REKEY);
            ASSERT((*ppSA)->sa_RekeyOriginalSA->sa_RekeyLarvalSA == (*ppSA));
            ASSERT((*ppSA)->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

            (*ppSA)->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
            (*ppSA)->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
            (*ppSA)->sa_RekeyOriginalSA = NULL;
        }

        (*ppSA)->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
        IPSecStopTimer(&(*ppSA)->sa_Timer);
        IPSecDerefSA(*ppSA);
        return status;
    }

    return status;
}


VOID
IPSecFlushQueuedPackets(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  NTSTATUS                status
    )
/*++

Routine Description:

    Flushes queued packets now that the keys are known

Arguments:


Return Value:


Notes:

--*/
{
    PIPSEC_SEND_COMPLETE_CONTEXT pContext;
    IPOptInfo       optInfo;
    ULONG           len;
    PNDIS_BUFFER    pHdrMdl;
    ULONG           dataLen;
    IPHeader UNALIGNED * pIPH;
    KIRQL	        kIrql;

    //
    // We need to acquire a lock here because this routine can be called in
    // parallel with one in SA delete and the other in SA update (normal).
    //
    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);
    pHdrMdl = pSA->sa_BlockedBuffer;
    dataLen = pSA->sa_BlockedDataLen;

    pSA->sa_BlockedBuffer = NULL;
    pSA->sa_BlockedDataLen = 0;
    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    if (!pHdrMdl) {
        IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("FlushQueuedPackets: pHdrMdl == NULL"));
        return;
    }

    if (status == STATUS_SUCCESS) {
        ASSERT(pSA->sa_State == STATE_SA_ACTIVE);
        ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);
        ASSERT(pHdrMdl);

        pContext = IPSecAllocateSendCompleteCtx(IPSEC_TAG_ESP);

        if (!pContext) {
            PNDIS_BUFFER    pNextMdl;
            PNDIS_BUFFER    pMdl = pHdrMdl;
            NTSTATUS        freeBufferStatus;

            IPSEC_DEBUG(LL_A, DBF_ESP, ("Failed to alloc. SendCtx"));

            ASSERT(pMdl);

            while (pMdl) {
                pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
                IPSecFreeBuffer(&freeBufferStatus, pMdl);
                pMdl = pNextMdl;
            }

            return;
        }

        IPSEC_INCREMENT(g_ipsec.NumSends);

        IPSecZeroMemory(pContext, sizeof(IPSEC_SEND_COMPLETE_CONTEXT));

#if DBG
        RtlCopyMemory(pContext->Signature, "ISC6", 4);
#endif

        pContext->FlushMdl = pHdrMdl;
        pContext->Flags |= SCF_FLUSH;

        IPSecQueryNdisBuf(pHdrMdl, (PVOID)&pIPH, &len);

        //
        // Call IPTransmit with proper Protocol type so it takes this packet
        // at *face* value.
        //
        optInfo = g_ipsec.OptInfo;
        optInfo.ioi_flags |= IP_FLAG_IPSEC;
        status = TCPIP_IP_TRANSMIT( &g_ipsec.IPProtInfo,
                                    pContext,
                                    pHdrMdl,
                                    dataLen,
                                    pIPH->iph_dest,
                                    pIPH->iph_src,
                                    &optInfo,
                                    NULL,
                                    pIPH->iph_protocol,
                                    NULL);

        //
        // Even in the synchronous case, we free the MDL chain in ProtocolSendComplete
        // (called by IPSecSendComplete). So, we dont call anything here.
        // See IPSecReinjectPacket.
        //
    } else {
        PNDIS_BUFFER    pNextMdl;
        PNDIS_BUFFER    pMdl = pHdrMdl;
        NTSTATUS        freeBufferStatus;

        ASSERT(pMdl);

        while (pMdl) {
            pNextMdl = NDIS_BUFFER_LINKAGE(pMdl);
            IPSecFreeBuffer(&freeBufferStatus, pMdl);
            pMdl = pNextMdl;
        }
    }

    return;
}


NTSTATUS
IPSecInsertOutboundSA(
    IN  PSA_TABLE_ENTRY         pSA,
    IN  PIPSEC_ACQUIRE_CONTEXT  pAcquireCtx,
    IN  BOOLEAN                 fTunnelFilter
    )
/*++

Routine Description:

    Adds an SA into the database, typically called to add outbound SAs as a
    result of successful negotiation of keys corresponding to the inbound SA
    specified in the context that comes down.

    NOTE: Called with SADB lock held.

Arguments:

    pSA - SA to be inserted

    pAcquireContext - The Acquire context

Return Value:


Notes:

--*/
{
    PSA_TABLE_ENTRY pInboundSA = pAcquireCtx->pSA;
    PSA_TABLE_ENTRY pAssociatedSA;
    KIRQL	        kIrql;
    KIRQL	        kIrql1;
    NTSTATUS        status;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pOutboundSA = NULL;
    PSA_TABLE_ENTRY pTunnelSA = NULL;
    PLIST_ENTRY     pSAChain;
    PIPSEC_UDP_ENCAP_CONTEXT pNatContext=NULL;
    
    ASSERT(pSA->sa_Flags & FLAGS_SA_OUTBOUND);
    ASSERT((pInboundSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);
    ASSERT(pInboundSA->sa_State == STATE_SA_LARVAL_ACTIVE);

	if (pSA->sa_EncapType != SA_UDP_ENCAP_TYPE_NONE) {
		pNatContext=&pSA->sa_EncapContext;
	}
    //
    // Potential dangling pointer, always go through the lookup path.
    //
    if (fTunnelFilter) {
        status = IPSecLookupTunnelSA(   pSA->sa_uliSrcDstAddr,
                                        pSA->sa_uliProtoSrcDstPort,
                                        &pFilter,
                                        &pOutboundSA,
                                        TRUE,
                                        pNatContext);
    } else {
#if GPC
        if (IS_GPC_ACTIVE()) {
            status = IPSecLookupGpcMaskedSA(pSA->sa_uliSrcDstAddr,
                                            pSA->sa_uliProtoSrcDstPort,
                                            &pFilter,
                                            &pOutboundSA,
                                            TRUE,
                                            pNatContext);
        } else {
            status = IPSecLookupMaskedSA(   pSA->sa_uliSrcDstAddr,
                                            pSA->sa_uliProtoSrcDstPort,
                                            &pFilter,
                                            &pOutboundSA,
                                            TRUE,
                                            pNatContext);
         }
#else
        status = IPSecLookupMaskedSA(   pSA->sa_uliSrcDstAddr,
                                        pSA->sa_uliProtoSrcDstPort,
                                        &pFilter,
                                        &pOutboundSA,
                                        TRUE,
                                        pNatContext);
#endif
    }

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecInsertOutboundSA: IPSecLookupSAByAddr failed: %lx", status));
        return status;
    }

    pSAChain = IPSecResolveSAChain(pFilter, pSA->SA_DEST_ADDR);

    if (status == STATUS_SUCCESS) {
        //
        // re-negotiate case: delete the outbound; expire the inbound; add the new one.
        //
        IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecInsertOutboundSA: found another: %p", pOutboundSA));
        ASSERT(pOutboundSA);
        ASSERT(pOutboundSA->sa_Flags & FLAGS_SA_OUTBOUND);

        pSA->sa_Filter = pFilter;
        pSA->sa_Flags |= FLAGS_SA_ON_FILTER_LIST;
        InsertHeadList(pSAChain, &pSA->sa_FilterLinkage);

        IPSEC_INC_STATISTIC(dwNumReKeys);

        pAssociatedSA = pOutboundSA->sa_AssociatedSA;
        if (pAssociatedSA &&
            ((pOutboundSA->sa_Flags & FLAGS_SA_REKEY_ORI) ||
             !(pInboundSA->sa_Filter))) {
            IPSecExpireInboundSA(pAssociatedSA);
        }
    } else {
        //
        // pending => this will be the add.
        //
        ASSERT(pOutboundSA == NULL);
        pSA->sa_Filter = pFilter;
        pSA->sa_Flags |= FLAGS_SA_ON_FILTER_LIST;
        InsertHeadList(pSAChain, &pSA->sa_FilterLinkage);
    }

    if (pFilter->TunnelAddr != 0) {
        pSA->sa_Flags |= FLAGS_SA_TUNNEL;
        pSA->sa_TunnelAddr = pFilter->TunnelAddr;
    }

    //
    // Initiator if the original SA had a filter pointer.
    //
    if (pInboundSA->sa_Filter) {
        pSA->sa_Flags |= FLAGS_SA_INITIATOR;
    }

    //
    // Flush this filter from cache table so we match the SA next.
    //
    if (IS_EXEMPT_FILTER(pFilter)) {
        IPSecInvalidateFilterCacheEntry(pFilter);
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecAddSA(
    IN  PIPSEC_ADD_SA   pAddSA,
    IN  ULONG           TotalSize
    )
/*++

Routine Description:

    Adds an SA into the database, typically called to add outbound SAs as a
    result of successful negotiation of keys corresponding to the inbound SA
    specified in the context that comes down.

Arguments:

    pAddSA - Add SA context and info.

    TotalSize - the total size of the input buffer.

Return Value:


Notes:


--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PSA_STRUCT      saInfo = &pAddSA->SAInfo;
    PSA_TABLE_ENTRY pSA = NULL;
    ULONG           keyLen = 0;
    PSA_TABLE_ENTRY pInboundSA = NULL;
    KIRQL	        kIrql;
    KIRQL	        kIrql1;
    PIPSEC_ACQUIRE_CONTEXT  pAcquireContext = NULL;

    //
    // Lock the larval list so this SA does not go away.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql1);
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    //
    // Sanity check the incoming context to see if it is actually
    // an SA block
    //
    if (!NT_SUCCESS(IPSecValidateHandle(HandleToUlong(saInfo->Context),
										&pAcquireContext,
									    STATE_SA_LARVAL_ACTIVE))) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecAddSA: invalid context: %p", pAcquireContext));
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return  STATUS_INVALID_PARAMETER;
    }

    //
    // figure out the key length and pass that in
    //
    keyLen = TotalSize - IPSEC_ADD_SA_NO_KEY_SIZE;
    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecAddSA: keyLen: %d", keyLen));

    //
    // create SA block
    //
    status = IPSecCreateSA(&pSA);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecAddSA: IPSecCreateSA failed: %lx", status));
        IPSecAbortAcquire(pAcquireContext);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return status;
    }

    pSA->sa_Flags |= FLAGS_SA_OUTBOUND;

    //
    // Populate with the info in AddSA
    //
    status = IPSecPopulateSA(saInfo, keyLen, pSA);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecAddSA: IPSecPopulateSA failed: %lx", status));
        // IPSecPopulateSA will not free the outbound SA so we have to do it.
        IPSecFreeSA(pSA);
        IPSecAbortAcquire(pAcquireContext);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return status;
    }

    //
    // Stash the outermost spi
    //
    pSA->sa_SPI = pSA->sa_OtherSPIs[pSA->sa_NumOps-1];

    //
    // insert into proper tables
    //
    status = IPSecInsertOutboundSA(pSA, pAcquireContext, (BOOLEAN)((pSA->sa_Flags & FLAGS_SA_TUNNEL) != 0)); 

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecAddSA: IPSecInsertOutboundSA failed: %lx", status));
        IPSecFreeSA(pSA);
        IPSecAbortAcquire(pAcquireContext);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return status;
    }

    pInboundSA = pAcquireContext->pSA;

    IPSecRefSA(pInboundSA);

    ASSERT (pInboundSA->sa_State == STATE_SA_LARVAL_ACTIVE);

    //
    // Associate the inbound and outbound SAs
    //
    pSA->sa_AssociatedSA = pInboundSA;
    pInboundSA->sa_AssociatedSA = pSA;

    //
    // Initialize IPSec overhead for the outbound SA.
    //
    IPSecCalcHeaderOverheadFromSA(pSA, &pSA->sa_IPSecOverhead);

    // Copy the NewMTU value over to the new SA.
    //
    pSA->sa_NewMTU = pInboundSA->sa_NewMTU;

    //
    // Adjust SA lifetime to the maximum/minimum allowed in driver
    //
    if (pSA->sa_Lifetime.KeyExpirationTime > IPSEC_MAX_EXPIRE_TIME) {
        pSA->sa_Lifetime.KeyExpirationTime = IPSEC_MAX_EXPIRE_TIME;
    }

    if (pSA->sa_Lifetime.KeyExpirationTime &&
        pSA->sa_Lifetime.KeyExpirationTime < IPSEC_MIN_EXPIRE_TIME) {
        pSA->sa_Lifetime.KeyExpirationTime = IPSEC_MIN_EXPIRE_TIME;
    }

    //
    // Setup lifetime characteristics
    //
    IPSecSetupSALifetime(pSA);

    //
    // Init the LastUsedTime
    //
    NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);

    //
    // outbound is ready to go!
    //
    pSA->sa_State = STATE_SA_ACTIVE;
    pInboundSA->sa_State = STATE_SA_ACTIVE;

    IPSEC_DEBUG(LL_A, DBF_SA, ("IPSecAddSA: SA: %p, S:%lx, D:%lx, O: %c",
                pSA,
                pSA->SA_SRC_ADDR,
                pSA->SA_DEST_ADDR,
                (pSA->sa_Operation[0] == Auth) ?
                    'A' : (pSA->sa_Operation[0] == Encrypt) ?
                        'E' : 'N'));

    IPSEC_INC_STATISTIC(dwNumActiveAssociations);
    IPSEC_INC_TUNNELS(pSA);
    IPSEC_INCREMENT(g_ipsec.NumOutboundSAs);
    IPSEC_INC_STATISTIC(dwNumKeyAdditions);


    //
    // See if we have well-associated SAs
    //
    ASSERT(pInboundSA == pInboundSA->sa_AssociatedSA->sa_AssociatedSA);

    ASSERT((pInboundSA->sa_Flags & FLAGS_SA_TUNNEL) == (pSA->sa_Flags & FLAGS_SA_TUNNEL));
    ASSERT(pInboundSA->sa_SrcTunnelAddr == pSA->sa_TunnelAddr);
    ASSERT(pSA->sa_SrcTunnelAddr == pInboundSA->sa_TunnelAddr);

    //
    // Expire the original SA that kicked off this rekey
    //
    if (pInboundSA->sa_Flags & FLAGS_SA_REKEY) {
        PSA_TABLE_ENTRY pOriSA;

        if (pOriSA = pInboundSA->sa_RekeyOriginalSA) {

            pInboundSA->sa_RekeyOriginalSA = NULL;
            IPSEC_DEBUG(LL_A, DBF_SA, ("Deleting original SA: pSA: %p", pOriSA));

            if (pOriSA->sa_AssociatedSA) {
                IPSecExpireInboundSA(pOriSA->sa_AssociatedSA);
            }
            IPSEC_INC_STATISTIC(dwNumReKeys);
        }
    }

    //
    // Remove from larval list
    //
    IPSecRemoveEntryList(&pInboundSA->sa_LarvalLinkage);
    IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);
    
    ACQUIRE_LOCK(&pInboundSA->sa_Lock, &kIrql);

    if (pInboundSA->sa_AcquireCtx) {
        IPSecInvalidateHandle(pInboundSA->sa_AcquireCtx);
        pInboundSA->sa_AcquireCtx = NULL;
    }

    RELEASE_LOCK(&pInboundSA->sa_Lock, kIrql);

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);

    //
    // Flush all the queued packets
    //

    IPSecFlushQueuedPackets(pInboundSA, STATUS_SUCCESS);
    IPSecDerefSA(pInboundSA);

    return status;
}


NTSTATUS
IPSecUpdateSA(
    IN  PIPSEC_UPDATE_SA    pUpdateSA,
    IN  ULONG               TotalSize
    )
/*++

Routine Description:

    Updates an inbound SA for which negotiation was kicked off via AcquireSA with
    the relevant keys/algorithms etc.

Arguments:

    pUpdateSA - Update SA context and info.

    TotalSize - the total size of the input buffer.

Return Value:


Notes:


--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PSA_STRUCT      saInfo = &pUpdateSA->SAInfo;
    PSA_TABLE_ENTRY pSA;
    PSA_TABLE_ENTRY pOutboundSA;
    PSA_HASH        pHash;
    ULONG           keyLen = 0;
    KIRQL	        kIrql;
    KIRQL	        kIrql1;
    KIRQL	        kIrql2;
    PIPSEC_ACQUIRE_CONTEXT  pAcquireContext = NULL;

    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecUpdateSA"));

    //
    // Lock the larval list so this SA does not go away.
    //
    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql1);
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    //
    // Sanity check the incoming context to see if it is actually
    // an SA block
    //
	if (!NT_SUCCESS(IPSecValidateHandle(HandleToUlong(saInfo->Context),
					&pAcquireContext, STATE_SA_LARVAL))) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecUpdSA: invalid context: %p", pAcquireContext));
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return  STATUS_INVALID_PARAMETER;
    }

    pSA = pAcquireContext->pSA;

    ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);
    ASSERT((pSA->sa_State == STATE_SA_LARVAL));

    //
    // figure out the key length and pass that in
    //
    keyLen = TotalSize - IPSEC_UPDATE_SA_NO_KEY_SIZE;

    IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecUpdSA: keyLen: %d", keyLen));

    //
    // sanity check the info passed in against the initial SA
    //
    if (pSA->sa_Filter) {
        status = IPSecCheckInboundSA(saInfo, pSA);

        if (!NT_SUCCESS(status)) {
            IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecUpdSA: IPSecCheckInboundSA failed: %lx", status));
            IPSecAbortAcquire(pAcquireContext);
            RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
            ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
            return status;
        }
    }

    //
    // Populate the SA block
    //
    status = IPSecPopulateSA(saInfo, keyLen, pSA);

    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_SAAPI, ("IPSecUpdSA: IPSecPopulateSA failed: %lx", status));
        // No need to free inbound SA since IPSecAbortAcquire will do it.
        IPSecAbortAcquire(pAcquireContext);
        RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
        ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
        return status;
    }

    //
    // inbound is ready to go!
    //
    pSA->sa_State = STATE_SA_LARVAL_ACTIVE;

    IPSEC_DEBUG(LL_A, DBF_SA, ("IPSecUpdateSA: SA: %p, S:%lx, D:%lx, O: %c",
                pSA,
                pSA->SA_SRC_ADDR,
                pSA->SA_DEST_ADDR,
                (pSA->sa_Operation[0] == Auth) ?
                    'A' : (pSA->sa_Operation[0] == Encrypt) ?
                        'E' : 'N'));

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    ASSERT(pSA->sa_Flags & FLAGS_SA_TIMER_STARTED);

    //
    // Bump the SA count for flush SA use; this is necessary because we flush
    // SA after releasing the lock because classification routine needs
    // it and the SA can be deleted right after we release the lock.
    //
    IPSecRefSA(pSA);

    ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql);

    //
    // Adjust SA lifetime to the maximum/minimum allowed in driver
    //
    if (pSA->sa_Lifetime.KeyExpirationTime > IPSEC_MAX_EXPIRE_TIME) {
        pSA->sa_Lifetime.KeyExpirationTime = IPSEC_MAX_EXPIRE_TIME;
    }

    if (pSA->sa_Lifetime.KeyExpirationTime &&
        pSA->sa_Lifetime.KeyExpirationTime < IPSEC_MIN_EXPIRE_TIME) {
        pSA->sa_Lifetime.KeyExpirationTime = IPSEC_MIN_EXPIRE_TIME;
    }

   //
    // Setup lifetime characteristics
    //
    IPSecSetupSALifetime(pSA);

    //
    // Init the LastUsedTime
    //
    NdisGetCurrentSystemTime(&pSA->sa_LastUsedTime);


    if ((pSA->sa_Flags & FLAGS_SA_DISABLE_LIFETIME_CHECK)) {

        if (!IPSecStopTimer(&(pSA->sa_Timer))) {
            IPSEC_DEBUG(LL_A, DBF_TIMER, ("Update: couldnt stop timer: %p", pSA));
        }
        pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
    } else {

        //
        // Reschedules the timer on this new value.
        //
        if (pSA->sa_Lifetime.KeyExpirationTime) {
            if (IPSecStopTimer(&pSA->sa_Timer)) {
                IPSecStartTimer(&pSA->sa_Timer,
                                IPSecSAExpired,
                                pSA->sa_Lifetime.KeyExpirationTime,              // expire in key expiration secs
                                (PVOID)pSA);
            }
        } else {
            ASSERT(FALSE);
            if (!IPSecStopTimer(&(pSA->sa_Timer))) {
                IPSEC_DEBUG(LL_A, DBF_TIMER, ("Update: couldnt stop timer: %p", pSA));
            }
            pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;
        }

    }
    RELEASE_LOCK(&pSA->sa_Lock, kIrql);

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);

    IPSecDerefSA(pSA);

    return  status;
}


VOID
IPSecRefSA(
    IN  PSA_TABLE_ENTRY         pSA
    )
/*++

Routine Description:

    Reference the SA passed in

Arguments:

    pSA - SA to be refed

Return Value:

    The final status from the operation.

--*/
{
    if (IPSEC_INCREMENT(pSA->sa_Reference) == 1) {
        ASSERT(FALSE);
    }
}


VOID
IPSecDerefSA(
    IN  PSA_TABLE_ENTRY         pSA
    )
/*++

Routine Description:

    Dereference the SA passed in; if refcount drops to 0, free the block.

Arguments:

    pSA - SA to be derefed

Return Value:

    The final status from the operation.

--*/
{
    ULONG   val;

    if ((val = IPSEC_DECREMENT(pSA->sa_Reference)) == 0) {
        //
        // last reference - destroy SA
        //
        IPSEC_DEBUG(LL_A, DBF_REF, ("Freeing SA: %p", pSA));

#if DBG

        if ((pSA->sa_Flags & FLAGS_SA_HW_PLUMBED)) {
            DbgPrint("Freeing SA: %p with offload on", pSA);
            DbgBreakPoint();
        }

        if (IPSEC_GET_VALUE(pSA->sa_NumSends) != 0) {
            DbgPrint("Freeing SA: %p with numsends > 0", pSA);
            DbgBreakPoint();
        }

        if ((pSA->sa_Flags & FLAGS_SA_TIMER_STARTED)) {
            DbgPrint("Freeing SA: %p with timer on", pSA);
            DbgBreakPoint();
        }

        if (pSA->sa_Signature != IPSEC_SA_SIGNATURE) {
            DbgPrint("Signature doesnt match for SA: %p", pSA);
            DbgBreakPoint();
        }

        if (!IPSEC_DRIVER_IS_INACTIVE() &&
            (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST)) {
            DbgPrint("Freeing SA: %p while still on filter list", pSA);
            DbgBreakPoint();
        }
#endif

        pSA->sa_Signature = IPSEC_SA_SIGNATURE + 1;

        IPSecFreeSA(pSA);
    }

    ASSERT((LONG)val >= 0);
}


VOID
IPSecStopSATimers()
/*++

Routine Description:

    Stop all timers active on Larval SA list and Filter list.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PLIST_ENTRY     pFilterEntry;
    PLIST_ENTRY     pSAEntry;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // Go through all SA's and stop its timers
    //
    for (   Index = MIN_FILTER;
            Index <= MAX_FILTER;
            Index++) {

        for (   pFilterEntry = g_ipsec.FilterList[Index].Flink;
                pFilterEntry != &g_ipsec.FilterList[Index];
                pFilterEntry = pFilterEntry->Flink) {

            pFilter = CONTAINING_RECORD(pFilterEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    IPSecStopSATimer(pSA);
                }
            }
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);
}

VOID
IPSecFlushLarvalSAList()
/*++

Routine Description:

    When the Acquire Irp is cancelled, this is called to flush all Larval SAs

    Called with SADB lock held (first); returns with it.
    Called with AcquireInfo.Lock held; returns with it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL           OldIrq;
    KIRQL           OldIrq1;
    KIRQL           kIrql;
    PSA_TABLE_ENTRY pLarvalSA;
    LIST_ENTRY      FreeList;

    InitializeListHead(&FreeList);

    while (TRUE) {
        if (!IsListEmpty(&g_ipsec.AcquireInfo.PendingAcquires)) {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&g_ipsec.AcquireInfo.PendingAcquires);

            pLarvalSA = CONTAINING_RECORD(  pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_PendingLinkage);
            ASSERT(pLarvalSA->sa_State == STATE_SA_LARVAL);
            ASSERT(pLarvalSA->sa_Flags & FLAGS_SA_PENDING);

            pLarvalSA->sa_Flags &= ~FLAGS_SA_PENDING;

            //
            // Insert into another list, which we walk without the lock
            //
            InsertTailList(&FreeList, &pLarvalSA->sa_PendingLinkage);

            //
            // also remove from Larval list
            //
            ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &OldIrq1);
            IPSecRemoveEntryList(&pLarvalSA->sa_LarvalLinkage);
            IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);
            RELEASE_LOCK(&g_ipsec.LarvalListLock, OldIrq1);
        } else {
            break;
        }
    }

    //
    // get the remaining Larval SAs
    //
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &OldIrq);
    while (TRUE) {
        if (!IsListEmpty(&g_ipsec.LarvalSAList)) {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&g_ipsec.LarvalSAList);

            pLarvalSA = CONTAINING_RECORD(  pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_LarvalLinkage);

            //
            // Insert into another list, which we walk without the lock
            //
            InsertTailList(&FreeList, &pLarvalSA->sa_PendingLinkage);

        } else {
            break;
        }
    }
    RELEASE_LOCK(&g_ipsec.LarvalListLock, OldIrq);

    while (TRUE) {
        if (!IsListEmpty(&FreeList)) {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&FreeList);

            pLarvalSA = CONTAINING_RECORD(  pEntry,
                                            SA_TABLE_ENTRY,
                                            sa_PendingLinkage);

            AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql);
            IPSecRemoveSPIEntry(pLarvalSA);
            ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql);

            //
            // Flush all the queued packets
            //
            IPSecFlushQueuedPackets(pLarvalSA, STATUS_TIMEOUT);

            //
            // also remove from the filter list
            //
            if (pLarvalSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
                pLarvalSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
                IPSecRemoveEntryList(&pLarvalSA->sa_FilterLinkage);
            }

            if (pLarvalSA->sa_RekeyOriginalSA) {
                ASSERT(pLarvalSA->sa_Flags & FLAGS_SA_REKEY);
                ASSERT(pLarvalSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA == pLarvalSA);
                ASSERT(pLarvalSA->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

                pLarvalSA->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
                pLarvalSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
                pLarvalSA->sa_RekeyOriginalSA = NULL;
            }

            //
            // release acquire context and invalidate the associated cache entry
            //
            ACQUIRE_LOCK(&pLarvalSA->sa_Lock, &kIrql);
            if (pLarvalSA->sa_AcquireCtx) {
                IPSecInvalidateHandle(pLarvalSA->sa_AcquireCtx);
                pLarvalSA->sa_AcquireCtx = NULL;
            }
            RELEASE_LOCK(&pLarvalSA->sa_Lock, kIrql);

            IPSecInvalidateSACacheEntry(pLarvalSA);

            IPSecStopTimerDerefSA(pLarvalSA);
        } else {
            break;
        }
    }

    return;
}


NTSTATUS
IPSecDeleteSA(
    IN  PIPSEC_DELETE_SA    pDeleteSA
    )
/*++

Routine Description:

    Delete the SA matching the particulars passed in.  Both inbound and
    outbound SAs are deleted.  No timer set for inbound SA.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA, pInboundSA;
    PLIST_ENTRY     pEntry, pSAEntry;
    KIRQL           kIrql;
    LONG            Index;
    LONG            SAIndex;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // Walk through the outbound SAs and delete matched ones.
    //
    for (   Index = OUTBOUND_TRANSPORT_FILTER;
            Index <= OUTBOUND_TUNNEL_FILTER;
            Index += TRANSPORT_TUNNEL_INCREMENT) {

        for (   pEntry = g_ipsec.FilterList[Index].Flink;
                pEntry != &g_ipsec.FilterList[Index];
                pEntry = pEntry->Flink) {

            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                pSAEntry = pFilter->SAChain[SAIndex].Flink;

                while (pSAEntry != &pFilter->SAChain[SAIndex]) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    pSAEntry = pSAEntry->Flink;

                    if (IPSecMatchSATemplate(pSA, &pDeleteSA->SATemplate)) {
                        ASSERT(pSA->sa_State == STATE_SA_ACTIVE);
                        ASSERT(pSA->sa_Flags & FLAGS_SA_OUTBOUND);
                        ASSERT(pSA->sa_AssociatedSA);

                        pInboundSA = pSA->sa_AssociatedSA;
                        if (pInboundSA) {
                            IPSecDeleteInboundSA(pInboundSA);
                        }
                    }
                }
            }
        }
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecExpireSA(
    IN  PIPSEC_EXPIRE_SA    pExpireSA
    )
/*++

Routine Description:

    Expires the SA matching the particulars passed in.
    Applied to Inbound SAs - we place the SA in the timer queue
    for the next time the timer hits. Also, we delete the
    corresponding outbound SA so no further packets match that
    SA.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PSA_TABLE_ENTRY pInboundSA;
    KIRQL           kIrql;
    NTSTATUS        status;

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    pInboundSA = IPSecLookupSABySPI(pExpireSA->DelInfo.SPI,
                                    pExpireSA->DelInfo.DestAddr);

    if (pInboundSA) {
        ASSERT((pInboundSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

        if (pInboundSA->sa_State == STATE_SA_ACTIVE) {
            IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Expiring SA: %p", pInboundSA));

            if (pInboundSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
                pInboundSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
                IPSecRemoveEntryList(&pInboundSA->sa_FilterLinkage);
            }

            pInboundSA->sa_Flags |= FLAGS_SA_DELETE_BY_IOCTL;

            IPSecExpireInboundSA(pInboundSA);
        }

        status = STATUS_SUCCESS;
    } else {
        IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Expire for a non-existent SA: %p", pExpireSA));

        status = STATUS_NO_MATCH;
    }

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    return  status;
}


VOID
IPSecSAExpired(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    )
/*++

Routine Description:

     Called when an SA has expired or when a Larval SA has timed out.

Arguments:

    pTimer - the timer struct

    Context - SA ptr

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    PSA_TABLE_ENTRY pSA = (PSA_TABLE_ENTRY)Context;
    PSA_TABLE_ENTRY pOutboundSA;
    KIRQL       	kIrql;
    KIRQL       	kIrql1;
    KIRQL       	kIrql2;
    KIRQL           OldIrq;

    IPSEC_DEBUG(LL_A, DBF_TIMER, ("IPSecSAExpired: pSA: %p state: %lx", pSA, pSA->sa_State));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql1);
    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    switch (pSA->sa_State) {
    case   STATE_SA_CREATED:
        ASSERT(FALSE);
        break;

    case   STATE_SA_LARVAL:
    case   STATE_SA_LARVAL_ACTIVE:
        //
        // Lock the larval list so this SA does not go away.
        //
        ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

        //
        // Remove from larval list
        //
        IPSecRemoveEntryList(&pSA->sa_LarvalLinkage);
        IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);

        //
        // Also remove from Pending list if queued there.
        //
        ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &kIrql1);
        if (pSA->sa_Flags & FLAGS_SA_PENDING) {
            ASSERT(pSA->sa_State == STATE_SA_LARVAL);
            IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecSAExpired: Removed from pending too: %p", pSA));
            IPSecRemoveEntryList(&pSA->sa_PendingLinkage);
            pSA->sa_Flags &= ~FLAGS_SA_PENDING;
        }
        RELEASE_LOCK(&g_ipsec.AcquireInfo.Lock, kIrql1);

        //
        // Flush all the queued packets
        //
        IPSecFlushQueuedPackets(pSA, STATUS_TIMEOUT);

        //
        // remove from inbound sa list
        //
        AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql1);
        IPSecRemoveSPIEntry(pSA);
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql1);

        //
        // also remove from the filter list
        //
        if (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
            pSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
            IPSecRemoveEntryList(&pSA->sa_FilterLinkage);
        }

        //
        // invalidate the associated cache entry
        //
        ACQUIRE_LOCK(&pSA->sa_Lock, &kIrql2);
        if (pSA->sa_AcquireCtx) {
            IPSecInvalidateHandle(pSA->sa_AcquireCtx);
            pSA->sa_AcquireCtx = NULL;
        }
        RELEASE_LOCK(&pSA->sa_Lock, kIrql2);

        IPSecInvalidateSACacheEntry(pSA);

        pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;

        if (pSA->sa_RekeyOriginalSA) {
            ASSERT(pSA->sa_Flags & FLAGS_SA_REKEY);
            ASSERT(pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA == pSA);
            ASSERT(pSA->sa_RekeyOriginalSA->sa_Flags & FLAGS_SA_REKEY_ORI);

            pSA->sa_RekeyOriginalSA->sa_Flags &= ~FLAGS_SA_REKEY_ORI;
            pSA->sa_RekeyOriginalSA->sa_RekeyLarvalSA = NULL;
            pSA->sa_RekeyOriginalSA = NULL;
        }

        if (pOutboundSA = pSA->sa_AssociatedSA) {

            ASSERT (0);

            IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
            IPSEC_DEC_TUNNELS(pOutboundSA);
            IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

            IPSecCleanupOutboundSA(pSA, pOutboundSA, FALSE);
        }

        IPSEC_DEBUG(LL_A, DBF_REF, ("Timer in Deref"));
        IPSecDerefSA(pSA);

        break;

    case   STATE_SA_ZOMBIE:
        ASSERT(FALSE);
        break;

    case   STATE_SA_ACTIVE:
        //
        // Inbound SA being expired; outbound was deleted immediately
        //
        ASSERT((pSA->sa_Flags & FLAGS_SA_OUTBOUND) == 0);

        ACQUIRE_LOCK(&g_ipsec.AcquireInfo.Lock, &OldIrq);
        IPSecNotifySAExpiration(pSA, NULL, OldIrq, FALSE);

        ASSERT (NULL == pSA->sa_AcquireCtx);

        //
        // remove from inbound sa list
        //
        AcquireWriteLock(&g_ipsec.SPIListLock, &kIrql1);
        IPSecRemoveSPIEntry(pSA);
        ReleaseWriteLock(&g_ipsec.SPIListLock, kIrql1);

        //
        // also remove from the filter list
        //
        if (pSA->sa_Flags & FLAGS_SA_ON_FILTER_LIST) {
            pSA->sa_Flags &= ~FLAGS_SA_ON_FILTER_LIST;
            IPSecRemoveEntryList(&pSA->sa_FilterLinkage);
        }

        //
        // invalidate the associated cache entry
        //
        IPSecInvalidateSACacheEntry(pSA);

        pSA->sa_Flags &= ~FLAGS_SA_TIMER_STARTED;

        if (pOutboundSA = pSA->sa_AssociatedSA) {

            IPSEC_DEC_STATISTIC(dwNumActiveAssociations);
            IPSEC_DEC_TUNNELS(pOutboundSA);
            IPSEC_DECREMENT(g_ipsec.NumOutboundSAs);

            IPSecCleanupOutboundSA(pSA, pOutboundSA, FALSE);
        } 

        if (pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
            IPSecDelHWSAAtDpc(pSA);
        }

        ASSERT(pSA->sa_AssociatedSA == NULL);
        IPSEC_DEBUG(LL_A, DBF_REF, ("Timer#2 in Deref"));
        IPSecDerefSA(pSA);

        break;

    default:
        ASSERT(FALSE);
    }

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);
    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql1);
}


VOID
IPSecFillSAInfo(
    IN  PSA_TABLE_ENTRY pSA,
    OUT PIPSEC_SA_INFO  pBuf
    )
/*++

Routine Description:

    Fill out the SA_INFO structure.

Arguments:

    pSA     - SA to be filled in
    pBuf    - where to fill in

Returns:

    None.

--*/
{
    LONG            Index;
    PSA_TABLE_ENTRY pAssociatedSA = pSA->sa_AssociatedSA;

    RtlZeroMemory(pBuf, sizeof(IPSEC_SA_INFO));

    pBuf->PolicyId = pSA->sa_Filter->PolicyId;
    pBuf->FilterId = pSA->sa_Filter->FilterId;
    pBuf->Lifetime = pSA->sa_Lifetime;
    pBuf->InboundTunnelAddr = pSA->sa_SrcTunnelAddr;
    pBuf->NumOps = pSA->sa_NumOps;

    pBuf->dwQMPFSGroup = pSA->sa_QMPFSGroup;
    RtlCopyMemory(  &pBuf->CookiePair,
                    &pSA->sa_CookiePair,
                    sizeof(IKE_COOKIE_PAIR));

    for (Index = 0; Index < pSA->sa_NumOps; Index++) {
        pBuf->Operation[Index] = pSA->sa_Operation[Index];

        pBuf->EXT_INT_ALGO_EX(Index) = pSA->INT_ALGO(Index);
        pBuf->EXT_INT_KEYLEN_EX(Index) = pSA->INT_KEYLEN(Index);
        pBuf->EXT_INT_ROUNDS_EX(Index) = pSA->INT_ROUNDS(Index);

        pBuf->EXT_CONF_ALGO_EX(Index) = pSA->CONF_ALGO(Index);
        pBuf->EXT_CONF_KEYLEN_EX(Index) = pSA->CONF_KEYLEN(Index);
        pBuf->EXT_CONF_ROUNDS_EX(Index) = pSA->CONF_ROUNDS(Index);

        if (pAssociatedSA) {
            pBuf->InboundSPI[Index] = pAssociatedSA->sa_OtherSPIs[Index];
        }
        pBuf->OutboundSPI[Index] = pSA->sa_OtherSPIs[Index];
    }

    pBuf->AssociatedFilter.SrcAddr = pSA->SA_SRC_ADDR & pSA->SA_SRC_MASK;
    pBuf->AssociatedFilter.SrcMask = pSA->SA_SRC_MASK;
    pBuf->AssociatedFilter.DestAddr = pSA->SA_DEST_ADDR & pSA->SA_DEST_MASK;
    pBuf->AssociatedFilter.DestMask = pSA->SA_DEST_MASK;
    pBuf->AssociatedFilter.Protocol = pSA->SA_PROTO;
    pBuf->AssociatedFilter.SrcPort = SA_SRC_PORT(pSA);
    pBuf->AssociatedFilter.DestPort = SA_DEST_PORT(pSA);
    pBuf->AssociatedFilter.TunnelAddr = pSA->sa_TunnelAddr;
    pBuf->AssociatedFilter.TunnelFilter = (pSA->sa_Flags & FLAGS_SA_TUNNEL) != 0;

    if (pSA->sa_Flags & FLAGS_SA_OUTBOUND) {
        pBuf->AssociatedFilter.Flags = FILTER_FLAGS_OUTBOUND;
    } else {
        pBuf->AssociatedFilter.Flags = FILTER_FLAGS_INBOUND;
    }

    if (pSA->sa_Flags & FLAGS_SA_INITIATOR) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_INITIATOR;
    }
    if (pSA->sa_Flags & FLAGS_SA_MTU_BUMPED) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_MTU_BUMPED;
    }
    if (pSA->sa_Flags & FLAGS_SA_HW_PLUMBED) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_OFFLOADED;
    }
    if (pSA->sa_Flags & FLAGS_SA_HW_PLUMB_FAILED) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_OFFLOAD_FAILED;
    }
    if (pSA->sa_Flags & FLAGS_SA_OFFLOADABLE) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_OFFLOADABLE;
    }
    if (pSA->sa_Flags & FLAGS_SA_REKEY_ORI) {
        pBuf->EnumFlags |= SA_ENUM_FLAGS_IN_REKEY;
    }

    pBuf->Stats.ConfidentialBytesSent = pSA->sa_Stats.ConfidentialBytesSent;
    pBuf->Stats.AuthenticatedBytesSent = pSA->sa_Stats.AuthenticatedBytesSent;
    pBuf->Stats.TotalBytesSent = pSA->sa_Stats.TotalBytesSent;
    pBuf->Stats.OffloadedBytesSent = pSA->sa_Stats.OffloadedBytesSent;

    if (pAssociatedSA) {
        pBuf->Stats.ConfidentialBytesReceived =
            pAssociatedSA->sa_Stats.ConfidentialBytesReceived;
        pBuf->Stats.AuthenticatedBytesReceived =
            pAssociatedSA->sa_Stats.AuthenticatedBytesReceived;
        pBuf->Stats.TotalBytesReceived =
            pAssociatedSA->sa_Stats.TotalBytesReceived;
        pBuf->Stats.OffloadedBytesReceived =
            pAssociatedSA->sa_Stats.OffloadedBytesReceived;
    }
    
    ConvertEncapInfo(pSA,&pBuf->EncapInfo);
}


NTSTATUS
IPSecEnumSAs(
    IN  PIRP    pIrp,
    OUT PULONG  pBytesCopied
    )
/*++

Routine Description:

    Fills in the request to enumerate SAs.

Arguments:

    pIrp            - The actual Irp
    pBytesCopied    - the number of bytes copied.

Returns:

    Status of the operation.

--*/
{
    PNDIS_BUFFER    NdisBuffer = NULL;
    PIPSEC_ENUM_SAS pEnum = NULL;
    ULONG           BufferLength = 0;
    KIRQL           kIrql;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pSAEntry;
    IPSEC_SA_INFO   infoBuff = {0};
    NTSTATUS        status = STATUS_SUCCESS;
    ULONG           BytesCopied = 0;
    ULONG           Offset = 0;
    PFILTER         pFilter;
    PSA_TABLE_ENTRY pSA;
    LONG            Index;
    LONG            FilterIndex;
    LONG            SAIndex;

    //
    // Get at the IO buffer - its in the MDL
    //
    NdisBuffer = REQUEST_NDIS_BUFFER(pIrp);
    if (NdisBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    NdisQueryBufferSafe(NdisBuffer,
                        (PVOID *)&pEnum,
                        &BufferLength,
                        NormalPagePriority);

    //
    // Make sure NdisQueryBufferSafe succeeds.
    //
    if (!pEnum) {
        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("EnumSAs failed, no resources"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make sure we have enough room for just the header not
    // including the data.
    //
    if (BufferLength < (UINT)(FIELD_OFFSET(IPSEC_ENUM_SAS, pInfo[0]))) {
        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("EnumSAs failed, buffer too small"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Make sure we are naturally aligned.
    //
    if (((ULONG_PTR)(pEnum)) & (TYPE_ALIGNMENT(IPSEC_ENUM_SAS) - 1)) {
        IPSEC_DEBUG(LL_A, DBF_IOCTL, ("EnumSAs failed, alignment"));
        return STATUS_DATATYPE_MISALIGNMENT_ERROR;
    }

    pEnum->NumEntries = 0;
    pEnum->NumEntriesPresent = 0;

    //
    // Now copy over the SA data into the user buffer and fit as many as possible.
    //
    BufferLength -= FIELD_OFFSET(IPSEC_ENUM_SAS, pInfo[0]);
    Offset = FIELD_OFFSET(IPSEC_ENUM_SAS, pInfo[0]);

    Index = pEnum->Index;   // where to start?

    AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

    for (   FilterIndex = MIN_FILTER;
            FilterIndex <= MAX_FILTER;
            FilterIndex++) {

        for (   pEntry = g_ipsec.FilterList[FilterIndex].Flink;
                pEntry != &g_ipsec.FilterList[FilterIndex];
                pEntry = pEntry->Flink) {

            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex ++) {

                for (   pSAEntry = pFilter->SAChain[SAIndex].Flink;
                        pSAEntry != &pFilter->SAChain[SAIndex];
                        pSAEntry = pSAEntry->Flink) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    //
                    // Only interested in outbound or multicast SAs.
                    //
                    if (!(pSA->sa_Flags & FLAGS_SA_OUTBOUND)) {
                        continue;
                    }

                    //
                    // Dump only SAs that match the template.
                    //
                    if (IPSecMatchSATemplate(pSA, &pEnum->SATemplate)) {
                        if (Index > 0) {
                            Index--;    // Skip number of Index SAs.
                            continue;
                        }

                        pEnum->NumEntriesPresent++;

                        if ((INT)(BufferLength - BytesCopied) >= (INT)sizeof(IPSEC_SA_INFO)) {
                            IPSecFillSAInfo(pSA, &infoBuff);
                            BytesCopied += sizeof(IPSEC_SA_INFO);
                            NdisBuffer = CopyToNdis(NdisBuffer, (UCHAR *)&infoBuff, sizeof(IPSEC_SA_INFO), &Offset);
                            if (!NdisBuffer) {
                                ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
                                return STATUS_INSUFFICIENT_RESOURCES;
                            }
                        }
                    }
                }
            }
        }
    }

    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

    pEnum->NumEntries = BytesCopied / sizeof(IPSEC_SA_INFO);

    *pBytesCopied = BytesCopied + FIELD_OFFSET(IPSEC_ENUM_SAS, pInfo[0]);

    if (pEnum->NumEntries < pEnum->NumEntriesPresent) {
        status = STATUS_BUFFER_OVERFLOW;
    }

    return status;
}


VOID
IPSecReaper(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    )
/*++

Routine Description:

    Called every 5 mins; reaps the (active) SA list

Arguments:

    pTimer - the timer struct

    Context - NULL

Return Value:

    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/
{
    KIRQL	kIrql;

    IPSEC_DEBUG(LL_A, DBF_TIMER, ("Entering IPSecReaper"));

    AcquireWriteLock(&g_ipsec.SADBLock, &kIrql);

    //
    // walk the outbound SAs and delete/expire them if they have been
    // idle for sometime (lets say 5 mins for now).
    //
    IPSecReapIdleSAs();

    ReleaseWriteLock(&g_ipsec.SADBLock, kIrql);

    IPSEC_DEBUG(LL_A, DBF_TIMER, ("Exiting IPSecReaper"));
    if (!IPSEC_DRIVER_IS_INACTIVE()) {
        IPSecStartTimer(&g_ipsec.ReaperTimer,
                        IPSecReaper,
                        IPSEC_REAPER_TIME,
                        (PVOID)NULL);
    }

}


VOID
IPSecReapIdleSAs()
/*++

Routine Description:

    Called to reap the idle SA list

Arguments:


Return Value:


--*/
{
    PSA_TABLE_ENTRY pSA;
    PFILTER         pFilter;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pSAEntry;
    BOOLEAN         fExpired;
    LONG            Index;
    LONG            SAIndex;

    IPSEC_DEBUG(LL_A, DBF_TIMER, ("Entering IPSecReapIdleSAs"));

    //
    // Walk the inbound SAs and delete/expire them if they have been
    // idle for sometime (lets say 5 mins for now).
    //
    for (   Index = INBOUND_TRANSPORT_FILTER;
            Index <= INBOUND_TUNNEL_FILTER;
            Index += TRANSPORT_TUNNEL_INCREMENT) {

        for (   pEntry = g_ipsec.FilterList[Index].Flink;
                pEntry != &g_ipsec.FilterList[Index];
                pEntry = pEntry->Flink) {

            pFilter = CONTAINING_RECORD(pEntry,
                                        FILTER,
                                        MaskedLinkage);

            for (   SAIndex = 0;
                    SAIndex < pFilter->SAChainSize;
                    SAIndex++) {

                pSAEntry = pFilter->SAChain[SAIndex].Flink;

                while (pSAEntry != &pFilter->SAChain[SAIndex]) {

                    pSA = CONTAINING_RECORD(pSAEntry,
                                            SA_TABLE_ENTRY,
                                            sa_FilterLinkage);

                    ASSERT(!(pSA->sa_Flags & FLAGS_SA_OUTBOUND));

                    pSAEntry = pSAEntry->Flink;

                    if (!(pSA->sa_Flags & FLAGS_SA_IDLED_OUT) &&
                        (pSA->sa_State == STATE_SA_ACTIVE) &&
                        !(pSA->sa_Flags & FLAGS_SA_DISABLE_IDLE_OUT)) {

                        IPSEC_SA_EXPIRED(pSA, fExpired);
                        if (fExpired) {
                            pSA->sa_Flags |= FLAGS_SA_IDLED_OUT;
                            IPSecExpireInboundSA(pSA);
                        }
                    }
                }
            }
        }
    }

    IPSEC_DEBUG(LL_A, DBF_TIMER, ("Exiting IPSecReapIdleSAs"));
}


VOID
IPSecFlushEventLog(
    IN	PIPSEC_TIMER	pTimer,
    IN	PVOID		Context
    )
/*++

Routine Description:

    Called every LogInterval seconds; flush all events currently logged.

Arguments:

    pTimer - the timer struct

    Context - NULL

Return Value:


Notes:


--*/
{
    KIRQL   kIrql;

    IPSEC_DEBUG(LL_A, DBF_TIMER, ("Entering IPSecFlushEventLog"));

    ACQUIRE_LOCK(&g_ipsec.EventLogLock, &kIrql);

    if (g_ipsec.IPSecLogMemoryLoc > g_ipsec.IPSecLogMemory) {
        //
        // Flush the logs.
        //
        IPSecQueueLogEvent();
    }

    RELEASE_LOCK(&g_ipsec.EventLogLock, kIrql);

    if (!IPSEC_DRIVER_IS_INACTIVE()) {
        IPSecStartTimer(&g_ipsec.EventLogTimer,
                        IPSecFlushEventLog,
                        g_ipsec.LogInterval,
                        (PVOID)NULL);
    }
}


NTSTATUS
IPSecQuerySpi(
    IN OUT PIPSEC_QUERY_SPI pQuerySpi
    )
/*++

Routine Description:

    Queries IPSEC for spis corresponding to given filter

Arguments:


Return Value:


Notes:


--*/
{
    NTSTATUS    status;

    ULARGE_INTEGER  uliSrcDstAddr;
    ULARGE_INTEGER  uliProtoSrcDstPort;
    PFILTER         pFilter = NULL;
    PSA_TABLE_ENTRY pSA = NULL;
    PSA_TABLE_ENTRY pNextSA = NULL;
    PSA_TABLE_ENTRY pTunnelSA = NULL;
    KIRQL           kIrql;

    pQuerySpi->Spi          = 0;
    pQuerySpi->OtherSpi     = 0;
    pQuerySpi->Operation    = 0;

    IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecQuerySPI: Src %08x.%04x Dst %08x.%04x Protocol %d",
                          pQuerySpi->Filter.SrcAddr,
                          pQuerySpi->Filter.SrcPort,
                          pQuerySpi->Filter.DestAddr,
                          pQuerySpi->Filter.DestPort,
                          pQuerySpi->Filter.Protocol));

    IPSEC_BUILD_SRC_DEST_ADDR(  uliSrcDstAddr,
                                pQuerySpi->Filter.SrcAddr,
                                pQuerySpi->Filter.DestAddr);

    IPSEC_BUILD_PROTO_PORT_LI(  uliProtoSrcDstPort,
                                pQuerySpi->Filter.Protocol,
                                pQuerySpi->Filter.SrcPort,
                                pQuerySpi->Filter.DestPort);


    AcquireReadLock(&g_ipsec.SADBLock, &kIrql);

    //
    // search for SA
    //
    status = IPSecLookupSAByAddr(   uliSrcDstAddr,
                                    uliProtoSrcDstPort,
                                    &pFilter,
                                    &pSA,
                                    &pNextSA,
                                    &pTunnelSA,
                                    FALSE,
                                    FALSE,
                                    FALSE,
                                    FALSE,
                                    NULL); 
    if (!NT_SUCCESS(status)) {
        IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("IPSecQuerySPI: IPSecLookupSAByAddr failed: %lx", status));
        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
        return status;
    }

    if (status == STATUS_SUCCESS) {
        ASSERT(pSA);
    } else {
        ReleaseReadLock(&g_ipsec.SADBLock, kIrql);
        return STATUS_SUCCESS;
    }

    pQuerySpi->Spi = pSA->sa_SPI;

    if (pSA->sa_AssociatedSA) {
        pQuerySpi->OtherSpi = pSA->sa_AssociatedSA->sa_SPI;
    }

    pQuerySpi->Operation = pSA->sa_Operation[pSA->sa_NumOps-1];

    ReleaseReadLock(&g_ipsec.SADBLock, kIrql);

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecSetOperationMode(
    IN PIPSEC_SET_OPERATION_MODE    pSetOperationMode
    )
/*++

Routine Description:

    Set the driver operation mode.

Arguments:



Return Value:



Notes:


--*/
{
    NTSTATUS status = STATUS_SUCCESS; 

    //
    // Check that SPD has provided a value within bounds
    //
    if (!( (pSetOperationMode->OperationMode >= IPSEC_BYPASS_MODE) &&
    	(pSetOperationMode->OperationMode < IPSEC_OPERATION_MODE_MAX))){
    		status  = STATUS_UNSUCCESSFUL;
    	}

    //
    // SPD can not move driver dynamically into boot time stateful mode
    //
    if ( IPSEC_BOOTTIME_STATEFUL_MODE == pSetOperationMode->OperationMode){
    		status = STATUS_UNSUCCESSFUL;
    	}
    	
      
     if ( STATUS_SUCCESS == status){
     		 g_ipsec.OperationMode = pSetOperationMode->OperationMode;
     		 //
     		 // Log the new operation mode in the system event log
     		 //
     		 IPSecLogChangeOperationMode();
     	}
     return status;
}


NTSTATUS
IPSecInitializeTcpip(
    IN PIPSEC_SET_TCPIP_STATUS  pSetTcpipStatus
    )
/*++

Routine Description:

    Initialize TCP/IP.

Arguments:



Return Value:



Notes:


--*/
{
    IPInfo  Info;

    if (IPSEC_DRIVER_INIT_TCPIP()) {
        return  STATUS_SUCCESS;
    }

    //
    // Store all TCP/IP function pointers for future use.  There is no check
    // for NULL pointer here because the function pointer can also be stale
    // address.  We trust TCP/IP to pass in the values corretly.
    //
    TCPIP_FREE_BUFF = pSetTcpipStatus->TcpipFreeBuff;
    TCPIP_ALLOC_BUFF = pSetTcpipStatus->TcpipAllocBuff;
    TCPIP_GET_INFO = pSetTcpipStatus->TcpipGetInfo;
    TCPIP_NDIS_REQUEST = pSetTcpipStatus->TcpipNdisRequest;
    TCPIP_SET_IPSEC_STATUS = pSetTcpipStatus->TcpipSetIPSecStatus;
    TCPIP_SET_IPSEC = pSetTcpipStatus->TcpipSetIPSecPtr;
    TCPIP_UNSET_IPSEC = pSetTcpipStatus->TcpipUnSetIPSecPtr;
    TCPIP_UNSET_IPSEC_SEND = pSetTcpipStatus->TcpipUnSetIPSecSendPtr;
    TCPIP_TCP_XSUM = pSetTcpipStatus->TcpipTCPXsum;
    TCPIP_SEND_ICMP_ERR = pSetTcpipStatus->TcpipSendICMPErr;

    //
    // Initialize IPInfo for reinjecting packets to TCP/IP.
    //
    if (TCPIP_GET_INFO(&Info, sizeof(IPInfo)) != IP_SUCCESS) {
        ASSERT(FALSE);
        return  STATUS_BUFFER_TOO_SMALL;
    }

    Info.ipi_initopts(&g_ipsec.OptInfo);

    //
    // The followings come from IPInfo.
    //
    TCPIP_REGISTER_PROTOCOL = Info.ipi_protreg;
    TCPIP_DEREGISTER_PROTOCOL = Info.ipi_protdereg;
    TCPIP_IP_TRANSMIT = Info.ipi_xmit;
    TCPIP_GET_ADDRTYPE = Info.ipi_getaddrtype;
    TCPIP_GEN_IPID = Info.ipi_getipid;
    TCPIP_GET_PINFO = Info.ipi_getpinfo;

    //
    // Don't register IPSecStatus function for AH and ESP protocol here.
    // Registration occurs with filter addition.
    //

    //
    // Everything is ready to go, bind to IP so we will intercept traffic.
    //
    IPSecBindToIP();

    // We want to see traffic on forward path if we are in any of these
    // two modes
    if (IS_DRIVER_BOOTSTATEFUL() || IS_DRIVER_BLOCK()){
        TCPIP_SET_IPSEC_STATUS(TRUE);
    }


    IPSEC_DRIVER_INIT_TCPIP() = TRUE;

    return STATUS_SUCCESS;
}


NTSTATUS
IPSecDeinitializeTcpip(
    VOID
    )
/*++

Routine Description:

    Deinitialize TCP/IP.

Arguments:



Return Value:



Notes:


--*/
{
    if (!IPSEC_DRIVER_INIT_TCPIP()) {
        return  STATUS_SUCCESS;
    }

    IPSEC_DRIVER_INIT_TCPIP() = FALSE;

    //
    // Unbind IPSecHandlerPtr from TCP/IP and wait for all transmits, pending
    // sends, worker threads and iotcls to complete.
    //
    IPSecUnbindSendFromIP();

    //
    // Wait for all threads (transmits) to finish.
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumThreads) != 0) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Wait for all pending IOCTLs to finish.  Note this current IOCTL also
    // takes one count.
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumIoctls) != 1) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Wait for all worker threads (logs or plumbs) to finish.
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumWorkers) != 0) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Wait for all send completes to go through.
    //
    while (IPSEC_GET_VALUE(g_ipsec.NumSends) != 0) {
        IPSEC_DELAY_EXECUTION();
    }

    //
    // Reset IPSecStatus functions in TCP/IP to NULL.
    //
    if (IPSEC_GET_VALUE(gdwInitEsp)) {
        TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_ESP);
        IPSEC_SET_VALUE(gdwInitEsp, 0);
    }
    if (IPSEC_GET_VALUE(gdwInitAh)) {
        TCPIP_DEREGISTER_PROTOCOL(PROTOCOL_AH);
        IPSEC_SET_VALUE(gdwInitAh, 0);
    }

    //
    // Unbind the rest of IPSec routines from TCP/IP.
    //
    IPSecUnbindFromIP();

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecSetTcpipStatus(
    IN PIPSEC_SET_TCPIP_STATUS  pSetTcpipStatus
    )
/*++

Routine Description:

    Set the TCP/IP driver status indicating whether can register with it.

Arguments:



Return Value:



Notes:


--*/
{
    PAGED_CODE();

    if (pSetTcpipStatus->TcpipStatus) {
        return  IPSecInitializeTcpip(pSetTcpipStatus);
    } else {
        return  IPSecDeinitializeTcpip();
    }
}


NTSTATUS
IPSecResetCacheTable(
    VOID
    )
/*++

Routine Description:

    Invalidate all cache entries and its associated SA or Filter.

Arguments:


Return Value:


Notes:


--*/
{
    PFILTER_CACHE   pCache;
    ULONG           i;

    for (i = 0; i < g_ipsec.CacheSize; i ++) {
        pCache = g_ipsec.ppCache[i];
        if (pCache && IS_VALID_CACHE_ENTRY(pCache)) {
            if (pCache->FilterEntry) {
                pCache->pFilter->FilterCache = NULL;
            } else {
                pCache->pSAEntry->sa_FilterCache = NULL;
                if (pCache->pNextSAEntry) {
                    pCache->pNextSAEntry->sa_FilterCache = NULL;
                }
            }
            INVALIDATE_CACHE_ENTRY(pCache);
        }
    }

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecPurgeFilterSAs(
    IN PFILTER             pFilter
    )
/*++

Routine Description

    Delete all SAs that are related to this filter.

Locks

    Called with SADB held.

Arguments

    pFilter - filter of interest

Return Value

    STATUS_SUCCESS

--*/
{
    PLIST_ENTRY     pEntry;
    PSA_TABLE_ENTRY pSA;
    KIRQL           kIrql;
    LONG            Index;
    KIRQL           kIrql2;


    //
    // Expire each inbound SA and delete outbound SA
    //
    for (Index = 0; Index < pFilter->SAChainSize; Index ++) {
        pEntry = pFilter->SAChain[Index].Flink;

        while (pEntry != &pFilter->SAChain[Index]) {

            pSA = CONTAINING_RECORD(pEntry,
                                    SA_TABLE_ENTRY,
                                    sa_FilterLinkage);

            pEntry = pEntry->Flink;

            if (pSA->sa_State == STATE_SA_ACTIVE) {
                IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Destroying active SA: %p", pSA));
                //
                // Filter is going away, SA must be deleted now
                //

                //
                // The SA must be fully associated
                //
                if (pSA->sa_Flags & FLAGS_SA_OUTBOUND) {
                    pSA = pSA->sa_AssociatedSA;
                    ASSERT (pSA->sa_State == STATE_SA_ACTIVE);
                }
                IPSecDeleteInboundSA(pSA);
            } else {

                ASSERT (pSA->sa_State == STATE_SA_LARVAL || pSA->sa_State == STATE_SA_LARVAL_ACTIVE);
                ASSERT (NULL == pSA->sa_AssociatedSA);

                IPSEC_DEBUG(LL_A, DBF_ACQUIRE, ("Destroying larval SA: %p", pSA));
                IPSecDeleteLarvalSA(pSA);
            }
        }
    }

    //
    // Also need to remove all those larval SAs whose sa_Filter is pointing
    // to the filter being deleted.
    //

    ACQUIRE_LOCK(&g_ipsec.LarvalListLock, &kIrql);

    pEntry = g_ipsec.LarvalSAList.Flink;
    while (pEntry != &g_ipsec.LarvalSAList) {
        pSA = CONTAINING_RECORD(pEntry,
                                SA_TABLE_ENTRY,
                                sa_LarvalLinkage);
        pEntry = pEntry->Flink;

        if (pSA->sa_Filter == pFilter) {
            IPSecRemoveEntryList(&pSA->sa_LarvalLinkage);
            IPSEC_DEC_STATISTIC(dwNumPendingKeyOps);
            IPSecCleanupLarvalSA(pSA);
        }
    }

    RELEASE_LOCK(&g_ipsec.LarvalListLock, kIrql);

    return  STATUS_SUCCESS;
}


NTSTATUS
IPSecSetupSALifetime(
    IN  PSA_TABLE_ENTRY pSA
    )
/*++

Routine Description:

    Setup the SA lifetime characteristics for rekey and idle timeout.

Arguments:


Return Value:


--*/
{
    LARGE_INTEGER   CurrentTime;
    LARGE_INTEGER   Delta = {0};
    LARGE_INTEGER   Pad = {(pSA->sa_Flags & FLAGS_SA_INITIATOR)?
                            IPSEC_EXPIRE_TIME_PAD_I :
                            IPSEC_EXPIRE_TIME_PAD_R,
                            0};

    //
    // pSA->sa_Lifetime.KeyExpirationTime is in seconds.
    //
    if (pSA->sa_Lifetime.KeyExpirationTime) {
        IPSEC_CONVERT_SECS_TO_100NS(Delta, pSA->sa_Lifetime.KeyExpirationTime);

        NdisGetCurrentSystemTime(&CurrentTime);

        pSA->sa_KeyExpirationTime.QuadPart = (CurrentTime.QuadPart + Delta.QuadPart);

        pSA->sa_KeyExpirationTimeWithPad.QuadPart = pSA->sa_KeyExpirationTime.QuadPart - Pad.QuadPart;

        if (!(pSA->sa_KeyExpirationTimeWithPad.QuadPart > 0i64)) {
            pSA->sa_KeyExpirationTimeWithPad.QuadPart = 0i64;
        }
    }

    //
    // pSA->sa_Lifetime.KeyExpirationBytes is in Kbytes.
    //
    if (pSA->sa_Lifetime.KeyExpirationBytes) {
        pSA->sa_KeyExpirationBytes.LowPart = pSA->sa_Lifetime.KeyExpirationBytes;
        pSA->sa_KeyExpirationBytes = EXTENDED_MULTIPLY(pSA->sa_KeyExpirationBytes, 1024);

        if (pSA->sa_Flags & FLAGS_SA_INITIATOR) {
            pSA->sa_KeyExpirationBytesWithPad.LowPart = pSA->sa_Lifetime.KeyExpirationBytes * IPSEC_EXPIRE_THRESHOLD_I / 100;
        } else {
            pSA->sa_KeyExpirationBytesWithPad.LowPart = pSA->sa_Lifetime.KeyExpirationBytes * IPSEC_EXPIRE_THRESHOLD_R / 100;
        }

        pSA->sa_KeyExpirationBytesWithPad = EXTENDED_MULTIPLY(pSA->sa_KeyExpirationBytesWithPad, 1024);
    }

    //
    // Also setup the idle timeout characteristics.
    //
    if (pSA->sa_Flags & FLAGS_SA_ENABLE_NLBS_IDLE_CHECK) {
        IPSEC_CONVERT_SECS_TO_100NS(pSA->sa_IdleTime,
                                    IPSEC_NLBS_IDLE_TIME);
    } else {
        if (pSA->sa_Flags & FLAGS_SA_INITIATOR) {
            IPSEC_CONVERT_SECS_TO_100NS(pSA->sa_IdleTime,
                                        (g_ipsec.DefaultSAIdleTime + IPSEC_DEFAULT_SA_IDLE_TIME_PAD_I));
        } else {
            IPSEC_CONVERT_SECS_TO_100NS(pSA->sa_IdleTime,
                                        (g_ipsec.DefaultSAIdleTime + IPSEC_DEFAULT_SA_IDLE_TIME_PAD_R));
        }
    }

    return  STATUS_SUCCESS;
}

DWORD ConvertAddr(IPAddr Addr, IPAddr Mask, ADDR* OutAddr)
{

    if (Mask == 0xffffffff) {
        OutAddr->AddrType=IP_ADDR_UNIQUE;
    } else {
        OutAddr->AddrType=IP_ADDR_SUBNET;
    }
    
    OutAddr->uSubNetMask=Mask;
    OutAddr->uIpAddr=Addr;
    OutAddr->pgInterfaceID = NULL;

    return STATUS_SUCCESS;

}

VOID ConvertEncapInfo(PSA_TABLE_ENTRY pInSA,
                      PUDP_ENCAP_INFO pEncapInfo)
{

    memset(pEncapInfo,0,sizeof(UDP_ENCAP_INFO));

    pEncapInfo->SAEncapType = SA_UDP_ENCAP_TYPE_NONE;

    pEncapInfo->SAEncapType = pInSA->sa_EncapType;

    if (pEncapInfo->SAEncapType !=  SA_UDP_ENCAP_TYPE_NONE) {
        pEncapInfo->UdpEncapContext.wSrcEncapPort=NET_SHORT(pInSA->sa_EncapContext.wSrcEncapPort);
        pEncapInfo->UdpEncapContext.wDesEncapPort=NET_SHORT(pInSA->sa_EncapContext.wDesEncapPort);

        pEncapInfo->PeerAddrVersion = IPSEC_PROTOCOL_V4;
        
        ConvertAddr(pInSA->sa_PeerPrivateAddr, 0xffffffff,
                    &pEncapInfo->PeerPrivateAddr);
    }



}

DWORD ConvertSAToIPSecQMSA(PIPSEC_QM_SA pOutSA,
                           PSA_TABLE_ENTRY pInSA)
/*++

Routine Description:

    Convert SA_TABLE_ENTRY to IPSEC_QM_SA

Arguments:


Return Value:


--*/
{
    int i;

    memcpy(&pOutSA->gQMPolicyID,&pInSA->sa_Filter->PolicyId,sizeof(GUID));
    memcpy(&pOutSA->gQMFilterID,&pInSA->sa_Filter->FilterId,sizeof(GUID));
    
    memcpy(&pOutSA->MMSpi.Initiator,&pInSA->sa_CookiePair.Initiator,sizeof(IKE_COOKIE));
    memcpy(&pOutSA->MMSpi.Responder,&pInSA->sa_CookiePair.Responder,sizeof(IKE_COOKIE));

    pOutSA->IpsecQMFilter.IpVersion = IPSEC_PROTOCOL_V4;
    ConvertAddr(pInSA->SA_SRC_ADDR,pInSA->SA_SRC_MASK,&pOutSA->IpsecQMFilter.SrcAddr);
    ConvertAddr(pInSA->SA_DEST_ADDR,pInSA->SA_DEST_MASK,&pOutSA->IpsecQMFilter.DesAddr);

    pOutSA->IpsecQMFilter.Protocol.ProtocolType=PROTOCOL_UNIQUE;
    pOutSA->IpsecQMFilter.Protocol.dwProtocol=pInSA->SA_PROTO;

    pOutSA->IpsecQMFilter.SrcPort.PortType=PORT_UNIQUE;
    pOutSA->IpsecQMFilter.SrcPort.wPort=NET_SHORT(SA_SRC_PORT(pInSA));

    pOutSA->IpsecQMFilter.DesPort.PortType=PORT_UNIQUE;
    pOutSA->IpsecQMFilter.DesPort.wPort=NET_SHORT(SA_DEST_PORT(pInSA));

    if (pInSA->sa_Flags & FLAGS_SA_TUNNEL) {
        pOutSA->IpsecQMFilter.QMFilterType = QM_TUNNEL_FILTER;
        ConvertAddr(pInSA->sa_SrcTunnelAddr,0xffffffff,&pOutSA->IpsecQMFilter.MyTunnelEndpt);
        ConvertAddr(pInSA->sa_TunnelAddr,0xffffffff,&pOutSA->IpsecQMFilter.PeerTunnelEndpt);
        
    } else {
        pOutSA->IpsecQMFilter.QMFilterType = QM_TRANSPORT_FILTER;
    }

    pOutSA->SelectedQMOffer.dwPFSGroup=pInSA->sa_QMPFSGroup;
    pOutSA->SelectedQMOffer.dwReserved = 0;
    if (pOutSA->SelectedQMOffer.dwPFSGroup) {
        pOutSA->SelectedQMOffer.bPFSRequired=TRUE;
    }
    pOutSA->SelectedQMOffer.Lifetime.uKeyExpirationTime=pInSA->sa_Lifetime.KeyExpirationTime;
    pOutSA->SelectedQMOffer.Lifetime.uKeyExpirationKBytes=pInSA->sa_Lifetime.KeyExpirationBytes;
    
    pOutSA->SelectedQMOffer.dwNumAlgos=pInSA->sa_NumOps;

    for (i=0; i < pInSA->sa_NumOps;i++) {
        pOutSA->SelectedQMOffer.Algos[i].Operation=pInSA->sa_Operation[i];
        if (pInSA->sa_AssociatedSA) {            
            pOutSA->SelectedQMOffer.Algos[i].MySpi= pInSA->sa_AssociatedSA->sa_OtherSPIs[i];
        }        
        pOutSA->SelectedQMOffer.Algos[i].PeerSpi= pInSA->sa_OtherSPIs[i];
        
        switch(pOutSA->SelectedQMOffer.Algos[i].Operation) {
        case AUTHENTICATION:            
            pOutSA->SelectedQMOffer.Algos[i].uAlgoIdentifier=pInSA->INT_ALGO(i);            
            pOutSA->SelectedQMOffer.Algos[i].uAlgoKeyLen=pInSA->INT_KEYLEN(i);
            pOutSA->SelectedQMOffer.Algos[i].uAlgoRounds=pInSA->INT_ROUNDS(i);

            pOutSA->SelectedQMOffer.Algos[i].uSecAlgoIdentifier=0;

            pOutSA->SelectedQMOffer.Algos[i].uSecAlgoKeyLen=0;
            pOutSA->SelectedQMOffer.Algos[i].uSecAlgoRounds=0;
            break;
        case ENCRYPTION:
            pOutSA->SelectedQMOffer.Algos[i].uAlgoIdentifier=pInSA->CONF_ALGO(i);            
            pOutSA->SelectedQMOffer.Algos[i].uAlgoKeyLen=pInSA->CONF_KEYLEN(i);
            pOutSA->SelectedQMOffer.Algos[i].uAlgoRounds=pInSA->CONF_ROUNDS(i);

            pOutSA->SelectedQMOffer.Algos[i].uSecAlgoIdentifier=pInSA->INT_ALGO(i);            
            pOutSA->SelectedQMOffer.Algos[i].uSecAlgoKeyLen=pInSA->INT_KEYLEN(i);
            pOutSA->SelectedQMOffer.Algos[i].uSecAlgoRounds=pInSA->INT_ROUNDS(i);
            break;
        default:
            break;
        }
    }

    ConvertEncapInfo(pInSA,
                     &pOutSA->EncapInfo);

    return STATUS_SUCCESS;

}

BOOLEAN
IPSecMatchSATemplate(
    IN  PSA_TABLE_ENTRY pSA,
    IN  PIPSEC_QM_SA    pSATemplate
    )
/*++

Routine Description:

    Try to see if the SA passed in matches the template.

Arguments:

    pSA         - SA of interest
    pSATemplate - SA template

Return Value:

    TRUE/FALSE

--*/
{
    LARGE_INTEGER   ZeroLI = {0};
    ADDR            ZeroADDR = {0};
    PROTOCOL        ZeroPROTOCOL = {0};
    PORT            ZeroPORT = {0};

    IPSEC_QM_SA CurSA;
    memset(&CurSA,0,sizeof(IPSEC_QM_SA));
    
    ConvertSAToIPSecQMSA(&CurSA,pSA);
    
    return((BOOLEAN)MatchQMSATemplate(pSATemplate,&CurSA));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipsec\sys\timer.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Contains timer management structures.

Author:

    Sanjay Anand (SanjayAn) 26-May-1997
    ChunYe

Environment:

    Kernel mode

Revision History:

--*/


#include "precomp.h"

#ifdef RUN_WPP
#include "timer.tmh"
#endif

#pragma hdrstop


BOOLEAN
IPSecInitTimer()
/*++

Routine Description:

    Initialize the timer structures.

Arguments:

    None

Return Value:

    None

--*/
{
    PIPSEC_TIMER_LIST   pTimerList;
    LONG                i;

    INIT_LOCK(&g_ipsec.TimerLock);

    //
    // Allocate timer structures
    //
    for (i = 0; i < IPSEC_CLASS_MAX; i++) {
        pTimerList = &(g_ipsec.TimerList[i]);
#if DBG
        pTimerList->atl_sig = atl_signature;
#endif

        pTimerList->pTimers = IPSecAllocateMemory(
                                sizeof(IPSEC_TIMER) * IPSecTimerListSize[i],
                                IPSEC_TAG_TIMER);

        if (pTimerList->pTimers == NULL_PIPSEC_TIMER) {
            while (--i >= 0) {
                pTimerList = &(g_ipsec.TimerList[i]);
                IPSecFreeMemory(pTimerList->pTimers);
            }

            return FALSE;
        }
    }

    //
    // Initialize timer wheels.
    //
    for (i = 0; i < IPSEC_CLASS_MAX; i++) {
        pTimerList = &(g_ipsec.TimerList[i]);

        IPSecZeroMemory(pTimerList->pTimers,
                        sizeof(IPSEC_TIMER) * IPSecTimerListSize[i]);

        pTimerList->MaxTimer = IPSecMaxTimerValue[i];
        pTimerList->TimerPeriod = IPSecTimerPeriod[i];
        pTimerList->TimerListSize = IPSecTimerListSize[i];

        IPSEC_INIT_SYSTEM_TIMER(
                    &(pTimerList->NdisTimer),
                    IPSecTickHandler,
                    (PVOID)pTimerList);
    }

    return TRUE;
}


VOID
IPSecStartTimer(
    IN  PIPSEC_TIMER            pTimer,
    IN  IPSEC_TIMEOUT_HANDLER   TimeoutHandler,
    IN  ULONG                   SecondsToGo,
    IN  PVOID                   Context
    )
/*++

Routine Description:

    Start an IPSEC timer. Based on the length (SecondsToGo) of the
    timer, we decide on whether to insert it in the short duration
    timer list or in the long duration timer list in the Interface
    structure.

    NOTE: the caller is assumed to either hold a lock to the structure
    that contains the timer, or ensure that it is safe to access the
    timer structure.

Arguments:

    pTimer          - Pointer to IPSEC Timer structure
    TimeoutHandler  - Handler function to be called if this timer expires
    SecondsToGo     - When does this timer go off?
    Context         - To be passed to timeout handler if this timer expires

Return Value:

    None

--*/
{
    PIPSEC_TIMER_LIST   pTimerList;         // List to which this timer goes
    PIPSEC_TIMER        pTimerListHead;     // Head of above list
    ULONG               Index;              // Into timer wheel
    ULONG               TicksToGo = 1;
    KIRQL               kIrql;
    INT                 i;

    IPSEC_DEBUG(LL_A, DBF_TIMER,
                ("StartTimer: Secs %d, Handler %p, Ctxt %p, pTimer %p",
                SecondsToGo, TimeoutHandler, Context, pTimer));

    if (IPSEC_IS_TIMER_ACTIVE(pTimer)) {
        IPSEC_DEBUG(LL_A, DBF_TIMER,
                    ("Start timer: pTimer %p: is active (list %p, hnd %p), stopping it",
                    pTimer, pTimer->pTimerList, pTimer->TimeoutHandler));

        if (!IPSecStopTimer(pTimer)) {
            IPSEC_DEBUG(LL_A, DBF_TIMER, ("Couldnt stop prev timer - bail"));
            return;
        }
    }

    ACQUIRE_LOCK(&g_ipsec.TimerLock, &kIrql);

    ASSERT(!IPSEC_IS_TIMER_ACTIVE(pTimer));

    //
    // Find the list to which this timer should go, and the
    // offset (TicksToGo)
    //
    for (i = 0; i < IPSEC_CLASS_MAX; i++) {
        pTimerList = &(g_ipsec.TimerList[i]);
        if (SecondsToGo < pTimerList->MaxTimer) {
            //
            // Found it.
            //
            TicksToGo = SecondsToGo / (pTimerList->TimerPeriod);
            break;
        }
    }
    
    //
    // Find the position in the list for this timer
    //
    Index = pTimerList->CurrentTick + TicksToGo;
    if (Index >= pTimerList->TimerListSize) {
        Index -= pTimerList->TimerListSize;
    }

    ASSERT(Index < pTimerList->TimerListSize);

    pTimerListHead = &(pTimerList->pTimers[Index]);

    //
    // Fill in the timer
    //
    pTimer->pTimerList = pTimerList;
    pTimer->LastRefreshTime = pTimerList->CurrentTick;
    pTimer->Duration = TicksToGo;
    pTimer->TimeoutHandler = TimeoutHandler;
    pTimer->Context = Context;

    //
    // Insert this timer in the "ticking" list
    //
    pTimer->pPrevTimer = pTimerListHead;
    pTimer->pNextTimer = pTimerListHead->pNextTimer;
    if (pTimer->pNextTimer != NULL_PIPSEC_TIMER) {
        pTimer->pNextTimer->pPrevTimer = pTimer;
    }

    pTimerListHead->pNextTimer = pTimer;

    //
    // Start off the system tick timer if necessary.
    //
    pTimerList->TimerCount++;
    if (pTimerList->TimerCount == 1) {
        IPSEC_DEBUG(LL_A, DBF_TIMER,
                    ("StartTimer: Starting system timer %p, class %d",
                    &(pTimerList->NdisTimer), i));

        IPSEC_START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
    }

    RELEASE_LOCK(&g_ipsec.TimerLock, kIrql);

    //
    // We're done
    //
    IPSEC_DEBUG(LL_A, DBF_TIMER,
                ("Started timer %p, Secs %d, Index %d, Head %p",
                pTimer,                
                SecondsToGo,
                Index,
                pTimerListHead));

    IPSEC_INCREMENT(g_ipsec.NumTimers);

    return;
}


BOOLEAN
IPSecStopTimer(
    IN  PIPSEC_TIMER    pTimer
    )
/*++

Routine Description:

    Stop an IPSEC timer, if it is running. We remove this timer from
    the active timer list and mark it so that we know it's not running.

    NOTE: the caller is assumed to either hold a lock to the structure
    that contains the timer, or ensure that it is safe to access the
    timer structure.

    SIDE EFFECT: If we happen to stop the last timer (of this "duration") on
    the Interface, we also stop the appropriate Tick function.

Arguments:

    pTimer  - Pointer to IPSEC Timer structure

Return Value:

    TRUE if the timer was running, FALSE otherwise.

--*/
{
    PIPSEC_TIMER_LIST   pTimerList; // Timer List to which this timer belongs
    BOOLEAN             WasRunning;
    KIRQL               kIrql;

    IPSEC_DEBUG(LL_A, DBF_TIMER,
                ("Stopping Timer %p, List %p, Prev %p, Next %p",
                pTimer,
                pTimer->pTimerList,
                pTimer->pPrevTimer,
                pTimer->pNextTimer));

    ACQUIRE_LOCK(&g_ipsec.TimerLock, &kIrql);

    if (IPSEC_IS_TIMER_ACTIVE(pTimer)) {
        WasRunning = TRUE;

        //
        // Unlink timer from the list
        //
        ASSERT(pTimer->pPrevTimer); // the list head always exists

        if (pTimer->pPrevTimer) {
            pTimer->pPrevTimer->pNextTimer = pTimer->pNextTimer;
        }

        if (pTimer->pNextTimer) {
            pTimer->pNextTimer->pPrevTimer = pTimer->pPrevTimer;
        }

        pTimer->pNextTimer = pTimer->pPrevTimer = NULL_PIPSEC_TIMER;

        //
        // Update timer count on Interface, for this class of timers
        //
        pTimerList = pTimer->pTimerList;
        pTimerList->TimerCount--;

        //
        // If all timers of this class are gone, stop the system tick timer
        // for this class
        //
        if (pTimerList->TimerCount == 0) {
            IPSEC_DEBUG(LL_A, DBF_TIMER, ("Stopping system timer %p, List %p",
                        &(pTimerList->NdisTimer),
                        pTimerList));

            pTimerList->CurrentTick = 0;
            IPSEC_STOP_SYSTEM_TIMER(&(pTimerList->NdisTimer));
        }

        //
        // Mark stopped timer as not active
        //
        pTimer->pTimerList = (PIPSEC_TIMER_LIST)NULL;

        IPSEC_DECREMENT(g_ipsec.NumTimers);
    } else {
        WasRunning = FALSE;
    }

    RELEASE_LOCK(&g_ipsec.TimerLock, kIrql);

    return  WasRunning;
}


VOID
IPSecTickHandler(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   Context,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    )
/*++

Routine Description:

    This is the handler we register with the system for processing each
    Timer List. This is called every "tick" seconds, where "tick" is
    determined by the granularity of the timer type.

Arguments:

    Context             - Actually a pointer to a Timer List structure
    SystemSpecific[1-3] - Not used

Return Value:

    None

--*/
{
    PIPSEC_TIMER_LIST   pTimerList;
    PIPSEC_TIMER        pExpiredTimer;      // Start of list of expired timers
    PIPSEC_TIMER        pNextTimer;         // for walking above list
    PIPSEC_TIMER        pTimer;             // temp, for walking timer list
    PIPSEC_TIMER        pPrevExpiredTimer;  // for creating expired timer list
    ULONG               Index;              // into the timer wheel
    ULONG               NewIndex;           // for refreshed timers
    KIRQL               kIrql;

    pTimerList = (PIPSEC_TIMER_LIST)Context;

    IPSEC_DEBUG(LL_A, DBF_TIMER, ("Tick: List %p, Count %d",
                pTimerList, pTimerList->TimerCount));

    pExpiredTimer = NULL_PIPSEC_TIMER;

    ACQUIRE_LOCK(&g_ipsec.TimerLock, &kIrql);

    if (TRUE) {
        //
        // Pick up the list of timers scheduled to have expired at the
        // current tick. Some of these might have been refreshed.
        //
        Index = pTimerList->CurrentTick;
        pExpiredTimer = (pTimerList->pTimers[Index]).pNextTimer;
        (pTimerList->pTimers[Index]).pNextTimer = NULL_PIPSEC_TIMER;

        //
        // Go through the list of timers scheduled to expire at this tick.
        // Prepare a list of expired timers, using the pNextExpiredTimer
        // link to chain them together.
        //
        // Some timers may have been refreshed, in which case we reinsert
        // them in the active timer list.
        //
        pPrevExpiredTimer = NULL_PIPSEC_TIMER;

        for (pTimer = pExpiredTimer;
             pTimer != NULL_PIPSEC_TIMER;
             pTimer = pNextTimer) {
            //
            // Save a pointer to the next timer, for the next iteration.
            //
            pNextTimer = pTimer->pNextTimer;

            IPSEC_DEBUG(LL_A, DBF_TIMER,
                        ("Tick Handler: looking at timer %p, next %p",
                        pTimer, pNextTimer));

            //
            // Find out when this timer should actually expire.
            //
            NewIndex = pTimer->LastRefreshTime + pTimer->Duration;
            if (NewIndex >= pTimerList->TimerListSize) {
                NewIndex -= pTimerList->TimerListSize;
            }

            //
            // Check if we are currently at the point of expiry.
            //
            if (NewIndex != Index) {
                //
                // This timer still has some way to go, so put it back.
                //
                IPSEC_DEBUG(LL_A, DBF_TIMER,
                            ("Tick: Reinserting Timer %p: Hnd %p, Durn %d, Ind %d, NewInd %d",
                            pTimer, pTimer->TimeoutHandler, pTimer->Duration, Index, NewIndex));

                //
                // Remove it from the expired timer list. Note that we only
                // need to update the forward (pNextExpiredTimer) links.
                //
                if (pPrevExpiredTimer == NULL_PIPSEC_TIMER) {
                    pExpiredTimer = pNextTimer;
                } else {
                    pPrevExpiredTimer->pNextExpiredTimer = pNextTimer;
                }

                //
                // And insert it back into the running timer list.
                //
                pTimer->pNextTimer = (pTimerList->pTimers[NewIndex]).pNextTimer;
                if (pTimer->pNextTimer != NULL_PIPSEC_TIMER) {
                    pTimer->pNextTimer->pPrevTimer = pTimer;
                }

                pTimer->pPrevTimer = &(pTimerList->pTimers[NewIndex]);
                (pTimerList->pTimers[NewIndex]).pNextTimer = pTimer;
            } else {
                //
                // This one has expired. Keep it in the expired timer list.
                //
                pTimer->pNextExpiredTimer = pNextTimer;
                if (pPrevExpiredTimer == NULL_PIPSEC_TIMER) {
                    pExpiredTimer = pTimer;
                }
                pPrevExpiredTimer = pTimer;

                //
                // Mark it as inactive.
                //
                ASSERT(pTimer->pTimerList == pTimerList);
                pTimer->pTimerList = (PIPSEC_TIMER_LIST)NULL;

                //
                // Update the active timer count.
                //
                pTimerList->TimerCount--;
            }
        }

        //
        // Update current tick index in readiness for the next tick.
        //
        if (++Index == pTimerList->TimerListSize) {
            pTimerList->CurrentTick = 0;
        } else {
            pTimerList->CurrentTick = Index;
        }

        if (pTimerList->TimerCount > 0) {
            //
            // Re-arm the tick handler
            //
            IPSEC_DEBUG(LL_A, DBF_TIMER, ("Tick[%d]: Starting system timer %p",
                        pTimerList->CurrentTick, &(pTimerList->NdisTimer)));
            
            IPSEC_START_SYSTEM_TIMER(&(pTimerList->NdisTimer), pTimerList->TimerPeriod);
        } else {
            pTimerList->CurrentTick = 0;
        }

    }

    RELEASE_LOCK(&g_ipsec.TimerLock, kIrql);

    //
    // Now pExpiredTimer is a list of expired timers.
    // Walk through the list and call the timeout handlers
    // for each timer.
    //
    while (pExpiredTimer != NULL_PIPSEC_TIMER) {
        pNextTimer = pExpiredTimer->pNextExpiredTimer;

        IPSEC_DEBUG(LL_A, DBF_TIMER,
                    ("Expired timer %p: handler %p, next %p",
                    pExpiredTimer, pExpiredTimer->TimeoutHandler, pNextTimer));

        (*(pExpiredTimer->TimeoutHandler))( pExpiredTimer,
                                            pExpiredTimer->Context);

        IPSEC_DECREMENT(g_ipsec.NumTimers);

        pExpiredTimer = pNextTimer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\arpdef.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//***   arpdef.h - ARP definitions
//
//  This file containes all of the private ARP related definitions.


#define MEDIA_DIX       0
#define MEDIA_TR        1
#define MEDIA_FDDI      2
#define MEDIA_ARCNET    3
#define MAX_MEDIA       4

typedef enum _INTERFACE_STATE {
    INTERFACE_UP     = 0,                   // Interface is up.
    INTERFACE_INIT   = 1,                   // Interface is initializing.
    INTERFACE_DOWN   = 2,                   // Interface is down.
    INTERFACE_UNINIT = 3                    // Interface is going away.
} INTERFACE_STATE, *PINTERFACE_STATE;

#define LOOKAHEAD_SIZE  128                 // A reasonable lookahead size

// Definitions for state of an ATE. The 'RESOLVING' indicators must occur first.
#define ARP_RESOLVING_LOCAL     0           // Address is being resolved (on local ring, if TR)
#define ARP_RESOLVING_GLOBAL    1           // Address is being resolved globally.
#define ARP_RESOLVING ARP_RESOLVING_GLOBAL
#define ARP_GOOD            2               // ATE is good.
#define ARP_BAD             3               // ATE is bad.
#define ARP_FLOOD_RATE      1000L           // No more than once a second.
#define ARP_802_ADDR_LENGTH 6               // Length of an 802 address.

#define MIN_ETYPE           0x600           // Minimum valid Ethertype
#define SNAP_SAP            170
#define SNAP_UI             3


//* Structure of an Ethernet header.
typedef struct ENetHeader {
    uchar       eh_daddr[ARP_802_ADDR_LENGTH];
    uchar       eh_saddr[ARP_802_ADDR_LENGTH];
    ushort      eh_type;
} ENetHeader;

//* Structure of a token ring header.
typedef struct TRHeader {
    uchar       tr_ac;
    uchar       tr_fc;
    uchar       tr_daddr[ARP_802_ADDR_LENGTH];
    uchar       tr_saddr[ARP_802_ADDR_LENGTH];
} TRHeader;

#define ARP_AC      0x10
#define ARP_FC      0x40
#define TR_RII      0x80

typedef struct RC {
    uchar   rc_blen;                    // Broadcast indicator and length.
    uchar   rc_dlf;                     // Direction and largest frame.
} RC;
#define RC_DIR      0x80
#define RC_LENMASK  0x1f
#define RC_SRBCST   0xc2                    // Single route broadcast RC.
#define RC_ARBCST   0x82                    // All route broadcast RC.
#define RC_LMASK    0x1F                    // Mask for length field for route
                                            // information
#define RC_LEN      0x2                     // Length to put in the length bits
                                            // when sending source routed
                                            // frames
#define RC_BCST_LEN 0x70                    // Length for a broadcast.
#define RC_LF_MASK  0x70                    // Mask for length bits.

//* Structure of source routing information.
typedef struct SRInfo {
    RC      sri_rc;                         // Routing control info.
    ushort  sri_rd[1];                      // Routing designators.
} SRInfo;

#define ARP_MAX_RD      8

//* Structure of an FDDI header.
typedef struct FDDIHeader {
    uchar       fh_pri;
    uchar       fh_daddr[ARP_802_ADDR_LENGTH];
    uchar       fh_saddr[ARP_802_ADDR_LENGTH];
} FDDIHeader;

#define ARP_FDDI_PRI    0x57
#define ARP_FDDI_MSS    4352

//* Structure of an ARCNET header.
typedef struct ARCNetHeader {
    uchar       ah_saddr;
    uchar       ah_daddr;
    uchar       ah_prot;
} ARCNetHeader;

//* Structure of a SNAP header.
typedef struct SNAPHeader {
    uchar       sh_dsap;
    uchar       sh_ssap;
    uchar       sh_ctl;
    uchar       sh_protid[3];
    ushort      sh_etype;
} SNAPHeader;

#define ARP_MAX_MEDIA_ENET  sizeof(ENetHeader)
#define ARP_MAX_MEDIA_TR    (sizeof(TRHeader)+sizeof(RC)+(ARP_MAX_RD*sizeof(ushort))+sizeof(SNAPHeader))
#define ARP_MAX_MEDIA_FDDI  (sizeof(FDDIHeader)+sizeof(SNAPHeader))
#define ARP_MAX_MEDIA_ARC   sizeof(ARCNetHeader)

#define ENET_BCAST_MASK     0x01
#define TR_BCAST_MASK       0x80
#define FDDI_BCAST_MASK     0x01
#define ARC_BCAST_MASK      0xff

#define ENET_BCAST_VAL      0x01
#define TR_BCAST_VAL        0x80
#define FDDI_BCAST_VAL      0x01
#define ARC_BCAST_VAL       0x00

#define ENET_BCAST_OFF      0x00
#define TR_BCAST_OFF        offsetof(struct TRHeader, tr_daddr)
#define FDDI_BCAST_OFF      offsetof(struct FDDIHeader, fh_daddr)
#define ARC_BCAST_OFF       offsetof(struct ARCNetHeader, ah_daddr)

typedef void (*ArpRtn)(void *, IP_STATUS Status);

typedef struct ARPControlBlock {
   struct ARPControlBlock  *next;
   ArpRtn CompletionRtn;
   ulong status;
   ulong  PhyAddrLen;
   ulong *PhyAddr;

} ARPControlBlock;


//* Structure of an ARP table entry.
typedef struct ARPTableEntry {
    struct ARPTableEntry    *ate_next;      // Next ATE in hash chain
    ulong                   ate_valid;      // Last time ATE was known to be valid.
    IPAddr                  ate_dest;       // IP address represented.
    PNDIS_PACKET            ate_packet;     // Packet (if any) queued for resolution
    RouteCacheEntry         *ate_rce;       // List of RCEs that reference this ATE.
    DEFINE_LOCK_STRUCTURE(ate_lock)         // Lock for this ATE.
    uint                    ate_useticks;   // Number of ticks left until this
                                            // goes away.
    uchar                   ate_addrlength; // Length of the address.
    uchar                   ate_state;      // State of this entry
    ulong                   ate_userarp;    // added to facilitate user api ARP reauests
    ARPControlBlock         *ate_resolveonly;// This field points ARP control block(s)
    uint                    ate_refresh;     //refresh arp entries before timeingout
    uchar                   ate_addr[1];    // Address that maps to dest
} ARPTableEntry;

#define ALWAYS_VALID        0xffffffff

//* Structure of the ARP table.
#define ARP_TABLE_SIZE      64
#define ARP_HASH(x)         ((((uchar *)&(x))[3] + ((uchar *)&(x))[2] + ((uchar *)&(x))[1] + ((uchar *)&(x))[0]) % ARP_TABLE_SIZE)

typedef ARPTableEntry   *ARPTable[];

//* List structure for local representation of an IPAddress.
typedef struct ARPIPAddr {
    struct ARPIPAddr        *aia_next;      // Next in list.
    uint                    aia_age;
    IPAddr                  aia_addr;       // The address.
    IPMask                  aia_mask;
    void                    *aia_context;
} ARPIPAddr;

#define ARPADDR_MARKER      5
#define ARPADDR_NOT_LOCAL   4
#define ARPADDR_NEW_LOCAL   3
#define ARPADDR_OLD_LOCAL   0

//* List structure for Proxy-ARP addresses.
typedef struct ARPPArpAddr {
    struct ARPPArpAddr      *apa_next;      // Next in list.
    IPAddr                  apa_addr;       // The address.
    IPMask                  apa_mask;       // And the mask.
} ARPPArpAddr;

//* List structure for a multicast IP address.
typedef struct ARPMCastAddr {
    struct ARPMCastAddr     *ama_next;      // Next in list.
    IPAddr                  ama_addr;       // The (masked) address.
    uint                    ama_refcnt;     // Reference count for this address.
} ARPMCastAddr;

#define ARP_MCAST_MASK      0xffff7f00

#define ARP_TIMER_TIME          1000L
#define ARP_RESOLVE_TIMEOUT     1000L
#define ARP_MIN_VALID_TIMEOUT   600000L
#define ARP_REFRESH_TIME        2000L

#if FFP_SUPPORT
#define FFP_ARP_FLUSH_INTERVAL  300 // Time (in s) after which ARP forces an FFP
                                    // flush (inorder to keep the ARP cache and
                                    // FFP's MAC Addr mapping in limited sync)
#endif

typedef struct ARPNotifyStruct {
    CTEEvent                ans_event;
    uint                    ans_shutoff;
    IPAddr                  ans_addr;
    uint                    ans_hwaddrlen;
    uchar                   ans_hwaddr[1];
} ARPNotifyStruct;

typedef struct CACHE_ALIGN _PerProcArpInterfaceCounters {
     uint                    ai_qlen;
} PP_AI_COUNTERS, *PPP_AI_COUNTERS;

//* Structure of information we keep on a per-interface basis.
typedef struct ARPInterface {
    LIST_ENTRY              ai_linkage;     // to link into ARP interface list
    void                    *ai_context;    // Upper layer context info.
#if FFP_SUPPORT
    NDIS_HANDLE             ai_driver;      // NDIS Miniport/MAC driver handle
#endif
    NDIS_HANDLE             ai_handle;      // NDIS bind handle.
    NDIS_MEDIUM             ai_media;       // Media type.
    NDIS_HANDLE             ai_ppool;       // Handle for packet pool.
    DEFINE_LOCK_STRUCTURE(ai_lock)          // Lock for this structure.
    DEFINE_LOCK_STRUCTURE(ai_ARPTblLock)    // ARP Table lock for this structure.
    ARPTable                *ai_ARPTbl;     // Pointer to the ARP table for this interface
    ARPIPAddr               ai_ipaddr;      // Local IP address list.
    ARPPArpAddr             *ai_parpaddr;   // Proxy ARP address list.
    IPAddr                  ai_bcast;       // Broadcast mask for this interface.
    // SNMP required counters
    uint                    ai_inoctets;    // Input octets.
    uint                    ai_inpcount[3]; // Count of nonunicast, unicast & promiscuous
                                            // packets received.
    uint                    ai_outoctets;   // Output octets
    uint                    ai_outpcount[2];// Count of nonunicast and unicast
                                            // packets sent.
    PPP_AI_COUNTERS         ai_qlen;        // Output Queue Length
    uchar                   ai_addr[ARP_802_ADDR_LENGTH]; // Local HW address.
    uchar                   ai_operstatus;  // State of the interface. Union of
                                            // admin and media sense states.
    uchar                   ai_addrlen;     // Length of ai_addr.
    uchar                   ai_bcastmask;   // Mask for checking unicast.
    uchar                   ai_bcastval;    // Value to check against.
    uchar                   ai_bcastoff;    // Offset in frame to check against.
    uchar                   ai_hdrsize;     // Size of 'typical' header.
    uchar                   ai_snapsize;    // Size of snap header, if any.
    uchar                   ai_pad[2];      // PAD PAD
    uint                    ai_pfilter;     // Packet filter for this i/f.
    uint                    ai_count;       // Number of entries in the ARPTable.
    uint                    ai_parpcount;   // Number of proxy ARP entries.
    CTETimer                ai_timer;       // ARP timer for this interface.

    BOOLEAN                 ai_timerstarted;// ARP timer started for this interface?
    BOOLEAN                 ai_stoptimer;   // ARP timer started for this interface?
    CTEBlockStruc           ai_timerblock;  // used to sync stopping the interface timer

    CTEBlockStruc           ai_block;       // Structure for blocking on.
    ushort                  ai_mtu;         // MTU for this interface.
    uchar                   ai_adminstate;  // Admin state.
    uchar                   ai_mediastatus; // Media sense state.
    uint                    ai_speed;       // Speed.
    uint                    ai_lastchange;  // Last change time.
    uint                    ai_indiscards;  // In discards.
    uint                    ai_inerrors;    // Input errors.
    uint                    ai_uknprotos;   // Unknown protocols received.
    uint                    ai_outdiscards; // Output packets discarded.
    uint                    ai_outerrors;   // Output errors.
    uint                    ai_desclen;     // Length of desc. string.
    uint                    ai_index;       // Global I/F index ID.
    uint                    ai_atinst;      // AT instance number.
    uint                    ai_ifinst;      // IF instance number.
    char                    *ai_desc;       // Descriptor string.
    ARPMCastAddr            *ai_mcast;      // Multicast list.
    uint                    ai_mcastcnt;    // Count of elements on mcast list.
    uint                    ai_ipaddrcnt;   // number of local address on this
    uint                    ai_telladdrchng;// tell link layer about addr change? (for psched)
    ULONG                   ai_mediatype;
    uint                    ai_promiscuous; // promiscuous mode or not.
#if FFP_SUPPORT
    ulong                   ai_ffpversion;  // The version of FFP in use (0 implies no support)
    uint                    ai_ffplastflush;// Number of timer ticks since arp's last FFP flush
#endif
    ARPNotifyStruct         *ai_conflict;
    uint                    ai_delay;
    uint                    ai_OffloadFlags;// IP offload capabilities
    uint                    ai_IPSecOffloadFlags;// IPSec offload capabilities
    NDIS_TASK_TCP_LARGE_SEND ai_TcpLargeSend;
    NDIS_PNP_CAPABILITIES   ai_wakeupcap;   // wakeup capabilities.
    NDIS_STRING             ai_devicename;  // Name of the device.
} ARPInterface;


//* NOTE: These two values MUST stay at 0 and 1.
#define AI_UCAST_INDEX      0
#define AI_NONUCAST_INDEX   1
#define AI_PROMIS_INDEX     2

#define ARP_DEFAULT_PACKETS 10

//* Structure of information passed as context in RCE.
typedef struct ARPContext {
    RouteCacheEntry     *ac_next;       // Next RCE in ARP table chain.
    ARPTableEntry       *ac_ate;        // Back pointer to ARP table entry.
} ARPContext;

typedef struct IPNMEContext {
    uint                inc_index;
    ARPTableEntry       *inc_entry;
} IPNMEContext;

#include <packon.h>
// Structure of an ARP header.
typedef struct ARPHeader {
    ushort      ah_hw;                      // Hardware address space.
    ushort      ah_pro;                     // Protocol address space.
    uchar       ah_hlen;                    // Hardware address length.
    uchar       ah_plen;                    // Protocol address length.
    ushort      ah_opcode;                  // Opcode.
    uchar       ah_shaddr[ARP_802_ADDR_LENGTH]; // Source HW address.
    IPAddr      ah_spaddr;                  // Source protocol address.
    uchar       ah_dhaddr[ARP_802_ADDR_LENGTH]; // Destination HW address.
    IPAddr      ah_dpaddr;                  // Destination protocol address.
} ARPHeader;
#include <packoff.h>

#define ARP_ETYPE_IP    0x800
#define ARP_ETYPE_ARP   0x806
#define ARP_REQUEST     1
#define ARP_RESPONSE    2
#define ARP_HW_ENET     1
#define ARP_HW_802      6
#define ARP_HW_ARCNET   7

#define ARP_ARCPROT_ARP 0xd5
#define ARP_ARCPROT_IP  0xd4

// The size we need to back off the buffer length because ARCNet address
// are one bytes instead of six.
#define ARCNET_ARPHEADER_ADJUSTMENT     10

typedef struct _AddAddrNotifyEvent {
    CTEEvent        Event;
    SetAddrControl  *SAC;
    IPAddr          Address;
    IP_STATUS       Status;
} AddAddrNotifyEvent;


// Compute the length of the wakeup pattern mask based on the length
// of the pattern. See NET_PM_WAKEUP_PATTERN_DESC.
//
__inline
UINT
GetWakeupPatternMaskLength(
    IN UINT Ptrnlen)
{
    return (Ptrnlen - 1)/8 + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\debug.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Debug functions

Revision History:

    AmritanR

--*/

#include "precomp.h"

#define __FILE_SIG__    DEBUG_SIG

#include "ipmcast.h"

#define PRINT_BYTES(x) (UCHAR)x,(UCHAR)(x>>8),(UCHAR)(x>>16),(UCHAR)(x>>24)

#if RT_LOCK_DEBUG

KSPIN_LOCK g_kslLockLock;

#endif

#if RT_MEM_DEBUG

RT_LOCK g_rlMemoryLock;
LIST_ENTRY g_leAllocMemListHead;
LIST_ENTRY g_leFreeMemListHead;

#endif

VOID
RtInitializeDebug()
{

#if RT_TRACE_DEBUG

    g_byDebugLevel = RT_DBG_LEVEL_WARN;
    //g_byDebugLevel  = 0x00;
    g_fDebugComp = 0xFFFFFFFF;

#endif

#if RT_LOCK_DEBUG

    KeInitializeSpinLock(&(g_kslLockLock));

#endif

#if RT_MEM_DEBUG

    RtInitializeSpinLock(&g_rlMemoryLock);

    InitializeListHead(&g_leAllocMemListHead);
    InitializeListHead(&g_leFreeMemListHead);

#endif

}

#if RT_LOCK_DEBUG

VOID
RtpInitializeSpinLock(
                      IN PRT_LOCK pLock,
                      IN ULONG ulFileSig,
                      IN ULONG ulLineNumber
                      )
{
    UNREFERENCED_PARAMETER(ulFileSig);
    UNREFERENCED_PARAMETER(ulLineNumber);
    
    pLock->ulLockSig = RT_LOCK_SIG;
    pLock->ulFileSig = 0;
    pLock->ulLineNumber = 0;
    pLock->bAcquired = 0;
    pLock->pktLastThread = (PKTHREAD) NULL;

    KeInitializeSpinLock(&(pLock->kslLock));
}

VOID
RtpAcquireSpinLock(
                   IN PRT_LOCK pLock,
                   OUT PKIRQL pkiIrql,
                   IN ULONG ulFileSig,
                   IN ULONG ulLineNumber,
                   IN BOOLEAN bAtDpc
                   )
{
    PKTHREAD pThread;
    KIRQL kiInternalIrql;

    pThread = KeGetCurrentThread();

    if (bAtDpc) {
        kiInternalIrql = KeGetCurrentIrql();

        if (kiInternalIrql isnot DISPATCH_LEVEL) {
            DbgPrint("RTDBG: Called AcquireSpinLockAtDpc for lock at 0x%x when not at DISPATCH. File %c%c%c%c, Line %d\n",
                     pLock,
                     PRINT_BYTES(ulFileSig),
                     ulLineNumber);

            DbgBreakPoint();
        }
    }
    KeAcquireSpinLock(&(g_kslLockLock),
                      &kiInternalIrql);

    if (pLock->ulLockSig isnot RT_LOCK_SIG) {
        DbgPrint("RTDBG: Trying to acquire uninited lock 0x%x, File %c%c%c%c, Line %d\n",
                 pLock,
                 (CHAR) (ulFileSig & 0xff),
                 (CHAR) ((ulFileSig >> 8) & 0xff),
                 (CHAR) ((ulFileSig >> 16) & 0xff),
                 (CHAR) ((ulFileSig >> 24) & 0xff),
                 ulLineNumber);

        DbgBreakPoint();
    }
    if (pLock->bAcquired isnot 0) {
        if (pLock->pktLastThread is pThread) {
            DbgPrint("RTDBG: Detected recursive locking!: pLock 0x%x, File %c%c%c%c, Line %d\n",
                     pLock,
                     PRINT_BYTES(ulFileSig),
                     ulLineNumber);

            DbgPrint("RTDBG: pLock 0x%x already acquired in File %c%c%c%c, Line %d\n",
                     pLock,
                     PRINT_BYTES(pLock->ulFileSig),
                     pLock->ulLineNumber);

            DbgBreakPoint();
        }
    }
    KeReleaseSpinLock(&(g_kslLockLock),
                      kiInternalIrql);

    if (bAtDpc) {
        KeAcquireSpinLockAtDpcLevel(&(pLock->kslLock));
    } else {
        KeAcquireSpinLock(&(pLock->kslLock),
                          pkiIrql);
    }

    //
    //  Mark this lock.
    //

    pLock->pktLastThread = pThread;
    pLock->ulFileSig = ulFileSig;
    pLock->ulLineNumber = ulLineNumber;
    pLock->bAcquired = TRUE;
}

VOID
RtpReleaseSpinLock(
                   IN PRT_LOCK pLock,
                   IN KIRQL kiIrql,
                   IN ULONG ulFileSig,
                   IN ULONG ulLineNumber,
                   IN BOOLEAN bFromDpc
                   )
{
    if (pLock->ulLockSig isnot RT_LOCK_SIG) {
        DbgPrint("RTDBG: Trying to release uninited lock 0x%x, File %c%c%c%c, Line %d\n",
                 pLock,
                 PRINT_BYTES(ulFileSig),
                 ulLineNumber);
        DbgBreakPoint();
    }
    if (pLock->bAcquired is 0) {
        DbgPrint("RTDBG: Detected release of unacquired lock 0x%x, File %c%c%c%c, Line %d\n",
                 pLock,
                 PRINT_BYTES(ulFileSig),
                 ulLineNumber);

        DbgBreakPoint();
    }
    pLock->ulFileSig = ulFileSig;
    pLock->ulLineNumber = ulLineNumber;
    pLock->bAcquired = FALSE;
    pLock->pktLastThread = (PKTHREAD) NULL;

    if (bFromDpc) {
        KeReleaseSpinLockFromDpcLevel(&(pLock->kslLock));
    } else {
        KeReleaseSpinLock(&(pLock->kslLock),
                          kiIrql);
    }
}

#endif // RT_LOCK_DEBUG

#if RT_MEM_DEBUG

PVOID
RtpAllocate(
            IN POOL_TYPE ptPool,
            IN ULONG ulSize,
            IN ULONG ulTag,
            IN ULONG ulFileSig,
            IN ULONG ulLineNumber
            )
{
    PVOID pBuffer;
    PRT_ALLOCATION pwaAlloc;
    KIRQL kiIrql;

    pwaAlloc = ExAllocatePoolWithTag(ptPool,
                                     ulSize + sizeof(RT_ALLOCATION),
                                     ulTag);

    if (pwaAlloc is NULL) {
        Trace(MEMORY, ERROR,
              ("Failed to allocate %d bytes in file %c%c%c%c, line %d\n",
               ulSize, PRINT_BYTES(ulFileSig), ulLineNumber));

        pBuffer = NULL;
    } else {
        pBuffer = (PVOID) & (pwaAlloc->pucData);

        pwaAlloc->ulMemSig = RT_MEMORY_SIG;
        pwaAlloc->ulFileSig = ulFileSig;
        pwaAlloc->ulLineNumber = ulLineNumber;
        pwaAlloc->ulSize = ulSize;

        RtAcquireSpinLock(&(g_rlMemoryLock), &kiIrql);

        InsertHeadList(&g_leAllocMemListHead,
                       &(pwaAlloc->leLink));

        RtReleaseSpinLock(&g_rlMemoryLock, kiIrql);
    }

    return pBuffer;

}

VOID
RtpFree(
        PVOID pvPointer,
        IN ULONG ulFileSig,
        IN ULONG ulLineNumber
        )
{
    PRT_ALLOCATION pwaAlloc;
    KIRQL kiIrql;
    PRT_FREE pFree;

    pwaAlloc = CONTAINING_RECORD(pvPointer, RT_ALLOCATION, pucData);

    if (pwaAlloc->ulMemSig is RT_FREE_SIG) {
        DbgPrint("RTDBG: Trying to free memory that is already freed. Pointer0x%x, File %c%c%c%c, Line %d. Was freed at File %c%c%c%c, Line %d. \n",
                 pvPointer,
                 PRINT_BYTES(ulFileSig),
                 ulLineNumber,
                 PRINT_BYTES(pwaAlloc->ulFileSig),
                 pwaAlloc->ulLineNumber);

        return;
    }
    if (pwaAlloc->ulMemSig isnot RT_MEMORY_SIG) {
        DbgPrint("RTDBG: Trying to free memory whose signature is wrong. Pointer 0x%x\n",
                 pvPointer);

        DbgBreakPoint();

        return;
    }
    //
    // create a warp free block for it
    //

    pFree = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(RT_FREE),
                                  FREE_TAG);

    RtAssert(pFree);

    //
    // Take the lock so that no one else touches the list
    //

    RtAcquireSpinLock(&(g_rlMemoryLock), &kiIrql);

    RemoveEntryList(&(pwaAlloc->leLink));

    pFree->ulMemSig = RT_FREE_SIG;
    pFree->ulAllocFileSig = pwaAlloc->ulFileSig;
    pFree->ulAllocLineNumber = pwaAlloc->ulLineNumber;
    pFree->ulFreeFileSig = ulFileSig;
    pFree->ulFreeLineNumber = ulLineNumber;
    pFree->ulStartAddr = (ULONG_PTR) (pwaAlloc->pucData);
    pFree->ulSize = pwaAlloc->ulSize;

    pwaAlloc->ulMemSig = RT_FREE_SIG;
    pwaAlloc->ulFileSig = ulFileSig;
    pwaAlloc->ulLineNumber = ulLineNumber;

    ExFreePool(pwaAlloc);

    InsertTailList(&g_leFreeMemListHead,
                   &(pFree->leLink));

    RtReleaseSpinLock(&(g_rlMemoryLock), kiIrql);
}

VOID
RtAuditMemory()
{
    PRT_ALLOCATION pwaAlloc;
    PLIST_ENTRY pleNode;
    PRT_FREE pFree;

    while (!IsListEmpty(&g_leAllocMemListHead)) {
        pleNode = RemoveHeadList(&g_leAllocMemListHead);

        pwaAlloc = CONTAINING_RECORD(pleNode, RT_ALLOCATION, leLink);

        if (pwaAlloc->ulMemSig is RT_MEMORY_SIG) {
            DbgPrint("RTDBG: Unfreed memory. %d bytes. Pointer 0x%x, File %c%c%c%c, Line %d\n",
                     pwaAlloc->ulSize,
                     pwaAlloc->pucData,
                     PRINT_BYTES(pwaAlloc->ulFileSig),
                     pwaAlloc->ulLineNumber);

            DbgBreakPoint();

            ExFreePool(pwaAlloc);

            continue;
        }
        DbgPrint("RTDBG: Allocation with bad signature. Pointer 0x%x\n",
                 pwaAlloc->pucData);

        DbgBreakPoint();

        continue;
    }

    while (!IsListEmpty(&g_leFreeMemListHead)) {
        pleNode = RemoveHeadList(&g_leFreeMemListHead);

        pFree = CONTAINING_RECORD(pleNode, RT_FREE, leLink);

        if (pFree->ulMemSig is RT_FREE_SIG) {
            ExFreePool(pFree);

            continue;
        }
        DbgPrint("RTDBG: Freed memory with bad signature.\n");

        DbgBreakPoint();
    }

}

#endif

#if IF_REFERENCE_DEBUG

uint
DbgLockedReferenceIF(
            IN Interface *RefIF,
            IN uchar *File,
            IN uint Line
            )
/*++

Routine Description:

    Increases the reference count of a IF and records a history of who
    made the call to reference.

Arguments:

    RefIF  - The IF to reference.
    File   - The filename containing the calling fcn (output of the __FILE__ macro).
    Line   - The line number of the call to this fcn (output of the __LINE__ macro).

Return Value:

    Reference count 

--*/
{
    void *CallersCaller;
    IF_REFERENCE_HISTORY *RefHistory;

    RefHistory = &RefIF->if_refhistory[RefIF->if_refhistory_index];
    RefHistory->File = File;
    RefHistory->Line = Line;
    RtlGetCallersAddress(&RefHistory->Caller, &CallersCaller);
    RefHistory->Count = ++RefIF->if_refcount;
    RefIF->if_refhistory_index = ++RefIF->if_refhistory_index % MAX_IFREFERENCE_HISTORY;

    return RefIF->if_refcount;

}


uint
DbgDereferenceIF(
              IN Interface *DerefIF,
              IN uchar *File,
              IN uint Line
              )
/*++

Routine Description:

    Lock, Dereference the interface and records a history of who made the call to dereference.

Arguments:

    DerefIF        - The IF to dereference.
    File           - The filename containing the calling fcn (output of the __FILE__ macro).
    Line           - The line number of the call to this fcn (output of the __LINE__ macro).

Return Value:
    Original reference count

--*/
{
    void *Caller;
    IF_REFERENCE_HISTORY *RefHistory;
    CTELockHandle RouteTableHandle;
    uint RefCount;

    CTEGetLock(&RouteTableLock.Lock, &RouteTableHandle);
    RefHistory = &DerefIF->if_refhistory[DerefIF->if_refhistory_index];
    RefHistory->File = File;
    RefHistory->Line = Line;
    RtlGetCallersAddress(&Caller, &RefHistory->Caller);
    RefCount = DerefIF->if_refcount;
    RefHistory->Count = --DerefIF->if_refcount;
    DerefIF->if_refhistory_index = ++DerefIF->if_refhistory_index % MAX_IFREFERENCE_HISTORY;
    CTEFreeLock(&RouteTableLock.Lock, RouteTableHandle);

    return RefCount;

}

uint
DbgLockedDereferenceIF(
              IN Interface *DerefIF,
              IN uchar *File,
              IN uint Line
              )
/*++

Routine Description:

    Dereference the interface and records a history of who made the call to dereference.

Arguments:

    DerefIF        - The IF to dereference.
    File           - The filename containing the calling fcn (output of the __FILE__ macro).
    Line           - The line number of the call to this fcn (output of the __LINE__ macro).

Return Value:
    Reference count

--*/
{
    void *Caller;
    IF_REFERENCE_HISTORY *RefHistory;
    uint RefCount;

    RefHistory = &DerefIF->if_refhistory[DerefIF->if_refhistory_index];
    RefHistory->File = File;
    RefHistory->Line = Line;
    RtlGetCallersAddress(&Caller, &RefHistory->Caller);
    RefCount = DerefIF->if_refcount;
    RefHistory->Count = --DerefIF->if_refcount;
    DerefIF->if_refhistory_index = ++DerefIF->if_refhistory_index % MAX_IFREFERENCE_HISTORY;

    return RefCount;

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\arp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

       ARP.C - LAN arp module.

Abstract:

  This file implements arp framing for IP layer on the upper edge
  and interfaces with ndis driver on the lower edge.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:

--*/

#include "precomp.h"

//***   arp.c - ARP routines.
//
//  This file containes all of the ARP related routines, including
//  table lookup, registration, etc.
//
//  ARP is architected to support multiple protocols, but for now
//  it in only implemented to take one protocol (IP). This is done
//  for simplicity and ease of implementation. In the future we may
//  split ARP out into a seperate driver.


#include "arp.h"
#include "arpdef.h"
#include "iproute.h"
#include "iprtdef.h"
#include "arpinfo.h"
#include "tcpipbuf.h"
#include "mdlpool.h"
#include "ipifcons.h"

#define NDIS_MAJOR_VERSION 0x4
#define NDIS_MINOR_VERSION 0

#ifndef NDIS_API
#define NDIS_API
#endif

#define PPP_HW_ADDR     "DEST"
#define PPP_HW_ADDR_LEN 4

#if DBG
uint fakereset = 0;
#endif

extern void IPReset(void *Context);

UINT cUniAdapters = 0;

extern uint EnableBcastArpReply;

static ulong ARPLookahead = LOOKAHEAD_SIZE;

static const uchar ENetBcst[] = "\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x08\x06";
static const uchar TRBcst[] = "\x10\x40\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x82\x70";
static const uchar FDDIBcst[] = "\x57\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00";
static const uchar ARCBcst[] = "\x00\x00\xd5";

ulong TRFunctionalMcast = 0;
//canonical or non-canonical?
static uchar TRMcst[] = "\x10\x40\xc0\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x82\x70";
//#define TR_MCAST_FUNCTIONAL_ADDRESS 0xc00000040000
//canonical form
#define TR_MCAST_FUNCTIONAL_ADDRESS 0x030000200000
static uchar TRNetMcst[] = "\x00\x04\x00\x00";

static const uchar ENetMcst[] = "\x01\x00\x5E\x00\x00\x00";
static const uchar FDDIMcst[] = "\x57\x01\x00\x5E\x00\x00\x00";
static const uchar ARPSNAP[] = "\xAA\xAA\x03\x00\x00\x00\x08\x06";

static const uchar ENetPtrnMsk[] = "\x00\x30";
static const uchar ENetSNAPPtrnMsk[] = "\x00\xC0\x3f";
//static const uchar TRPtrnMsk[] = "\x03\x00";
//static const uchar TRSNAPPtrnMsk[] = "\x03\xC0\x3f";

static const uchar TRPtrnMsk[] = "\x00\x00";    //NO AC/FC bits need to be checked
static const uchar TRSNAPPtrnMsk[] = "\x00\xC0\x3f";

static const uchar FDDIPtrnMsk[] = "\x01\x00";
static const uchar FDDISNAPPtrnMsk[] = "\x01\x70\x1f";
static const uchar ARCPtrnMsk[] = "\x01";
static const uchar ARPPtrnMsk[] = "\x80\x00\x00\x0F";
static const uchar ARCARPPtrnMsk[] = "\x80\xC0\x03";

NDIS_STATUS __stdcall DoWakeupPattern(void *Context,
                                      PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc, ushort protoid,
                                      BOOLEAN AddPattern);

NDIS_STATUS ARPWakeupPattern(ARPInterface *Interface, IPAddr Address,
                             BOOLEAN AddPattern);

NDIS_STATUS AddrNotifyLink(ARPInterface *Interface);

static WCHAR ARPName[] = TCP_NAME;

NDIS_HANDLE ARPHandle;                  // Our NDIS protocol handle.

uint ArpCacheLife;
extern uint ArpMinValidCacheLife;
uint sArpAlwaysSourceRoute;             // True if we always send ARP requests
uint ArpRetryCount;                     // retries for arp request with source
                                        // route info on token ring.
uint sIPAlwaysSourceRoute;
extern uchar TrRii;
extern PDRIVER_OBJECT IPDriverObject;
extern DisableTaskOffload;

extern NDIS_STATUS __stdcall IPPnPEvent(void *, PNET_PNP_EVENT PnPEvent);
extern NDIS_STATUS GetIPConfigValue(NDIS_HANDLE Handle, PUNICODE_STRING IPConfig);
extern VOID IPUnload(IN PDRIVER_OBJECT DriverObject);

extern BOOLEAN CopyToNdisSafe(
                             PNDIS_BUFFER DestBuf,
                             PNDIS_BUFFER *ppNextBuf,
                             uchar *SrcBuf,
                             uint Size,
                             uint *StartOffset);

extern void NDIS_API ARPSendComplete(NDIS_HANDLE, PNDIS_PACKET, NDIS_STATUS);
extern void IPULUnloadNotify(void);

extern void NotifyOfUnload(void);

extern uint OpenIFConfig(PNDIS_STRING ConfigName, NDIS_HANDLE * Handle);
extern int IsLLInterfaceValueNull(NDIS_HANDLE Handle);
extern void CloseIFConfig(NDIS_HANDLE Handle);

BOOLEAN QueryAndSetOffload(ARPInterface *ai);


ARPTableEntry *CreateARPTableEntry(ARPInterface *Interface, IPAddr Destination,
                                   CTELockHandle *Handle, void *UserArp);

NDIS_STATUS NDIS_API
ARPRcvIndicationNew(NDIS_HANDLE Handle, NDIS_HANDLE Context, void *Header,
                    uint HeaderSize, void *Data, uint Size, uint TotalSize,
                    PNDIS_BUFFER pNdisBuffer, PINT pClientCnt);

void
CompleteIPSetNTEAddrRequestDelayed(CTEEvent *WorkerThreadEvent, PVOID Context);

// Tables for bitswapping.

const uchar SwapTableLo[] =
{
    0,                                  // 0
    0x08,                               // 1
    0x04,                               // 2
    0x0c,                               // 3
    0x02,                               // 4
    0x0a,                               // 5,
    0x06,                               // 6,
    0x0e,                               // 7,
    0x01,                               // 8,
    0x09,                               // 9,
    0x05,                               // 10,
    0x0d,                               // 11,
    0x03,                               // 12,
    0x0b,                               // 13,
    0x07,                               // 14,
    0x0f                                // 15
};

const uchar SwapTableHi[] =
{
    0,                                  // 0
    0x80,                               // 1
    0x40,                               // 2
    0xc0,                               // 3
    0x20,                               // 4
    0xa0,                               // 5,
    0x60,                               // 6,
    0xe0,                               // 7,
    0x10,                               // 8,
    0x90,                               // 9,
    0x50,                               // 10,
    0xd0,                               // 11,
    0x30,                               // 12,
    0xb0,                               // 13,
    0x70,                               // 14,
    0xf0                                // 15
};

// Table of source route maximum I-field lengths for token ring.
const ushort IFieldSize[] =
{
    516,
    1500,
    2052,
    4472,
    8191
};

#define LF_BIT_SHIFT    4
#define MAX_LF_BITS     4

//
// Disposable init or paged code.
//
void FreeARPInterface(ARPInterface * Interface);
void ARPOpen(void *Context);
void NotifyConflictProc(CTEEvent * Event, void *Context);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ARPInit)
#pragma alloc_text(PAGE, ARPOpen)
#pragma alloc_text(PAGELK, ARPRegister)
#pragma alloc_text(PAGE, NotifyConflictProc)
#endif // ALLOC_PRAGMA


LIST_ENTRY ArpInterfaceList;
CACHE_LINE_KSPIN_LOCK ArpInterfaceListLock;
HANDLE ArpEnetHeaderPool;
HANDLE ArpAuxHeaderPool;
#define BUFSIZE_ENET_HEADER_POOL sizeof(ENetHeader) + sizeof(ARPHeader)
#define BUFSIZE_AUX_HEADER_POOL ARP_MAX_MEDIA_TR + (2 * sizeof(ARPHeader))


//
// Support Structs for DoNDISRequest (BLOCKING & NON-BLOCKING)
//
typedef struct _RequestBlock {
    NDIS_REQUEST Request;               // Request structure we'll use
    ULONG Blocking;                     // ? Is this Request Blocking ?
    CTEBlockStruc Block;                // Structure for blocking on. No longer use
    // ai_block since multiple requests can
    // occur simultaneously.
    // ai_block is now only used for blocking on
    // opening and closing the NDIS adapter.
    ULONG RefCount;                     // Reference count (only used for blocking).
    // Reference counting is required for Windows ME since KeWaitForSingleObject
    // can fail (when the event is NOT set) and we need to protect the memory
    // until completion.
} RequestBlock;


// This prototype enables DoNDISRequest to compile without errors
void NDIS_API
ARPRequestComplete(NDIS_HANDLE Handle, PNDIS_REQUEST pRequest,
                   NDIS_STATUS Status);

//* FillARPControlBlock
//
//  A utility routine to transfer a physical address into an ARPControlBlock,
//  taking into account different MAC address formats.
//
//  Entry:
//      Interface   - the ARPInterface which identifies the media
//      Entry       - the ARP entry containing the MAC address
//      ArpContB    - the control-block to be filled
//
__inline
NDIS_STATUS
FillARPControlBlock(ARPInterface* Interface, ARPTableEntry* Entry,
                    ARPControlBlock* ArpContB)
{
    ENetHeader *EHdr;
    TRHeader *TRHdr;
    FDDIHeader *FHdr;
    ARCNetHeader *AHdr;
    uint Size = 0;
    NDIS_STATUS Status;

    if (Interface->ai_media == NdisMediumArcnet878_2) {
        if (!ArpContB->PhyAddrLen) {
            return NDIS_STATUS_BUFFER_OVERFLOW;
        }
        Status = NDIS_STATUS_SUCCESS;
    } else if (ArpContB->PhyAddrLen < ARP_802_ADDR_LENGTH) {
        Size = ArpContB->PhyAddrLen;
        Status = NDIS_STATUS_BUFFER_OVERFLOW;
    } else {
        Size = ARP_802_ADDR_LENGTH;
        Status = NDIS_STATUS_SUCCESS;
    }

    switch (Interface->ai_media) {
    case NdisMedium802_3:
        EHdr = (ENetHeader *) Entry->ate_addr;
        RtlCopyMemory(ArpContB->PhyAddr, EHdr->eh_daddr, Size);
        ArpContB->PhyAddrLen = Size;
        break;
    case NdisMedium802_5:
        TRHdr = (TRHeader *) Entry->ate_addr;
        RtlCopyMemory(ArpContB->PhyAddr, TRHdr->tr_daddr, Size);
        ArpContB->PhyAddrLen = Size;
        break;
    case NdisMediumFddi:
        FHdr = (FDDIHeader *) Entry->ate_addr;
        RtlCopyMemory(ArpContB->PhyAddr, FHdr->fh_daddr, Size);
        ArpContB->PhyAddrLen = Size;
        break;
    case NdisMediumArcnet878_2:
        AHdr = (ARCNetHeader *) Entry->ate_addr;
        ArpContB->PhyAddr[0] = AHdr->ah_daddr;
        ArpContB->PhyAddrLen = 1;
        break;
    default:
        ASSERT(0);
    }
    return Status;
}

//* DoNDISRequest - Submit a (NON) BLOCKING request to an NDIS driver
//
//  This is a utility routine to submit a general request to an NDIS
//  driver. The caller specifes the request code (OID), a buffer and
//  a length. This routine allocates a request structure, fills it in, &
//  submits the request.
//
//  If the call is non-blocking, any memory allocated is deallocated
//  in ARPRequestComplete. Also as this callback is shared by both
//  DoNDISRequest blocking and non-blocking, we suffix the request
//  with a ULONG that tells ARPRequestComplete if this request is a
//  blocking request or not. If the request is non blocking, then the
//  ARPRequestComplete reclaims the memory allocated on the heap
//
//  Important:
//    Allocate Info, which points to the Information Buffer passed to
//    NdisRequest, on the HEAP, if this request does not block. This
//    memory is automatically deallocated by ARPRequestComplete
//
//  If the call is blocking, the request memory can be allocated on the
//  STACK. When we complete the request, the request on the stack
//  will automatically get unwound.
//
//  Entry:
//      Adapter - A pointer to the ARPInterface adapter structure.
//      Request - Type of request to be done (Set or Query)
//      OID     - Value to be set/queried.
//      Info     - A pointer to the info buffer
//      Length  - Length of data in the buffer
//      Needed  - On return, filled in with bytes needed in buffer
//      Blocking - Whether NdisRequest is completed synchronously
//
//  Exit:
//      Status - BLOCKING req - SUCCESS or some NDIS error code
//              NON-BLOCKING - SUCCESS, PENDING or some error
//
NDIS_STATUS
DoNDISRequest(ARPInterface * Adapter, NDIS_REQUEST_TYPE RT, NDIS_OID OID,
              VOID * Info, UINT Length, UINT * Needed, BOOLEAN Blocking)
{
    RequestBlock *pReqBlock;
    NDIS_STATUS Status;

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_REQUEST,
         (DTEXT("+DoNDISRequest(%x, %x, %x, %x, %d, %x, %x\n"),
          Adapter, RT, OID, Info, Length, Needed, Blocking));

    if ((Adapter->ai_adminstate == INTERFACE_DOWN) ||
        (Adapter->ai_handle == NULL)) {
        return NDIS_STATUS_ADAPTER_NOT_READY;
    }

    // Both blocking and non-blocking requests are allocated from NPP. The
    // blocking case is to protect against wait failure.
    pReqBlock = CTEAllocMemN(sizeof(RequestBlock), 'NiCT');
    if (pReqBlock == NULL) {
        return NDIS_STATUS_RESOURCES;
    }

    if (Blocking) {
        // Initialize the structure to block on
        CTEInitBlockStruc(&pReqBlock->Block);

        // Reference count is initialize to two. One for the completion in
        // ARPRequestComplete and one for when the CTEBlock completes.
        // N.B. This ensures that we don't touch freed memory if
        // the CTEBlock fails on Windows ME.
        pReqBlock->RefCount = 2;

        DEBUGMSG(DBG_INFO && DBG_ARP && DBG_REQUEST,
             (DTEXT("DoNDISRequset block: pReqBlock %x OID %x\n"),
              pReqBlock, OID));
    } else {
        DEBUGMSG(DBG_INFO && DBG_ARP &&  DBG_REQUEST,
             (DTEXT("DoNDISRequest async: pReqBlock %x OID %x\n"),
              pReqBlock, OID));
    }

    // Now fill the request's info buffer (same for BLOCKING & NON-BLOCKING)
    pReqBlock->Block.cbs_status = NDIS_STATUS_SUCCESS;
    pReqBlock->Request.RequestType = RT;
    if (RT == NdisRequestSetInformation) {
        pReqBlock->Request.DATA.SET_INFORMATION.Oid = OID;
        pReqBlock->Request.DATA.SET_INFORMATION.InformationBuffer = Info;
        pReqBlock->Request.DATA.SET_INFORMATION.InformationBufferLength = Length;
    } else {
        pReqBlock->Request.DATA.QUERY_INFORMATION.Oid = OID;
        pReqBlock->Request.DATA.QUERY_INFORMATION.InformationBuffer = Info;
        pReqBlock->Request.DATA.QUERY_INFORMATION.InformationBufferLength = Length;
    }

    pReqBlock->Blocking = Blocking;

    // Submit the request.
    if (Adapter->ai_handle != NULL) {

#if MILLEN
        // On Millennium, the AOL adapter returns with registers trashed.
        // We will work around by saving and restoring registers.
        //

        _asm {
            push esi
            push edi
            push ebx
        }
#endif // MILLEN

        NdisRequest(&Status, Adapter->ai_handle, &pReqBlock->Request);

#if MILLEN
        _asm {
            pop ebx
            pop edi
            pop esi
        }
#endif // MILLEN
} else {

        Status = NDIS_STATUS_FAILURE;
    }

    if (Blocking) {
        if (Status == NDIS_STATUS_PENDING) {
            CTEBlockTracker Tracker;

            Status = (NDIS_STATUS) CTEBlockWithTracker(&pReqBlock->Block,
                                                       &Tracker, Adapter);

#if MILLEN
            // If Status == -1, it means the wait failed -- due to system reasons.
            // Put in a reasonable failure.
            if (Status == -1) {
                Status = NDIS_STATUS_FAILURE;
            }
#endif // MILLEN

        } else {
            // Since we aren't blocking, remove refcount for ARPRequestComplete.
            InterlockedDecrement( (PLONG) &pReqBlock->RefCount);
        }

        if (Needed != NULL)
            *Needed = pReqBlock->Request.DATA.QUERY_INFORMATION.BytesNeeded;

        if (InterlockedDecrement( (PLONG) &pReqBlock->RefCount) == 0) {
            CTEFreeMem(pReqBlock);
        }

    } else {
        if (Status != NDIS_STATUS_PENDING) {
            if (Needed != NULL)
                *Needed = pReqBlock->Request.DATA.QUERY_INFORMATION.BytesNeeded;

            ARPRequestComplete(Adapter->ai_handle, &pReqBlock->Request, Status);
        }
    }

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_REQUEST,
         (DTEXT("-DoNDISRequest [%x]\n"), Status));

    return Status;
}

//* FreeARPBuffer - Free a header and buffer descriptor pair.
//
//  Called when we're done with a buffer. We'll free the buffer and the
//  buffer descriptor pack to the interface.
//
//  Entry:  Interface   - Interface buffer/bd came frome.
//          Buffer      - NDIS_BUFFER to be freed.
//
//  Returns: Nothing.
//
__inline
VOID
FreeARPBuffer(ARPInterface *Interface, PNDIS_BUFFER Buffer)
{
    UNREFERENCED_PARAMETER(Interface);
    MdpFree(Buffer);
}

//* GetARPBuffer - Get a buffer and descriptor
//
//  Returns a pointer to an NDIS_BUFFER and a pointer to a buffer
//      of the specified size.
//
//  Entry:  Interface   - Pointer to ARPInterface structure to allocate buffer from.
//          BufPtr      - Pointer to where to return buf address.
//          Size        - Size in bytes of buffer needed.
//
//  Returns: Pointer to NDIS_BUFFER if successfull, NULL if not
//
PNDIS_BUFFER
GetARPBufferAtDpcLevel(ARPInterface *Interface, uchar **BufPtr, uchar Size)
{
    PNDIS_BUFFER Mdl = NULL;
    UNREFERENCED_PARAMETER(Interface);


#if DBG
    *BufPtr = NULL;
#endif

    UNREFERENCED_PARAMETER(Interface);

    if (Size <= BUFSIZE_ENET_HEADER_POOL) {
        Mdl = MdpAllocateAtDpcLevel(ArpEnetHeaderPool, BufPtr);
    } else if (Size <= BUFSIZE_AUX_HEADER_POOL) {
        Mdl = MdpAllocateAtDpcLevel(ArpAuxHeaderPool, BufPtr);
    }

    if (Mdl) {
        NdisAdjustBufferLength(Mdl, Size);
    }

    return Mdl;
}

#if MILLEN
#define GetARPBuffer GetARPBufferAtDpcLevel
#else
__inline
PNDIS_BUFFER
GetARPBuffer(ARPInterface *Interface, uchar **BufPtr, uchar Size)
{
    KIRQL OldIrql;
    PNDIS_BUFFER Mdl;

    OldIrql = KeRaiseIrqlToDpcLevel();

    Mdl = GetARPBufferAtDpcLevel(Interface, BufPtr, Size);

    KeLowerIrql(OldIrql);

    return Mdl;
}
#endif


//* BitSwap - Bit swap two strings.
//
//  A routine to bitswap two strings.
//
//  Input:   Dest   - Destination of swap.
//           Src    - Src string to be swapped.
//           Length - Length in bytes to swap.
//
//  Returns: Nothing.
//
void
BitSwap(uchar * Dest, uchar * Src, uint Length)
{
    uint i;
    uchar Temp, TempSrc;

    for (i = 0; i < Length; i++, Dest++, Src++) {
        TempSrc = *Src;
        Temp = SwapTableLo[TempSrc >> 4] | SwapTableHi[TempSrc & 0x0f];
        *Dest = Temp;
    }
}

//* SendARPPacket - Build a header, and send a packet.
//
//  A utility routine to build and ARP header and send a packet. We assume
//  the media specific header has been built.
//
//  Entry:  Interface   - Interface for NDIS drive.
//          Packet      - Pointer to packet to be sent
//          Header      - Pointer to header to fill in.
//          Opcode      - Opcode for packet.
//          Address     - Source HW address.
//          SrcAddr     - Address to use as our source h/w address.
//          Destination - Destination IP address.
//          Src         - Source IP address.
//          HWType      - Hardware type.
//          CheckIF     - TRUE iff we are to check the I/F status before
//                        sending.
//
//  Returns: NDIS_STATUS of send.
//
NDIS_STATUS
SendARPPacket(ARPInterface * Interface, PNDIS_PACKET Packet, ARPHeader * Header, ushort Opcode,
              uchar * Address, uchar * SrcAddr, IPAddr Destination, IPAddr Src,
              ushort HWType, uint CheckIF)
{
    NDIS_STATUS Status;
    PNDIS_BUFFER Buffer;
    uint PacketDone;
    uchar *AddrPtr;
    ulong Proc;

    Header->ah_hw = HWType;
    Header->ah_pro = net_short(ARP_ETYPE_IP);
    Header->ah_hlen = Interface->ai_addrlen;
    Header->ah_plen = sizeof(IPAddr);
    Header->ah_opcode = Opcode;
    AddrPtr = Header->ah_shaddr;

    if (SrcAddr == NULL)
        SrcAddr = Interface->ai_addr;

    RtlCopyMemory(AddrPtr, SrcAddr, Interface->ai_addrlen);

    AddrPtr += Interface->ai_addrlen;
    *(IPAddr UNALIGNED *) AddrPtr = Src;
    AddrPtr += sizeof(IPAddr);

    if (Address != (uchar *) NULL)
        RtlCopyMemory(AddrPtr, Address, Interface->ai_addrlen);
    else
        RtlZeroMemory(AddrPtr, Interface->ai_addrlen);

    AddrPtr += Interface->ai_addrlen;
    *(IPAddr UNALIGNED *) AddrPtr = Destination;

    PacketDone = FALSE;

    if (!CheckIF || (Interface->ai_operstatus == INTERFACE_UP)) {
		
        Proc = KeGetCurrentProcessorNumber();
        Interface->ai_qlen[Proc].ai_qlen++;

        NdisSend(&Status, Interface->ai_handle, Packet);

        if (Status != NDIS_STATUS_PENDING) {
            PacketDone = TRUE;
            Interface->ai_qlen[Proc].ai_qlen--;

            if (Status == NDIS_STATUS_SUCCESS)
                Interface->ai_outoctets += Packet->Private.TotalLength;
            else {
                if (Status == NDIS_STATUS_RESOURCES)
                    Interface->ai_outdiscards++;
                else
                    Interface->ai_outerrors++;
            }
        }
    } else {
        PacketDone = TRUE;
        Status = NDIS_STATUS_ADAPTER_NOT_READY;
    }

    if (PacketDone) {
        NdisUnchainBufferAtFront(Packet, &Buffer);
        FreeARPBuffer(Interface, Buffer);
        NdisFreePacket(Packet);
    }
    return Status;
}

//* SendARPRequest - Send an ARP packet
//
//  Called when we need to ARP an IP address, or respond to a request. We'll send out
//  the packet, and the receiving routines will process the response.
//
//  Entry:  Interface   - Interface to send the request on.
//          Destination - The IP address to be ARPed.
//          Type        - Either RESOLVING_GLOBAL or RESOLVING_LOCAL
//                      SrcAddr         - NULL if we're sending from ourselves, the value
//                                                      to use otherwise.
//                      CheckIF         - Flag passed through to SendARPPacket().
//
//  Returns:    Status of attempt to send ARP request.
//
NDIS_STATUS
SendARPRequest(ARPInterface * Interface, IPAddr Destination, uchar Type,
               uchar * SrcAddr, uint CheckIF)
{
    uchar *MHeader;                     // Pointer to media header.
    PNDIS_BUFFER Buffer;                // NDIS buffer descriptor.
    uchar MHeaderSize;                  // Size of media header.
    const uchar *MAddr;                 // Pointer to media address structure.
    uint SAddrOffset;                   // Offset into media address of source address.
    uchar SRFlag = 0;                   // Source routing flag.
    uchar SNAPLength = 0;
    const uchar *SNAPAddr;              // Address of SNAP header.
    PNDIS_PACKET Packet;                // Packet for sending.
    NDIS_STATUS Status;
    ushort HWType;
    IPAddr Src;
    CTELockHandle Handle;
    ARPIPAddr *Addr;

    // First, get a source address we can use.
    CTEGetLock(&Interface->ai_lock, &Handle);
    Addr = &Interface->ai_ipaddr;
    Src = NULL_IP_ADDR;
    do {
        if (!IP_ADDR_EQUAL(Addr->aia_addr, NULL_IP_ADDR)) {
            //
            // This is a valid address. See if it is the same as the
            // target address - i.e. arp'ing for ourselves. If it is,
            // we want to use that as our source address.
            //
            if (IP_ADDR_EQUAL(Addr->aia_addr, Destination)) {
                Src = Addr->aia_addr;
                break;
            }
            // See if the target is on this subnet.
            if (IP_ADDR_EQUAL(
                             Addr->aia_addr & Addr->aia_mask,
                             Destination & Addr->aia_mask
                             )) {
                //
                // See if we've already found a suitable candidate on the
                // same subnet. If we haven't, we'll use this one.
                //
                if (!IP_ADDR_EQUAL(
                                  Addr->aia_addr & Addr->aia_mask,
                                  Src & Addr->aia_mask
                                  )) {
                    Src = Addr->aia_addr;
                }
            } else {
                // He's not on our subnet. If we haven't already found a valid
                // address save this one in case we don't find a match for the
                // subnet.
                if (IP_ADDR_EQUAL(Src, NULL_IP_ADDR)) {
                    Src = Addr->aia_addr;
                }
            }
        }
        Addr = Addr->aia_next;

    } while (Addr != NULL);

    CTEFreeLock(&Interface->ai_lock, Handle);

    // If we didn't find a source address, give up.
    if (IP_ADDR_EQUAL(Src, NULL_IP_ADDR))
        return NDIS_STATUS_SUCCESS;

    NdisAllocatePacket(&Status, &Packet, Interface->ai_ppool);
    if (Status != NDIS_STATUS_SUCCESS) {
        Interface->ai_outdiscards++;
        return Status;
    }
    ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_owner = PACKET_OWNER_LINK;
    (Interface->ai_outpcount[AI_NONUCAST_INDEX])++;

    // Figure out what type of media this is, and do the appropriate thing.
    switch (Interface->ai_media) {
    case NdisMedium802_3:
        MHeaderSize = ARP_MAX_MEDIA_ENET;
        MAddr = ENetBcst;
        if (Interface->ai_snapsize == 0) {
            SNAPAddr = (uchar *) NULL;
            HWType = net_short(ARP_HW_ENET);
        } else {
            SNAPLength = sizeof(SNAPHeader);
            SNAPAddr = ARPSNAP;
            HWType = net_short(ARP_HW_802);
        }

        SAddrOffset = offsetof(struct ENetHeader, eh_saddr);
        break;
    case NdisMedium802_5:
        // Token ring. We have logic for dealing with the second transmit
        // of an arp request.
        MAddr = TRBcst;
        SAddrOffset = offsetof(struct TRHeader, tr_saddr);
        SNAPLength = sizeof(SNAPHeader);
        SNAPAddr = ARPSNAP;
        MHeaderSize = sizeof(TRHeader);
        HWType = net_short(ARP_HW_802);
        if (Type == ARP_RESOLVING_GLOBAL) {
            MHeaderSize += sizeof(RC);
            SRFlag = TR_RII;
        }
        break;
    case NdisMediumFddi:
        MHeaderSize = sizeof(FDDIHeader);
        MAddr = FDDIBcst;
        SNAPAddr = ARPSNAP;
        SNAPLength = sizeof(SNAPHeader);
        SAddrOffset = offsetof(struct FDDIHeader, fh_saddr);
        HWType = net_short(ARP_HW_ENET);
        break;
    case NdisMediumArcnet878_2:
        MHeaderSize = ARP_MAX_MEDIA_ARC;
        MAddr = ARCBcst;
        SNAPAddr = (uchar *) NULL;
        SAddrOffset = offsetof(struct ARCNetHeader, ah_saddr);
        HWType = net_short(ARP_HW_ARCNET);
        break;
    default:
        ASSERT(0);
        Interface->ai_outerrors++;
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    if ((Buffer = GetARPBuffer(Interface, &MHeader,
                               (uchar) (sizeof(ARPHeader) + MHeaderSize + SNAPLength))) == (PNDIS_BUFFER) NULL) {
        NdisFreePacket(Packet);
        Interface->ai_outdiscards++;
        return NDIS_STATUS_RESOURCES;
    }
    if (Interface->ai_media == NdisMediumArcnet878_2) {
        NdisAdjustBufferLength(Buffer, NdisBufferLength(Buffer) - ARCNET_ARPHEADER_ADJUSTMENT);
    }

    // Copy broadcast address into packet.
    RtlCopyMemory(MHeader, MAddr, MHeaderSize);
    // Fill in source address.
    if (SrcAddr == NULL) {
        SrcAddr = Interface->ai_addr;
    }
    if (Interface->ai_media == NdisMedium802_3 && Interface->ai_snapsize != 0) {
        ENetHeader *Hdr = (ENetHeader *) MHeader;

        // Using SNAP on ethernet. Adjust the etype to a length.
        Hdr->eh_type = net_short(sizeof(ARPHeader) + sizeof(SNAPHeader));
    }
    RtlCopyMemory(&MHeader[SAddrOffset], SrcAddr, Interface->ai_addrlen);
    if ((Interface->ai_media == NdisMedium802_5) && (Type == ARP_RESOLVING_GLOBAL)) {
        // Turn on source routing.
        MHeader[SAddrOffset] |= SRFlag;
        MHeader[SAddrOffset + Interface->ai_addrlen] |= TrRii;
    }
    // Copy in SNAP header, if any.
    RtlCopyMemory(&MHeader[MHeaderSize], SNAPAddr, SNAPLength);

    // Media header is filled in. Now do ARP packet itself.
    NdisChainBufferAtFront(Packet, Buffer);
    return SendARPPacket(Interface, Packet, (ARPHeader *) & MHeader[MHeaderSize + SNAPLength],
                         net_short(ARP_REQUEST), (uchar *) NULL, SrcAddr, Destination, Src,
                         HWType, CheckIF);
}

//* SendARPReply - Reply to an ARP request.
//
//  Called by our receive packet handler when we need to reply. We build a packet
//  and buffer and call SendARPPacket to send it.
//
//  Entry:  Interface   - Pointer to interface to reply on.
//          Destination - IPAddress to reply to.
//          Src         - Source address to reply from.
//          HWAddress   - Hardware address to reply to.
//          SourceRoute - Source Routing information, if any.
//          SourceRouteSize - Size in bytes of soure routing.
//                      UseSNAP         - Whether or not to use SNAP for this reply.
//
//  Returns: Nothing.
//
void
SendARPReply(ARPInterface * Interface, IPAddr Destination, IPAddr Src, uchar * HWAddress,
             RC UNALIGNED * SourceRoute, uint SourceRouteSize, uint UseSNAP)
{
    PNDIS_PACKET Packet;                // Buffer and packet to be used.
    PNDIS_BUFFER Buffer;
    uchar *Header;                      // Pointer to media header.
    NDIS_STATUS Status;
    uchar Size = 0;                     // Size of media header buffer.
    ushort HWType;
    ENetHeader *EH;
    FDDIHeader *FH;
    ARCNetHeader *AH;
    TRHeader *TRH;

    // Allocate a packet for this.
    NdisAllocatePacket(&Status, &Packet, Interface->ai_ppool);
    if (Status != NDIS_STATUS_SUCCESS) {
        Interface->ai_outdiscards++;
        return;
    }
    ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_owner = PACKET_OWNER_LINK;
    (Interface->ai_outpcount[AI_UCAST_INDEX])++;

    Size = Interface->ai_hdrsize;

    if (UseSNAP)
        Size = Size + (uchar) Interface->ai_snapsize;

    if (Interface->ai_media == NdisMedium802_5)
        Size = Size + (uchar) SourceRouteSize;

    if ((Buffer = GetARPBuffer(Interface, &Header, (uchar) (Size + sizeof(ARPHeader)))) ==
        (PNDIS_BUFFER) NULL) {
        Interface->ai_outdiscards++;
        NdisFreePacket(Packet);
        return;
    }
    // Decide how to build the header based on the media type.
    switch (Interface->ai_media) {
    case NdisMedium802_3:
        EH = (ENetHeader *) Header;
        RtlCopyMemory(EH->eh_daddr, HWAddress, ARP_802_ADDR_LENGTH);
        RtlCopyMemory(EH->eh_saddr, Interface->ai_addr, ARP_802_ADDR_LENGTH);
        if (!UseSNAP) {
            EH->eh_type = net_short(ARP_ETYPE_ARP);
            HWType = net_short(ARP_HW_ENET);
        } else {
            // Using SNAP on ethernet.
            EH->eh_type = net_short(sizeof(ARPHeader) + sizeof(SNAPHeader));
            HWType = net_short(ARP_HW_802);
            RtlCopyMemory(Header + sizeof(ENetHeader), ARPSNAP,
                       sizeof(SNAPHeader));
        }
        break;
    case NdisMedium802_5:
        TRH = (TRHeader *) Header;
        TRH->tr_ac = ARP_AC;
        TRH->tr_fc = ARP_FC;
        RtlCopyMemory(TRH->tr_daddr, HWAddress, ARP_802_ADDR_LENGTH);
        RtlCopyMemory(TRH->tr_saddr, Interface->ai_addr, ARP_802_ADDR_LENGTH);
        if (SourceRouteSize) {          // If we have source route info, deal with
            // it.

            RtlCopyMemory(Header + sizeof(TRHeader), SourceRoute,
                       SourceRouteSize);
            // Convert to directed  response.
            ((RC *) & Header[sizeof(TRHeader)])->rc_blen &= RC_LENMASK;

            ((RC *) & Header[sizeof(TRHeader)])->rc_dlf ^= RC_DIR;
            TRH->tr_saddr[0] |= TR_RII;
        }
        RtlCopyMemory(Header + sizeof(TRHeader) + SourceRouteSize, ARPSNAP,
                   sizeof(SNAPHeader));
        HWType = net_short(ARP_HW_802);
        break;
    case NdisMediumFddi:
        FH = (FDDIHeader *) Header;
        FH->fh_pri = ARP_FDDI_PRI;
        RtlCopyMemory(FH->fh_daddr, HWAddress, ARP_802_ADDR_LENGTH);
        RtlCopyMemory(FH->fh_saddr, Interface->ai_addr, ARP_802_ADDR_LENGTH);
        RtlCopyMemory(Header + sizeof(FDDIHeader), ARPSNAP, sizeof(SNAPHeader));
        HWType = net_short(ARP_HW_ENET);
        break;
    case NdisMediumArcnet878_2:
        AH = (ARCNetHeader *) Header;
        AH->ah_saddr = Interface->ai_addr[0];
        AH->ah_daddr = *HWAddress;
        AH->ah_prot = ARP_ARCPROT_ARP;
        NdisAdjustBufferLength(Buffer, NdisBufferLength(Buffer) - ARCNET_ARPHEADER_ADJUSTMENT);
        HWType = net_short(ARP_HW_ARCNET);
        break;
    default:
        ASSERT(0);
        Interface->ai_outerrors++;
        FreeARPBuffer(Interface, Buffer);
        NdisFreePacket(Packet);
        return;
    }

    NdisChainBufferAtFront(Packet, Buffer);
    SendARPPacket(Interface, Packet, (ARPHeader *) (Header + Size), net_short(ARP_RESPONSE),
                  HWAddress, NULL, Destination, Src, HWType, TRUE);
}

//* ARPRemoveRCE - Remove an RCE from the ATE list.
//
//  This funtion removes a specified RCE from a given ATE. It assumes the ate_lock
//  is held by the caller.
//
//  Entry:  ATE     - ATE from which RCE is to be removed.
//          RCE     - RCE to be removed.
//
//  Returns:   Nothing
//
void
ARPRemoveRCE(ARPTableEntry * ATE, RouteCacheEntry * RCE)
{
    ARPContext *CurrentAC;              // Current ARP Context being checked.
#if DBG
    uint Found = FALSE;
#endif

    CurrentAC = (ARPContext *) (((char *)&ATE->ate_rce) -
                                offsetof(struct ARPContext, ac_next));

    while (CurrentAC->ac_next != (RouteCacheEntry *) NULL)
        if (CurrentAC->ac_next == RCE) {
            ARPContext *DummyAC = (ARPContext *) RCE->rce_context;
            CurrentAC->ac_next = DummyAC->ac_next;
            DummyAC->ac_ate = (ARPTableEntry *) NULL;
            DummyAC->ac_next = NULL;
#if DBG
            Found = TRUE;
#endif
            break;
        } else
            CurrentAC = (ARPContext *) CurrentAC->ac_next->rce_context;

    ASSERT(Found);
}

//* ARPLookup - Look up an entry in the ARP table.
//
//  Called to look up an entry in an interface's ARP table. If we find it, we'll
//  lock the entry and return a pointer to it, otherwise we return NULL. We
//  assume that the caller has the ARP table locked when we are called.
//
//  The ARP table entry is structured as a hash table of pointers to
//  ARPTableEntrys.After hashing on the IP address, a linear search is done to
//  lookup the entry.
//
//  If we find the entry, we lock it for the caller. If we don't find
//  the entry, we leave the ARP table locked so that the caller may atomically
//  insert a new entry without worrying about a duplicate being inserted between
//  the time the table was checked and the time the caller went to insert the
//  entry.
//
//  Entry:  Interface   - The interface to be searched upon.
//          Address     - The IP address we're looking up.
//
//  Returns: Pointer to ARPTableEntry if found, or NULL if not.
//
ARPTableEntry *
ARPLookup(ARPInterface * Interface, IPAddr Address)
{
    int i = ARP_HASH(Address);          // Index into hash table.
    ARPTableEntry *Current;             // Current ARP Table entry being
    // examined.

    Current = (*Interface->ai_ARPTbl)[i];

    while (Current != (ARPTableEntry *) NULL) {
        CTEGetLockAtDPC(&Current->ate_lock);
        if (IP_ADDR_EQUAL(Current->ate_dest, Address)) {    // Found a match.
            return Current;
        }
        CTEFreeLockFromDPC(&Current->ate_lock);
        Current = Current->ate_next;
    }
    // If we got here, we didn't find the entry. Leave the table locked and
    // return the handle.
    return(ARPTableEntry *) NULL;
}

//*     IsBCastOnIF- See it an address is a broadcast address on an interface.
//
//      Called to see if a particular address is a broadcast address on an
//      interface. We'll check the global, net, and subnet broadcasts. We assume
//      the caller holds the lock on the interface.
//
//      Entry:  Interface               - Interface to check.
//              Addr                    - Address to check.
//
//      Returns: TRUE if it it a broadcast, FALSE otherwise.
//
uint
IsBCastOnIF(ARPInterface * Interface, IPAddr Addr)
{
    IPAddr BCast;
    IPMask Mask;
    ARPIPAddr *ARPAddr;
    IPAddr LocalAddr;

    // First get the interface broadcast address.
    BCast = Interface->ai_bcast;

    // First check for global broadcast.
    if (IP_ADDR_EQUAL(BCast, Addr) || CLASSD_ADDR(Addr))
        return TRUE;

    // Now walk the local addresses, and check for net/subnet bcast on each
    // one.
    ARPAddr = &Interface->ai_ipaddr;
    do {
        // See if this one is valid.
        LocalAddr = ARPAddr->aia_addr;
        if (!IP_ADDR_EQUAL(LocalAddr, NULL_IP_ADDR)) {
            // He's valid.
            Mask = ARPAddr->aia_mask;

            // First check for subnet bcast.
            if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
                return TRUE;

            // Now check all nets broadcast.
            Mask = IPNetMask(LocalAddr);
            if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
                return TRUE;
        }
        ARPAddr = ARPAddr->aia_next;

    } while (ARPAddr != NULL);

    // If we're here, it's not a broadcast.
    return FALSE;

}

//* ARPSendBCast - See if this is a bcast or mcast frame, and send it.
//
//   Called when we have a packet to send and we want to see if it's a broadcast
//   or multicast frame on this interface. We'll search the local addresses and
//   see if we can determine if it is. If it is, we'll send it here. Otherwise
//   we return FALSE, and the caller will try to resolve the address.
//
//   Entry:  Interface       - A pointer to an AI structure.
//           Dest            - Destination of datagram.
//           Packet          - Packet to be sent.
//           Status          - Place to return status of send attempt.
//
//    Returns: TRUE if is was a bcast or mcast send, FALSE otherwise.
//
uint
ARPSendBCast(ARPInterface * Interface, IPAddr Dest, PNDIS_PACKET Packet,
             PNDIS_STATUS Status)
{
    uint IsBCast;
    CTELockHandle Handle;
    PNDIS_BUFFER ARPBuffer;             // ARP Header buffer.
    uchar *BufAddr;                     // Address of NDIS buffer
    NDIS_STATUS MyStatus;
    ENetHeader *Hdr;
    FDDIHeader *FHdr;
    TRHeader *TRHdr;
    SNAPHeader UNALIGNED *SNAPPtr;
    RC UNALIGNED *RCPtr;
    ARCNetHeader *AHdr;
    uint DataLength;
    ulong Proc;

    // Get the lock, and see if it's a broadcast.
    CTEGetLock(&Interface->ai_lock, &Handle);
    IsBCast = IsBCastOnIF(Interface, Dest);
    CTEFreeLock(&Interface->ai_lock, Handle);

    if (IsBCast) {
        if (Interface->ai_operstatus == INTERFACE_UP) {
            uchar Size;

            Size = Interface->ai_hdrsize + Interface->ai_snapsize;
            if (Interface->ai_media == NdisMedium802_5)
                Size += sizeof(RC);
            ARPBuffer = GetARPBuffer(Interface, &BufAddr, Size);
            if (ARPBuffer != NULL) {
                uint UNALIGNED *Temp;
                // Got the buffer we need.
                switch (Interface->ai_media) {
                case NdisMedium802_3:

                    Hdr = (ENetHeader *) BufAddr;
                    if (!CLASSD_ADDR(Dest))
                        RtlCopyMemory(Hdr, ENetBcst, ARP_802_ADDR_LENGTH);
                    else {
                        RtlCopyMemory(Hdr, ENetMcst, ARP_802_ADDR_LENGTH);
                        Temp = (uint UNALIGNED *) & Hdr->eh_daddr[2];
                        *Temp |= (Dest & ARP_MCAST_MASK);
                    }

                    RtlCopyMemory(Hdr->eh_saddr, Interface->ai_addr,
                               ARP_802_ADDR_LENGTH);

                    if (Interface->ai_snapsize == 0) {
                        // No snap on this interface, so just use ETypr.
                        Hdr->eh_type = net_short(ARP_ETYPE_IP);
                    } else {
                        ushort ShortDataLength;

                        // We're using SNAP. Find the size of the packet.
                        NdisQueryPacket(Packet, NULL, NULL, NULL,
                                        &DataLength);

                        ShortDataLength = (ushort) (DataLength +
                                                    sizeof(SNAPHeader));
                        Hdr->eh_type = net_short(ShortDataLength);
                        SNAPPtr = (SNAPHeader UNALIGNED *)
                                  (BufAddr + sizeof(ENetHeader));
                        RtlCopyMemory(SNAPPtr, ARPSNAP, sizeof(SNAPHeader));
                        SNAPPtr->sh_etype = net_short(ARP_ETYPE_IP);
                    }

                    break;

                case NdisMedium802_5:

                    // This is token ring. We'll have to mess around with
                    // source routing.


                    // for multicast - see RFC 1469.
                    // Handle RFC 1469.

                    if (!CLASSD_ADDR(Dest) || (!TRFunctionalMcast)) {

                        TRHdr = (TRHeader *) BufAddr;

                        RtlCopyMemory(TRHdr, TRBcst, offsetof(TRHeader, tr_saddr));
                        RtlCopyMemory(TRHdr->tr_saddr, Interface->ai_addr,
                                   ARP_802_ADDR_LENGTH);
                    } else {

                        TRHdr = (TRHeader *) BufAddr;

                        RtlCopyMemory(TRHdr, TRMcst, offsetof(TRHeader, tr_saddr));
                        RtlCopyMemory(TRHdr->tr_saddr, Interface->ai_addr,
                                   ARP_802_ADDR_LENGTH);
                    }

                    if (sIPAlwaysSourceRoute) {
                        TRHdr->tr_saddr[0] |= TR_RII;

                        RCPtr = (RC UNALIGNED *) ((uchar *) TRHdr + sizeof(TRHeader));
                        RCPtr->rc_blen = TrRii | RC_LEN;
                        RCPtr->rc_dlf = RC_BCST_LEN;
                        SNAPPtr = (SNAPHeader UNALIGNED *) ((uchar *) RCPtr + sizeof(RC));
                    } else {

                        //
                        // Adjust the size of the buffer to account for the
                        // fact that we don't have the RC field.
                        //
                        NdisAdjustBufferLength(ARPBuffer, (Size - sizeof(RC)));
                        SNAPPtr = (SNAPHeader UNALIGNED *) ((uchar *) TRHdr + sizeof(TRHeader));
                    }
                    RtlCopyMemory(SNAPPtr, ARPSNAP, sizeof(SNAPHeader));
                    SNAPPtr->sh_etype = net_short(ARP_ETYPE_IP);

                    break;
                case NdisMediumFddi:
                    FHdr = (FDDIHeader *) BufAddr;

                    if (!CLASSD_ADDR(Dest))
                        RtlCopyMemory(FHdr, FDDIBcst,
                                   offsetof(FDDIHeader, fh_saddr));
                    else {
                        RtlCopyMemory(FHdr, FDDIMcst,
                                   offsetof(FDDIHeader, fh_saddr));
                        Temp = (uint UNALIGNED *) & FHdr->fh_daddr[2];
                        *Temp |= (Dest & ARP_MCAST_MASK);
                    }

                    RtlCopyMemory(FHdr->fh_saddr, Interface->ai_addr,
                               ARP_802_ADDR_LENGTH);

                    SNAPPtr = (SNAPHeader UNALIGNED *) (BufAddr + sizeof(FDDIHeader));
                    RtlCopyMemory(SNAPPtr, ARPSNAP, sizeof(SNAPHeader));
                    SNAPPtr->sh_etype = net_short(ARP_ETYPE_IP);

                    break;
                case NdisMediumArcnet878_2:
                    AHdr = (ARCNetHeader *) BufAddr;
                    AHdr->ah_saddr = Interface->ai_addr[0];
                    AHdr->ah_daddr = 0;
                    AHdr->ah_prot = ARP_ARCPROT_IP;
                    break;
                default:
                    ASSERT(0);
                    *Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
                    FreeARPBuffer(Interface, ARPBuffer);
                    return FALSE;

                }

                (Interface->ai_outpcount[AI_NONUCAST_INDEX])++;
                Proc = KeGetCurrentProcessorNumber();
                Interface->ai_qlen[Proc].ai_qlen++;
                NdisChainBufferAtFront(Packet, ARPBuffer);
                NdisSend(&MyStatus, Interface->ai_handle, Packet);

                *Status = MyStatus;

                if (MyStatus != NDIS_STATUS_PENDING) {    // Send finished
                    // immediately.

                    if (MyStatus == NDIS_STATUS_SUCCESS) {
                        Interface->ai_outoctets += Packet->Private.TotalLength;
                    } else {
                        if (MyStatus == NDIS_STATUS_RESOURCES)
                            Interface->ai_outdiscards++;
                        else
                            Interface->ai_outerrors++;
                    }

                    Proc = KeGetCurrentProcessorNumber(); 
                    Interface->ai_qlen[Proc].ai_qlen--;
                    NdisUnchainBufferAtFront(Packet, &ARPBuffer);
                    FreeARPBuffer(Interface, ARPBuffer);
                }
            } else
                *Status = NDIS_STATUS_RESOURCES;
        } else
            *Status = NDIS_STATUS_ADAPTER_NOT_READY;

        return TRUE;

    } else
        return FALSE;
}

//* ARPResolveIP - resolves IP address
//
//  Called by IP layer when it needs to find physical address of the host
//  given the interface and dest IP address
//  Entry:  Interface   - A pointer to the AI structure.
//          ArpControlBlock      - A pointer to the BufDesc chain to be sent.
//
//  Returns: Status.
//

NDIS_STATUS
ARPResolveIP(void *Context, IPAddr Destination, void *ArpControlBlock)
{
    ARPInterface *ai = (ARPInterface *) Context;    // Set up as AI pointer.
    ARPControlBlock *ArpContB = (ARPControlBlock *) ArpControlBlock;

    ARPTableEntry *entry;   // Pointer to ARP tbl. entry
    CTELockHandle Handle;   // Lock handle
    NDIS_STATUS Status;
    uchar ate_state;

    CTEGetLock(&ai->ai_ARPTblLock, &Handle);

    // Check if we already got the mapping.

    if ((entry = ARPLookup(ai, Destination)) != NULL) {

        // Found a matching entry. ARPLookup returns with the ATE lock held.

        if (entry->ate_state != ARP_GOOD) {
            Status = NDIS_STATUS_FAILURE;
        } else {
            Status = FillARPControlBlock(ai, entry, ArpContB);
        }

        CTEFreeLockFromDPC(&entry->ate_lock);
        CTEFreeLock(&ai->ai_ARPTblLock, Handle);
        return Status;
    }
    // We need to send arp request.

    CTEFreeLock(&ai->ai_ARPTblLock, Handle);

    entry = CreateARPTableEntry(ai, Destination, &Handle, ArpContB);

    if (entry != NULL) {
        if (entry->ate_state <= ARP_RESOLVING) {    // Newly created entry.

            // Someone else could have raced in and created the entry between
            // the time we free the lock and the time we called
            // CreateARPTableEntry(). We check this by looking at the packet
            // on the entry. If there is no old packet we'll ARP. If there is,
            // we'll call ARPSendData to figure out what to do.

            if (entry->ate_packet == NULL) {

                ate_state = entry->ate_state;

                CTEFreeLock(&entry->ate_lock, Handle);

                SendARPRequest(ai, Destination, ate_state, NULL, TRUE);

                // We don't know the state of the entry - we've freed the lock
                // and yielded, and it could conceivably have timed out by now,
                // or SendARPRequest could have failed, etc. We could take the
                // lock, check the status from SendARPRequest, see if it's
                // still the same packet, and then make a decision on the
                // return value, but it's easiest just to return pending. If
                // SendARPRequest failed, the entry will time out anyway.

                return NDIS_STATUS_PENDING;

            } else {
                CTEFreeLock(&entry->ate_lock, Handle);
                return NDIS_STATUS_PENDING;
            }
        } else if (entry->ate_state == ARP_GOOD) {    // Yow! A valid entry.

            Status = FillARPControlBlock(ai, entry, ArpContB);

            //remove ArpContB from ate_resolveonly queue.

            if (entry->ate_resolveonly) {
                ARPControlBlock *TmpArpContB, *PrvArpContB = NULL;
                TmpArpContB = entry->ate_resolveonly;

                while (TmpArpContB && (ArpContB != TmpArpContB)) {
                    PrvArpContB = TmpArpContB;
                    TmpArpContB = TmpArpContB->next;
                }
                if (TmpArpContB == ArpContB) {
                    if (PrvArpContB) {
                        PrvArpContB->next = ArpContB->next;
                    } else {
                        entry->ate_resolveonly = NULL;
                    }
                }
            }

            CTEFreeLock(&entry->ate_lock, Handle);
            return Status;

        } else {                    // An invalid entry!
            CTEFreeLock(&entry->ate_lock, Handle);
            return NDIS_STATUS_RESOURCES;
        }
    } else {                             // Couldn't create an entry.
        return NDIS_STATUS_RESOURCES;
    }
}

//* ARPSendData - Send a frame to a specific destination address.
//
//  Called when we need to send a frame to a particular address, after the
//  ATE has been looked up. We take in an ATE and a packet, validate the state of the
//  ATE, and either send or ARP for the address if it's not done resolving. We assume
//  the lock on the ATE is held where we're called, and we'll free it before returning.
//
//  Entry:  Interface   - A pointer to the AI structure.
//          Packet      - A pointer to the BufDesc chain to be sent.
//          entry       - A pointer to the ATE for the send.
//          lhandle     - Pointer to a lock handle for the ATE.
//
//  Returns: Status of the transmit - success, an error, or pending.
//
NDIS_STATUS
ARPSendData(ARPInterface * Interface, PNDIS_PACKET Packet, ARPTableEntry * entry,
            CTELockHandle lhandle)
{
    PNDIS_BUFFER ARPBuffer = NULL;      // ARP Header buffer.
    uchar *BufAddr = NULL;              // Address of NDIS buffer
    NDIS_STATUS Status;                 // Status of send.
    ulong Proc;

#if BACK_FILL
    PMDL TmpMdl = NULL;
#endif

    if (Interface->ai_operstatus == INTERFACE_UP) {

        if (entry->ate_state == ARP_GOOD) {    // Entry is valid

            entry->ate_useticks = ArpCacheLife;

#if BACK_FILL
            if (Interface->ai_media == NdisMedium802_3) {

                NdisQueryPacket(Packet, NULL, NULL, &TmpMdl, NULL);

                if (TmpMdl->MdlFlags & MDL_NETWORK_HEADER) {

                    TmpMdl->MappedSystemVa = (PVOID) (((ULONG_PTR)
                                                      TmpMdl->MappedSystemVa) -
                                                      entry->ate_addrlength);

                    TmpMdl->ByteOffset -= entry->ate_addrlength;
                    TmpMdl->ByteCount += entry->ate_addrlength;
                    ARPBuffer = (PNDIS_BUFFER) TmpMdl;
                    BufAddr = TmpMdl->MappedSystemVa;
                } else {
                    TmpMdl = NULL;
                }
            }
            if (ARPBuffer == (PNDIS_BUFFER) NULL) {

                ARPBuffer = GetARPBufferAtDpcLevel(Interface, &BufAddr,
                                                   entry->ate_addrlength);
            }
#else
            ARPBuffer = GetARPBufferAtDpcLevel(Interface, &BufAddr,
                                               entry->ate_addrlength);
#endif
            if (ARPBuffer != (PNDIS_BUFFER) NULL) {
                // Everything's in good shape, copy header and send packet.

                (Interface->ai_outpcount[AI_UCAST_INDEX])++;
                Proc = KeGetCurrentProcessorNumber();                
                Interface->ai_qlen[Proc].ai_qlen++;
                RtlCopyMemory(BufAddr, entry->ate_addr, entry->ate_addrlength);

                // If we're on Ethernet, see if we're using SNAP here.
                if (Interface->ai_media == NdisMedium802_3 &&
                    entry->ate_addrlength != sizeof(ENetHeader)) {
                    ENetHeader *Header;
                    uint DataSize;
                    ushort ShortDataSize;

                    // We're apparently using SNAP on Ethernet. Query the
                    // packet for the size, and set the length properly.

                    NdisQueryPacket(Packet, NULL, NULL, NULL, &DataSize);

#if BACK_FILL
                    if (!TmpMdl) {
                        ShortDataSize = (ushort) (DataSize + sizeof(SNAPHeader));
                    } else {
                        ShortDataSize = (ushort) (DataSize - entry->ate_addrlength + sizeof(SNAPHeader));
                    }
#else // BACK_FILL
                    ShortDataSize = (ushort) (DataSize + sizeof(SNAPHeader));
#endif // !BACK_FILL
                    Header = (ENetHeader *) BufAddr;
                    Header->eh_type = net_short(ShortDataSize);

                    // In case backfill is enabled, we need to remember that
                    // a SNAP header was appended to the Ethernet header
                    // so we can restore the correct offsets in the MDL.
                    ((PacketContext*)
                     Packet->ProtocolReserved)->pc_common.pc_flags |=
                    PACKET_FLAG_SNAP;
                } else
                    ((PacketContext*)
                     Packet->ProtocolReserved)->pc_common.pc_flags &=
                    ~PACKET_FLAG_SNAP;
                CTEFreeLock(&entry->ate_lock, lhandle);

#if BACK_FILL
                if (TmpMdl == NULL) {
                    NdisChainBufferAtFront(Packet, ARPBuffer);
                }
#else
                NdisChainBufferAtFront(Packet, ARPBuffer);
#endif

                NdisSend(&Status, Interface->ai_handle, Packet);
                if (Status != NDIS_STATUS_PENDING) {    // Send finished
                    // immediately.

                    if (Status == NDIS_STATUS_SUCCESS) {
                        Interface->ai_outoctets += Packet->Private.TotalLength;
                    } else {
                        if (Status == NDIS_STATUS_RESOURCES)
                            Interface->ai_outdiscards++;
                        else
                            Interface->ai_outerrors++;
                    }

                    Proc = KeGetCurrentProcessorNumber(); 
                    Interface->ai_qlen[Proc].ai_qlen--;

#if BACK_FILL
                    if (TmpMdl == NULL) {
                        NdisUnchainBufferAtFront(Packet, &ARPBuffer);
                        FreeARPBuffer(Interface, ARPBuffer);
                    } else {
                        uint HdrSize;

                        HdrSize = sizeof(ENetHeader);

                        if (((PacketContext *)
                             Packet->ProtocolReserved)->pc_common.pc_flags &
                            PACKET_FLAG_SNAP)
                            HdrSize += Interface->ai_snapsize;

                        TmpMdl->MappedSystemVa = (PVOID) (((ULONG_PTR)
                                                          TmpMdl->MappedSystemVa) +
                                                          HdrSize);

                        TmpMdl->ByteOffset += HdrSize;
                        TmpMdl->ByteCount -= HdrSize;
                    }
#else
                    NdisUnchainBufferAtFront(Packet, &ARPBuffer);
                    FreeARPBuffer(Interface, ARPBuffer);
#endif

                }
                return Status;
            } else {                    // No buffer, free lock and return.

                CTEFreeLock(&entry->ate_lock, lhandle);
                Interface->ai_outdiscards++;
                return NDIS_STATUS_RESOURCES;
            }
        }
        // The IP addresses match, but the state of the ARP entry indicates
        // it's not valid. If the address is marked as resolving, we'll replace
        // the current cached packet with this one. If it's been more than
        // ARP_FLOOD_RATE ms. since we last sent an ARP request, we'll send
        // another one now.
        if (entry->ate_state <= ARP_RESOLVING) {
            PNDIS_PACKET OldPacket = entry->ate_packet;
            ulong Now = CTESystemUpTime();
            entry->ate_packet = Packet;
            if ((Now - entry->ate_valid) > ARP_FLOOD_RATE) {
                IPAddr Dest = entry->ate_dest;

                entry->ate_valid = Now;
                entry->ate_state = ARP_RESOLVING_GLOBAL;    // We've done this
                // at least once.

                CTEFreeLock(&entry->ate_lock, lhandle);
                SendARPRequest(Interface, Dest, ARP_RESOLVING_GLOBAL,
                               NULL, TRUE);    // Send a request.

            } else
                CTEFreeLock(&entry->ate_lock, lhandle);

            if (OldPacket)
                IPSendComplete(Interface->ai_context, OldPacket,
                               NDIS_STATUS_SUCCESS);

            return NDIS_STATUS_PENDING;
        } else {
            ASSERT(0);
            CTEFreeLock(&entry->ate_lock, lhandle);
            Interface->ai_outerrors++;
            return NDIS_STATUS_INVALID_PACKET;
        }
    } else {
        // Adapter is down. Just return the error.
        CTEFreeLock(&entry->ate_lock, lhandle);
        return NDIS_STATUS_ADAPTER_NOT_READY;
    }
}

//* CreateARPTableEntry - Create a new entry in the ARP table.
//
//  A function to put an entry into the ARP table. We allocate memory if we
//  need to.
//
//  The first thing to do is get the lock on the ARP table, and see if the
//  entry already exists. If it does, we're done. Otherwise we need to
//  allocate memory and create a new entry.
//
//  Entry:  Interface - Interface for ARP table.
//          Destination - Destination address to be mapped.
//          Handle - Pointer to lock handle for entry.
//
//  Returns: Pointer to newly created entry.
//
ARPTableEntry *
CreateARPTableEntry(ARPInterface * Interface, IPAddr Destination,
                    CTELockHandle * Handle, void *UserArp)
{
    ARPTableEntry *NewEntry, *Entry;
    CTELockHandle TableHandle;
    int i = ARP_HASH(Destination);
    int Size;

    // First look for it, and if we don't find it return try to create one.
    CTEGetLock(&Interface->ai_ARPTblLock, &TableHandle);
    if ((Entry = ARPLookup(Interface, Destination)) != NULL) {
        CTEFreeLockFromDPC(&Interface->ai_ARPTblLock);
        *Handle = TableHandle;

        // if we are using arp api entry, turn off the
        // userarp flag so that handle arp need not free it.
        if (!UserArp && Entry->ate_userarp) {
            Entry->ate_userarp = 0;
        }

        if (UserArp) {
            if (Entry->ate_resolveonly) {
                // chain the current request at the end of the new
                // before using the new request as the head.
                //
                ((ARPControlBlock *)UserArp)->next = Entry->ate_resolveonly;
            }
            // link the new request.
            //
            Entry->ate_resolveonly = (ARPControlBlock *)UserArp;
        }

        return Entry;
    }
    // Allocate memory for the entry. If we can't, fail the request.
    Size = sizeof(ARPTableEntry) - 1 +
           (Interface->ai_media == NdisMedium802_5 ?
            ARP_MAX_MEDIA_TR : (Interface->ai_hdrsize +
                                Interface->ai_snapsize));

    if ((NewEntry = CTEAllocMemN(Size, 'QiCT')) == (ARPTableEntry *) NULL) {
        CTEFreeLock(&Interface->ai_ARPTblLock, TableHandle);
        return (ARPTableEntry *) NULL;
    }

    RtlZeroMemory(NewEntry, Size);
    NewEntry->ate_dest = Destination;
    if (Interface->ai_media != NdisMedium802_5 || sArpAlwaysSourceRoute) {
        NewEntry->ate_state = ARP_RESOLVING_GLOBAL;
    } else {
        NewEntry->ate_state = ARP_RESOLVING_LOCAL;
    }

    if (UserArp) {
        NewEntry->ate_userarp = 1;
    }

    NewEntry->ate_resolveonly = (ARPControlBlock *)UserArp;
    NewEntry->ate_valid = CTESystemUpTime();
    NewEntry->ate_useticks = ArpCacheLife;
    CTEInitLock(&NewEntry->ate_lock);

    // Entry does not exist. Insert the new entry into the table at the
    // appropriate spot.
    //
    NewEntry->ate_next = (*Interface->ai_ARPTbl)[i];
    (*Interface->ai_ARPTbl)[i] = NewEntry;
    Interface->ai_count++;
    CTEGetLockAtDPC(&NewEntry->ate_lock);
    CTEFreeLockFromDPC(&Interface->ai_ARPTblLock);
    *Handle = TableHandle;
    return NewEntry;
}

//* ARPTransmit - Send a frame.
//
//  The main ARP transmit routine, called by the upper layer. This routine
//  takes as input a buf desc chain, RCE, and size. We validate the cached
//  information in the RCE. If it is valid, we use it to send the frame.
//  Otherwise we do a table lookup. If we find it in the table, we'll update
//  the RCE and continue. Otherwise we'll queue the packet and start an ARP
//  resolution.
//
//  Entry:  Context     - A pointer to the AI structure.
//          Packet      - A pointer to the BufDesc chain to be sent.
//          Destination - IP address of destination we're trying to reach,
//          RCE         - A pointer to an RCE which may have cached information.
//
//  Returns: Status of the transmit - success, an error, or pending.
//
NDIS_STATUS
__stdcall
ARPTransmit(void *Context, PNDIS_PACKET * PacketArray, uint NumberOfPackets,
            IPAddr Destination, RouteCacheEntry * RCE, void *LinkCtxt)
{
    ARPInterface *ai = (ARPInterface *) Context;    // Set up as AI pointer.
    ARPContext *ac = NULL;              // ARP context pointer.
    ARPTableEntry *entry;               // Pointer to ARP tbl. entry
    CTELockHandle Handle;               // Lock handle
    NDIS_STATUS Status;
    PNDIS_PACKET Packet = *PacketArray;

    //
    // For now, we get only one packet...
    //
    DBG_UNREFERENCED_PARAMETER(NumberOfPackets);
    UNREFERENCED_PARAMETER(LinkCtxt);

    ASSERT(NumberOfPackets == 1);

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_TX,
             (DTEXT("+ARPTransmit(%x, %x, %d, %x, %x, %x)\n"),
              Context, PacketArray, NumberOfPackets,
              Destination, RCE, LinkCtxt));

    if (ai->ai_operstatus != INTERFACE_UP) {
        return NDIS_STATUS_ADAPTER_NOT_READY;
    }

    CTEGetLock(&ai->ai_ARPTblLock, &Handle);
    if (RCE != (RouteCacheEntry *) NULL) {    // Have a valid RCE.

        ac = (ARPContext *) RCE->rce_context;    // Get pointer to context

        entry = ac->ac_ate;
        if (entry != (ARPTableEntry *) NULL) {    // Have a valid ATE.

            CTEGetLockAtDPC(&entry->ate_lock);    // Lock this structure

            if (IP_ADDR_EQUAL(entry->ate_dest, Destination)) {
                uint refresh,status;
                uchar state = entry->ate_state;

                refresh= entry->ate_refresh;

                CTEFreeLockFromDPC(&ai->ai_ARPTblLock);
                status = ARPSendData(ai, Packet, entry, Handle);    // Send the data
                if (refresh) {
                    if (sArpAlwaysSourceRoute) {
                        //
                        // If Always source route is on,
                        // the state should ve resolving_global
                        // so that SendArpRequest will send SR
                        // header in case of 802.5.
                        //
                        state = ARP_RESOLVING_GLOBAL;
                    }
                    SendARPRequest(ai, Destination, state, NULL, TRUE);
                }
                return status;
            }

            // We have an RCE that identifies the wrong ATE. We'll free it from
            // this list and try and find an ATE that is valid.
            ARPRemoveRCE(entry, RCE);
            CTEFreeLockFromDPC(&entry->ate_lock);
            // Fall through to 'no valid entry' code.
        }
    }

    // Here we have no valid ATE, either because the RCE is NULL or the ATE
    // specified by the RCE was invalid. We'll try and find one in the table. If
    // we find one, we'll fill in this RCE and send the packet. Otherwise we'll
    // try to create one. At this point we hold the lock on the ARP table.

    if ((entry = ARPLookup(ai, Destination)) != (ARPTableEntry *) NULL) {
        // Found a matching entry. ARPLookup returns with the ATE lock held.
        if (RCE != (RouteCacheEntry *) NULL) {
            ac->ac_next = entry->ate_rce;    // Fill in context for next time.
            entry->ate_rce = RCE;
            ac->ac_ate = entry;
        }

        DEBUGMSG(DBG_INFO && DBG_ARP && DBG_TX,
                 (DTEXT("ARPTx: ATE %x - calling ARPSendData\n"), entry));

        CTEFreeLockFromDPC(&ai->ai_ARPTblLock);
        return ARPSendData(ai, Packet, entry, Handle);
    }

    // No valid entry in the ARP table. First we'll see if we're sending to a
    // broadcast address or multicast address. If not, we'll try to create
    // an entry in the table and get an ARP resolution going. ARPLookup returns
    // with the table lock held when it fails, we'll free it here.
    CTEFreeLock(&ai->ai_ARPTblLock, Handle);

    if (ARPSendBCast(ai, Destination, Packet, &Status)) {
        return Status;
    }

    entry = CreateARPTableEntry(ai, Destination, &Handle, 0);
    if (entry != NULL) {
        if (entry->ate_state <= ARP_RESOLVING) {    // Newly created entry.

            uchar state = entry->ate_state;

            DEBUGMSG(DBG_INFO && DBG_ARP && DBG_TX,
                     (DTEXT("ARPTx: Created ATE %x\n"), entry));

            // Someone else could have raced in and created the entry between
            // the time we free the lock and the time we called
            // CreateARPTableEntry(). We check this by looking at the packet
            // on the entry. If there is no old packet we'll ARP. If there is,
            // we'll call ARPSendData to figure out what to do.

            if (entry->ate_packet == NULL) {
                entry->ate_packet = Packet;

                DEBUGMSG(DBG_INFO && DBG_ARP && DBG_TX,
                         (DTEXT("ARPTx: ATE %x - calling SendARPRequest\n"), entry));

                CTEFreeLock(&entry->ate_lock, Handle);
                SendARPRequest(ai, Destination, state, NULL, TRUE);
                // We don't know the state of the entry - we've freed the lock
                // and yielded, and it could conceivably have timed out by now,
                // or SendARPRequest could have failed, etc. We could take the
                // lock, check the status from SendARPRequest, see if it's
                // still the same packet, and then make a decision on the
                // return value, but it's easiest just to return pending. If
                // SendARPRequest failed, the entry will time out anyway.
                return NDIS_STATUS_PENDING;
            } else {
                return ARPSendData(ai, Packet, entry, Handle);
            }
        } else if (entry->ate_state == ARP_GOOD) {   // Yow! A valid entry.
            return ARPSendData(ai, Packet, entry, Handle);
        } else {                        // An invalid entry!
            CTEFreeLock(&entry->ate_lock, Handle);
            return NDIS_STATUS_RESOURCES;
        }
    } else {                            // Couldn't create an entry.
        DEBUGMSG(DBG_ERROR && DBG_ARP,
                 (DTEXT("ARPTx: Failed to create ATE.\n")));
        return NDIS_STATUS_RESOURCES;
    }
}

//* RemoveARPTableEntry - Delete an entry from the ARP table.
//
//  This is a simple utility function to delete an entry from the ATP table. We
//  assume locks are held on both the table and the entry.
//
//  Entry:  Previous    - The entry immediately before the one to be deleted.
//          Entry       - The entry to be deleted.
//
//  Returns: Nothing.
//
void
RemoveARPTableEntry(ARPTableEntry * Previous, ARPTableEntry * Entry)
{
    RouteCacheEntry *RCE;               // Pointer to route cache entry
    ARPContext *AC;

    RCE = Entry->ate_rce;
    // Loop through and invalidate all RCEs on this ATE.
    while (RCE != (RouteCacheEntry *) NULL) {
        AC = (ARPContext *) RCE->rce_context;
        AC->ac_ate = (ARPTableEntry *) NULL;
        RCE = AC->ac_next;
    }

    // Splice this guy out of the list.
    Previous->ate_next = Entry->ate_next;
}

//* ARPFlushATE - removes ARP Table entry for given dest address
//
//  Called by IP layer when it needs to flush the link layer address from arp
//  cache
//  Entry:  Interface   - A pointer to the AI structure.
//          Destination - Destination Address whose Xlation needs to be removed
//
//  Returns: TRUE if the entry was found and flushed, FALSE otherwise
//

BOOLEAN
ARPFlushATE(void *Context, IPAddr Address)
{
    ARPInterface *ai = (ARPInterface *) Context;
    CTELockHandle lhandle, tlhandle;
    ARPTable *Table;
    ARPTableEntry *Current, *Previous;
    int i = ARP_HASH(Address);
    PNDIS_PACKET OldPacket = NULL;

    CTEGetLock(&ai->ai_ARPTblLock, &tlhandle);
    Table = ai->ai_ARPTbl;

    Current = (*Table)[i];
    Previous = (ARPTableEntry *) ((uchar *) & ((*Table)[i]) - offsetof(struct ARPTableEntry, ate_next));

    while (Current != (ARPTableEntry *) NULL) {
        CTEGetLock(&Current->ate_lock, &lhandle);
        if (IP_ADDR_EQUAL(Current->ate_dest, Address)) {    // Found a match.

            if (Current->ate_resolveonly) {
                ARPControlBlock *ArpContB, *TmpArpContB;

                ArpContB = Current->ate_resolveonly;

                while (ArpContB) {
                    ArpRtn rtn;
                    rtn = (ArpRtn) ArpContB->CompletionRtn;
                    ArpContB->status = (ULONG) STATUS_UNSUCCESSFUL;
                    TmpArpContB = ArpContB->next;
                    (*rtn) (ArpContB, (IP_STATUS) STATUS_UNSUCCESSFUL);
                    ArpContB = TmpArpContB;
                }

                Current->ate_resolveonly = NULL;
            }

            RemoveARPTableEntry(Previous, Current);

            CTEFreeLock(&Current->ate_lock, lhandle);

            OldPacket = Current->ate_packet;

            CTEFreeLock(&ai->ai_ARPTblLock, tlhandle);

            if (OldPacket) {
                IPSendComplete(ai->ai_context, OldPacket, NDIS_STATUS_SUCCESS);
            }
            CTEFreeMem(Current);
            return TRUE;
        }
        CTEFreeLock(&Current->ate_lock, lhandle);
        Previous = Current;
        Current = Current->ate_next;
    }

    CTEFreeLock(&ai->ai_ARPTblLock, tlhandle);
    return FALSE;

}

//* ARPFlushAllATE - removes all ARP Table entries.
//
//  Entry:  Interface   - A pointer to the AI structure.
//
//  Returns: None
//

void
ARPFlushAllATE(void *Context)
{
    ARPInterface *ai = (ARPInterface *) Context;
    CTELockHandle tlhandle;
    ARPTable *Table;
    int i;
    ARPTableEntry *ATE;
    PNDIS_PACKET PList = (PNDIS_PACKET) NULL;

    CTEGetLock(&ai->ai_ARPTblLock, &tlhandle);
    Table = ai->ai_ARPTbl;

    if (Table != NULL) {
        for (i = 0; i < ARP_TABLE_SIZE; i++) {
            while ((*Table)[i] != NULL) {
                ATE = (*Table)[i];
                if (ATE->ate_resolveonly) {
                    ARPControlBlock *ArpContB, *TmpArpContB;

                    ArpContB = ATE->ate_resolveonly;

                    while (ArpContB) {
                        ArpRtn rtn;
                        rtn = (ArpRtn) ArpContB->CompletionRtn;
                        ArpContB->status = (ULONG) STATUS_UNSUCCESSFUL;
                        TmpArpContB = ArpContB->next;
                        (*rtn) (ArpContB, (IP_STATUS) STATUS_UNSUCCESSFUL);
                        ArpContB = TmpArpContB;
                    }

                    ATE->ate_resolveonly = NULL;

                }

                // Acquire ate_lock to ensure exclusive access to the ATE.
                CTEGetLockAtDPC(&ATE->ate_lock);
                RemoveARPTableEntry(STRUCT_OF(ARPTableEntry, &((*Table)[i]), ate_next),
                                    ATE);
                CTEFreeLockFromDPC(&ATE->ate_lock);

                if (ATE->ate_packet) {
                    ((PacketContext *) ATE->ate_packet->ProtocolReserved)->pc_common.pc_link = PList;
                    PList = ATE->ate_packet;
                }
                CTEFreeMem(ATE);
            }
        }
    }
    CTEFreeLock(&ai->ai_ARPTblLock, tlhandle);

    while (PList != (PNDIS_PACKET) NULL) {
        PNDIS_PACKET Packet = PList;

        PList = ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_link;
        IPSendComplete(ai->ai_context, Packet, NDIS_STATUS_SUCCESS);
    }

}

//* ARPXferData - Transfer data on behalf on an upper later protocol.
//
//  This routine is called by the upper layer when it needs to transfer data
//  from an NDIS driver. We just map his call down.
//
//  Entry:  Context     - Context value we gave to IP (really a pointer to an AI).
//          MACContext  - Context value MAC gave us on a receive.
//          MyOffset    - Packet offset we gave to the protocol earlier.
//          ByteOffset  - Byte offset into packet protocol wants transferred.
//          BytesWanted - Number of bytes to transfer.
//          Packet      - Pointer to packet to be used for transferring.
//          Transferred - Pointer to where to return bytes transferred.
//
//  Returns: NDIS_STATUS of command.
//
NDIS_STATUS
__stdcall
ARPXferData(void *Context, NDIS_HANDLE MACContext, uint MyOffset,
            uint ByteOffset, uint BytesWanted, PNDIS_PACKET Packet, uint * Transferred)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    NDIS_STATUS Status;

    NdisTransferData(&Status, Interface->ai_handle, MACContext, ByteOffset + MyOffset,
                     BytesWanted, Packet, Transferred);

    return Status;
}

//* ARPUpdateOperStatus - Update the OperStatus and LastChange values.
//
//  Called whenever ai_adminstate or ai_mediastatus changes, to preserve
//  the invariant that ai_operstatus should only be up if the admin
//  status is up and media sense is present.
//
//  Entry:  Interface   - Interface to update.
//
//  Returns: Nothing.
//
__inline
void
ARPUpdateOperStatus(ARPInterface *Interface)
{
    uchar NewOperStatus;

    if (Interface->ai_operstatus == INTERFACE_UNINIT) {
        return;
    }

    if ((Interface->ai_adminstate == IF_STATUS_DOWN) ||
        (Interface->ai_mediastatus == FALSE)) {
        NewOperStatus = INTERFACE_DOWN;
    } else {
        NewOperStatus = INTERFACE_UP;
    }

    if (Interface->ai_operstatus != NewOperStatus) {
        Interface->ai_operstatus = NewOperStatus;
        Interface->ai_lastchange = GetTimeTicks();
    }
}

//* ARPClose - Close an adapter.
//
//  Called by IP when it wants to close an adapter, presumably due to an error condition.
//  We'll close the adapter, but we won't free any memory.
//
//  Entry:  Context     - Context value we gave him earlier.
//
//  Returns: Nothing.
//
void
__stdcall
ARPClose(void *Context)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    NDIS_STATUS Status;
    CTELockHandle LockHandle;
    NDIS_HANDLE Handle;

    Interface->ai_mediastatus = FALSE;
    ARPUpdateOperStatus(Interface);

    //
    // Mark the interface as going away so it will disappear from the
    // entity list.
    //
    Interface->ai_operstatus = INTERFACE_UNINIT;

    CTEInitBlockStruc(&Interface->ai_block);

    CTEGetLock(&Interface->ai_lock, &LockHandle);
    if (Interface->ai_handle != (NDIS_HANDLE) NULL) {
        Handle = Interface->ai_handle;
        CTEFreeLock(&Interface->ai_lock, LockHandle);

        NdisCloseAdapter(&Status, Handle);

        if (Status == NDIS_STATUS_PENDING) {
            Status = CTEBlock(&Interface->ai_block);
        }
        Interface->ai_handle = NULL;
    } else {
        CTEFreeLock(&Interface->ai_lock, LockHandle);
    }
}

//* ARPInvalidate - Notification that an RCE is invalid.
//
//  Called by IP when an RCE is closed or otherwise invalidated. We look up
//  the ATE for the specified RCE, and then remove the RCE from the ATE list.
//
//  Entry:  Context     - Context value we gave him earlier.
//          RCE         - RCE to be invalidated
//
//  Returns: Nothing.
//
void
__stdcall
ARPInvalidate(void *Context, RouteCacheEntry *RCE)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    ARPTableEntry *ATE;
    CTELockHandle Handle;
    ARPContext *AC = (ARPContext *) RCE->rce_context;

    CTEGetLock(&Interface->ai_ARPTblLock, &Handle);

#if DBG
    if (!(RCE->rce_flags & RCE_CONNECTED)) {

        ARPTableEntry *tmpATE;

        ATE = ARPLookup(Interface, RCE->rce_dest);

        if (ATE != NULL) {
            tmpATE = ATE;
            while (ATE) {
                if (ATE->ate_rce == RCE) {
                    DbgBreakPoint();
                }
                ATE = ATE->ate_next;
            }
            CTEFreeLockFromDPC(&Interface->ai_ARPTblLock);
            CTEFreeLock(&tmpATE->ate_lock, Handle);

            return;
        }
    }
#endif

    if ((ATE = AC->ac_ate) == (ARPTableEntry *) NULL) {
        CTEFreeLock(&Interface->ai_ARPTblLock, Handle);    // No matching ATE.

        return;
    }
    CTEGetLockAtDPC(&ATE->ate_lock);
    ARPRemoveRCE(ATE, RCE);
    RtlZeroMemory(RCE->rce_context, RCE_CONTEXT_SIZE);
    CTEFreeLockFromDPC(&Interface->ai_ARPTblLock);
    CTEFreeLock(&ATE->ate_lock, Handle);
}

//*     ARPSetMCastList - Set the multicast address list for the adapter.
//
//      Called to try and set the multicast reception list for the adapter.
//      We allocate a buffer big enough to hold the new address list, and format
//      the address list into the buffer. Then we submit the NDIS request to set
//      the list. If we can't set the list because the multicast address list is
//      full we'll put the card into all multicast mode.
//
//      Input:  Interface               - Interface on which to set list.
//
//      Returns: NDIS_STATUS of attempt.
//
NDIS_STATUS
ARPSetMCastList(ARPInterface * Interface)
{
    CTELockHandle Handle;
    uchar *MCastBuffer, *CurrentPtr;
    uint MCastSize;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    uint i;
    ARPMCastAddr *AddrPtr;
    IPAddr UNALIGNED *Temp;

    CTEGetLock(&Interface->ai_lock, &Handle);
    MCastSize = Interface->ai_mcastcnt * ARP_802_ADDR_LENGTH;
    if (MCastSize != 0)
        MCastBuffer = CTEAllocMemN(MCastSize, 'RiCT');
    else
        MCastBuffer = NULL;

    if (MCastBuffer != NULL || MCastSize == 0) {
        // Got the buffer. Loop through, building the list.
        AddrPtr = Interface->ai_mcast;

        CurrentPtr = MCastBuffer;

        for (i = 0; i < Interface->ai_mcastcnt; i++) {
            ASSERT(AddrPtr != NULL);

            if (Interface->ai_media == NdisMedium802_3) {

                RtlCopyMemory(CurrentPtr, ENetMcst, ARP_802_ADDR_LENGTH);
                Temp = (IPAddr UNALIGNED *) (CurrentPtr + 2);
                *Temp |= AddrPtr->ama_addr;
            } else if ((Interface->ai_media == NdisMedium802_5) & TRFunctionalMcast) {
                RtlCopyMemory(CurrentPtr, TRNetMcst, ARP_802_ADDR_LENGTH - 2);
                MCastSize = 4;
            } else if (Interface->ai_media == NdisMediumFddi) {
                RtlCopyMemory(CurrentPtr, ((FDDIHeader *) FDDIMcst)->fh_daddr,
                           ARP_802_ADDR_LENGTH);
                Temp = (IPAddr UNALIGNED *) (CurrentPtr + 2);
                *Temp |= AddrPtr->ama_addr;
            } else
                ASSERT(0);

            CurrentPtr += ARP_802_ADDR_LENGTH;
            AddrPtr = AddrPtr->ama_next;
        }

        CTEFreeLock(&Interface->ai_lock, Handle);

        // We're built the list. Now give it to the driver to handle.
        if (Interface->ai_media == NdisMedium802_3) {
            Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                   OID_802_3_MULTICAST_LIST, MCastBuffer, MCastSize, NULL, TRUE);
        } else if ((Interface->ai_media == NdisMedium802_5) & TRFunctionalMcast) {
            if (!(Interface->ai_pfilter & NDIS_PACKET_TYPE_FUNCTIONAL)) {
                Interface->ai_pfilter |= NDIS_PACKET_TYPE_FUNCTIONAL;
                Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                       OID_GEN_CURRENT_PACKET_FILTER,
                                       &Interface->ai_pfilter,
                                       sizeof(uint), NULL, TRUE);
            }
            Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                   OID_802_5_CURRENT_FUNCTIONAL, MCastBuffer, MCastSize, NULL,
                                   TRUE);

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                      "SetMcast after OID-- TR mcast address on %x status %x\n",
                      Interface, Status));

        } else if (Interface->ai_media == NdisMediumFddi) {
            Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                   OID_FDDI_LONG_MULTICAST_LIST, MCastBuffer, MCastSize, NULL,
                                   TRUE);
        } else
            ASSERT(0);

        if (MCastBuffer != NULL) {
            CTEFreeMem(MCastBuffer);
        }
        if (Status == NDIS_STATUS_MULTICAST_FULL) {
            // Multicast list is full. Try to set the filter to all multicasts.
            Interface->ai_pfilter |= NDIS_PACKET_TYPE_ALL_MULTICAST;

            Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                                   OID_GEN_CURRENT_PACKET_FILTER, &Interface->ai_pfilter,
                                   sizeof(uint), NULL, TRUE);
        }
    } else {
        CTEFreeLock(&Interface->ai_lock, Handle);
        Status = NDIS_STATUS_RESOURCES;
    }

    return Status;

}

//*     ARPFindMCast - Find a multicast address structure on our list.
//
//      Called as a utility to find a multicast address structure. If we find
//      it, we return a pointer to it and it's predecessor. Otherwise we return
//      NULL. We assume the caller holds the lock on the interface already.
//
//      Input:  Interface               - Interface to search.
//              Addr                    - Addr to find.
//              Prev                    - Where to return previous pointer.
//
//      Returns: Pointer if we find one, NULL otherwise.
//
ARPMCastAddr *
ARPFindMCast(ARPInterface * Interface, IPAddr Addr, ARPMCastAddr ** Prev)
{
    ARPMCastAddr *AddrPtr, *PrevPtr;

    PrevPtr = STRUCT_OF(ARPMCastAddr, &Interface->ai_mcast, ama_next);
    AddrPtr = PrevPtr->ama_next;
    while (AddrPtr != NULL) {
        if (IP_ADDR_EQUAL(AddrPtr->ama_addr, Addr))
            break;
        else {
            PrevPtr = AddrPtr;
            AddrPtr = PrevPtr->ama_next;
        }
    }

    *Prev = PrevPtr;
    return AddrPtr;
}

//*     ARPDelMCast - Delete a multicast address.
//
//      Called when we want to delete a multicast address. We look for a matching
//      (masked) address. If we find one, we'll dec. the reference count and if
//      it goes to 0 we'll pull him from the list and reset the multicast list.
//
//      Input:  Interface                       - Interface on which to act.
//                      Addr                            - Address to be deleted.
//
//      Returns: TRUE if it worked, FALSE otherwise.
//
uint
ARPDelMCast(ARPInterface * Interface, IPAddr Addr)
{
    ARPMCastAddr *AddrPtr, *PrevPtr;
    CTELockHandle Handle;
    uint Status = TRUE;

    // When we support TR (RFC 1469) fully we'll need to change this.
    if (Interface->ai_media == NdisMedium802_3 ||
        Interface->ai_media == NdisMediumFddi ||
        (Interface->ai_media == NdisMedium802_5 && TRFunctionalMcast)) {
        // This is an interface that supports mcast addresses.
        Addr &= ARP_MCAST_MASK;

        CTEGetLock(&Interface->ai_lock, &Handle);
        AddrPtr = ARPFindMCast(Interface, Addr, &PrevPtr);
        if (AddrPtr != NULL) {
            // We found one. Dec. his refcnt, and if it's 0 delete him.
            (AddrPtr->ama_refcnt)--;
            if (AddrPtr->ama_refcnt == 0) {
                // He's done.
                PrevPtr->ama_next = AddrPtr->ama_next;
                (Interface->ai_mcastcnt)--;
                CTEFreeLock(&Interface->ai_lock, Handle);
                CTEFreeMem(AddrPtr);
                ARPSetMCastList(Interface);
                CTEGetLock(&Interface->ai_lock, &Handle);
            }
        } else
            Status = FALSE;

        CTEFreeLock(&Interface->ai_lock, Handle);
    }

    return Status;
}
//*     ARPAddMCast - Add a multicast address.
//
//      Called when we want to start receiving a multicast address. We'll mask
//      the address and look it up in our address list. If we find it, we'll just
//      bump the reference count. Otherwise we'll try to create one and put him
//      on the list. In that case we'll need to set the multicast address list for
//      the adapter.
//
//      Input:  Interface               - Interface to set on.
//              Addr                    - Address to set.
//
//      Returns: TRUE if we succeed, FALSE if we fail.
//
uint
ARPAddMCast(ARPInterface * Interface, IPAddr Addr)
{
    ARPMCastAddr *AddrPtr, *PrevPtr;
    CTELockHandle Handle;
    uint Status = TRUE;

    if (Interface->ai_operstatus != INTERFACE_UP) {
        return FALSE;
    }

    // Currently we don't do anything with token ring, since we send
    // all mcasts as TR broadcasts. When we comply with RFC 1469 we'll need to
    // fix this.
    if ((Interface->ai_media == NdisMedium802_3) ||
        (Interface->ai_media == NdisMediumFddi) ||
        ((Interface->ai_media == NdisMedium802_5) && TRFunctionalMcast)) {

        Addr &= ARP_MCAST_MASK;

        CTEGetLock(&Interface->ai_lock, &Handle);
        AddrPtr = ARPFindMCast(Interface, Addr, &PrevPtr);
        if (AddrPtr != NULL) {
            // We found one, just bump refcnt.
            (AddrPtr->ama_refcnt)++;
        } else {
            // Didn't find one. Allocate space for one, link him in, and
            // try to set the list.
            AddrPtr = CTEAllocMemN(sizeof(ARPMCastAddr), 'SiCT');
            if (AddrPtr != NULL) {
                // Got one. Link him in.
                AddrPtr->ama_addr = Addr;
                AddrPtr->ama_refcnt = 1;
                AddrPtr->ama_next = Interface->ai_mcast;
                Interface->ai_mcast = AddrPtr;
                (Interface->ai_mcastcnt)++;
                CTEFreeLock(&Interface->ai_lock, Handle);

                // Now try to set the list.
                if (ARPSetMCastList(Interface) != NDIS_STATUS_SUCCESS) {
                    // Couldn't set the list. Call the delete routine to delete
                    // the address we just tried to set.
                    Status = ARPDelMCast(Interface, Addr);
                    ASSERT(Status);
                    Status = FALSE;
                }
                CTEGetLock(&Interface->ai_lock, &Handle);
            } else
                Status = FALSE;         // Couldn't get memory.

        }

        // We've done out best. Free the lock and return.
        CTEFreeLock(&Interface->ai_lock, Handle);
    }
    return Status;
}

//* ARPAddAddr - Add an address to the ARP table.
//
//  This routine is called by IP to add an address as a local address, or
//      or specify the broadcast address for this interface.
//
//  Entry:  Context  - Context we gave IP earlier (really an ARPInterface ptr)
//          Type        - Type of address (local, p-arp, multicast, or
//                                                      broadcast).
//          Address     - Broadcast IP address to be added.
//                      Mask            - Mask for address.
//
//  Returns: 0 if we failed, non-zero otherwise
//
uint
__stdcall
ARPAddAddr(void *Context, uint Type, IPAddr Address, IPMask Mask, void *Context2)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    CTELockHandle Handle;

    if (Type != LLIP_ADDR_LOCAL && Type != LLIP_ADDR_PARP) {
        // Not a local address, must be broadcast or multicast.

        if (Type == LLIP_ADDR_BCAST) {
            Interface->ai_bcast = Address;
            return TRUE;
        } else if (Type == LLIP_ADDR_MCAST) {
            return ARPAddMCast(Interface, Address);
        } else
            return FALSE;
    } else {                            // This is a local address.

        CTEGetLock(&Interface->ai_lock, &Handle);
        if (Type != LLIP_ADDR_PARP) {
            uint RetStatus = FALSE;
            uint ArpForSelf = FALSE;

            if (IP_ADDR_EQUAL(Interface->ai_ipaddr.aia_addr, 0)) {
                Interface->ai_ipaddr.aia_addr = Address;
                Interface->ai_ipaddr.aia_mask = Mask;
                Interface->ai_ipaddr.aia_age = ArpRetryCount;
                if (Interface->ai_operstatus == INTERFACE_UP) {
                    // When ArpRetryCount is 0, we'll return immediately
                    // below, so don't save completion context
                    Interface->ai_ipaddr.aia_context = (ArpRetryCount > 0)?
                        Context2 : NULL;
                    ArpForSelf = TRUE;
                } else {
                    Interface->ai_ipaddr.aia_context = NULL;
                }
                RetStatus = TRUE;
            } else {
                ARPIPAddr *NewAddr;

                NewAddr = CTEAllocMemNBoot(sizeof(ARPIPAddr), 'TiCT');
                if (NewAddr != (ARPIPAddr *) NULL) {
                    NewAddr->aia_addr = Address;
                    NewAddr->aia_mask = Mask;
                    NewAddr->aia_age = ArpRetryCount;
                    NewAddr->aia_next = Interface->ai_ipaddr.aia_next;
                    if (Interface->ai_operstatus == INTERFACE_UP) {
                        // When ArpRetryCount is 0, we'll return immediately
                        // below, so don't save completion context
                        NewAddr->aia_context = (ArpRetryCount > 0)?
                            Context2 : NULL;
                        ArpForSelf = TRUE;
                    } else {
                        NewAddr->aia_context = NULL;
                    }

                    Interface->ai_ipaddr.aia_next = NewAddr;
                    RetStatus = TRUE;
                }
            }

            if (RetStatus) {
                Interface->ai_ipaddrcnt++;
                if (Interface->ai_telladdrchng) {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                    AddrNotifyLink(Interface);
                } else {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                }

            } else {
                CTEFreeLock(&Interface->ai_lock, Handle);
            }

            // add wakeup pattern for this address, if the address is in
            // conflict ip will turn around and delete the address thus
            // deleting the wakeup pattern.

            ARPWakeupPattern(Interface, Address, TRUE);

            // ARP for the address we've added, to see it it already exists.
            if (RetStatus == TRUE && ArpForSelf == TRUE) {
                if (ArpRetryCount) {

                    SendARPRequest(Interface, Address, ARP_RESOLVING_GLOBAL,
                                   NULL, TRUE);
                    return IP_PENDING;
                } else {
                    return TRUE;
                }
            }
            return RetStatus;
        } else if (Type == LLIP_ADDR_PARP) {
            ARPPArpAddr *NewPArp, *TmpPArp;

            // He's adding a proxy arp address.
            // Don't allow to add duplicate proxy arp entries
            TmpPArp = Interface->ai_parpaddr;
            while (TmpPArp) {
                if (IP_ADDR_EQUAL(TmpPArp->apa_addr, Address) && IP_ADDR_EQUAL(TmpPArp->apa_mask, Mask)) {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                    return FALSE;
                }
                TmpPArp = TmpPArp->apa_next;
            }

            NewPArp = CTEAllocMemN(sizeof(ARPPArpAddr), 'UiCT');
            if (NewPArp != NULL) {
                NewPArp->apa_addr = Address;
                NewPArp->apa_mask = Mask;
                NewPArp->apa_next = Interface->ai_parpaddr;
                Interface->ai_parpaddr = NewPArp;
                Interface->ai_parpcount++;
                CTEFreeLock(&Interface->ai_lock, Handle);

                return TRUE;
            }
            CTEFreeLock(&Interface->ai_lock, Handle);

        }
        return FALSE;
    }

}

//* ARPDeleteAddr - Delete a local or proxy address.
//
//      Called to delete a local or proxy address.
//
//  Entry:  Context    - An ARPInterface pointer.
//          Type       - Type of address (local or p-arp).
//          Address    - IP address to be deleted.
//          Mask       - Mask for address. Used only for deleting proxy-ARP
//                                                      entries.
//
//  Returns: 0 if we failed, non-zero otherwise
//
uint
__stdcall
ARPDeleteAddr(void *Context, uint Type, IPAddr Address, IPMask Mask)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    CTELockHandle Handle;
    ARPIPAddr *DelAddr, *PrevAddr;
    ARPPArpAddr *DelPAddr, *PrevPAddr;
    SetAddrControl *SAC;
    AddAddrNotifyEvent *DelayedEvent;

    if (Type == LLIP_ADDR_LOCAL) {

        CTEGetLock(&Interface->ai_lock, &Handle);

        if (IP_ADDR_EQUAL(Interface->ai_ipaddr.aia_addr, Address)) {
            IPAddr IpAddress;
            ARPIPAddr *Addr;

            Addr = &Interface->ai_ipaddr;
            IpAddress = Addr->aia_addr;

            Interface->ai_ipaddr.aia_addr = NULL_IP_ADDR;
            Interface->ai_ipaddrcnt--;
            if (Interface->ai_telladdrchng) {
                CTEFreeLock(&Interface->ai_lock, Handle);
                AddrNotifyLink(Interface);
                CTEGetLock(&Interface->ai_lock, &Handle);
            }
            // if the address is deleted before the add completes, complete the add here
            // Doing this will complete the irp and also decrements the refcount on the interface

            if (Addr->aia_context != NULL) {
                SAC = (SetAddrControl *) Addr->aia_context;
                Addr->aia_context = NULL;
                CTEFreeLock(&Interface->ai_lock, Handle);

                // We cannot call completion routine at timer DPC
                // because completion routine will need to notify
                // TDI clients and that could take long time.
                DelayedEvent = CTEAllocMemNBoot(sizeof(AddAddrNotifyEvent), 'ViCT');
                if (DelayedEvent) {
                    DelayedEvent->SAC = SAC;
                    DelayedEvent->Address = IpAddress;
                    DelayedEvent->Status = IP_SUCCESS;
                    CTEInitEvent(&DelayedEvent->Event, CompleteIPSetNTEAddrRequestDelayed);
                    CTEScheduleDelayedEvent(&DelayedEvent->Event, DelayedEvent);
                } else {
                    ASSERT(FALSE);
                    return FALSE;
                }
            } else {
                CTEFreeLock(&Interface->ai_lock, Handle);
            }

            ARPWakeupPattern(Interface, Address, FALSE);

            return TRUE;
        } else {
            PrevAddr = STRUCT_OF(ARPIPAddr, &Interface->ai_ipaddr, aia_next);
            DelAddr = PrevAddr->aia_next;
            while (DelAddr != NULL)
                if (IP_ADDR_EQUAL(DelAddr->aia_addr, Address))
                    break;
                else {
                    PrevAddr = DelAddr;
                    DelAddr = DelAddr->aia_next;
                }

            if (DelAddr != NULL) {
                PrevAddr->aia_next = DelAddr->aia_next;
                if (DelAddr->aia_next &&
                    DelAddr->aia_next->aia_age == ARPADDR_MARKER) {
                    DelAddr->aia_next->aia_context = (PVOID) PrevAddr;
                }
                Interface->ai_ipaddrcnt--;

                if (Interface->ai_telladdrchng) {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                    AddrNotifyLink(Interface);
                } else {
                    CTEFreeLock(&Interface->ai_lock, Handle);
                }
                if (DelAddr->aia_context != NULL) {
                    SAC = (SetAddrControl *) DelAddr->aia_context;
                    DelAddr->aia_context = NULL;
                    DelayedEvent = CTEAllocMemNBoot(sizeof(AddAddrNotifyEvent), 'ViCT');
                    if (DelayedEvent) {
                        DelayedEvent->SAC = SAC;
                        DelayedEvent->Address = DelAddr->aia_addr;
                        DelayedEvent->Status = IP_SUCCESS;
                        CTEInitEvent(&DelayedEvent->Event, CompleteIPSetNTEAddrRequestDelayed);
                        CTEScheduleDelayedEvent(&DelayedEvent->Event, DelayedEvent);
                    } else {
                        ASSERT(FALSE);
                        return FALSE;
                    }
                }
                CTEFreeMem(DelAddr);
                ARPWakeupPattern(Interface, Address, FALSE);
            } else {
                CTEFreeLock(&Interface->ai_lock, Handle);
            }

            return(DelAddr != NULL);
        }

    } else if (Type == LLIP_ADDR_PARP) {
        CTEGetLock(&Interface->ai_lock, &Handle);
        PrevPAddr = STRUCT_OF(ARPPArpAddr, &Interface->ai_parpaddr, apa_next);
        DelPAddr = PrevPAddr->apa_next;
        while (DelPAddr != NULL)
            if (IP_ADDR_EQUAL(DelPAddr->apa_addr, Address) &&
                DelPAddr->apa_mask == Mask)
                break;
            else {
                PrevPAddr = DelPAddr;
                DelPAddr = DelPAddr->apa_next;
            }

        if (DelPAddr != NULL) {
            PrevPAddr->apa_next = DelPAddr->apa_next;
            Interface->ai_parpcount--;
            CTEFreeMem(DelPAddr);
        }
        CTEFreeLock(&Interface->ai_lock, Handle);
        return(DelPAddr != NULL);
    } else if (Type == LLIP_ADDR_MCAST)
        return ARPDelMCast(Interface, Address);
    else
        return FALSE;
}

//*AddrNotifyLink - Notify link layer of Network Address changes
//
//      Called when address are added/deleted on an interface
//
//  Entry: Interface - ARPinterface pointer
//
//  returns: NDIS_STATUS.Also sets ai_telladdrchng if status is failure
//  when this happens caller can check and see if next addr notification
//  need to be done or not.
//

NDIS_STATUS
AddrNotifyLink(ARPInterface * Interface)
{
    PNETWORK_ADDRESS_LIST AddressList;
    NETWORK_ADDRESS UNALIGNED *Address;
    int i = 0, size, count;
    ARPIPAddr *addrlist;
    NDIS_STATUS status = NDIS_STATUS_FAILURE;
    CTELockHandle Handle;

    CTEGetLock(&Interface->ai_lock, &Handle);

    size = Interface->ai_ipaddrcnt * (sizeof(NETWORK_ADDRESS_IP) +
                                      FIELD_OFFSET(NETWORK_ADDRESS, Address)) +
           FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);

    AddressList = CTEAllocMemN(size, 'WiCT');

    if (AddressList) {
        addrlist = &Interface->ai_ipaddr;
        count = Interface->ai_ipaddrcnt;

        AddressList->AddressType = NDIS_PROTOCOL_ID_TCP_IP;
        while (addrlist && count) {

            NETWORK_ADDRESS_IP UNALIGNED *tmpIPAddr;
            uchar *Address0;

            //
            // Skip if this is a Marker.
            //
            if (addrlist->aia_age != ARPADDR_MARKER) {
                Address0 = (uchar *) & AddressList->Address[0];

                Address = (PNETWORK_ADDRESS) (Address0 + i * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + sizeof(NETWORK_ADDRESS_IP)));

                tmpIPAddr = (PNETWORK_ADDRESS_IP) & Address->Address[0];

                Address->AddressLength = sizeof(NETWORK_ADDRESS_IP);
                Address->AddressType = NDIS_PROTOCOL_ID_TCP_IP;

                RtlCopyMemory(&tmpIPAddr->in_addr, &addrlist->aia_addr, sizeof(IPAddr));
                count--;
                i++;
            }
            addrlist = addrlist->aia_next;
        }

        CTEFreeLock(&Interface->ai_lock, Handle);

        AddressList->AddressCount = i;
        status = DoNDISRequest(Interface,
                               NdisRequestSetInformation,
                               OID_GEN_NETWORK_LAYER_ADDRESSES,
                               AddressList,
                               size,
                               NULL, TRUE);
        if (status != NDIS_STATUS_SUCCESS) {
            CTEGetLock(&Interface->ai_lock, &Handle);
            Interface->ai_telladdrchng = 0;
            CTEFreeLock(&Interface->ai_lock, Handle);
        }
        CTEFreeMem(AddressList);

    } else {
        CTEFreeLock(&Interface->ai_lock, Handle);
        status = NDIS_STATUS_RESOURCES;
    }
    return status;
}


#if !MILLEN

//* ARPCancelPackets
//
//  Entry:  Context   - Pointer to the ARPInterface
//          ID        - Pattern that need to be passed down to ndis
//
//  Returns: Nothing
//

VOID
__stdcall
ARPCancelPackets(void *Context, void *ID)
{
    ARPInterface *Interface = (ARPInterface *) Context;

    NdisCancelSendPackets(Interface->ai_handle,ID);

}
#endif

//* DoWakeupPattern - Adds and removes wakeup pattern.
//
//  Entry:  Context   - Pointer to the ARPInterface
//          PtrnDesc    - Pattern buffer(s) of high level protocol
//          protoid     - the proto type used in ethernet or snap type fields.
//          AddPattern  - TRUE if pattern is to be added, FALSE if it is to be removed.
//
//  Returns: Nothing.
//
NDIS_STATUS
__stdcall
DoWakeupPattern(void *Context, PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc, ushort protoid, BOOLEAN AddPattern)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    uint PtrnLen;
    uint PtrnBufferLen;
    uint MaskLen;
    PNET_PM_WAKEUP_PATTERN_DESC CurPtrnDesc;
    uchar *NextMask, *NextPtrn;
    const uchar *MMask;
    uint MMaskLength;
    uchar NextMaskBit;
    uchar *Buffer;
    PNDIS_PM_PACKET_PATTERN PtrnBuffer;
    NDIS_STATUS Status;

    //
    //  First find the total length of the pattern.
    //  Pattern starts right at MacHeader.
    //

    //  First add the media portion of the header.
    //
    PtrnLen = Interface->ai_hdrsize + Interface->ai_snapsize;

    //  now add the high level proto pattern size.
    CurPtrnDesc = PtrnDesc;
    while (CurPtrnDesc != (PNET_PM_WAKEUP_PATTERN_DESC) NULL) {
        PtrnLen += CurPtrnDesc->PtrnLen;
        CurPtrnDesc = CurPtrnDesc->Next;
    }

    //  length of the mask: every byte of pattern requires
    //  one bit of the mask.
    MaskLen = GetWakeupPatternMaskLength(PtrnLen);


    //  total length of the pattern buffer to be given to ndis.
    PtrnBufferLen = sizeof(NDIS_PM_PACKET_PATTERN) + PtrnLen + MaskLen;
    if ((Buffer = CTEAllocMemN(PtrnBufferLen, 'XiCT')) == (uchar *) NULL) {
        return NDIS_STATUS_RESOURCES;
    }
    RtlZeroMemory(Buffer, PtrnBufferLen);

    PtrnBuffer = (PNDIS_PM_PACKET_PATTERN) Buffer;
    PtrnBuffer->PatternSize = PtrnLen;
    NextMask = Buffer + sizeof(NDIS_PM_PACKET_PATTERN);
    NextPtrn = NextMask + MaskLen;
    PtrnBuffer->MaskSize = MaskLen;
    PtrnBuffer->PatternOffset =
    (ULONG) ((ULONG_PTR) NextPtrn - (ULONG_PTR) PtrnBuffer);

    // Figure out what type of media this is, and do the appropriate thing.
    switch (Interface->ai_media) {
    case NdisMedium802_3:
        if (Interface->ai_snapsize == 0) {
            ENetHeader UNALIGNED *Hdr = (ENetHeader UNALIGNED *) NextPtrn;
            Hdr->eh_type = net_short(protoid);
            MMask = ENetPtrnMsk;
        } else {
            MMask = ENetSNAPPtrnMsk;
        }

        break;
    case NdisMedium802_5:
        if (Interface->ai_snapsize == 0) {
            MMask = TRPtrnMsk;
        } else {
            MMask = TRSNAPPtrnMsk;
        }
        break;
    case NdisMediumFddi:
        if (Interface->ai_snapsize == 0) {
            MMask = FDDIPtrnMsk;
        } else {
            MMask = FDDISNAPPtrnMsk;
        }
        break;
    case NdisMediumArcnet878_2:
        MMask = ARCPtrnMsk;
        break;
    default:
        ASSERT(0);
        Interface->ai_outerrors++;
        CTEFreeMem(Buffer);
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    NextPtrn += Interface->ai_hdrsize;

    // Copy in SNAP header, if any.
    if (Interface->ai_snapsize) {
        SNAPHeader UNALIGNED *SNAPPtr = (SNAPHeader UNALIGNED *) NextPtrn;

        RtlCopyMemory(SNAPPtr, ARPSNAP, Interface->ai_snapsize);
        SNAPPtr->sh_etype = net_short(protoid);
        NextPtrn += Interface->ai_snapsize;

    }
    //
    MMaskLength = (Interface->ai_snapsize + Interface->ai_hdrsize - 1) / 8 + 1;
    // copy the mask for media part
    RtlCopyMemory(NextMask, MMask, MMaskLength);

    NextMaskBit = (Interface->ai_hdrsize + Interface->ai_snapsize) % 8;
    NextMask = NextMask + (Interface->ai_hdrsize + Interface->ai_snapsize) / 8;

    //  copy the pattern and mask of high level proto.
    CurPtrnDesc = PtrnDesc;
    while (CurPtrnDesc) {
        uint CopyBits = CurPtrnDesc->PtrnLen;
        uchar *SrcMask = CurPtrnDesc->Mask;
        uchar SrcMaskBit = 0;
        RtlCopyMemory(NextPtrn, CurPtrnDesc->Ptrn, CurPtrnDesc->PtrnLen);
        NextPtrn += CurPtrnDesc->PtrnLen;
        while (CopyBits--) {
            *NextMask |= ((*SrcMask & (0x1 << SrcMaskBit)) ? (0x1 << NextMaskBit) : 0);
            if ((NextMaskBit = ((NextMaskBit + 1) % 8)) == 0) {
                NextMask++;
            }
            if ((SrcMaskBit = ((SrcMaskBit + 1) % 8)) == 0) {
                SrcMask++;
            }
        }
        CurPtrnDesc = CurPtrnDesc->Next;
    }

    //  now tell ndis to set or remove the pattern.
    Status = DoNDISRequest(
                          Interface,
                          NdisRequestSetInformation,
                          AddPattern ? OID_PNP_ADD_WAKE_UP_PATTERN : OID_PNP_REMOVE_WAKE_UP_PATTERN,
                          PtrnBuffer,
                          PtrnBufferLen,
                          NULL, TRUE);

    CTEFreeMem(Buffer);

    return Status;
}

//* ARPWakeupPattern - add or remove ARP wakeup pattern.
//
//  Entry:  Interface   - Pointer to the ARPInterface
//          Addr        - IPAddr for which we need to set ARP pattern filter.
//
//  Returns: Nothing.
//
NDIS_STATUS
ARPWakeupPattern(ARPInterface * Interface, IPAddr Addr, BOOLEAN AddPattern)
{
    PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc;
    uint PtrnLen;
    uint MaskLen;
    const uchar *PtrnMask;
    NDIS_STATUS Status;

    //
    // create high level proto (ARP here) pattern descriptor.
    //

    // len of pattern.
    PtrnLen = sizeof(ARPHeader);

    // adjust for Arcnet.
    if (Interface->ai_media == NdisMediumArcnet878_2) {
        PtrnLen -= ARCNET_ARPHEADER_ADJUSTMENT;
        PtrnMask = ARCARPPtrnMsk;
    } else {
        PtrnMask = ARPPtrnMsk;
    }

    // masklen = 1 bit per every byte of pattern.
    MaskLen = GetWakeupPatternMaskLength(PtrnLen);

    if ((PtrnDesc = CTEAllocMemN(sizeof(NET_PM_WAKEUP_PATTERN_DESC) + PtrnLen + MaskLen, 'YiCT')) != (PNET_PM_WAKEUP_PATTERN_DESC) NULL) {
        ARPHeader UNALIGNED *Hdr;
        uchar *IPAddrPtr;

        RtlZeroMemory(PtrnDesc, sizeof(NET_PM_WAKEUP_PATTERN_DESC) + PtrnLen + MaskLen);

        // set the ptrn and mask pointers in the buffer.
        PtrnDesc->PtrnLen = (USHORT) PtrnLen;
        PtrnDesc->Ptrn = (uchar *) PtrnDesc + sizeof(NET_PM_WAKEUP_PATTERN_DESC);
        PtrnDesc->Mask = (uchar *) PtrnDesc + sizeof(NET_PM_WAKEUP_PATTERN_DESC) + PtrnLen;

        // we need to wakeup on ARP request for our IPAddr.
        // so set the opcode and dest ip addr fields of ARP.
        Hdr = (ARPHeader UNALIGNED *) PtrnDesc->Ptrn;
        Hdr->ah_opcode = net_short(ARP_REQUEST);

        IPAddrPtr = Hdr->ah_shaddr + Interface->ai_addrlen + sizeof(IPAddr) + Interface->ai_addrlen;
        *(IPAddr UNALIGNED *) IPAddrPtr = Addr;

        RtlCopyMemory(PtrnDesc->Mask, PtrnMask, MaskLen);

        // give it to ndis.
        Status = DoWakeupPattern(
                                Interface,
                                PtrnDesc,
                                ARP_ETYPE_ARP,
                                AddPattern);

        // free the ptrn desc.
        CTEFreeMem(PtrnDesc);

        //now add wakeup pattren for directed mac address
        {
            uint PtrnBufferLen;
            PNDIS_PM_PACKET_PATTERN PtrnBuffer;
            uchar *Buffer;

            PtrnLen = ARP_802_ADDR_LENGTH;    //eth dest address

            MaskLen = 1;                //1 byte, needs 6 bits, 1 bit/byte

            PtrnBufferLen = sizeof(NDIS_PM_PACKET_PATTERN) + PtrnLen + MaskLen;

            Buffer = CTEAllocMem(PtrnBufferLen);

            if (Buffer) {

                RtlZeroMemory(Buffer, PtrnBufferLen);
                PtrnBuffer = (PNDIS_PM_PACKET_PATTERN) Buffer;
                PtrnBuffer->PatternSize = PtrnLen;
                PtrnBuffer->MaskSize = MaskLen;
                PtrnBuffer->PatternOffset = sizeof(NDIS_PM_PACKET_PATTERN) + 1;

                *(Buffer + sizeof(NDIS_PM_PACKET_PATTERN)) = 0x3F;

                RtlCopyMemory(Buffer + sizeof(NDIS_PM_PACKET_PATTERN) + 1, Interface->ai_addr, ARP_802_ADDR_LENGTH);

                Status = DoNDISRequest(
                                      Interface,
                                      NdisRequestSetInformation,
                                      AddPattern ? OID_PNP_ADD_WAKE_UP_PATTERN : OID_PNP_REMOVE_WAKE_UP_PATTERN,
                                      PtrnBuffer,
                                      PtrnBufferLen,
                                      NULL, TRUE);

                CTEFreeMem(Buffer);
            }
        }

        return Status;
    }
    return IP_NO_RESOURCES;
}

//** CompleteIPSetNTEAddrRequestDelayed -
//
//  calls CompleteIPSetNTEAddrRequest on a delayed worker thread
//
//  Entry:
//      Context - pointer to the control block
//  Exit:
//      None.
//
void
CompleteIPSetNTEAddrRequestDelayed(CTEEvent * WorkerThreadEvent, PVOID Context)
{
    AddAddrNotifyEvent *DelayedEvent;
    SetAddrControl *SAC;
    IPAddr Address;
    IP_STATUS Status;

    UNREFERENCED_PARAMETER(WorkerThreadEvent);

    DelayedEvent = (AddAddrNotifyEvent *) Context;
    SAC = DelayedEvent->SAC;            // the client context block;

    Address = DelayedEvent->Address;    // The address for which SetNTEAddr was called for.

    Status = DelayedEvent->Status;

    // Free the worker thread event.
    CTEFreeMem(Context);

    IPAddAddrComplete(Address, SAC, Status);
}

#if FFP_SUPPORT

//* ARPReclaimRequestMem - Post processing upon request completion
//
//    Called upon completion of NDIS requests that originate at ARP
//
//    Input:    pRequestInfo    - Points to request IP sends ARP
//
//    Returns:  None
//
void
ARPReclaimRequestMem(PVOID pRequestInfo)
{
    // Decrement ref count, and reclaim memory if it drops to zero
    if (InterlockedDecrement( (PLONG)
                              &((ReqInfoBlock *) pRequestInfo)->RequestRefs) == 0) {
        // TCPTRACE(("ARPReclaimRequestMem: Freeing mem at pReqInfo = %08X\n",
        //            pRequestInfo));
        CTEFreeMem(pRequestInfo);
    }
}

#endif // if FFP_SUPPORT

//* ARPTimeout - ARP timeout routine.
//
//  This is the timeout routine that is called periodically. We scan the ARP table, looking
//  for invalid entries that can be removed.
//
//  Entry:  Timer   - Pointer to the timer that just fired.
//          Context - Pointer to the interface to be timed out.
//
//  Returns: Nothing.
//
void
ARPTimeout(CTEEvent * Timer, void *Context)
{
    ARPInterface *Interface = (ARPInterface *) Context;    // Our interface.
    ARPTable *Table;
    ARPTableEntry *Current, *Previous;
    int i;                              // Index variable.
    ulong Now = CTESystemUpTime(), ValidTime;
    CTELockHandle tblhandle;
    uchar Deleted;
    PNDIS_PACKET PList = (PNDIS_PACKET) NULL;
    ARPIPAddr *Addr;
    ARPIPAddr Marker;


    UNREFERENCED_PARAMETER(Timer);

    // Walk down the list of addresses, decrementing the age.
    CTEGetLock(&Interface->ai_lock, &tblhandle);

    if (Interface->ai_conflict && !(--Interface->ai_delay)) {
        ARPNotifyStruct *NotifyStruct = Interface->ai_conflict;
        CTEScheduleDelayedEvent(&NotifyStruct->ans_event, NotifyStruct);
        Interface->ai_conflict = NULL;
    }

    Addr = &Interface->ai_ipaddr;

    //
    // Marker is used to track the next addr to be processed
    // in the ipaddr list. Initialize it so that its aia_age is
    // OLD_LOCAL, and aia_addr is NULL_IP_ADDR. The places where
    // address list is scanned will skip ARPIPAddr with NULL_IP_ADDR
    // and in ARPDeleteAddr, if an addr element before the marker is
    // removed, Marker's aia_context will be changed to its prev element.
    //
    Marker.aia_addr = NULL_IP_ADDR;
    do {


        if (Addr->aia_age != ARPADDR_OLD_LOCAL) {
            IPAddr IpAddress;
            (Addr->aia_age)--;

            //
            // Insert Marker after this Addr
            // Marker's aia_context is used as blink
            //
            Marker.aia_age = ARPADDR_MARKER;
            Marker.aia_next = Addr->aia_next;
            Marker.aia_context = Addr;
            Addr->aia_next = &Marker;

            if (Addr->aia_age == ARPADDR_OLD_LOCAL) {
                if (Addr->aia_context != NULL) {
                    SetAddrControl *SAC;
                    AddAddrNotifyEvent *DelayedEvent;
                    SAC = (SetAddrControl *) Addr->aia_context;
                    Addr->aia_context = NULL;
                    IpAddress = Addr->aia_addr;
                    CTEFreeLock(&Interface->ai_lock, tblhandle);

                    // We cannot call completion routine at timer DPC
                    // because completion routine will need to notify
                    // TDI clients and that could take long time.
                    DelayedEvent = CTEAllocMemNBoot(sizeof(AddAddrNotifyEvent), 'ZiCT');
                    if (DelayedEvent) {
                        DelayedEvent->SAC = SAC;
                        DelayedEvent->Address = IpAddress;
                        DelayedEvent->Status = IP_SUCCESS;
                        CTEInitEvent(&DelayedEvent->Event, CompleteIPSetNTEAddrRequestDelayed);
                        CTEScheduleDelayedEvent(&DelayedEvent->Event, DelayedEvent);
                    }

                    CTEGetLock(&Interface->ai_lock, &tblhandle);
                }
            } else {
                IpAddress = Addr->aia_addr;
                CTEFreeLock(&Interface->ai_lock, tblhandle);
                SendARPRequest(Interface, IpAddress, ARP_RESOLVING_GLOBAL,
                               NULL, TRUE);
                CTEGetLock(&Interface->ai_lock, &tblhandle);
            }
            //
            // We are done scanning the list
            // Remove the Marker
            //

            Addr = Marker.aia_next;

            ((ARPIPAddr *)(Marker.aia_context))->aia_next = Marker.aia_next;

        } else {
            Addr = Addr->aia_next;
        }

    } while (Addr != NULL);

    CTEFreeLock(&Interface->ai_lock, tblhandle);

    // Loop through the ARP table for this interface, and delete stale entries.
    CTEGetLock(&Interface->ai_ARPTblLock, &tblhandle);
    Table = Interface->ai_ARPTbl;
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
        Previous = (ARPTableEntry *) ((uchar *) & ((*Table)[i]) - offsetof(struct ARPTableEntry, ate_next));
        Current = (*Table)[i];
        while (Current != (ARPTableEntry *) NULL) {
            CTEGetLockAtDPC(&Current->ate_lock);
            Deleted = 0;

            //Delete the entry if it was used for api purpose

            if (Current->ate_resolveonly) {

                ARPControlBlock *ArpContB, *tmpArpContB;
                PNDIS_PACKET Packet = Current->ate_packet;

                ArpContB = Current->ate_resolveonly;
                ASSERT(Current->ate_resolveonly != NULL);
                while (ArpContB) {
                    ArpRtn rtn;
                    //Complete the pending request
                    rtn = (ArpRtn) ArpContB->CompletionRtn;
                    ArpContB->status = 0;
                    tmpArpContB = ArpContB->next;
                    (*rtn) (ArpContB, (IP_STATUS) STATUS_UNSUCCESSFUL);
                    ArpContB = tmpArpContB;
                }
                Current->ate_resolveonly = NULL;

                if (Packet != (PNDIS_PACKET) NULL) {
                    ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_link = PList;
                    PList = Packet;
                }
                RemoveARPTableEntry(Previous, Current);
                Interface->ai_count--;
                Deleted = 1;
                goto doneapi;
            }

            if (Current->ate_state == ARP_GOOD) {
                //
                // The ARP entry is valid for ARP_VALID_TIMEOUT by default.
                // If a cache life greater than ARP_VALID_TIMEOUT has been
                // configured, we'll make the entry valid for that time.
                //
                ValidTime = ArpCacheLife * ARP_TIMER_TIME;

                if (ValidTime < (ArpMinValidCacheLife * 1000)) {
                    ValidTime = (ArpMinValidCacheLife * 1000);
                }
            } else {
                ValidTime = ARP_RESOLVE_TIMEOUT;
            }

            if (Current->ate_valid != ALWAYS_VALID &&
                (((Now - Current->ate_valid) > ValidTime) ||
                 (Current->ate_state == ARP_GOOD &&
                  !(--(Current->ate_useticks))))) {

                if (Current->ate_state != ARP_RESOLVING_LOCAL) {
                    // Really need to delete this guy.
                    PNDIS_PACKET Packet = Current->ate_packet;

                    if (((Now - Current->ate_valid) > ValidTime) && Current->ate_refresh) {

                        DEBUGMSG(DBG_INFO && DBG_ARP,
                             (DTEXT("ARPTimeout: Expiring ATE %x\n"), Current));

                        if (Packet != (PNDIS_PACKET) NULL) {
                            ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_link
                            = PList;
                            PList = Packet;
                        }
                        RemoveARPTableEntry(Previous, Current);
                        Interface->ai_count--;
                        Deleted = 1;
                    } else {
                        //Just try to validate this again.

                        Current->ate_valid = Now + ARP_REFRESH_TIME;
                        Current->ate_refresh=TRUE;

                    }

                } else {
                    IPAddr Dest = Current->ate_dest;
                    // This entry is only resoving locally, presumably this is
                    // token ring. We'll need to transmit a 'global' resolution
                    // now.
                    ASSERT(Interface->ai_media == NdisMedium802_5);

                    Now = CTESystemUpTime();
                    Current->ate_valid = Now;
                    Current->ate_state = ARP_RESOLVING_GLOBAL;
                    CTEFreeLockFromDPC(&Current->ate_lock);
                    CTEFreeLock(&Interface->ai_ARPTblLock, tblhandle);
                    // Send a global request.
                    SendARPRequest(Interface, Dest, ARP_RESOLVING_GLOBAL,
                                   NULL, TRUE);
                    CTEGetLock(&Interface->ai_ARPTblLock, &tblhandle);

                    // Since we've freed the locks, we need to start over from
                    // the start of this chain.
                    Previous = STRUCT_OF(ARPTableEntry, &((*Table)[i]),
                                         ate_next);
                    Current = (*Table)[i];
                    continue;
                }
            }

            doneapi:

            // If we deleted the entry, leave the previous pointer alone,
            // advance the current pointer, and free the memory. Otherwise
            // move both pointers forward. We can free the entry lock now
            // because the next pointers are protected by the table lock, and
            // we've removed it from the list so nobody else should
            // find it anyway.
            CTEFreeLockFromDPC(&Current->ate_lock);
            if (Deleted) {
                ARPTableEntry *Temp = Current;
                Current = Current->ate_next;
                CTEFreeMem(Temp);
            } else {
                Previous = Current;
                Current = Current->ate_next;
            }
        }
    }

    CTEFreeLock(&Interface->ai_ARPTblLock, tblhandle);

    while (PList != (PNDIS_PACKET) NULL) {
        PNDIS_PACKET Packet = PList;

        PList = ((PacketContext *) Packet->ProtocolReserved)->pc_common.pc_link;
        IPSendComplete(Interface->ai_context, Packet, NDIS_STATUS_SUCCESS);
    }

    //
    // Dont requeue if interface is going down and we need to stop the timer
    //
    if (Interface->ai_stoptimer) {
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARP interface %lx is down - dont requeue the timer - signal the waiter\n", Interface));
        Interface->ai_timerstarted = FALSE;
        CTESignal(&Interface->ai_timerblock, NDIS_STATUS_SUCCESS);
    } else {
        CTEStartTimer(&Interface->ai_timer, ARP_TIMER_TIME, ARPTimeout, Interface);
    }

#if FFP_SUPPORT

    // Flush Processing - This can be done after starting the timer

    CTEGetLock(&Interface->ai_lock, &tblhandle);

    // If FFP supported on this interface & it is time to do a flush
    if ((Interface->ai_ffpversion) &&
        (++Interface->ai_ffplastflush >= FFP_ARP_FLUSH_INTERVAL)) {
        ReqInfoBlock *pRequestInfo;
        FFPFlushParams *pFlushInfo;

        TCPTRACE(("ARPTimeout: Sending a FFP flush to ARPInterface %08X\n",
                  Interface));

        // Allocate the request block - For General and Request Specific Parts
        pRequestInfo = CTEAllocMemN(sizeof(ReqInfoBlock) + sizeof(FFPFlushParams), '0ICT');

        // TCPTRACE(("ARPTimeout: Allocated mem at pReqInfo = %08X\n",
        //                pRequestInfo));

        if (pRequestInfo != NULL) {
            // Prepare the params for the request [Part common to all requests]
            pRequestInfo->RequestType = OID_FFP_FLUSH;
            pRequestInfo->ReqCompleteCallback = ARPReclaimRequestMem;

            // Prepare the params for the request [Part specific to this request]
            pRequestInfo->RequestLength = sizeof(FFPFlushParams);

            // Flush all caches that FFP keeps - just a safe reset of FFP state
            pFlushInfo = (FFPFlushParams *) pRequestInfo->RequestInfo;

            pFlushInfo->NdisProtocolType = NDIS_PROTOCOL_ID_TCP_IP;

            // Assign the ref count to 1 => Used for just a single request
            pRequestInfo->RequestRefs = 1;

            DoNDISRequest(Interface, NdisRequestSetInformation, OID_FFP_FLUSH,
                          pFlushInfo, sizeof(FFPFlushParams), NULL, FALSE);

            // Reset the number of timer ticks since the last FFP request
            Interface->ai_ffplastflush = 0;
        } else {
            TCPTRACE(("Error: Unable to allocate memory for NdisRequest\n"));
        }
    }

#if DBG
    if (fakereset) {
        NDIS_STATUS Status;

        NdisReset(&Status, Interface->ai_handle);
        KdPrint(("fakereset: %x\n", Status));
    }
#endif

    CTEFreeLock(&Interface->ai_lock, tblhandle);

#endif // if FFP_SUPPORT
}

//*     IsLocalAddr - Return info. about local status of address.
//
//      Called when we need info. about whether or not a particular address is
//      local. We return info about whether or not it is, and if it is how old
//      it is.
//
//  Entry:  Interface   - Pointer to interface structure to be searched.
//          Address     - Address in question.
//
//  Returns: ARPADDR_*, for how old it is.
//
//
uint
IsLocalAddr(ARPInterface * Interface, IPAddr Address)
{
    CTELockHandle Handle;
    ARPIPAddr *CurrentAddr;
    uint Age;

    // If we are asking about the null ip address, we don't want to consider
    // it as a true local address.
    //
    if (IP_ADDR_EQUAL(Address, NULL_IP_ADDR)) {
        return ARPADDR_NOT_LOCAL;
    }

    CTEGetLock(&Interface->ai_lock, &Handle);

    CurrentAddr = &Interface->ai_ipaddr;
    Age = ARPADDR_NOT_LOCAL;

    do {
        if (CurrentAddr->aia_addr == Address) {
            Age = CurrentAddr->aia_age;
            break;
        }
        CurrentAddr = CurrentAddr->aia_next;
    } while (CurrentAddr != NULL);

    CTEFreeLock(&Interface->ai_lock, Handle);
    return Age;
}

//* ARPLocalAddr - Determine whether or not a given address if local.
//
//  This routine is called when we receive an incoming packet and need to
//  determine whether or not it's local. We look up the provided address on
//  the specified interface.
//
//  Entry:  Interface   - Pointer to interface structure to be searched.
//          Address     - Address in question.
//
//  Returns: TRUE if it is a local address, FALSE if it's not.
//
uchar
ARPLocalAddr(ARPInterface * Interface, IPAddr Address)
{
    CTELockHandle Handle;
    ARPPArpAddr *CurrentPArp;
    IPMask Mask, NetMask;
    IPAddr MatchAddress;

    // First, see if he's a local (not-proxy) address.
    if (IsLocalAddr(Interface, Address) != ARPADDR_NOT_LOCAL)
        return TRUE;

    CTEGetLock(&Interface->ai_lock, &Handle);

    // Didn't find him in out local address list. See if he exists on our
    // proxy ARP list.
    for (CurrentPArp = Interface->ai_parpaddr; CurrentPArp != NULL;
        CurrentPArp = CurrentPArp->apa_next) {
        // See if this guy matches.
        Mask = CurrentPArp->apa_mask;
        MatchAddress = Address & Mask;
        if (IP_ADDR_EQUAL(CurrentPArp->apa_addr, MatchAddress)) {
            // He matches. We need to make a few more checks to make sure
            // we don't reply to a broadcast address.
            if (Mask == HOST_MASK) {
                // We're matching the whole address, so it's OK.
                CTEFreeLock(&Interface->ai_lock, Handle);
                return TRUE;
            }
            // See if the non-mask part it all-zeros. Since the mask presumably
            // covers a subnet, this trick will prevent us from replying to
            // a zero host part.
            if (IP_ADDR_EQUAL(MatchAddress, Address))
                continue;

            // See if the host part is all ones.
            if (IP_ADDR_EQUAL(Address, MatchAddress | (IP_LOCAL_BCST & ~Mask)))
                continue;

            // If the mask we were given is not the net mask for this address,
            // we'll need to repeat the above checks.
            NetMask = IPNetMask(Address);
            if (NetMask != Mask) {

                MatchAddress = Address & NetMask;
                if (IP_ADDR_EQUAL(MatchAddress, Address))
                    continue;

                if (IP_ADDR_EQUAL(Address, MatchAddress |
                                  (IP_LOCAL_BCST & ~NetMask)))
                    continue;
            }
            // If we get to this point we've passed all the tests, so it's
            // local.
            CTEFreeLock(&Interface->ai_lock, Handle);
            return TRUE;
        }
    }

    CTEFreeLock(&Interface->ai_lock, Handle);
    return FALSE;

}

//*     NotifyConflictProc - Notify the user of an address conflict.
//
//      Called when we need to notify the user of an address conflict. The
//      exact mechanism is system dependent, but generally involves a popup.
//
//      Input:  Event                   - Event that fired.
//                      Context                 - Pointer to ARPNotifyStructure.
//
//      Returns: Nothing.
//
void
NotifyConflictProc(CTEEvent * Event, void *Context)
{
#if MILLEN
    //
    // Call into VIP to VIP_NotifyConflicProc. This will schedule an Appy
    // event, etc. This is a little sleazy, but we do an INT 20, give the
    // appropriate index into service table and VIP VxD ID.
    //
    // void VIP_NotifyConflictProc(CTEEvent *Event, void *Context);
    //  Event is unused.
    //

     _asm {
         push    Context
         push    Context

         _emit   0xcd
         _emit   0x20
         _emit   0x15  // VIP_NotifyConflictProc (Low)
         _emit   0x00  // VIP_NotifyConflictProc (High)
         _emit   0x89  // VIP VxD ID (Low)
         _emit   0x04  // VIP VxD ID (High)
         add esp,8
     }

#else // MILLEN
    ARPNotifyStruct *NotifyStruct = (ARPNotifyStruct *) Context;
    PWCHAR stringList[2];
    uchar IPAddrBuffer[(sizeof(IPAddr) * 4)];
    uchar HWAddrBuffer[(ARP_802_ADDR_LENGTH * 3)];
    WCHAR unicodeIPAddrBuffer[((sizeof(IPAddr) * 4) + 1)];
    WCHAR unicodeHWAddrBuffer[(ARP_802_ADDR_LENGTH * 3)];
    uint i;
    uint IPAddrCharCount;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(Event);


    //
    // Convert the IP address into a string.
    //
    IPAddrCharCount = 0;

    for (i = 0; i < sizeof(IPAddr); i++) {
        uint CurrentByte;

        CurrentByte = NotifyStruct->ans_addr & 0xff;
        if (CurrentByte > 99) {
            IPAddrBuffer[IPAddrCharCount++] = (uchar)(CurrentByte / 100) + '0';
            CurrentByte %= 100;
            IPAddrBuffer[IPAddrCharCount++] = (uchar)(CurrentByte / 10) + '0';
            CurrentByte %= 10;
        } else if (CurrentByte > 9) {
            IPAddrBuffer[IPAddrCharCount++] = (uchar)(CurrentByte / 10) + '0';
            CurrentByte %= 10;
        }
        IPAddrBuffer[IPAddrCharCount++] = (uchar)CurrentByte + '0';
        if (i != (sizeof(IPAddr) - 1))
            IPAddrBuffer[IPAddrCharCount++] = '.';

        NotifyStruct->ans_addr >>= 8;
    }

    //
    // Convert the hardware address into a string.
    //
    for (i = 0; i < NotifyStruct->ans_hwaddrlen; i++) {
        uchar CurrentHalf;

        CurrentHalf = NotifyStruct->ans_hwaddr[i] >> 4;
        HWAddrBuffer[i * 3] = (uchar) (CurrentHalf < 10 ? CurrentHalf + '0' :
                                       (CurrentHalf - 10) + 'A');
        CurrentHalf = NotifyStruct->ans_hwaddr[i] & 0x0f;
        HWAddrBuffer[(i * 3) + 1] = (uchar) (CurrentHalf < 10 ? CurrentHalf + '0' :
                                             (CurrentHalf - 10) + 'A');
        if (i != (NotifyStruct->ans_hwaddrlen - 1))
            HWAddrBuffer[(i * 3) + 2] = ':';
    }

    //
    // Unicode the strings.
    //
    *unicodeIPAddrBuffer = *unicodeHWAddrBuffer = UNICODE_NULL;

    unicodeString.Buffer = unicodeIPAddrBuffer;
    unicodeString.Length = 0;
    unicodeString.MaximumLength = sizeof(WCHAR) * ((sizeof(IPAddr) * 4) + 1);
    ansiString.Buffer = (PCHAR) IPAddrBuffer;
    ansiString.Length = (USHORT) IPAddrCharCount;
    ansiString.MaximumLength = (USHORT) IPAddrCharCount;

    RtlAnsiStringToUnicodeString(
                                &unicodeString,
                                &ansiString,
                                FALSE
                                );

    stringList[0] = unicodeIPAddrBuffer;

    unicodeString.Buffer = unicodeHWAddrBuffer;
    unicodeString.Length = 0;
    unicodeString.MaximumLength = sizeof(WCHAR) * (ARP_802_ADDR_LENGTH * 3);
    ansiString.Buffer = (PCHAR) HWAddrBuffer;
    ansiString.Length = (ushort) ((NotifyStruct->ans_hwaddrlen * 3) - 1);
    ansiString.MaximumLength = (ushort)(NotifyStruct->ans_hwaddrlen * 3);

    RtlAnsiStringToUnicodeString(
                                &unicodeString,
                                &ansiString,
                                FALSE
                                );

    stringList[1] = unicodeHWAddrBuffer;

    //
    // Kick off a popup and log an event.
    //
    if (NotifyStruct->ans_shutoff) {
        CTELogEvent(
                   IPDriverObject,
                   EVENT_TCPIP_ADDRESS_CONFLICT1,
                   0,
                   2,
                   stringList,
                   0,
                   NULL
                   );

        IoRaiseInformationalHardError(
                                     STATUS_IP_ADDRESS_CONFLICT1,
                                     NULL,
                                     NULL
                                     );
    } else {
        CTELogEvent(
                   IPDriverObject,
                   EVENT_TCPIP_ADDRESS_CONFLICT2,
                   0,
                   2,
                   stringList,
                   0,
                   NULL
                   );

        IoRaiseInformationalHardError(
                                     STATUS_IP_ADDRESS_CONFLICT2,
                                     NULL,
                                     NULL
                                     );
    }
    CTEFreeMem(NotifyStruct);
#endif // !MILLEN

    return;
}

//*     DebugConflictProc - Prints some debugging info in case of addr conflicts
//      Prints the ip and hw addr of the guy causing the conflict
//      Context                 - Pointer to ARPNotifyStructure.
//
//      Returns: Nothing.
//
void
DebugConflictProc(void *Context)
{
    ARPNotifyStruct *NotifyStruct = (ARPNotifyStruct *) Context;
    uchar IPAddrBuffer[(sizeof(IPAddr) * 4)];
    uchar HWAddrBuffer[(ARP_802_ADDR_LENGTH * 3)];
    uint i;
    uint IPAddrCharCount;
    IPAddr ans_addr;

    //
    // Save the IP address in case we need it later, then convert into
    // a string.
    //
    ans_addr = NotifyStruct->ans_addr;

    IPAddrCharCount = 0;

    for (i = 0; i < sizeof(IPAddr); i++) {
        uint CurrentByte;

        CurrentByte = NotifyStruct->ans_addr & 0xff;
        if (CurrentByte > 99) {
            IPAddrBuffer[IPAddrCharCount++] = (uchar)(CurrentByte / 100) + '0';
            CurrentByte %= 100;
            IPAddrBuffer[IPAddrCharCount++] = (uchar)(CurrentByte / 10) + '0';
            CurrentByte %= 10;
        } else if (CurrentByte > 9) {
            IPAddrBuffer[IPAddrCharCount++] = (uchar)(CurrentByte / 10) + '0';
            CurrentByte %= 10;
        }
        IPAddrBuffer[IPAddrCharCount++] = (uchar) (CurrentByte) + '0';
        if (i != (sizeof(IPAddr) - 1))
            IPAddrBuffer[IPAddrCharCount++] = '.';

        NotifyStruct->ans_addr >>= 8;
    }

    IPAddrBuffer[IPAddrCharCount] = '\0';

    //
    // Convert the hardware address into a string.
    //
    for (i = 0; i < NotifyStruct->ans_hwaddrlen; i++) {
        uchar CurrentHalf;

        CurrentHalf = NotifyStruct->ans_hwaddr[i] >> 4;
        HWAddrBuffer[i * 3] = (uchar) (CurrentHalf < 10 ? CurrentHalf + '0' :
                                       (CurrentHalf - 10) + 'A');
        CurrentHalf = NotifyStruct->ans_hwaddr[i] & 0x0f;
        HWAddrBuffer[(i * 3) + 1] = (uchar) (CurrentHalf < 10 ? CurrentHalf + '0' :
                                             (CurrentHalf - 10) + 'A');
        if (i != (NotifyStruct->ans_hwaddrlen - 1))
            HWAddrBuffer[(i * 3) + 2] = ':';
    }

    HWAddrBuffer[((NotifyStruct->ans_hwaddrlen * 3) - 1)] = '\0';

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
               "TCPIP: Address Conflict: IPAddr %s HWAddr %s \n",
               IPAddrBuffer, HWAddrBuffer));
    return;
}

//* HandleARPPacket - Process an incoming ARP packet.
//
//  This is the main routine to process an incoming ARP packet. We look at
//  all ARP frames, and update our cache entry for the source address if one
//  exists. Else, if we are the target we create an entry if one doesn't
//  exist. Finally, we'll handle the opcode, responding if this is a request
//  or sending pending packets if this is a response.
//
//  Entry:  Interface   - Pointer to interface structure for this adapter.
//          Header      - Pointer to header buffer.
//          HeaderSize  - Size of header buffer.
//          ARPHdr      - ARP packet header.
//          ARPHdrSize  - Size of ARP header.
//          ProtOffset  - Offset into original data field of arp header.
//                                       Will be non-zero if we're using SNAP.
//
//  Returns: An NDIS_STATUS value to be returned to the NDIS driver.
//
NDIS_STATUS
HandleARPPacket(ARPInterface * Interface, void *Header, uint HeaderSize,
                ARPHeader UNALIGNED * ARPHdr, uint ARPHdrSize, uint ProtOffset)
{
    ARPTableEntry *Entry;               // Entry in ARP table
    CTELockHandle LHandle = DISPATCH_LEVEL, TableHandle;
    RC UNALIGNED *SourceRoute = (RC UNALIGNED *) NULL;    // Pointer to Source Route info, if any.
    uint SourceRouteSize = 0;
    ulong Now = CTESystemUpTime();
    uchar LocalAddr;
    uint LocalAddrAge;
    uchar *SHAddr, *DHAddr;
    IPAddr UNALIGNED *SPAddr, *DPAddr;
    ENetHeader *ENetHdr;
    TRHeader *TRHdr;
    FDDIHeader *FHdr;
    ARCNetHeader *AHdr;
    ushort MaxMTU;
    uint UseSNAP;
    SetAddrControl *SAC=NULL;
    ARPIPAddr *CurrentAddr;
    AddAddrNotifyEvent *DelayedEvent;
    uint NUCast;

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_RX,
             (DTEXT("+HandleARPPacket(%x, %x, %d, %x, %d, %d)\n"),
              Interface, Header, HeaderSize, ARPHdr, ARPHdrSize, ProtOffset));

    // Validate the opcode
    //
    if ((ARPHdr->ah_opcode != net_short(ARP_REQUEST)) &&
        (ARPHdr->ah_opcode != net_short(ARP_RESPONSE))) {
        return NDIS_STATUS_NOT_RECOGNIZED;
    }

    // We examine all ARP frames. If we find the source address in the ARP table, we'll
    // update the hardware address and set the state to valid. If we're the
    // target and he's not in the table, we'll add him. Otherwise if we're the
    // target and this is a response we'll send any pending packets to him.
    if (Interface->ai_media != NdisMediumArcnet878_2) {
        if (ARPHdrSize < sizeof(ARPHeader))
            return NDIS_STATUS_NOT_RECOGNIZED;    // Frame is too small.

        if (ARPHdr->ah_hw != net_short(ARP_HW_ENET) &&
            ARPHdr->ah_hw != net_short(ARP_HW_802))
            return NDIS_STATUS_NOT_RECOGNIZED;    // Wrong HW type

        if (ARPHdr->ah_hlen != ARP_802_ADDR_LENGTH)
            return NDIS_STATUS_NOT_RECOGNIZED;    // Wrong address length.

        if (Interface->ai_media == NdisMedium802_3 && Interface->ai_snapsize == 0)
            UseSNAP = FALSE;
        else
            UseSNAP = (ProtOffset != 0);

        // Figure out SR size on TR.
        if (Interface->ai_media == NdisMedium802_5) {
            // Check for source route information. SR is present if the header
            // size is greater than the standard TR header size. If the SR is
            // only an RC field, we ignore it because it came from the same
            // ring which is the same as no SR.

            if ((HeaderSize - sizeof(TRHeader)) > sizeof(RC)) {
                SourceRouteSize = HeaderSize - sizeof(TRHeader);
                SourceRoute = (RC UNALIGNED *) ((uchar *) Header +
                                                sizeof(TRHeader));
            }
        }
        SHAddr = ARPHdr->ah_shaddr;
        SPAddr = (IPAddr UNALIGNED *) & ARPHdr->ah_spaddr;
        DHAddr = ARPHdr->ah_dhaddr;
        DPAddr = (IPAddr UNALIGNED *) & ARPHdr->ah_dpaddr;

    } else {
        if (ARPHdrSize < (sizeof(ARPHeader) - ARCNET_ARPHEADER_ADJUSTMENT))
            return NDIS_STATUS_NOT_RECOGNIZED;    // Frame is too small.

        if (ARPHdr->ah_hw != net_short(ARP_HW_ARCNET))
            return NDIS_STATUS_NOT_RECOGNIZED;    // Wrong HW type

        if (ARPHdr->ah_hlen != 1)
            return NDIS_STATUS_NOT_RECOGNIZED;    // Wrong address length.

        UseSNAP = FALSE;
        SHAddr = ARPHdr->ah_shaddr;
        SPAddr = (IPAddr UNALIGNED *) (SHAddr + 1);
        DHAddr = (uchar *) SPAddr + sizeof(IPAddr);
        DPAddr = (IPAddr UNALIGNED *) (DHAddr + 1);
    }

    if (ARPHdr->ah_pro != net_short(ARP_ETYPE_IP))
        return NDIS_STATUS_NOT_RECOGNIZED;    // Unsupported protocol type.

    if (ARPHdr->ah_plen != sizeof(IPAddr))
        return NDIS_STATUS_NOT_RECOGNIZED;

    LocalAddrAge = ARPADDR_NOT_LOCAL;

    // First, let's see if we have an address conflict.
    //
    LocalAddrAge = IsLocalAddr(Interface, *SPAddr);

    if (LocalAddrAge != ARPADDR_NOT_LOCAL) {
        // The source IP address is one of ours. See if the source h/w address
        // is ours also.
        if (ARPHdr->ah_hlen != Interface->ai_addrlen ||
            CTEMemCmp(SHAddr, Interface->ai_addr, Interface->ai_addrlen) != 0) {

            uint Shutoff = FALSE;
            BOOLEAN PopUP = TRUE;
            ARPNotifyStruct *NotifyStruct;

            // This isn't from us; we must have an address conflict somewhere.
            // We always log an error about this. If what triggered this is a
            // response and the address in conflict is young, we'll turn off
            // the interface.
            if (LocalAddrAge != ARPADDR_OLD_LOCAL &&
                ARPHdr->ah_opcode == net_short(ARP_RESPONSE)) {
                // Send an arp request with the owner's address to reset the
                // caches.

                CTEGetLock(&Interface->ai_lock, &LHandle);
                // now find the address that is in conflict and get the
                // corresponding client context.
                CurrentAddr = &Interface->ai_ipaddr;

                do {
                    if (CurrentAddr->aia_addr == *SPAddr) {
                        SAC = (SetAddrControl *) CurrentAddr->aia_context;
                        CurrentAddr->aia_context = NULL;
                        break;
                    }
                    CurrentAddr = CurrentAddr->aia_next;
                } while (CurrentAddr != NULL);

                CTEFreeLock(&Interface->ai_lock, LHandle);

                SendARPRequest(Interface, *SPAddr, ARP_RESOLVING_GLOBAL,
                               SHAddr, FALSE);    // Send a request.

                Shutoff = TRUE;
                // Display the debug information for remote boot/install.
                // This code should be kept.
                {
                    ARPNotifyStruct *DebugNotifyStruct;

                    DebugNotifyStruct = CTEAllocMemN(offsetof(ARPNotifyStruct, ans_hwaddr) +
                                                     ARPHdr->ah_hlen, '1ICT');
                    if (DebugNotifyStruct != NULL) {
                        DebugNotifyStruct->ans_addr = *SPAddr;
                        DebugNotifyStruct->ans_shutoff = Shutoff;
                        DebugNotifyStruct->ans_hwaddrlen = (uint) ARPHdr->ah_hlen;
                        RtlCopyMemory(DebugNotifyStruct->ans_hwaddr, SHAddr,
                                   ARPHdr->ah_hlen);
                        DebugConflictProc(DebugNotifyStruct);
                        CTEFreeMem(DebugNotifyStruct);
                    }
                }

                if ((SAC != NULL) && !SAC->StaticAddr) {
                    // This is a dhcp adapter.
                    // Don't display a warning dialog in this case - DHCP will
                    // alert the user
                    //

                    PopUP = FALSE;
                }


                // We cannot call completion routine at this time
                // because completion routine calls back into arp to
                // reset the address and that may go down into ndis.
                DelayedEvent = CTEAllocMemN(sizeof(AddAddrNotifyEvent), '2ICT');
                if (DelayedEvent) {

                    DelayedEvent->SAC = SAC;
                    DelayedEvent->Address = *SPAddr;
                    DelayedEvent->Status = IP_DUPLICATE_ADDRESS;
                    CTEInitEvent(&DelayedEvent->Event, CompleteIPSetNTEAddrRequestDelayed);
                    CTEScheduleDelayedEvent(&DelayedEvent->Event, DelayedEvent);
                } else {
                    ASSERT(FALSE);
                }

                if (!PopUP) {
                    goto no_dialog;
                }

            } else {
                if (ARPHdr->ah_opcode == net_short(ARP_REQUEST) &&
                    (IsLocalAddr(Interface, *DPAddr) == ARPADDR_OLD_LOCAL)) {
                    // Send a response for gratuitous ARP.
                    SendARPReply(Interface, *SPAddr, *DPAddr, SHAddr,
                                 SourceRoute, SourceRouteSize, UseSNAP);
                    Shutoff = FALSE;
                } else if (LocalAddrAge != ARPADDR_OLD_LOCAL) {
                    // our address is still young. we dont need to put the
                    // warning popup as it will be done by the code that
                    // checks for arp response in above if portion of the code.
                    goto no_dialog;
                }
                // Else. We have an old local address and received an ARP for
                //       a third address. Fall through and indicate address
                //       conflict.
            }

            // Now allocate a structure, and schedule an event to notify
            // the user.
            NotifyStruct = CTEAllocMemN(offsetof(ARPNotifyStruct, ans_hwaddr) +
                                        ARPHdr->ah_hlen, '3ICT');
            if (NotifyStruct != NULL) {
                NotifyStruct->ans_addr = *SPAddr;
                NotifyStruct->ans_shutoff = Shutoff;
                NotifyStruct->ans_hwaddrlen = (uint) ARPHdr->ah_hlen;
                RtlCopyMemory(NotifyStruct->ans_hwaddr, SHAddr,
                           ARPHdr->ah_hlen);
                CTEInitEvent(&NotifyStruct->ans_event, NotifyConflictProc);
                if (Shutoff) {
                    // Delay notification for few seconds.
                    Interface->ai_conflict = NotifyStruct;
                #if MILLEN
                    Interface->ai_delay = 5;
                #else
                    Interface->ai_delay = 90;    // delay 3 seconds.
                #endif
                } else
                    CTEScheduleDelayedEvent(&NotifyStruct->ans_event, NotifyStruct);
            }
            no_dialog:
            ;

        }
        return NDIS_STATUS_NOT_RECOGNIZED;
    }
    if (!EnableBcastArpReply) {

        // Check for bogus arp entry
        NUCast = ((*(SHAddr) &
                   Interface->ai_bcastmask) == Interface->ai_bcastval) ?
                 AI_NONUCAST_INDEX : AI_UCAST_INDEX;

        if (NUCast == AI_NONUCAST_INDEX) {
            return NDIS_STATUS_NOT_RECOGNIZED;
        }
    }

    CTEGetLock(&Interface->ai_ARPTblLock, &TableHandle);

    MaxMTU = Interface->ai_mtu;

    LocalAddr = ARPLocalAddr(Interface, *DPAddr);

    // If the sender's address is not remote (i.e. multicast, broadcast,
    // local, or just invalid), We don't want to create an entry for it or
    // bother looking it up.
    //
    if ((DEST_REMOTE == GetAddrType(*SPAddr))) {

        Entry = ARPLookup(Interface, *SPAddr);
        if (Entry == (ARPTableEntry *) NULL) {

            // Didn't find him, create one if it's for us. The call to ARPLookup
            // returned with the ARPTblLock held, so we need to free it.

            CTEFreeLock(&Interface->ai_ARPTblLock, TableHandle);

            if (LocalAddr) {
                // If this was an ARP request, we need to create a new
                // entry for the source info.  If this was a reply, it was
                // unsolicited and we don't create an entry.
                //
                if (ARPHdr->ah_opcode != net_short(ARP_RESPONSE)) {
                    Entry = CreateARPTableEntry(Interface, *SPAddr, &LHandle, 0);
                }
            } else {
                return NDIS_STATUS_NOT_RECOGNIZED;    // Not in our table, and not for us.
            }
        } else {

            //if this is for userarp, make sure that it is out of the table
            //while we still have the arp table lock.

            if (Entry->ate_userarp) {

               ARPTable *Table;
               ARPTableEntry *PrevATE, *CurrentATE;
               uint Index = ARP_HASH(*SPAddr);

               Table = Interface->ai_ARPTbl;

               PrevATE = STRUCT_OF(ARPTableEntry, &((*Table)[Index]), ate_next);
               CurrentATE = PrevATE;

               while (CurrentATE != (ARPTableEntry *) NULL) {
                  if (CurrentATE == Entry) {
                     break;
                  }
                  PrevATE = CurrentATE;
                  CurrentATE = CurrentATE->ate_next;
               }
               if (CurrentATE != NULL) {
                  RemoveARPTableEntry(PrevATE, CurrentATE);
                  Interface->ai_count--;
               }
            }

            CTEFreeLockFromDPC(&Interface->ai_ARPTblLock);
            LHandle = TableHandle;
        }
    } else { // Source address was invalid for an Arp table entry.
        CTEFreeLock(&Interface->ai_ARPTblLock, TableHandle);
        Entry = NULL;
    }

    // At this point, entry should be valid and we hold the lock on the entry
    // in LHandle or entry is NULL.

    if (Entry != (ARPTableEntry *) NULL) {
        PNDIS_PACKET Packet;            // Packet to be sent.

        DEBUGMSG(DBG_INFO && DBG_ARP && DBG_RX,
                 (DTEXT("HandleARPPacket: resolving addr for ATE %x\n"), Entry));

        Entry->ate_refresh = FALSE;

        // If the entry is already static, we'll want to leave it as static.
        if (Entry->ate_valid != ALWAYS_VALID) {

            // OK, we have an entry to use, and hold the lock on it. Fill in the
            // required fields.
            switch (Interface->ai_media) {
            case NdisMedium802_3:

                // This is an Ethernet.
                ENetHdr = (ENetHeader *) Entry->ate_addr;

                RtlCopyMemory(ENetHdr->eh_daddr, SHAddr, ARP_802_ADDR_LENGTH);
                RtlCopyMemory(ENetHdr->eh_saddr, Interface->ai_addr,
                           ARP_802_ADDR_LENGTH);
                ENetHdr->eh_type = net_short(ARP_ETYPE_IP);

                // If we're using SNAP on this entry, copy in the SNAP header.
                if (UseSNAP) {
                    RtlCopyMemory(&Entry->ate_addr[sizeof(ENetHeader)], ARPSNAP,
                               sizeof(SNAPHeader));
                    Entry->ate_addrlength = (uchar) (sizeof(ENetHeader) +
                                                     sizeof(SNAPHeader));
                    *(ushort UNALIGNED *) & Entry->ate_addr[Entry->ate_addrlength - 2] =
                    net_short(ARP_ETYPE_IP);
                } else
                    Entry->ate_addrlength = sizeof(ENetHeader);

                Entry->ate_state = ARP_GOOD;
                Entry->ate_valid = Now;     // Mark last time he was
                // valid.

                Entry->ate_useticks = ArpCacheLife;

                break;

            case NdisMedium802_5:

                // This is TR.
                // For token ring we have to deal with source routing. There's
                // a special case to handle multiple responses for an all-routes
                // request - if the entry is currently good and we knew it was
                // valid recently, we won't update the entry.

                if (Entry->ate_state != ARP_GOOD ||
                    (Now - Entry->ate_valid) > ARP_RESOLVE_TIMEOUT) {

                    TRHdr = (TRHeader *) Entry->ate_addr;

                    // We need to update a TR entry.
                    TRHdr->tr_ac = ARP_AC;
                    TRHdr->tr_fc = ARP_FC;
                    RtlCopyMemory(TRHdr->tr_daddr, SHAddr, ARP_802_ADDR_LENGTH);
                    RtlCopyMemory(TRHdr->tr_saddr, Interface->ai_addr,
                               ARP_802_ADDR_LENGTH);
                    if (SourceRoute != (RC UNALIGNED *) NULL) {
                        uchar MaxIFieldBits;

                        // We have source routing information.
                        RtlCopyMemory(&Entry->ate_addr[sizeof(TRHeader)],
                                   SourceRoute, SourceRouteSize);
                        MaxIFieldBits = (SourceRoute->rc_dlf & RC_LF_MASK) >>
                                        LF_BIT_SHIFT;
                        MaxIFieldBits = MIN(MaxIFieldBits, MAX_LF_BITS);
                        MaxMTU = IFieldSize[MaxIFieldBits];

                        // The new MTU we've computed is the max I-field size,
                        // which doesn't include source routing info but
                        // does include SNAP info. Subtract off the SNAP size.
                        MaxMTU -= sizeof(SNAPHeader);

                        TRHdr->tr_saddr[0] |= TR_RII;
                        (*(RC UNALIGNED *) & Entry->ate_addr[sizeof(TRHeader)]).rc_dlf ^=
                        RC_DIR;
                        // Make sure it's non-broadcast.
                        (*(RC UNALIGNED *) & Entry->ate_addr[sizeof(TRHeader)]).rc_blen &=
                        RC_LENMASK;

                    }
                    RtlCopyMemory(&Entry->ate_addr[sizeof(TRHeader) + SourceRouteSize],
                               ARPSNAP, sizeof(SNAPHeader));
                    Entry->ate_state = ARP_GOOD;
                    Entry->ate_valid = Now;
                    Entry->ate_useticks = ArpCacheLife;
                    Entry->ate_addrlength = (uchar) (sizeof(TRHeader) +
                                                     SourceRouteSize + sizeof(SNAPHeader));
                    *(ushort *) & Entry->ate_addr[Entry->ate_addrlength - 2] =
                    net_short(ARP_ETYPE_IP);
                }
                break;
            case NdisMediumFddi:
                FHdr = (FDDIHeader *) Entry->ate_addr;

                FHdr->fh_pri = ARP_FDDI_PRI;
                RtlCopyMemory(FHdr->fh_daddr, SHAddr, ARP_802_ADDR_LENGTH);
                RtlCopyMemory(FHdr->fh_saddr, Interface->ai_addr,
                           ARP_802_ADDR_LENGTH);
                RtlCopyMemory(&Entry->ate_addr[sizeof(FDDIHeader)], ARPSNAP,
                           sizeof(SNAPHeader));
                Entry->ate_addrlength = (uchar) (sizeof(FDDIHeader) +
                                                 sizeof(SNAPHeader));
                *(ushort UNALIGNED *) & Entry->ate_addr[Entry->ate_addrlength - 2] =
                net_short(ARP_ETYPE_IP);
                Entry->ate_state = ARP_GOOD;
                Entry->ate_valid = Now;     // Mark last time he was
                // valid.

                Entry->ate_useticks = ArpCacheLife;
                break;
            case NdisMediumArcnet878_2:
                AHdr = (ARCNetHeader *) Entry->ate_addr;
                AHdr->ah_saddr = Interface->ai_addr[0];
                AHdr->ah_daddr = *SHAddr;
                AHdr->ah_prot = ARP_ARCPROT_IP;
                Entry->ate_addrlength = sizeof(ARCNetHeader);
                Entry->ate_state = ARP_GOOD;
                Entry->ate_valid = Now;     // Mark last time he was
                // valid.

                break;
            default:
                ASSERT(0);
                break;
            }
        }

        if (Entry->ate_resolveonly) {

            ARPControlBlock *ArpContB, *TmpArpContB;

            ArpContB = Entry->ate_resolveonly;
            ASSERT(Entry->ate_resolveonly != NULL);

            while (ArpContB) {

                ArpRtn rtn;

                rtn = (ArpRtn) ArpContB->CompletionRtn;

                ArpContB->status = FillARPControlBlock(Interface, Entry,
                                                       ArpContB);
                TmpArpContB = ArpContB->next;
                (*rtn) (ArpContB, STATUS_SUCCESS);
                ArpContB = TmpArpContB;
            }

            Entry->ate_resolveonly = NULL;

            if (Entry->ate_userarp) {

                PNDIS_PACKET OldPacket = NULL;

                OldPacket = Entry->ate_packet;
                CTEFreeLock(&Entry->ate_lock, LHandle);
                CTEFreeMem(Entry);

                if (OldPacket) {
                    IPSendComplete(Interface->ai_context, OldPacket,
                                   NDIS_STATUS_SUCCESS);
                }
            } else {
                CTEFreeLock(&Entry->ate_lock, LHandle);
            }
            return NDIS_STATUS_SUCCESS;
        }

        // At this point we've updated the entry, and we still hold the lock
        // on it. If we have a packet that was pending to be sent, send it now.
        // Otherwise just free the lock.

        Packet = Entry->ate_packet;

        if (Packet != NULL) {
            // We have a packet to send.
            ASSERT(Entry->ate_state == ARP_GOOD);

            Entry->ate_packet = NULL;

            DEBUGMSG(DBG_INFO && DBG_ARP && DBG_TX,
                     (DTEXT("ARPHandlePacket: Sending packet %x after resolving ATE %x\n"),
                      Packet, Entry));

            if (ARPSendData(Interface, Packet, Entry, LHandle) != NDIS_STATUS_PENDING) {
                IPSendComplete(Interface->ai_context, Packet, NDIS_STATUS_SUCCESS);
            }
        } else {
            CTEFreeLock(&Entry->ate_lock, LHandle);
        }
    }
    // See if the MTU is less than our local one. This should only happen
    // in the case of token ring source routing.
    if (MaxMTU < Interface->ai_mtu) {
        LLIPAddrMTUChange LAM;

        LAM.lam_mtu = MaxMTU;
        LAM.lam_addr = *SPAddr;

        // It is less. Notify IP.
        ASSERT(Interface->ai_media == NdisMedium802_5);
        IPStatus(Interface->ai_context, LLIP_STATUS_ADDR_MTU_CHANGE,
                 &LAM, sizeof(LLIPAddrMTUChange), NULL);

    }
    // At this point we've updated the entry (if we had one), and we've freed
    // all locks. If it's for a local address and it's a request, reply to
    // it.
    if (LocalAddr) {                    // It's for us.

        if (ARPHdr->ah_opcode == net_short(ARP_REQUEST)) {
            // It's a request, and we need to respond.
            SendARPReply(Interface, *SPAddr, *DPAddr,
                         SHAddr, SourceRoute, SourceRouteSize, UseSNAP);
        }
    }
    return NDIS_STATUS_SUCCESS;
}

//* InitAdapter - Initialize an adapter.
//
//  Called when an adapter is open to finish initialization. We set
//  up our lookahead size and packet filter, and we're ready to go.
//
//  Entry:
//      adapter - Pointer to an adapter structure for the adapter to be
//                  initialized.
//
//  Exit: Nothing
//
void
InitAdapter(ARPInterface * Adapter)
{
    NDIS_STATUS Status;
    CTELockHandle Handle;
    ARPIPAddr *Addr, *OldAddr;

    if ((Status = DoNDISRequest(Adapter, NdisRequestSetInformation,
                                OID_GEN_CURRENT_LOOKAHEAD, &ARPLookahead, sizeof(ARPLookahead),
                                NULL, TRUE)) != NDIS_STATUS_SUCCESS) {
        Adapter->ai_operstatus = INTERFACE_UNINIT;
        return;
    }
    if ((Status = DoNDISRequest(Adapter, NdisRequestSetInformation,
                                OID_GEN_CURRENT_PACKET_FILTER, &Adapter->ai_pfilter, sizeof(uint),
                                NULL, TRUE)) == NDIS_STATUS_SUCCESS) {
        uint MediaStatus;

        Adapter->ai_adminstate = IF_STATUS_UP;

        Adapter->ai_mediastatus = TRUE;

        if ((Status = DoNDISRequest(Adapter, NdisRequestQueryInformation,
                                OID_GEN_MEDIA_CONNECT_STATUS, &MediaStatus, sizeof(MediaStatus),
                                NULL, TRUE)) == NDIS_STATUS_SUCCESS) {
            if (MediaStatus == NdisMediaStateDisconnected) {
                Adapter->ai_mediastatus = FALSE;
            }
        }

        ARPUpdateOperStatus(Adapter);

        // Now walk through any addresses we have and ARP for them , only when ArpRetryCount != 0.
        if (ArpRetryCount) {
            CTEGetLock(&Adapter->ai_lock, &Handle);
            OldAddr = NULL;
            Addr = &Adapter->ai_ipaddr;
            do {
                if (!IP_ADDR_EQUAL(Addr->aia_addr, NULL_IP_ADDR)) {
                    IPAddr Address = Addr->aia_addr;

                    Addr->aia_age = ArpRetryCount;
                    CTEFreeLock(&Adapter->ai_lock, Handle);
                    OldAddr = Addr;
                    SendARPRequest(Adapter, Address, ARP_RESOLVING_GLOBAL,
                                   NULL, TRUE);
                    CTEGetLock(&Adapter->ai_lock, &Handle);

                    Addr = &Adapter->ai_ipaddr;
                    while (Addr != OldAddr && Addr != NULL) {
                        Addr = Addr->aia_next;
                    }
                  
                    if (Addr != NULL) {
                        Addr = Addr->aia_next;
                    }
                } else {
                    Addr = Addr->aia_next;
                }
            } while (Addr != NULL);

            CTEFreeLock(&Adapter->ai_lock, Handle);
        }

    } else {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                  "**InitAdapter setting FAILED\n"));

        Adapter->ai_operstatus = INTERFACE_UNINIT;
    }
}

//** ARPOAComplete - ARP Open adapter complete handler.
//
//  This routine is called by the NDIS driver when an open adapter
//  call completes. Presumably somebody is blocked waiting for this, so
//  we'll wake him up now.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Status - Final status of command.
//      ErrorStatus - Final error status.
//
//  Exit: Nothing.
//
void NDIS_API
ARPOAComplete(NDIS_HANDLE Handle, NDIS_STATUS Status, NDIS_STATUS ErrorStatus)
{
    ARPInterface *ai = (ARPInterface *) Handle;    // For compiler.

    UNREFERENCED_PARAMETER(ErrorStatus);

    CTESignal(&ai->ai_block, (uint) Status);    // Wake him up, and return status.

}

//** ARPCAComplete - ARP close adapter complete handler.
//
//  This routine is called by the NDIS driver when a close adapter
//  call completes.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Status - Final status of command.
//
//  Exit: Nothing.
//
void NDIS_API
ARPCAComplete(NDIS_HANDLE Handle, NDIS_STATUS Status)
{
    ARPInterface *ai = (ARPInterface *) Handle;    // For compiler.

    CTESignal(&ai->ai_block, (uint) Status);    // Wake him up, and return status.

}

//** ARPSendComplete - ARP send complete handler.
//
//  This routine is called by the NDIS driver when a send completes.
//  This is a pretty time critical operation, we need to get through here
//  quickly. We'll strip our buffer off and put it back, and call the upper
//  later send complete handler.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Packet - A pointer to the packet that was sent.
//      Status - Final status of command.
//
//  Exit: Nothing.
//
void NDIS_API
ARPSendComplete(NDIS_HANDLE Handle, PNDIS_PACKET Packet, NDIS_STATUS Status)
{
    ARPInterface *Interface = (ARPInterface *) Handle;
    PacketContext *PC = (PacketContext *) Packet->ProtocolReserved;
    PNDIS_BUFFER Buffer;
    uint  DataLength;
    ulong Proc;

    Proc = KeGetCurrentProcessorNumber();
    Interface->ai_qlen[Proc].ai_qlen--;

    if (Status == NDIS_STATUS_SUCCESS) {
        DataLength = Packet->Private.TotalLength;
        if (!(Packet->Private.ValidCounts)) {

            NdisQueryPacket(Packet, NULL, NULL, NULL,&DataLength);
        }
        Interface->ai_outoctets += DataLength;
    } else {
        if (Status == NDIS_STATUS_RESOURCES)
            Interface->ai_outdiscards++;
        else
            Interface->ai_outerrors++;
    }

#if BACK_FILL
    // Get first buffer on packet.
    if (Interface->ai_media == NdisMedium802_3) {

        PMDL TmpMdl = NULL;
        uint HdrSize;

        NdisQueryPacket(Packet, NULL, NULL, &TmpMdl, NULL);

        if (TmpMdl->MdlFlags & MDL_NETWORK_HEADER) {
            HdrSize = sizeof(ENetHeader);
            if (((PacketContext*)
                 Packet->ProtocolReserved)->pc_common.pc_flags &
                PACKET_FLAG_SNAP)
                HdrSize += Interface->ai_snapsize;

            TmpMdl->MappedSystemVa = (PVOID) (((ULONG_PTR)
                                              TmpMdl->MappedSystemVa) +
                                              HdrSize);
            TmpMdl->ByteOffset += HdrSize;
            TmpMdl->ByteCount -= HdrSize;
        } else {
            NdisUnchainBufferAtFront(Packet, &Buffer);
            FreeARPBuffer(Interface, Buffer);    // Free it up.

        }

    } else {
        NdisUnchainBufferAtFront(Packet, &Buffer);
        FreeARPBuffer(Interface, Buffer);    // Free it up.

    }

#else
    // Get first buffer on packet.
    NdisUnchainBufferAtFront(Packet, &Buffer);

    ASSERT(Buffer);

    FreeARPBuffer(Interface, Buffer);   // Free it up.

#endif

    if (PC->pc_common.pc_owner != PACKET_OWNER_LINK) {    // We don't own this one.

        IPSendComplete(Interface->ai_context, Packet, Status);
        return;
    }
    // This packet belongs to us, so free it.
    NdisFreePacket(Packet);

}

//** ARPTDComplete - ARP transfer data complete handler.
//
//  This routine is called by the NDIS driver when a transfer data
//  call completes. Since we never transfer data ourselves, this must be
//  from the upper layer. We'll just call his routine and let him deal
//  with it.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Packet - A pointer to the packet used for the TD.
//      Status - Final status of command.
//      BytesCopied - Count of bytes copied.
//
//  Exit: Nothing.
//
void NDIS_API
ARPTDComplete(NDIS_HANDLE Handle, PNDIS_PACKET Packet, NDIS_STATUS Status,
              uint BytesCopied)
{
    ARPInterface *ai = (ARPInterface *) Handle;

    IPTDComplete(ai->ai_context, Packet, Status, BytesCopied);

}

//** ARPResetComplete - ARP reset complete handler.
//
//  This routine is called by the NDIS driver when a reset completes.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Status - Final status of command.
//
//  Exit: Nothing.
//
void NDIS_API
ARPResetComplete(NDIS_HANDLE Handle, NDIS_STATUS Status)
{
    ARPInterface *ai = (ARPInterface *) Handle;

    UNREFERENCED_PARAMETER(Status);

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ArpResetComplete on %x\n", ai->ai_context));
    IPReset(ai->ai_context);
}

//** ARPRequestComplete - ARP request complete handler.
//
//  This routine is called by the NDIS driver when a general request
//  completes. If ARP blocks on a request, we'll just give a wake up
//  to whoever's blocked on this request. Else if it is a non-blocking
//  request, we extract the request complete callback fn in the request
//  call it, and then deallocate the request block (that is on the heap)
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Request - A pointer to the request that completed.
//      Status - Final status of command.
//
//  Exit: Nothing.
//
void NDIS_API
ARPRequestComplete(NDIS_HANDLE Handle, PNDIS_REQUEST pRequest,
                   NDIS_STATUS Status)
{
    RequestBlock *rb = STRUCT_OF(RequestBlock, pRequest, Request);

    DBG_UNREFERENCED_PARAMETER(Handle);

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_REQUEST,
         (DTEXT("+ARPRequestComplete(%x, %x, %x) RequestBlock %x\n"),
          Handle, pRequest, Status, rb));

    if (rb->Blocking) {
        // Request through BLOCKING DoNDISRequest

        // Signal the blocked guy here
        CTESignal(&rb->Block, (uint) Status);

        if (InterlockedDecrement( (PLONG) &rb->RefCount) == 0) {
            CTEFreeMem(rb);
        }
    } else {
        ReqInfoBlock *rib;
        RCCALL reqcallback;

        // Request through NON-BLOCKING DoNDISRequest

        // Extract the callback fn pointer & params
        if (pRequest->RequestType == NdisRequestSetInformation)
            rib = STRUCT_OF(ReqInfoBlock,
                            pRequest->DATA.SET_INFORMATION.InformationBuffer,
                            RequestInfo);
        else
            rib = STRUCT_OF(ReqInfoBlock,
                            pRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                            RequestInfo);

        reqcallback = rib->ReqCompleteCallback;
        if (reqcallback)
            reqcallback(rib);

        // Free ARP memory associated with request
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPRequestComplete: Freeing mem at pRequest = %08X\n", rb));
        CTEFreeMem(rb);
    }

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_REQUEST,
         (DTEXT("-ARPRequestComplete [%x]\n"), Status));
}

//** ARPRcv - ARP receive data handler.
//
//  This routine is called when data arrives from the NDIS driver.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Context - NDIS context to be used for TD.
//      Header - Pointer to header
//      HeaderSize - Size of header
//      Data - Pointer to buffer of received data
//      Size - Byte count of data in buffer.
//      TotalSize - Byte count of total packet size.
//
//  Exit: Status indicating whether or not we took the packet.
//
NDIS_STATUS NDIS_API
ARPRcv(NDIS_HANDLE Handle, NDIS_HANDLE Context, void *Header, uint HeaderSize,
       void *Data, uint Size, uint TotalSize)
{
    ARPInterface *Interface = Handle;
    NDIS_STATUS status;
    PINT OrigPacket = NULL;

    //get the original packet (if any)
    //this is required to make task offload work
    //note: We shall hack the pClientCount Field
    //to point to the packet as a short term solution
    //to avoid changing all atm - ip interface changes

    if (Interface->ai_OffloadFlags || Interface->ai_IPSecOffloadFlags) {
        OrigPacket = (PINT) NdisGetReceivedPacket(Interface->ai_handle, Context);
    }

    //Call the new interface with null mdl and context pointers

    status = ARPRcvIndicationNew(Handle, Context, Header, HeaderSize,
                                 Data, Size, TotalSize, NULL, OrigPacket);

    return status;
}

//** ARPRcvPacket - ARP receive data handler.
//
//  This routine is called when data arrives from the NDIS driver.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Packet - Contains the incoming frame
//
//  Returns number of upper layer folks latching on to this frame
//
//
INT
ARPRcvPacket(NDIS_HANDLE Handle, PNDIS_PACKET Packet)
{
    UINT HeaderBufferSize = NDIS_GET_PACKET_HEADER_SIZE(Packet);
    UINT firstbufferLength, bufferLength, LookAheadBufferSize;
    PNDIS_BUFFER pFirstBuffer;
    PUCHAR headerBuffer;
    NTSTATUS ntStatus;
    INT ClientCnt = 0;

    //
    // Query the number of buffers, the first MDL's descriptor and the packet length
    //

    NdisGetFirstBufferFromPacket(Packet,    // packet
                                 &pFirstBuffer,    // first buffer descriptor
                                 &headerBuffer,    // ptr to the start of packet
                                 &firstbufferLength,    // length of the header+lookahead
                                 &bufferLength);    // length of the bytes in the buffers

    //
    // ReceiveContext is the packet itself
    //


    LookAheadBufferSize = firstbufferLength - HeaderBufferSize;

    ntStatus = ARPRcvIndicationNew(Handle, Packet, headerBuffer,
                                   HeaderBufferSize,
                                   headerBuffer + HeaderBufferSize,    // LookaheadBuffer
                                   LookAheadBufferSize,    // LookaheadBufferSize
                                   bufferLength - HeaderBufferSize,    // PacketSize - since
                                   // the whole packet is
                                   // indicated
                                   pFirstBuffer,    // pMdl
                                   &ClientCnt    // tdi client count
                                  );

    return ClientCnt;
}

//** ARPRcvIndicationNew - ARP receive data handler.
//
//  This routine is called when data arrives from the NDIS driver.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      Context - NDIS context to be used for TD.
//      Header - Pointer to header
//      HeaderSize - Size of header
//      Data - Pointer to buffer of received data
//      Size - Byte count of data in buffer.
//      TotalSize - Byte count of total packet size.
//      pMdl - NDIS_BUFFER of incoming frame
//      pClientCnt address to return the clinet counts
//
//  Exit: Status indicating whether or not we took the packet.
//
NDIS_STATUS NDIS_API
ARPRcvIndicationNew(NDIS_HANDLE Handle, NDIS_HANDLE Context, void *Header,
                    uint HeaderSize, void *Data, uint Size, uint TotalSize,
                    PNDIS_BUFFER pNdisBuffer, PINT pClientCnt)
{
    ARPInterface *Interface = Handle;   // Interface for this driver.
    ENetHeader UNALIGNED *EHdr = (ENetHeader UNALIGNED *) Header;
    SNAPHeader UNALIGNED *SNAPHdr;
    ushort type;                        // Protocol type
    uint ProtOffset;                    // Offset in Data to non-media info.
    uint NUCast;                        // TRUE if the frame is not a unicast frame.

    if ((Interface->ai_operstatus == INTERFACE_UP) &&
        HeaderSize >= (uint) Interface->ai_hdrsize) {

        // Per RFC 1213 and its successors, the inoctets count includes
        // the MAC header bytes.
        Interface->ai_inoctets += HeaderSize + TotalSize;

        NUCast = ((*((uchar UNALIGNED *) EHdr + Interface->ai_bcastoff) &
                   Interface->ai_bcastmask) == Interface->ai_bcastval) ?
                 AI_NONUCAST_INDEX : AI_UCAST_INDEX;

        if ((Interface->ai_promiscuous) && (!NUCast)) {    // AI_UCAST_INDEX = 0

            switch (Interface->ai_media) {
            case NdisMedium802_3:{
                    // Enet
                    if (Interface->ai_addrlen != ARP_802_ADDR_LENGTH ||
                        CTEMemCmp(EHdr->eh_daddr, Interface->ai_addr, ARP_802_ADDR_LENGTH) != 0) {
                        NUCast = AI_PROMIS_INDEX;
                    }
                    break;
                }
            case NdisMedium802_5:{
                    // token ring
                    TRHeader UNALIGNED *THdr = (TRHeader UNALIGNED *) Header;
                    if (Interface->ai_addrlen != ARP_802_ADDR_LENGTH ||
                        CTEMemCmp(THdr->tr_daddr, Interface->ai_addr, ARP_802_ADDR_LENGTH) != 0) {
                        NUCast = AI_PROMIS_INDEX;
                    }
                    break;
                }
            case NdisMediumFddi:{
                    // FDDI
                    FDDIHeader UNALIGNED *FHdr = (FDDIHeader UNALIGNED *) Header;
                    if (Interface->ai_addrlen != ARP_802_ADDR_LENGTH ||
                        CTEMemCmp(FHdr->fh_daddr, Interface->ai_addr, ARP_802_ADDR_LENGTH) != 0) {
                        NUCast = AI_PROMIS_INDEX;
                    }
                    break;
                }
            case NdisMediumArcnet878_2:{
                    // ArcNet
                    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_RX,
                             (DTEXT("-ARPRcvIndicationNew [NOT_RECOGNIZED]\n")));

                    return NDIS_STATUS_NOT_RECOGNIZED;
                    break;
                }
            default:
                ASSERT(0);
                Interface->ai_outerrors++;
                DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_RX,
                         (DTEXT("-ARPRcvIndicationNew [UNSUPPORTED_MEDIA]\n")));
                return NDIS_STATUS_UNSUPPORTED_MEDIA;
            }
        }

        if ((Interface->ai_media == NdisMedium802_3) &&
            (type = net_short(EHdr->eh_type)) >= MIN_ETYPE) {
            ProtOffset = 0;
        } else if (Interface->ai_media != NdisMediumArcnet878_2) {
            SNAPHdr = (SNAPHeader UNALIGNED *) Data;

            if (Size >= sizeof(SNAPHeader) &&
                SNAPHdr->sh_dsap == SNAP_SAP &&
                SNAPHdr->sh_ssap == SNAP_SAP &&
                SNAPHdr->sh_ctl == SNAP_UI) {
                type = net_short(SNAPHdr->sh_etype);
                ProtOffset = sizeof(SNAPHeader);
            } else {
                //handle XID/TEST here.
                Interface->ai_uknprotos++;
                return NDIS_STATUS_NOT_RECOGNIZED;
            }
        } else {
            ARCNetHeader UNALIGNED *AH = (ARCNetHeader UNALIGNED *) Header;

            ProtOffset = 0;
            if (AH->ah_prot == ARP_ARCPROT_IP)
                type = ARP_ETYPE_IP;
            else if (AH->ah_prot == ARP_ARCPROT_ARP)
                type = ARP_ETYPE_ARP;
            else
                type = 0;
        }

        if (type == ARP_ETYPE_IP) {

            (Interface->ai_inpcount[NUCast])++;

            ASSERT (KeGetCurrentIrql() <= DISPATCH_LEVEL);

            IPRcvPacket(Interface->ai_context, (uchar *) Data + ProtOffset,
                        Size - ProtOffset, TotalSize - ProtOffset, Context, ProtOffset,
                        NUCast, HeaderSize, pNdisBuffer, (PUINT) pClientCnt, NULL);
            return NDIS_STATUS_SUCCESS;
        } else {
            if (type == ARP_ETYPE_ARP) {
                (Interface->ai_inpcount[NUCast])++;
                return HandleARPPacket(Interface, Header, HeaderSize,
                                       (ARPHeader *) ((uchar *) Data + ProtOffset), Size - ProtOffset,
                                       ProtOffset);
            } else {
                Interface->ai_uknprotos++;
                return NDIS_STATUS_NOT_RECOGNIZED;
            }
        }
    } else {
        // Interface is marked as down.
        return NDIS_STATUS_NOT_RECOGNIZED;
    }
}

//** ARPRcvComplete - ARP receive complete handler.
//
//  This routine is called by the NDIS driver after some number of
//  receives. In some sense, it indicates 'idle time'.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//
//  Exit: Nothing.
//
void NDIS_API
ARPRcvComplete(NDIS_HANDLE Handle)
{
    UNREFERENCED_PARAMETER(Handle);

    IPRcvComplete();
}

//** ARPStatus - ARP status handler.
//
//  Called by the NDIS driver when some sort of status change occurs.
//  We take action depending on the type of status.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      GStatus - General type of status that caused the call.
//      Status - Pointer to a buffer of status specific information.
//      StatusSize - Size of the status buffer.
//
//  Exit: Nothing.
//
void NDIS_API
ARPStatus(NDIS_HANDLE Handle, NDIS_STATUS GStatus, void *Status, uint
          StatusSize)
{
    ARPInterface *ai = (ARPInterface *) Handle;

    //
    // ndis calls this sometimes even before ip interface is created.
    //
    if ((ai->ai_context) && (ai->ai_operstatus != INTERFACE_INIT)) {

        IPStatus(ai->ai_context, GStatus, Status, StatusSize, NULL);

        switch (GStatus) {

        //reflect media connect/disconnect status in
        //operstatus for query purpose

        case NDIS_STATUS_MEDIA_CONNECT:

            ai->ai_mediastatus = TRUE;
            ARPUpdateOperStatus(ai);
            break;

        case NDIS_STATUS_MEDIA_DISCONNECT:

            ai->ai_mediastatus = FALSE;
            ARPUpdateOperStatus(ai);
            break;

        default:
            break;
        }
    }
}

//** ARPStatusComplete - ARP status complete handler.
//
//  A routine called by the NDIS driver so that we can do postprocessing
//  after a status event.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//
//  Exit: Nothing.
//
void NDIS_API
ARPStatusComplete(NDIS_HANDLE Handle)
{
    UNREFERENCED_PARAMETER(Handle);
}

//** ARPPnPEvent - ARP PnPEvent handler.
//
//  Called by the NDIS driver when PnP or PM events occurs.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      NetPnPEvent - This is a pointer to a NET_PNP_EVENT that describes
//                    the PnP indication.
//
//  Exit:
//      Just call into IP and return status.
//
NDIS_STATUS
ARPPnPEvent(NDIS_HANDLE Handle, PNET_PNP_EVENT NetPnPEvent)
{
    ARPInterface *ai = (ARPInterface *) Handle;

    //
    // ndis can calls this sometimes even before ip interface is created.
    //
    if (ai && !ai->ai_context) {
        return STATUS_SUCCESS;
    } else {

        return IPPnPEvent(ai ? ai->ai_context : NULL, NetPnPEvent);
    }

}

//** ARPSetNdisRequest - ARP Ndisrequest handler.
//
//  Called by the upper driver to set the packet filter for the interface.
//
//      Entry:
//      Context     - Context value we gave to IP (really a pointer to an AI).
//      OID         - Object ID to set/unset
//      On          - Set_if, clear_if or clear_card
//
//  Exit:
//      returns status.
//
NDIS_STATUS
__stdcall
ARPSetNdisRequest(void *Context, NDIS_OID OID, uint On)
{
    int Status;

    ARPInterface *Interface = (ARPInterface *) Context;
    if (On == SET_IF) {
        Interface->ai_pfilter |= OID;
        if (OID == NDIS_PACKET_TYPE_PROMISCUOUS) {
            Interface->ai_promiscuous = 1;
        }
        Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                               OID_GEN_CURRENT_PACKET_FILTER, &Interface->ai_pfilter,
                               sizeof(uint), NULL, TRUE);
    } else {                            // turn off

        Interface->ai_pfilter &= ~(OID);

        if (OID == NDIS_PACKET_TYPE_PROMISCUOUS) {
            Interface->ai_promiscuous = 0;
        }
        Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                               OID_GEN_CURRENT_PACKET_FILTER, &Interface->ai_pfilter,
                               sizeof(uint), NULL, TRUE);
    }
    return Status;
}

//** ARPPnPComplete - ARP PnP complete handler.
//
//  Called by the upper driver to do the post processing of pnp event.
//
//      Entry:
//      Context     - Context value we gave to IP (really a pointer to an AI).
//      Status      - Status code of the pnp operation.
//      NetPnPEvent - This is a pointer to a NET_PNP_EVENT that describes
//                    the PnP indication.
//
//  Exit:
//      returns nothing.
//
void
__stdcall
ARPPnPComplete(void *Context, NDIS_STATUS Status, PNET_PNP_EVENT NetPnPEvent)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    NdisCompletePnPEvent(Status, (Interface ? Interface->ai_handle : NULL), NetPnPEvent);
}

extern void NDIS_API ARPBindAdapter(PNDIS_STATUS RetStatus,
                                    NDIS_HANDLE BindContext,
                                    PNDIS_STRING AdapterName,
                                    PVOID SS1, PVOID SS2);
extern void NDIS_API ARPUnbindAdapter(PNDIS_STATUS RetStatus,
                                      NDIS_HANDLE ProtBindContext,
                                      NDIS_HANDLE UnbindContext);
extern void NDIS_API ARPUnloadProtocol(void);

extern void ArpUnload(PDRIVER_OBJECT);

//* ARPReadNext - Read the next entry in the ARP table.
//
//  Called by the GetInfo code to read the next ATE in the table. We assume
//  the context passed in is valid, and the caller has the ARP TableLock.
//
//  Input:  Context     - Pointer to a IPNMEContext.
//          Interface   - Pointer to interface for table to read on.
//          Buffer      - Pointer to an IPNetToMediaEntry structure.
//
//  Returns: TRUE if more data is available to be read, FALSE is not.
//
uint
ARPReadNext(void *Context, ARPInterface * Interface, void *Buffer)
{
    IPNMEContext *NMContext = (IPNMEContext *) Context;
    IPNetToMediaEntry *IPNMEntry = (IPNetToMediaEntry *) Buffer;
    CTELockHandle Handle;
    ARPTableEntry *CurrentATE;
    uint i;
    ARPTable *Table = Interface->ai_ARPTbl;
    uint AddrOffset;

    CurrentATE = NMContext->inc_entry;

    // Fill in the buffer.
    CTEGetLock(&CurrentATE->ate_lock, &Handle);
    IPNMEntry->inme_index = Interface->ai_index;
    IPNMEntry->inme_physaddrlen = Interface->ai_addrlen;

    switch (Interface->ai_media) {
    case NdisMedium802_3:
        AddrOffset = 0;
        break;
    case NdisMedium802_5:
        AddrOffset = offsetof(struct TRHeader, tr_daddr);
        break;
    case NdisMediumFddi:
        AddrOffset = offsetof(struct FDDIHeader, fh_daddr);
        break;
    case NdisMediumArcnet878_2:
        AddrOffset = offsetof(struct ARCNetHeader, ah_daddr);
        break;
    default:
        AddrOffset = 0;
        break;
    }

    RtlCopyMemory(IPNMEntry->inme_physaddr, &CurrentATE->ate_addr[AddrOffset],
               Interface->ai_addrlen);
    IPNMEntry->inme_addr = CurrentATE->ate_dest;

    if (CurrentATE->ate_state == ARP_GOOD)
        IPNMEntry->inme_type = (CurrentATE->ate_valid == ALWAYS_VALID ?
                                INME_TYPE_STATIC : INME_TYPE_DYNAMIC);
    else
        IPNMEntry->inme_type = INME_TYPE_INVALID;
    CTEFreeLock(&CurrentATE->ate_lock, Handle);

    // We've filled it in. Now update the context.
    if (CurrentATE->ate_next != NULL) {
        NMContext->inc_entry = CurrentATE->ate_next;
        return TRUE;
    } else {
        // The next ATE is NULL. Loop through the ARP Table looking for a new
        // one.
        i = NMContext->inc_index + 1;
        while (i < ARP_TABLE_SIZE) {
            if ((*Table)[i] != NULL) {
                NMContext->inc_entry = (*Table)[i];
                NMContext->inc_index = i;
                return TRUE;
                break;
            } else
                i++;
        }

        NMContext->inc_index = 0;
        NMContext->inc_entry = NULL;
        return FALSE;
    }

}

//* ARPValidateContext - Validate the context for reading an ARP table.
//
//  Called to start reading an ARP table sequentially. We take in
//  a context, and if the values are 0 we return information about the
//  first route in the table. Otherwise we make sure that the context value
//  is valid, and if it is we return TRUE.
//  We assume the caller holds the ARPInterface lock.
//
//  Input:  Context     - Pointer to a RouteEntryContext.
//          Interface   - Pointer to an interface
//          Valid       - Where to return information about context being
//                          valid.
//
//  Returns: TRUE if more data to be read in table, FALSE if not. *Valid set
//      to TRUE if input context is valid
//
uint
ARPValidateContext(void *Context, ARPInterface * Interface, uint * Valid)
{
    IPNMEContext *NMContext = (IPNMEContext *) Context;
    uint i;
    ARPTableEntry *TargetATE;
    ARPTableEntry *CurrentATE;
    ARPTable *Table = Interface->ai_ARPTbl;

    i = NMContext->inc_index;
    TargetATE = NMContext->inc_entry;

    // If the context values are 0 and NULL, we're starting from the beginning.
    if (i == 0 && TargetATE == NULL) {
        *Valid = TRUE;
        do {
            if ((CurrentATE = (*Table)[i]) != NULL) {
                break;
            }
            i++;
        } while (i < ARP_TABLE_SIZE);

        if (CurrentATE != NULL) {
            NMContext->inc_index = i;
            NMContext->inc_entry = CurrentATE;
            return TRUE;
        } else
            return FALSE;

    } else {

        // We've been given a context. We just need to make sure that it's
        // valid.

        if (i < ARP_TABLE_SIZE) {
            CurrentATE = (*Table)[i];
            while (CurrentATE != NULL) {
                if (CurrentATE == TargetATE) {
                    *Valid = TRUE;
                    return TRUE;
                    break;
                } else {
                    CurrentATE = CurrentATE->ate_next;
                }
            }

        }
        // If we get here, we didn't find the matching ATE.
        *Valid = FALSE;
        return FALSE;

    }

}

#define IFE_FIXED_SIZE  offsetof(struct IFEntry, if_descr)

//* ARPQueryInfo - ARP query information handler.
//
//  Called to query information about the ARP table or statistics about the
//  actual interface.
//
//  Input:  IFContext       - Interface context (pointer to an ARPInterface).
//          ID              - TDIObjectID for object.
//          Buffer          - Buffer to put data into.
//          Size            - Pointer to size of buffer. On return, filled with
//                              bytes copied.
//          Context         - Pointer to context block.
//
//  Returns: Status of attempt to query information.
//
int
__stdcall
ARPQueryInfo(void *IFContext, TDIObjectID * ID, PNDIS_BUFFER Buffer, uint * Size,
             void *Context)
{
    ARPInterface *AI = (ARPInterface *) IFContext;
    uint Offset = 0;
    uint BufferSize = *Size;
    CTELockHandle Handle;
    uint ContextValid, DataLeft;
    uint BytesCopied = 0;
    uchar InfoBuff[sizeof(IFEntry)];
    uint Entity;
    uint Instance;
    BOOLEAN fStatus;
    long QueueLength = 0;
    uint i;

     DEBUGMSG(DBG_TRACE && DBG_QUERYINFO,
         (DTEXT("+ARPQueryInfo(%x, %x, %x, %x, %x)\n"),
         IFContext, ID, Buffer, Size, Context));

    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // TCPTRACE(("ARPQueryInfo: AI %lx, Instance %lx, ai_atinst %lx, ai_ifinst %lx\n",
    //    AI, Instance, AI->ai_atinst, AI->ai_ifinst ));

    // First, make sure it's possibly an ID we can handle.
    if ((Entity != AT_ENTITY || Instance != AI->ai_atinst) &&
        (Entity != IF_ENTITY || Instance != AI->ai_ifinst)) {
        return TDI_INVALID_REQUEST;
    }
    *Size = 0;                          // In case of an error.

    if (ID->toi_type != INFO_TYPE_PROVIDER)
        return TDI_INVALID_PARAMETER;

    if (ID->toi_class == INFO_CLASS_GENERIC) {
        if (ID->toi_id == ENTITY_TYPE_ID) {
            // He's trying to see what type we are.
            if (BufferSize >= sizeof(uint)) {
                *(uint *) & InfoBuff[0] = (Entity == AT_ENTITY) ? AT_ARP :
                                          IF_MIB;
                fStatus = CopyToNdisSafe(Buffer, NULL, InfoBuff, sizeof(uint), &Offset);

                if (fStatus == FALSE) {
                    return TDI_NO_RESOURCES;
                }
                *Size = sizeof(uint);
                return TDI_SUCCESS;
            } else
                return TDI_BUFFER_TOO_SMALL;
        }
        return TDI_INVALID_PARAMETER;
    }
    // Might be able to handle this.
    if (Entity == AT_ENTITY) {
        // It's an address translation object. It could be a MIB object or
        // an implementation specific object (the generic objects were handled
        // above).

        if (ID->toi_class == INFO_CLASS_IMPLEMENTATION) {
            ARPPArpAddr *PArpAddr;

            // It's an implementation specific ID. The only ones we handle
            // are the PARP_COUNT_ID and the PARP_ENTRY ID.

            if (ID->toi_id == AT_ARP_PARP_COUNT_ID) {
                // He wants to know the count. Just return that to him.
                if (BufferSize >= sizeof(uint)) {

                    CTEGetLock(&AI->ai_lock, &Handle);

                    fStatus = CopyToNdisSafe(Buffer, NULL, (uchar *) & AI->ai_parpcount,
                                             sizeof(uint), &Offset);

                    CTEFreeLock(&AI->ai_lock, Handle);

                    if (fStatus == FALSE) {
                        return TDI_NO_RESOURCES;
                    }
                    *Size = sizeof(uint);
                    return TDI_SUCCESS;
                } else
                    return TDI_BUFFER_TOO_SMALL;
            }
            if (ID->toi_id != AT_ARP_PARP_ENTRY_ID)
                return TDI_INVALID_PARAMETER;

            // It's for Proxy ARP entries. The context should be either NULL
            // or a pointer to the next one to be read.
            CTEGetLock(&AI->ai_lock, &Handle);

            PArpAddr = *(ARPPArpAddr **) Context;

            if (PArpAddr != NULL) {
                ARPPArpAddr *CurrentPARP;

                // Loop through the P-ARP addresses on the interface, and
                // see if we can find this one.
                CurrentPARP = AI->ai_parpaddr;
                while (CurrentPARP != NULL) {
                    if (CurrentPARP == PArpAddr)
                        break;
                    else
                        CurrentPARP = CurrentPARP->apa_next;
                }

                // If we found a match, PARPAddr points to where to begin
                // reading. Otherwise, fail the request.
                if (CurrentPARP == NULL) {
                    // Didn't find a match, so fail the request.
                    CTEFreeLock(&AI->ai_lock, Handle);
                    return TDI_INVALID_PARAMETER;
                }
            } else
                PArpAddr = AI->ai_parpaddr;

            // PARPAddr points to the next entry to put in the buffer, if
            // there is one.
            while (PArpAddr != NULL) {
                if ((int)(BufferSize - BytesCopied) >=
                    (int)sizeof(ProxyArpEntry)) {
                    ProxyArpEntry *TempPArp;

                    TempPArp = (ProxyArpEntry *) InfoBuff;
                    TempPArp->pae_status = PAE_STATUS_VALID;
                    TempPArp->pae_addr = PArpAddr->apa_addr;
                    TempPArp->pae_mask = PArpAddr->apa_mask;
                    BytesCopied += sizeof(ProxyArpEntry);
                    fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) TempPArp,
                                             sizeof(ProxyArpEntry), &Offset);

                    if (fStatus == FALSE) {
                        CTEFreeLock(&AI->ai_lock, Handle);
                        return TDI_NO_RESOURCES;
                    }
                    PArpAddr = PArpAddr->apa_next;
                } else
                    break;
            }

            // We're done copying. Free the lock and return the correct
            // status.
            CTEFreeLock(&AI->ai_lock, Handle);
            *Size = BytesCopied;
            **(ARPPArpAddr ***) & Context = PArpAddr;
            return(PArpAddr == NULL) ? TDI_SUCCESS : TDI_BUFFER_OVERFLOW;
        }
        if (ID->toi_id == AT_MIB_ADDRXLAT_INFO_ID) {
            AddrXlatInfo *AXI;

            // It's for the count. Just return the number of entries in the
            // table.
            if (BufferSize >= sizeof(AddrXlatInfo)) {
                *Size = sizeof(AddrXlatInfo);
                AXI = (AddrXlatInfo *) InfoBuff;
                AXI->axi_count = AI->ai_count;
                AXI->axi_index = AI->ai_index;
                fStatus = CopyToNdisSafe(Buffer, NULL, (uchar *) AXI, sizeof(AddrXlatInfo),
                                         &Offset);

                if (fStatus == FALSE) {
                    return TDI_NO_RESOURCES;
                }
                *Size = sizeof(AddrXlatInfo);
                return TDI_SUCCESS;
            } else
                return TDI_BUFFER_TOO_SMALL;
        }
        if (ID->toi_id == AT_MIB_ADDRXLAT_ENTRY_ID) {
            // He's trying to read the table.
            // Make sure we have a valid context.
            CTEGetLock(&AI->ai_ARPTblLock, &Handle);
            DataLeft = ARPValidateContext(Context, AI, &ContextValid);

            // If the context is valid, we'll continue trying to read.
            if (!ContextValid) {
                CTEFreeLock(&AI->ai_ARPTblLock, Handle);
                return TDI_INVALID_PARAMETER;
            }
            while (DataLeft) {
                // The invariant here is that there is data in the table to
                // read. We may or may not have room for it. So DataLeft
                // is TRUE, and BufferSize - BytesCopied is the room left
                // in the buffer.
                if ((int)(BufferSize - BytesCopied) >=
                    (int)sizeof(IPNetToMediaEntry)) {
                    DataLeft = ARPReadNext(Context, AI, InfoBuff);
                    BytesCopied += sizeof(IPNetToMediaEntry);
                    fStatus = CopyToNdisSafe(Buffer, &Buffer, InfoBuff,
                                             sizeof(IPNetToMediaEntry), &Offset);

                    if (fStatus == FALSE) {
                        CTEFreeLock(&AI->ai_ARPTblLock, Handle);
                        return(TDI_NO_RESOURCES);
                    }
                } else
                    break;

            }

            *Size = BytesCopied;

            CTEFreeLock(&AI->ai_ARPTblLock, Handle);
            return(!DataLeft ? TDI_SUCCESS : TDI_BUFFER_OVERFLOW);
        }
        return TDI_INVALID_PARAMETER;
    }
    if (ID->toi_class != INFO_CLASS_PROTOCOL)
        return TDI_INVALID_PARAMETER;

    // He must be asking for interface level information. See if we support
    // what he's asking for.
    if (ID->toi_id == IF_MIB_STATS_ID) {
        IFEntry *IFE = (IFEntry *) InfoBuff;
        uint speed;

        // He's asking for statistics. Make sure his buffer is at least big
        // enough to hold the fixed part.

        if (BufferSize < IFE_FIXED_SIZE) {
            return TDI_BUFFER_TOO_SMALL;
        }
        // He's got enough to hold the fixed part. Build the IFEntry structure,
        // and copy it to his buffer.
        IFE->if_index = AI->ai_index;
        switch (AI->ai_media) {
        case NdisMedium802_3:
            IFE->if_type = IF_TYPE_ETHERNET_CSMACD;
            break;
        case NdisMedium802_5:
            IFE->if_type = IF_TYPE_ISO88025_TOKENRING;
            break;
        case NdisMediumFddi:
            IFE->if_type = IF_TYPE_FDDI;
            break;
        case NdisMediumArcnet878_2:
        default:
            IFE->if_type = IF_TYPE_OTHER;
            break;
        }
        IFE->if_mtu = AI->ai_mtu;

        // Some adapters support dynamic speed settings and causes this
        // query to return a different speed from the Networks Connection
        // folder. Therefore, we will requery the speed of the
        // interface. Should we update the ai_speed? Anf if so, do we update
        // if_speed as well?

        IFE->if_speed = AI->ai_speed;

        if (AI->ai_mediastatus == TRUE) {

            if (DoNDISRequest(
                         AI,
                         NdisRequestQueryInformation,
                         OID_GEN_LINK_SPEED,
                         &speed,
                         sizeof(speed),
                         NULL,
                         TRUE) == NDIS_STATUS_SUCCESS) {
                // Update to real value we want to return.
                speed *= 100L;
                IFE->if_speed = speed;

            } else {
                // Should we fail, or just update with known speed.
                IFE->if_speed = AI->ai_speed;
            }
        }

        IFE->if_physaddrlen = AI->ai_addrlen;
        RtlCopyMemory(IFE->if_physaddr, AI->ai_addr, AI->ai_addrlen);
        IFE->if_adminstatus = (uint) AI->ai_adminstate;
        if (AI->ai_operstatus == INTERFACE_UP) {
            IFE->if_operstatus = IF_OPER_STATUS_OPERATIONAL;
        } else {
            // DOWN,INIT, and UNINIT all count as non-operational
            IFE->if_operstatus = IF_OPER_STATUS_NON_OPERATIONAL;
        }
        IFE->if_lastchange = AI->ai_lastchange;
        IFE->if_inoctets = AI->ai_inoctets;
        IFE->if_inucastpkts = AI->ai_inpcount[AI_UCAST_INDEX] + AI->ai_inpcount[AI_PROMIS_INDEX];
        IFE->if_innucastpkts = AI->ai_inpcount[AI_NONUCAST_INDEX];
        IFE->if_indiscards = AI->ai_indiscards;
        IFE->if_inerrors = AI->ai_inerrors;
        IFE->if_inunknownprotos = AI->ai_uknprotos;
        IFE->if_outoctets = AI->ai_outoctets;
        IFE->if_outucastpkts = AI->ai_outpcount[AI_UCAST_INDEX];
        IFE->if_outnucastpkts = AI->ai_outpcount[AI_NONUCAST_INDEX];
        IFE->if_outdiscards = AI->ai_outdiscards;
        IFE->if_outerrors = AI->ai_outerrors;

        for (i=0;  i < (uint)KeNumberProcessors; i++) {
             QueueLength += AI->ai_qlen[i].ai_qlen;
        }

        IFE->if_outqlen  = max(0, QueueLength);
        IFE->if_descrlen = AI->ai_desclen;
#if FFP_SUPPORT
        // If FFP enabled on this interface, adjust IF stats for FFP'd packets
        if (AI->ai_ffpversion) {
            FFPAdapterStats IFStatsInfo =
            {
                NDIS_PROTOCOL_ID_TCP_IP,
                0, 0, 0, 0, 0, 0, 0, 0
            };

            // Update ARP SNMP vars to account for FFP'd packets
            if (DoNDISRequest(AI, NdisRequestQueryInformation, OID_FFP_ADAPTER_STATS,
                              &IFStatsInfo, sizeof(FFPAdapterStats), NULL, TRUE)
                == NDIS_STATUS_SUCCESS) {
                // Compensate 'inoctets' for packets not seen due to FFP
                IFE->if_inoctets += IFStatsInfo.InOctetsForwarded;
                IFE->if_inoctets += IFStatsInfo.InOctetsDiscarded;

                // Compensate 'inucastpkts' for packets not seen due to FFP
                // Assume all FFP fwded/dropped pkts came in as Eth Unicasts
                // A check to see if it is a ucast or an mcast would slow FFP
                IFE->if_inucastpkts += IFStatsInfo.InPacketsForwarded;
                IFE->if_inucastpkts += IFStatsInfo.InPacketsDiscarded;

                // Compensate 'outoctets' for packets not seen due to FFP
                IFE->if_outoctets += IFStatsInfo.OutOctetsForwarded;

                // Compensate 'outucastpkts' for packets not seen due to FFP
                // Assume all FFP fwded are sent as Ethernet Unicasts
                // A check to see if it is a ucast or an mcast would slow FFP
                IFE->if_outucastpkts += IFStatsInfo.OutPacketsForwarded;
            }
        }
#endif // if FFP_SUPPORT
        fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) IFE, IFE_FIXED_SIZE, &Offset);

        if (fStatus == FALSE) {
            return TDI_NO_RESOURCES;
        }
        // See if he has room for the descriptor string.
        if (BufferSize >= (IFE_FIXED_SIZE + AI->ai_desclen)) {
            // He has room. Copy it.
            if (AI->ai_desclen != 0) {
                fStatus = CopyToNdisSafe( Buffer, NULL, (PUCHAR) AI->ai_desc,
                                          AI->ai_desclen, &Offset);
            }
            if (fStatus == FALSE) {
                return TDI_NO_RESOURCES;
            }
            *Size = IFE_FIXED_SIZE + AI->ai_desclen;
            return TDI_SUCCESS;
        } else {
            // Not enough room to copy the desc. string.
            *Size = IFE_FIXED_SIZE;
            return TDI_BUFFER_OVERFLOW;
        }

    } else if (ID->toi_id == IF_FRIENDLY_NAME_ID) {
        int Status;
        PNDIS_BUFFER NextBuffer;
        NDIS_STRING NdisString;

        // This is a query for the adapter's friendly name.
        // We'll convert this to an OID_GEN_FRIENDLY_NAME query for NDIS,
        // and transfer the resulting UNICODE_STRING to the caller's buffer
        // as a nul-terminated Unicode string.

        if (NdisQueryAdapterInstanceName(&NdisString, AI->ai_handle) ==
            NDIS_STATUS_SUCCESS) {

            // Verify that the buffer is large enough for the string we just
            // retrieved and, if so, attempt to copy the string to the
            // caller's buffer. If that succeeds, nul-terminate the resulting
            // string.

            if (BufferSize >= (NdisString.Length + 1) * sizeof(WCHAR)) {
                fStatus = CopyToNdisSafe(Buffer, &NextBuffer,
                                         (uchar *)NdisString.Buffer,
                                         NdisString.Length, &Offset);
                if (fStatus) {
                    WCHAR Nul = L'\0';
                    fStatus = CopyToNdisSafe(Buffer, &NextBuffer, (uchar *)&Nul,
                                             sizeof(Nul), &Offset);
                    if (fStatus) {
                        *Size = NdisString.Length + sizeof(Nul);
                        Status = TDI_SUCCESS;
                    } else
                        Status = TDI_NO_RESOURCES;
                } else
                    Status = TDI_NO_RESOURCES;
            } else
                Status = TDI_BUFFER_OVERFLOW;
            NdisFreeString(NdisString);
            return Status;
        } else
            return TDI_NO_RESOURCES;
    } else if (ID->toi_id == IF_QUERY_SET_OFFLOAD_ID) {

        IFOffloadCapability IFOC;

        if (BufferSize < sizeof(IFOC)) {
            return TDI_BUFFER_TOO_SMALL;
        }
        if (QueryAndSetOffload(AI)) {

            IFOC.ifoc_OffloadFlags = AI->ai_OffloadFlags;
            IFOC.ifoc_IPSecOffloadFlags = AI->ai_IPSecOffloadFlags;

            if (CopyToNdisSafe(Buffer, NULL, (uchar*)&IFOC, sizeof(IFOC),
                               &Offset)) {
                return TDI_SUCCESS;
            }
        }
        return TDI_NO_RESOURCES;
    }
    return TDI_INVALID_PARAMETER;

}

//* ARPSetInfo - ARP set information handler.
//
//  The ARP set information handler. We support setting of an I/F admin
//  status, and setting/deleting of ARP table entries.
//
//  Input:  Context         - Pointer to I/F to set on.
//          ID              - The object ID
//          Buffer          - Pointer to buffer containing value to set.
//          Size            - Size in bytes of Buffer.
//
//  Returns: Status of attempt to set information.
//
int
__stdcall
ARPSetInfo(void *Context, TDIObjectID * ID, void *Buffer, uint Size)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    CTELockHandle Handle, EntryHandle;
    int Status;
    IFEntry UNALIGNED *IFE = (IFEntry UNALIGNED *) Buffer;
    IPNetToMediaEntry UNALIGNED *IPNME;
    ARPTableEntry *PrevATE, *CurrentATE;
    ARPTable *Table;
    ENetHeader *Header;
    uint Entity, Instance;
    PNDIS_PACKET Packet;

    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // First, make sure it's possibly an ID we can handle.
    if ((Entity != AT_ENTITY || Instance != Interface->ai_atinst) &&
        (Entity != IF_ENTITY || Instance != Interface->ai_ifinst)) {
        return TDI_INVALID_REQUEST;
    }
    if (ID->toi_type != INFO_TYPE_PROVIDER) {
        return TDI_INVALID_PARAMETER;
    }
    // Might be able to handle this.
    if (Entity == IF_ENTITY) {

        // It's for the I/F level, see if it's for the statistics.
        if (ID->toi_class != INFO_CLASS_PROTOCOL)
            return TDI_INVALID_PARAMETER;

        if (ID->toi_id == IF_MIB_STATS_ID) {
            // It's for the stats. Make sure it's a valid size.
            if (Size >= IFE_FIXED_SIZE) {
                // It's a valid size. See what he wants to do.
                CTEGetLock(&Interface->ai_lock, &Handle);
                switch (IFE->if_adminstatus) {
                case IF_STATUS_UP:
                    // He's marking it up. If the operational state is
                    // alse up, mark the whole interface as up.
                    Interface->ai_adminstate = IF_STATUS_UP;
                    ARPUpdateOperStatus(Interface);
                    Status = TDI_SUCCESS;
                    break;
                case IF_STATUS_DOWN:
                    // He's taking it down. Mark both the admin state and
                    // the interface state down.
                    Interface->ai_adminstate = IF_STATUS_DOWN;
                    ARPUpdateOperStatus(Interface);
                    Status = TDI_SUCCESS;
                    break;
                case IF_STATUS_TESTING:
                    // He's trying to cause up to do testing, which we
                    // don't support. Just return success.
                    Status = TDI_SUCCESS;
                    break;
                default:
                    Status = TDI_INVALID_PARAMETER;
                    break;
                }
                CTEFreeLock(&Interface->ai_lock, Handle);
                return Status;
            } else
                return TDI_INVALID_PARAMETER;
        } else {
            return TDI_INVALID_PARAMETER;
        }
    }
    // Not for the interface level. See if it's an implementation or protocol
    // class.
    if (ID->toi_class == INFO_CLASS_IMPLEMENTATION) {
        ProxyArpEntry UNALIGNED *PArpEntry;
        ARPIPAddr *Addr;
        IPAddr AddAddr;
        IPMask Mask;

        // It's for the implementation. It should be the proxy-ARP ID.
        if (ID->toi_id != AT_ARP_PARP_ENTRY_ID || Size < sizeof(ProxyArpEntry))
            return TDI_INVALID_PARAMETER;

        PArpEntry = (ProxyArpEntry UNALIGNED *) Buffer;
        AddAddr = PArpEntry->pae_addr;
        Mask = PArpEntry->pae_mask;

        // See if he's trying to add or delete a proxy arp entry.
        if (PArpEntry->pae_status == PAE_STATUS_VALID) {
            // We're trying to add an entry. We won't allow an entry
            // to be added that we believe to be invalid or conflicting
            // with our local addresses.

            if (!VALID_MASK(Mask))
                return TDI_INVALID_PARAMETER;

            if (!IP_ADDR_EQUAL(AddAddr & Mask, AddAddr) ||
                IP_ADDR_EQUAL(AddAddr, NULL_IP_ADDR) ||
                IP_ADDR_EQUAL(AddAddr, IP_LOCAL_BCST) ||
                IP_LOOPBACK(AddAddr) ||
                CLASSD_ADDR(AddAddr) ||
                CLASSE_ADDR(AddAddr))
                return TDI_INVALID_PARAMETER;

            // Walk through the list of addresses on the interface, and see
            // if they would match the AddAddr. If so, fail the request.
            CTEGetLock(&Interface->ai_lock, &Handle);

            if (IsBCastOnIF(Interface, AddAddr & Mask)) {
                CTEFreeLock(&Interface->ai_lock, Handle);
                return TDI_INVALID_PARAMETER;
            }
            Addr = &Interface->ai_ipaddr;
            do {
                if (!IP_ADDR_EQUAL(Addr->aia_addr, NULL_IP_ADDR)) {
                    if (IP_ADDR_EQUAL(Addr->aia_addr & Mask, AddAddr))
                        break;
                }
                Addr = Addr->aia_next;
            } while (Addr != NULL);

            CTEFreeLock(&Interface->ai_lock, Handle);
            if (Addr != NULL)
                return TDI_INVALID_PARAMETER;

            // At this point, we believe we're ok. Try to add the address.
            if (ARPAddAddr(Interface, LLIP_ADDR_PARP, AddAddr, Mask, NULL))
                return TDI_SUCCESS;
            else
                return TDI_NO_RESOURCES;
        } else {
            if (PArpEntry->pae_status == PAE_STATUS_INVALID) {
                // He's trying to delete a proxy ARP address.
                if (ARPDeleteAddr(Interface, LLIP_ADDR_PARP, AddAddr, Mask))
                    return TDI_SUCCESS;
            }
            return TDI_INVALID_PARAMETER;
        }
    }

    if (ID->toi_class != INFO_CLASS_PROTOCOL) {
        return TDI_INVALID_PARAMETER;
    }

    if (ID->toi_id == AT_MIB_ADDRXLAT_ENTRY_ID &&
        Size >= sizeof(IPNetToMediaEntry)) {
        // He does want to set an ARP table entry. See if he's trying to
        // create or delete one.

        IPNME = (IPNetToMediaEntry UNALIGNED *) Buffer;
        if (IPNME->inme_type == INME_TYPE_INVALID) {
            uint Index = ARP_HASH(IPNME->inme_addr);

            // We're trying to delete an entry. See if we can find it,
            // and then delete it.
            CTEGetLock(&Interface->ai_ARPTblLock, &Handle);
            Table = Interface->ai_ARPTbl;
            PrevATE = STRUCT_OF(ARPTableEntry, &((*Table)[Index]), ate_next);
            CurrentATE = (*Table)[Index];
            while (CurrentATE != (ARPTableEntry *) NULL) {
                if (CurrentATE->ate_dest == IPNME->inme_addr) {
                    // Found him. Break out of the loop.
                    break;
                } else {
                    PrevATE = CurrentATE;
                    CurrentATE = CurrentATE->ate_next;
                }
            }

            if (CurrentATE != NULL) {
                CTEGetLock(&CurrentATE->ate_lock, &EntryHandle);


                if (CurrentATE->ate_resolveonly) {
                    ARPControlBlock *ArpContB, *TmpArpContB;

                    ArpContB = CurrentATE->ate_resolveonly;

                    while (ArpContB) {
                        ArpRtn rtn;
                        rtn = (ArpRtn) ArpContB->CompletionRtn;
                        ArpContB->status = (IP_STATUS) STATUS_UNSUCCESSFUL;
                        TmpArpContB = ArpContB->next;
                        (*rtn) (ArpContB, (IP_STATUS) STATUS_UNSUCCESSFUL);
                        ArpContB = TmpArpContB;
                    }

                    CurrentATE->ate_resolveonly = NULL;
                }


                RemoveARPTableEntry(PrevATE, CurrentATE);
                Interface->ai_count--;
                CTEFreeLockFromDPC(&CurrentATE->ate_lock);
                CTEFreeLock(&Interface->ai_ARPTblLock, Handle);

                if (CurrentATE->ate_packet != NULL) {
                    IPSendComplete(Interface->ai_context,
                                   CurrentATE->ate_packet, NDIS_STATUS_SUCCESS);
                }

                CTEFreeMem(CurrentATE);
                return TDI_SUCCESS;
            } else
                Status = TDI_INVALID_PARAMETER;

            CTEFreeLock(&Interface->ai_ARPTblLock, Handle);
            return Status;
        }
        // We're not trying to delete. See if we're trying to create.
        if (IPNME->inme_type != INME_TYPE_DYNAMIC &&
            IPNME->inme_type != INME_TYPE_STATIC) {
            // Not creating, return an error.
            return TDI_INVALID_PARAMETER;
        }
        // Make sure he's trying to create a valid address.
        if (IPNME->inme_physaddrlen != Interface->ai_addrlen)
            return TDI_INVALID_PARAMETER;

        // We're trying to create an entry. Call CreateARPTableEntry to create
        // one, and fill it in.
        CurrentATE = CreateARPTableEntry(Interface, IPNME->inme_addr, &Handle, 0);
        if (CurrentATE == NULL) {
            return TDI_NO_RESOURCES;
        }
        // We've created or found an entry. Fill it in.
        Header = (ENetHeader *) CurrentATE->ate_addr;

        switch (Interface->ai_media) {
        case NdisMedium802_5:
            {
                TRHeader *Temp = (TRHeader *) Header;

                // Fill in the TR specific parts, and set the length to the
                // size of a TR header.

                Temp->tr_ac = ARP_AC;
                Temp->tr_fc = ARP_FC;
                RtlCopyMemory(&Temp->tr_saddr[ARP_802_ADDR_LENGTH], ARPSNAP,
                           sizeof(SNAPHeader));

                Header = (ENetHeader *) & Temp->tr_daddr;
                CurrentATE->ate_addrlength = sizeof(TRHeader) +
                                             sizeof(SNAPHeader);
            }
            break;
        case NdisMedium802_3:
            CurrentATE->ate_addrlength = sizeof(ENetHeader);
            break;
        case NdisMediumFddi:
            {
                FDDIHeader *Temp = (FDDIHeader *) Header;

                Temp->fh_pri = ARP_FDDI_PRI;
                RtlCopyMemory(&Temp->fh_saddr[ARP_802_ADDR_LENGTH], ARPSNAP,
                           sizeof(SNAPHeader));
                Header = (ENetHeader *) & Temp->fh_daddr;
                CurrentATE->ate_addrlength = sizeof(FDDIHeader) +
                                             sizeof(SNAPHeader);
            }
            break;
        case NdisMediumArcnet878_2:
            {
                ARCNetHeader *Temp = (ARCNetHeader *) Header;

                Temp->ah_saddr = Interface->ai_addr[0];
                Temp->ah_daddr = IPNME->inme_physaddr[0];
                Temp->ah_prot = ARP_ARCPROT_IP;
                CurrentATE->ate_addrlength = sizeof(ARCNetHeader);
            }
            break;
        default:
            ASSERT(0);
            break;
        }

        // Copy in the source and destination addresses.

        if (Interface->ai_media != NdisMediumArcnet878_2) {
            RtlCopyMemory(Header->eh_daddr, IPNME->inme_physaddr,
                       ARP_802_ADDR_LENGTH);
            RtlCopyMemory(Header->eh_saddr, Interface->ai_addr,
                       ARP_802_ADDR_LENGTH);

            // Now fill in the Ethertype.
            *(ushort *) & CurrentATE->ate_addr[CurrentATE->ate_addrlength - 2] =
            net_short(ARP_ETYPE_IP);
        }
        // If he's creating a static entry, mark it as always valid. Otherwise
        // mark him as valid now.
        if (IPNME->inme_type == INME_TYPE_STATIC)
            CurrentATE->ate_valid = ALWAYS_VALID;
        else
            CurrentATE->ate_valid = CTESystemUpTime();

        CurrentATE->ate_state = ARP_GOOD;

        Packet = CurrentATE->ate_packet;
        CurrentATE->ate_packet = NULL;

        CTEFreeLock(&CurrentATE->ate_lock, Handle);

        if (Packet) {
            IPSendComplete(Interface->ai_context, Packet, NDIS_STATUS_SUCCESS);
        }

        return TDI_SUCCESS;
    }
    return TDI_INVALID_PARAMETER;
}

#pragma BEGIN_INIT
//** ARPInit - Initialize the ARP module.
//
//  This functions intializes all of the ARP module, including allocating
//  the ARP table and any other necessary data structures.
//
//  Entry: nothing.
//
//  Exit: Returns 0 if we fail to init., !0 if we succeed.
//
int
ARPInit()
{
    NDIS_STATUS Status;                 // Status for NDIS calls.
    NDIS_PROTOCOL_CHARACTERISTICS Characteristics;

    DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("+ARPInit()\n")));

    RtlZeroMemory(&Characteristics, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    Characteristics.MajorNdisVersion = NDIS_MAJOR_VERSION;
    Characteristics.MinorNdisVersion = NDIS_MINOR_VERSION;
    Characteristics.OpenAdapterCompleteHandler = ARPOAComplete;
    Characteristics.CloseAdapterCompleteHandler = ARPCAComplete;
    Characteristics.SendCompleteHandler = ARPSendComplete;
    Characteristics.TransferDataCompleteHandler = ARPTDComplete;
    Characteristics.ResetCompleteHandler = ARPResetComplete;
    Characteristics.RequestCompleteHandler = ARPRequestComplete;
    Characteristics.ReceiveHandler = ARPRcv,
    Characteristics.ReceiveCompleteHandler = ARPRcvComplete;
    Characteristics.StatusHandler = ARPStatus;
    Characteristics.StatusCompleteHandler = ARPStatusComplete;

    //
    // Re-direct to IP since IP now binds to NDIS.
    //
    Characteristics.BindAdapterHandler = IPBindAdapter;    // ARPBindAdapter;
    Characteristics.UnbindAdapterHandler = ARPUnbindAdapter;
    Characteristics.PnPEventHandler = ARPPnPEvent;

#if MILLEN
    Characteristics.UnloadHandler = ARPUnloadProtocol;
#endif // MILLEN

    RtlInitUnicodeString(&(Characteristics.Name), ARPName);

    Characteristics.ReceivePacketHandler = ARPRcvPacket;

    DEBUGMSG(DBG_INFO && DBG_INIT,
             (DTEXT("ARPInit: Calling NdisRegisterProtocol %d:%d %ws\n"),
              NDIS_MAJOR_VERSION, NDIS_MINOR_VERSION, ARPName));

    NdisRegisterProtocol(&Status, &ARPHandle, (NDIS_PROTOCOL_CHARACTERISTICS *)
                         & Characteristics, sizeof(Characteristics));

    DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-ARPInit [%x]\n"), Status));

    if (Status == NDIS_STATUS_SUCCESS) {
        return(1);
    } else {
        return(0);
    }
}

//* FreeARPInterface - Free an ARP interface
//
//  Called in the event of some sort of initialization failure. We free all
//  the memory associated with an ARP interface.
//
//  Entry:  Interface   - Pointer to interface structure to be freed.
//
//  Returns: Nothing.
//
void
FreeARPInterface(ARPInterface *Interface)
{
    NDIS_STATUS Status;
    ARPTable *Table;                    // ARP table.
    uint i;                             // Index variable.
    ARPTableEntry *ATE;
    CTELockHandle LockHandle;
    NDIS_HANDLE Handle;

    if (Interface->ai_timerstarted &&
        !CTEStopTimer(&Interface->ai_timer)) {
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could not stop ai_timer - waiting for event\n"));

        (VOID) CTEBlock(&Interface->ai_timerblock);
        KeClearEvent(&Interface->ai_timerblock.cbs_event);
    }

// If we're bound to the adapter, close it now.
    CTEInitBlockStruc(&Interface->ai_block);

    CTEGetLock(&Interface->ai_lock, &LockHandle);
    if (Interface->ai_handle != (NDIS_HANDLE) NULL) {
        Handle = Interface->ai_handle;
        Interface->ai_handle = NULL;
        CTEFreeLock(&Interface->ai_lock, LockHandle);

        NdisCloseAdapter(&Status, Handle);

        if (Status == NDIS_STATUS_PENDING)
            Status = CTEBlock(&Interface->ai_block);
    } else {
        CTEFreeLock(&Interface->ai_lock, LockHandle);
    }

    // First free any outstanding ARP table entries.
    Table = Interface->ai_ARPTbl;
    if (Table != NULL) {
        for (i = 0; i < ARP_TABLE_SIZE; i++) {
            while ((*Table)[i] != NULL) {
                ATE = (*Table)[i];

                if (ATE->ate_resolveonly) {
                    ARPControlBlock *ArpContB, *TmpArpContB;

                    ArpContB = ATE->ate_resolveonly;

                    while (ArpContB) {
                        ArpRtn rtn;
                        rtn = (ArpRtn) ArpContB->CompletionRtn;
                        ArpContB->status = (IP_STATUS) STATUS_UNSUCCESSFUL;
                        TmpArpContB = ArpContB->next;
                        (*rtn) (ArpContB, (IP_STATUS) STATUS_UNSUCCESSFUL);
                        ArpContB = TmpArpContB;
                    }

                    ATE->ate_resolveonly = NULL;

                }

                RemoveARPTableEntry(STRUCT_OF(ARPTableEntry, &((*Table)[i]),
                                              ate_next), ATE);

                if (ATE->ate_packet) {
                    IPSendComplete(Interface->ai_context, ATE->ate_packet,
                                   NDIS_STATUS_SUCCESS);
                }
                CTEFreeMem(ATE);
            }
        }
        CTEFreeMem(Table);
    }
    Interface->ai_ARPTbl = NULL;

    if (Interface->ai_ppool != (NDIS_HANDLE) NULL)
        NdisFreePacketPool(Interface->ai_ppool);

    if (Interface->ai_qlen) {
        CTEFreeMem(Interface->ai_qlen);
    }

    if (Interface->ai_devicename.Buffer != NULL) {
        CTEFreeMem(Interface->ai_devicename.Buffer);
    }

    if (Interface->ai_desc) {
        CTEFreeMem(Interface->ai_desc);
    }
    // Free the interface itself.
    CTEFreeMem(Interface);
}

//** ARPOpen - Open an adapter for reception.
//
//  This routine is called when the upper layer is done initializing and wishes to
//  begin receiveing packets. The adapter is actually 'open', we just call InitAdapter
//  to set the packet filter and lookahead size.
//
//  Input:  Context     - Interface pointer we gave to IP earlier.
//
//  Returns: Nothing
//
void
__stdcall
ARPOpen(void *Context)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    InitAdapter(Interface);             // Set the packet filter - we'll begin receiving.
}

//*     ARPGetEList - Get the entity list.
//
//      Called at init time to get an entity list. We fill our stuff in, and
//      then call the interfaces below us to allow them to do the same.
//
//      Input:  EntityList              - Pointer to entity list to be filled in.
//                      Count                   - Pointer to number of entries in the list.
//
//      Returns Status of attempt to get the info.
//
int
__stdcall
ARPGetEList(void *Context, TDIEntityID * EList, uint * Count)
{
    ARPInterface *Interface = (ARPInterface *) Context;
    uint MyATBase;
    uint MyIFBase;
    uint i;
    TDIEntityID *ATEntity, *IFEntity;
    TDIEntityID *EntityList;

    // Walk down the list, looking for existing AT or IF entities, and
    // adjust our base instance accordingly.
    // if we are already on the list then do nothing.
    // if we are going away, mark our entry invalid.

    EntityList = EList;
    MyATBase = 0;
    MyIFBase = 0;
    ATEntity = NULL;
    IFEntity = NULL;
    for (i = 0; i < *Count; i++, EntityList++) {
        if (EntityList->tei_entity == AT_ENTITY) {
            // if we are already on the list remember our entity item
            // o/w find an instance # for us.
            if (EntityList->tei_instance == Interface->ai_atinst &&
                EntityList->tei_instance != INVALID_ENTITY_INSTANCE) {
                ATEntity = EntityList;
                // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - Found our interface %lx at_atinst %lx\n",Interface, Interface->ai_atinst));
            } else {
                MyATBase = MAX(MyATBase, EntityList->tei_instance + 1);
            }
        } else {
            if (EntityList->tei_entity == IF_ENTITY)
                // if we are already on the list remember our entity item
                // o/w find an instance # for us.
                if (EntityList->tei_instance == Interface->ai_ifinst &&
                    EntityList->tei_instance != INVALID_ENTITY_INSTANCE) {
                    IFEntity = EntityList;
                    // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - Found our interface %lx ai_ifinst %lx\n",Interface, Interface->ai_ifinst));
                } else {
                    MyIFBase = MAX(MyIFBase, EntityList->tei_instance + 1);
                }
        }
        if (ATEntity && IFEntity) {
            break;
        }
    }

    if (ATEntity) {
        // we are already on the list.
        // are we going away?
        if (Interface->ai_operstatus == INTERFACE_UNINIT) {
            // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - our interface %lx atinst %lx going away \n",Interface, Interface->ai_atinst));
            ATEntity->tei_instance = (ULONG) INVALID_ENTITY_INSTANCE;
        }
    } else {
        // we are not on the list.
        // insert ourself iff we are not going away.
        if (Interface->ai_operstatus != INTERFACE_UNINIT) {
            // make sure we have the room for it.
            if (*Count >= MAX_TDI_ENTITIES) {
                return FALSE;
            }
            Interface->ai_atinst = MyATBase;
            ATEntity = &EList[*Count];
            ATEntity->tei_entity = AT_ENTITY;
            ATEntity->tei_instance = MyATBase;
            (*Count)++;
            // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - adding interface %lx atinst %lx \n",Interface, Interface->ai_atinst));
        }
    }

    if (IFEntity) {
        // we are already on the list.
        // are we going away?
        if (Interface->ai_operstatus == INTERFACE_UNINIT) {
            // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - our interface %lx ifinst %lx going away \n",Interface, Interface->ai_ifinst));
            IFEntity->tei_instance = (ULONG) INVALID_ENTITY_INSTANCE;
        }
    } else {
        // we are not on the list.
        // insert ourself iff we are not going away.
        if (Interface->ai_operstatus != INTERFACE_UNINIT) {
            // make sure we have the room for it.
            if (*Count >= MAX_TDI_ENTITIES) {
                return FALSE;
            }
            Interface->ai_ifinst = MyIFBase;
            IFEntity = &EList[*Count];
            IFEntity->tei_entity = IF_ENTITY;
            IFEntity->tei_instance = MyIFBase;
            (*Count)++;
            // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetElist - adding interface %lx ifinst %lx \n",Interface, Interface->ai_ifinst));
        }
    }

    // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ARPGetEList: arp interface %lx, ai_atinst %lx, ai_ifinst %lx, total %lx\n",
    //       Interface, Interface->ai_atinst, Interface->ai_ifinst, *Count));

    return TRUE;
}

extern uint UseEtherSNAP(PNDIS_STRING Name);
extern void GetAlwaysSourceRoute(uint * pArpAlwaysSourceRoute, uint * pIPAlwaysSourceRoute);
extern uint GetArpCacheLife(void);
extern uint GetArpRetryCount(void);

//** InitTaskOffloadHeader - Initializes the task offload header wrt version
//                           and encapsulation, etc.
//
//    All task offload header structure members are initialized.
//
//  Input:
//      ai                  - ARPInterface for which we are initializing
//                            the task offload header.
//      TaskOffloadHeader   - Pointer to task offload header to initialize.
//  Returns:
//      None.
//
VOID
InitTaskOffloadHeader(ARPInterface *ai,
                      PNDIS_TASK_OFFLOAD_HEADER TaskOffloadHeader)
{
    TaskOffloadHeader->Version = NDIS_TASK_OFFLOAD_VERSION;
    TaskOffloadHeader->Size    = sizeof(NDIS_TASK_OFFLOAD_HEADER);

    TaskOffloadHeader->EncapsulationFormat.Flags.FixedHeaderSize = 1;
    TaskOffloadHeader->EncapsulationFormat.EncapsulationHeaderSize = ai->ai_hdrsize;
    TaskOffloadHeader->OffsetFirstTask = 0;


    if (ai->ai_media == NdisMedium802_3) {

        if (ai->ai_snapsize) {
            TaskOffloadHeader->EncapsulationFormat.Encapsulation = LLC_SNAP_ROUTED_Encapsulation;
            TaskOffloadHeader->EncapsulationFormat.EncapsulationHeaderSize += ai->ai_snapsize;
        } else {
            TaskOffloadHeader->EncapsulationFormat.Encapsulation = IEEE_802_3_Encapsulation;
        }
    } else if (ai->ai_media == NdisMedium802_5) {

        TaskOffloadHeader->EncapsulationFormat.Encapsulation = IEEE_802_5_Encapsulation;
    } else {

        TaskOffloadHeader->EncapsulationFormat.Encapsulation = UNSPECIFIED_Encapsulation;
    }

    return;
}

//**SetOffload - Set offload capabilities
//
//
//    All task offload header structure members are initialized.
//
//  Input:
//      ai                  - ARPInterface for which we are initializing
//                            the task offload header.
//      TaskOffloadHeader   - Pointer to task offload header to initialize.
//      Bufsize             - length of task offload buffer allocated by teh caller
//
//  Returns:
//      TRUE                - successfully set the offload capability
//      FALSE               - failure case
//
BOOLEAN
SetOffload(ARPInterface *ai,PNDIS_TASK_OFFLOAD_HEADER TaskOffloadHeader,uint BufSize)
{
    PNDIS_TASK_OFFLOAD tmpoffload;
    PNDIS_TASK_OFFLOAD TaskOffload, NextTaskOffLoad, LastTaskOffload;
    NDIS_TASK_IPSEC ipsecCaps;
    uint TotalLength;
    NDIS_STATUS Status;
    uint PrevOffLoad=ai->ai_OffloadFlags;
    uint PrevIPSecOffLoad=ai->ai_IPSecOffloadFlags;

    //Parse the buffer for Checksum and tcplargesend offload capabilities

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Something to Offload. offload buffer size %x\n", BufSize));
    ASSERT(TaskOffloadHeader->OffsetFirstTask == sizeof(NDIS_TASK_OFFLOAD_HEADER));

    TaskOffload = tmpoffload = (NDIS_TASK_OFFLOAD *) ((uchar *) TaskOffloadHeader + TaskOffloadHeader->OffsetFirstTask);

    if (BufSize >= (TaskOffloadHeader->OffsetFirstTask + sizeof(NDIS_TASK_OFFLOAD))) {

        while (tmpoffload) {

            if (tmpoffload->Task == TcpIpChecksumNdisTask) {
                //Okay we this adapter supports checksum offload
                //check if tcp and/or  ip chksums bits are present

                PNDIS_TASK_TCP_IP_CHECKSUM ChecksumInfo;

                ChecksumInfo = (PNDIS_TASK_TCP_IP_CHECKSUM) & tmpoffload->TaskBuffer[0];

                //if (ChecksumInfo->V4Transmit.V4Checksum) {

                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"V4 Checksum offload\n"));

                if (ChecksumInfo->V4Transmit.TcpChecksum) {
                    ai->ai_OffloadFlags |= TCP_XMT_CHECKSUM_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," Tcp Checksum offload\n"));
                }
                if (ChecksumInfo->V4Transmit.IpChecksum) {
                    ai->ai_OffloadFlags |= IP_XMT_CHECKSUM_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," IP xmt Checksum offload\n"));
                }
                if (ChecksumInfo->V4Receive.TcpChecksum) {
                    ai->ai_OffloadFlags |= TCP_RCV_CHECKSUM_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," Tcp Rcv Checksum offload\n"));
                }
                if (ChecksumInfo->V4Receive.IpChecksum) {
                    ai->ai_OffloadFlags |= IP_RCV_CHECKSUM_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," IP rcv  Checksum offload\n"));
                }
                if (ChecksumInfo->V4Transmit.IpOptionsSupported) {
                    ai->ai_OffloadFlags |= IP_CHECKSUM_OPT_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," IP Checksum xmt options offload\n"));
                }

                if (ChecksumInfo->V4Transmit.TcpOptionsSupported) {
                    ai->ai_OffloadFlags |= TCP_CHECKSUM_OPT_OFFLOAD;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," TCP Checksum xmt options offload\n"));
                }


            } else if ((tmpoffload->Task == TcpLargeSendNdisTask) && (ai->ai_snapsize == 0)) {

                PNDIS_TASK_TCP_LARGE_SEND TcpLargeSend, in_LargeSend = (PNDIS_TASK_TCP_LARGE_SEND) & tmpoffload->TaskBuffer[0];



                TcpLargeSend = &ai->ai_TcpLargeSend;
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," Tcp large send!! \n"));


                TcpLargeSend->MaxOffLoadSize = in_LargeSend->MaxOffLoadSize;
                TcpLargeSend->MinSegmentCount = in_LargeSend->MinSegmentCount;

                //
                // If MaxOffLoadSize is zero, reject this request.
                //

                if (TcpLargeSend->MaxOffLoadSize) {

                    ai->ai_OffloadFlags |= TCP_LARGE_SEND_OFFLOAD;

                    // no tcp or ip options when doing large send
                    // Need to reevaluate this as we turn on Time stamp option.

                    if (in_LargeSend->TcpOptions) {

                        ai->ai_OffloadFlags |= TCP_LARGE_SEND_TCPOPT_OFFLOAD;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," TCP largesend  options offload\n"));
                    }

                    if (in_LargeSend->IpOptions) {
                        ai->ai_OffloadFlags |= TCP_LARGE_SEND_IPOPT_OFFLOAD;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL," IP largesend  options offload\n"));
                    }

                }



            } else if (tmpoffload->Task == IpSecNdisTask) {
                PNDIS_TASK_IPSEC pIPSecCaps = (PNDIS_TASK_IPSEC) & tmpoffload->TaskBuffer[0];

                //
                // Save off the capabilities for setting them later.
                //
                ipsecCaps = *pIPSecCaps;

                //
                // CryptoOnly is assumed if we have IpSecNdisTask
                //
                ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_CRYPTO_ONLY;

                //
                // Do Support first
                //

                if (pIPSecCaps->Supported.AH_ESP_COMBINED) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_AH_ESP;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_ESP\n"));
                }
                if (pIPSecCaps->Supported.TRANSPORT_TUNNEL_COMBINED) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_TPT_TUNNEL;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TPT_TUNNEL\n"));
                }
                if (pIPSecCaps->Supported.V4_OPTIONS) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_V4_OPTIONS;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"V4_OPTIONS\n"));
                }
                if (pIPSecCaps->Supported.RESERVED) {
                    if (pIPSecCaps->Supported.RESERVED & IPSEC_TPT_UDPESP_ENCAPTYPE_IKE) {
                        ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_TPT_UDPESP_IKE;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPSEC_OFFLOAD_TPT_UDPESP_IKE\n"));
                    }
                    if (pIPSecCaps->Supported.RESERVED & IPSEC_TUN_UDPESP_ENCAPTYPE_IKE) {
                        ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_TUNNEL_UDPESP_IKE;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPSEC_OFFLOAD_TUNNEL_UDPESP_IKE\n"));
                    }
                    if (pIPSecCaps->Supported.RESERVED & IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_IKE) {
                        ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_IKE;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_IKE\n"));
                    }
                    if (pIPSecCaps->Supported.RESERVED & IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_IKE) {
                        ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_IKE;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_IKE\n"));
                    }
                    if (pIPSecCaps->Supported.RESERVED & IPSEC_TPT_UDPESP_ENCAPTYPE_OTHER) {
                        ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_TPT_UDPESP_OTHER;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPSEC_OFFLOAD_TPT_UDPESP_OTHER\n"));
                    }
                    if (pIPSecCaps->Supported.RESERVED & IPSEC_TUN_UDPESP_ENCAPTYPE_OTHER) {
                        ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_TUNNEL_UDPESP_OTHER;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPSEC_OFFLOAD_TUNNEL_UDPESP_OTHER\n"));
                    }
                    if (pIPSecCaps->Supported.RESERVED & IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_OTHER) {
                        ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_OTHER;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_OTHER\n"));
                    }
                    if (pIPSecCaps->Supported.RESERVED & IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_OTHER) {
                        ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_OTHER;
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_OTHER\n"));
                    }
                }
                //
                // Do V4AH next
                //

                if (pIPSecCaps->V4AH.MD5) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_AH_MD5;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"MD5\n"));
                }
                if (pIPSecCaps->V4AH.SHA_1) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_AH_SHA_1;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"SHA\n"));
                }
                if (pIPSecCaps->V4AH.Transport) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_AH_TPT;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_TRANSPORT\n"));
                }
                if (pIPSecCaps->V4AH.Tunnel) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_AH_TUNNEL;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_TUNNEL\n"));
                }
                if (pIPSecCaps->V4AH.Send) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_AH_XMT;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_XMT\n"));
                }
                if (pIPSecCaps->V4AH.Receive) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_AH_RCV;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AH_RCV\n"));
                }
                //
                // Do V4ESP next
                //

                if (pIPSecCaps->V4ESP.DES) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_ESP_DES;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_DES\n"));
                }
                if (pIPSecCaps->V4ESP.RESERVED) {
                    pIPSecCaps->V4ESP.RESERVED = 0;
                    //ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_ESP_DES_40;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_DES_40\n"));
                }
                if (pIPSecCaps->V4ESP.TRIPLE_DES) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_ESP_3_DES;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_3_DES\n"));
                }
                if (pIPSecCaps->V4ESP.NULL_ESP) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_ESP_NONE;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_NONE\n"));
                }
                if (pIPSecCaps->V4ESP.Transport) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_ESP_TPT;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_TRANSPORT\n"));
                }
                if (pIPSecCaps->V4ESP.Tunnel) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_ESP_TUNNEL;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_TUNNEL\n"));
                }
                if (pIPSecCaps->V4ESP.Send) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_ESP_XMT;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_XMT\n"));
                }
                if (pIPSecCaps->V4ESP.Receive) {
                    ai->ai_IPSecOffloadFlags |= IPSEC_OFFLOAD_ESP_RCV;
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"ESP_RCV\n"));
                }
            }
            // Point to the next offload structure

            if (tmpoffload->OffsetNextTask) {

                tmpoffload = (PNDIS_TASK_OFFLOAD)
                             ((PUCHAR) tmpoffload + tmpoffload->OffsetNextTask);

            } else {
                tmpoffload = NULL;
            }

        }                               //while

    } else {                            //if BufSize is not okay

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"response of task offload does not have sufficient space even for 1 offload task!!\n"));

        return FALSE;

    }

    // Enable the capabilities by setting them.

    if (PrevOffLoad) {
        ai->ai_OffloadFlags &= PrevOffLoad;
    }
    if (PrevIPSecOffLoad) {
        ai->ai_IPSecOffloadFlags &= PrevIPSecOffLoad;
    }

    TaskOffload->Task = 0;
    TaskOffload->OffsetNextTask = 0;

    NextTaskOffLoad = LastTaskOffload = TaskOffload;

    TotalLength = sizeof(NDIS_TASK_OFFLOAD_HEADER);

    if ((ai->ai_OffloadFlags & TCP_XMT_CHECKSUM_OFFLOAD) ||
        (ai->ai_OffloadFlags & IP_XMT_CHECKSUM_OFFLOAD) ||
        (ai->ai_OffloadFlags & TCP_RCV_CHECKSUM_OFFLOAD) ||
        (ai->ai_OffloadFlags & IP_RCV_CHECKSUM_OFFLOAD)) {

        PNDIS_TASK_TCP_IP_CHECKSUM ChksumBuf = (PNDIS_TASK_TCP_IP_CHECKSUM) & NextTaskOffLoad->TaskBuffer[0];

        NextTaskOffLoad->Task = TcpIpChecksumNdisTask;
        NextTaskOffLoad->TaskBufferLength = sizeof(NDIS_TASK_TCP_IP_CHECKSUM);

        NextTaskOffLoad->OffsetNextTask = FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) +
                                          NextTaskOffLoad->TaskBufferLength;

        TotalLength += NextTaskOffLoad->OffsetNextTask;

        RtlZeroMemory(ChksumBuf, sizeof(NDIS_TASK_TCP_IP_CHECKSUM));

        if (ai->ai_OffloadFlags & TCP_XMT_CHECKSUM_OFFLOAD) {
            ChksumBuf->V4Transmit.TcpChecksum = 1;
        }
        if (ai->ai_OffloadFlags & IP_XMT_CHECKSUM_OFFLOAD) {
            ChksumBuf->V4Transmit.IpChecksum = 1;
        }
        if (ai->ai_OffloadFlags & TCP_RCV_CHECKSUM_OFFLOAD) {
            ChksumBuf->V4Receive.TcpChecksum = 1;
        }
        if (ai->ai_OffloadFlags & IP_RCV_CHECKSUM_OFFLOAD) {
            ChksumBuf->V4Receive.IpChecksum = 1;
        }
        //
        // Enable Options capability if present.
        //
        if (ai->ai_OffloadFlags & IP_CHECKSUM_OPT_OFFLOAD) {
            ChksumBuf->V4Transmit.IpOptionsSupported = 1;
        }

        if (ai->ai_OffloadFlags & TCP_CHECKSUM_OPT_OFFLOAD) {
            ChksumBuf->V4Transmit.TcpOptionsSupported = 1;
        }

        LastTaskOffload = NextTaskOffLoad;

        NextTaskOffLoad = (PNDIS_TASK_OFFLOAD)
                          ((PUCHAR) NextTaskOffLoad + NextTaskOffLoad->OffsetNextTask);

    }
    if (ai->ai_OffloadFlags & TCP_LARGE_SEND_OFFLOAD) {

        PNDIS_TASK_TCP_LARGE_SEND TcpLargeSend, out_LargeSend = (PNDIS_TASK_TCP_LARGE_SEND) & NextTaskOffLoad->TaskBuffer[0];

        NextTaskOffLoad->Task = TcpLargeSendNdisTask;
        NextTaskOffLoad->TaskBufferLength = sizeof(NDIS_TASK_TCP_LARGE_SEND);

        NextTaskOffLoad->OffsetNextTask = FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) + NextTaskOffLoad->TaskBufferLength;

        TotalLength += NextTaskOffLoad->OffsetNextTask;

        //(uchar)TaskOffload + sizeof(NDIS_TASK_OFFLOAD) + NextTaskOffload->TaskBufferLength;

        TcpLargeSend = &ai->ai_TcpLargeSend;

        RtlZeroMemory(out_LargeSend, sizeof(NDIS_TASK_TCP_LARGE_SEND));

        out_LargeSend->MaxOffLoadSize = TcpLargeSend->MaxOffLoadSize;
        out_LargeSend->MinSegmentCount = TcpLargeSend->MinSegmentCount;

        if (ai->ai_OffloadFlags & TCP_LARGE_SEND_TCPOPT_OFFLOAD) {
            out_LargeSend->TcpOptions = 1;
        }

        if (ai->ai_OffloadFlags & TCP_LARGE_SEND_IPOPT_OFFLOAD) {
            out_LargeSend->IpOptions = 1;
        }

        LastTaskOffload = NextTaskOffLoad;
        NextTaskOffLoad = (PNDIS_TASK_OFFLOAD)
                          ((PUCHAR) NextTaskOffLoad + NextTaskOffLoad->OffsetNextTask);

    }
    if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_CRYPTO_ONLY) {

        PNDIS_TASK_IPSEC pIPSecCaps = (PNDIS_TASK_IPSEC) & NextTaskOffLoad->TaskBuffer[0];

        //
        // plunk down the advertised capabilities
        //

        RtlZeroMemory(pIPSecCaps, sizeof(NDIS_TASK_IPSEC));

        NextTaskOffLoad->Task = IpSecNdisTask;
        NextTaskOffLoad->TaskBufferLength = sizeof(NDIS_TASK_IPSEC);

        NextTaskOffLoad->OffsetNextTask = (FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) + NextTaskOffLoad->TaskBufferLength);

        TotalLength += NextTaskOffLoad->OffsetNextTask;

        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_ESP) {
            pIPSecCaps->Supported.AH_ESP_COMBINED = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_TUNNEL) {
            pIPSecCaps->Supported.TRANSPORT_TUNNEL_COMBINED = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_V4_OPTIONS) {
            pIPSecCaps->Supported.V4_OPTIONS = 1;
        }

        pIPSecCaps->Supported.RESERVED = 0;
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_IKE) {
            pIPSecCaps->Supported.RESERVED |= IPSEC_TPT_UDPESP_ENCAPTYPE_IKE;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_TUNNEL_UDPESP_IKE) {
            pIPSecCaps->Supported.RESERVED |= IPSEC_TUN_UDPESP_ENCAPTYPE_IKE;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_IKE) {
            pIPSecCaps->Supported.RESERVED |= IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_IKE;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_IKE) {
            pIPSecCaps->Supported.RESERVED |= IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_IKE;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_OTHER) {
            pIPSecCaps->Supported.RESERVED |= IPSEC_TPT_UDPESP_ENCAPTYPE_OTHER;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_TUNNEL_UDPESP_OTHER) {
            pIPSecCaps->Supported.RESERVED |= IPSEC_TUN_UDPESP_ENCAPTYPE_OTHER;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_OVER_TUNNEL_UDPESP_OTHER) {
            pIPSecCaps->Supported.RESERVED |= IPSEC_TPTOVERTUN_UDPESP_ENCAPTYPE_OTHER;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_TPT_UDPESP_OVER_PURE_TUNNEL_OTHER) {
            pIPSecCaps->Supported.RESERVED |= IPSEC_TPT_UDPESP_OVER_PURE_TUN_ENCAPTYPE_OTHER;
        }

        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_MD5) {
            pIPSecCaps->V4AH.MD5 = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_SHA_1) {
            pIPSecCaps->V4AH.SHA_1 = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_TPT) {
            pIPSecCaps->V4AH.Transport = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_TUNNEL) {
            pIPSecCaps->V4AH.Tunnel = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_XMT) {
            pIPSecCaps->V4AH.Send = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_AH_RCV) {
            pIPSecCaps->V4AH.Receive = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_DES) {
            pIPSecCaps->V4ESP.DES = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_3_DES) {
            pIPSecCaps->V4ESP.TRIPLE_DES = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_NONE) {
            pIPSecCaps->V4ESP.NULL_ESP = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_TPT) {
            pIPSecCaps->V4ESP.Transport = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_TUNNEL) {
            pIPSecCaps->V4ESP.Tunnel = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_XMT) {
            pIPSecCaps->V4ESP.Send = 1;
        }
        if (ai->ai_IPSecOffloadFlags & IPSEC_OFFLOAD_ESP_RCV) {
            pIPSecCaps->V4ESP.Receive = 1;
        }
        LastTaskOffload = NextTaskOffLoad;
        NextTaskOffLoad = (PNDIS_TASK_OFFLOAD)
                          ((PUCHAR) NextTaskOffLoad + NextTaskOffLoad->OffsetNextTask);
    }
    LastTaskOffload->OffsetNextTask = 0;

    // Okay, lets set this now.

    Status = DoNDISRequest(ai, NdisRequestSetInformation,
                           OID_TCP_TASK_OFFLOAD, TaskOffloadHeader, TotalLength,
                           NULL, TRUE);

    if (Status != NDIS_STATUS_SUCCESS) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                   "Failed to enable indicated offload capabilities!!\n"));
        ai->ai_OffloadFlags = 0;
        ai->ai_IPSecOffloadFlags = 0;
    }

    return TRUE;


}

//**QueryOffload - Query offload capabilities
//
//  Input:
//      ai - ARPInterface for which we are initializing
//           the task offload header.
//  Returns:
//      TRUE/FALSE - Success/Failure to query/set
//
BOOLEAN
QueryAndSetOffload(ARPInterface *ai)
{
    PNDIS_TASK_OFFLOAD_HEADER TaskOffloadHeader;
    NDIS_STATUS Status;
    BOOLEAN stat;
    uint Needed = 0;
    uchar *buffer;

    // Query and set checksum capability

    TaskOffloadHeader = CTEAllocMemNBoot(sizeof(NDIS_TASK_OFFLOAD_HEADER), '8ICT');

    Status = STATUS_BUFFER_OVERFLOW;

    if (TaskOffloadHeader) {

        InitTaskOffloadHeader(ai, TaskOffloadHeader);

        Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                               OID_TCP_TASK_OFFLOAD, TaskOffloadHeader,
                               sizeof(NDIS_TASK_OFFLOAD_HEADER),
                               &Needed, TRUE);

        // Need to initialize Needed to the real size of the buffer. The NDIS
        // call may not init on success.
        if (Status == NDIS_STATUS_SUCCESS) {
            Needed = sizeof(NDIS_TASK_OFFLOAD_HEADER);
        } else if ((Status == NDIS_STATUS_INVALID_LENGTH) ||
                   (Status == NDIS_STATUS_BUFFER_TOO_SHORT)) {

            // We know the size we need. Allocate a buffer.
            ASSERT(Needed >= sizeof(NDIS_TASK_OFFLOAD_HEADER));
            buffer = CTEAllocMemNBoot(Needed, '9ICT');

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                      "Calling OID_TCP_TASK_OFFLOAD with %d bytes\n", Needed));

            if (buffer != NULL) {

                CTEFreeMem(TaskOffloadHeader);

                TaskOffloadHeader = (PNDIS_TASK_OFFLOAD_HEADER) buffer;
                InitTaskOffloadHeader(ai, TaskOffloadHeader);

                Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                                       OID_TCP_TASK_OFFLOAD, buffer, Needed, NULL, TRUE);
            }
        }
    }
    if ((Status != NDIS_STATUS_SUCCESS)
        || (TaskOffloadHeader && TaskOffloadHeader->OffsetFirstTask == 0)) {

        //Make sure that the flag is null.
        ai->ai_OffloadFlags = 0;
        ai->ai_IPSecOffloadFlags = 0;
        if (TaskOffloadHeader) {
            CTEFreeMem(TaskOffloadHeader);
        }
        return FALSE;

    }

    if (TaskOffloadHeader) {
        stat = SetOffload(ai, TaskOffloadHeader, Needed);
        CTEFreeMem(TaskOffloadHeader);
        return stat;
    }

    return FALSE;
}

//** ARPRegister - Register a protocol with the ARP module.
//
//  We register a protocol for ARP processing. We also open the
//  NDIS adapter here.
//
//      Note that much of the information passed in here is unused, as
//  ARP currently only works with IP.
//
//  Entry:
//      Adapter     - Name of the adapter to bind to.
//      IPContext   - Value to be passed to IP on upcalls.
//
int
ARPRegister(PNDIS_STRING Adapter, uint *Flags, struct ARPInterface **Interface)
{
    ARPInterface *ai;                   // Pointer to interface struct. for this interface.
    NDIS_STATUS Status, OpenStatus;     // Status values.
    uint i = 0;                         // Medium index.
    NDIS_MEDIUM MediaArray[MAX_MEDIA];
    uint mss;
    uint speed;
    uint MacOpts;
    uchar bcastmask, bcastval, bcastoff, addrlen, hdrsize, snapsize;
    uint OID;
    uint PF;
    TRANSPORT_HEADER_OFFSET IPHdrOffset;
    CTELockHandle LockHandle;
    UINT MediaType;
    NDIS_STRING NdisString;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
             (DTEXT("+ARPRegister(%x, %x, %x)\n"),
              Adapter, Flags, Interface));

    if ((ai = CTEAllocMemNBoot(sizeof(ARPInterface), '4ICT')) == (ARPInterface *) NULL)
        return FALSE;                   // Couldn't allocate memory for this one.

    *Interface = ai;

    RtlZeroMemory(ai, sizeof(ARPInterface));
    CTEInitTimer(&ai->ai_timer);

    ai->ai_timerstarted = FALSE;
    ai->ai_stoptimer = FALSE;

    MediaArray[MEDIA_DIX] = NdisMedium802_3;
    MediaArray[MEDIA_TR] = NdisMedium802_5;
    MediaArray[MEDIA_FDDI] = NdisMediumFddi;
    MediaArray[MEDIA_ARCNET] = NdisMediumArcnet878_2;

    // Initialize this adapter interface structure.
    ai->ai_operstatus = INTERFACE_INIT;
    ai->ai_adminstate = IF_STATUS_UNKNOWN;
    ai->ai_mediastatus = FALSE;
    ai->ai_lastchange = GetTimeTicks();
    ai->ai_bcast = IP_LOCAL_BCST;
    ai->ai_atinst = ai->ai_ifinst = (UINT)INVALID_ENTITY_INSTANCE;
    ai->ai_telladdrchng = 1;            //Initially let us do try to do network layer address stuff


    // Initialize the locks.
    CTEInitLock(&ai->ai_lock);
    CTEInitLock(&ai->ai_ARPTblLock);

    GetAlwaysSourceRoute(&sArpAlwaysSourceRoute, &sIPAlwaysSourceRoute);

    ArpCacheLife = GetArpCacheLife();

    if (!ArpCacheLife) {
        ArpCacheLife = 1;
    }
    ArpCacheLife = (ArpCacheLife * 1000L) / ARP_TIMER_TIME;

    ArpRetryCount = GetArpRetryCount();

    if (!ArpMinValidCacheLife) {
        ArpMinValidCacheLife = 1;
    }

    // Allocate  the buffer and packet pools.
    NdisAllocatePacketPoolEx(&Status, &ai->ai_ppool,
                             ARP_DEFAULT_PACKETS, ARP_DEFAULT_PACKETS * 1000,
                             sizeof(struct PCCommon));
    if (Status != NDIS_STATUS_SUCCESS) {
        FreeARPInterface(ai);
        return FALSE;
    }

    // Allocate the ARP table
    ai->ai_ARPTbl = (ARPTable *) CTEAllocMemNBoot(ARP_TABLE_SIZE * sizeof(ARPTableEntry*), '5ICT');
    if (ai->ai_ARPTbl == (ARPTable *) NULL) {
        FreeARPInterface(ai);
        return FALSE;
    }

    //
    // NULL out the pointers
    //
    RtlZeroMemory(ai->ai_ARPTbl, ARP_TABLE_SIZE * sizeof(ARPTableEntry *));

    // Allocate the Counters Structure with best effort in avoiding false sharing
    ai->ai_qlen = CTEAllocMem(KeNumberProcessors * sizeof(PP_AI_COUNTERS));
    if (ai->ai_qlen == (PPP_AI_COUNTERS) NULL) {
        FreeARPInterface(ai);
        return FALSE;
    }

    RtlZeroMemory(ai->ai_qlen, KeNumberProcessors * sizeof(PP_AI_COUNTERS));

    CTEInitBlockStruc(&ai->ai_block);

    DEBUGMSG(DBG_INFO && DBG_PNP,
             (DTEXT("ARPRegister calling NdisOpenAdapter\n")));

    // Open the NDIS adapter.
    NdisOpenAdapter(&Status, &OpenStatus, &ai->ai_handle, &i, MediaArray,
                    MAX_MEDIA, ARPHandle, ai, Adapter, 0, NULL);

    // Block for open to complete.
    if (Status == NDIS_STATUS_PENDING)
        Status = (NDIS_STATUS) CTEBlock(&ai->ai_block);

    ai->ai_media = MediaArray[i];       // Fill in media type.

    // Open adapter completed. If it succeeded, we'll finish our intialization.
    // If it failed, bail out now.
    if (Status != NDIS_STATUS_SUCCESS) {
        ai->ai_handle = NULL;
        FreeARPInterface(ai);
        return FALSE;
    }
#if FFP_SUPPORT
    // Store NIC driver handle
    NdisGetDriverHandle(ai->ai_handle, &ai->ai_driver);
#endif

    // Read the local address.
    switch (ai->ai_media) {
    case NdisMedium802_3:
        addrlen = ARP_802_ADDR_LENGTH;
        bcastmask = ENET_BCAST_MASK;
        bcastval = ENET_BCAST_VAL;
        bcastoff = ENET_BCAST_OFF;
        OID = OID_802_3_CURRENT_ADDRESS;
        hdrsize = sizeof(ENetHeader);
        if (!UseEtherSNAP(Adapter)) {
            snapsize = 0;
        } else {
            snapsize = sizeof(SNAPHeader);
        }

        PF = NDIS_PACKET_TYPE_BROADCAST | \
             NDIS_PACKET_TYPE_DIRECTED | \
             NDIS_PACKET_TYPE_MULTICAST;

        ai->ai_mediatype = IF_TYPE_IS088023_CSMACD;

        break;

    case NdisMedium802_5:
        addrlen = ARP_802_ADDR_LENGTH;
        bcastmask = TR_BCAST_MASK;
        bcastval = TR_BCAST_VAL;
        bcastoff = TR_BCAST_OFF;
        OID = OID_802_5_CURRENT_ADDRESS;
        hdrsize = sizeof(TRHeader);
        snapsize = sizeof(SNAPHeader);
        PF = NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED;

        ai->ai_mediatype = IF_TYPE_ISO88025_TOKENRING;

        break;
    case NdisMediumFddi:
        addrlen = ARP_802_ADDR_LENGTH;
        bcastmask = FDDI_BCAST_MASK;
        bcastval = FDDI_BCAST_VAL;
        bcastoff = FDDI_BCAST_OFF;
        OID = OID_FDDI_LONG_CURRENT_ADDR;
        hdrsize = sizeof(FDDIHeader);
        snapsize = sizeof(SNAPHeader);

        PF = NDIS_PACKET_TYPE_BROADCAST | \
             NDIS_PACKET_TYPE_DIRECTED | \
             NDIS_PACKET_TYPE_MULTICAST;

        ai->ai_mediatype = IF_TYPE_FDDI;

        break;

    case NdisMediumArcnet878_2:
        addrlen = 1;
        bcastmask = ARC_BCAST_MASK;
        bcastval = ARC_BCAST_VAL;
        bcastoff = ARC_BCAST_OFF;
        OID = OID_ARCNET_CURRENT_ADDRESS;
        hdrsize = sizeof(ARCNetHeader);
        snapsize = 0;
        PF = NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED;

        ai->ai_mediatype = IF_TYPE_ARCNET;

        break;

    default:
        ASSERT(0);
        FreeARPInterface(ai);
        return FALSE;
    }

    ai->ai_bcastmask = bcastmask;
    ai->ai_bcastval = bcastval;
    ai->ai_bcastoff = bcastoff;
    ai->ai_addrlen = addrlen;
    ai->ai_hdrsize = hdrsize;
    ai->ai_snapsize = snapsize;
    ai->ai_pfilter = PF;

    Status = DoNDISRequest(ai, NdisRequestQueryInformation, OID,
                           ai->ai_addr, addrlen, NULL, TRUE);

    if (Status != NDIS_STATUS_SUCCESS) {
        FreeARPInterface(ai);
        return FALSE;
    }

    // Read the maximum frame size.
    if ((Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                                OID_GEN_MAXIMUM_FRAME_SIZE, &mss, sizeof(mss), NULL, TRUE)) != NDIS_STATUS_SUCCESS) {
        FreeARPInterface(ai);
        return FALSE;
    }
    // If this is token ring, figure out the RC len stuff now.
    mss -= (uint) ai->ai_snapsize;

    if (ai->ai_media == NdisMedium802_5) {
        mss -= (sizeof(RC) + (ARP_MAX_RD * sizeof(ushort)));
    } else {
        if (ai->ai_media == NdisMediumFddi) {
            mss = MIN(mss, ARP_FDDI_MSS);
        }
    }

    ai->ai_mtu = (ushort) mss;

    // Read the speed for local purposes.
    if ((Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                                OID_GEN_LINK_SPEED, &speed, sizeof(speed), NULL, TRUE)) == NDIS_STATUS_SUCCESS) {
        ai->ai_speed = speed * 100L;
    }

    // Read and save the options.
    Status = DoNDISRequest(ai, NdisRequestQueryInformation, OID_GEN_MAC_OPTIONS,
                           &MacOpts, sizeof(MacOpts), NULL, TRUE);

    if (Status != NDIS_STATUS_SUCCESS) {
        *Flags = 0;
    } else {
        *Flags = (MacOpts & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) ? LIP_COPY_FLAG : 0;
    }

    if (CTEMemCmp(ai->ai_addr, PPP_HW_ADDR, PPP_HW_ADDR_LEN) == 0) {
        *Flags = *Flags | LIP_P2P_FLAG;
    }

    //
    // Query the media capability to determine if it is a uni-directional adapter.
    //

    Status = DoNDISRequest(
        ai,
        NdisRequestQueryInformation,
        OID_GEN_MEDIA_CAPABILITIES,
        &MediaType,
        sizeof(MediaType),
        NULL,
        TRUE); // Blocking.

    if (Status == NDIS_STATUS_SUCCESS) {
        // Bit field of Rx and Tx. If only Rx, set uni flag.
        if (MediaType == NDIS_MEDIA_CAP_RECEIVE) {
            DEBUGMSG(DBG_WARN,
                (DTEXT("ARPRegister: ai %x: MEDIA_CAP_RX -> UniAdapter!!\n"), ai));
            *Flags |= LIP_UNI_FLAG;
            InterlockedIncrement( (PLONG) &cUniAdapters);
        }
    }

    // Read and store the vendor description string.
    Status = NdisQueryAdapterInstanceName(&NdisString, ai->ai_handle);

    if (Status == NDIS_STATUS_SUCCESS) {
        ANSI_STRING AnsiString;

        // Convert the string to ANSI, and use the new ANSI string's buffer
        // to store the description in the ARP interface.
        // N.B. The conversion results in a nul-terminated string.

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &NdisString, TRUE);
        if (Status == STATUS_SUCCESS) {
            ai->ai_desc = AnsiString.Buffer;
            ai->ai_desclen = (uint)strlen(AnsiString.Buffer) + 1;
        }
        NdisFreeString(NdisString);
    }

    if (!ArpEnetHeaderPool || !ArpAuxHeaderPool) {
        PVOID SectionHandle;
        // Allocate our small and big buffer pools.  Take the interface list
        // lock simply to protect creating of the buffer pools if we haven't
        // already done so.  We could have used our own lock, but the interface
        // list lock is global, and not already used in this path.
        //

        // This routine is in pageable memory.  Since getting the lock
        // requires writable access to LockHandle at DISPATCH, we need to
        // lock this code in.
        //

        SectionHandle = MmLockPagableCodeSection(ARPRegister);
        CTEGetLock(&ArpInterfaceListLock.Lock, &LockHandle);

        if (!ArpEnetHeaderPool) {
            ArpEnetHeaderPool = MdpCreatePool(BUFSIZE_ENET_HEADER_POOL, 'ehCT');
        }

        if (!ArpAuxHeaderPool) {
            ArpAuxHeaderPool = MdpCreatePool(BUFSIZE_AUX_HEADER_POOL, 'ahCT');
        }

        CTEFreeLock(&ArpInterfaceListLock.Lock, LockHandle);
        MmUnlockPagableImageSection(SectionHandle);

        if (!ArpAuxHeaderPool || !ArpEnetHeaderPool) {
            FreeARPInterface(ai);
            return FALSE;
        }
    }

    ai->ai_promiscuous = 0;

#if FFP_SUPPORT
    {
        FFPVersionParams Version =
        {
            NDIS_PROTOCOL_ID_TCP_IP, 0
        };

        // Initialize all FFP Handling Variables
        ai->ai_ffpversion = 0;
        ai->ai_ffplastflush = 0;

        // Query FFP Handling capabilities
        Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                               OID_FFP_SUPPORT, &Version, sizeof(FFPVersionParams), NULL, TRUE);

        // Non-Zero Value indicates FFP support
        if (Version.FFPVersion) {
            // Set the FFP startup parameters
            FFPSupportParams Info;

            Info.NdisProtocolType = NDIS_PROTOCOL_ID_TCP_IP;
            Info.FastForwardingCacheSize = FFPRegFastForwardingCacheSize;
            Info.FFPControlFlags = FFPRegControlFlags;

            // But store away the version first
            ai->ai_ffpversion = Version.FFPVersion;

            DoNDISRequest(ai, NdisRequestSetInformation,
                          OID_FFP_SUPPORT, &Info, sizeof(FFPSupportParams), NULL, TRUE);

            TCPTRACE(("Setting FFP capabilities: Cache Size = %lu, Flags = %08x\n",
                      Info.FastForwardingCacheSize,
                      Info.FFPControlFlags));
        }
    }
#endif // if FFP_SUPPORT

    ai->ai_OffloadFlags = 0;
    ai->ai_IPSecOffloadFlags = 0;

    if (DisableTaskOffload) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Taskoffload disabled\n"));
    } else {

       if(!QueryAndSetOffload(ai)){
           DEBUGMSG(DBG_ERROR, (DTEXT("ARP: Query and set offload failed.\n")));
       }
    }

    // query the wakeup capabilities.
    Status = DoNDISRequest(
                          ai,
                          NdisRequestQueryInformation,
                          OID_PNP_CAPABILITIES,
                          &ai->ai_wakeupcap,
                          sizeof(NDIS_PNP_CAPABILITIES),
                          NULL, TRUE);
    if (Status == NDIS_STATUS_SUCCESS) {
        uint wakeup = NDIS_PNP_WAKE_UP_PATTERN_MATCH;
        // enable wakeup capabilities.
        Status = DoNDISRequest(
                              ai,
                              NdisRequestSetInformation,
                              OID_PNP_ENABLE_WAKE_UP,
                              &wakeup,
                              sizeof(wakeup),
                              NULL, TRUE);
        if (Status != NDIS_STATUS_SUCCESS) {
            ai->ai_wakeupcap.WakeUpCapabilities.MinPatternWakeUp = NdisDeviceStateUnspecified;
        }
    }
    // Store the device name, we need to pass this to our TDI clients when
    // we do the PNP notification.
    if ((ai->ai_devicename.Buffer = CTEAllocMemNBoot(Adapter->MaximumLength, 'aICT')) == NULL) {
        FreeARPInterface(ai);
        return FALSE;
    }
    RtlCopyMemory(ai->ai_devicename.Buffer, Adapter->Buffer, Adapter->MaximumLength);
    ai->ai_devicename.Length = Adapter->Length;
    ai->ai_devicename.MaximumLength = Adapter->MaximumLength;

    ai->ai_timerstarted = TRUE;

    IPHdrOffset.HeaderOffset = ai->ai_snapsize + ai->ai_hdrsize;
    IPHdrOffset.ProtocolType = NDIS_PROTOCOL_ID_TCP_IP;

    Status = DoNDISRequest(ai, NdisRequestSetInformation, OID_GEN_TRANSPORT_HEADER_OFFSET,
                           &IPHdrOffset, sizeof(TRANSPORT_HEADER_OFFSET), NULL, TRUE);

    // Everything's set up, so get the ARP timer running.
    CTEStartTimer(&ai->ai_timer, ARP_TIMER_TIME, ARPTimeout, ai);

    return TRUE;

}

#pragma END_INIT

//*     ARPDynRegister - Dynamically register IP.
//
//      Called by IP when he's about done binding to register with us. Since we
//      call him directly, we don't save his info here. We do keep his context
//      and index number.
//
//      Input:  See ARPRegister
//
//      Returns: Nothing.
//
int
__stdcall
ARPDynRegister(
              IN PNDIS_STRING Adapter,
              IN void *IPContext,
              IN struct _IP_HANDLERS *IpHandlers,
              OUT struct LLIPBindInfo *Info,
              IN uint NumIFBound)
{
    ARPInterface *Interface = (ARPInterface *) Info->lip_context;

    UNREFERENCED_PARAMETER(Adapter);
    UNREFERENCED_PARAMETER(IpHandlers);

    Interface->ai_context = IPContext;
    Interface->ai_index = NumIFBound;

    // TCPTRACE(("Arp Interface %lx ai_context %lx ai_index %lx\n",Interface, Interface->ai_context, Interface->ai_index));
    return TRUE;
}

//*     ARPBindAdapter - Bind and initialize an adapter.
//
//      Called in a PNP environment to initialize and bind an adapter. We open
//      the adapter and get it running, and then we call up to IP to tell him
//      about it. IP will initialize, and if all goes well call us back to start
//      receiving.
//
//      Input:  RetStatus               - Where to return the status of this call.
//              BindContext             - Handle to use for calling BindAdapterComplete.
//                              AdapterName             - Pointer to name of adapter.
//                              SS1                                             - System specific 1 parameter.
//                              SS2                                             - System specific 2 parameter.
//
//      Returns: Nothing.
//
void NDIS_API
ARPBindAdapter(PNDIS_STATUS RetStatus, NDIS_HANDLE BindContext,
               PNDIS_STRING AdapterName, PVOID SS1, PVOID SS2)
{
    uint Flags;                         // MAC binding flags.
    ARPInterface *Interface;            // Newly created interface.
    IP_STATUS Status;                   // State of IPAddInterface call.
    LLIPBindInfo BindInfo;              // Binding information for IP.
    NDIS_HANDLE Handle;
    NDIS_STRING IPConfigName;

    DBG_UNREFERENCED_PARAMETER(BindContext);

    DEBUGMSG(DBG_TRACE && DBG_PNP,
             (DTEXT("+ARPBindAdapter(%x, %x, %x, %x, %x)\n"),
              RetStatus, BindContext, AdapterName, SS1, SS2));

    if (!OpenIFConfig(SS1, &Handle)) {
        *RetStatus = NDIS_STATUS_FAILURE;
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("ARPBindAdapter: Open failure\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-ARPBindAdapter [%x]\n"), *RetStatus));
        return;
    }

#if !MILLEN
    if ((*RetStatus = GetIPConfigValue(Handle, &IPConfigName)) != NDIS_STATUS_SUCCESS) {
        CloseIFConfig(Handle);
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("ARPBindAdapter: GetIPConfigValue failure\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-ARPBindAdapter [%x]\n"), *RetStatus));
        return;
    }
#endif // !MILLEN

    CloseIFConfig(Handle);

    // First, open the adapter and get the info.
    if (!ARPRegister(AdapterName, &Flags, &Interface)) {

#if !MILLEN
        CTEFreeMem(IPConfigName.Buffer);
#endif // !MILLEN

        *RetStatus = NDIS_STATUS_FAILURE;
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("ARPBindAdapter: ARPRegister failure\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-ARPBindAdapter [%x]\n"), *RetStatus));
        return;
    }

    // OK, we're opened the adapter. Call IP to tell him about it.
    BindInfo.lip_context = Interface;
    BindInfo.lip_transmit = ARPTransmit;
    BindInfo.lip_transfer = ARPXferData;
    BindInfo.lip_close = ARPClose;
    BindInfo.lip_addaddr = ARPAddAddr;
    BindInfo.lip_deladdr = ARPDeleteAddr;
    BindInfo.lip_invalidate = ARPInvalidate;
    BindInfo.lip_open = ARPOpen;
    BindInfo.lip_qinfo = ARPQueryInfo;
    BindInfo.lip_setinfo = ARPSetInfo;
    BindInfo.lip_getelist = ARPGetEList;
    BindInfo.lip_dondisreq = DoNDISRequest;

    BindInfo.lip_mss = Interface->ai_mtu;
    BindInfo.lip_speed = Interface->ai_speed;
    BindInfo.lip_flags = Flags;
    BindInfo.lip_addrlen = Interface->ai_addrlen;
    BindInfo.lip_addr = Interface->ai_addr;
    BindInfo.lip_dowakeupptrn = DoWakeupPattern;
    BindInfo.lip_pnpcomplete = ARPPnPComplete;
    BindInfo.lip_setndisrequest = ARPSetNdisRequest;
    BindInfo.lip_arpresolveip = ARPResolveIP;
    BindInfo.lip_arpflushate = ARPFlushATE;
    BindInfo.lip_arpflushallate = ARPFlushAllATE;
#if !MILLEN
    BindInfo.lip_cancelpackets = ARPCancelPackets;
#endif


#if FFP_SUPPORT
    // NDIS Driver Handle, FFP Version are passed up
    // [ Non zero version implies FFP Support exists ]
    BindInfo.lip_ffpversion = Interface->ai_ffpversion;
    BindInfo.lip_ffpdriver = (ULONG_PTR) Interface->ai_driver;
#endif

    //Interface capability is passed on to IP via BindInfo

    BindInfo.lip_OffloadFlags = Interface->ai_OffloadFlags;
    BindInfo.lip_IPSecOffloadFlags = Interface->ai_IPSecOffloadFlags;
    BindInfo.lip_MaxOffLoadSize = (uint) Interface->ai_TcpLargeSend.MaxOffLoadSize;
    BindInfo.lip_MaxSegments = (uint) Interface->ai_TcpLargeSend.MinSegmentCount;
    BindInfo.lip_closelink = NULL;
    BindInfo.lip_pnpcap = Interface->ai_wakeupcap.Flags;

    DEBUGMSG(DBG_INFO && DBG_PNP,
             (DTEXT("ARPBindAdapter calling IPAddInterface.\n")));

    Status = IPAddInterface(AdapterName,
                            NULL,
#if MILLEN
                            (PNDIS_STRING) SS1,
#else // MILLEN
                            (PNDIS_STRING) & IPConfigName,
#endif // !MILLEN
                            SS2,
                            Interface,
                            ARPDynRegister,
                            &BindInfo,
                            0,
                            Interface->ai_mediatype,
                            IF_ACCESS_BROADCAST,
                            IF_CONNECTION_DEDICATED);

#if !MILLEN
    CTEFreeMem(IPConfigName.Buffer);
#endif // !MILLEN

    if (Status != IP_SUCCESS) {
        // Need to close the binding. FreeARPInterface will do that, as well
        // as freeing resources.

        DEBUGMSG(DBG_ERROR && DBG_PNP,
                 (DTEXT("ARPBindAdapter: IPAddInterface failure %x\n"), Status));

        FreeARPInterface(Interface);
        *RetStatus = NDIS_STATUS_FAILURE;
    } else {
        //
        // Insert into ARP IF list
        //
        ExInterlockedInsertTailList(&ArpInterfaceList,
                                    &Interface->ai_linkage,
                                    &ArpInterfaceListLock.Lock);
        *RetStatus = NDIS_STATUS_SUCCESS;
    }

    DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-ARPBindAdapter [%x]\n"), *RetStatus));
}

//*   ARPUnbindAdapter - Unbind from an adapter.
//
//    Called when we need to unbind from an adapter. We'll call up to IP to tell
//    him. When he's done, we'll free our memory and return.
//
//   Input:  RetStatus               - Where to return status from call.
//           ProtBindContext - The context we gave NDIS earlier - really a
//                                       pointer to an ARPInterface structure.
//           UnbindContext   - Context for completeing this request.
//
//      Returns: Nothing.
//
void NDIS_API
ARPUnbindAdapter(PNDIS_STATUS RetStatus, NDIS_HANDLE ProtBindContext,
                 NDIS_HANDLE UnbindContext)
{
    ARPInterface *Interface = (ARPInterface *) ProtBindContext;
    NDIS_STATUS Status;                 // Status of close call.
    CTELockHandle LockHandle;

    // Shut him up, so we don't get any more frames.
    Interface->ai_pfilter = 0;
    if (Interface->ai_handle != NULL) {
        DoNDISRequest(Interface, NdisRequestSetInformation,
                      OID_GEN_CURRENT_PACKET_FILTER, &Interface->ai_pfilter, sizeof(uint),
                      NULL, TRUE);
    }
    CTEInitBlockStrucEx(&Interface->ai_timerblock);
    Interface->ai_stoptimer = TRUE;

    // Mark him as down.
    Interface->ai_adminstate = IF_STATUS_DOWN;
    ARPUpdateOperStatus(Interface);

    // Mark the interface as going away so it will disappear from the
    // entity list.
    Interface->ai_operstatus = INTERFACE_UNINIT;

#if FFP_SUPPORT
    // Stop FFP on this interface
    Interface->ai_ffpversion = 0;
#endif

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Flushing all ates %x\n", Interface));
    ARPFlushAllATE(Interface);

    // Now tell IP he's gone. We need to make sure that we don't tell him twice.
    // To do this we set the context to NULL after we tell him the first time,
    // and we check to make sure it's non-NULL before notifying him.

    if (Interface->ai_context != NULL) {
        IPDelInterface(Interface->ai_context, TRUE);
        Interface->ai_context = NULL;
    }
    // Finally, close him. We do this here so we can return a valid status.

    CTEGetLock(&Interface->ai_lock, &LockHandle);

    if (Interface->ai_handle != NULL) {
        NDIS_HANDLE Handle = Interface->ai_handle;

        CTEFreeLock(&Interface->ai_lock, LockHandle);

        CTEInitBlockStruc(&Interface->ai_block);
        NdisCloseAdapter(&Status, Handle);

        // Block for close to complete.
        if (Status == NDIS_STATUS_PENDING) {
            Status = (NDIS_STATUS) CTEBlock(&Interface->ai_block);
        }
        Interface->ai_handle = NULL;
    } else {
        CTEFreeLock(&Interface->ai_lock, LockHandle);
        Status = NDIS_STATUS_SUCCESS;
    }

    //Check if are called from ARPUnload

    if ((ARPInterface *) UnbindContext != Interface) {
        CTELockHandle Handle;
        //No. Acquire lock and remove entry.
        CTEGetLock(&ArpInterfaceListLock.Lock, &Handle);
        RemoveEntryList(&Interface->ai_linkage);
        CTEFreeLock(&ArpInterfaceListLock.Lock, Handle);
    }

    *RetStatus = Status;

    if (Status == NDIS_STATUS_SUCCESS) {
        FreeARPInterface(Interface);
    }
}

extern ulong VIPTerminate;

//* ARPUnloadProtocol - Unload.
//
//      Called when we need to unload. All we do is call up to IP, and return.
//
//      Input:  Nothing.
//
//      Returns: Nothing.
//
void NDIS_API
ARPUnloadProtocol(void)
{

#if MILLEN
    DEBUGMSG(1, (DTEXT("ARPUnloadProtocol called! What to do???\n")));
#endif // MILLEN
}

VOID
ArpUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    This routine unloads the TCPIP stack.
    It unbinds from any NDIS drivers that are open and frees all resources
    associated with the transport. The I/O system will not call us until
    nobody above has IPX open.

    NOTE: Also, since other ARP modules depend on IP, they are unloaded before
    out unload handler is called. We concern ourselves with the LAN arp
    only at this point

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/
{
    PLIST_ENTRY pEntry;
    CTELockHandle LockHandle;
    NDIS_STATUS status;
    ARPInterface *Interface;

    //
    // Walk the list of opened ARP interfaces, issuing
    // PnP deletes on each in turn.
    //
    CTEGetLock(&ArpInterfaceListLock.Lock, &LockHandle);

    while(!IsListEmpty(&ArpInterfaceList)) {
        pEntry = ArpInterfaceList.Flink;
        Interface = STRUCT_OF(ARPInterface, pEntry, ai_linkage);
        RemoveEntryList(&Interface->ai_linkage);
        CTEFreeLock(&ArpInterfaceListLock.Lock, LockHandle);
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Issuing unbind on %lx\n", Interface));
        ARPUnbindAdapter(&status, Interface, Interface);
        CTEGetLock(&ArpInterfaceListLock.Lock, &LockHandle);
    }

    CTEFreeLock(&ArpInterfaceListLock.Lock, LockHandle);

    MdpDestroyPool(ArpEnetHeaderPool);
    MdpDestroyPool(ArpAuxHeaderPool);

    //
    // Deal with any residual events/timers
    // Only one timer sits at this layer: ai_timer, which is stopped
    // on the unbind above.
    //

    //
    // call into IP so it can cleanup.
    //
    IPUnload(DriverObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ftrie.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ftrie.h

Abstract:

    This module contains support definitions for 
    an F-trie data stucture, that forms the fast
    path in a fast IP route lookup implementation.

Author:

    Chaitanya Kodeboyina (chaitk)   26-Nov-1997

Revision History:

--*/
#ifndef FTRIE_H_INCLUDED
#define FTRIE_H_INCLUDED

#include "trie.h"

//
// Constants
//

// State of the trie
#define    NORMAL                        0
#define    PARTIAL                       1

//
// Structs
//

// A Node in an F-Trie
typedef struct _FTrieNode FTrieNode;

#pragma warning(push)
#pragma warning(disable:4200) // nonstandard extension used: zero sized array

struct _FTrieNode
{
    LIST_ENTRY  linkage;                // Linkage into list of nodes on the F-Trie
    Dest       *comDest;                // Dest for this subtree's common prefix
    UINT        numDests;               // Number of dests in this node's subtree
    UINT        numBits;                // Number of addr bits to get to children
    FTrieNode  *child[0];               // Child Node (Or) Info Ptr Array [Var Len]
};

#pragma warning(pop)

// An FTrie Data Structure
typedef struct _FTrie FTrie;

struct _FTrie
{
    FTrieNode   *trieRoot;              // Pointer to the root of the FTrie

    ULONG        availMemory;           // Memory available for allocation
    LIST_ENTRY   listofNodes;           // List of nodes allocated on FTrie
    
    UINT         numLevels;             // Total num of levels in the FTrie
    UINT        *bitsInLevel;           // Num of index bits in each level

    UINT        *numDestsInOrigLevel;   // Num of dests in each original level
    UINT        *numNodesInExpnLevel;   // Num of nodes in each expanded level
    UINT        *numDestsInExpnLevel;   // Num of dests in each expanded level
};

// Specific Dest Macros

#define  StoreDestPtr(_p_)     (FTrieNode *) ((ULONG_PTR) _p_ + 1)
#define  RestoreDestPtr(_p_)   (Dest *)      ((ULONG_PTR) _p_ - 1)
#define  IsPtrADestPtr(_p_)    (BOOLEAN)     ((ULONG_PTR) _p_ & 1)

#define  ReplaceDestPtr(_pNewDest_, _pOldDest_, _ppDest_)                       \
                                if (*_ppDest_ == _pOldDest_)                    \
                                {                                               \
                                    *_ppDest_ = _pNewDest_;                     \
                                }                                               \

// Specific FTrieNode Macros

#define  NewFTrieNode(_pFTrie_, _pFTrieNode_, _numBits_, _pDest_)               \
                                {                                               \
                                    UINT __i;                                   \
                                    UINT __numChild = 1 << _numBits_;           \
                                    UINT __numBytes = sizeof(FTrieNode) +       \
                                                    __numChild * sizeof(PVOID); \
                                                                                \
                                    if (_numBits_ > 7*sizeof(PVOID))            \
                                    {                                           \
                                         Recover("Unable to Allocate Memory",   \
                                                (UINT) ERROR_TRIE_RESOURCES);     \
                                    }                                           \
                                                                                \
                                    AllocMemory2(_pFTrieNode_,                  \
                                                 __numBytes,                    \
                                                 _pFTrie_->availMemory);        \
                                                                                \
                                    InsertHeadList(&_pFTrie_->listofNodes,      \
                                                   &_pFTrieNode_->linkage);     \
/*                                                                              \
                                    DbgPrint("Allocating FTNode @ %08x\n",      \
                                                 _pFTrieNode_);                 \
*/                                                                              \
                                    _pFTrieNode_->numDests = 0;                 \
                                                                                \
                                    _pFTrieNode_->comDest = _pDest_;            \
                                                                                \
                                    _pFTrieNode_->numBits = _numBits_;          \
                                                                                \
                                    for (__i = 0; __i < __numChild; __i++)      \
                                    {                                           \
                                         _pFTrieNode_->child[__i] =             \
                                                      StoreDestPtr(NULL);       \
                                    }                                           \
                                }                                               \

#define  FreeFTrieNode(_pFTrie_, _pFTrieNode_)                                  \
                                {                                               \
                                    UINT __numChild = 1 << _pFTrieNode_->numBits;\
                                    UINT __numBytes = sizeof(FTrieNode) +       \
                                                    __numChild * sizeof(PVOID); \
                                                                                \
                                    RemoveEntryList(&_pFTrieNode_->linkage);    \
/*                                                                              \
                                    DbgPrint("Freeing FTNode @ %08x\n",         \
                                                 _pFTrieNode_);                 \
*/                                                                              \
                                    FreeMemory1(_pFTrieNode_,                   \
                                               __numBytes,                      \
                                               _pFTrie_->availMemory);          \
                                }                                               \


// Prototypes
UINT
CALLCONV
InitFTrie                       (IN     FTrie    *pFTrie,
                                 IN     ULONG     levels,
                                 IN     ULONG     maxMemory);

UINT
CALLCONV
InsertIntoFTrie                 (IN     FTrie    *pFTrie,
                                 IN     Route    *pInsRoute,
                                 IN     Dest     *pInsDest,
                                 IN     Dest     *pOldDest);

UINT
CALLCONV
DeleteFromFTrie                 (IN     FTrie    *pFTrie,
                                 IN     Route    *pDelRoute,
                                 IN     Dest     *pDelDest,
                                 IN     Dest     *pNewDest,
                                 IN     BOOLEAN   trieState);

UINT
CALLCONV
SearchDestInFTrie               (IN     FTrie    *pFTrie,
                                 IN     Dest     *pSerDest,
                                 OUT    UINT     *pNumPtrs,
                                 OUT    Dest    **pStartPtr);

Dest *
CALLCONV
SearchAddrInFTrie               (IN     FTrie    *pFTrie,
                                 IN     ULONG     Addr);

UINT
CALLCONV
CleanupFTrie                    (IN     FTrie    *pFTrie);

#if DBG

VOID
CALLCONV
PrintFTrie                      (IN     FTrie    *pFTrie,
                                 IN     UINT      fPrintAll);

VOID
CALLCONV 
PrintFTrieNode                  (IN     FTrieNode *pFTrieNode,
                                 IN     UINT      levelNumber);

#endif // DBG

#endif // FTRIE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ffp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ffp.h

Abstract:

    Structures used in controlling the
    Fast Forwarding Path (FFP)
    functionality in network drivers.

Author:

    Chaitanya Kodeboyina (chaitk)  30-Sep-1998

Environment:

    Kernel Mode

Revision History:

--*/

#ifndef _FFP_H
#define _FFP_H

//
// CacheEntryTypes for OID_FFP_SEED
//

#define FFP_DISCARD_PACKET        -1 // -ve cache entry  - packet discarded
#define FFP_INDICATE_PACKET        0 // invalid entry - packet passed to xport
#define FFP_FORWARD_PACKET        +1 // +ve cache entry - packet forwarded

//
// Input format for various NDIS OIDs
// used in controlling FFP operation
//

//
// RequestInfo for OID_FFP_SUPPORT query
//
typedef    struct _FFPVersionParams {
    ULONG          NdisProtocolType;
    ULONG          FFPVersion;
}   FFPVersionParams;

//
// RequestInfo for OID_FFP_SUPPORT set
//
typedef    struct _FFPSupportParams {
    ULONG          NdisProtocolType;
    ULONG          FastForwardingCacheSize;
    ULONG          FFPControlFlags;
}   FFPSupportParams;

//
// RequestInfo for OID_FFP_FLUSH set
//
typedef struct _FFPFlushParams {
    ULONG          NdisProtocolType;
}   FFPFlushParams;

//
// RequestInfo for OID_FFP_CONTROL query/set
//
typedef    struct _FFPControlParams {
    ULONG          NdisProtocolType;
    ULONG          FFPControlFlags;
}   FFPControlParams;

//
// RequestInfo for OID_FFP_PARAMS query/set
//
typedef    struct _FFPCacheParams {
    ULONG          NdisProtocolType;
    ULONG          FastForwardingCacheSize;
}   FFPCacheParams;

//
// RequestInfo for OID_FFP_SEED query/set
//
typedef struct _FFPDataParams {
    ULONG          NdisProtocolType;
    LONG           CacheEntryType;
    ULONG          HeaderSize;
    union {
        UCHAR       Header[1];
        struct {
            IPHeader Header;
            ULONG    DwordAfterHeader;
        }           IpHeader;
    };
}   FFPDataParams;


//
// RequestInfo for OID_FFP_IFSTATS query/reset
// [ used to get per adapter FF statistics ]
//

/*
InPacketsForwarded refers to the number of packets
received on this adapter that were forwarded out
on another adapter, 
and
OutPacketsForwarded refer to the number of packets
received on another adapter and forwarded out on
on this adapter.
*/

typedef struct _FFPAdapterStats {
    ULONG          NdisProtocolType; 
    ULONG          InPacketsForwarded;
    ULONG          InOctetsForwarded;
    ULONG          InPacketsDiscarded;
    ULONG          InOctetsDiscarded;
    ULONG          InPacketsIndicated;
    ULONG          InOctetsIndicated;
    ULONG          OutPacketsForwarded;
    ULONG          OutOctetsForwarded;
}   FFPAdapterStats;


//
// RequestInfo for OID_FFP_GLSTATS query/reset
// [ used to get global Fast Forwarding stats ]
//

/*
PacketsForwarded refers to the number of packets
forwarded out in the fast path,
and
PacketsDiscarded refers to the number of packets
discarded on the fast path, 
and
PacketsIndicated refers to the number of packets
that were indicated to transport.
*/

typedef struct _FFPDriverStats {
    ULONG          NdisProtocolType;
    ULONG          PacketsForwarded;
    ULONG          OctetsForwarded;
    ULONG          PacketsDiscarded;
    ULONG          OctetsDiscarded;
    ULONG          PacketsIndicated;
    ULONG          OctetsIndicated;
}   FFPDriverStats;

#endif // _FFP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug macros for the ARP module

Revision History:


Notes:

--*/

#ifndef __RT_DEBUG_H__
#define __RT_DEBUG_H__

VOID
RtInitializeDebug();

//
// Tags for Pools
//

#define GROUP_TAG   'gmPI'
#define SOURCE_TAG  'smPI'
#define OIF_TAG     'omPI'
#define MSG_TAG     'mmPI'
#define FREE_TAG    'fmPI'

//
// File signatures for everyone
//

#define DEBUG_SIG   'gbed'
#define INI_SIG     'tini'
#define IOCT_SIG    'tcoi'
#define MFE_SIG     'efmm'
#define FWD_SIG     'dwfm'
#define TMR_SIG     'rmit'

//
// We use the RT_XXX_DEBUG flags so that we can force to
// different debug modes on free builds by changing sources.
// On a checked build, all debugging is on
//

#if DBG

#ifndef RT_TRACE_DEBUG
#define RT_TRACE_DEBUG  1
#endif

#ifndef RT_LOCK_DEBUG
#define RT_LOCK_DEBUG   1
#endif

#ifndef RT_ASSERT_ON
#define RT_ASSERT_ON    1
#endif

#ifndef RT_MEM_DEBUG
#define RT_MEM_DEBUG    1
#endif

#else // DBG

#ifndef RT_TRACE_DEBUG
#define RT_TRACE_DEBUG  0
#endif

#ifndef RT_LOCK_DEBUG
#define RT_LOCK_DEBUG   0
#endif

#ifndef RT_ASSERT_ON
#define RT_ASSERT_ON    0
#endif

#ifndef RT_MEM_DEBUG
#define RT_MEM_DEBUG    0
#endif

#endif // DBG


#if RT_ASSERT_ON

#define RtAssert(X)                                             \
{                                                               \
    if(!(X))                                                    \
    {                                                           \
        DbgPrint("[IPMCAST] Assertion failed in %s at line %d\n",\
                 __FILE__,__LINE__);                            \
        DbgPrint("IPMCAST: Assertion " #X "\n");                 \
        DbgBreakPoint();                                        \
    }                                                           \
}

#else   // RT_ASSERT_ON

#define RtAssert(X)

#endif

#if RT_TRACE_DEBUG

BYTE    g_byDebugLevel;
DWORD   g_fDebugComp;


#define MCAST_STREAM_GLOBAL         0x00000001
#define MCAST_STREAM_SEND           0x00000002
#define MCAST_STREAM_RCV            0x00000004
#define MCAST_STREAM_MFE            0x00000008
#define MCAST_STREAM_MEMORY         0x00000010
#define MCAST_STREAM_IF             0x00000020
#define MCAST_STREAM_FWD            0x00000040
#define MCAST_STREAM_TMR            0x00000080

#define RT_DBG_LEVEL_NONE           0xFF
#define RT_DBG_LEVEL_ERROR          0xE0
#define RT_DBG_LEVEL_WARN           0xD0
#define RT_DBG_LEVEL_INFO           0xC0
#define RT_DBG_LEVEL_TRACE          0xB0


#define Trace(Stream, Level, Str)                   \
{                                                   \
    if ( ((RT_DBG_LEVEL_##Level >= g_byDebugLevel) &&                    \
         ((g_fDebugComp & MCAST_STREAM_##Stream) == MCAST_STREAM_##Stream)))\
    {                                               \
        DbgPrint("[IPMCAST] ");                      \
        DbgPrint Str;                               \
    }                                               \
}


#define TraceEnter(Stream, Str) Trace(Stream, TRACE, ("Entering "Str"\n"))
#define TraceLeave(Stream, Str) Trace(Stream, TRACE, ("Leaving "Str"\n"))


#else   // RT_TRACE_DEBUG


#define Trace(Stream, Level, Str)

#define TraceEnter(Stream, Str)
#define TraceLeave(Stream, Str)



#endif // !RT_TRACE_DEBUG



#if RT_LOCK_DEBUG

extern KSPIN_LOCK  g_ksLockLock;

#ifndef __FILE_SIG__
#error File signature not defined
#endif

typedef struct _RT_LOCK
{
	ULONG		ulLockSig;
	BOOLEAN     bAcquired;
	PKTHREAD    pktLastThread;
	ULONG       ulFileSig;
	ULONG		ulLineNumber;
	KSPIN_LOCK  kslLock;
}RT_LOCK, *PRT_LOCK;


VOID
RtpInitializeSpinLock(
    IN  PRT_LOCK    pLock,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber
    );

VOID
RtpAcquireSpinLock(
    IN  PRT_LOCK    pLock,
    OUT PKIRQL      pkiIrql,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bAtDpc
    );

VOID
RtpReleaseSpinLock(
    IN  PRT_LOCK    pLock,
    IN  KIRQL       kiIrql,
    IN  ULONG       ulFileSig,
    IN  ULONG       ulLineNumber,
    IN  BOOLEAN     bFromDpc
    );

#define RT_LOCK_SIG	'KCOL'


#define RtInitializeSpinLock(X)        RtpInitializeSpinLock((X), __FILE_SIG__, __LINE__)

#define RtAcquireSpinLock(X, Y)        RtpAcquireSpinLock((X), (Y), __FILE_SIG__, __LINE__, FALSE)

#define RtAcquireSpinLockAtDpcLevel(X) RtpAcquireSpinLock((X), NULL, __FILE_SIG__, __LINE__, TRUE)

#define RtReleaseSpinLock(X, Y)        RtpReleaseSpinLock((X), (Y), __FILE_SIG__, __LINE__, FALSE)

#define RtReleaseSpinLockFromDpcLevel(X) RtpReleaseSpinLock((X), 0, __FILE_SIG__, __LINE__, TRUE)


#else   // RT_LOCK_DEBUG


typedef KSPIN_LOCK  RT_LOCK, *PRT_LOCK;

#define RtInitializeSpinLock          KeInitializeSpinLock
#define RtAcquireSpinLock             KeAcquireSpinLock
#define RtAcquireSpinLockAtDpcLevel   KeAcquireSpinLockAtDpcLevel
#define RtReleaseSpinLock             KeReleaseSpinLock
#define RtReleaseSpinLockFromDpcLevel KeReleaseSpinLockFromDpcLevel


#endif	// RT_LOCK_DEBUG





#if RT_MEM_DEBUG


#ifndef __FILE_SIG__
#error File signature not defined
#endif

//
// Memory Allocation/Freeing Audit:
//

//
// The RT_ALLOCATION structure stores all info about one allocation
//

typedef struct _RT_ALLOCATION
{
    LIST_ENTRY  leLink;
    ULONG       ulMemSig;
    ULONG       ulFileSig;
    ULONG       ulLineNumber;
    ULONG       ulSize;
    UCHAR		pucData[1];
}RT_ALLOCATION, *PRT_ALLOCATION;

//
// The RT_FREE structure stores info about an allocation
// that was freed. Later if the memory is touched, the
// free list can be scanned to see where the allocation was
// freed
//

typedef struct _RT_FREE
{
    LIST_ENTRY  leLink;
    ULONG_PTR   ulStartAddr;
    ULONG       ulSize;
    ULONG       ulMemSig;
    ULONG       ulAllocFileSig;
    ULONG       ulAllocLineNumber;
    ULONG       ulFreeFileSig;
    ULONG       ulFreeLineNumber;
}RT_FREE, *PRT_FREE;


#define RT_MEMORY_SIG     'YRMM'
#define RT_FREE_SIG       'EERF'

PVOID
RtpAllocate(
    IN POOL_TYPE    ptPool,
	IN ULONG	    ulSize,
    IN ULONG        ulTag,
	IN ULONG	    ulFileSig,
	IN ULONG	    ulLineNumber
    );

VOID
RtpFree(
	PVOID	pvPointer,
    IN ULONG	    ulFileSig,
	IN ULONG	    ulLineNumber
    );

VOID
RtAuditMemory();

#define RtAllocate(X, Y, Z)   RtpAllocate((X), (Y), (Z), __FILE_SIG__, __LINE__)
#define RtFree(X)             RtpFree((X), __FILE_SIG__, __LINE__)



#else // RT_MEM_DEBUG



#define RtAllocate    ExAllocatePoolWithTag
#define RtFree        ExFreePool

#define RtAuditMemory()



#endif // RT_MEM_DEBUG




#endif // __RT_DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ftrie.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ftrie.c

Abstract:

    This module contains routines that manipulate
    an F-trie data stucture, that forms the fast
    path in a fast IP route lookup implementation.

Author:

    Chaitanya Kodeboyina (chaitk)   26-Nov-1997

Revision History:

--*/

#include "precomp.h"
#include "ftrie.h"

UINT
CALLCONV
InitFTrie(IN FTrie * pFTrie,
          IN ULONG levels,
          IN ULONG maxMemory)
/*++

Routine Description:

    Initialises an F-trie. This should be done prior to
    any other trie operations.

Arguments:

    pFTrie - Pointer to the trie to be initialized
    levels - Bitmap [ 32 bits ] of expanded levels
    maxMemory - Limit on memory taken by the F-Trie

    For example, levels = 0xF0F0F0F0 [8,16,24,32 bits]
    means -> all prefixes are expanded to these levels
    and only these trie levels have any dests at all

    Num of Levels + 2 memory accesses are needed in the
    worst case to get to the dest corresponding to a
    prefix - Num of Levels + 1 accesses including the
    zero level access, and 1 access to read the dest.

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    UINT prevLevel;
    UINT currLevel;
    UINT nBytes, i;

    TRY_BLOCK
    {
        if (levels == 0) {
            Error("NewFTrie: No levels specified", (UINT) ERROR_TRIE_BAD_PARAM);
        }
        // Zero all the memory for the trie header
        RtlZeroMemory(pFTrie, sizeof(FTrie));

        // Set a limit on the memory for trie/nodes
        pFTrie->availMemory = maxMemory;

        // Initialize list of trienodes allocated
        InitializeListHead(&pFTrie->listofNodes);

        // Initialize root node with a NULL dest
        pFTrie->trieRoot = StoreDestPtr(NULL);

        // Initialize the number of bits in each level
        nBytes = (MAXLEVEL + 1) * sizeof(UINT);
        AllocMemory2(pFTrie->bitsInLevel,
                     nBytes,
                     pFTrie->availMemory);
        RtlZeroMemory(pFTrie->bitsInLevel, nBytes);

        // Get the number of index bits at each level
        prevLevel = 0;
        i = 0;

        for (currLevel = 1; currLevel <= MAXLEVEL; currLevel++) {
            if (levels & 1) {
                pFTrie->bitsInLevel[i++] = currLevel - prevLevel;

                prevLevel = currLevel;
            }
            levels >>= 1;
        }

        pFTrie->numLevels = i;

        // Make sure that the last level is MAXLEVEL
        pFTrie->bitsInLevel[i] = MAXLEVEL - prevLevel;
        if (pFTrie->bitsInLevel[i]) {
            pFTrie->numLevels++;
        }
#if DBG
        Print("Num of levels: %d\n", pFTrie->numLevels);
        Print("Bits In Level:\n");
        for (i = 0; i < pFTrie->numLevels; i++) {
            Print("\t%d", pFTrie->bitsInLevel[i]);
            if (i % 8 == 7)
                Print("\n");
        }
        Print("\n\n");
#endif

        // Allocate and Zero all the statistics variables
        nBytes = (MAXLEVEL + 1) * sizeof(UINT);
        AllocMemory2(pFTrie->numDestsInOrigLevel,
                     nBytes,
                     pFTrie->availMemory);
        RtlZeroMemory(pFTrie->numDestsInOrigLevel, nBytes);

        nBytes = pFTrie->numLevels * sizeof(UINT);
        AllocMemory2(pFTrie->numNodesInExpnLevel,
                     nBytes,
                     pFTrie->availMemory);
        RtlZeroMemory(pFTrie->numNodesInExpnLevel, nBytes);

        nBytes = pFTrie->numLevels * sizeof(UINT);
        AllocMemory2(pFTrie->numDestsInExpnLevel,
                     nBytes,
                     pFTrie->availMemory);
        RtlZeroMemory(pFTrie->numDestsInExpnLevel, nBytes);

        return TRIE_SUCCESS;
    }
    ERR_BLOCK
    {
        // Not enough resources to create an FTrie
        CleanupFTrie(pFTrie);
    }
    END_BLOCK
}

UINT
CALLCONV
InsertIntoFTrie(IN FTrie * pFTrie,
                IN Route * pInsRoute,
                IN Dest * pInsDest,
                IN Dest * pOldDest)
/*++

Routine Description:

    Inserts a dest corresponding to an address
    prefix into a F-trie. It actually replaces
    all pointers to OldDest by that of InsDest.

Arguments:

    pFTrie    - Pointer to the F-Trie to insert into
    pInsRoute - Pointer to best route on new dest
    pInsDest  - Pointer to the dest being inserted
    pOldDest  - Pointer to the dest being replaced

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    FTrieNode **ppCurrNode;
    FTrieNode *pCurrNode;
    Dest *pBestDest;
    Dest *pComDest;
    UINT startIndex;
    UINT stopIndex;
    UINT nextIndex;
    UINT shiftIndex;
    UINT addrBits;
    UINT numBits;
    UINT bitsLeft;
    UINT i;

#if DBG
    // Make sure the trie is initialized
    if (!pFTrie || !pFTrie->trieRoot) {
        Fatal("Insert Dest: FTrie not initialized",
              ERROR_TRIE_NOT_INITED);
    }
    // Make sure input dest is valid

    if (NULL_DEST(pInsDest)) {
        Fatal("Insert Dest: NULL or invalid dest",
              ERROR_TRIE_BAD_PARAM);
    }
    // Make sure input route is valid

    if (NULL_ROUTE(pInsRoute)) {
        Fatal("Insert Dest: NULL or invalid route",
              ERROR_TRIE_BAD_PARAM);
    }
    if (LEN(pInsRoute) > ADDRSIZE) {
        Fatal("Insert Dest: Invalid mask length",
              ERROR_TRIE_BAD_PARAM);
    }
#endif

    Assert(pInsDest != pOldDest);

    // Use addr bits to index the trie
    addrBits = RtlConvertEndianLong(DEST(pInsRoute));
    bitsLeft = LEN(pInsRoute);

#if DBG
    // Make sure addr and mask agree
    if (ShowMostSigNBits(addrBits, bitsLeft) != addrBits) {
        Fatal("Insert Dest: Addr & mask don't agree",
              ERROR_TRIE_BAD_PARAM);
    }
#endif

    TRY_BLOCK
    {
        // Special case: Default Prefix
        if (LEN(pInsRoute) == 0) {
            // Do we have a subtree in the trie's root node ?
            if (IsPtrADestPtr(pFTrie->trieRoot)) {
                // Make sure you are replacing right dest
                Assert(pFTrie->trieRoot == StoreDestPtr(pOldDest));

                // Make the root to point to the new default
                pFTrie->trieRoot = StoreDestPtr(pInsDest);
            } else {
                // Make sure you are replacing right dest
                Assert(pFTrie->trieRoot->comDest == pOldDest);

                // Make new dest the common subtrie dest
                pFTrie->trieRoot->comDest = pInsDest;
            }

            return TRIE_SUCCESS;
        }
        // Start going down the trie using addr bits

        pBestDest = NULL;

        ppCurrNode = &pFTrie->trieRoot;

        for (i = 0; /* NOTHING */ ; i++) {
            pCurrNode = *ppCurrNode;

            if (IsPtrADestPtr(pCurrNode)) {
                // Creating a new subtree for the current level

                // This pointer actually points to a dest node
                pComDest = RestoreDestPtr(pCurrNode);

                // Create, initialize a new FTrie node (grow it)
                NewFTrieNode(pFTrie,
                             pCurrNode,
                             pFTrie->bitsInLevel[i],
                             pComDest);

                // Attach it to the FTrie
                *ppCurrNode = pCurrNode;

                // Update FTrie Statistics
                pFTrie->numNodesInExpnLevel[i]++;
            }
            // Update the best dest seen so far - used later
            pComDest = pCurrNode->comDest;
            if (pComDest) {
                pBestDest = pComDest;
            }
            // Increment the number of dests in this subtrie
            pCurrNode->numDests++;

            // Can I pass this level with remaining bits ?
            if (bitsLeft <= pFTrie->bitsInLevel[i]) {
                break;
            }
            // Get the next index from the IP addr
            numBits = pCurrNode->numBits;

            nextIndex = PickMostSigNBits(addrBits, numBits);
            ppCurrNode = &pCurrNode->child[nextIndex];

            // Throw away the used bits
            addrBits <<= numBits;
            bitsLeft -= numBits;
        }

        // Update FTrie stats before expanding
        // Update if this isn't a dest change
        pFTrie->numDestsInExpnLevel[i]++;
        pFTrie->numDestsInOrigLevel[LEN(pInsRoute)]++;

        // At this level, expand and add the dest
        nextIndex = PickMostSigNBits(addrBits, bitsLeft);
        shiftIndex = pFTrie->bitsInLevel[i] - bitsLeft;

        startIndex = nextIndex << shiftIndex;
        stopIndex = (nextIndex + 1) << shiftIndex;

        // Have you seen the old dest already ?
        if (pBestDest == pOldDest) {
            pOldDest = NULL;
        }
        // These dests cannot be the same here
        Assert(pInsDest != pOldDest);

        // Fill the expanded range with the dest
        for (i = startIndex; i < stopIndex; i++) {
            if (IsPtrADestPtr(pCurrNode->child[i])) {
                // A dest pointer - replace with new one
                ReplaceDestPtr(StoreDestPtr(pInsDest),
                               StoreDestPtr(pOldDest),
                               &pCurrNode->child[i]);
            } else {
                // Node pointer - update subtree's dest
                ReplaceDestPtr(pInsDest,
                               pOldDest,
                               &pCurrNode->child[i]->comDest);
            }
        }

        return TRIE_SUCCESS;
    }
    ERR_BLOCK
    {
        // Not enough resources - rollback to original state
        DeleteFromFTrie(pFTrie, pInsRoute, pInsDest, pOldDest, PARTIAL);
    }
    END_BLOCK
}

UINT
CALLCONV
DeleteFromFTrie(IN FTrie * pFTrie,
                IN Route * pDelRoute,
                IN Dest * pDelDest,
                IN Dest * pNewDest,
                IN BOOLEAN trieState)
/*++

Routine Description:

    Deletes a dest corresponding to an address
    prefix from a F-trie. It actually replaces
    all pointers to DelDest by that of NewDest.

Arguments:

    pFTrie    - Pointer to the F-Trie to delete from
    pDelRoute - Pointer to last route on old dest
    pDelDest  - Pointer to the dest being deleted
    pNewDest  - Pointer to the dest replacing above
    trieState - NORMAL - deleting from a consistent FTrie
                PARTIAL - cleaning up an incomplete insert

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    FTrieNode **ppCurrNode;
    FTrieNode *pCurrNode;
    FTrieNode *pPrevNode;
    FTrieNode *pNextNode;
    Dest *pBestDest;
    Dest *pComDest;
    UINT startIndex;
    UINT stopIndex;
    UINT nextIndex;
    UINT shiftIndex;
    UINT addrBits;
    UINT numBits;
    UINT bitsLeft;
    UINT i, j;

    DBG_UNREFERENCED_PARAMETER(trieState);
    j = 1;
    
#if DBG
    // Make sure the trie is initialized
    if (!pFTrie || !pFTrie->trieRoot) {
        Fatal("Delete Dest: FTrie not initialized",
              ERROR_TRIE_NOT_INITED);
    }
    // Make sure input dest is valid

    if (NULL_DEST(pDelDest)) {
        Fatal("Delete Dest: NULL or invalid dest",
              ERROR_TRIE_BAD_PARAM);
    }
    // Make sure input route is valid

    if (NULL_ROUTE(pDelRoute)) {
        Fatal("Delete Dest: NULL or invalid route",
              ERROR_TRIE_BAD_PARAM);
    }
    if (LEN(pDelRoute) > ADDRSIZE) {
        Fatal("Delete Dest: Invalid mask length",
              ERROR_TRIE_BAD_PARAM);
    }
#endif

    // Use addr bits to index the trie
    addrBits = RtlConvertEndianLong(DEST(pDelRoute));
    bitsLeft = LEN(pDelRoute);

#if DBG
    // Make sure addr and mask agree
    if (ShowMostSigNBits(addrBits, bitsLeft) != addrBits) {
        Fatal("Delete Dest: Addr & mask don't agree",
              ERROR_TRIE_BAD_PARAM);
    }
#endif

    Assert(pDelDest != pNewDest);

    // Special case: Default Prefix
    if (LEN(pDelRoute) == 0) {
        // Do we have a subtree in the trie's root node ?
        if (IsPtrADestPtr(pFTrie->trieRoot)) {
            // Make sure you are replacing right dest
            Assert(pFTrie->trieRoot == StoreDestPtr(pDelDest));

            // Make the root to point to the new default
            pFTrie->trieRoot = StoreDestPtr(pNewDest);
        } else {
            // Make sure you are replacing right dest
            Assert(pFTrie->trieRoot->comDest == pDelDest);

            // Make new dest the common subtrie dest
            pFTrie->trieRoot->comDest = pNewDest;
        }

        return TRIE_SUCCESS;
    }
    // Start going down the trie using addr bits

    pBestDest = NULL;

    ppCurrNode = &pFTrie->trieRoot;

    pPrevNode = pCurrNode = *ppCurrNode;

    for (i = 0; /* NOTHING */ ; i++) {
        // We still have bits left, so we go down the trie

        // Do we have a valid subtree at the current node
        if (IsPtrADestPtr(pCurrNode)) {
            // We are cleaning a partial (failed) insert
            Assert(trieState == PARTIAL);

            // We have cleaned up the trie - return now
            return TRIE_SUCCESS;
        }
        // We have a valid subtree, so we go down the trie

        // Update the best dest seen so far - used later
        pComDest = pCurrNode->comDest;
        if (pComDest) {
            pBestDest = pComDest;
        }
        // Decrement the number of dests in this subtrie
        pCurrNode->numDests--;

        // Is the number of dests in curr subtree zero ?
        if (pCurrNode->numDests == 0) {
#if DBG
            int k = 0;

            // Just make sure that only one dest exists
            for (j = 1; j < (UINT) 1 << pCurrNode->numBits; j++) {
                if (pCurrNode->child[j - 1] != pCurrNode->child[j]) {
                    Assert((pCurrNode->child[j] == StoreDestPtr(NULL)) ||
                           (pCurrNode->child[j - 1] == StoreDestPtr(NULL)));
                    k++;
                }
            }

            if (trieState == NORMAL) {
                if ((k != 1) && (k != 2)) {
                    Print("k = %d\n", k);
                    Assert(FALSE);
                }
            } else {
                if ((k != 0) && (k != 1) && (k != 2)) {
                    Print("k = %d\n", k);
                    Assert(FALSE);
                }
            }
#endif

            // Remove link from its parent (if it exists)
            if (pPrevNode) {
                *ppCurrNode = StoreDestPtr(pCurrNode->comDest);
            }
        }
        // Can I pass this level with remaining bits ?
        if (bitsLeft <= pFTrie->bitsInLevel[i]) {
            break;
        }
        // Get the next index from the IP addr
        numBits = pCurrNode->numBits;

        nextIndex = PickMostSigNBits(addrBits, numBits);
        ppCurrNode = &pCurrNode->child[nextIndex];

        pNextNode = *ppCurrNode;

        // Throw away the used bits
        addrBits <<= numBits;
        bitsLeft -= numBits;

        // Is the number of dests in subtree zero ?
        if (pCurrNode->numDests == 0) {
            // Deallocate it (shrink FTrie)
            FreeFTrieNode(pFTrie, pCurrNode);

            // Update FTrie Statistics
            pFTrie->numNodesInExpnLevel[i]--;
        }
        pPrevNode = pCurrNode;
        pCurrNode = pNextNode;
    }

    // Update F-Trie stats before deleting
    pFTrie->numDestsInExpnLevel[i]--;
    pFTrie->numDestsInOrigLevel[LEN(pDelRoute)]--;

    // Is the number of dests in curr subtree zero ?
    if (pCurrNode->numDests == 0) {
        // Deallocate it (shrink FTrie)
        FreeFTrieNode(pFTrie, pCurrNode);

        // Update FTrie Statistics
        pFTrie->numNodesInExpnLevel[i]--;
    } else {
        // At this level, expand and add the dest
        nextIndex = PickMostSigNBits(addrBits, bitsLeft);
        shiftIndex = pFTrie->bitsInLevel[i] - bitsLeft;

        startIndex = nextIndex << shiftIndex;
        stopIndex = (nextIndex + 1) << shiftIndex;

        // Have you seen the new dest already ?
        if (pBestDest == pNewDest) {
            pNewDest = NULL;
        }
        // These dests cannot be the same here
        Assert(pDelDest != pNewDest);

        // Fill the expanded range with the dest
        for (i = startIndex; i < stopIndex; i++) {
            if (IsPtrADestPtr(pCurrNode->child[i])) {
                // A dest pointer - replace with new one
                ReplaceDestPtr(StoreDestPtr(pNewDest),
                               StoreDestPtr(pDelDest),
                               &pCurrNode->child[i]);
            } else {
                // Node pointer - update subtree's dest
                ReplaceDestPtr(pNewDest,
                               pDelDest,
                               &pCurrNode->child[i]->comDest);
            }
        }
    }

    return TRIE_SUCCESS;
}

UINT
CALLCONV
SearchDestInFTrie(IN FTrie * pFTrie,
                  IN Dest * pSerDest,
                  OUT UINT * pNumPtrs,
                  OUT Dest ** pStartPtr)
/*++

Routine Description:

    Search for a specific dest in an F-trie,
    returns the expanded range for the dest

Arguments:

    pFTrie     - Pointer to the F-trie to search
    pSerDest   - Pointer to dest being searched
    pStartPtr  - Start of dest's expanded range
    pNumPtrs   - Number of pointers in the range

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*

--*/
{
    UNREFERENCED_PARAMETER(pFTrie);
    UNREFERENCED_PARAMETER(pSerDest);
    UNREFERENCED_PARAMETER(pNumPtrs);
    UNREFERENCED_PARAMETER(pStartPtr);
    
    return (UINT) ERROR_TRIE_BAD_PARAM;
}

Dest *
 CALLCONV
SearchAddrInFTrie(IN FTrie * pFTrie,
                  IN ULONG Addr)
/*++

Routine Description:

    Search for an address in an F-trie

Arguments:

    pFTrie  - Pointer to the trie to search
    Addr    - Pointer to addr being queried

Return Value:
    Return best dest match for this address

--*/
{
    FTrieNode *pCurrNode;
    Dest *pBestDest;
    Dest *pDest;
    ULONG addrBits;
    UINT numBits;
    UINT nextIndex;

#if DBG
    if (!pFTrie || !pFTrie->trieRoot) {
        Fatal("Searching into an uninitialized FTrie",
              ERROR_TRIE_NOT_INITED);
    }
#endif

    addrBits = RtlConvertEndianLong(Addr);

    pBestDest = NULL;

    pCurrNode = pFTrie->trieRoot;

    for (;;) {
        // Have we reached the end of this search ?
        if (IsPtrADestPtr(pCurrNode)) {
            // Get the best matching dest until now
            pDest = RestoreDestPtr(pCurrNode);
            if (!NULL_DEST(pDest)) {
                pBestDest = pDest;
            }
            return pBestDest;
        } else {
            // Get the best matching dest until now
            pDest = pCurrNode->comDest;
            if (!NULL_DEST(pDest)) {
                pBestDest = pDest;
            }
        }

        // Number of bits to use in this FTrie level
        numBits = pCurrNode->numBits;

        // Get the next index from IP address bits
        nextIndex = PickMostSigNBits(addrBits, numBits);

        // And go down the tree with the new index
        pCurrNode = pCurrNode->child[nextIndex];

        // Throw away the used bits for this iteration
        addrBits <<= numBits;
    }
}

UINT
CALLCONV
CleanupFTrie(IN FTrie * pFTrie)
/*++

Routine Description:

    Deletes an F-trie if it is empty

Arguments:

    ppFTrie - Ptr to the F-trie

Return Value:

    TRIE_SUCCESS or ERROR_TRIE_*
--*/
{
    FTrieNode *pCurrNode;
    LIST_ENTRY *p;

    // Free all trie nodes and corresponding memory
    while (!IsListEmpty(&pFTrie->listofNodes)) {
        p = RemoveHeadList(&pFTrie->listofNodes);
        pCurrNode = CONTAINING_RECORD(p, FTrieNode, linkage);
        FreeFTrieNode(pFTrie, pCurrNode);
    }

    // Free the memory for the arr of levels
    if (pFTrie->bitsInLevel) {
        FreeMemory1(pFTrie->bitsInLevel,
                    (MAXLEVEL + 1) * sizeof(UINT),
                    pFTrie->availMemory);
    }
    // Free memory allocated for statistics
    if (pFTrie->numDestsInOrigLevel) {
        FreeMemory1(pFTrie->numDestsInOrigLevel,
                    (MAXLEVEL + 1) * sizeof(UINT),
                    pFTrie->availMemory);
    }
    if (pFTrie->numNodesInExpnLevel) {
        FreeMemory1(pFTrie->numNodesInExpnLevel,
                    pFTrie->numLevels * sizeof(UINT),
                    pFTrie->availMemory);
    }
    if (pFTrie->numDestsInExpnLevel) {
        FreeMemory1(pFTrie->numDestsInExpnLevel,
                    pFTrie->numLevels * sizeof(UINT),
                    pFTrie->availMemory);
    }
    // Reset other fields in trie structure
    pFTrie->trieRoot = NULL;
    pFTrie->numLevels = 0;

    return TRIE_SUCCESS;
}

#if DBG

VOID
CALLCONV
PrintFTrie(IN FTrie * pFTrie,
           IN UINT printFlags)
/*++

Routine Description:

    Print an F-Trie

Arguments:

    pFTrie - Pointer to the F-Trie
    printFlags - Information to print

Return Value:

    None
--*/
{
    UINT i;

    if (pFTrie == NULL) {
        Print("%s", "Uninitialized FTrie\n\n");
        return;
    }
    if ((printFlags & SUMM) == SUMM) {
        Print("\n\n/***Fast-Trie------------------------------------------------");
        Print("\n/***---------------------------------------------------------\n");
    }
    if (printFlags & POOL) {
        Print("Available Memory: %10lu\n\n", pFTrie->availMemory);
    }
    if (printFlags & STAT) {
        Print("Statistics:\n\n");

        Print("Num of levels: %d\n", pFTrie->numLevels);
        Print("Bits In Level:\n");
        for (i = 0; i < pFTrie->numLevels; i++) {
            Print("\t%d", pFTrie->bitsInLevel[i]);
            if (i % 8 == 7)
                Print("\n");
        }
        Print("\n\n");

        Print("Num of Nodes in Expanded Levels:\n");
        for (i = 0; i < pFTrie->numLevels; i++) {
            Print("\t%d", pFTrie->numNodesInExpnLevel[i]);
            if (i % 8 == 7)
                Print("\n");
        }
        Print("\n\n");

        Print("Num of Dests in Original Levels:\n");
        for (i = 0; i < MAXLEVEL + 1; i++) {
            Print("\t%d", pFTrie->numDestsInOrigLevel[i]);
            if (i % 8 == 0)
                Print("\n");
        }
        Print("\n\n");

        Print("Num of Dests in Expanded Levels:\n");
        for (i = 0; i < pFTrie->numLevels; i++) {
            Print("\t%d", pFTrie->numDestsInExpnLevel[i]);
            if (i % 8 == 7)
                Print("\n");
        }
        Print("\n\n");
    }
    if (printFlags & TRIE) {
        if (!IsPtrADestPtr(pFTrie->trieRoot)) {
            PrintFTrieNode(pFTrie->trieRoot, 0);
        } else {
            PrintDest(RestoreDestPtr(pFTrie->trieRoot));
        }
    }
    if ((printFlags & SUMM) == SUMM) {
        Print("\n---------------------------------------------------------***/\n");
        Print("---------------------------------------------------------***/\n\n");
    }
}

VOID
CALLCONV
PrintFTrieNode(IN FTrieNode * pFTrieNode,
               IN UINT levelNumber)
/*++

Routine Description:

    Print an F-Trie node

Arguments:

    pFTrieNode - Pointer to the FTrie node

Return Value:

    None
--*/
{
    FTrieNode *pCurrNode;
    UINT numElmts;
    UINT i;

    Print("\n/*-----------------------------------------------------------\n");
    Print("Num of bits at level %3d : %d\n", levelNumber, pFTrieNode->numBits);
    Print("Number of Subtrie Dests : %d\n", pFTrieNode->numDests);
    Print("Common SubTree Dest : ");
    PrintDest(pFTrieNode->comDest);
    Print("\n");

    numElmts = 1 << pFTrieNode->numBits;
    pCurrNode = StoreDestPtr(NULL);

    Print("Child Ptrs:\n\n");
    for (i = 0; i < numElmts; i++) {
        if (pFTrieNode->child[i] != pCurrNode) {
            pCurrNode = pFTrieNode->child[i];

            Print("Child Index: %8lu ", i);

            if (IsPtrADestPtr(pCurrNode)) {
                PrintDest(RestoreDestPtr(pCurrNode));
            } else {
                PrintFTrieNode(pCurrNode, levelNumber + 1);
            }
        }
    }
    Print("-----------------------------------------------------------*/\n\n");
}

#endif // DBG


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\icmp.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//***   icmp.h - IP ICMP header.
//
//  This module contains private ICMP definitions.
//
#pragma once

#define PROT_ICMP   1

#define ICMP_ECHO_RESP      0
#define ICMP_ECHO           8
#define ICMP_TIMESTAMP      13
#define ICMP_TIMESTAMP_RESP 14

#define MIN_ERRDATA_LENGTH  8       // Minimum amount of data we need.

// Structure of an ICMP header.

typedef struct ICMPHeader {
    uchar       ich_type;           // Type of ICMP packet.
    uchar       ich_code;           // Subcode of type.
    ushort      ich_xsum;           // Checksum of packet.
    ulong       ich_param;          // Type-specific parameter field.
} ICMPHeader;

typedef struct ICMPRouterAdHeader {
    uchar       irah_numaddrs;      // Number of addresses
    uchar       irah_addrentrysize; // Address Entry Size
    ushort      irah_lifetime;      // Lifetime
} ICMPRouterAdHeader;

typedef struct ICMPRouterAdAddrEntry {
    IPAddr      irae_addr;          // Router Address
    long        irae_preference;    // Preference Level
} ICMPRouterAdAddrEntry;

typedef struct ICMPSendCompleteCtxt {
    uchar       iscc_Type;
    uchar       *iscc_DataPtr;
} ICMPSendCompleteCtxt;

typedef void    (*EchoRtn)(struct EchoControl *, IP_STATUS, void *, uint, IPOptInfo *);

typedef struct EchoControl {
    struct EchoControl *ec_next;        // Next control structure in list.
    EchoRtn             ec_rtn;         // Pointer to routine to call when completing request.
    LARGE_INTEGER       ec_starttime;   // time request was issued
    void               *ec_replybuf;    // buffer to store replies
    ulong               ec_replybuflen; // size of reply buffer
    ulong               ec_to;          // Timeout
    IPAddr              ec_src;         // IPAddr of source
    uint                ec_seq;         // Seq. # of this ping request. 32-bit
                                        // to reduce collisons from wraparound.
    uchar               ec_active;      // Set when packet has been sent
} EchoControl;

extern ICMPHeader   *GetICMPBuffer(uint Size, PNDIS_BUFFER *Buffer);
extern void         FreeICMPBuffer(PNDIS_BUFFER Buffer, uchar Type);
extern void         ICMPSendComplete(ICMPSendCompleteCtxt *SCC, PNDIS_BUFFER BufferChain, IP_STATUS SendStatus);
extern uint         AddrMaskReply;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\icmp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  icmp.c - IP ICMP routines.

Abstract:

 This module contains all of the ICMP related routines.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "mdlpool.h"
#include "icmp.h"
#include "info.h"
#include "iproute.h"
#include "ipxmit.h"
#include <icmpif.h>
#include "iprtdef.h"
#include "tcpipbuf.h"

#if GPC
#include "qos.h"
#include "traffic.h"
#include "gpcifc.h"
#include "ntddtc.h"

extern GPC_HANDLE hGpcClient[];
extern ULONG GpcCfCounts[];
extern GPC_EXPORTED_CALLS GpcEntries;
extern ULONG GPCcfInfo;
#endif

extern ProtInfo IPProtInfo[];    // Protocol information table.

extern void *IPRegisterProtocol(uchar, void *, void *, void *, void *, void *, void *);

extern ulong GetTime();

extern ULStatusProc FindULStatus(uchar);
extern uchar IPUpdateRcvdOptions(IPOptInfo *, IPOptInfo *, IPAddr, IPAddr);
extern void IPInitOptions(IPOptInfo *);
extern IP_STATUS IPCopyOptions(uchar *, uint, IPOptInfo *);
extern IP_STATUS IPFreeOptions(IPOptInfo *);
extern uchar IPGetLocalAddr(IPAddr, IPAddr *);
void ICMPRouterTimer(NetTableEntry *);

extern NDIS_HANDLE BufferPool;

extern uint DisableUserTOS;
extern uint DefaultTOS;
extern NetTableEntry **NewNetTableList;        // hash table for NTEs
extern uint NET_TABLE_SIZE;
extern ProtInfo *RawPI;            // Raw IP protinfo

uint EnableICMPRedirects = 0;
uint AddrMaskReply;
ICMPStats ICMPInStats;
ICMPStats ICMPOutStats;

HANDLE IcmpHeaderPool;



// Each ICMP header buffer contains room for the outer IP header, the
// ICMP header and the inner IP header (for the ICMP error case).
//
#define BUFSIZE_ICMP_HEADER_POOL    sizeof(IPHeader) + sizeof(ICMPHeader) + \
                                    sizeof(IPHeader) +  MAX_OPT_SIZE + \
                                    MAX_ICMP_PAYLOAD_SIZE

#define TIMESTAMP_MSG_LEN  3    // icmp timestamp message length is 3 long words (12 bytes)
// fix for icmp 3 way ping bug

#define MAX_ICMP_ECHO 1000
int IcmpEchoPendingCnt = 0;

// fix for system crash because of
// too many UDP PORT_UNREACH errors
// this covers redirect as well as
// unreachable errors

#define MAX_ICMP_ERR 1000
int IcmpErrPendingCnt = 0;

void ICMPInit(uint NumBuffers);

IP_STATUS
ICMPEchoRequest(
                void *InputBuffer,
                uint InputBufferLength,
                EchoControl * ControlBlock,
                EchoRtn Callback);

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, ICMPInit)
#pragma alloc_text(PAGE, ICMPEchoRequest)

#endif // ALLOC_PRAGMA

//* UpdateICMPStats - Update ICMP statistics.
//
//  A routine to update the ICMP statistics.
//
//  Input:  Stats       - Pointer to stat. structure to update (input or output).
//          Type        - Type of stat to update.
//
//  Returns: Nothing.
//
void
UpdateICMPStats(ICMPStats * Stats, uchar Type)
{
    switch (Type) {
    case ICMP_DEST_UNREACH:
        Stats->icmps_destunreachs++;
        break;
    case ICMP_TIME_EXCEED:
        Stats->icmps_timeexcds++;
        break;
    case ICMP_PARAM_PROBLEM:
        Stats->icmps_parmprobs++;
        break;
    case ICMP_SOURCE_QUENCH:
        Stats->icmps_srcquenchs++;
        break;
    case ICMP_REDIRECT:
        Stats->icmps_redirects++;
        break;
    case ICMP_TIMESTAMP:
        Stats->icmps_timestamps++;
        break;
    case ICMP_TIMESTAMP_RESP:
        Stats->icmps_timestampreps++;
        break;
    case ICMP_ECHO:
        Stats->icmps_echos++;
        break;
    case ICMP_ECHO_RESP:
        Stats->icmps_echoreps++;
        break;
    case ADDR_MASK_REQUEST:
        Stats->icmps_addrmasks++;
        break;
    case ADDR_MASK_REPLY:
        Stats->icmps_addrmaskreps++;
        break;
    default:
        break;
    }

}

//** GetICMPBuffer - Get an ICMP buffer, and allocate an NDIS_BUFFER that maps it.
//
//  A routine to allocate an ICMP buffer and map an NDIS_BUFFER to it.
//
//  Entry:  Size    - Size in bytes header buffer should be mapped as.
//          Buffer  - Pointer to pointer to NDIS_BUFFER to return.
//
//  Returns: Pointer to ICMP buffer if allocated, or NULL.
//
ICMPHeader *
GetICMPBuffer(uint Size, PNDIS_BUFFER *Buffer)
{
    ICMPHeader *Header;

    ASSERT(Size);
    ASSERT(Buffer);

    *Buffer = MdpAllocate(IcmpHeaderPool, &Header);

    if (*Buffer) {
        NdisAdjustBufferLength(*Buffer, Size);

        // Reserve room for the IP Header.
        //
        Header = (ICMPHeader *)((uchar *)Header + sizeof(IPHeader));
        Header->ich_xsum = 0;
    }

    return Header;
}

//** FreeICMPBuffer - Free an ICMP buffer.
//
//  This routine puts an ICMP buffer back on our free list.
//
//  Entry:  Buffer      - Pointer to NDIS_BUFFER to be freed.
//          Type        - ICMP header type
//
//  Returns: Nothing.
//
void
FreeICMPBuffer(PNDIS_BUFFER Buffer, uchar Type)
{

    ASSERT(Buffer);

    // If the header is ICMP echo response, decrement the pending count.
    //
    if (Type == ICMP_ECHO_RESP) {
        InterlockedDecrement( (PLONG) &IcmpEchoPendingCnt);
    } else if ((Type == ICMP_DEST_UNREACH) ||
               (Type == ICMP_REDIRECT)) {
        InterlockedDecrement( (PLONG) &IcmpErrPendingCnt);
    }

    MdpFree(Buffer);
}

//** DeleteEC - Remove an EchoControl from an NTE, and return a pointer to it.
//
//  This routine is called when we need to remove an echo control structure from
//  an NTE. We walk the list of EC structures on the NTE, and if we find a match
//  we remove it and return a pointer to it.
//
//  Entry:  NTE         - Pointer to NTE to be searched.
//          Seq         - Seq. # identifying the EC.
//          MatchUshort - if TRUE, matches on lower 16 bits of seq. #
//
//  Returns: Pointer to the EC if it finds it.
//
EchoControl *
DeleteEC(NetTableEntry * NTE, uint Seq, BOOLEAN MatchUshort)
{
    EchoControl *Prev, *Current;
    CTELockHandle Handle;

    CTEGetLock(&NTE->nte_lock, &Handle);
    Prev = STRUCT_OF(EchoControl, &NTE->nte_echolist, ec_next);
    Current = NTE->nte_echolist;
    while (Current != (EchoControl *) NULL) {
        if (Current->ec_seq == Seq ||
            (MatchUshort && (ushort)Current->ec_seq == Seq)) {
            Prev->ec_next = Current->ec_next;
            break;
        } else {
            Prev = Current;
            Current = Current->ec_next;
        }
    }

    CTEFreeLock(&NTE->nte_lock, Handle);
    return Current;

}

//** ICMPSendComplete - Complete an ICMP send.
//
//  This rtn is called when an ICMP send completes. We free the header buffer,
//  the data buffer if there is one, and the NDIS_BUFFER chain.
//
//  Entry:  SCC         - SendCompleteContext
//          BufferChain - Pointer to NDIS_BUFFER chain.
//
//  Returns: Nothing
//
void
ICMPSendComplete(ICMPSendCompleteCtxt *SCC, PNDIS_BUFFER BufferChain, IP_STATUS SendStatus)
{
    PNDIS_BUFFER DataBuffer;
    uchar *DataPtr, Type;

    UNREFERENCED_PARAMETER(SendStatus);

    NdisGetNextBuffer(BufferChain, &DataBuffer);
    DataPtr = SCC->iscc_DataPtr;
    Type = SCC->iscc_Type;
    FreeICMPBuffer(BufferChain, Type);

    if (DataBuffer != (PNDIS_BUFFER) NULL) {    // We had data with this ICMP send.
        CTEFreeMem(DataPtr);
        NdisFreeBuffer(DataBuffer);
    }
    CTEFreeMem(SCC);
}

//** SendEcho - Send an ICMP Echo or Echo response.
//
//  This routine sends an ICMP echo or echo response. The Echo/EchoResponse may
//  carry data. If it does we'll copy the data here. The request may also have
//  options. Options are not copied, as the IPTransmit routine will copy
//  options.
//
//  Entry:  Dest        - Destination to send to.
//          Source      - Source to send from.
//          Type        - Type of request (ECHO or ECHO_RESP)
//          ID          - ID of request.
//          Seq         - Seq. # of request.
//          Data        - Pointer to data (NULL if none).
//          DataLength  - Length in bytes of data
//          OptInfo     - Pointer to IP Options structure.
//
//  Returns: IP_STATUS of request.
//
IP_STATUS
SendEcho(IPAddr Dest, IPAddr Source, uchar Type, ushort ID, uint Seq,
         IPRcvBuf * Data, uint DataLength, IPOptInfo * OptInfo)
{
    uchar *DataBuffer = (uchar *) NULL;        // Pointer to data buffer.
    PNDIS_BUFFER HeaderBuffer, Buffer;    // Buffers for our header and user data.
    ICMPHeader *Header;
    ushort header_xsum;
    IP_STATUS IpStatus;
    RouteCacheEntry *RCE;
    ushort MSS;
    uchar DestType;
    IPAddr SrcAddr;
    ICMPSendCompleteCtxt *SCC;

    ICMPOutStats.icmps_msgs++;

    DEBUGMSG(DBG_TRACE && DBG_ICMP && DBG_TX,
        (DTEXT("+SendEcho(%x, %x, %x, %x, %x, %x, %x, %x)\n"),
        Dest, Source, Type, ID, Seq, Data, DataLength, OptInfo));

    SrcAddr = OpenRCE(Dest, Source, &RCE, &DestType, &MSS, OptInfo);
    if (IP_ADDR_EQUAL(SrcAddr,NULL_IP_ADDR)) {
        //Failure, free resource and exit

        ICMPOutStats.icmps_errors++;
        if (Type == ICMP_ECHO_RESP)
            CTEInterlockedDecrementLong(&IcmpEchoPendingCnt);

        return IP_DEST_HOST_UNREACHABLE;
    }

    Header = GetICMPBuffer(sizeof(ICMPHeader), &HeaderBuffer);
    if (Header == (ICMPHeader *) NULL) {
        ICMPOutStats.icmps_errors++;
        if (Type == ICMP_ECHO_RESP)
            CTEInterlockedDecrementLong(&IcmpEchoPendingCnt);

        CloseRCE(RCE);
        return IP_NO_RESOURCES;
    }

    ASSERT(Type == ICMP_ECHO_RESP || Type == ICMP_ECHO);

    Header->ich_type = Type;
    Header->ich_code = 0;
    *(ushort *) & Header->ich_param = ID;
    *((ushort *) & Header->ich_param + 1) = (ushort)Seq;
    header_xsum = xsum(Header, sizeof(ICMPHeader));
    Header->ich_xsum = ~header_xsum;

    SCC = CTEAllocMemN(sizeof(ICMPSendCompleteCtxt), 'sICT');
    if (SCC == NULL) {
        FreeICMPBuffer(HeaderBuffer,Type);
        ICMPOutStats.icmps_errors++;
        CloseRCE(RCE);
        return IP_NO_RESOURCES;
    }
    SCC->iscc_Type = Type;
    SCC->iscc_DataPtr = NULL;

    // If there's data, get a buffer and copy it now. If we can't do this fail the request.
    if (DataLength != 0) {
        NDIS_STATUS Status;
        ulong TempXsum;
        uint BytesToCopy, CopyIndex;

        DataBuffer = CTEAllocMemN(DataLength, 'YICT');
        if (DataBuffer == (void *)NULL) {    // Couldn't get a buffer
            CloseRCE(RCE);
            FreeICMPBuffer(HeaderBuffer, Type);
            ICMPOutStats.icmps_errors++;
            CTEFreeMem(SCC);
            return IP_NO_RESOURCES;
        }

        BytesToCopy = DataLength;
        CopyIndex = 0;
        do {
            uint CopyLength;

            ASSERT(Data);
            CopyLength = MIN(BytesToCopy, Data->ipr_size);

            RtlCopyMemory(DataBuffer + CopyIndex, Data->ipr_buffer, CopyLength);
            Data = Data->ipr_next;
            CopyIndex += CopyLength;
            BytesToCopy -= CopyLength;
        } while (BytesToCopy);

        SCC->iscc_DataPtr = DataBuffer;

        NdisAllocateBuffer(&Status, &Buffer, BufferPool, DataBuffer, DataLength);
        if (Status != NDIS_STATUS_SUCCESS) {    // Couldn't get an NDIS_BUFFER

            CloseRCE(RCE);
            CTEFreeMem(DataBuffer);
            FreeICMPBuffer(HeaderBuffer, Type);
            ICMPOutStats.icmps_errors++;
            CTEFreeMem(SCC);
            return IP_NO_RESOURCES;
        }

        // Compute rest of xsum.
        TempXsum = (ulong) header_xsum + (ulong) xsum(DataBuffer, DataLength);
        TempXsum = (TempXsum >> 16) + (TempXsum & 0xffff);
        TempXsum += (TempXsum >> 16);
        Header->ich_xsum = ~(ushort) TempXsum;
        NDIS_BUFFER_LINKAGE(HeaderBuffer) = Buffer;
    }

    UpdateICMPStats(&ICMPOutStats, Type);

    OptInfo->ioi_hdrincl = 0;
    OptInfo->ioi_ucastif = 0;
    OptInfo->ioi_mcastif = 0;

#if GPC

    if (DisableUserTOS) {
        OptInfo->ioi_tos = (uchar) DefaultTOS;
    }

    if (GPCcfInfo) {
        //
        // we'll fall into here only if the GPC client is there
        // and there is at least one CF_INFO_QOS installed
        // (counted by GPCcfInfo).
        //

        GPC_STATUS status = STATUS_SUCCESS;
        struct QosCfTransportInfo TransportInfo = {0, 0};
        GPC_IP_PATTERN Pattern;
        CLASSIFICATION_HANDLE GPCHandle;

        Pattern.SrcAddr = Source;
        Pattern.DstAddr = Dest;
        Pattern.ProtocolId = PROT_ICMP;
        Pattern.gpcSrcPort = 0;
        Pattern.gpcDstPort = 0;

        Pattern.InterfaceId.InterfaceId = 0;
        Pattern.InterfaceId.LinkId = 0;

        GetIFAndLink(RCE,
                     &Pattern.InterfaceId.InterfaceId,
                     &Pattern.InterfaceId.LinkId);



        GPCHandle = 0;

        status = GpcEntries.GpcClassifyPatternHandler(
                                                     hGpcClient[GPC_CF_QOS],
                                                     GPC_PROTOCOL_TEMPLATE_IP,
                                                     &Pattern,
                                                     NULL,        // context
                                                     &GPCHandle,
                                                     0,
                                                     NULL,
                                                     FALSE);

        OptInfo->ioi_GPCHandle = (int)GPCHandle;

        //
        // Only if QOS patterns exist, we get the TOS bits out.
        //
        if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

            status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                        hGpcClient[GPC_CF_QOS],
                        OptInfo->ioi_GPCHandle,
                        FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                        (PULONG)&TransportInfo);
            //
            // It is likely that the pattern has gone by now (Removed or whatever)
            // and the handle that we are caching is INVALID.
            // We need to pull up a new handle and get the
            // TOS bit again.
            //

            if (STATUS_NOT_FOUND == status) {

                GPCHandle = 0;

                status = GpcEntries.GpcClassifyPatternHandler(
                                                      hGpcClient[GPC_CF_QOS],
                                                      GPC_PROTOCOL_TEMPLATE_IP,
                                                      &Pattern,
                                                      NULL,        // context
                                                      &GPCHandle,
                                                      0,
                                                      NULL,
                                                      FALSE);

                OptInfo->ioi_GPCHandle = (int)GPCHandle;

                //
                // Only if QOS patterns exist, we get the TOS bits out.
                //
                if (NT_SUCCESS(status)) {

                    status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                hGpcClient[GPC_CF_QOS],
                                OptInfo->ioi_GPCHandle,
                                FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                                (PULONG)&TransportInfo);
                }
            }
        }
        if (status == STATUS_SUCCESS) {
            OptInfo->ioi_tos = (OptInfo->ioi_tos & TOS_MASK) |
                               (UCHAR)TransportInfo.ToSValue;
        }
    } // if (GPCcfInfo)

#endif

    IpStatus = IPTransmit(IPProtInfo, SCC, HeaderBuffer,
                         DataLength + sizeof(ICMPHeader), Dest, Source, OptInfo, RCE,
                         PROT_ICMP,NULL);

    CloseRCE(RCE);

    if (IpStatus != IP_PENDING) {
        ICMPSendComplete(SCC, HeaderBuffer, IP_SUCCESS);
    }
    return IpStatus;
}

//** SendICMPMsg - Send an ICMP message
//
//  This is the general ICMP message sending routine, called for most ICMP
//  sends besides echo. Basically, all we do is get a buffer, format the
//  info, copy the input  header, and send the message.
//
//  Entry:  Src         - IPAddr of source.
//          Dest        - IPAddr of destination
//          Type        - Type of request.
//          Code        - Subcode of request.
//          Pointer     - Pointer value for request.
//          Data        - Pointer to data (NULL if none).
//          DataLength  - Length in bytes of data
//
//  Returns: IP_STATUS of request.
//
IP_STATUS
SendICMPMsg(IPAddr Src, IPAddr Dest, uchar Type, uchar Code, ulong Pointer,
            uchar * Data, uchar DataLength)
{
    PNDIS_BUFFER HeaderBuffer;    // Buffer for our header
    ICMPHeader *Header;
    IP_STATUS IStatus;            // Status of transmit
    IPOptInfo OptInfo;            // Options for this transmit.
    RouteCacheEntry *RCE;
    ushort MSS;
    uchar DestType;
    IPAddr SrcAddr;
    ICMPSendCompleteCtxt *SCC;



    ICMPOutStats.icmps_msgs++;

    IPInitOptions(&OptInfo);

    SrcAddr = OpenRCE(Dest,Src, &RCE, &DestType, &MSS, &OptInfo);

    if (IP_ADDR_EQUAL(SrcAddr,NULL_IP_ADDR)) {

        ICMPOutStats.icmps_errors++;
        if ((Type == ICMP_DEST_UNREACH) || (Type == ICMP_REDIRECT))
            CTEInterlockedDecrementLong(&IcmpErrPendingCnt);

        return IP_DEST_HOST_UNREACHABLE;
    }



    Header = GetICMPBuffer(sizeof(ICMPHeader) + DataLength, &HeaderBuffer);
    if (Header == (ICMPHeader *) NULL) {
        ICMPOutStats.icmps_errors++;
        if ((Type == ICMP_DEST_UNREACH) || (Type == ICMP_REDIRECT))
            CTEInterlockedDecrementLong(&IcmpErrPendingCnt);
        CloseRCE(RCE);
        return IP_NO_RESOURCES;
    }

    Header->ich_type = Type;
    Header->ich_code = Code;
    Header->ich_param = Pointer;
    if (Data)
        RtlCopyMemory(Header + 1, Data, DataLength);
    Header->ich_xsum = ~xsum(Header, sizeof(ICMPHeader) + DataLength);

    SCC = CTEAllocMemN(sizeof(ICMPSendCompleteCtxt), 'sICT');

    if (SCC == NULL) {
        ICMPOutStats.icmps_errors++;
        FreeICMPBuffer(HeaderBuffer, Type);
        CloseRCE(RCE);
        return IP_NO_RESOURCES;
    }

    SCC->iscc_Type = Type;
    SCC->iscc_DataPtr = NULL;

    UpdateICMPStats(&ICMPOutStats, Type);

#if GPC
    if (DisableUserTOS) {
        OptInfo.ioi_tos = (uchar) DefaultTOS;
    }
    if (GPCcfInfo) {

        //
        // we'll fall into here only if the GPC client is there
        // and there is at least one CF_INFO_QOS installed
        // (counted by GPCcfInfo).
        //

        GPC_STATUS status = STATUS_SUCCESS;
        struct QosCfTransportInfo TransportInfo = {0, 0};
        GPC_IP_PATTERN Pattern;
        CLASSIFICATION_HANDLE GPCHandle;

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "ICMPSend: Classifying \n"));

        Pattern.SrcAddr = Src;
        Pattern.DstAddr = Dest;
        Pattern.ProtocolId = PROT_ICMP;
        Pattern.gpcSrcPort = 0;
        Pattern.gpcDstPort = 0;

        Pattern.InterfaceId.InterfaceId = 0;
        Pattern.InterfaceId.LinkId = 0;

        GetIFAndLink(RCE,
                     &Pattern.InterfaceId.InterfaceId,
                     &Pattern.InterfaceId.LinkId);


        GPCHandle = 0;

        status = GpcEntries.GpcClassifyPatternHandler(
                                                      hGpcClient[GPC_CF_QOS],
                                                      GPC_PROTOCOL_TEMPLATE_IP,
                                                      &Pattern,
                                                      NULL,        // context
                                                      &GPCHandle,
                                                      0,
                                                      NULL,
                                                      FALSE);

        OptInfo.ioi_GPCHandle = (int)GPCHandle;

        //
        // Only if QOS patterns exist, we get the TOS bits out.
        //
        if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

            status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                        hGpcClient[GPC_CF_QOS],
                        OptInfo.ioi_GPCHandle,
                        FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                        (PULONG)&TransportInfo);

            //
            // It is likely that the pattern has gone by now (Removed or whatever)
            // and the handle that we are caching is INVALID.
            // We need to pull up a new handle and get the
            // TOS bit again.
            //

            if (STATUS_NOT_FOUND == status) {

                GPCHandle = 0;

                status = GpcEntries.GpcClassifyPatternHandler(
                                                    hGpcClient[GPC_CF_QOS],
                                                    GPC_PROTOCOL_TEMPLATE_IP,
                                                    &Pattern,
                                                    NULL,        // context
                                                    &GPCHandle,
                                                    0,
                                                    NULL,
                                                    FALSE);

                OptInfo.ioi_GPCHandle = (int)GPCHandle;

                //
                // Only if QOS patterns exist, we get the TOS bits out.
                //
                if (NT_SUCCESS(status)) {

                    status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                hGpcClient[GPC_CF_QOS],
                                OptInfo.ioi_GPCHandle,
                                FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                                (PULONG)&TransportInfo);
                }
            }
        }
        if (status == STATUS_SUCCESS) {

            OptInfo.ioi_tos = (OptInfo.ioi_tos & TOS_MASK) | 
                              (UCHAR)TransportInfo.ToSValue;

        }
    }                            // if (GPCcfInfo)

#endif

    IStatus = IPTransmit(IPProtInfo, SCC, HeaderBuffer,
                         DataLength + sizeof(ICMPHeader),
                         Dest, Src, &OptInfo, RCE,
                         PROT_ICMP,NULL);

    CloseRCE(RCE);

    if (IStatus != IP_PENDING)
        ICMPSendComplete(SCC, HeaderBuffer, IP_SUCCESS);

    return IStatus;

}

//** SendICMPErr - Send an ICMP error message
//
//  This is the routine used to send an ICMP error message, such as ]
//  Destination Unreachable. We examine the header to find the length of the
//  data, and also make sure we're not replying to another ICMP error message
//  or a broadcast message. Then we call SendICMPMsg to send it.
//
//  Entry:  Src         - IPAddr of source.
//          Header      - Pointer to IP Header that caused the problem.
//          Type        - Type of request.
//          Code        - Subcode of request.
//          Pointer     - Pointer value for request.
//          Length      - ICMP Payload length, zero if default
//                        length to be used.
//
//  Returns: IP_STATUS of request.
//
IP_STATUS
SendICMPErr(IPAddr Src, IPHeader UNALIGNED * Header, uchar Type, uchar Code,
            ulong Pointer, uchar Length)
{
    uchar HeaderLength;            // Length in bytes if header.
    uchar DType;
    uchar PayloadLength;

    HeaderLength = (Header->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;

    if (Header->iph_protocol == PROT_ICMP) {
        ICMPHeader UNALIGNED *ICH = (ICMPHeader UNALIGNED *)
        ((uchar *) Header + HeaderLength);

        if (ICH->ich_type != ICMP_ECHO)
            return IP_SUCCESS;
    }
    // Don't respond to sends to a broadcast destination.
    DType = GetAddrType(Header->iph_dest);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType))
        return IP_SUCCESS;

    // Don't respond if the source address is bad.
    DType = GetAddrType(Header->iph_src);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType) ||
        (IP_LOOPBACK(Header->iph_dest) && DType != DEST_LOCAL))
        return IP_SUCCESS;

    // Make sure the source we're sending from is good.
    if (!IP_ADDR_EQUAL(Src, NULL_IP_ADDR)) {
        if (GetAddrType(Src) != DEST_LOCAL) {
            return IP_SUCCESS;
        }
    }
    // Double check to make sure it's an initial fragment.
    if ((Header->iph_offset & IP_OFFSET_MASK) != 0)
        return IP_SUCCESS;


    if ((Type == ICMP_DEST_UNREACH) || (Type == ICMP_REDIRECT)) {

        if (IcmpErrPendingCnt > MAX_ICMP_ERR) {
            return IP_SUCCESS;
        }
        CTEInterlockedIncrementLong(&IcmpErrPendingCnt);
    }
    PayloadLength = Length;
    if (Length == 0) {
        PayloadLength = MIN(HeaderLength + 8, (uchar) (net_short(Header->iph_length)));
    }
    return SendICMPMsg(Src, Header->iph_src, Type, Code, Pointer,
                       (uchar *) Header, PayloadLength);
}

//** SendICMPIPSecErr - Send an ICMP error message related to IPSEC
//
//  This is the routine used to send an ICMP error message, such as Destination
//  Unreachable.  We examine the header to find the length of the data, and
//  also make sure we're not replying to another ICMP error message or a
//  broadcast message. Then we call SendICMPMsg to send it.
//
//  This function is essentially the same as SendICMPErr except we don't
//  verify the source address is local because the packet could be tunneled.
//
//  Entry:  Src         - IPAddr of source.
//          Header      - Pointer to IP Header that caused the problem.
//          Type        - Type of request.
//          Code        - Subcode of request.
//          Pointer     - Pointer value for request.
//
//  Returns: IP_STATUS of request.
//
IP_STATUS
SendICMPIPSecErr(IPAddr Src, IPHeader UNALIGNED * Header, uchar Type, uchar Code,
                 ulong Pointer)
{
    uchar HeaderLength;            // Length in bytes if header.
    uchar DType;

    HeaderLength = (Header->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;

    if (Header->iph_protocol == PROT_ICMP) {
        ICMPHeader UNALIGNED *ICH = (ICMPHeader UNALIGNED *)
        ((uchar *) Header + HeaderLength);

        if (ICH->ich_type != ICMP_ECHO)
            return IP_SUCCESS;
    }
    // Don't respond to sends to a broadcast destination.
    DType = GetAddrType(Header->iph_dest);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType))
        return IP_SUCCESS;

    // Don't respond if the source address is bad.
    DType = GetAddrType(Header->iph_src);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType) ||
        (IP_LOOPBACK(Header->iph_dest) && DType != DEST_LOCAL))
        return IP_SUCCESS;

    // Make sure the source we're sending from is good.
    if (IP_ADDR_EQUAL(Src, NULL_IP_ADDR))
        return IP_SUCCESS;

    // Double check to make sure it's an initial fragment.
    if ((Header->iph_offset & IP_OFFSET_MASK) != 0)
        return IP_SUCCESS;


    if ((Type == ICMP_DEST_UNREACH) || (Type == ICMP_REDIRECT)) {
        if (IcmpErrPendingCnt > MAX_ICMP_ERR) {
            return IP_SUCCESS;
        }
        CTEInterlockedIncrementLong(&IcmpErrPendingCnt);
    }

    return SendICMPMsg(Src, Header->iph_src, Type, Code, Pointer,
                       (uchar *) Header, (uchar) (HeaderLength + 8));

}

//** ICMPTimer - Timer for ICMP
//
//  This is the timer routine called periodically by global IP timer. We
//  walk through the list of pending pings, and if we find one that's timed
//  out we remove it and call the finish routine.
//
//  Entry: NTE      - Pointer to NTE being timed out.
//
//  Returns: Nothing
//
void
ICMPTimer(NetTableEntry * NTE)
{
    CTELockHandle Handle;
    EchoControl *TimeoutList = (EchoControl *) NULL;    // Timed out entries.
    EchoControl *Prev, *Current;
    ulong Now = CTESystemUpTime();

    CTEGetLock(&NTE->nte_lock, &Handle);
    Prev = STRUCT_OF(EchoControl, &NTE->nte_echolist, ec_next);
    Current = NTE->nte_echolist;
    while (Current != (EchoControl *) NULL)
        if ((Current->ec_active) && ((long)(Now - Current->ec_to) > 0)) {
            // This one's timed out.
            Prev->ec_next = Current->ec_next;
            // Link him on timed out list.
            Current->ec_next = TimeoutList;
            TimeoutList = Current;
            Current = Prev->ec_next;
        } else {
            Prev = Current;
            Current = Current->ec_next;
        }

    CTEFreeLock(&NTE->nte_lock, Handle);

    // Now go through the timed out entries, and call the completion routine.
    while (TimeoutList != (EchoControl *) NULL) {
        Current = TimeoutList;
        TimeoutList = Current->ec_next;

        Current->ec_rtn(Current, IP_REQ_TIMED_OUT, NULL, 0, NULL);
    }

    ICMPRouterTimer(NTE);

}

//* CompleteEcho - Complete an echo request.
//
//  Called when we need to complete an echo request, either because of
//  a response or a received ICMP error message. We look it up, and then
//  call the completion routine.
//
//  Input:  Header          - Pointer to ICMP header causing completion.
//          Status          - Final status of request.
//          Src             - IPAddr of source
//          Data            - Data to be returned, if any.
//          DataSize        - Size in bytes of data.
//          OptInfo         - Option info structure.
//
//  Returns: Nothing.
//
void
CompleteEcho(ICMPHeader UNALIGNED * Header, IP_STATUS Status,
             IPAddr Src, IPRcvBuf * Data, uint DataSize, IPOptInfo * OptInfo)
{
    ushort NTEContext;
    EchoControl *EC;
    NetTableEntry *NTE = NULL;
    uint i;

    // Look up and remove the matching echo control block.
    NTEContext = (*(ushort UNALIGNED *) & Header->ich_param);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next)
            if (NTEContext == NTE->nte_context)
                break;
        if (NTE != NULL)
            break;
    }

    if (NTE == NULL)
        return;                    // Bad context value.

    EC = DeleteEC(NTE, *(((ushort UNALIGNED *) & Header->ich_param) + 1), TRUE);
    if (EC != (EchoControl *) NULL) {    // Found a match.
        EC->ec_src = Src; // Set source address
        EC->ec_rtn(EC, Status, Data, DataSize, OptInfo);
    }
}

//** ICMPStatus - ICMP status handling procedure.
//
// This is the procedure called during a status change, either from an
// incoming ICMP message or a hardware status change. ICMP ignores most of
// these, unless we get an ICMP status message that was caused be an echo
// request. In that case we will complete the corresponding echo request with
// the appropriate error code.
//
//  Input:  StatusType      - Type of status (NET or HW)
//          StatusCode      - Code identifying IP_STATUS.
//          OrigDest        - If this is net status, the original dest. of DG
//                            that triggered it.
//          OrigSrc         - "   "    "  "    "   , the original src.
//          Src             - IP address of status originator (could be local
//                            or remote).
//          Param           - Additional information for status - i.e. the
//                            param field of an ICMP message.
//          Data            - Data pertaining to status - for net status, this
//                            is the first 8 bytes of the original DG.
//
//  Returns: Nothing
//
void
ICMPStatus(uchar StatusType, IP_STATUS StatusCode, IPAddr OrigDest,
           IPAddr OrigSrc, IPAddr Src, ulong Param, void *Data)
{
    UNREFERENCED_PARAMETER(OrigDest);
    UNREFERENCED_PARAMETER(OrigSrc);
    UNREFERENCED_PARAMETER(Param);


    if (StatusType == IP_NET_STATUS) {
        ICMPHeader UNALIGNED *ICH = (ICMPHeader UNALIGNED *) Data;
        // ICH is the datagram that caused the message.

        if (ICH->ich_type == ICMP_ECHO) {    // And it was an echo request.

            IPRcvBuf RcvBuf;

            RcvBuf.ipr_next = NULL;
            RcvBuf.ipr_buffer = (uchar *) & Src;
            RcvBuf.ipr_size = sizeof(IPAddr);
            RcvBuf.ipr_flags = 0;
            CompleteEcho(ICH, StatusCode, Src, &RcvBuf, sizeof(IPAddr), NULL);
        }
    }
}

//* ICMPMapStatus - Map an ICMP error to an IP status code.
//
//  Called by ICMP status when we need to map from an incoming ICMP error
//  code and type to an ICMP status.
//
//  Entry:  Type        - Type of ICMP error.
//          Code        - Subcode of error.
//
//  Returns: Corresponding IP status.
//
IP_STATUS
ICMPMapStatus(uchar Type, uchar Code)
{
    switch (Type) {

    case ICMP_DEST_UNREACH:
        switch (Code) {
        case NET_UNREACH:
        case HOST_UNREACH:
        case PROT_UNREACH:
        case PORT_UNREACH:
            return IP_DEST_UNREACH_BASE + Code;
            break;
        case FRAG_NEEDED:
            return IP_PACKET_TOO_BIG;
            break;
        case SR_FAILED:
            return IP_BAD_ROUTE;
            break;
        case DEST_NET_UNKNOWN:
        case SRC_ISOLATED:
        case DEST_NET_ADMIN:
        case NET_UNREACH_TOS:
            return IP_DEST_NET_UNREACHABLE;
            break;
        case DEST_HOST_UNKNOWN:
        case DEST_HOST_ADMIN:
        case HOST_UNREACH_TOS:
            return IP_DEST_HOST_UNREACHABLE;
            break;
        default:
            return IP_DEST_NET_UNREACHABLE;
        }
        break;
    case ICMP_TIME_EXCEED:
        if (Code == TTL_IN_TRANSIT)
            return IP_TTL_EXPIRED_TRANSIT;
        else
            return IP_TTL_EXPIRED_REASSEM;
        break;
    case ICMP_PARAM_PROBLEM:
        return IP_PARAM_PROBLEM;
        break;
    case ICMP_SOURCE_QUENCH:
        return IP_SOURCE_QUENCH;
        break;
    default:
        return IP_GENERAL_FAILURE;
        break;
    }

}

void
SendRouterSolicitation(NetTableEntry * NTE)
{
    if (NTE->nte_rtrdiscovery) {
        SendICMPMsg(NTE->nte_addr, NTE->nte_rtrdiscaddr,
                    ICMP_ROUTER_SOLICITATION, 0, 0, NULL, 0);
    }
}

//** ICMPRouterTimer - Timeout default gateway entries
//
// This is the router advertisement timeout handler. When a router
// advertisement is received, we add the routers to our default gateway
// list if applicable. We then run a timer on the entries and refresh
// the list as new advertisements are received. If we fail to hear an
// update for a router within the specified lifetime we will delete the
// route from our routing tables.
//

void
ICMPRouterTimer(NetTableEntry * NTE)
{
    CTELockHandle Handle;
    IPRtrEntry *rtrentry;
    IPRtrEntry *temprtrentry;
    IPRtrEntry *lastrtrentry = NULL;
    uint SendIt = FALSE;

    CTEGetLock(&NTE->nte_lock, &Handle);
    rtrentry = NTE->nte_rtrlist;
    while (rtrentry != NULL) {
        if (rtrentry->ire_lifetime-- == 0) {
            if (lastrtrentry == NULL) {
                NTE->nte_rtrlist = rtrentry->ire_next;
            } else {
                lastrtrentry->ire_next = rtrentry->ire_next;
            }
            temprtrentry = rtrentry;
            rtrentry = rtrentry->ire_next;
            DeleteRoute(NULL_IP_ADDR, DEFAULT_MASK,
                        temprtrentry->ire_addr, NTE->nte_if, 0);
            CTEFreeMem(temprtrentry);
        } else {
            lastrtrentry = rtrentry;
            rtrentry = rtrentry->ire_next;
        }
    }
    if (NTE->nte_rtrdisccount != 0) {
        NTE->nte_rtrdisccount--;
        if ((NTE->nte_rtrdiscstate == NTE_RTRDISC_SOLICITING) &&
            ((NTE->nte_rtrdisccount % SOLICITATION_INTERVAL) == 0)) {
            SendIt = TRUE;
        }
        if ((NTE->nte_rtrdiscstate == NTE_RTRDISC_DELAYING) &&
            (NTE->nte_rtrdisccount == 0)) {
            NTE->nte_rtrdisccount = (SOLICITATION_INTERVAL) * (MAX_SOLICITATIONS - 1);
            NTE->nte_rtrdiscstate = NTE_RTRDISC_SOLICITING;
            SendIt = TRUE;
        }
    }
    CTEFreeLock(&NTE->nte_lock, Handle);
    if (SendIt) {
        SendRouterSolicitation(NTE);
    }
}

//** ProcessRouterAdvertisement - Process a router advertisement
//
// This is the router advertisement handler. When a router advertisement
// is received, we add the routers to our default gateway list if applicable.
//

uint
ProcessRouterAdvertisement(IPAddr Src, IPAddr LocalAddr, NetTableEntry * NTE,
                           ICMPRouterAdHeader UNALIGNED * AdHeader, IPRcvBuf * RcvBuf, uint Size)
{
    uchar NumAddrs = AdHeader->irah_numaddrs;
    uchar AddrEntrySize = AdHeader->irah_addrentrysize;
    ushort Lifetime = net_short(AdHeader->irah_lifetime);
    ICMPRouterAdAddrEntry UNALIGNED *RouterAddr = (ICMPRouterAdAddrEntry UNALIGNED *) RcvBuf->ipr_buffer;
    uint i;
    CTELockHandle Handle;
    IPRtrEntry *rtrentry;
    IPRtrEntry *lastrtrentry = NULL;
    int Update = FALSE;
    int New = FALSE;
    IP_STATUS status;


    UNREFERENCED_PARAMETER(Src);
    UNREFERENCED_PARAMETER(LocalAddr);
    UNREFERENCED_PARAMETER(Size);


    if ((NumAddrs == 0) || (AddrEntrySize < 2))        // per rfc 1256

        return FALSE;

    CTEGetLock(&NTE->nte_lock, &Handle);
    for (i = 0; i < NumAddrs; i++, RouterAddr++) {
        if ((RouterAddr->irae_addr & NTE->nte_mask) != (NTE->nte_addr & NTE->nte_mask)) {
            continue;
        }
        if (!IsRouteICMP(NULL_IP_ADDR, DEFAULT_MASK, RouterAddr->irae_addr, NTE->nte_if)) {
            continue;
        }

        rtrentry = NTE->nte_rtrlist;
        while (rtrentry != NULL) {
            if (rtrentry->ire_addr == RouterAddr->irae_addr) {
                rtrentry->ire_lifetime = Lifetime * 2;
                if (rtrentry->ire_preference != RouterAddr->irae_preference) {
                    rtrentry->ire_preference = RouterAddr->irae_preference;
                    Update = TRUE;
                }
                break;
            }
            lastrtrentry = rtrentry;
            rtrentry = rtrentry->ire_next;
        }

        if (rtrentry == NULL) {
            rtrentry = (IPRtrEntry *) CTEAllocMemN(sizeof(IPRtrEntry), 'dICT');
            if (rtrentry == NULL) {
                CTEFreeLock(&NTE->nte_lock, Handle);
                return FALSE;
            }
            rtrentry->ire_next = NULL;
            rtrentry->ire_addr = RouterAddr->irae_addr;
            rtrentry->ire_preference = RouterAddr->irae_preference;
            rtrentry->ire_lifetime = Lifetime * 2;
            if (lastrtrentry == NULL) {
                NTE->nte_rtrlist = rtrentry;
            } else {
                lastrtrentry->ire_next = rtrentry;
            }
            New = TRUE;
            Update = TRUE;
        }
        if (Update && (RouterAddr->irae_preference != (long)0x00000080)) {    // per rfc 1256

            status = AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                              RouterAddr->irae_addr,
                              NTE->nte_if, NTE->nte_mss,
                              (uint) (MIN(9999, MAX(1, 1000 - net_long(RouterAddr->irae_preference)))),        // invert for metric
                               IRE_PROTO_ICMP, ATYPE_OVERRIDE, 0, 0);

            if (New && (status != IP_SUCCESS)) {

                if (lastrtrentry == NULL) {
                    NTE->nte_rtrlist = NULL;
                } else {
                    lastrtrentry->ire_next = NULL;
                }
                CTEFreeMem(rtrentry);
            }
        }
        Update = FALSE;
        New = FALSE;
    }
    CTEFreeLock(&NTE->nte_lock, Handle);

    return TRUE;
}

//** ICMPRcv - Receive an ICMP datagram.
//
//  Called by the main IP code when we receive an ICMP datagram. The action we
//  take depends on what the DG is. For some DGs, we call upper layer status
//  handlers. For Echo Requests, we call the echo responder.
//
//  Entry:  NTE            - Pointer to NTE on which ICMP message was received.
//          Dest           - IPAddr of destionation.
//          Src            - IPAddr of source
//          LocalAddr      - Local address of network which caused this to be
//                              received.
//          SrcAddr        - Address of local interface which received the
//                              packet
//          IPHdr          - Pointer to IP Header
//          IPHdrLength    - Bytes in Header.
//          RcvBuf         - ICMP message buffer.
//          Size           - Size in bytes of ICMP message.
//          IsBCast        - Boolean indicator of whether or not this came in
//                              as a bcast.
//          Protocol       - Protocol this came in on.
//          OptInfo        - Pointer to info structure for received options.
//
//  Returns: Status of reception
//
IP_STATUS
ICMPRcv(NetTableEntry * NTE, IPAddr Dest, IPAddr Src, IPAddr LocalAddr,
        IPAddr SrcAddr, IPHeader UNALIGNED * IPHdr, uint IPHdrLength,
        IPRcvBuf * RcvBuf, uint Size, uchar IsBCast, uchar Protocol,
        IPOptInfo * OptInfo)
{
    ICMPHeader UNALIGNED *Header;
    void *Data;                    // Pointer to data received.
    IPHeader UNALIGNED *IPH;    // Pointer to IP Header in error messages.
    uint HeaderLength;            // Size of IP header.
    ULStatusProc ULStatus;        // Pointer to upper layer status procedure.
    IPOptInfo NewOptInfo;
    uchar DType;
    uint PassUp = FALSE;

    uint PromiscuousMode = 0;

    DEBUGMSG(DBG_TRACE && DBG_ICMP && DBG_RX,
        (DTEXT("+ICMPRcv(%x, %x, %x, %x, %x, %x, %d, %x, %d, %x, %x, %x)\n"),
        NTE, Dest, Src, LocalAddr, SrcAddr, IPHdr, IPHdrLength,
         RcvBuf, Size, IsBCast, Protocol, OptInfo));

    ICMPInStats.icmps_msgs++;

    PromiscuousMode = NTE->nte_if->if_promiscuousmode;

    DType = GetAddrType(Src);
    if (Size < sizeof(ICMPHeader) || DType == DEST_INVALID ||
        IS_BCAST_DEST(DType) || (IP_LOOPBACK(Dest) && DType != DEST_LOCAL) ||
        XsumRcvBuf(0, RcvBuf) != (ushort) 0xffff) {
        DEBUGMSG(DBG_WARN && DBG_ICMP && DBG_RX,
            (DTEXT("ICMPRcv: Packet dropped, invalid checksum.\n")));
        ICMPInStats.icmps_errors++;
        return IP_SUCCESS;        // Bad checksum.

    }
    Header = (ICMPHeader UNALIGNED *) RcvBuf->ipr_buffer;

    RcvBuf->ipr_buffer += sizeof(ICMPHeader);
    RcvBuf->ipr_size -= sizeof(ICMPHeader);

    // Set up the data pointer for most requests, i.e. those that take less
    // than MIN_FIRST_SIZE data.

    if (Size -= sizeof(ICMPHeader))
        Data = (void *)(Header + 1);
    else
        Data = (void *)NULL;

    switch (Header->ich_type) {

    case ICMP_DEST_UNREACH:
    case ICMP_TIME_EXCEED:
    case ICMP_PARAM_PROBLEM:
    case ICMP_SOURCE_QUENCH:
    case ICMP_REDIRECT:

        if (IsBCast)
            return IP_SUCCESS;    // ICMP doesn't respond to bcast requests.

        if (Data == NULL || Size < sizeof(IPHeader)) {
            ICMPInStats.icmps_errors++;
            return IP_SUCCESS;    // No data, error.

        }
        IPH = (IPHeader UNALIGNED *) Data;
        HeaderLength = (IPH->iph_verlen & (uchar) ~ IP_VER_FLAG) << 2;
        if (HeaderLength < sizeof(IPHeader) || Size < (HeaderLength + MIN_ERRDATA_LENGTH)) {
            ICMPInStats.icmps_errors++;
            return IP_SUCCESS;    // Not enough data for this
            // ICMP message.

        }
        // Make sure that the source address of the datagram that triggered
        // the message is one of ours.

        if (GetAddrType(IPH->iph_src) != DEST_LOCAL) {
            ICMPInStats.icmps_errors++;
            return IP_SUCCESS;    // Bad src in header.

        }
        if (Header->ich_type != ICMP_REDIRECT) {

            UpdateICMPStats(&ICMPInStats, Header->ich_type);

            ULStatus = FindULStatus(IPH->iph_protocol);
            if (ULStatus) {
                (void)(*ULStatus) (IP_NET_STATUS,
                                   ICMPMapStatus(Header->ich_type, Header->ich_code),
                                   IPH->iph_dest, IPH->iph_src, Src, Header->ich_param,
                                   (uchar *) IPH + HeaderLength);
            }
            if (Header->ich_code == FRAG_NEEDED)
                RouteFragNeeded(
                                IPH,
                                (ushort) net_short(
                                                   *((ushort UNALIGNED *) & Header->ich_param + 1)));
        } else {
            ICMPInStats.icmps_redirects++;
            if (EnableICMPRedirects)
                Redirect(NTE, Src, IPH->iph_dest, IPH->iph_src,
                         Header->ich_param);
        }

        PassUp = TRUE;

        break;

    case ICMP_ECHO_RESP:
        if (IsBCast)
            return IP_SUCCESS;    // ICMP doesn't respond to bcast requests.

        ICMPInStats.icmps_echoreps++;
        // Look up and remove the matching echo control block.
        CompleteEcho(Header, IP_SUCCESS, Src, RcvBuf, Size, OptInfo);

        PassUp = TRUE;

        break;

    case ICMP_ECHO:
        if (IsBCast)
            return IP_SUCCESS;    // ICMP doesn't respond to bcast requests.

        // NKS Outstanding PINGs can not exceed MAX_ICMP_ECHO
        // else they can eat up system resource and kill the system

        if (IcmpEchoPendingCnt > MAX_ICMP_ECHO) {
            return IP_SUCCESS;
        }

        CTEInterlockedIncrementLong(&IcmpEchoPendingCnt);

        ICMPInStats.icmps_echos++;
        IPInitOptions(&NewOptInfo);
        NewOptInfo.ioi_tos = OptInfo->ioi_tos;
        NewOptInfo.ioi_flags = OptInfo->ioi_flags;

        // If we have options, we need to reverse them and update any
        // record route info. We can use the option buffer supplied by the
        // IP layer, since we're part of him.
        if (OptInfo->ioi_options != (uchar *) NULL)
            IPUpdateRcvdOptions(OptInfo, &NewOptInfo, Src, LocalAddr);

        DEBUGMSG(DBG_INFO && DBG_ICMP && DBG_RX,
            (DTEXT("ICMPRcv: responding to echo request from SA:%x\n"),
            Src));

        SendEcho(Src, LocalAddr, ICMP_ECHO_RESP,
                 *(ushort UNALIGNED *) & Header->ich_param,
                 *((ushort UNALIGNED *) & Header->ich_param + 1),
                 RcvBuf, Size, &NewOptInfo);

        IPFreeOptions(&NewOptInfo);
        break;

    case ADDR_MASK_REQUEST:

        if (!AddrMaskReply)
            return IP_SUCCESS;    // By default we dont send a reply

        ICMPInStats.icmps_addrmasks++;

        Dest = Src;
        SendICMPMsg(LocalAddr, Dest, ADDR_MASK_REPLY, 0, Header->ich_param,
                    (uchar *) & NTE->nte_mask, sizeof(IPMask));
        break;

    case ICMP_TIMESTAMP:
        {
            ulong *TimeStampData;
            ulong CurrentTime;

            // Don't respond to sends to a broadcast destination.
            if (IsBCast) {
                return IP_SUCCESS;
            }
            if (Header->ich_code != 0)
                return IP_SUCCESS;    // Code must be 0

            ICMPInStats.icmps_timestamps++;

            Dest = Src;
            // create the data to be transmited
            CurrentTime = GetTime();
            TimeStampData = (ulong *) (CTEAllocMemN(TIMESTAMP_MSG_LEN * sizeof(ulong), 'eICT'));

            if (TimeStampData) {
                // originate timestamp
                RtlCopyMemory(TimeStampData, RcvBuf->ipr_buffer, sizeof(ulong));
                // receive timestamp
                RtlCopyMemory(TimeStampData + 1, &CurrentTime, sizeof(ulong));
                // transmit timestamp = receive timestamp
                RtlCopyMemory(TimeStampData + 2, &CurrentTime, sizeof(ulong));
                SendICMPMsg(LocalAddr, Dest, ICMP_TIMESTAMP_RESP, 0, Header->ich_param,
                            (uchar *) TimeStampData, TIMESTAMP_MSG_LEN * sizeof(ulong));
                CTEFreeMem(TimeStampData);
            }
            break;
        }

    case ICMP_ROUTER_ADVERTISEMENT:
        if (Header->ich_code != 0)
            return IP_SUCCESS;    // Code must be 0 as per RFC1256

        if (NTE->nte_rtrdiscovery) {
            if (!ProcessRouterAdvertisement(Src, LocalAddr, NTE,
                                            (ICMPRouterAdHeader *) & Header->ich_param, RcvBuf, Size))
                return IP_SUCCESS;    // An error was returned

        }
        PassUp = TRUE;
        break;

    case ICMP_ROUTER_SOLICITATION:
        if (Header->ich_code != 0)
            return IP_SUCCESS;    // Code must be 0 as per RFC1256

        PassUp = TRUE;
        break;

    default:
        PassUp = TRUE;
        UpdateICMPStats(&ICMPInStats, Header->ich_type);
        break;
    }

    if (PromiscuousMode) {
        // since if promiscuous mode is set then we will anyway call rawrcv
        PassUp = FALSE;
    }
    //
    // Pass the packet up to the raw layer if applicable.
    //
    if (PassUp && (RawPI != NULL)) {
        if (RawPI->pi_rcv != NULL) {
            //
            // Restore the original values.
            //
            RcvBuf->ipr_buffer -= sizeof(ICMPHeader);
            RcvBuf->ipr_size += sizeof(ICMPHeader);
            Size += sizeof(ICMPHeader);
            Data = (void *)Header;

            (*(RawPI->pi_rcv)) (NTE, Dest, Src, LocalAddr, SrcAddr, IPHdr,
                                IPHdrLength, RcvBuf, Size, IsBCast, Protocol, OptInfo);
        }
    }
    return IP_SUCCESS;
}

//** ICMPEcho - Send an echo to the specified address.
//
// Entry:  ControlBlock    - Pointer to an EchoControl structure. This structure
//                           must remain valid until the req. completes.
//          Timeout        - Time in milliseconds to wait for response.
//          Data           - Pointer to data to send with echo.
//          DataSize       - Size in bytes of data.
//          Callback       - Routine to call when request is responded to or
//                           times out.
//          Dest           - Address to be pinged.
//          OptInfo        - Pointer to opt info structure to use for ping.
//
//  Returns: IP_STATUS of attempt to ping..
//
IP_STATUS
ICMPEcho(EchoControl * ControlBlock, ulong Timeout, void *Data, uint DataSize,

         EchoRtn Callback, IPAddr Dest, IPOptInfo * OptInfo)
{
    IPAddr Dummy;
    NetTableEntry *NTE;
    CTELockHandle Handle;
    uint Seq;
    IP_STATUS Status;
    IPOptInfo NewOptInfo;
    IPRcvBuf RcvBuf;
    uint MTU;
    Interface *IF;
    uchar DType;
    IPHeader IPH;

    if (OptInfo->ioi_ttl == 0) {
        return IP_BAD_OPTION;
    }

    IPInitOptions(&NewOptInfo);
    NewOptInfo.ioi_ttl = OptInfo->ioi_ttl;
    NewOptInfo.ioi_flags = OptInfo->ioi_flags;
    NewOptInfo.ioi_tos = OptInfo->ioi_tos & 0xfe;

    if (OptInfo->ioi_optlength != 0) {
        Status = IPCopyOptions(OptInfo->ioi_options, OptInfo->ioi_optlength,
                               &NewOptInfo);

        if (Status != IP_SUCCESS)
            return Status;
    }
    if (!IP_ADDR_EQUAL(NewOptInfo.ioi_addr, NULL_IP_ADDR)) {
        Dest = NewOptInfo.ioi_addr;
    }

    DType = GetAddrType(Dest);
    if (DType == DEST_INVALID) {
        IPFreeOptions(&NewOptInfo);
        return IP_BAD_DESTINATION;
    }
    IPH.iph_protocol = 1;
    IPH.iph_xsum = 0;
    IPH.iph_dest = Dest;
    IPH.iph_src = 0;
    IPH.iph_ttl = 128;

    IF = LookupNextHopWithBuffer(Dest, NULL_IP_ADDR, &Dummy, &MTU, 0x1,
            (uchar *) &IPH, sizeof(IPHeader), NULL, NULL, NULL_IP_ADDR, 0);
    if (IF == NULL) {
        IPFreeOptions(&NewOptInfo);
        return IP_DEST_HOST_UNREACHABLE;    // Don't know how to get there.
    }

    // Loop through the NetTable, looking for a matching NTE.
    CTEGetLock(&RouteTableLock.Lock, &Handle);
    if (DHCPActivityCount != 0) {
        NTE = NULL;
    } else {
        NTE = BestNTEForIF(Dummy, IF, FALSE);
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    // We're done with the interface, so dereference it.
    DerefIF(IF);

    if (NTE == NULL) {
        IPFreeOptions(&NewOptInfo);
        return IP_DEST_HOST_UNREACHABLE;
    }

    // Figure out the timeout.
    ControlBlock->ec_to = CTESystemUpTime() + Timeout;
    ControlBlock->ec_rtn = Callback;
    ControlBlock->ec_active = 0;    // Prevent from timing out until sent

    CTEGetLock(&NTE->nte_lock, &Handle);
    // Link onto ping list, and get seq. # */
    Seq = ++NTE->nte_icmpseq;
    ControlBlock->ec_seq = Seq;
    ControlBlock->ec_next = NTE->nte_echolist;
    NTE->nte_echolist = ControlBlock;
    CTEFreeLock(&NTE->nte_lock, Handle);

    //
    // N.B. At this point, it is only safe to return IP_PENDING from this
    // routine.  This is because we may recieve a spoofed ICMP reply/status
    // which matches the Seq in the echo control block we just linked.  If
    // this happens, it will be completed via CompleteEcho and we do not
    // want to risk double-completion by returning anything other than
    // pending from here on.
    //

    RcvBuf.ipr_next = NULL;
    RcvBuf.ipr_buffer = Data;
    RcvBuf.ipr_size = DataSize;
    RcvBuf.ipr_flags = 0;

    Status = SendEcho(Dest, NTE->nte_addr, ICMP_ECHO, NTE->nte_context,
                      Seq, &RcvBuf, DataSize, &NewOptInfo);

    IPFreeOptions(&NewOptInfo);

    if (Status != IP_PENDING && Status != IP_SUCCESS) {
        EchoControl *FoundEC;
        // We had an error on the send.  We need to complete the request
        // but only if it has not already been completed.  (We can get
        // an "error" via IpSec negotiating security, but the reply may
        // have already been received which would cause CompleteEcho to be
        // invoked.  Therefore, we must lookup the echo control by sequence
        // number and only complete it here if it was found (not already
        // completed.)
        FoundEC = DeleteEC(NTE, Seq, FALSE);
        if (FoundEC == ControlBlock) {
            FoundEC->ec_rtn(FoundEC, Status, NULL, 0, NULL);
        }
    } else {
        EchoControl *Current;

        // If the request is still pending, activate the timer
        CTEGetLock(&NTE->nte_lock, &Handle);
        for (Current = NTE->nte_echolist; Current != (EchoControl *) NULL;
            Current = Current->ec_next) {
            if (Current->ec_seq == Seq) {
                Current->ec_active = 1;    // start the timer
                break;
            }
        }
        CTEFreeLock(&NTE->nte_lock, Handle);
    }

    return IP_PENDING;
}

//** ICMPEchoRequest - Common dispatch routine for echo requests
//
//  This is the routine called by the OS-specific code on behalf of a user to
//  issue an echo request.
//
//  Entry:  InputBuffer       - Pointer to an ICMP_ECHO_REQUEST structure.
//          InputBufferLength - Size in bytes of the InputBuffer.
//          ControlBlock      - Pointer to an EchoControl structure. This
//                                structure must remain valid until the
//                                request completes.
//          Callback        - Routine to call when request is responded to
//                                or times out.
//
//  Returns: IP_STATUS of attempt to ping.
//
IP_STATUS
ICMPEchoRequest(void *InputBuffer, uint InputBufferLength,
                EchoControl *ControlBlock, EchoRtn Callback)
{
    PICMP_ECHO_REQUEST requestBuffer;
    struct IPOptInfo optionInfo;
    IP_STATUS status;

    PAGED_CODE();

    requestBuffer = (PICMP_ECHO_REQUEST) InputBuffer;

    //
    // Validate the request.
    //
    if (InputBufferLength < sizeof(ICMP_ECHO_REQUEST)) {
        status = IP_BUF_TOO_SMALL;
        goto common_echo_exit;
    } else if (InputBufferLength > MAXLONG) {
        status = IP_NO_RESOURCES;
        goto common_echo_exit;
    }
    if (requestBuffer->DataSize > 0) {

        if ((requestBuffer->DataOffset < sizeof(ICMP_ECHO_REQUEST)) ||
            (((UINT) requestBuffer->DataOffset +
                requestBuffer->DataSize) > InputBufferLength)) {
            status = IP_GENERAL_FAILURE;
            goto common_echo_exit;
        }
    }
    if (requestBuffer->OptionsSize > 0) {

        if ((requestBuffer->OptionsOffset < sizeof(ICMP_ECHO_REQUEST)) ||
            (((UINT) requestBuffer->OptionsOffset + 
                requestBuffer->OptionsSize) > InputBufferLength)) {
            status = IP_GENERAL_FAILURE;
            goto common_echo_exit;
        }
    }
    RtlZeroMemory(&optionInfo, sizeof(IPOptInfo));
    //
    // Copy the options to a local structure.
    //
    if (requestBuffer->OptionsValid) {
        optionInfo.ioi_optlength = requestBuffer->OptionsSize;

        if (requestBuffer->OptionsSize > 0) {
            optionInfo.ioi_options = ((uchar *) requestBuffer) +
                requestBuffer->OptionsOffset;
        } else {
            optionInfo.ioi_options = NULL;
        }
        optionInfo.ioi_addr = 0;
        optionInfo.ioi_ttl = requestBuffer->Ttl;
        optionInfo.ioi_tos = requestBuffer->Tos;
        optionInfo.ioi_flags = requestBuffer->Flags;
        optionInfo.ioi_flags &= ~IP_FLAG_IPSEC;

    } else {
        optionInfo.ioi_optlength = 0;
        optionInfo.ioi_options = NULL;
        optionInfo.ioi_addr = 0;
        optionInfo.ioi_ttl = DEFAULT_TTL;
        optionInfo.ioi_tos = 0;
        optionInfo.ioi_flags = 0;
    }

    status = ICMPEcho(
                      ControlBlock,
                      requestBuffer->Timeout,
                      ((uchar *) requestBuffer) + requestBuffer->DataOffset,
                      requestBuffer->DataSize,
                      Callback,
                      (IPAddr) requestBuffer->Address,
                      &optionInfo);

  common_echo_exit:

    return (status);

} // ICMPEchoRequest

//** ICMPEchoComplete - Common completion routine for echo requests
//
//  This is the routine is called by the OS-specific code to process an
//  ICMP echo response.
//
//  Entry:  OutputBuffer       - Pointer to an ICMP_ECHO_REPLY structure.
//          OutputBufferLength - Size in bytes of the OutputBuffer.
//          Status             - The status of the reply.
//          Data               - The reply data (may be NULL).
//          DataSize           - The amount of reply data.
//          OptionInfo         - A pointer to the reply options
//
//  Returns: The number of bytes written to the output buffer
//
ulong
ICMPEchoComplete(EchoControl * ControlBlock, IP_STATUS Status, void *Data,
                 uint DataSize, struct IPOptInfo * OptionInfo)
{
    PICMP_ECHO_REPLY    replyBuffer;
    IPRcvBuf            *dataBuffer;
    uchar               *replyData;
    uchar               *replyOptionsData;
    uchar               optionsLength;
    uchar               *tmp;
    ulong               bytesReturned = sizeof(ICMP_ECHO_REPLY);

    replyBuffer = (PICMP_ECHO_REPLY)ControlBlock->ec_replybuf;
    dataBuffer = (IPRcvBuf *)Data;

    if (OptionInfo != NULL) {
        optionsLength = OptionInfo->ioi_optlength;
    } else {
        optionsLength = 0;
    }

    //
    // Initialize the reply buffer
    //
    replyBuffer->Options.OptionsSize = 0;
    replyBuffer->Options.OptionsData = (PUCHAR)(replyBuffer + 1);
    replyBuffer->DataSize = 0;
    replyBuffer->Data = replyBuffer->Options.OptionsData;

    replyOptionsData = (uchar*)(replyBuffer + 1);
    replyData = replyOptionsData;

    if ((Status != IP_SUCCESS) && (DataSize == 0)) {
        //
        // Timed out or internal error.
        //
        replyBuffer->Reserved = 0;    // indicate no replies.

        replyBuffer->Status = Status;
    } else {
        if (Status != IP_SUCCESS) {
            //
            // A message other than an echo reply was received.
            // The IP Address of the system that reported the error is
            // in the data buffer. There is no other data.
            //
            ASSERT(dataBuffer->ipr_size == sizeof(IPAddr));

            RtlCopyMemory(&(replyBuffer->Address), dataBuffer->ipr_buffer,
                          sizeof(IPAddr));

            DataSize = 0;
            dataBuffer = NULL;
        } else {
            // If there were no timeouts or errors, store the source
            // address in the reply buffer.
            //
            replyBuffer->Address = ControlBlock->ec_src;
        }

        //
        // Check that the reply buffer is large enough to hold all the data.
        //
        if (ControlBlock->ec_replybuflen <
            (sizeof(ICMP_ECHO_REPLY) + DataSize + optionsLength)) {
            //
            // Not enough space to hold the reply.
            //
            replyBuffer->Reserved = 0;    // indicate no replies

            replyBuffer->Status = IP_BUF_TOO_SMALL;
        } else {
            LARGE_INTEGER Now, Freq;

            replyBuffer->Reserved = 1;    // indicate one reply
            replyBuffer->Status = Status;

            Now = KeQueryPerformanceCounter(&Freq);
            replyBuffer->RoundTripTime = (uint)
                ((1000 * (Now.QuadPart - ControlBlock->ec_starttime.QuadPart))
                            / Freq.QuadPart);

            //
            // Copy the reply options.
            //
            if (OptionInfo != NULL) {
                replyBuffer->Options.Ttl = OptionInfo->ioi_ttl;
                replyBuffer->Options.Tos = OptionInfo->ioi_tos;
                replyBuffer->Options.Flags = OptionInfo->ioi_flags;
                replyBuffer->Options.OptionsSize = optionsLength;

                if (optionsLength > 0) {

                    RtlCopyMemory(replyOptionsData,
                                  OptionInfo->ioi_options, optionsLength);
                }
            }

            //
            // Copy the reply data
            //
            replyBuffer->DataSize = (ushort) DataSize;
            replyData = replyOptionsData + replyBuffer->Options.OptionsSize;

            if (DataSize > 0) {
                uint bytesToCopy;

                ASSERT(Data != NULL);

                tmp = replyData;

                while (DataSize) {
                    ASSERT(dataBuffer != NULL);

                    bytesToCopy =
                        (DataSize > dataBuffer->ipr_size)
                            ? dataBuffer->ipr_size : DataSize;

                    RtlCopyMemory(tmp, dataBuffer->ipr_buffer, bytesToCopy);

                    tmp += bytesToCopy;
                    DataSize -= bytesToCopy;
                    dataBuffer = dataBuffer->ipr_next;
                }
            }
            bytesReturned += replyBuffer->DataSize + optionsLength;

            //
            // Convert the kernel-mode pointers to offsets from start of reply
            // buffer.
            //
            replyBuffer->Options.OptionsData =
                (PUCHAR)((ULONG_PTR)replyOptionsData - (ULONG_PTR)replyBuffer);

            replyBuffer->Data =
                (PVOID)((ULONG_PTR)replyData - (ULONG_PTR)replyBuffer);
        }
    }

    return (bytesReturned);
}

#if defined(_WIN64)

//** ICMPEchoComplete32 - common completion routine for 32-bit client requests.
//
//  This is the routine called by the OS-specific request handler to complete
//  processing of an ICMP echo-request issued by a 32-bit client on Win64.
//
//  Entry:  see ICMPEchoComplete.
//
//  Returns:    see ICMPEchoComplete.
//
ulong
ICMPEchoComplete32(EchoControl * ControlBlock, IP_STATUS Status, void *Data,
                   uint DataSize, struct IPOptInfo * OptionInfo)
{
    PICMP_ECHO_REPLY32  replyBuffer;
    IPRcvBuf            *dataBuffer;
    uchar               *replyData;
    uchar               *replyOptionsData;
    uchar               optionsLength;
    uchar               *tmp;
    ulong               bytesReturned = sizeof(ICMP_ECHO_REPLY32);

    replyBuffer = (PICMP_ECHO_REPLY32)ControlBlock->ec_replybuf;
    dataBuffer = (IPRcvBuf *)Data;

    if (OptionInfo != NULL) {
        optionsLength = OptionInfo->ioi_optlength;
    } else {
        optionsLength = 0;
    }

    //
    // Initialize the reply buffer
    //
    replyBuffer->Options.OptionsSize = 0;

#pragma warning(push)
#pragma warning(disable:4305) // truncation to UCHAR *
    replyBuffer->Options.OptionsData = (UCHAR* POINTER_32)(replyBuffer + 1);
#pragma warning(pop)

    replyBuffer->DataSize = 0;
    replyBuffer->Data = replyBuffer->Options.OptionsData;

    replyOptionsData = (uchar*)(replyBuffer + 1);
    replyData = replyOptionsData;

    if ((Status != IP_SUCCESS) && (DataSize == 0)) {
        //
        // Timed out or internal error.
        //
        replyBuffer->Reserved = 0;    // indicate no replies.

        replyBuffer->Status = Status;
    } else {
        if (Status != IP_SUCCESS) {
            //
            // A message other than an echo reply was received.
            // The IP Address of the system that reported the error is
            // in the data buffer. There is no other data.
            //
            ASSERT(dataBuffer->ipr_size == sizeof(IPAddr));

            RtlCopyMemory(&(replyBuffer->Address), dataBuffer->ipr_buffer,
                          sizeof(IPAddr));

            DataSize = 0;
            dataBuffer = NULL;
        } else {
            // If there were no timeouts or errors, store the source
            // address in the reply buffer.
            //
            replyBuffer->Address = ControlBlock->ec_src;
        }

        //
        // Check that the reply buffer is large enough to hold all the data.
        //
        if (ControlBlock->ec_replybuflen <
            (sizeof(ICMP_ECHO_REPLY32) + DataSize + optionsLength)) {
            //
            // Not enough space to hold the reply.
            //
            replyBuffer->Reserved = 0;    // indicate no replies

            replyBuffer->Status = IP_BUF_TOO_SMALL;
        } else {
            LARGE_INTEGER Now, Freq;

            replyBuffer->Reserved = 1;    // indicate one reply
            replyBuffer->Status = Status;

            Now = KeQueryPerformanceCounter(&Freq);
            replyBuffer->RoundTripTime = (uint)
                ((1000 * (Now.QuadPart - ControlBlock->ec_starttime.QuadPart))
                            / Freq.QuadPart);

            //
            // Copy the reply options.
            //
            if (OptionInfo != NULL) {
                replyBuffer->Options.Ttl = OptionInfo->ioi_ttl;
                replyBuffer->Options.Tos = OptionInfo->ioi_tos;
                replyBuffer->Options.Flags = OptionInfo->ioi_flags;
                replyBuffer->Options.OptionsSize = optionsLength;

                if (optionsLength > 0) {

                    RtlCopyMemory(replyOptionsData,
                                  OptionInfo->ioi_options, optionsLength);
                }
            }

            //
            // Copy the reply data
            //
            replyBuffer->DataSize = (ushort) DataSize;
            replyData = replyOptionsData + replyBuffer->Options.OptionsSize;

            if (DataSize > 0) {
                uint bytesToCopy;

                ASSERT(Data != NULL);

                tmp = replyData;

                while (DataSize) {
                    ASSERT(dataBuffer != NULL);

                    bytesToCopy =
                        (DataSize > dataBuffer->ipr_size)
                            ? dataBuffer->ipr_size : DataSize;

                    RtlCopyMemory(tmp, dataBuffer->ipr_buffer, bytesToCopy);

                    tmp += bytesToCopy;
                    DataSize -= bytesToCopy;
                    dataBuffer = dataBuffer->ipr_next;
                }
            }
            bytesReturned += replyBuffer->DataSize + optionsLength;

            //
            // Convert the kernel-mode pointers to offsets from start of reply
            // buffer.
            //
#pragma warning(push)
#pragma warning(disable:4305) // truncation from 'ULONG_PTR' to 'UCHAR *'/void *
            replyBuffer->Options.OptionsData =
                (UCHAR * POINTER_32)
                ((ULONG_PTR)replyOptionsData - (ULONG_PTR)replyBuffer);

            replyBuffer->Data =
                (VOID * POINTER_32)
                    ((ULONG_PTR)replyData - (ULONG_PTR)replyBuffer);
#pragma warning(pop)
        }
    }

    return (bytesReturned);
}

#endif // _WIN64

#pragma BEGIN_INIT
//** ICMPInit - Initialize ICMP.
//
//  This routine initializes ICMP. All we do is allocate and link up some header buffers,
/// and register our protocol with IP.
//
//  Entry:  NumBuffers  - Number of ICMP buffers to allocate.
//
//  Returns: Nothing
//
void
ICMPInit(uint NumBuffers)
{
    UNREFERENCED_PARAMETER(NumBuffers);


    IcmpHeaderPool = MdpCreatePool(BUFSIZE_ICMP_HEADER_POOL, 'chCT');

    IPRegisterProtocol(PROT_ICMP, ICMPRcv, ICMPSendComplete, ICMPStatus, NULL, NULL, NULL);
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\igmp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  igmp.c - IP multicast routines.

Abstract:

  This file contains all the routines related to the Internet Group Management
  Protocol (IGMP).

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:
    Feb. 2000 - upgraded to IGMPv3  (DThaler)

--*/

#include "precomp.h"
#include "mdlpool.h"
#include "igmp.h"
#include "icmp.h"
#include "ipxmit.h"
#include "iproute.h"

#if GPC
#include "qos.h"
#include "traffic.h"
#include "gpcifc.h"
#include "ntddtc.h"

extern GPC_HANDLE hGpcClient[];
extern ULONG GpcCfCounts[];

extern GPC_EXPORTED_CALLS GpcEntries;
extern ULONG GPCcfInfo;
#endif

extern uint DisableUserTOS;
extern uint DefaultTOS;

#define IGMP_QUERY          0x11    // Membership query
#define IGMP_REPORT_V1      0x12    // Version 1 membership report
#define IGMP_REPORT_V2      0x16    // Version 2 membership report
#define IGMP_LEAVE          0x17    // Leave Group
#define IGMP_REPORT_V3      0x22    // Version 3 membership report

// IGMPv3 Group Record Types
#define MODE_IS_INCLUDE        1
#define MODE_IS_EXCLUDE        2
#define CHANGE_TO_INCLUDE_MODE 3
#define CHANGE_TO_EXCLUDE_MODE 4
#define ALLOW_NEW_SOURCES      5
#define BLOCK_OLD_SOURCES      6

#define ALL_HOST_MCAST      0x010000E0
#define IGMPV3_RTRS_MCAST   0x160000E0

#define UNSOLICITED_REPORT_INTERVAL 2 // used when sending a report after a
                                      // mcast group has been added.  The
                                      // report is sent at a interval of
                                      // 0 msecs to 1 sec.  IGMPv3 spec
                                      // changed this from previous value
                                      // of 10 seconds (value 20)

#define DEFAULT_ROBUSTNESS  2
#define MAX_ROBUSTNESS      7

static uchar g_IgmpRobustness = DEFAULT_ROBUSTNESS;

//
//  The following values are used to initialize counters that keep time in
//  1/2 a sec.
//
#define DEFAULT_QUERY_RESP_INTERVAL 100 // 10 seconds, note different units from other defines

#define DEFAULT_QUERY_INTERVAL      250     // 125 secs, per spec

// Macro to test whether a source passes the network-layer filter
#define IS_SOURCE_ALLOWED(Grp, Src) \
     (((Src)->isa_xrefcnt != (Grp)->iga_grefcnt) || ((Src)->isa_irefcnt != 0))

// Macro to test whether a group should pass the link-layer filter
#define IS_GROUP_ALLOWED(Grp) \
    (BOOLEAN) (((Grp)->iga_grefcnt != 0) || ((Grp)->iga_srclist != NULL))

#define IS_SOURCE_DELETABLE(Src) \
    (((Src)->isa_irefcnt == 0) && ((Src)->isa_xrefcnt == 0) \
     && ((Src)->isa_xmitleft==0) && ((Src)->isa_csmarked == 0))

#define IS_GROUP_DELETABLE(Grp) \
    (!IS_GROUP_ALLOWED(Grp) && ((Grp)->iga_xmitleft == 0) \
     && ((Grp)->iga_resptimer == 0))

int RandomValue;
int Seed;

// Structure of an IGMPv1/v2 header.
typedef struct IGMPHeader {
    uchar igh_vertype;         //  Type of igmp message
    uchar igh_rsvd;            // max. resp. time for igmpv2 query;
                               // max. resp. code for igmpv3 query;
                               // will be 0 for other messages
    ushort igh_xsum;
    IPAddr igh_addr;
} IGMPHeader;


#pragma warning(push)
#pragma warning(disable:4200)

typedef struct IGMPv3GroupRecord {
    uchar  igr_type;
    uchar  igr_datalen;
    ushort igr_numsrc;
    IPAddr igr_addr;
    IPAddr igr_srclist[0];
} IGMPv3GroupRecord;

#pragma warning(pop)


#define RECORD_SIZE(numsrc, datalen) (sizeof(IGMPv3GroupRecord) + (numsrc) * sizeof(IPAddr) + (datalen * sizeof(ulong)))

typedef struct IGMPv3RecordQueueEntry {
    struct IGMPv3RecordQueueEntry *i3qe_next;
    IGMPv3GroupRecord             *i3qe_buff;
    uint                           i3qe_size;
} IGMPv3RecordQueueEntry;

typedef struct IGMPReportQueueEntry {
    struct IGMPReportQueueEntry   *iqe_next;
    IGMPHeader                    *iqe_buff;
    uint                           iqe_size;
    IPAddr                         iqe_dest;
} IGMPReportQueueEntry;

typedef struct IGMPv3ReportHeader {
    uchar  igh_vertype;         //  Type of igmp message
    uchar  igh_rsvd;
    ushort igh_xsum;
    ushort igh_rsvd2;
    ushort igh_numrecords;
} IGMPv3ReportHeader;


#pragma warning(push)
#pragma warning(disable:4200) // nonstandard extension used: zero sized array

typedef struct IGMPv3QueryHeader {
    uchar igh_vertype;         //  Type of igmp message
    union {
        uchar igh_maxresp;     // will be 0 for igmpv1 messages
        struct {
            uchar igh_mrcmant : 4;  // MaxRespCode mantissa
            uchar igh_mrcexp  : 3;  // MaxRespCode exponent
            uchar igh_mrctype : 1;  // MaxRespCode type
        };
    };
    ushort igh_xsum;
    IPAddr igh_addr;

    uchar  igh_qrv   : 3;
    uchar  igh_s     : 1;
    uchar  igh_rsvd2 : 4;

    uchar  igh_qqic;
    ushort igh_numsrc;
    IPAddr igh_srclist[0];
} IGMPv3QueryHeader;

#pragma warning(pop)


#define IGMPV3_QUERY_SIZE(NumSrc) \
    (sizeof(IGMPv3QueryHeader) + (NumSrc) * sizeof(IPAddr))

#define TOTAL_HEADER_LENGTH \
    (sizeof(IPHeader) + ROUTER_ALERT_SIZE + sizeof(IGMPv3ReportHeader))

#define RECORD_MTU(NTE)  \
    (4 * (((NTE)->nte_if->if_mtu - TOTAL_HEADER_LENGTH) / 4))

typedef struct IGMPBlockStruct {
    struct IGMPBlockStruct *ibs_next;
    CTEBlockStruc ibs_block;
} IGMPBlockStruct;

void *IGMPProtInfo;

IGMPBlockStruct *IGMPBlockList;
uchar IGMPBlockFlag;

extern BOOLEAN CopyToNdisSafe(PNDIS_BUFFER DestBuf, PNDIS_BUFFER * ppNextBuf,
                              uchar * SrcBuf, uint Size, uint * StartOffset);
extern NDIS_HANDLE BufferPool;

DEFINE_LOCK_STRUCTURE(IGMPLock)
extern ProtInfo *RawPI;            // Raw IP protinfo

//
// the global address for unnumbered interfaces
//

extern IPAddr g_ValidAddr;

extern IP_STATUS IPCopyOptions(uchar *, uint, IPOptInfo *);
extern void IPInitOptions(IPOptInfo *);
extern void *IPRegisterProtocol(uchar Protocol, void *RcvHandler,
                                void *XmitHandler, void *StatusHandler,
                                void *RcvCmpltHandler, void *PnPHandler,
                                void *ElistHandler);

uint IGMPInit(void);

//
// All of the init code can be discarded
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IGMPInit)
#endif // ALLOC_PRAGMA


//** GetIGMPBuffer - Get an IGMP buffer, and allocate an NDIS_BUFFER that maps it.
//
//  A routine to allocate an IGMP buffer and map an NDIS_BUFFER to it.
//
//  Entry:  Size    - Size in bytes header buffer should be mapped as.
//          Buffer  - Pointer to pointer to NDIS_BUFFER to return.
//
//  Returns: Pointer to IGMP buffer if allocated, or NULL.
//
__inline
IGMPHeader *
GetIGMPBuffer(uint Size, PNDIS_BUFFER *Buffer)
{
    IGMPHeader *Header;

    ASSERT(Size);
    ASSERT(Buffer);

    *Buffer = MdpAllocate(IcmpHeaderPool, &Header);

    if (*Buffer) {
        NdisAdjustBufferLength(*Buffer, Size);

        // Reserve room for the IP Header.
        //
        Header = (IGMPHeader *)((uchar *)Header + sizeof(IPHeader));
    }

    return Header;
}

//** FreeIGMPBuffer - Free an IGMP buffer.
//
//  This routine puts an IGMP buffer back on our free list.
//
//  Entry:  Buffer      - Pointer to NDIS_BUFFER to be freed.
//          Type        - IGMP header type
//
//  Returns: Nothing.
//
__inline
void
FreeIGMPBuffer(PNDIS_BUFFER Buffer)
{

    MdpFree(Buffer);
}


//** IGMPSendComplete - Complete an IGMP send.
//
//  This rtn is called when an IGMP send completes. We free the header buffer,
//  the data buffer if there is one, and the NDIS_BUFFER chain.
//
//  Entry:  DataPtr     - Pointer to data buffer, if any.
//          BufferChain - Pointer to NDIS_BUFFER chain.
//
//  Returns: Nothing
//
void
IGMPSendComplete(void *DataPtr, PNDIS_BUFFER BufferChain, IP_STATUS SendStatus)
{
    PNDIS_BUFFER DataBuffer;

    UNREFERENCED_PARAMETER(SendStatus);

    NdisGetNextBuffer(BufferChain, &DataBuffer);
    FreeIGMPBuffer(BufferChain);

    if (DataBuffer != (PNDIS_BUFFER) NULL) {    // We had data with this IGMP send.
        CTEFreeMem(DataPtr);
        NdisFreeBuffer(DataBuffer);
    }
}



//* IGMPRandomTicks - Generate a random value of timer ticks.
//
//  A random number routine to generate a random number of timer ticks,
//  between 1 and time (in units of half secs) passed. The random number
//  algorithm is adapted from the book 'System Simulation' by Geoffrey Gordon.
//
//  Input:  Nothing.
//
//  Returns: A random value between 1 and TimeDelayInHalfSec.
//
uint
IGMPRandomTicks(
    IN uint TimeDelayInHalfSec)
{

    RandomValue = RandomValue * 1220703125;

    if (RandomValue < 0) {
        RandomValue += 2147483647;    // inefficient, but avoids warnings.

        RandomValue++;
    }
    // Not sure if RandomValue can get to 0, but if it does the algorithm
    // degenerates, so fix this if it happens.
    if (RandomValue == 0)
        RandomValue = ((Seed + (int)CTESystemUpTime()) % 100000000) | 1;

    return (uint) (((uint) RandomValue % TimeDelayInHalfSec) + 1);
}


//////////////////////////////////////////////////////////////////////////////
// Routines accessing group entries
//////////////////////////////////////////////////////////////////////////////

//* FindIGMPAddr - Find an mcast entry on an NTE.
//
//      Called to search an NTE for an IGMP entry for a given multicast address.
//      We walk down the chain on the NTE looking for it. If we find it,
//      we return a pointer to it and the one immediately preceding it. If we
//      don't find it we return NULL. We assume the caller has taken the lock
//      on the NTE before calling us.
//
//      Input:  NTE             - NTE on which to search.
//              Addr            - Class D address to find.
//              PrevPtr         - Where to return pointer to preceding entry.
//
//      Returns: Pointer to matching IGMPAddr structure if found, or NULL if not
//               found.
//
IGMPAddr *
FindIGMPAddr(
    IN  NetTableEntry *NTE,
    IN  IPAddr         Addr,
    OUT IGMPAddr     **PrevPtr OPTIONAL)
{
    int bucket;
    IGMPAddr *Current, *Temp;
    IGMPAddr **AddrPtr;

    AddrPtr = NTE->nte_igmplist;

    if (AddrPtr != NULL) {
        bucket = IGMP_HASH(Addr);
        Temp = STRUCT_OF(IGMPAddr, &AddrPtr[bucket], iga_next);
        Current = AddrPtr[bucket];

        while (Current != NULL) {
            if (IP_ADDR_EQUAL(Current->iga_addr, Addr)) {
                // Found a match, so return it.
                if (PrevPtr) {
                    *PrevPtr = Temp;
                }
                return Current;
            }
            Temp = Current;
            Current = Current->iga_next;
        }
    }
    return NULL;
}

//* CreateIGMPAddr - Allocate memory and link the new IGMP address in
//
// Input:  NTE      - NetTableEntry to add group on
//         Addr     - Group address to add
//
// Output: pAddrPtr - group entry added
//         pPrevPtr - previous group entry
//
// Assumes caller holds lock on NTE.
//
IP_STATUS
CreateIGMPAddr(
    IN  NetTableEntry *NTE,
    IN  IPAddr         Addr,
    OUT IGMPAddr     **pAddrPtr,
    OUT IGMPAddr     **pPrevPtr)
{
    int       bucket;
    IGMPAddr *AddrPtr;

    // If this is not a multicast address, fail the request.
    if (!CLASSD_ADDR(Addr)) {
        return IP_BAD_REQ;
    }

    AddrPtr = CTEAllocMemN(sizeof(IGMPAddr), 'yICT');
    if (AddrPtr == NULL) {
        return IP_NO_RESOURCES;
    }

    // See if we added it succesfully. If we did, fill in
    // the structure and link it in.

    CTEMemSet(AddrPtr, 0, sizeof(IGMPAddr));
    AddrPtr->iga_addr = Addr;

    // check whether the hash table has been allocated
    if (NTE->nte_igmpcount == 0) {
        NTE->nte_igmplist = CTEAllocMemN(IGMP_TABLE_SIZE * sizeof(IGMPAddr *),
                                         'VICT');
        if (NTE->nte_igmplist) {
            CTEMemSet(NTE->nte_igmplist, 0,
                      IGMP_TABLE_SIZE * sizeof(IGMPAddr *));
        }
    }

    if (NTE->nte_igmplist == NULL) {
        // Alloc failure. Free the memory and fail the request.
        CTEFreeMem(AddrPtr);
        return IP_NO_RESOURCES;
    }

    NTE->nte_igmpcount++;
    bucket = IGMP_HASH(Addr);
    AddrPtr->iga_next = NTE->nte_igmplist[bucket];
    NTE->nte_igmplist[bucket] = AddrPtr;

    *pAddrPtr = AddrPtr;
    *pPrevPtr = STRUCT_OF(IGMPAddr, &NTE->nte_igmplist[bucket], iga_next);

    return IP_SUCCESS;
}

//* FindOrCreateIGMPAddr - Find or create a group entry
//
// Input:  NTE      - NetTableEntry to add group on
//         Addr     - Group address to add
//
// Output: pGrp     - group entry found or added
//         pPrevGrp - previous group entry
//
// Assumes caller holds lock on NTE
IP_STATUS
FindOrCreateIGMPAddr(
    IN  NetTableEntry *NTE,
    IN  IPAddr         Addr,
    OUT IGMPAddr     **pGrp,
    OUT IGMPAddr     **pPrevGrp)
{
    *pGrp = FindIGMPAddr(NTE, Addr, pPrevGrp);
    if (*pGrp)
        return IP_SUCCESS;

    return CreateIGMPAddr(NTE, Addr, pGrp, pPrevGrp);
}

//* DeleteIGMPAddr - delete a group entry
//
// Input:  NTE      - NetTableEntry to add group on
//         PrevPtr  - Previous group entry
//         pPtr     - Group entry to delete
//
// Output: pPtr     - zeroed since group entry is freed
//
// Assumes caller holds lock on NTE
void
DeleteIGMPAddr(
    IN     NetTableEntry *NTE,
    IN     IGMPAddr      *PrevPtr,
    IN OUT IGMPAddr     **pPtr)
{
    // Make sure all references have been released and retransmissions are done
    ASSERT(IS_GROUP_DELETABLE(*pPtr));

    // Unlink from the NTE
    PrevPtr->iga_next = (*pPtr)->iga_next;
    NTE->nte_igmpcount--;

    // Free the hash table if needed
    if (NTE->nte_igmpcount == 0) {
        CTEFreeMem(NTE->nte_igmplist);
        NTE->nte_igmplist = NULL;
    }

    // Free memory
    CTEFreeMem(*pPtr);
    *pPtr = NULL;
}

//////////////////////////////////////////////////////////////////////////////
// Routines accessing source entries
//////////////////////////////////////////////////////////////////////////////

//* FindIGMPSrcAddr - Find an mcast source entry on a source list.
//
//      Called to search an NTE for an IGMP source entry for a given address.
//      We walk down the chain on the group entry looking for it. If we find it,
//      we return a pointer to it and the one immediately preceding it. If we
//      don't find it we return NULL. We assume the caller has taken the lock
//      on the NTE before calling us.
//
//      Input:  IGA             - group entry on which to search.
//              Addr            - source address to find.
//              PrevPtr         - Where to return pointer to preceding entry.
//
//      Returns: Pointer to matching IGMPSrcAddr structure if found, or NULL
//                  if not found.
//
IGMPSrcAddr *
FindIGMPSrcAddr(
    IN  IGMPAddr     *IGA,
    IN  IPAddr        Addr,
    OUT IGMPSrcAddr **PrevPtr OPTIONAL)
{
    IGMPSrcAddr *Current, *Temp;

    Temp = STRUCT_OF(IGMPSrcAddr, &IGA->iga_srclist, isa_next);
    Current = IGA->iga_srclist;

    while (Current != NULL) {
        if (IP_ADDR_EQUAL(Current->isa_addr, Addr)) {
            // Found a match, so return it.
            if (PrevPtr) {
                *PrevPtr = Temp;
            }
            return Current;
        }
        Temp = Current;
        Current = Current->isa_next;
    }
    return NULL;
}

//* CreateIGMPSrcAddr - Allocate memory and link the new source address in
//
//  Input:  GroupPtr    - group entry to add source to.
//          SrcAddr     - source address to add.
//
//  Output: pSrcPtr     - source entry added.
//          pPrevSrcPtr - previous source entry.
//
// Assumes caller holds lock on NTE.
//
IP_STATUS
CreateIGMPSrcAddr(
    IN  IGMPAddr     *GroupPtr,
    IN  IPAddr        SrcAddr,
    OUT IGMPSrcAddr **pSrcPtr,
    OUT IGMPSrcAddr **pPrevSrcPtr OPTIONAL)
{
    IGMPSrcAddr *SrcAddrPtr;

    // If this is a multicast address, fail the request.
    if (CLASSD_ADDR(SrcAddr)) {
        return IP_BAD_REQ;
    }

    // Allocate space for the new source entry
    SrcAddrPtr = CTEAllocMemN(sizeof(IGMPSrcAddr), 'yICT');
    if (SrcAddrPtr == NULL) {
        return IP_NO_RESOURCES;
    }

    // Initialize fields
    RtlZeroMemory(SrcAddrPtr, sizeof(IGMPSrcAddr));
    SrcAddrPtr->isa_addr    = SrcAddr;

    // Link it off the group entry
    SrcAddrPtr->isa_next = GroupPtr->iga_srclist;
    GroupPtr->iga_srclist = SrcAddrPtr;

    *pSrcPtr = SrcAddrPtr;
    if (pPrevSrcPtr)
        *pPrevSrcPtr = STRUCT_OF(IGMPSrcAddr, &GroupPtr->iga_srclist, isa_next);
    return IP_SUCCESS;
}

//* FindOrCreateIGMPSrcAddr - Find or create a source entry
//
//  Input:  GroupPtr    - group entry to add source to.
//          SrcAddr     - source address to add.
//
//  Output: pSrcPtr     - source entry added.
//          pPrevSrcPtr - previous source entry.
//
// Assumes caller holds lock on NTE
IP_STATUS
FindOrCreateIGMPSrcAddr(
    IN  IGMPAddr      *AddrPtr,
    IN  IPAddr         SrcAddr,
    OUT IGMPSrcAddr  **pSrc,
    OUT IGMPSrcAddr  **pPrevSrc)
{
    *pSrc = FindIGMPSrcAddr(AddrPtr, SrcAddr, pPrevSrc);
    if (*pSrc)
        return IP_SUCCESS;

    return CreateIGMPSrcAddr(AddrPtr, SrcAddr, pSrc, pPrevSrc);
}

//* DeleteIGMPSrcAddr - delete a source entry
//
//  Input:  pSrcPtr    - source entry added.
//          PrevSrcPtr - previous source entry.
//
//  Output: pSrcPtr    - zeroed since source entry is freed.
//
// Caller is responsible for freeing group entry if needed
// Assumes caller holds lock on NTE
void
DeleteIGMPSrcAddr(
    IN     IGMPSrcAddr  *PrevSrcPtr,
    IN OUT IGMPSrcAddr **pSrcPtr)
{
    // Make sure all references have been released
    // and no retransmissions are left
    ASSERT(IS_SOURCE_DELETABLE(*pSrcPtr));

    // Unlink from the group entry
    PrevSrcPtr->isa_next = (*pSrcPtr)->isa_next;

    // Free memory
    CTEFreeMem(*pSrcPtr);
    *pSrcPtr = NULL;
}

//////////////////////////////////////////////////////////////////////////////
// Timer routines
//////////////////////////////////////////////////////////////////////////////

//* ResetGeneralTimer - Reset timer for responding to a General Query in
//                      IGMPv3 mode
//
// Input: IF                   - Interface to reset timer on
//        MaxRespTimeInHalfSec - Maximum expiration time
void
ResetGeneralTimer(
    IN Interface *IF,
    IN uint       MaxRespTimeInHalfSec)
{
    if ((IF->IgmpGeneralTimer == 0) ||
        (IF->IgmpGeneralTimer > MaxRespTimeInHalfSec)) {
        IF->IgmpGeneralTimer = IGMPRandomTicks(MaxRespTimeInHalfSec);
    }

    // We could walk all groups here to stop any timers longer
    // than IF->IgmpGeneralTimer, but is it really worth it?
}

//* CancelGroupResponseTimer - stop a group timer
//
// Caller is responsible for deleting AddrPtr if no longer needed.
void
CancelGroupResponseTimer(
    IN IGMPAddr  *AddrPtr)
{
    IGMPSrcAddr *Src, *PrevSrc;

    AddrPtr->iga_resptimer = 0;
    AddrPtr->iga_resptype  = NO_RESP;

    // Make sure we never violate the invariant:
    // iga_resptimer>0 if isa_csmarked=TRUE for any source
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        Src->isa_csmarked = FALSE;

        if (IS_SOURCE_DELETABLE(Src)) {
           DeleteIGMPSrcAddr(PrevSrc, &Src);
           Src = PrevSrc;
        }
    }
}

//* ResetGroupResponseTimer - Reset timer for responding to a Group-specific
//                            Query, or an IGMPv1/v2 General Query.
//
// Input: IF                   - Interface to reset timer on.
//        AddrPtr              - Group entry whose timer should be reset.
//        MaxRespTimeInHalfSec - Maximum expiration time.
//
// Caller is responsible for deleting AddrPtr if no longer needed.
void
ResetGroupResponseTimer(
    IN Interface     *IF,
    IN IGMPAddr      *AddrPtr,
    IN uint           MaxRespTimeInHalfSec)
{
    if ((AddrPtr->iga_resptimer == 0) ||
        (AddrPtr->iga_resptimer > MaxRespTimeInHalfSec)) {
        AddrPtr->iga_resptimer = IGMPRandomTicks(MaxRespTimeInHalfSec);
    }

    // Check if superceded by a general query
    if ((IF->IgmpGeneralTimer != 0)
     && (IF->IgmpGeneralTimer <= AddrPtr->iga_resptimer)) {
        CancelGroupResponseTimer(AddrPtr);
        return;
    }

    // Supercede group-source responses
    AddrPtr->iga_resptype = GROUP_RESP;
}

//* ResetGroupAndSourceTimer - Reset timer for responding to a
//                             Group-and-source-specific Query
//
// Input: IF                   - Interface to reset timer on.
//        AddrPtr              - Group entry whose timer should be reset.
//        MaxRespTimeInHalfSec - Maximum expiration time.
//
// Caller is responsible for deleting AddrPtr if no longer needed
void
ResetGroupAndSourceTimer(
    IN Interface *IF,
    IN IGMPAddr  *AddrPtr,
    IN uint       MaxRespTimeInHalfSec)
{
    if ((AddrPtr->iga_resptimer == 0) ||
        (AddrPtr->iga_resptimer > MaxRespTimeInHalfSec)) {
        AddrPtr->iga_resptimer = IGMPRandomTicks(MaxRespTimeInHalfSec);
    }

    // Check if superceded by a general query
    if ((IF->IgmpGeneralTimer != 0)
     && (IF->IgmpGeneralTimer < AddrPtr->iga_resptimer)) {
        CancelGroupResponseTimer(AddrPtr);
        return;
    }

    // Check if superceded by a group-specific responses
    if (AddrPtr->iga_resptype == NO_RESP)
        AddrPtr->iga_resptype = GROUP_SOURCE_RESP;
}

//////////////////////////////////////////////////////////////////////////////
// Receive routines
//////////////////////////////////////////////////////////////////////////////

//* SetVersion - change the IGMP compatability mode on an interface.
//
// Input: NTE     - NetTableEntry on which to set IGMP version.
//        Version - IGMP version number to set
//
// Caller is responsible for deleting AddrPtr if no longer needed
void
SetVersion(
    IN NetTableEntry *NTE,
    IN uint           Version)
{
    IGMPAddr   **HashPtr, *AddrPtr, *PrevPtr;
    IGMPSrcAddr *Src, *PrevSrc;
    uint         i;

    DEBUGMSG(DBG_INFO && DBG_IGMP,
        (DTEXT("Setting version on interface %d to %d\n"),
        NTE->nte_if->if_index, Version));

    NTE->nte_if->IgmpVersion = Version;

    // Cancel General Timer
    NTE->nte_if->IgmpGeneralTimer = 0;

    //
    // Cancel all Group-Response and Triggered Retransmission timers
    //

    HashPtr = NTE->nte_igmplist;
    for (i = 0; (i < IGMP_TABLE_SIZE) && (NTE->nte_igmplist != NULL); i++) {
        PrevPtr = STRUCT_OF(IGMPAddr, &HashPtr[i], iga_next);
        for (AddrPtr = HashPtr[i];
             (AddrPtr != NULL);
             PrevPtr = AddrPtr, AddrPtr = AddrPtr->iga_next)
        {
            PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
            for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
                Src->isa_xmitleft = 0;
                Src->isa_csmarked = FALSE;

                if (IS_SOURCE_DELETABLE(Src)) {
                   DeleteIGMPSrcAddr(PrevSrc, &Src);
                   Src = PrevSrc;
                }
            }

            AddrPtr->iga_trtimer    = 0;
            AddrPtr->iga_changetype = NO_CHANGE;
            AddrPtr->iga_xmitleft   = 0;

            CancelGroupResponseTimer(AddrPtr);

            if (IS_GROUP_DELETABLE(AddrPtr)) {
                DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                AddrPtr = PrevPtr;
            }

            if (NTE->nte_igmplist == NULL)
                break;
        }
    }
}

//* ProcessGroupQuery - process an IGMP Group-specific query
//
// Caller is responsible for deleting AddrPtr if no longer needed.
void
ProcessGroupQuery(
    IN Interface     *IF,
    IN IGMPAddr      *AddrPtr,
    IN uint           ReportingDelayInHalfSec)
{
    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("Got group query on interface %d\n"), IF->if_index));

    // Ignore query if we won't report anything.  This will happen
    // right after we leave and have retransmissions pending.
    if (!IS_GROUP_ALLOWED(AddrPtr))
        return;

    ResetGroupResponseTimer(IF, AddrPtr, ReportingDelayInHalfSec);
}

//* ProcessGeneralQuery - Process an IGMP General Query
//
// Assumes caller holds lock on NTE
void
ProcessGeneralQuery(
    IN NetTableEntry *NTE,
    IN uint           ReportingDelayInHalfSec)
{
    IGMPAddr **HashPtr, *AddrPtr, *PrevPtr;
    uint       i;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("Got general query on interface %d\n"),
        NTE->nte_if->if_index));

    if (NTE->nte_if->IgmpVersion == IGMPV3) {
        // IGMPv3 can pack multiple group records into the same report
        // and hence does not stagger the timers.

        // Create a pending response record
        ResetGeneralTimer(NTE->nte_if, ReportingDelayInHalfSec);
    } else {
        //
        // Walk our list and set a random report timer for all those
        // multicast addresses (except for the all-hosts address) that
        // don't already have one running.
        //
        HashPtr = NTE->nte_igmplist;

        for (i=0; (i < IGMP_TABLE_SIZE) && (NTE->nte_igmplist != NULL); i++) {
            PrevPtr = STRUCT_OF(IGMPAddr, &HashPtr[i], iga_next);
            for (AddrPtr = HashPtr[i];
                 (AddrPtr != NULL);
                 PrevPtr=AddrPtr, AddrPtr = AddrPtr->iga_next)
            {
                if (IP_ADDR_EQUAL(AddrPtr->iga_addr, ALL_HOST_MCAST))
                    continue;

                ProcessGroupQuery(NTE->nte_if, AddrPtr,
                                  ReportingDelayInHalfSec);

                if (IS_GROUP_DELETABLE(AddrPtr)) {
                    DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                    AddrPtr = PrevPtr;
                }

                if (NTE->nte_igmplist == NULL)
                    break;
            }
        }
    }
}

//* Process an IGMP Group-and-source-specific Query
//
// Caller is responsible for deleting AddrPtr if no longer needed
void
ProcessGroupAndSourceQuery(
    IN NetTableEntry               *NTE,
    IN IGMPv3QueryHeader UNALIGNED *IQH,
    IN IGMPAddr                    *AddrPtr,
    IN uint                         ReportingDelayInHalfSec)
{
    uint         i, NumSrc;
    IGMPSrcAddr *Src;
    IP_STATUS    Status = IP_SUCCESS;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("Got source query on interface %d\n"),
        NTE->nte_if->if_index));

    NumSrc  = net_short(IQH->igh_numsrc);

    ResetGroupAndSourceTimer(NTE->nte_if, AddrPtr, ReportingDelayInHalfSec);

    // Mark each source
    for (i=0; i<NumSrc; i++) {
        Src = FindIGMPSrcAddr(AddrPtr, IQH->igh_srclist[i], NULL);
        if (!Src) {
            if (AddrPtr->iga_grefcnt == 0)
                continue;

            // Create temporary source state
            Status = CreateIGMPSrcAddr(AddrPtr, IQH->igh_srclist[i],
                                       &Src, NULL);

            // If this fails, we have a problem since we won't be
            // able to override the leave and a temporary black
            // hole would result.  To avoid this, we pretend we
            // just got a group-specific query instead.
            if (Status != IP_SUCCESS) {
                ProcessGroupQuery(NTE->nte_if, AddrPtr,
                                  ReportingDelayInHalfSec);
                break;
            }
        }

        // Mark source for current-state report inclusion
        Src->isa_csmarked = TRUE;
    }
}

//* Process an IGMP Query message
//
//  Entry:  NTE           - Pointer to NTE on which IGMP message was received.
//          Dest          - IPAddr of destination (should be a Class D address).
//          IPHdr         - Pointer to the IP Header.
//          IPHdrLength   - Bytes in IPHeader.
//          IQH           - Pointer to IGMP Query received.
//          Size          - Size in bytes of IGMP message.
//
// Assumes caller holds lock on NTE
void
IGMPRcvQuery(
    IN NetTableEntry               *NTE,
    IN IPAddr                       Dest,
    IN IPHeader UNALIGNED          *IPHdr,
    IN uint                         IPHdrLength,
    IN IGMPv3QueryHeader UNALIGNED *IQH,
    IN uint                         Size)
{
    uint ReportingDelayInHalfSec, MaxResp, NumSrc;
    IGMPAddr *AddrPtr, *PrevPtr;
    uchar QRV;

    DBG_UNREFERENCED_PARAMETER(Dest);

    // Make sure we're running at least level 2 of IGMP support.
    if (IGMPLevel != 2)
        return;

    NumSrc  = (Size >= 12)? net_short(IQH->igh_numsrc) : 0;
    QRV     = (Size >= 12)? IQH->igh_qrv : 0;

    // Update Robustness to match querier's robustness variable
    if (QRV > MAX_ROBUSTNESS) {
        QRV = MAX_ROBUSTNESS;
    }
    g_IgmpRobustness = (QRV)? QRV : DEFAULT_ROBUSTNESS;

    //
    // If it is an older-version General Query, set the timer value for 
    // staying in older-version mode.
    //
    if ((Size == 8) && (IQH->igh_maxresp == 0)) {
        MaxResp = DEFAULT_QUERY_RESP_INTERVAL;
        if (IQH->igh_addr == 0) {
            if (NTE->nte_if->IgmpVersion > IGMPV1) {
                SetVersion(NTE, IGMPV1);
            }
            NTE->nte_if->IgmpVer1Timeout = g_IgmpRobustness * DEFAULT_QUERY_INTERVAL
                                           + (MaxResp+4)/5;
        }
    } else if ((Size == 8) && (IQH->igh_maxresp != 0)) {
        MaxResp = IQH->igh_maxresp;
        if (IQH->igh_addr == 0) {
            if (NTE->nte_if->IgmpVersion > IGMPV2) {
                SetVersion(NTE, IGMPV2);
            }
            NTE->nte_if->IgmpVer2Timeout = g_IgmpRobustness * DEFAULT_QUERY_INTERVAL
                                           + (MaxResp+4)/5;
        }
    } else if ((Size < 12) || (IQH->igh_rsvd2 != 0)) {
        // must silently ignore

        DEBUGMSG(DBG_WARN && DBG_IGMP,
            (DTEXT("Dropping IGMPv3 query with unrecognized version\n")));

        return;
    } else {
        // IGMPv3

        uchar* ptr = ((uchar*)IPHdr) + sizeof(IPHeader);
        int len = IPHdrLength - sizeof(IPHeader);
        uchar temp;
        BOOLEAN bRtrAlertFound = FALSE;

        // drop it if size is too short for advertised # sources
        if (Size < IGMPV3_QUERY_SIZE(NumSrc)) {

            DEBUGMSG(DBG_WARN && DBG_IGMP,
                (DTEXT("Dropping IGMPv3 query due to size too short\n")));

            return;
        }

        // drop it if it didn't have router alert
        while (!bRtrAlertFound && len>=2) {
            if (ptr[0] == IP_OPT_ROUTER_ALERT) {
                bRtrAlertFound = TRUE;
                break;
            }
            temp = ptr[1]; // length
            ptr += temp;
            len -= temp;
        }

        if (!bRtrAlertFound) {
            DEBUGMSG(DBG_WARN && DBG_IGMP,
                (DTEXT("Dropping IGMPv3 query due to lack of Router Alert option\n")));
            return;
        }

        if (IQH->igh_mrctype == 0) {
            MaxResp = IQH->igh_maxresp;
        } else {
            MaxResp = ((((uint)IQH->igh_mrcmant) + 16) << (((uint)IQH->igh_mrcexp) + 3));
        }
    }
    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("IGMPRcvQuery: Max response time = %d.%d seconds\n"),
        MaxResp/10, MaxResp%10));

    //
    // MaxResp has time in 100 msec (1/10 sec) units.  Convert
    // to 500 msec units.  If the time is < 500 msec, use 1.
    //
    ReportingDelayInHalfSec = ((MaxResp > 5) ? (MaxResp / 5) : 1);

    if (IQH->igh_addr == 0) {
        // General Query
        ProcessGeneralQuery(NTE, ReportingDelayInHalfSec);
    } else {
        // If all-hosts address, ignore it
        if (IP_ADDR_EQUAL(IQH->igh_addr, ALL_HOST_MCAST)) {
            DEBUGMSG(DBG_WARN && DBG_IGMP,
                (DTEXT("Dropping IGMPv3 query for the All-Hosts group\n")));
            return;
        }

        // Don't need to do anything if we have no group state for the group
        AddrPtr = FindIGMPAddr(NTE, IQH->igh_addr, &PrevPtr);
        if (!AddrPtr)
            return;

        if (NumSrc == 0) {
            // Group-specific query
            ProcessGroupQuery(NTE->nte_if, AddrPtr, ReportingDelayInHalfSec);

        } else {
            // Group-and-source-specific query
            ProcessGroupAndSourceQuery(NTE, IQH, AddrPtr,
                                       ReportingDelayInHalfSec);
        }

        // Delete group if no longer needed
        if (IS_GROUP_DELETABLE(AddrPtr))
            DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
    }
}

//** IGMPRcv - Receive an IGMP datagram.
//
//      Called by IP when we receive an IGMP datagram. We validate it to make
//      sure it's reasonable. Then if it it's a query for a group to which we
//      belong we'll start a response timer. If it's a report to a group to
//      which we belong  we'll stop any running timer.
//
//      The IGMP header is only 8 bytes long, and so should always fit in
//      exactly  one IP rcv buffer. We check this to make sure, and if it
//      takes multiple buffers we discard it.
//
//  Entry:  NTE           - Pointer to NTE on which IGMP message was received.
//          Dest          - IPAddr of destination (should be a Class D address).
//          Src           - IPAddr of source
//          LocalAddr     - Local address of network which caused this to be
//                          received.
//          SrcAddr       - Address of local interface which received the
//                          packet
//          IPHdr         - Pointer to the IP Header.
//          IPHdrLength   - Bytes in IPHeader.
//          RcvBuf        - Pointer to IP receive buffer chain.
//          Size          - Size in bytes of IGMP message.
//          IsBCast       - Boolean indicator of whether or not this came in
//                          as a bcast (should always be true).
//          Protocol      - Protocol this came in on.
//          OptInfo       - Pointer to info structure for received options.
//
//  Returns: Status of reception
IP_STATUS
IGMPRcv(
    IN NetTableEntry      * NTE,
    IN IPAddr               Dest,
    IN IPAddr               Src,
    IN IPAddr               LocalAddr,
    IN IPAddr               SrcAddr,
    IN IPHeader UNALIGNED * IPHdr,
    IN uint                 IPHdrLength,
    IN IPRcvBuf           * RcvBuf,
    IN uint                 Size,
    IN uchar                IsBCast,
    IN uchar                Protocol,
    IN IPOptInfo          * OptInfo)
{
    IGMPHeader UNALIGNED *IGH;
    CTELockHandle Handle;
    IGMPAddr *AddrPtr, *PrevPtr;
    uchar DType;
    uint PromiscuousMode = 0;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_RX,
        (DTEXT("IGMPRcv entered\n")));

    PromiscuousMode = NTE->nte_if->if_promiscuousmode;

    // ASSERT(CLASSD_ADDR(Dest));
    // ASSERT(IsBCast);

    // Discard packets with invalid or broadcast source addresses.
    DType = GetAddrType(Src);
    if (DType == DEST_INVALID || IS_BCAST_DEST(DType)) {
        return IP_SUCCESS;
    }

    // Now get the pointer to the header, and validate the xsum.
    IGH = (IGMPHeader UNALIGNED *) RcvBuf->ipr_buffer;

    //
    // For mtrace like programs, use the entire IGMP packet to generate the xsum.
    //
    if ((Size < sizeof(IGMPHeader)) || (XsumRcvBuf(0, RcvBuf) != 0xffff)) {
        // Bad checksum, so fail.
        return IP_SUCCESS;
    }

    // OK, we may need to process this. See if we are a member of the
    // destination group. If we aren't, there's no need to proceed further.

    //
    // Since for any interface we always get notified with
    // same NTE, locking the NTE is fine.  We don't have to
    // lock the interface structure
    //
    CTEGetLock(&NTE->nte_lock, &Handle);
    {
        if (!(NTE->nte_flags & NTE_VALID)) {
            CTEFreeLock(&NTE->nte_lock, Handle);
            return IP_SUCCESS;
        }

        //
        // The NTE is valid. Demux on type.
        //
        switch (IGH->igh_vertype) {

        case IGMP_QUERY:
            IGMPRcvQuery(NTE, Dest, IPHdr, IPHdrLength,
                         (IGMPv3QueryHeader UNALIGNED *)IGH, Size);
            break;

        case IGMP_REPORT_V1:
        case IGMP_REPORT_V2:
            // Make sure we're running at least level 2 of IGMP support.
            if (IGMPLevel != 2) {
                CTEFreeLock(&NTE->nte_lock, Handle);
                return IP_SUCCESS;
            }

            //
            // This is a report. Check its validity and see if we have a
            // response timer running for that address. If we do, stop it.
            // Make sure the destination address matches the address in the
            // IGMP header.
            //
            if (IP_ADDR_EQUAL(Dest, IGH->igh_addr)) {
                // The addresses match. See if we have a membership in this
                // group.
                AddrPtr = FindIGMPAddr(NTE, IGH->igh_addr, &PrevPtr);
                if (AddrPtr != NULL) {
                    // We found a matching multicast address. Stop the response
                    // timer for any Group-specific or Group-and-source-
                    // specific queries.
                    CancelGroupResponseTimer(AddrPtr);

                    if (IS_GROUP_DELETABLE(AddrPtr))
                        DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                }
            }
            break;

        default:
            break;
        }
    }
    CTEFreeLock(&NTE->nte_lock, Handle);

    //
    // Pass the packet up to the raw layer if applicable.
    // If promiscuous mode is set then we will anyway call rawrcv later
    //
    if ((RawPI != NULL) && (!PromiscuousMode)) {
        if (RawPI->pi_rcv != NULL) {
            (*(RawPI->pi_rcv)) (NTE, Dest, Src, LocalAddr, SrcAddr, IPHdr,
                                IPHdrLength, RcvBuf, Size, IsBCast, Protocol, OptInfo);
        }
    }
    return IP_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
// Send routines
//////////////////////////////////////////////////////////////////////////////

//* IGMPTransmit - transmit an IGMP message
IP_STATUS
IGMPTransmit(
    IN PNDIS_BUFFER Buffer,
    IN PVOID        Body,
    IN uint         Size,
    IN IPAddr       SrcAddr,
    IN IPAddr       DestAddr)
{
    uchar        RtrAlertOpt[4] = { IP_OPT_ROUTER_ALERT, 4, 0, 0 };
    IPOptInfo    OptInfo;            // Options for this transmit.
    IP_STATUS    Status;
    RouteCacheEntry *RCE;
    ushort MSS;
    uchar DestType;
    IPAddr Src;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("IGMPTransmit: Buffer=%x Body=%x Size=%d SrcAddr=%x\n"),
        Buffer, Body, Size, SrcAddr));

    IPInitOptions(&OptInfo);

    OptInfo.ioi_ttl = 1;
    OptInfo.ioi_options = (uchar *) RtrAlertOpt;
    OptInfo.ioi_optlength = ROUTER_ALERT_SIZE;

    Src = OpenRCE(DestAddr, SrcAddr, &RCE, &DestType, &MSS, &OptInfo);

    if (IP_ADDR_EQUAL(Src,NULL_IP_ADDR)) {
        IGMPSendComplete(Body, Buffer, IP_SUCCESS);
        return IP_DEST_HOST_UNREACHABLE;
    }

#if GPC
    if (DisableUserTOS) {
        OptInfo.ioi_tos = (uchar) DefaultTOS;
    }
    if (GPCcfInfo) {

        //
        // we'll fall into here only if the GPC client is there
        // and there is at least one CF_INFO_QOS installed
        // (counted by GPCcfInfo).
        //

        GPC_STATUS status = STATUS_SUCCESS;
        struct QosCfTransportInfo TransportInfo = {0, 0};
        GPC_IP_PATTERN Pattern;
        CLASSIFICATION_HANDLE GPCHandle;

        Pattern.SrcAddr = SrcAddr;
        Pattern.DstAddr = DestAddr;
        Pattern.ProtocolId = PROT_IGMP;
        Pattern.gpcSrcPort = 0;
        Pattern.gpcDstPort = 0;

        Pattern.InterfaceId.InterfaceId = 0;
        Pattern.InterfaceId.LinkId = 0;
        GPCHandle = 0;

        GetIFAndLink(RCE,
                     &Pattern.InterfaceId.InterfaceId,
                     &Pattern.InterfaceId.LinkId
                     );

        status = GpcEntries.GpcClassifyPatternHandler(
                                                 hGpcClient[GPC_CF_QOS],
                                                 GPC_PROTOCOL_TEMPLATE_IP,
                                                 &Pattern,
                                                 NULL,        // context
                                                 &GPCHandle,
                                                 0,
                                                 NULL,
                                                 FALSE);

        OptInfo.ioi_GPCHandle = (int)GPCHandle;

        //
        // Only if QOS patterns exist, we get the TOS bits out.
        //
        if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

            status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                        hGpcClient[GPC_CF_QOS],
                        OptInfo.ioi_GPCHandle,
                        FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                        (PULONG)&TransportInfo);

            //
            // It is likely that the pattern has gone by now (Removed or
            // whatever) and the handle that we are caching is INVALID.
            // We need to pull up a new handle and get the
            // TOS bit again.
            //

            if (STATUS_NOT_FOUND == status) {

                GPCHandle = 0;

                status = GpcEntries.GpcClassifyPatternHandler(
                                                 hGpcClient[GPC_CF_QOS],
                                                 GPC_PROTOCOL_TEMPLATE_IP,
                                                 &Pattern,
                                                 NULL,        // context
                                                 &GPCHandle,
                                                 0,
                                                 NULL,
                                                 FALSE);

                OptInfo.ioi_GPCHandle = (int)GPCHandle;

                //
                // Only if QOS patterns exist, we get the TOS bits out.
                //
                if (NT_SUCCESS(status)) {

                    status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                hGpcClient[GPC_CF_QOS],
                                OptInfo.ioi_GPCHandle,
                                FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                                (PULONG)&TransportInfo);
                }
            }
        }
        if (status == STATUS_SUCCESS) {

            OptInfo.ioi_tos = (OptInfo.ioi_tos & TOS_MASK) |
                              (UCHAR)TransportInfo.ToSValue;

        }
    }                        // if (GPCcfInfo)

#endif

    Status = IPTransmit(IGMPProtInfo, Body, Buffer, Size,
                        DestAddr, SrcAddr, &OptInfo, RCE, PROT_IGMP, NULL);
    CloseRCE(RCE);

    if (Status != IP_PENDING)
        IGMPSendComplete(Body, Buffer, IP_SUCCESS);

    return Status;
}

//* GetAllowRecord - allocate and fill in an IGMPv3 ALLOW record for a group
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetAllowRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // Count sources to include
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (Src->isa_xmitleft == 0)
            continue;
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        Count++;
    }
    if (Count == 0) {
        *RecSize = 0;
        return NULL;
    }

    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');

    //
    // We need to walk the source list regardless of whether the
    // allocation succeeded, so that we preserve the invariant that
    // iga_xmitleft >= isa_xmitleft for all sources.
    //
    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if (Src->isa_xmitleft == 0)
            continue;
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        if (Rec)
            Rec->igr_srclist[Count++] = Src->isa_addr;
        Src->isa_xmitleft--;

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    Rec->igr_type    = ALLOW_NEW_SOURCES;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;
    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);
    return Rec;
}

// Count a state-change report as going out, and preserve the invariant
// that iga_xmitleft>0 if iga_changetype!=NO_CHANGE
//
VOID
IgmpDecXmitLeft(
    IN IGMPAddr *AddrPtr)
{
    AddrPtr->iga_xmitleft--;
    if (!AddrPtr->iga_xmitleft) {
        AddrPtr->iga_changetype = NO_CHANGE;
    }
}

//* GetBlockRecord - allocate and fill in an IGMPv3 BLOCK record for a group
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetBlockRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // We now need to decrement the retransmission count on the group.
    // This must be done exactly once for every pair of ALLOW/BLOCK
    // records possibly generated.  We centralize this code in one place
    // by putting it in either GetAllowRecord or GetBlockRecord (which
    // are always called together).  We arbitrarily choose to put it
    // in GetBlockRecord, rather than GetAllowRecord (which isn't currently
    // called from LeaveAllIGMPAddr).
    //
    IgmpDecXmitLeft(AddrPtr);

    // Count sources to include
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (Src->isa_xmitleft == 0)
            continue;
        if (IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        Count++;
    }
    if (Count == 0) {
        *RecSize = 0;
        return NULL;
    }

    // Allocate record
    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');

    //
    // We need to walk the source list regardless of whether the
    // allocation succeeded, so that we preserve the invariant that
    // iga_xmitleft >= isa_xmitleft for all sources.
    //
    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if (Src->isa_xmitleft == 0)
            continue;
        if (IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        if (Rec)
            Rec->igr_srclist[Count++] = Src->isa_addr;
        Src->isa_xmitleft--;

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    Rec->igr_type    = BLOCK_OLD_SOURCES;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;

    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);
    return Rec;
}

//* GetGSIsInRecord - allocate and fill in an IGMPv3 IS_IN record for a
//  group-and-source query response.
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetGSIsInRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // Count sources marked and included
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        if (!Src->isa_csmarked)
            continue;
        Count++;
    }

    // Allocate record
    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');
    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        if (!Src->isa_csmarked)
            continue;
        Rec->igr_srclist[Count++] = Src->isa_addr;
        Src->isa_csmarked = FALSE;

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    Rec->igr_type    = MODE_IS_INCLUDE;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;

    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);

    return Rec;
}

//* GetInclRecord - allocate and fill in an IGMPv3 TO_IN or IS_IN record for
//  a group
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetInclRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize,
    IN uchar     Type)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // Count sources
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (!IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        Count++;
    }

    // Allocate record
    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');
    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    //
    // Walk the source list, making sure to preserve the invariants:
    // iga_xmitleft >= isa_xmitleft for all sources, and
    // iga_resptimer>0 whenever isa_csmarked is TRUE.
    //
    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if ((Type == CHANGE_TO_INCLUDE_MODE) && (Src->isa_xmitleft > 0))
            Src->isa_xmitleft--;

        if (IS_SOURCE_ALLOWED(AddrPtr, Src)) {
            Rec->igr_srclist[Count++] = Src->isa_addr;
            Src->isa_csmarked = FALSE;
        }

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    Rec->igr_type    = Type;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;

    if (Type == CHANGE_TO_INCLUDE_MODE) {
        IgmpDecXmitLeft(AddrPtr);
    }

    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);

    return Rec;
}

#define GetIsInRecord(Grp, RecSz) \
        GetInclRecord(Grp, RecSz, MODE_IS_INCLUDE)

#define GetToInRecord(Grp, RecSz) \
        GetInclRecord(Grp, RecSz, CHANGE_TO_INCLUDE_MODE)

//* GetExclRecord - allocate and fill in an IGMPv3 TO_EX or IS_EX record for
//  a group
//
// Caller is responsible for freeing pointer returned
IGMPv3GroupRecord *
GetExclRecord(
    IN IGMPAddr *AddrPtr,
    IN uint     *RecSize,
    IN uint      BodyMTU,
    IN uchar     Type)
{
    IGMPSrcAddr       *Src, *PrevSrc;
    IGMPv3GroupRecord *Rec;
    ushort             Count = 0;

    // Count sources
    for (Src=AddrPtr->iga_srclist; Src; Src=Src->isa_next) {
        if (IS_SOURCE_ALLOWED(AddrPtr, Src))
            continue;
        Count++;
    }

    // Allocate record
    Rec = CTEAllocMemN(RECORD_SIZE(Count,0), 'qICT');
    if (Rec == NULL) {
        *RecSize = 0;
        return NULL;
    }

    //
    // Walk the source list, making sure to preserve the invariants:
    // iga_xmitleft <= isa_xmitleft for all sources, and
    // iga_resptimer>0 whenever isa_csmarked is TRUE.
    //
    Count = 0;
    PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
    for (Src=AddrPtr->iga_srclist; Src; PrevSrc=Src,Src=Src->isa_next) {
        if ((Type == CHANGE_TO_EXCLUDE_MODE) && (Src->isa_xmitleft > 0))
            Src->isa_xmitleft--;

        if (!IS_SOURCE_ALLOWED(AddrPtr, Src)) {
            Rec->igr_srclist[Count++] = Src->isa_addr;
            Src->isa_csmarked = FALSE;
        }

        if (IS_SOURCE_DELETABLE(Src)) {
            DeleteIGMPSrcAddr(PrevSrc, &Src);
            Src = PrevSrc;
        }
    }

    Rec->igr_type    = Type;
    Rec->igr_datalen = 0;
    Rec->igr_numsrc  = net_short(Count);
    Rec->igr_addr    = AddrPtr->iga_addr;

    if (Type == CHANGE_TO_EXCLUDE_MODE) {
        IgmpDecXmitLeft(AddrPtr);
    }

    *RecSize = RECORD_SIZE(Count,Rec->igr_datalen);

    // Truncate at MTU boundary
    if (*RecSize > BodyMTU) {
        *RecSize = BodyMTU;
    }

    return Rec;
}

#define GetIsExRecord(Grp, RecSz, BodyMTU) \
        GetExclRecord(Grp, RecSz, BodyMTU, MODE_IS_EXCLUDE)

#define GetToExRecord(Grp, RecSz, BodyMTU) \
        GetExclRecord(Grp, RecSz, BodyMTU, CHANGE_TO_EXCLUDE_MODE)

//* QueueRecord - Queue an IGMPv3 group record for transmission.
//  If the record cannot be queued, the record is dropped and the
//  memory freed.
//
//  Input:  pCurr   = pointer to last queue entry
//          Record  = record to append to end of queue
//          RecSize = size of record to queue
//
//  Output: pCurr   = pointer to new queue entry
//          Record  = zeroed if queue failed and record was freed
//
//  Returns: status
//
IP_STATUS
QueueRecord(
    IN OUT IGMPv3RecordQueueEntry **pCurr,
    IN OUT IGMPv3GroupRecord      **pRecord,
    IN     uint                     RecSize)
{
    IGMPv3RecordQueueEntry *rqe;
    IGMPv3GroupRecord      *Record = *pRecord;
    IP_STATUS               Status;

    if (!Record) {
        return IP_SUCCESS;
    }

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("QueueRecord: Record=%x Type=%d Group=%x NumSrc=%d\n"),
        Record, Record->igr_type, Record->igr_addr,
        net_short(Record->igr_numsrc)));

    //
    // Make sure we never add a record for the all-hosts mcast address.
    //
    if (IP_ADDR_EQUAL(Record->igr_addr, ALL_HOST_MCAST)) {
        Status = IP_BAD_REQ;
        goto Error;
    }

    // Allocate a queue entry
    rqe = CTEAllocMemN(sizeof(IGMPv3RecordQueueEntry), 'qICT');
    if (rqe == NULL) {
        Status = IP_NO_RESOURCES;
        goto Error;
    }
    rqe->i3qe_next = NULL;
    rqe->i3qe_buff = Record;
    rqe->i3qe_size = RecSize;

    // Append to queue
    (*pCurr)->i3qe_next = rqe;
    *pCurr = rqe;

    return IP_SUCCESS;

Error:
    // Free buffers
    CTEFreeMem(Record);
    *pRecord = NULL;

    return Status;
}

VOID
FlushIGMPv3Queue(
    IN IGMPv3RecordQueueEntry *Head)
{
    IGMPv3RecordQueueEntry *Rqe;

    while ((Rqe = Head) != NULL) {
        // Remove entry from queue
        Head = Rqe->i3qe_next;
        Rqe->i3qe_next = NULL;

        // Free queued record
        CTEFreeMem(Rqe->i3qe_buff);
        CTEFreeMem(Rqe);
    }
}

//* SendIGMPv3Reports - send pending IGMPv3 reports
//
// Input: Head    - queue of IGMPv3 records to transmit
//        SrcAddr - source address to send with
//        BodyMTU - message payload size available to pack records in
IP_STATUS
SendIGMPv3Reports(
    IN IGMPv3RecordQueueEntry *Head,
    IN IPAddr                  SrcAddr,
    IN uint                    BodyMTU)
{
    PNDIS_BUFFER            HdrBuffer;
    uint                    HdrSize;
    IGMPv3ReportHeader     *IGH;

    PNDIS_BUFFER            BodyBuffer;
    uint                    BodySize;
    uchar*                  Body;

    IP_STATUS               Status = IP_SUCCESS;
    NDIS_STATUS             NdisStatus;
    uint                    NumRecords;
    ushort                  NumOldSources, NumNewSources;
    IGMPv3RecordQueueEntry *Rqe;
    IGMPv3GroupRecord      *Rec, *HeadRec;
    ulong                   csum;

    while (Head != NULL) {

        // Get header buffer
        HdrSize = sizeof(IGMPv3ReportHeader);
        IGH = (IGMPv3ReportHeader*) GetIGMPBuffer(HdrSize, &HdrBuffer);
        if (IGH == NULL) {
            FlushIGMPv3Queue(Head);
            return IP_NO_RESOURCES;
        }

        // We got the buffer. Fill it in and send it.
        IGH->igh_vertype = (UCHAR) IGMP_REPORT_V3;
        IGH->igh_rsvd = 0;
        IGH->igh_rsvd2 = 0;

        // Compute optimum body size
        for (;;) {
            NumRecords = 0;
            BodySize = 0;
            for (Rqe=Head; Rqe; Rqe=Rqe->i3qe_next) {
                if (BodySize + Rqe->i3qe_size > BodyMTU)
                    break;
                BodySize += Rqe->i3qe_size;
                NumRecords++;
            }

            // Make sure we fit at least one record
            if (NumRecords > 0)
                break;

            //
            // No records fit.  Let's split the first record and try again.
            // Note that igr_datalen is always 0 today.  If there is data
            // later, then splitting will need to know whether to copy
            // the data or not.  Today we assume not.
            //

            HeadRec = Head->i3qe_buff;

#pragma warning(push)
#pragma warning(disable:4267) // conversion from 'size_t' to 'ushort'            
            NumOldSources = (ushort) ((BodyMTU - sizeof(IGMPv3GroupRecord)) /
                sizeof(IPAddr));
#pragma warning(pop)
            
            NumNewSources = net_short(HeadRec->igr_numsrc) - NumOldSources;

            DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
                (DTEXT("SendIGMPv3Reports: Splitting queue entry %x Srcs=%d+%d\n"),
                HeadRec, NumOldSources, NumNewSources));

            // Truncate head
            HeadRec->igr_numsrc = net_short(NumOldSources);
            Head->i3qe_size = RECORD_SIZE(NumOldSources, HeadRec->igr_datalen);

            // Special case for IS_EX/TO_EX: just truncate or else the router
            // will end up forwarding all the sources we exclude in messages
            // other than the last one.
            if (HeadRec->igr_type == MODE_IS_EXCLUDE
             || HeadRec->igr_type == CHANGE_TO_EXCLUDE_MODE) {
                continue;
            }

            // Create a new record with NumNewSources sources
            Rec = CTEAllocMemN(RECORD_SIZE(NumNewSources,0), 'qICT');
            if (Rec == NULL) {
               // Forget the continuation, just send the truncated original.
               continue;
            }
            Rec->igr_type    = HeadRec->igr_type;
            Rec->igr_datalen = 0;
            Rec->igr_numsrc  = net_short(NumNewSources);
            Rec->igr_addr    = HeadRec->igr_addr;

            RtlCopyMemory(Rec->igr_srclist,
                          &HeadRec->igr_srclist[NumOldSources],
                          NumNewSources * sizeof(IPAddr));

            // Append it
            Rqe = Head;
            QueueRecord(&Rqe, &Rec, RECORD_SIZE(NumNewSources,
                                                Rec->igr_datalen));
        }

        // Get another ndis buffer for the body
        Body = CTEAllocMemN(BodySize, 'bICT');
        if (Body == NULL) {
            FreeIGMPBuffer(HdrBuffer);
            FlushIGMPv3Queue(Head);
            return IP_NO_RESOURCES;
        }
        NdisAllocateBuffer(&NdisStatus, &BodyBuffer, BufferPool, Body, BodySize);
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            CTEFreeMem(Body);
            FreeIGMPBuffer(HdrBuffer);
            FlushIGMPv3Queue(Head);
            return IP_NO_RESOURCES;
        }
        NDIS_BUFFER_LINKAGE(HdrBuffer) = BodyBuffer;

        // Fill in records
        NumRecords = 0;
        BodySize = 0;
        csum = 0;
        while ((Rqe = Head) != NULL) {
            if (BodySize + Rqe->i3qe_size > BodyMTU)
                break;

            // Remove from queue
            Head = Rqe->i3qe_next;
            Rqe->i3qe_next = NULL;

            // update checksum
            csum += xsum((uchar *)Rqe->i3qe_buff, Rqe->i3qe_size);

            DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
                (DTEXT("SendRecord: Record=%x RecSize=%d Type=%d Group=%x Body=%x Offset=%d\n"),
                Rqe->i3qe_buff, Rqe->i3qe_size, Rqe->i3qe_buff->igr_type,
                Rqe->i3qe_buff->igr_addr, Body, BodySize));

            RtlCopyMemory(Body + BodySize, (uchar *)Rqe->i3qe_buff,
                          Rqe->i3qe_size);
            BodySize += Rqe->i3qe_size;
            NumRecords++;

            CTEFreeMem(Rqe->i3qe_buff);
            CTEFreeMem(Rqe);
        }

        // Finish header
        IGH->igh_xsum = 0;
        IGH->igh_numrecords = net_short(NumRecords);
        csum += xsum(IGH, sizeof(IGMPv3ReportHeader));

        // Fold the checksum down.
        csum = (csum >> 16) + (csum & 0xffff);
        csum += (csum >> 16);

        IGH->igh_xsum = (ushort)~csum;

        Status = IGMPTransmit(HdrBuffer, Body, HdrSize + BodySize, SrcAddr,
                              IGMPV3_RTRS_MCAST);
    }

    return Status;
}

//* QueueIGMPv3GeneralResponse - compose and queue IGMPv3 responses to general
//  query
IP_STATUS
QueueIGMPv3GeneralResponse(
    IN IGMPv3RecordQueueEntry **pCurr,
    IN NetTableEntry           *NTE)
{
    IGMPAddr              **HashPtr, *AddrPtr;
    uint                    i;
    IGMPv3GroupRecord      *StateRec;
    uint                    StateRecSize;
    uint                    BodyMTU;

    BodyMTU = RECORD_MTU(NTE);

    //
    // Walk our list and set a random report timer for all those
    // multicast addresses (except for the all-hosts address) that
    // don't already have one running.
    //
    HashPtr = NTE->nte_igmplist;

    if (HashPtr != NULL) {
        for (i = 0; i < IGMP_TABLE_SIZE; i++) {
            for (AddrPtr = HashPtr[i];
                 AddrPtr != NULL;
                 AddrPtr = AddrPtr->iga_next)
            {
                if (IP_ADDR_EQUAL(AddrPtr->iga_addr, ALL_HOST_MCAST))
                    continue;

                if (AddrPtr->iga_grefcnt == 0)
                    StateRec = GetIsInRecord(AddrPtr, &StateRecSize);
                else
                    StateRec = GetIsExRecord(AddrPtr, &StateRecSize, BodyMTU);

                QueueRecord(pCurr, &StateRec, StateRecSize);
            }
        }
    }

    return IP_SUCCESS;
}

//* QueueOldReport - create and queue an IGMPv1/v2 membership report to be sent
IP_STATUS
QueueOldReport(
    IN IGMPReportQueueEntry **pCurr,
    IN uint                   ChangeType,
    IN uint                   IgmpVersion,
    IN IPAddr                 Group)
{
    IGMPReportQueueEntry *rqe;
    IGMPHeader           *IGH;
    uint                  ReportType, Size;
    IPAddr                Dest;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("QueueOldReport: Type=%d Vers=%d Group=%x\n"),
        ChangeType, IgmpVersion, Group));

    //
    // Make sure we never queue a report for the all-hosts mcast address.
    //
    if (IP_ADDR_EQUAL(Group, ALL_HOST_MCAST)) {
        return IP_BAD_REQ;
    }

    //
    // If the report to be sent is a "Leave Group" report but we have
    // detected an igmp v1 router on this net, do not send the report
    //
    if (IgmpVersion == IGMPV1) {
        if (ChangeType == IGMP_DELETE) {
            return IP_SUCCESS;
        } else {
            ReportType = IGMP_REPORT_V1;
            Dest = Group;
        }
    } else {
        if (ChangeType == IGMP_DELETE) {
            ReportType = IGMP_LEAVE;
            Dest = ALL_ROUTER_MCAST;
        } else {
            ReportType = IGMP_REPORT_V2;
            Dest = Group;
        }
    }

    // Allocate an IGMP report
    Size = sizeof(IGMPHeader);
    IGH = (IGMPHeader *) CTEAllocMemN(Size, 'hICT');
    if (IGH == NULL) {
        return IP_NO_RESOURCES;
    }

    IGH->igh_vertype = (UCHAR) ReportType;
    IGH->igh_rsvd = 0;
    IGH->igh_xsum = 0;
    IGH->igh_addr = Group;
    IGH->igh_xsum = ~xsum(IGH, Size);

    // Allocate a queue entry
    rqe = (IGMPReportQueueEntry *) CTEAllocMemN(sizeof(IGMPReportQueueEntry),
                                                'qICT');
    if (rqe == NULL) {
        CTEFreeMem(IGH);
        return IP_NO_RESOURCES;
    }
    rqe->iqe_next = NULL;
    rqe->iqe_buff = IGH;
    rqe->iqe_size = Size;
    rqe->iqe_dest = Dest;
    ASSERT((IGH != NULL) && (Size > 0));

    // Append to queue
    (*pCurr)->iqe_next = rqe;
    *pCurr = rqe;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("QueueOldReport: added rqe=%x buff=%x size=%d\n"),
        rqe, rqe->iqe_buff, rqe->iqe_size));

    return IP_SUCCESS;
}

//* SendOldReport - send an IGMPv1/v2 membership report
IP_STATUS
SendOldReport(
    IN IGMPReportQueueEntry *Rqe,
    IN IPAddr                SrcAddr)
{
    PNDIS_BUFFER Buffer;
    uint         Size;
    IGMPHeader  *IGH;
    uchar       *IGH2;
    IPAddr       DestAddr;

    //ASSERT(!IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR));

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("SendOldReport: rqe=%x buff=%x size=%x\n"),
        Rqe, Rqe->iqe_buff, Rqe->iqe_size));

    IGH  = Rqe->iqe_buff;
    ASSERT(IGH != NULL);
    Size = Rqe->iqe_size;
    ASSERT(Size > 0);

    DestAddr = Rqe->iqe_dest;

    IGH2 = (uchar*)GetIGMPBuffer(Size, &Buffer);
    if (IGH2 == NULL) {
        CTEFreeMem(IGH);
        Rqe->iqe_buff = NULL;
        return IP_NO_RESOURCES;
    }

    RtlCopyMemory(IGH2, (uchar *)IGH, Size);

    CTEFreeMem(IGH);
    Rqe->iqe_buff = NULL;

    return IGMPTransmit(Buffer, NULL, Size, SrcAddr, DestAddr);
}

//* SendOldReports - send pending IGMPv1/v2 membership reports
void
SendOldReports(
    IN IGMPReportQueueEntry *Head,
    IN IPAddr                SrcAddr)
{
    IGMPReportQueueEntry *rqe;

    while ((rqe = Head) != NULL) {
        // Remove from queue
        Head = rqe->iqe_next;
        rqe->iqe_next = NULL;

        SendOldReport(rqe, SrcAddr);
        CTEFreeMem(rqe);
    }
}


//////////////////////////////////////////////////////////////////////////////
// Mark changes for triggered reports
//////////////////////////////////////////////////////////////////////////////

// Should only be called for leaves if in IGMPv3 mode,
// but should be called for joins always.
void
MarkGroup(
    IN IGMPAddr    *Grp)
{
    // No reports are sent for the ALL_HOST_MCAST group
    if (IP_ADDR_EQUAL(Grp->iga_addr, ALL_HOST_MCAST)) {
        return;
    }

    Grp->iga_changetype = MODE_CHANGE;
    Grp->iga_xmitleft = g_IgmpRobustness;
}

// Should only be called if in IGMPv3 mode
void
MarkSource(
    IN IGMPAddr    *Grp,
    IN IGMPSrcAddr *Src)
{
    // No reports are sent for the ALL_HOST_MCAST group
    if (IP_ADDR_EQUAL(Grp->iga_addr, ALL_HOST_MCAST)) {
        return;
    }

    Src->isa_xmitleft = g_IgmpRobustness;
    Grp->iga_xmitleft = g_IgmpRobustness;
    if (Grp->iga_changetype == NO_CHANGE) {
        Grp->iga_changetype = SOURCE_CHANGE;
    }
}

//* IGMPDelExclList - delete sources from an internal source exclude list
//
// This never affects link-layer filters.
// Assumes caller holds lock on NTE
void
IGMPDelExclList(
    IN     NetTableEntry *NTE,
    IN     IGMPAddr      *PrevAddrPtr,
    IN OUT IGMPAddr     **pAddrPtr,
    IN     uint           NumDelSources,
    IN     IPAddr        *DelSourceList,
    IN     BOOLEAN        AllowMsg)
{
    uint         i;
    IGMPSrcAddr *Src, *PrevSrc;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("IGMPDelExclList: AddrPtr=%x NumDelSources=%d DelSourceList=%x\n"),
        *pAddrPtr, NumDelSources, DelSourceList));

    for (i=0; i<NumDelSources; i++) {

        // Find the source entry
        Src = FindIGMPSrcAddr(*pAddrPtr, DelSourceList[i], &PrevSrc);

        // Break if not there or xrefcnt=0
        ASSERT(Src && (Src->isa_xrefcnt!=0));

        if (AllowMsg && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // If all sockets exclude and no sockets include, add source
            // to IGMP ALLOW message
            if (!IS_SOURCE_ALLOWED(*pAddrPtr, Src)) {
                // Add source to ALLOW message
                MarkSource(*pAddrPtr, Src);
            }
        }

        // Decrement the xrefcnt
        Src->isa_xrefcnt--;

        // If irefcnt and xrefcnt are both 0 and no rexmits left,
        // delete the source entry
        if (IS_SOURCE_DELETABLE(Src))
            DeleteIGMPSrcAddr(PrevSrc, &Src);

        // If the group refcount=0, and srclist is null, delete group entry
        if (IS_GROUP_DELETABLE(*pAddrPtr))
            DeleteIGMPAddr(NTE, PrevAddrPtr, pAddrPtr);
    }
}

//* IGMPDelInclList - delete sources from an internal source include list
//
// Assumes caller holds lock on NTE
void
IGMPDelInclList(
    IN     CTELockHandle *pHandle,
    IN     NetTableEntry *NTE,
    IN     IGMPAddr     **pPrevAddrPtr,
    IN OUT IGMPAddr     **pAddrPtr,
    IN     uint           NumDelSources,
    IN     IPAddr        *DelSourceList,
    IN     BOOLEAN        BlockMsg)
{
    uint         i;
    IGMPSrcAddr *Src, *PrevSrc;
    BOOLEAN      GroupWasAllowed;
    BOOLEAN      GroupNowAllowed;
    IPAddr       Addr;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("IGMPDelInclList: AddrPtr=%x NumDelSources=%d DelSourceList=%x\n"),
        *pAddrPtr, NumDelSources, DelSourceList));

    Addr = (*pAddrPtr)->iga_addr;
    GroupWasAllowed = IS_GROUP_ALLOWED(*pAddrPtr);

    for (i=0; i<NumDelSources; i++) {

        // Find the source entry
        Src = FindIGMPSrcAddr(*pAddrPtr, DelSourceList[i], &PrevSrc);

        // Break if not there or irefcnt=0
        ASSERT(Src && (Src->isa_irefcnt!=0));

        // Decrement the irefcnt
        Src->isa_irefcnt--;
        if (Src->isa_irefcnt == 0) {
            (*pAddrPtr)->iga_isrccnt--;
        }

        if (BlockMsg && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // If all sockets exclude and no sockets include, add source
            // to IGMP BLOCK message
            if (!IS_SOURCE_ALLOWED(*pAddrPtr, Src)) {
                // Add source to BLOCK message
                MarkSource(*pAddrPtr, Src);
            }
        }

        // If irefcnt and xrefcnt are both 0 and no rexmits left,
        // delete the source entry
        if (IS_SOURCE_DELETABLE(Src))
            DeleteIGMPSrcAddr(PrevSrc, &Src);

        // If the group refcount=0, and srclist is null, delete group entry
        if (IS_GROUP_DELETABLE(*pAddrPtr))
            DeleteIGMPAddr(NTE, *pPrevAddrPtr, pAddrPtr);
    }

    GroupNowAllowed = (BOOLEAN) ((*pAddrPtr != NULL) && IS_GROUP_ALLOWED(*pAddrPtr));

    if (GroupWasAllowed && !GroupNowAllowed) {

        if (*pAddrPtr) {
            // Cancel response timer if running
            CancelGroupResponseTimer(*pAddrPtr);

            if (IS_GROUP_DELETABLE(*pAddrPtr))
                DeleteIGMPAddr(NTE, *pPrevAddrPtr, pAddrPtr);
        }

        // update link-layer filter
        CTEFreeLock(&NTE->nte_lock, *pHandle);
        {
            (*NTE->nte_if->if_deladdr) (NTE->nte_if->if_lcontext,
                                        LLIP_ADDR_MCAST, Addr, 0);
        }
        CTEGetLock(&NTE->nte_lock, pHandle);

        // Revalidate NTE, AddrPtr, PrevPtr
        if (!(NTE->nte_flags & NTE_VALID)) {
            *pAddrPtr = *pPrevAddrPtr = NULL;
            return;
        }

        *pAddrPtr = FindIGMPAddr(NTE, Addr, pPrevAddrPtr);
    }
}

//* IGMPAddExclList - add sources to an internal source exclude list
//
// This never affects link-layer filters.
// Assumes caller holds lock on NTE
// If failure results, the source list will be unchanged afterwards
// but the group entry may have been deleted.
IP_STATUS
IGMPAddExclList(
    IN     NetTableEntry *NTE,
    IN     IGMPAddr      *PrevAddrPtr,
    IN OUT IGMPAddr     **pAddrPtr,
    IN     uint           NumAddSources,
    IN     IPAddr        *AddSourceList)
{
    uint         i;
    IGMPSrcAddr *Src, *PrevSrc;
    IP_STATUS    Status = IP_SUCCESS;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
                (DTEXT("IGMPAddExclList: AddrPtr=%x NumAddSources=%d AddSourceList=%x\n"),
        *pAddrPtr, NumAddSources, AddSourceList));

    for (i=0; i<NumAddSources; i++) {
        // If an IGMPSrcAddr entry for the source doesn't exist, create one.
        Status = FindOrCreateIGMPSrcAddr(*pAddrPtr, AddSourceList[i], &Src,
                                         &PrevSrc);
        if (Status != IP_SUCCESS) {
            break;
        }

        // Bump the xrefcnt on the source entry
        Src->isa_xrefcnt++;

        // If all sockets exclude and no sockets include, add source
        // to IGMP BLOCK message
        if (!IS_SOURCE_ALLOWED(*pAddrPtr, Src)
         && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // Add source to BLOCK message
            MarkSource(*pAddrPtr, Src);
        }
    }

    if (Status == IP_SUCCESS)
        return Status;

    // undo previous
    IGMPDelExclList(NTE, PrevAddrPtr, pAddrPtr, i, AddSourceList, FALSE);

    return Status;
}

//* IGMPAddInclList - add sources to an internal source include list
//
// Assumes caller holds lock on NTE
//
// If failure results, the source list will be unchanged afterwards
// but the group entry may have been deleted.
IP_STATUS
IGMPAddInclList(
    IN     CTELockHandle *pHandle,
    IN     NetTableEntry *NTE,
    IN     IGMPAddr     **pPrevAddrPtr,
    IN OUT IGMPAddr     **pAddrPtr,
    IN     uint           NumAddSources,
    IN     IPAddr        *AddSourceList)
{
    uint         i, AddrAdded;
    IGMPSrcAddr *Src, *PrevSrc;
    IP_STATUS    Status = IP_SUCCESS;
    BOOLEAN      GroupWasAllowed;
    BOOLEAN      GroupNowAllowed;
    IPAddr       Addr;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
        (DTEXT("IGMPAddInclList: AddrPtr=%x NumAddSources=%d AddSourceList=%x\n"),
        *pAddrPtr, NumAddSources, AddSourceList));

    Addr = (*pAddrPtr)->iga_addr;
    GroupWasAllowed = IS_GROUP_ALLOWED(*pAddrPtr);

    for (i=0; i<NumAddSources; i++) {
        // If an IGMPSrcAddr entry for the source doesn't exist, create one.
        Status = FindOrCreateIGMPSrcAddr(*pAddrPtr, AddSourceList[i], &Src,
                                         &PrevSrc);
        if (Status != IP_SUCCESS) {
            break;
        }

        // If all sockets exclude and no sockets include, add source
        // to IGMP ALLOW message
        if (!IS_SOURCE_ALLOWED(*pAddrPtr, Src)
         && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // Add source to ALLOW message
            MarkSource(*pAddrPtr, Src);
        }

        // Bump the irefcnt on the source entry
        if (Src->isa_irefcnt == 0) {
            (*pAddrPtr)->iga_isrccnt++;
        }
        Src->isa_irefcnt++;
    }

    GroupNowAllowed = IS_GROUP_ALLOWED(*pAddrPtr);

    if (!GroupWasAllowed && GroupNowAllowed) {
        // update link-layer filter
        CTEFreeLock(&NTE->nte_lock, *pHandle);
        {
            AddrAdded = (*NTE->nte_if->if_addaddr) (NTE->nte_if->if_lcontext,
                                           LLIP_ADDR_MCAST, Addr, 0, NULL);
        }
        CTEGetLock(&NTE->nte_lock, pHandle);

        // Revalidate NTE, AddrPtr, PrevPtr
        if (!(NTE->nte_flags & NTE_VALID)) {
            Status = IP_BAD_REQ;
        } else {
            // Find the IGMPAddr entry
            *pAddrPtr = FindIGMPAddr(NTE, Addr, pPrevAddrPtr);
            if (!*pAddrPtr) {
                Status = IP_BAD_REQ;
            }   
        }

        if (!AddrAdded) {
            Status = IP_NO_RESOURCES;
        }
    }

    if (Status == IP_SUCCESS)
        return Status;

    // undo previous
    IGMPDelInclList(pHandle, NTE, pPrevAddrPtr, pAddrPtr, i, AddSourceList,
                    FALSE);

    return Status;
}


//* IGMPInclChange - update source inclusion list
//
// On failure, inclusion list will be unchanged
IP_STATUS
IGMPInclChange(
    IN NetTableEntry *NTE,
    IN IPAddr         Addr,
    IN uint           NumAddSources,
    IN IPAddr        *AddSourceList,
    IN uint           NumDelSources,
    IN IPAddr        *DelSourceList)
{
    CTELockHandle      Handle;
    IGMPAddr          *AddrPtr, *PrevPtr;
    IP_STATUS          Status;
    Interface         *IF;
    IGMPBlockStruct    Block;
    IGMPBlockStruct   *BlockPtr;
    uint               IgmpVersion = 0, BodyMTU = 0;
    IPAddr             SrcAddr = 0;
    IGMPv3GroupRecord *AllowRec = NULL, *BlockRec = NULL;
    uint               AllowRecSize = 0, BlockRecSize = 0;
    BOOLEAN            GroupWasAllowed = FALSE;
    BOOLEAN            GroupNowAllowed = FALSE;

    // First make sure we're at level 2 of IGMP support.

    if (IGMPLevel != 2)
        return IP_BAD_REQ;

    // Make sure addlist and dellist aren't both empty
    ASSERT((NumAddSources > 0) || (NumDelSources > 0));

    if (NTE->nte_flags & NTE_VALID) {

        //
        // If this is an unnumbered interface
        //

        if ((NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR) &&
            IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            SrcAddr = g_ValidAddr;
            if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                return IP_BAD_REQ;
            }
        } else {
            SrcAddr = NTE->nte_addr;
        }
    }
    CTEInitBlockStruc(&Block.ibs_block);

    // Make sure we're the only ones in this routine. If someone else is
    // already here, block.

    CTEGetLock(&IGMPLock, &Handle);
    if (IGMPBlockFlag) {

        // Someone else is already here. Walk down the block list, and
        // put ourselves on the end. Then free the lock and block on our
        // IGMPBlock structure.
        BlockPtr = STRUCT_OF(IGMPBlockStruct, &IGMPBlockList, ibs_next);
        while (BlockPtr->ibs_next != NULL)
            BlockPtr = BlockPtr->ibs_next;

        Block.ibs_next = NULL;
        BlockPtr->ibs_next = &Block;
        CTEFreeLock(&IGMPLock, Handle);
        CTEBlock(&Block.ibs_block);
    } else {
        // Noone else here, set the flag so noone else gets in and free the
        // lock.
        IGMPBlockFlag = 1;
        CTEFreeLock(&IGMPLock, Handle);
    }

    // Now we're in the routine, and we won't be reentered here by another
    // thread of execution. Make sure everything's valid, and figure out
    // what to do.

    Status = IP_SUCCESS;

    // Now get the lock on the NTE and make sure it's valid.
    CTEGetLock(&NTE->nte_lock, &Handle);
    {

        if (!(NTE->nte_flags & NTE_VALID)) {
            Status = IP_BAD_REQ;
            goto Done;
        }

        IF = NTE->nte_if;
        BodyMTU = RECORD_MTU(NTE);
        IgmpVersion = IF->IgmpVersion;

        // If an IGMPAddr entry for the group on the interface doesn't
        // exist, create one.
        Status = FindOrCreateIGMPAddr(NTE, Addr, &AddrPtr, &PrevPtr);
        if (Status != IP_SUCCESS) {
            goto Done;
        }

        GroupWasAllowed = IS_GROUP_ALLOWED(AddrPtr);

        // Perform IADDLIST
        Status = IGMPAddInclList(&Handle, NTE, &PrevPtr, &AddrPtr,
                                 NumAddSources, AddSourceList);
        if (Status != IP_SUCCESS) {
            goto Done;
        }

        // Perform IDELLLIST
        IGMPDelInclList(&Handle, NTE, &PrevPtr, &AddrPtr,
                        NumDelSources, DelSourceList, TRUE);

        if (AddrPtr == NULL) {
            GroupNowAllowed = FALSE;
            goto Done;
        } else {
            GroupNowAllowed = IS_GROUP_ALLOWED(AddrPtr);
        }

        if (IgmpVersion == IGMPV3) {
            // Get ALLOC/BLOCK records
            AllowRec = GetAllowRecord(AddrPtr, &AllowRecSize);
            BlockRec = GetBlockRecord(AddrPtr, &BlockRecSize);

            // Set retransmission timer
            AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
        } else if (!GroupWasAllowed && GroupNowAllowed) {
            // Set retransmission timer only for joins, not leaves
            MarkGroup(AddrPtr);
            AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
        }

    }
Done:
    CTEFreeLock(&NTE->nte_lock, Handle);

    if (IgmpVersion == IGMPV3) {
        IGMPv3RecordQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPv3RecordQueueEntry, &Head, i3qe_next);

        // Send IGMP ALLOW/BLOCK messages if non-empty
        QueueRecord(&rqe, &AllowRec, AllowRecSize);
        QueueRecord(&rqe, &BlockRec, BlockRecSize);
        SendIGMPv3Reports(Head, SrcAddr, BodyMTU);

    } else if (!GroupWasAllowed && GroupNowAllowed) {
        IGMPReportQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPReportQueueEntry, &Head, iqe_next);
        QueueOldReport(&rqe, IGMP_ADD, IgmpVersion, Addr);
        SendOldReports(Head, SrcAddr);

    } else if (GroupWasAllowed && !GroupNowAllowed) {
        IGMPReportQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPReportQueueEntry, &Head, iqe_next);
        QueueOldReport(&rqe, IGMP_DELETE, IgmpVersion, Addr);
        SendOldReports(Head, SrcAddr);
    }

    // We finished the request, and Status contains the completion status.
    // If there are any pending blocks for this routine, signal the next
    // one now. Otherwise clear the block flag.
    CTEGetLock(&IGMPLock, &Handle);
    if ((BlockPtr = IGMPBlockList) != NULL) {
        // Someone is blocking. Pull him from the list and signal him.
        IGMPBlockList = BlockPtr->ibs_next;
        CTEFreeLock(&IGMPLock, Handle);

        CTESignal(&BlockPtr->ibs_block, IP_SUCCESS);
    } else {
        // No one blocking, just clear the flag.
        IGMPBlockFlag = 0;
        CTEFreeLock(&IGMPLock, Handle);
    }

    return Status;
}

//* IGMPExclChange - update source exclusion list
//
// On failure, exclusion list will be unchanged
IP_STATUS
IGMPExclChange(
    IN NetTableEntry * NTE,
    IN IPAddr          Addr,
    IN uint            NumAddSources,
    IN IPAddr        * AddSourceList,
    IN uint            NumDelSources,
    IN IPAddr        * DelSourceList)
{
    CTELockHandle      Handle;
    IGMPAddr          *AddrPtr, *PrevPtr;
    IP_STATUS          Status;
    Interface         *IF;
    IGMPBlockStruct    Block;
    IGMPBlockStruct   *BlockPtr;
    uint               IgmpVersion = 0, BodyMTU = 0;
    IPAddr             SrcAddr = 0;
    IGMPv3GroupRecord *AllowRec = NULL, *BlockRec = NULL;
    uint               AllowRecSize = 0, BlockRecSize = 0;

    // First make sure we're at level 2 of IGMP support.

    if (IGMPLevel != 2)
        return IP_BAD_REQ;

    // Make sure addlist and dellist aren't both empty
    ASSERT((NumAddSources > 0) || (NumDelSources > 0));

    if (NTE->nte_flags & NTE_VALID) {

        //
        // If this is an unnumbered interface
        //

        if ((NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR) &&
            IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            SrcAddr = g_ValidAddr;
            if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                return IP_BAD_REQ;
            }
        } else {
            SrcAddr = NTE->nte_addr;
        }
    }
    CTEInitBlockStruc(&Block.ibs_block);

    // Make sure we're the only ones in this routine. If someone else is
    // already here, block.

    CTEGetLock(&IGMPLock, &Handle);
    if (IGMPBlockFlag) {

        // Someone else is already here. Walk down the block list, and
        // put ourselves on the end. Then free the lock and block on our
        // IGMPBlock structure.
        BlockPtr = STRUCT_OF(IGMPBlockStruct, &IGMPBlockList, ibs_next);
        while (BlockPtr->ibs_next != NULL)
            BlockPtr = BlockPtr->ibs_next;

        Block.ibs_next = NULL;
        BlockPtr->ibs_next = &Block;
        CTEFreeLock(&IGMPLock, Handle);
        CTEBlock(&Block.ibs_block);
    } else {
        // No one else here, set the flag so no one else gets in and free the
        // lock.
        IGMPBlockFlag = 1;
        CTEFreeLock(&IGMPLock, Handle);
    }

    // Now we're in the routine, and we won't be reentered here by another
    // thread of execution. Make sure everything's valid, and figure out
    // what to do.

    Status = IP_SUCCESS;

    // Now get the lock on the NTE and make sure it's valid.
    CTEGetLock(&NTE->nte_lock, &Handle);
    {

        if (!(NTE->nte_flags & NTE_VALID)) {
            Status = IP_BAD_REQ;
            goto Done;
        }

        IF = NTE->nte_if;
        BodyMTU = RECORD_MTU(NTE);
        IgmpVersion = IF->IgmpVersion;

        // Find the IGMPAddr entry
        AddrPtr = FindIGMPAddr(NTE, Addr, &PrevPtr);

        // Break if not there or refcount=0
        ASSERT(AddrPtr && (AddrPtr->iga_grefcnt!=0));

        // Perform XADDLIST
        Status = IGMPAddExclList(NTE, PrevPtr, &AddrPtr, NumAddSources,
                                 AddSourceList);
        if (Status != IP_SUCCESS) {
            goto Done;
        }

        // Perform XDELLLIST
        IGMPDelExclList(NTE, PrevPtr, &AddrPtr, NumDelSources, DelSourceList,
                        TRUE);

        // Don't need to reget AddrPtr here since the NTE lock is never
        // released while modifying the exclusion list above, since the
        // linklayer filter is unaffected.

        if (IgmpVersion == IGMPV3) {
            AllowRec = GetAllowRecord(AddrPtr, &AllowRecSize);
            BlockRec = GetBlockRecord(AddrPtr, &BlockRecSize);

            // Set retransmission timer
            AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
        }

    }
Done:
    CTEFreeLock(&NTE->nte_lock, Handle);

    // Since AddrPtr->iga_grefcnt cannot be zero, and is unchanged by
    // this function, we never need to update the link-layer filter.

    // Send IGMP ALLOW/BLOCK messages if non-empty
    // Note that we never need to do anything here in IGMPv1/v2 mode.
    if (IgmpVersion == IGMPV3) {
        IGMPv3RecordQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPv3RecordQueueEntry, &Head, i3qe_next);
        QueueRecord(&rqe, &AllowRec, AllowRecSize);
        QueueRecord(&rqe, &BlockRec, BlockRecSize);
        SendIGMPv3Reports(Head, SrcAddr, BodyMTU);
    }

    // We finished the request, and Status contains the completion status.
    // If there are any pending blocks for this routine, signal the next
    // one now. Otherwise clear the block flag.
    CTEGetLock(&IGMPLock, &Handle);
    if ((BlockPtr = IGMPBlockList) != NULL) {
        // Someone is blocking. Pull him from the list and signal him.
        IGMPBlockList = BlockPtr->ibs_next;
        CTEFreeLock(&IGMPLock, Handle);

        CTESignal(&BlockPtr->ibs_block, IP_SUCCESS);
    } else {
        // No one blocking, just clear the flag.
        IGMPBlockFlag = 0;
        CTEFreeLock(&IGMPLock, Handle);
    }

    return Status;
}

//* JoinIGMPAddr - add a membership reference to an entire group, and
//  update associated source list refcounts.
//
// On failure, state will remain unchanged.
IP_STATUS
JoinIGMPAddr(
    IN     NetTableEntry *NTE,
    IN     IPAddr         Addr,
    IN     uint           NumExclSources,
    IN OUT IPAddr        *ExclSourceList, // volatile
    IN     uint           NumInclSources,
    IN     IPAddr        *InclSourceList,
    IN     IPAddr         SrcAddr)
{
    IGMPAddr          *AddrPtr, *PrevPtr;
    IGMPSrcAddr       *SrcAddrPtr, *PrevSrc;
    Interface         *IF;
    uint               IgmpVersion = 0, i, AddrAdded, BodyMTU = 0;
    IP_STATUS          Status;
    CTELockHandle      Handle;
    IGMPv3GroupRecord *ToExRec = NULL, *AllowRec = NULL, *BlockRec = NULL;
    uint               ToExRecSize = 0, AllowRecSize = 0, BlockRecSize = 0;
    BOOLEAN            GroupWasAllowed = FALSE;
    uint               InitialRefOnIgmpAddr;

    Status = IP_SUCCESS;

    CTEGetLock(&NTE->nte_lock, &Handle);
    {
        if (!(NTE->nte_flags & NTE_VALID)) {
            Status = IP_BAD_REQ;
            goto Done;
        }

        IF = NTE->nte_if;
        IgmpVersion = IF->IgmpVersion;
        BodyMTU = RECORD_MTU(NTE);

        // If no group entry exists, create one in exclusion mode
        Status = FindOrCreateIGMPAddr(NTE, Addr, &AddrPtr, &PrevPtr);
        if (Status != IP_SUCCESS) {
            goto Done;
        }


        // Store the ref count at this point in a local variable.
        InitialRefOnIgmpAddr = AddrPtr->iga_grefcnt;

        GroupWasAllowed = IS_GROUP_ALLOWED(AddrPtr);

        if (!GroupWasAllowed) {

            // We have to be careful not to release the lock while
            // IS_GROUP_DELETABLE() is true, or else it might be
            // deleted by IGMPTimer().  So before releasing the lock,
            // we bump the join refcount (which we want to do anyway
            // later on, so it won't hurt anything now).
            (AddrPtr->iga_grefcnt)++;

            // Update link-layer filter
            CTEFreeLock(&NTE->nte_lock, Handle);
            {
                AddrAdded = (*IF->if_addaddr) (IF->if_lcontext,
                                               LLIP_ADDR_MCAST, Addr, 0, NULL);
            }
            CTEGetLock(&NTE->nte_lock, &Handle);

            // Revalidate NTE, AddrPtr, PrevPtr
            if (!(NTE->nte_flags & NTE_VALID)) {
                // Don't need to undo any refcount here as the refcount
                // was blown away by StopIGMPForNTE.
                Status = IP_BAD_REQ;
                goto Done;
            }

            // Find the IGMPAddr entry
            AddrPtr = FindIGMPAddr(NTE, Addr, &PrevPtr);
            if (!AddrPtr) {
                Status = IP_BAD_REQ;
                goto Done;
            }

            // Now release the refcount we grabbed above
            // so the rest of the logic is the same for
            // all cases.
            (AddrPtr->iga_grefcnt)--;

            if (!AddrAdded) {
                if (IS_GROUP_DELETABLE(AddrPtr))
                    DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                Status = IP_NO_RESOURCES;
                goto Done;
            }
        }

        // For each existing source entry,
        //    If not in {xaddlist}, xrefcnt=refcount, irefcnt=0
        //       Add source to ALLOW message
        //    If in {xaddlist},
        //       Increment xrefcnt and remove from {xaddlist}
        for (SrcAddrPtr = AddrPtr->iga_srclist;
             SrcAddrPtr;
             SrcAddrPtr = SrcAddrPtr->isa_next) {

            for (i=0; i<NumExclSources; i++) {

                if (IP_ADDR_EQUAL(SrcAddrPtr->isa_addr, ExclSourceList[i])) {
                    (SrcAddrPtr->isa_xrefcnt)++;
                    ExclSourceList[i] = ExclSourceList[--NumExclSources];
                    break;
                }
            }
            if ((i == NumExclSources)
             && !IS_SOURCE_ALLOWED(AddrPtr, SrcAddrPtr)
             && (NTE->nte_if->IgmpVersion == IGMPV3)) {
                // Add source to ALLOW message
                MarkSource(AddrPtr, SrcAddrPtr);
            }
        }

        // The purpose of this check is to mark this Address 'only the first time'.
        // To take care of race conditions, this has to be stored in a local variable.
        if (InitialRefOnIgmpAddr == 0) {
            MarkGroup(AddrPtr);
        }

        // Bump the refcount on the group entry
        (AddrPtr->iga_grefcnt)++;

        // For each entry left in {xaddlist}
        //    Add source entry and increment xrefcnt
        for (i=0; i<NumExclSources; i++) {
            Status = CreateIGMPSrcAddr(AddrPtr, ExclSourceList[i],
                                       &SrcAddrPtr, &PrevSrc);
            if (Status != IP_SUCCESS) {
                break;
            }
            (SrcAddrPtr->isa_xrefcnt)++;
        }
        if (Status != IP_SUCCESS) {
            // undo source adds
            IGMPDelExclList(NTE, PrevPtr, &AddrPtr, i, ExclSourceList, FALSE);

            // undo group join
            (AddrPtr->iga_grefcnt)--;

            if (IS_GROUP_DELETABLE(AddrPtr))
                DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);

            goto Done;
        }

        // Perform IDELLIST
        IGMPDelInclList(&Handle, NTE, &PrevPtr, &AddrPtr,
                        NumInclSources, InclSourceList, TRUE);

        // Make sure AddrPtr didn't go away somehow
        if (AddrPtr == NULL) {
            Status = IP_BAD_REQ;
            goto Done;
        }

        // No reports are sent for the ALL_HOST_MCAST group
        if (!IP_ADDR_EQUAL(AddrPtr->iga_addr, ALL_HOST_MCAST)) {
            if (IgmpVersion == IGMPV3) {
                // If filter mode was inclusion,
                //    Send TO_EX with list of sources where irefcnt=0,xrefcnt=refcnt
                // Else
                //    Send ALLOW/BLOCK messages if non-empty
                if (AddrPtr->iga_grefcnt == 1) {
                    ToExRec  = GetToExRecord( AddrPtr, &ToExRecSize, BodyMTU);
                } else {
                    AllowRec = GetAllowRecord(AddrPtr, &AllowRecSize);
                    BlockRec = GetBlockRecord(AddrPtr, &BlockRecSize);
                }

                // set triggered group retransmission timer
                AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
            } else if (!GroupWasAllowed) {
                // Set retransmission timer
                AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
            }
        }
    }
Done:
    CTEFreeLock(&NTE->nte_lock, Handle);

    if (Status != IP_SUCCESS) {
        return Status;
    }

    if (IP_ADDR_EQUAL(Addr, ALL_HOST_MCAST))
        return Status;

    if (IgmpVersion == IGMPV3) {
        IGMPv3RecordQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPv3RecordQueueEntry, &Head, i3qe_next);

        QueueRecord(&rqe, &ToExRec,  ToExRecSize);
        QueueRecord(&rqe, &AllowRec, AllowRecSize);
        QueueRecord(&rqe, &BlockRec, BlockRecSize);
        SendIGMPv3Reports(Head, SrcAddr, BodyMTU);

    } else if (!GroupWasAllowed) {
        IGMPReportQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPReportQueueEntry, &Head, iqe_next);

        QueueOldReport(&rqe, IGMP_ADD, IgmpVersion, Addr);
        SendOldReports(Head, SrcAddr);
    }

    return Status;
}

//* LeaveIGMPAddr - remove a membership reference to an entire group, and
//  update associated source list refcounts.
IP_STATUS
LeaveIGMPAddr(
    IN     NetTableEntry *NTE,
    IN     IPAddr         Addr,
    IN     uint           NumExclSources,
    IN OUT IPAddr        *ExclSourceList, // volatile
    IN     uint           NumInclSources,
    IN     IPAddr        *InclSourceList,
    IN     IPAddr         SrcAddr)
{
    IGMPAddr     *AddrPtr, *PrevPtr;
    IGMPSrcAddr  *Src, *PrevSrc;
    IP_STATUS     Status;
    CTELockHandle Handle;
    Interface    *IF = NULL;
    uint          IgmpVersion = 0, i, BodyMTU = 0;
    BOOLEAN       GroupNowAllowed = TRUE;
    IGMPv3GroupRecord *ToInRec = NULL, *AllowRec = NULL, *BlockRec = NULL;
    uint               ToInRecSize = 0, AllowRecSize = 0, BlockRecSize = 0;

    Status = IP_SUCCESS;

    DEBUGMSG(DBG_TRACE && DBG_IGMP,
        (DTEXT("LeaveIGMPAddr NTE=%x Addr=%x NumExcl=%d ExclSList=%x NumIncl=%d InclSList=%x SrcAddr=%x\n"),
        NTE, Addr, NumExclSources, ExclSourceList, NumInclSources,
        InclSourceList, SrcAddr));

    // Now get the lock on the NTE and make sure it's valid.
    CTEGetLock(&NTE->nte_lock, &Handle);
    {

        if (!(NTE->nte_flags & NTE_VALID)) {
            Status = IP_BAD_REQ;
            goto Done;
        }

        IF = NTE->nte_if;
        IgmpVersion = IF->IgmpVersion;
        BodyMTU = RECORD_MTU(NTE);

        // The NTE is valid. Try to find an existing IGMPAddr structure
        // that matches the input address.
        AddrPtr = FindIGMPAddr(NTE, Addr, &PrevPtr);

        // This is a delete request. If we didn't find the requested
        // address, fail the request.

        // For now, if the ref count is 0, we will treat it as equivalent to 
        // not-found. This is done to take care of the ref count on an
        // IGMPAddr going bad because of a race condition between the 
        // invalidation and revalidation of an NTE and deletion and creation
        // of an IGMPAddr.
        if ((AddrPtr == NULL) || (AddrPtr->iga_grefcnt == 0)) {
            Status = IP_BAD_REQ;
            goto Done;
        }

        // Don't let the all-hosts mcast address go away.
        if (IP_ADDR_EQUAL(Addr, ALL_HOST_MCAST)) {
            goto Done;
        }

        // Perform IADDLIST
        Status = IGMPAddInclList(&Handle, NTE, &PrevPtr, &AddrPtr,
                                 NumInclSources, InclSourceList);
        if (Status != IP_SUCCESS) {
            goto Done;
        }

        // Decrement the refcount
        ASSERT(AddrPtr->iga_grefcnt > 0);
        AddrPtr->iga_grefcnt--;

        if ((AddrPtr->iga_grefcnt == 0)
         && (NTE->nte_if->IgmpVersion == IGMPV3)) {
            // Leaves are only retransmitted in IGMPv3
            MarkGroup(AddrPtr);
        }

        // For each existing source entry:
        //    If entry is not in {xdellist}, xrefcnt=refcnt, irefcnt=0,
        //       Add source to BLOCK message
        //    If entry is in {xdellist},
        //       Decrement xrefcnt and remove from {xdellist}
        //       If xrefcnt=irefcnt=0, delete entry
        PrevSrc = STRUCT_OF(IGMPSrcAddr, &AddrPtr->iga_srclist, isa_next);
        for (Src = AddrPtr->iga_srclist; Src; PrevSrc=Src,Src = Src->isa_next) {

            for (i=0; i<NumExclSources; i++) {

                if (IP_ADDR_EQUAL(Src->isa_addr, ExclSourceList[i])) {
                    (Src->isa_xrefcnt)--;
                    ExclSourceList[i] = ExclSourceList[--NumExclSources];
                    break;
                }
            }
            if ((i == NumExclSources)
             && !IS_SOURCE_ALLOWED(AddrPtr, Src)
             && (NTE->nte_if->IgmpVersion == IGMPV3)) {
                // Add source to BLOCK message
                MarkSource(AddrPtr, Src);
            }

            if (IS_SOURCE_DELETABLE(Src)) {
                DeleteIGMPSrcAddr(PrevSrc, &Src);
                Src = PrevSrc;
            }
        }

        // Break if {xdellist} is not empty
        ASSERT(NumExclSources == 0);

        if (IgmpVersion == IGMPV3) {
            // If refcnt is 0
            //    Send TO_IN(null)
            // Else
            //    Send ALLOW/BLOCK messages if non-empty
            if (AddrPtr->iga_grefcnt == 0) {
                ToInRec  = GetToInRecord(AddrPtr, &ToInRecSize);
            } else {
                AllowRec = GetAllowRecord(AddrPtr, &AllowRecSize);
                BlockRec = GetBlockRecord(AddrPtr, &BlockRecSize);
            }

            // set triggered group retransmission timer
            if (ToInRec || AllowRec || BlockRec) {
                AddrPtr->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
            }
        }
        // Note: IGMPv2 leaves are not retransmitted, hence no timer set.

        GroupNowAllowed = IS_GROUP_ALLOWED(AddrPtr);

        if (!GroupNowAllowed)
            CancelGroupResponseTimer(AddrPtr);

        // Delete the group entry if it's no longer needed
        if (IS_GROUP_DELETABLE(AddrPtr))
            DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);

    }
Done:
    CTEFreeLock(&NTE->nte_lock, Handle);

    if (Status != IP_SUCCESS) {
        return Status;
    }

    // Update link-layer filter
    if (!GroupNowAllowed) {
        (*IF->if_deladdr) (IF->if_lcontext, LLIP_ADDR_MCAST, Addr, 0);
    }

    if (IgmpVersion == IGMPV3) {
        IGMPv3RecordQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPv3RecordQueueEntry, &Head, i3qe_next);

        QueueRecord(&rqe, &ToInRec, ToInRecSize);
        QueueRecord(&rqe, &AllowRec, AllowRecSize);
        QueueRecord(&rqe, &BlockRec, BlockRecSize);
        SendIGMPv3Reports(Head, SrcAddr, BodyMTU);
    } else if (!GroupNowAllowed) {
        IGMPReportQueueEntry *Head = NULL, *rqe;
        rqe = STRUCT_OF(IGMPReportQueueEntry, &Head, iqe_next);
        QueueOldReport(&rqe, IGMP_DELETE, IgmpVersion, Addr);
        SendOldReports(Head, SrcAddr);
    }

    return Status;
}

//* LeaveAllIGMPAddr - remove all group references on an interface
IP_STATUS
LeaveAllIGMPAddr(
    IN NetTableEntry *NTE,
    IN IPAddr         SrcAddr)
{
    IGMPAddr    **HashPtr, *Prev, *Next, *Curr;
    IGMPSrcAddr  *PrevSrc, *CurrSrc;
    int           i, Grefcnt;
    IP_STATUS     Status;
    CTELockHandle Handle;
    Interface    *IF;
    uint          IgmpVersion = 0, BodyMTU = 0;
    IPAddr        Addr;
    IGMPv3RecordQueueEntry *I3Head  = NULL, *i3qe;
    IGMPReportQueueEntry   *OldHead = NULL, *iqe;
    IGMPv3GroupRecord      *Rec;
    uint                    RecSize;

    i3qe = STRUCT_OF(IGMPv3RecordQueueEntry, &I3Head, i3qe_next);
    iqe  = STRUCT_OF(IGMPReportQueueEntry, &OldHead, iqe_next);

    // We've been called to delete all of the addresses,
    // regardless of their reference count. This should only
    // happen when the NTE is going away.

    Status = IP_SUCCESS;

    CTEGetLock(&NTE->nte_lock, &Handle);
    {
        HashPtr = NTE->nte_igmplist;
        if (HashPtr == NULL) {
            goto Done;
        }

        IF = NTE->nte_if;
        BodyMTU = RECORD_MTU(NTE);
        IgmpVersion = IF->IgmpVersion;

        for (i = 0; (i < IGMP_TABLE_SIZE) && (NTE->nte_igmplist != NULL); i++) {

            Curr = STRUCT_OF(IGMPAddr, &HashPtr[i], iga_next);
            Next = HashPtr[i];

            for (Prev=Curr,Curr=Next;
                 Curr && (NTE->nte_igmplist != NULL);
                 Prev=Curr,Curr=Next) {
                Next = Curr->iga_next;

                Grefcnt = Curr->iga_grefcnt;
                Addr = Curr->iga_addr;

                // Leave all sources
                PrevSrc = STRUCT_OF(IGMPSrcAddr, &Curr->iga_srclist, isa_next);
                for(CurrSrc=PrevSrc->isa_next;
                    CurrSrc;
                    PrevSrc=CurrSrc,CurrSrc=CurrSrc->isa_next) {

                    if (Grefcnt && IS_SOURCE_ALLOWED(Curr, CurrSrc)
                     && (IgmpVersion == IGMPV3)) {
                        // Add source to BLOCK message
                        MarkSource(Curr, CurrSrc);
                    }

                    // Force leave
                    CurrSrc->isa_irefcnt = 0;
                    CurrSrc->isa_xrefcnt = Curr->iga_grefcnt;

                    //
                    // We may be able to delete the source now,
                    // but not if it's marked for inclusion in a block
                    // message to be sent below.
                    //
                    if (IS_SOURCE_DELETABLE(CurrSrc)) {
                        DeleteIGMPSrcAddr(PrevSrc, &CurrSrc);
                        CurrSrc = PrevSrc;
                    }
                }

                // Force group leave
                if (Grefcnt > 0) {
                    Curr->iga_grefcnt = 0;

                    // Leaves are only retransmitted in IGMPv3, where
                    // state will actually be deleted once retransmissions
                    // are complete.
                    if (IgmpVersion == IGMPV3)
                        MarkGroup(Curr);

                    CancelGroupResponseTimer(Curr);

                    //
                    // We may be able to delete the group now,
                    // but not if it's marked for inclusion in an IGMPv3
                    // leave to be sent below.
                    //
                    if (IS_GROUP_DELETABLE(Curr))
                        DeleteIGMPAddr(NTE, Prev, &Curr);
                }

                // Queue triggered messages
                if (!IP_ADDR_EQUAL(Addr, ALL_HOST_MCAST)) {
                    if (IgmpVersion < IGMPV3) {
                        QueueOldReport(&iqe, IGMP_DELETE, IgmpVersion,Addr);
                    } else if (Grefcnt > 0) {
                        // queue TO_IN
                        Rec = GetToInRecord(Curr, &RecSize);
                        QueueRecord(&i3qe, &Rec, RecSize);
                    } else {
                        // queue BLOCK
                        Rec = GetBlockRecord(Curr, &RecSize);
                        QueueRecord(&i3qe, &Rec, RecSize);
                    }
                }

                // If we haven't deleted the group yet, delete it now
                if (Curr != NULL) {
                    // Delete any leftover sources
                    PrevSrc = STRUCT_OF(IGMPSrcAddr, &Curr->iga_srclist,
                                        isa_next);
                    while (Curr->iga_srclist != NULL) {
                        CurrSrc = Curr->iga_srclist;

                        CurrSrc->isa_irefcnt = CurrSrc->isa_xrefcnt = 0;
                        CurrSrc->isa_xmitleft = CurrSrc->isa_csmarked = 0;
                        DeleteIGMPSrcAddr(PrevSrc, &CurrSrc);
                    }

                    Curr->iga_xmitleft = 0;
                    DeleteIGMPAddr(NTE, Prev, &Curr);
                }
                Curr = Prev;

                CTEFreeLock(&NTE->nte_lock, Handle);
                {
                    // Update link-layer filter
                    (*IF->if_deladdr) (IF->if_lcontext, LLIP_ADDR_MCAST,
                                       Addr, 0);
                }
                CTEGetLock(&NTE->nte_lock, &Handle);
            }
        }

        ASSERT(NTE->nte_igmplist == NULL);
        ASSERT(NTE->nte_igmpcount == 0);

    }
Done:
    CTEFreeLock(&NTE->nte_lock, Handle);

    if (IgmpVersion == IGMPV3)
        SendIGMPv3Reports(I3Head, SrcAddr, BodyMTU);
    else
        SendOldReports(OldHead, SrcAddr);

    return Status;
}

//*     IGMPAddrChange - Change the IGMP address list on an NTE.
//
//      Called to add or delete an IGMP address. We're given the relevant NTE,
//      the address, and the action to be performed. We validate the NTE, the
//      address, and the IGMP level, and then attempt to perform the action.
//
//      There are a bunch of strange race conditions that can occur during
//      adding/deleting addresses, related to trying to add the same address
//      twice and having it fail, or adding and deleting the same address
//      simultaneously. Most of these happen because we have to free the lock
//      to call the interface, and the call to the interface can fail. To
//      prevent this we serialize all access to this routine. Only one thread
//      of execution can go through here at a time, all others are blocked.
//
//      Input:  NTE             - NTE with list to be altered.
//              Addr            - Address affected.
//              ChangeType      - Type of change - IGMP_ADD, IGMP_DELETE,
//                                  IGMP_DELETE_ALL.
//              ExclSourceList  - list of exclusion sources (volatile)
//
//      Returns: IP_STATUS of attempt to perform action.
//
IP_STATUS
IGMPAddrChange(
    IN     NetTableEntry *NTE,
    IN     IPAddr         Addr,
    IN     uint           ChangeType,
    IN     uint           NumExclSources,
    IN OUT IPAddr        *ExclSourceList,
    IN     uint           NumInclSources,
    IN     IPAddr        *InclSourceList)
{
    CTELockHandle Handle;
    IP_STATUS Status;
    IGMPBlockStruct Block;
    IGMPBlockStruct *BlockPtr;
    IPAddr SrcAddr = 0;

    // First make sure we're at level 2 of IGMP support.

    if (IGMPLevel != 2)
        return IP_BAD_REQ;

    if (NTE->nte_flags & NTE_VALID) {

        //
        // If this is an unnumbered interface
        //

        if ((NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR) &&
            IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            SrcAddr = g_ValidAddr;
            if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                return IP_BAD_REQ;
            }
        } else {
            SrcAddr = NTE->nte_addr;
        }
    }
    CTEInitBlockStruc(&Block.ibs_block);

    // Make sure we're the only ones in this routine. If someone else is
    // already here, block.

    CTEGetLock(&IGMPLock, &Handle);
    if (IGMPBlockFlag) {

        // Someone else is already here. Walk down the block list, and
        // put ourselves on the end. Then free the lock and block on our
        // IGMPBlock structure.
        BlockPtr = STRUCT_OF(IGMPBlockStruct, &IGMPBlockList, ibs_next);
        while (BlockPtr->ibs_next != NULL)
            BlockPtr = BlockPtr->ibs_next;

        Block.ibs_next = NULL;
        BlockPtr->ibs_next = &Block;
        CTEFreeLock(&IGMPLock, Handle);
        CTEBlock(&Block.ibs_block);
    } else {
        // Noone else here, set the flag so noone else gets in and free the
        // lock.
        IGMPBlockFlag = 1;
        CTEFreeLock(&IGMPLock, Handle);
    }

    // Now we're in the routine, and we won't be reentered here by another
    // thread of execution. Make sure everything's valid, and figure out
    // what to do.

    Status = IP_SUCCESS;

    // Now figure out the action to be performed.
    switch (ChangeType) {

    case IGMP_ADD:
        Status = JoinIGMPAddr(NTE, Addr, NumExclSources, ExclSourceList,
                                         NumInclSources, InclSourceList,
                              SrcAddr);
        break;

    case IGMP_DELETE:
        Status = LeaveIGMPAddr(NTE, Addr, NumExclSources, ExclSourceList,
                                          NumInclSources, InclSourceList,
                               SrcAddr);
        break;

    case IGMP_DELETE_ALL:
        Status = LeaveAllIGMPAddr(NTE, SrcAddr);
        break;

    default:
        DEBUGCHK;
        break;
    }

    // We finished the request, and Status contains the completion status.
    // If there are any pending blocks for this routine, signal the next
    // one now. Otherwise clear the block flag.
    CTEGetLock(&IGMPLock, &Handle);
    if ((BlockPtr = IGMPBlockList) != NULL) {
        // Someone is blocking. Pull him from the list and signal him.
        IGMPBlockList = BlockPtr->ibs_next;
        CTEFreeLock(&IGMPLock, Handle);

        CTESignal(&BlockPtr->ibs_block, IP_SUCCESS);
    } else {
        // No one blocking, just clear the flag.
        IGMPBlockFlag = 0;
        CTEFreeLock(&IGMPLock, Handle);
    }

    return Status;
}

//* GroupResponseTimeout - Called when group-response timer expires
// Assumes caller holds lock on NTE
// Caller is responsible for deleting AddrPtr if no longer needed
void
GroupResponseTimeout(
    IN OUT IGMPv3RecordQueueEntry **pI3qe,
    IN OUT IGMPReportQueueEntry   **pIqe,
    IN     NetTableEntry           *NTE,
    IN     IGMPAddr                *AddrPtr)
{
    uint IgmpVersion, BodyMTU, StateRecSize = 0;
    IGMPv3GroupRecord *StateRec = NULL;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("GroupResponseTimeout\n")));

    IgmpVersion = NTE->nte_if->IgmpVersion;
    BodyMTU = RECORD_MTU(NTE);

    if (IgmpVersion < IGMPV3) {
        QueueOldReport(pIqe, IGMP_ADD, IgmpVersion, AddrPtr->iga_addr);
        return;
    }

    if (AddrPtr->iga_resptype == GROUP_SOURCE_RESP) {
        StateRec = GetGSIsInRecord(AddrPtr, &StateRecSize);
    } else {
        // Group-specific response
        if (AddrPtr->iga_grefcnt == 0) {
           StateRec = GetIsInRecord(AddrPtr, &StateRecSize);
        } else {
           StateRec = GetIsExRecord(AddrPtr, &StateRecSize, BodyMTU);
        }
    }
    QueueRecord(pI3qe, &StateRec, StateRecSize);

    CancelGroupResponseTimer(AddrPtr);
}

//* RetransmissionTimeout - called when retransmission timer expires
//
// Caller is responsible for deleting Grp afterwards if no longer needed
void
RetransmissionTimeout(
    IN OUT IGMPv3RecordQueueEntry **pI3qe,
    IN OUT IGMPReportQueueEntry   **pIqe,
    IN     NetTableEntry           *NTE,
    IN     IGMPAddr                *Grp)
{
    IGMPv3GroupRecord *Rec = NULL;
    uint               RecSize = 0;
    uint               IgmpVersion, BodyMTU;

    DEBUGMSG(DBG_TRACE && DBG_IGMP && DBG_TX,
        (DTEXT("RetransmissionTimeout\n")));

    IgmpVersion = NTE->nte_if->IgmpVersion;

    BodyMTU = RECORD_MTU(NTE);

    if (IgmpVersion < IGMPV3) {
        // We decrement the counter here since the same function
        // is used to respond to queries.
        IgmpDecXmitLeft(Grp);

        QueueOldReport(pIqe, IGMP_ADD, IgmpVersion, Grp->iga_addr);
    } else {
        if (Grp->iga_changetype == MODE_CHANGE) {
            if (Grp->iga_grefcnt == 0) {
                Rec = GetToInRecord(Grp, &RecSize);
            } else {
                Rec = GetToExRecord(Grp, &RecSize, BodyMTU);
            }
            QueueRecord(pI3qe, &Rec, RecSize);
        } else {
            Rec = GetAllowRecord(Grp, &RecSize);
            QueueRecord(pI3qe, &Rec, RecSize);

            Rec = GetBlockRecord(Grp, &RecSize);
            QueueRecord(pI3qe, &Rec, RecSize);
        }
    }

    if (Grp->iga_xmitleft > 0) {
        Grp->iga_trtimer = IGMPRandomTicks(UNSOLICITED_REPORT_INTERVAL);
    }
}

//*     IGMPTimer - Handle an IGMP timer event.
//
//      This function is called every 500 ms. by IP. If we're at level 2 of
//      IGMP functionality we run down the NTE looking for running timers. If
//      we find one, we see if it has expired and if so we send an
//      IGMP report.
//
//      Input:  NTE             - Pointer to NTE to check.
//
//      Returns: Nothing.
//
void
IGMPTimer(
    IN NetTableEntry * NTE)
{
    CTELockHandle           Handle;
    IGMPAddr               *AddrPtr, *PrevPtr;
    uint                    IgmpVersion = 0, BodyMTU = 0, i;
    IPAddr                  SrcAddr = 0;
    IGMPAddr              **HashPtr;
    IGMPv3RecordQueueEntry *I3Head = NULL, *i3qe;
    IGMPReportQueueEntry   *OldHead = NULL, *iqe;

    i3qe = STRUCT_OF(IGMPv3RecordQueueEntry, &I3Head, i3qe_next);
    iqe  = STRUCT_OF(IGMPReportQueueEntry, &OldHead, iqe_next);

    if (IGMPLevel != 2) {
        return;
    }

    // We are doing IGMP. Run down the addresses active on this NTE.
    CTEGetLock(&NTE->nte_lock, &Handle);

    if (NTE->nte_flags & NTE_VALID) {

        //
        // If we haven't heard any query from an older version
        // router during timeout period, revert to newer version.
        // No need to check whether NTE is valid or not
        //
        if ((NTE->nte_if->IgmpVer2Timeout != 0)
        && (--(NTE->nte_if->IgmpVer2Timeout) == 0)) {
            NTE->nte_if->IgmpVersion = IGMPV3;
        }
        if ((NTE->nte_if->IgmpVer1Timeout != 0)
        && (--(NTE->nte_if->IgmpVer1Timeout) == 0)) {
            NTE->nte_if->IgmpVersion = IGMPV3;
        }
        if (NTE->nte_if->IgmpVer2Timeout != 0)
            NTE->nte_if->IgmpVersion = IGMPV2;
        if (NTE->nte_if->IgmpVer1Timeout != 0)
            NTE->nte_if->IgmpVersion = IGMPV1;

        if ((NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR) &&
            IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            SrcAddr = g_ValidAddr;
            if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                CTEFreeLock(&NTE->nte_lock, Handle);
                return;
            }
        } else {
            SrcAddr = NTE->nte_addr;
        }

        BodyMTU = RECORD_MTU(NTE);
        IgmpVersion = NTE->nte_if->IgmpVersion;

        HashPtr = NTE->nte_igmplist;

        for (i=0; (i<IGMP_TABLE_SIZE) && (NTE->nte_igmplist!=NULL); i++) {
            PrevPtr = STRUCT_OF(IGMPAddr, &HashPtr[i], iga_next);
            AddrPtr = PrevPtr->iga_next;
            while (AddrPtr != NULL) {

                // Hande group response timer
                if (AddrPtr->iga_resptimer != 0) {
                    AddrPtr->iga_resptimer--;
                    if ((AddrPtr->iga_resptimer == 0)
                     && (NTE->nte_flags & NTE_VALID)) {
                        GroupResponseTimeout(&i3qe, &iqe, NTE, AddrPtr);
                    }
                }

                // Handle triggered retransmission timer
                if (AddrPtr->iga_trtimer != 0) {
                    AddrPtr->iga_trtimer--;
                    if ((AddrPtr->iga_trtimer == 0)
                     && (NTE->nte_flags & NTE_VALID)) {
                        RetransmissionTimeout(&i3qe, &iqe, NTE, AddrPtr);
                    }
                }

                // Delete group if no longer needed
                if (IS_GROUP_DELETABLE(AddrPtr)) {
                    DeleteIGMPAddr(NTE, PrevPtr, &AddrPtr);
                    AddrPtr = PrevPtr;
                }

                if (NTE->nte_igmplist == NULL) {
                    // PrevPtr is gone
                    break;
                }

                //
                // Go on to the next one.
                //
                PrevPtr = AddrPtr;
                AddrPtr = AddrPtr->iga_next;
            }
        }

        // Check general query timer
        if ((NTE->nte_if->IgmpGeneralTimer != 0)
        && (--(NTE->nte_if->IgmpGeneralTimer) == 0)) {
            QueueIGMPv3GeneralResponse(&i3qe, NTE);
        }
    }                        //nte_valid

    CTEFreeLock(&NTE->nte_lock, Handle);

    if (IgmpVersion == IGMPV3)
        SendIGMPv3Reports(I3Head, SrcAddr, BodyMTU);
    else
        SendOldReports(OldHead, SrcAddr);
}

//* IsMCastSourceAllowed - check if incoming packet passes interface filter
//
// Returns: DEST_MCAST if allowed, DEST_LOCAL if not.
uchar
IsMCastSourceAllowed(
    IN IPAddr         Dest,
    IN IPAddr         Source,
    IN uchar          Protocol,
    IN NetTableEntry *NTE)
{
    CTELockHandle Handle;
    uchar         Result = DEST_LOCAL;
    IGMPAddr     *AddrPtr = NULL;
    IGMPSrcAddr  *SrcPtr = NULL;

    if (IGMPLevel != 2) {
        return DEST_LOCAL;
    }

    // IGMP Queries must be immune to source filters or else
    // we might not be able to respond to group-specific queries
    // from the querier and hence lose data.
    if (Protocol == PROT_IGMP) {
        return DEST_MCAST;
    }

    CTEGetLock(&NTE->nte_lock, &Handle);
    {
        AddrPtr = FindIGMPAddr(NTE, Dest, NULL);
        if (AddrPtr != NULL) {
            SrcPtr = FindIGMPSrcAddr(AddrPtr, Source, NULL);

            if (SrcPtr) {
                if (IS_SOURCE_ALLOWED(AddrPtr, SrcPtr))
                    Result = DEST_MCAST;
            } else {
                if (IS_GROUP_ALLOWED(AddrPtr))
                    Result = DEST_MCAST;
            }
        }
    }
    CTEFreeLock(&NTE->nte_lock, Handle);

    return Result;
}

//*     InitIGMPForNTE - Called to do per-NTE initialization.
//
//      Called when an NTE becomes valid. If we're at level 2, we put the
//      all-host mcast on the list and add the address to the interface.
//
//      Input:  NTE                     - NTE on which to act.
//
//      Returns: Nothing.
//
void
InitIGMPForNTE(
    IN NetTableEntry * NTE)
{
    if (IGMPLevel == 2) {
        IGMPAddrChange(NTE, ALL_HOST_MCAST, IGMP_ADD, 0, NULL, 0, NULL);
    }
    if (Seed == 0) {
        // No random seed yet.
        Seed = (int)NTE->nte_addr;

        // Make sure the inital value is odd, and less than 9 decimal digits.
        RandomValue = ((Seed + (int)CTESystemUpTime()) % 100000000) | 1;
    }
}

//*     StopIGMPForNTE - Called to do per-NTE shutdown.
//
//      Called when we're shutting down an NTE, and want to stop IGMP on it,
//
//      Input:  NTE                     - NTE on which to act.
//
//      Returns: Nothing.
//
void
StopIGMPForNTE(
    IN NetTableEntry * NTE)
{
    if (IGMPLevel == 2) {
        IGMPAddrChange(NTE, NULL_IP_ADDR, IGMP_DELETE_ALL,
                       0, NULL, 0, NULL);
    }
}

#pragma BEGIN_INIT

//** IGMPInit - Initialize IGMP.
//
//      This bit of code initializes IGMP generally. There is also some amount
//      of work done on a per-NTE basis that we do when each one is initialized.
//
//      Input:  Nothing.
///
//  Returns: TRUE if we init, FALSE if we don't.
//
uint
IGMPInit(void)
{
    DEBUGMSG(DBG_INFO && DBG_IGMP,
        (DTEXT("Initializing IGMP\n")));

    if (IGMPLevel != 2)
        return TRUE;

    CTEInitLock(&IGMPLock);
    IGMPBlockList = NULL;
    IGMPBlockFlag = 0;
    Seed = 0;

    IGMPProtInfo = IPRegisterProtocol(PROT_IGMP, IGMPRcv, IGMPSendComplete,
                                      NULL, NULL, NULL, NULL);

    if (IGMPProtInfo != NULL)
        return TRUE;
    else
        return FALSE;
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\igmp.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** IGMP.H - IP multicast definitions.
//
// This file contains definitions related to IP multicast.

// IP protocol number for IGMP
#define    PROT_IGMP    2

extern uint IGMPLevel;
extern HANDLE IcmpHeaderPool;

// Structure used for local mcast address tracking.
typedef struct IGMPAddr {
    struct IGMPAddr    *iga_next;
    struct IGMPSrcAddr *iga_srclist;
    IPAddr              iga_addr;
    uint                iga_grefcnt;   // # sockets joining whole group
    uint                iga_isrccnt;   // # sources with isa_irefcnt>0
    uint                iga_resptimer; // query response timer
    uint                iga_resptype;  // response type
    uint                iga_trtimer;   // triggered report timer
    uchar               iga_changetype;// triggered change type
    uchar               iga_xmitleft;  // triggered xmit's left
} IGMPAddr;

// Values of iga_resptype
#define NO_RESP           0
#define GROUP_RESP        1
#define GROUP_SOURCE_RESP 2

// Values of iga_changetype
#define NO_CHANGE         0
#define MODE_CHANGE       1
#define SOURCE_CHANGE     2

typedef struct IGMPSrcAddr {
    struct IGMPSrcAddr  *isa_next;
    IPAddr               isa_addr;
    uint                 isa_irefcnt;  // # sockets Including this source
    uint                 isa_xrefcnt;  // # sockets Excluding this source
    uchar                isa_xmitleft; // triggered xmit's left
    uchar                isa_csmarked; // response xmit's left
} IGMPSrcAddr;

#define    IGMP_ADD           0
#define    IGMP_DELETE        1
#define    IGMP_DELETE_ALL    2
#define    IGMP_CHANGE        3

#define    IGMPV1             2       //IGMP version 1
#define    IGMPV2             3       //IGMP version 2
#define    IGMPV3             4       //IGMP version 3

extern void InitIGMPForNTE(NetTableEntry *NTE);
extern void StopIGMPForNTE(NetTableEntry *NTE);
extern    IP_STATUS IGMPAddrChange(NetTableEntry *NTE, IPAddr Addr,
                                   uint ChangeType,
                                   uint NumExclSources, IPAddr *ExclSourceList,
                                   uint NumEnclSources, IPAddr *InclSourceList);
extern  IP_STATUS IGMPInclChange(NetTableEntry *NTE, IPAddr Addr,
                                 uint NumAddSources, IPAddr *AddSourceList,
                                 uint NumDelSources, IPAddr *DelSourceList);
extern  IP_STATUS IGMPExclChange(NetTableEntry *NTE, IPAddr Addr,
                                 uint NumAddSources, IPAddr *AddSourceList,
                                 uint NumDelSources, IPAddr *DelSourceList);
extern void    IGMPTimer(NetTableEntry *NTE);
extern uchar IsMCastSourceAllowed(IPAddr Dest, IPAddr Src, uchar Protocol, NetTableEntry *NTE);

#define IGMP_TABLE_SIZE      32
#define IGMP_HASH(x)         ((((uchar *)&(x))[3]) % IGMP_TABLE_SIZE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\internaldef.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */
#ifndef INTERNALDEF_H_INCLUDED
#define INTERNALDEF_H_INCLUDED

typedef struct _UNICODE_STRING_NEW {
    ULONG  Length;
    ULONG  MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING_NEW;
typedef UNICODE_STRING_NEW *PUNICODE_STRING_NEW;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ipinit.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** IPINIT.H - IP initialization definitions.
//
// This file contains all of the definitions for IP that are
// init. time specific.
#ifndef _IPINIT_H_
#define _IPINIT_H_  1

#define IP_INIT_FAILURE     0   // If we fail.
#define IP_INIT_SUCCESS     1
#define CFG_REQUIRED        1
#define CFG_OPTIONAL        0


#define NET_TYPE_LAN        0   // The local net interface is a LAN.
#define NET_TYPE_WAN        1   // Point to point or other non-LAN network.
#define DEFAULT_TTL         128
#define DEFAULT_TOS         0

#define MINIMUM_MAX_NORM_LOOKUP_MEM           100000 // Bytes => A small value
#define MINIMUM_MAX_FAST_LOOKUP_MEM           100000 // Bytes => A small value

// Small System [ 19 MB- Srv ]
#define DEFAULT_MAX_NORM_LOOKUP_MEM_SMALL     150000 // Bytes => ~1000 Routes
#define DEFAULT_MAX_FAST_LOOKUP_MEM_SMALL          0 // FTrie Disabled
#define DEFAULT_EXPN_LEVELS_SMALL                  0 // FTrie Disabled

// Medium System [ 19 to 64 MB Srv ]
#define DEFAULT_MAX_NORM_LOOKUP_MEM_MEDIUM   1500000 // Bytes => ~10000 Routes
#define DEFAULT_MAX_FAST_LOOKUP_MEM_MEDIUM   2500000 // Bytes => A 2.5 MB limit
#define DEFAULT_EXPN_LEVELS_MEDIUM        0x80808080 // Levels =>{8, 16, 24, 32}

// Large System [ 64 MB+ Srv ]
#define DEFAULT_MAX_NORM_LOOKUP_MEM_LARGE    5000000 // Bytes => ~40000 Routes
#define DEFAULT_MAX_FAST_LOOKUP_MEM_LARGE    5000000 // Bytes => A 5.0 MB limit
#define DEFAULT_EXPN_LEVELS_LARGE         0x80808080 // Levels =>{8, 16, 24, 32}

#define MAX_DEFAULT_GWS     5   // Maximum number of default gateways per net.
#define MAX_NAME_SIZE       32  // Maximum length of an adapter name.

#define DEFAULT_FW_PACKETS  50     // Default number of packets for forwarding.
#define DEFAULT_FW_BUFSIZE  74240  // Enough for 50 1480-byte Ethernet packets,
                                   //   rounded up to a multiple of 256.

#define DEFAULT_MAX_FW_PACKETS  0xffffffff
//#define   DEFAULT_MAX_FW_BUFSIZE  0xffffffff
#define DEFAULT_MAX_FW_BUFSIZE   2097152     // put the limit as 2 Mb

#define DEFAULT_MAX_PENDING 5000

#define TR_RII_ALL      0x80
#define TR_RII_SINGLE   0xC0

#define DEFAULT_ARP_CACHE_LIFE  (2L*60L)  // 2 minutes
#define DEFAULT_ARP_MIN_VALID_CACHE_LIFE    (10L*60L) // 10 miniutes

#define DEFAULT_ARP_RETRY_COUNT 1
/*NOINC*/

// Per-net config structures
typedef struct IFGeneralConfig {
    uint        igc_zerobcast;      // Type of broadcast to be used on this net.
    uint        igc_mtu;            // Max MSS for this net.
    uint        igc_maxpending;     // Max FW pending on this IF.
    uint        igc_numgws;         // Number of default gateways for this
                                    // interface.
    IPAddr      igc_gw[MAX_DEFAULT_GWS];    // Array of IPaddresses for gateways
    uint        igc_gwmetric[MAX_DEFAULT_GWS];
    uint        igc_metric;         // metric for NTE routes
    uchar       igc_dfencap;
    uchar       igc_rtrdiscovery;   // Router discovery enabled
    IPAddr      igc_rtrdiscaddr;    // Multicast or BCast?
    uint        igc_TcpWindowSize;  //IF specific window size
    uint        igc_TcpInitialRTT;  // initial rtt in msecs
    uchar       igc_TcpDelAckTicks; // delayed ack timer in ticks
    uchar       igc_TcpAckFrequency;// sends before an ack is sent
    uchar       igc_iftype;         // type of interface: allow unicast/mcast/both
    uchar       igc_disablemediasense;  // allow mediasense on interface?
} IFGeneralConfig;

typedef struct IFAddrList {
    IPAddr      ial_addr;           // Address for this interface.
    IPMask      ial_mask;           // Mask to go with this.
} IFAddrList;


/*INC*/

//* Structure of configuration information. A pointer to this information
//  is returned from a system-specific config. information routine.
typedef struct IPConfigInfo {
    uint    ici_gateway;            // 1 if we are a gateway, 0 otherwise
    uint    ici_fwbcast;            // 1 if bcasts should be forwarded. Else 0.
    uint    ici_fwbufsize;          // Total size of FW buf size.
    uint    ici_fwpackets;          // Total number of FW packets to have.
    uint    ici_maxfwbufsize;       // Maximum size of FW buffer.
    uint    ici_maxfwpackets;       // Maximum number of FW packets.
    uint    ici_deadgwdetect;       // True if we're doing dead GW detection.
    uint    ici_pmtudiscovery;      // True if we're doing Path MTU discovery.
    uint    ici_igmplevel;          // Level of IGMP we're doing.
    uint    ici_ttl;                // Default TTL.
    uint    ici_tos;                // Default TOS;
    uint    ici_addrmaskreply;      // 0 by default
    uint    ici_fastroutelookup;    // True if we have 'fast route lookup' enabled
    uint    ici_fastlookuplevels;   // Bitmap of levels in the fast lookup scheme
    uint    ici_maxnormlookupmemory;// Max memory used for the norm lookup scheme
    uint    ici_maxfastlookupmemory;// Max memory used for the fast lookup scheme
    uint    ici_TrFunctionalMcst;   //Defaults to true,  RFC 1469
} IPConfigInfo;

extern  uchar   TrRii;

typedef struct SetAddrControl {
    void                *sac_rtn;        // Pointer to routine to call when completing request.
    void             *interface;
    ushort           nte_context;
    BOOLEAN          StaticAddr;
} SetAddrControl;

/*NOINC*/
typedef void    (*SetAddrRtn)(void *, IP_STATUS);
/*INC*/

#endif // _IPINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\info.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  info.c - Routines for querying and setting IP information.

Abstract:

  This file contains the code for dealing with Query/Set information calls.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "info.h"
#include "iproute.h"
#include "igmp.h"
#include "iprtdef.h"
#include "arpdef.h"
#include "ntddndis.h"
#include "tcpipbuf.h"

extern NDIS_HANDLE BufferPool;
extern Interface *IFList;
extern NetTableEntry **NewNetTableList;        // hash table for NTEs
extern uint NET_TABLE_SIZE;
extern uint LoopIndex;            // Index of loopback I/F.
extern uint DefaultTTL;
extern uint NumIF;
extern uint NumNTE;
extern uint NumActiveNTE;
extern RouteInterface DummyInterface;    // Dummy interface.
extern NetTableEntry *LoopNTE;    // Pointer to loopback NTE
extern uint RTEReadNext(void *Context, void *Buffer);
extern uint RTValidateContext(void *Context, uint * Valid);
extern uint RTReadNext(void *Context, void *Buffer);
extern uint RTRead(void *Context, void *Buffer);
extern void IPInitOptions(IPOptInfo *);

uint IPInstance = (UINT) INVALID_ENTITY_INSTANCE;
uint ICMPInstance = (UINT) INVALID_ENTITY_INSTANCE;
TDIEntityID* IPEntityList = NULL;
uint IPEntityCount = 0;

#if FFP_SUPPORT
FFPDriverStats GlobalStatsInfoPrev = {0};   // Stats from the previous request
FFPDriverStats GlobalStatsInfoCurr = {0};   // Stats from the current request
#endif // if FFP_SUPPORT

#define MIB_IPADDR_PRIMARY 1

//* CopyToNdisSafe - Copy a flat buffer to an NDIS_BUFFER chain.
//
//  A utility function to copy a flat buffer to an NDIS buffer chain. We
//  assume that the NDIS_BUFFER chain is big enough to hold the copy amount;
//  in a debug build we'll  debugcheck if this isn't true. We return a pointer
//  to the buffer where we stopped copying, and an offset into that buffer.
//  This is useful for copying in pieces into the chain.
//
//  Input:  DestBuf     - Destination NDIS_BUFFER chain.
//          pNextBuf    - Pointer to next buffer in chain to copy into.
//          SrcBuf      - Src flat buffer.
//          Size        - Size in bytes to copy.
//          StartOffset - Pointer to start of offset into first buffer in
//                          chain. Filled in on return with the offset to
//                          copy into next.
//
//  Returns: TRUE  - Successfully copied flat buffer into NDIS_BUFFER chain.
//           FALSE - Failed to copy entire flat buffer.
//

BOOLEAN
CopyToNdisSafe(PNDIS_BUFFER DestBuf, PNDIS_BUFFER * ppNextBuf,
               uchar * SrcBuf, uint Size, uint * StartOffset)
{
    uint CopySize;
    uchar *DestPtr;
    uint DestSize;
    uint Offset = *StartOffset;
    uchar *VirtualAddress;
    uint Length;

    ASSERT(DestBuf != NULL);
    ASSERT(SrcBuf != NULL);

    TcpipQueryBuffer(DestBuf, &VirtualAddress, &Length, NormalPagePriority);

    if (VirtualAddress == NULL) {
        return (FALSE);
    }
    ASSERT(Length >= Offset);
    DestPtr = VirtualAddress + Offset;
    DestSize = Length - Offset;

    for (;;) {
        CopySize = MIN(Size, DestSize);
        RtlCopyMemory(DestPtr, SrcBuf, CopySize);

        DestPtr += CopySize;
        SrcBuf += CopySize;

        if ((Size -= CopySize) == 0)
            break;

        if ((DestSize -= CopySize) == 0) {
            DestBuf = NDIS_BUFFER_LINKAGE(DestBuf);
            ASSERT(DestBuf != NULL);

            TcpipQueryBuffer(DestBuf, &VirtualAddress, &Length, NormalPagePriority);

            if (VirtualAddress == NULL) {
                return FALSE;
            }
            DestPtr = VirtualAddress;
            DestSize = Length;
        }
    }

    *StartOffset = (uint) (DestPtr - VirtualAddress);

    if (ppNextBuf) {
        *ppNextBuf = DestBuf;
    }
    return TRUE;
}

// this structure is used in IPQueryInfo for IP_MIB_ADDRTABLE_ENTRY_ID
typedef struct _INFO_LIST {
    struct _INFO_LIST *info_next;
    NetTableEntry *info_nte;
} INFO_LIST, *PINFO_LIST;

//* FreeInfoList  - Free INFO_LIST used in IPQueryInfo for IP_MIB_ADDRTABLE_ENTRY_ID
//
// Input: Temp   - List to be freed
//
// Returns: Nothing.
//

void
FreeInfoList(PINFO_LIST Temp)
{
    PINFO_LIST NextTemp;
    PINFO_LIST CurrTemp = Temp;

    while (CurrTemp) {
        NextTemp = CurrTemp->info_next;
        CTEFreeMem(CurrTemp);
        CurrTemp = NextTemp;
    }
}

//* IPQueryInfo - IP query information handler.
//
//  Called by the upper layer when it wants to query information about us.
//  We take in an ID, a buffer and length, and a context value, and return
//  whatever information we can.
//
//  Input:  ID          - Pointer to ID structure.
//          Buffer      - Pointer to buffer chain.
//          Size        - Pointer to size in bytes of buffer. On return, filled
//                          in with bytes read.
//          Context     - Pointer to context value.
//
//  Returns: TDI_STATUS of attempt to read information.
//
long
IPQueryInfo(TDIObjectID * ID, PNDIS_BUFFER Buffer, uint * Size, void *Context)
{
    uint BufferSize = *Size;
    uint BytesCopied = 0;
    uint Offset = 0;
    TDI_STATUS Status;
    ushort NTEContext;
    uchar InfoBuff[sizeof(IPRouteEntry)];
    IPAddrEntry *AddrEntry;
    NetTableEntry *CurrentNTE = NULL;
    uint Valid, DataLeft;
    CTELockHandle Handle;
    Interface *LowerIF = NULL;
    IPInterfaceInfo *IIIPtr;
    uint Entity;
    uint Instance;
    IPAddr IFAddr;
    uint i;
    NetTableEntry *NetTableList;
    CTELockHandle TableHandle;
    IPInternalPerCpuStats SumCpuStats;

    BOOLEAN fStatus;

     DEBUGMSG(DBG_TRACE && DBG_QUERYINFO,
         (DTEXT("+IPQueryInfo(%x, %x, %x, %x)\n"), ID, Buffer, Size, Context));

    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // See if it's something we might handle.

    if (Entity != CL_NL_ENTITY && Entity != ER_ENTITY) {
        // We need to pass this down to the lower layer. Loop through until
        // we find one that takes it. If noone does, error out.

        CTEGetLock(&RouteTableLock.Lock, &TableHandle);

        LowerIF = IFList;

        while (LowerIF) {
            if (LowerIF->if_flags & IF_FLAGS_DELETING) {
                // this interface is about to get deleted
                // fail the request
                // we can also skip this interface
                LowerIF = LowerIF->if_next;
                continue;
            }
            LOCKED_REFERENCE_IF(LowerIF);
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            // we have freed the routetablelock here
            // but since we have a refcount on LowerIF, LowerIF can't go away
            Status = (*LowerIF->if_qinfo) (LowerIF->if_lcontext, ID, Buffer,
                                           Size, Context);
            if (Status != TDI_INVALID_REQUEST) {
                DerefIF(LowerIF);
                return Status;
            }
            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            LockedDerefIF(LowerIF);
            // LowerIF->if_next can't be freed at this point.
            LowerIF = LowerIF->if_next;
        }

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

        // If we get here, noone took it. Return an error.
        return TDI_INVALID_REQUEST;

    }
    if ((Entity == CL_NL_ENTITY && Instance != IPInstance) ||
        Instance != ICMPInstance)
        return TDI_INVALID_REQUEST;

    // The request is for us.
    *Size = 0;                    // Set to 0 in case of an error.

    // Make sure it's something we support.
    if (ID->toi_class == INFO_CLASS_GENERIC) {
        if (ID->toi_type == INFO_TYPE_PROVIDER && ID->toi_id == ENTITY_TYPE_ID) {
            // He's trying to see what type we are.
            if (BufferSize >= sizeof(uint)) {
                *(uint *) & InfoBuff[0] = (Entity == CL_NL_ENTITY) ? CL_NL_IP :
                    ER_ICMP;
                fStatus = CopyToNdisSafe(Buffer, NULL, InfoBuff, sizeof(uint), &Offset);

                if (fStatus == FALSE) {
                    return TDI_NO_RESOURCES;
                }
                *Size = sizeof(uint);
                return TDI_SUCCESS;
            } else
                return TDI_BUFFER_TOO_SMALL;
        }
        return TDI_INVALID_PARAMETER;
    } else if (ID->toi_class != INFO_CLASS_PROTOCOL ||
               ID->toi_type != INFO_TYPE_PROVIDER)
        return TDI_INVALID_PARAMETER;

    // If it's ICMP, just copy the statistics.
    if (Entity == ER_ENTITY) {

        // It is ICMP. Make sure the ID is valid.
        if (ID->toi_id != ICMP_MIB_STATS_ID)
            return TDI_INVALID_PARAMETER;

        // He wants the stats. Copy what we can.
        if (BufferSize < sizeof(ICMPSNMPInfo))
            return TDI_BUFFER_TOO_SMALL;

        fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) & ICMPInStats, sizeof(ICMPStats), &Offset);

        if (fStatus == TRUE) {
            fStatus = CopyToNdisSafe(Buffer, NULL, (uchar *) & ICMPOutStats, sizeof(ICMPStats),
                                     &Offset);

            if (fStatus == TRUE) {
                *Size = sizeof(ICMPSNMPInfo);
                return TDI_SUCCESS;
            }
        }
        return (TDI_NO_RESOURCES);
    }
    // It's not ICMP. We need to figure out what it is, and take the
    // appropriate action.

    switch (ID->toi_id) {

    case IP_MIB_STATS_ID:
        if (BufferSize < sizeof(IPSNMPInfo))
            return TDI_BUFFER_TOO_SMALL;
        IPSInfo.ipsi_numif = NumIF;
        IPSInfo.ipsi_numaddr = NumActiveNTE;
        IPSInfo.ipsi_defaultttl = DefaultTTL;
        IPSInfo.ipsi_forwarding = ForwardPackets ? IP_FORWARDING :
            IP_NOT_FORWARDING;

#if FFP_SUPPORT
        //
        // Tweak SNMP information to include information from FFP'ed packets
        //

        // Keep a copy of the prev stats for use
        RtlCopyMemory(&GlobalStatsInfoPrev, &GlobalStatsInfoCurr, sizeof(FFPDriverStats));

        // Get the stats by querying the driver
        IPStatsFromFFPCaches(&GlobalStatsInfoCurr);

        // These counts missed packets fast fwded from last time a query was made

        IPPerCpuStats[0].ics_inreceives +=
            GlobalStatsInfoCurr.PacketsForwarded - GlobalStatsInfoPrev.PacketsForwarded;

        IPSInfo.ipsi_forwdatagrams +=
            GlobalStatsInfoCurr.PacketsForwarded - GlobalStatsInfoPrev.PacketsForwarded;

        // These counts missed all packets dropped from last time a query was made

        IPPerCpuStats[0].ics_inreceives +=
            GlobalStatsInfoCurr.PacketsDiscarded - GlobalStatsInfoPrev.PacketsDiscarded;

        IPSInfo.ipsi_outdiscards +=
            GlobalStatsInfoCurr.PacketsDiscarded - GlobalStatsInfoPrev.PacketsDiscarded;
#endif // if FFP_SUPPORT

#if !MILLEN
        IPSGetTotalCounts(&SumCpuStats);
        IPSInfo.ipsi_inreceives = SumCpuStats.ics_inreceives;
        IPSInfo.ipsi_indelivers = SumCpuStats.ics_indelivers;
#endif


        fStatus = CopyToNdisSafe(Buffer, NULL, (uchar *) & IPSInfo, sizeof(IPSNMPInfo), &Offset);

        if (fStatus == TRUE) {
            BytesCopied = sizeof(IPSNMPInfo);
            Status = TDI_SUCCESS;
        } else {
            Status = TDI_NO_RESOURCES;
        }
        break;
    case IP_MIB_ADDRTABLE_ENTRY_ID:
        {

            PINFO_LIST PrimaryList, NonDynamicList, DynamicList, UniList;
            PINFO_LIST LastPrimaryEle, LastNonDynamicEle, LastDynamicEle, LastUniEle;
            PINFO_LIST SavedTempInfo = NULL;
            PINFO_LIST tempInfo;
            PINFO_LIST FinalList, LastFinalListEle;
            PINFO_LIST CurrentNTEInfo;

            // He wants to read the address table. Figure out where we're
            // starting from, and if it's valid begin copying from there.
            NTEContext = *(ushort *) Context;

            // Build 3 lists: Primary, nondynamic nonprimary and dynamic

            PrimaryList = NULL;
            NonDynamicList = NULL;
            DynamicList = NULL;
            UniList = NULL;

            LastPrimaryEle = NULL;
            LastNonDynamicEle = NULL;
            LastDynamicEle = NULL;
            LastUniEle = NULL;

            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            
            for (i = 0; i < NET_TABLE_SIZE; i++) {
                for (CurrentNTE = NewNetTableList[i];
                     CurrentNTE != NULL;
                     CurrentNTE = CurrentNTE->nte_next) {

                    if ((CurrentNTE->nte_flags & NTE_VALID) &&
                        (CurrentNTE->nte_if->if_flags & IF_FLAGS_UNI)) {
                        // allocate the block to store the info
                        tempInfo = CTEAllocMemN(sizeof(INFO_LIST), '1ICT');
                        if (!tempInfo) {
                            goto Error;
                        }
                        if (UniList == NULL) {
                            // this is the last element in this list
                            LastUniEle = tempInfo;
                        }
                        tempInfo->info_nte = CurrentNTE;
                        tempInfo->info_next = UniList;
                        UniList = tempInfo;

                    } else if (CurrentNTE->nte_flags & NTE_PRIMARY) {
                        // allocate the block to store the info
                        tempInfo = CTEAllocMemN(sizeof(INFO_LIST), '1ICT');
                        if (!tempInfo) {
                            goto Error;
                        }
                        if (PrimaryList == NULL) {
                            // this is the last element in this list
                            LastPrimaryEle = tempInfo;
                        }
                        tempInfo->info_nte = CurrentNTE;
                        tempInfo->info_next = PrimaryList;
                        PrimaryList = tempInfo;
                    } else if (CurrentNTE->nte_flags & NTE_DYNAMIC) {
                        // allocate the block to store the info
                        tempInfo = CTEAllocMemN(sizeof(INFO_LIST), '1ICT');
                        if (!tempInfo) {
                            goto Error;
                        }
                        if (DynamicList == NULL) {
                            // this is the last element in this list
                            LastDynamicEle = tempInfo;
                        }
                        tempInfo->info_nte = CurrentNTE;
                        tempInfo->info_next = DynamicList;
                        DynamicList = tempInfo;
                    } else {
                        INFO_LIST** nextInfo;
                        // Non primary non Dynamic list
                        // allocate the block to store the info
                        tempInfo = CTEAllocMemN(sizeof(INFO_LIST), '1ICT');
                        if (!tempInfo) {
                            goto Error;
                        }

                        // Even though we are reading from a hash-table,
                        // we need to preserve the ordering of entries
                        // as given on the entries' interfaces' 'if_ntelist'.
                        // Attempt to find the entry for this NTE's predecessor
                        // and, if found, place this entry before that.
                        // This builds the list in reverse order, and ensures
                        // that an entry whose predecessor is not on the list
                        // will appear last.

                        for (nextInfo = &NonDynamicList;
                             (*nextInfo) &&
                             (*nextInfo)->info_nte->nte_ifnext != CurrentNTE;
                             nextInfo = &(*nextInfo)->info_next) { }
                        tempInfo->info_nte = CurrentNTE;
                        tempInfo->info_next = *nextInfo;
                        *nextInfo = tempInfo;
                        if (!tempInfo->info_next)
                            LastNonDynamicEle = tempInfo;
                    }
                    if (NTEContext != 0) {
                        if (CurrentNTE->nte_context == NTEContext) {
                            SavedTempInfo = tempInfo;
                        }
                    }
                } // for (CurrentNTE ...
            } // for (i= ...

            // at this point we have 4 lists and we have to merge 4 lists
            // order should be Uni -> Dynamic -> NonDynamic -> Primary

            FinalList = NULL;
            LastFinalListEle = NULL;

            if (UniList) {
                if (FinalList == NULL) {
                    FinalList = UniList;
                    LastFinalListEle = LastUniEle;
                } else {
                    LastFinalListEle->info_next = UniList;
                    LastFinalListEle = LastUniEle;
                }
            }
            if (DynamicList) {
                if (FinalList == NULL) {
                    FinalList = DynamicList;
                    LastFinalListEle = LastDynamicEle;
                } else {
                    LastFinalListEle->info_next = DynamicList;
                    LastFinalListEle = LastDynamicEle;
                }
            }
            if (NonDynamicList) {
                if (FinalList == NULL) {
                    FinalList = NonDynamicList;
                    LastFinalListEle = LastNonDynamicEle;
                } else {
                    LastFinalListEle->info_next = NonDynamicList;
                    LastFinalListEle = LastNonDynamicEle;
                }
            }
            if (PrimaryList) {
                if (FinalList == NULL) {
                    FinalList = PrimaryList;
                    LastFinalListEle = LastPrimaryEle;
                } else {
                    LastFinalListEle->info_next = PrimaryList;
                    LastFinalListEle = LastPrimaryEle;
                }
            }

#if MILLEN

#if DBG
            if (DBG_INFO && DBG_VERBOSE && DBG_QUERYINFO) {
                DEBUGMSG(1,
                    (DTEXT("IP_MIB_ADDRTABLE_ENTRY_ID: List before reverse:\n")));

                CurrentNTEInfo = FinalList;
                while (CurrentNTEInfo) {
                    DEBUGMSG(1, (DTEXT("    InfoList: %x NTE\n"), CurrentNTEInfo, CurrentNTEInfo->info_nte));
                    CurrentNTEInfo = CurrentNTEInfo->info_next;
                }
            }
#endif

            // Now guess what Win9X requires us to...reverse the list. It
            // expects that the primary is at the start of the list.
            {
                PINFO_LIST pCurrInfo, pPrevInfo, pNextInfo;

                pCurrInfo = FinalList;
                pPrevInfo = NULL;

                // Exchange final pointers.
                FinalList = LastFinalListEle;
                LastFinalListEle = pCurrInfo;

                while (pCurrInfo) {
                    pNextInfo = pCurrInfo->info_next;
                    pCurrInfo->info_next = pPrevInfo;
                    pPrevInfo = pCurrInfo;
                    pCurrInfo = pNextInfo;
                }
            }

#if DBG
            if (DBG_INFO && DBG_VERBOSE && DBG_QUERYINFO) {
                DEBUGMSG(1,
                    (DTEXT("IP_MIB_ADDRTABLE_ENTRY_ID: List after reverse:\n")));

                CurrentNTEInfo = FinalList;
                while (CurrentNTEInfo) {
                    DEBUGMSG(1, (DTEXT("    InfoList: %x NTE\n"), CurrentNTEInfo, CurrentNTEInfo->info_nte));
                    CurrentNTEInfo = CurrentNTEInfo->info_next;
                }
            }
#endif
#endif // MILLEN

            // we have at least loopback NTE
            ASSERT(FinalList != NULL);

            // At this point we have the whole list and also if the user specified NTEContext
            // we have the pointer saved in SavedTempInfo

            if (SavedTempInfo) {
                CurrentNTEInfo = SavedTempInfo;
            } else {
                CurrentNTEInfo = FinalList;
            }

            AddrEntry = (IPAddrEntry *) InfoBuff;
            fStatus = TRUE;

            for (; CurrentNTEInfo != NULL; CurrentNTEInfo = CurrentNTEInfo->info_next) {

                // NetTableEntry *CurrentNTE = CurrentNTEInfo->info_nte;
                CurrentNTE = CurrentNTEInfo->info_nte;
                if (CurrentNTE->nte_flags & NTE_ACTIVE) {
                    if ((int)(BufferSize - BytesCopied) >= (int)sizeof(IPAddrEntry)) {
                        // We have room to copy it. Build the entry, and copy
                        // it.
                        if (CurrentNTE->nte_flags & NTE_VALID) {
                            AddrEntry->iae_addr = CurrentNTE->nte_addr;
                            AddrEntry->iae_mask = CurrentNTE->nte_mask;
                        } else {
                            AddrEntry->iae_addr = NULL_IP_ADDR;
                            AddrEntry->iae_mask = NULL_IP_ADDR;
                        }

                        if (CurrentNTE->nte_if->if_flags & IF_FLAGS_DELETING) {
                            AddrEntry->iae_index = INVALID_IF_INDEX;
                            AddrEntry->iae_bcastaddr = 0;
                        } else {
                            AddrEntry->iae_index =
                                CurrentNTE->nte_if->if_index;
                            AddrEntry->iae_bcastaddr =
                                *(int *)&(CurrentNTE->nte_if->if_bcast) & 1;
                        }
                        AddrEntry->iae_reasmsize = 0xffff;
                        AddrEntry->iae_context = CurrentNTE->nte_context;

                        // LSB will have primary bit set if this is PRIMARY NTE

                        ASSERT((NTE_PRIMARY >> 2) == MIB_IPADDR_PRIMARY);

                        AddrEntry->iae_pad = CurrentNTE->nte_flags >> 2;

                        fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) AddrEntry,
                                                 sizeof(IPAddrEntry), &Offset);

                        if (fStatus == FALSE) {
                            break;
                        }
                        BytesCopied += sizeof(IPAddrEntry);
                    } else
                        break;
                }
            }

            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            
            if (fStatus == FALSE) {
                Status = TDI_NO_RESOURCES;
            } else if (CurrentNTEInfo == NULL) {
                Status = TDI_SUCCESS;
            } else {
                Status = TDI_BUFFER_OVERFLOW;
                **(ushort **) & Context = CurrentNTE->nte_context;
            }

            // free the list
            FreeInfoList(FinalList);

            break;

        Error:
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            
            // free all the lists
            FreeInfoList(PrimaryList);
            FreeInfoList(NonDynamicList);
            FreeInfoList(DynamicList);
            FreeInfoList(UniList);
            return TDI_NO_RESOURCES;
            
        }
    case IP_MIB_RTTABLE_ENTRY_ID:
        // Make sure we have a valid context.
        CTEGetLock(&RouteTableLock.Lock, &Handle);
        DataLeft = RTValidateContext(Context, &Valid);

        // If the context is valid, we'll continue trying to read.
        if (!Valid) {
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            return TDI_INVALID_PARAMETER;
        }
        fStatus = TRUE;

        while (DataLeft) {
            // The invariant here is that there is data in the table to
            // read. We may or may not have room for it. So DataLeft
            // is TRUE, and BufferSize - BytesCopied is the room left
            // in the buffer.
            if ((int)(BufferSize - BytesCopied) >= (int)sizeof(IPRouteEntry)) {
                DataLeft = RTReadNext(Context, InfoBuff);
                BytesCopied += sizeof(IPRouteEntry);
                fStatus = CopyToNdisSafe(Buffer, &Buffer, InfoBuff, sizeof(IPRouteEntry),
                                         &Offset);
                if (fStatus == FALSE) {
                    break;
                }
            } else
                break;

        }

        CTEFreeLock(&RouteTableLock.Lock, Handle);

        if (fStatus == FALSE) {
            Status = TDI_NO_RESOURCES;
        } else {
            Status = (!DataLeft ? TDI_SUCCESS : TDI_BUFFER_OVERFLOW);
        }
        break;
    case IP_MIB_SINGLE_RT_ENTRY_ID:
        {
            CTEGetLock(&RouteTableLock.Lock, &Handle);

            if ((int)(BufferSize >= (int)sizeof(IPRouteEntry))) {
                Status = RTRead(Context, InfoBuff);
                fStatus = CopyToNdisSafe(Buffer, &Buffer, InfoBuff, sizeof(IPRouteEntry),
                                         &Offset);

                if (fStatus == FALSE) {
                    Status = TDI_NO_RESOURCES;
                } else {
                    //Status = TDI_SUCCESS;
                    BytesCopied = sizeof(IPRouteEntry);
                }
            } else {
                Status = TDI_BUFFER_OVERFLOW;
            }

            CTEFreeLock(&RouteTableLock.Lock, Handle);
        }
        break;
    case IP_INTFC_INFO_ID:
        IFAddr = *(IPAddr *) Context;
        // Loop through the NTE table, looking for a match.

        CTEGetLock(&RouteTableLock.Lock, &TableHandle);
        NetTableList = NewNetTableList[NET_TABLE_HASH(IFAddr)];
        for (CurrentNTE = NetTableList;
             CurrentNTE != NULL;
             CurrentNTE = CurrentNTE->nte_next) {
            if ((CurrentNTE->nte_flags & NTE_VALID) &&
                IP_ADDR_EQUAL(CurrentNTE->nte_addr, IFAddr)) {
                LowerIF = CurrentNTE->nte_if;
                LOCKED_REFERENCE_IF(LowerIF);
                break;
            }
        }
        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

        if (CurrentNTE == NULL) {
            Status = TDI_INVALID_PARAMETER;
            break;
        }
        if (BufferSize < offsetof(IPInterfaceInfo, iii_addr)) {
            DerefIF(LowerIF);
            Status = TDI_BUFFER_TOO_SMALL;
            break;
        }
        // We have the NTE.  Fill in a structure, and we're done.
        IIIPtr = (IPInterfaceInfo *) InfoBuff;

        IIIPtr->iii_flags = 0;

        if (LowerIF->if_flags & IF_FLAGS_P2P) {
            IIIPtr->iii_flags |= IP_INTFC_FLAG_P2P;
        }
        if (LowerIF->if_flags & IF_FLAGS_P2MP) {
            IIIPtr->iii_flags |= IP_INTFC_FLAG_P2MP;
        }
        if (LowerIF->if_flags & IF_FLAGS_UNI) {
            IIIPtr->iii_flags |= IP_INTFC_FLAG_UNIDIRECTIONAL;
        }

        IIIPtr->iii_mtu = LowerIF->if_mtu;
        IIIPtr->iii_speed = LowerIF->if_speed;
        IIIPtr->iii_addrlength = LowerIF->if_addrlen;
        BytesCopied = offsetof(IPInterfaceInfo, iii_addr);
        if (BufferSize >= (offsetof(IPInterfaceInfo, iii_addr) +
                           LowerIF->if_addrlen)) {
            Status = TDI_NO_RESOURCES;

            fStatus = CopyToNdisSafe(Buffer, &Buffer, InfoBuff,
                                     offsetof(IPInterfaceInfo, iii_addr), &Offset);

            if (fStatus == TRUE) {
                if (LowerIF->if_addr) {
                    fStatus = CopyToNdisSafe(Buffer, NULL,
                                             LowerIF->if_addr, LowerIF->if_addrlen, &Offset);

                    if (fStatus == TRUE) {
                        Status = TDI_SUCCESS;
                        BytesCopied += LowerIF->if_addrlen;
                    }
                } else {
                    Status = TDI_SUCCESS;
                }
            }
        } else {
            Status = TDI_BUFFER_TOO_SMALL;
        }

        DerefIF(LowerIF);
        break;

    case IP_GET_BEST_SOURCE: {
        IPAddr Dest = * (IPAddr *) Context;
        IPAddr Source;
        RouteCacheEntry *RCE;
        ushort MSS;
        uchar Type;
        IPOptInfo OptInfo;

        if (BufferSize < sizeof Source) {
            Status = TDI_BUFFER_TOO_SMALL;
            break;
        }

        IPInitOptions(&OptInfo);

        Source = OpenRCE(Dest, NULL_IP_ADDR, &RCE, &Type, &MSS, &OptInfo);
        if (!IP_ADDR_EQUAL(Source, NULL_IP_ADDR))
            CloseRCE(RCE);

        fStatus = CopyToNdisSafe(Buffer, &Buffer,
                                 (uchar *)&Source, sizeof Source, &Offset);
        if (fStatus == FALSE) {
            Status = TDI_NO_RESOURCES;
        } else {
            Status = TDI_SUCCESS;
            BytesCopied = sizeof Source;
        }
        break;
    }

    default:
        return TDI_INVALID_PARAMETER;
        break;
    }

    *Size = BytesCopied;
    return Status;
}

//*     IPSetNdisRequest - IP set ndis request handler.
//
//      Called by the upper layer when it wants to set the general packet filter for
//      the corr. arp interface
//
//      Input:          IPAddr          - Addr of addrobject to set on
//                      NDIS_OID        - Packet Filter
//                      On              - Set_if, clear_if or clear_card
//                      IfIndex         - IfIndex if IPAddr not given
//
//      Returns: Matched if index or 0 if failure
//
ulong
IPSetNdisRequest(IPAddr Addr, NDIS_OID OID, uint On, uint IfIndex)
{
    Interface       *IF = NULL;
    NetTableEntry   *NTE;
    int             Status;
    uint            i;
    CTELockHandle   Handle;
    uint            Index = 0;

    // set the interface to promiscuous mcast mode
    // scan s.t. match numbered interface with Addr or unnumbered interface
    // with IfIndex
    // can optimize it by taking special case for unnumbered interface

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
            if (NTE != LoopNTE && (NTE->nte_flags & NTE_VALID) &&
                (IP_ADDR_EQUAL(NTE->nte_addr, Addr) ||
                 NTE->nte_if->if_index == IfIndex)) {
                // Found one. Save it and break out.
                IF = NTE->nte_if;
                break;
            }
        }
        if (IF) {
            Index = IF->if_index;
            break;
        }
    }

    if (IF) {
        if (!IF->if_setndisrequest) {
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            return 0;
        }

        if (On != CLEAR_CARD) {    // just clear the option on the card
            IF->if_promiscuousmode = (uchar)On;
        }

        LOCKED_REFERENCE_IF(IF);
        CTEFreeLock(&RouteTableLock.Lock, Handle);

        Status = (*(IF->if_setndisrequest)) (IF->if_lcontext, OID, On);

        DerefIF(IF);
        if (Status != NDIS_STATUS_SUCCESS) {
            return 0;
        }
    } else {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return 0;
    }
    return Index;
}

//*     IPAbsorbRtrAlert - IP absorb rtr alert packet handler.
//
//      Called by the upper layer when it wants to set the general packet filter for
//      the corr. arp interface
//
//      Input:          IPAddr          - Addr of addrobject to set on
//                      Protocol        - if 0 turn of the option
//                      IfIndex         - IfIndex if IPAddr not given
//
//      Returns: Matched if index or 0 if failure
//
ulong
IPAbsorbRtrAlert(IPAddr Addr, uchar Protocol, uint IfIndex)
{
    Interface       *IF = NULL;
    NetTableEntry   *NTE;
    uint            i;
    CTELockHandle   Handle;
    uint            Index = 0;

    // can optimize it by taking special case for unnumbered interface

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
            if (NTE != LoopNTE && (NTE->nte_flags & NTE_VALID) &&
                (IP_ADDR_EQUAL(NTE->nte_addr, Addr) ||
                 NTE->nte_if->if_index == IfIndex)) {
                // Found one. Save it and break out.
                IF = NTE->nte_if;
                break;
            }
        }
        if (IF) {
            Index = IF->if_index;
            break;
        }
    }

    if (IF) {
        // we are keeping this property per interface so if there are 2 NTEs
        // on that interface its
        // set/unset on the interface
        // will decide later whether want to keep it per NTE also.

        IF->if_absorbfwdpkts = Protocol;
        CTEFreeLock(&RouteTableLock.Lock, Handle);

        return Index;
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return 0;
}

NTSTATUS
SetIFPromiscuous(ULONG Index, UCHAR Type, UCHAR Add)
{
    Interface *pIf;
    BOOLEAN bFound = FALSE;
    UINT On;

    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    //
    // Walk the interface to find the one with the given index
    //

    for (pIf = IFList; pIf != NULL; pIf = pIf->if_next) {
        if (!(pIf->if_flags & IF_FLAGS_DELETING) && (pIf->if_index == Index)) {
            bFound = TRUE;

            break;
        }
    }

    if (!bFound) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    } else {
        LOCKED_REFERENCE_IF(pIf);
        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }

    if (pIf->if_setndisrequest == NULL) {
        DerefIF(pIf);
        return STATUS_NOT_SUPPORTED;
    }
    if (Add == 0) {
        On = 0;
    } else {
        if (Add == 1) {
            On = 1;
        } else {
            DerefIF(pIf);
            return STATUS_INVALID_PARAMETER;
        }
    }

    if (Type == PROMISCUOUS_MCAST) {
        NTSTATUS status;

        status = (*(pIf->if_setndisrequest)) (pIf->if_lcontext,
                                              NDIS_PACKET_TYPE_ALL_MULTICAST,
                                              On);
        DerefIF(pIf);
        return status;
    }
    if (Type == PROMISCUOUS_BCAST) {
        NTSTATUS status;

        status = (*(pIf->if_setndisrequest)) (pIf->if_lcontext,
                                              NDIS_PACKET_TYPE_PROMISCUOUS,
                                              On);
        DerefIF(pIf);
        return status;
    }
    DerefIF(pIf);
    return STATUS_INVALID_PARAMETER;
}

//*     IPSetInfo - IP set information handler.
//
//      Called by the upper layer when it wants to set an object, which could
//      be a route table entry, an ARP table entry, or something else.
//
//      Input:  ID                      - Pointer to ID structure.
//                      Buffer          - Pointer to buffer containing element to set..
//                      Size            - Pointer to size in bytes of buffer.
//
//      Returns: TDI_STATUS of attempt to read information.
//
long
IPSetInfo(TDIObjectID * ID, void *Buffer, uint Size)
{
    uint Entity;
    uint Instance;
    Interface *LowerIF;
    Interface *OutIF;
    uint MTU;
    IPRouteEntry *IRE;
    NetTableEntry *OutNTE, *LocalNTE;
    IP_STATUS Status;
    IPAddr FirstHop, Dest, NextHop;
    uint i;
    CTELockHandle TableHandle;
    uint Flags;
    uchar Dtype;

    DEBUGMSG(DBG_TRACE && DBG_SETINFO,
        (DTEXT("+IPSetInfo(%x, %x, %d)\n"), ID, Buffer, Size));

    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // If it's not for us, pass it down.
    if (Entity != CL_NL_ENTITY) {
        // We need to pass this down to the lower layer. Loop through until
        // we find one that takes it. If noone does, error out.

        CTEGetLock(&RouteTableLock.Lock, &TableHandle);

        LowerIF = IFList;

        while (LowerIF) {
            if (LowerIF->if_flags & IF_FLAGS_DELETING) {
                // this interface is about to get deleted
                // fail the request
                break;
            }
            LOCKED_REFERENCE_IF(LowerIF);
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            // we have freed the routetablelock here
            // but since we have a refcount on LowerIF, LowerIF can't go away
            Status = (*LowerIF->if_setinfo) (LowerIF->if_lcontext, ID, Buffer,
                                             Size);
            if (Status != TDI_INVALID_REQUEST) {
                DEBUGMSG(DBG_ERROR && DBG_SETINFO,
                    (DTEXT("IPSetInfo: if_setinfo failure %x\n"), Status));
                DerefIF(LowerIF);
                return Status;
            }
            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            LockedDerefIF(LowerIF);
            // LowerIF->if_next can't be freed at this point.
            LowerIF = LowerIF->if_next;
        }

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

        // If we get here, noone took it. Return an error.
        return TDI_INVALID_REQUEST;
    }
    if (Instance != IPInstance)
        return TDI_INVALID_REQUEST;

    // We're identified as the entity. Make sure the ID is correct.

    Flags = RT_EXCLUDE_LOCAL;

    if (ID->toi_id == IP_MIB_RTTABLE_ENTRY_ID_EX) {

        Flags |= RT_NO_NOTIFY;
        ID->toi_id = IP_MIB_RTTABLE_ENTRY_ID;
    }
    if (ID->toi_id == IP_MIB_RTTABLE_ENTRY_ID) {
        NetTableEntry *TempNTE;

        DEBUGMSG(DBG_INFO && DBG_SETINFO,
            (DTEXT("IPSetInfo: IP_MIB_RTTABLE_ENTRY_ID - set route table entry.\n")));

        // This is an attempt to set a route table entry. Make sure the
        // size if correct.
        if (Size < sizeof(IPRouteEntry)) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("IPSetInfo RTTABLE: Buffer too small %d (IPRouteEntry = %d)\n"),
                 Size, sizeof(IPRouteEntry)));
            return TDI_INVALID_PARAMETER;
        }

        IRE = (IPRouteEntry *) Buffer;

        OutNTE = NULL;
        LocalNTE = NULL;

        Dest = IRE->ire_dest;
        NextHop = IRE->ire_nexthop;

        // Make sure that the nexthop is sensible. We don't allow nexthops
        // to be broadcast or invalid or loopback addresses.
        if (IP_LOOPBACK(NextHop) || CLASSD_ADDR(NextHop) ||
            CLASSE_ADDR(NextHop)) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("IPSetInfo RTTABLE: Invalid next hop %x\n"), NextHop));
            return TDI_INVALID_PARAMETER;
        }

        // Also make sure that the destination we're routing to is sensible.
        // Don't allow routes to be added to E or loopback addresses

        if (IP_LOOPBACK(Dest) || CLASSE_ADDR(Dest))
            return TDI_INVALID_PARAMETER;

        if (IRE->ire_index == LoopIndex) {
            DEBUGMSG(DBG_ERROR,
                (DTEXT("IPSetInfo RTTABLE: index == LoopIndex!! Invalid!\n")));
            return TDI_INVALID_PARAMETER;
        }

        if (IRE->ire_index != INVALID_IF_INDEX) {

            // First thing to do is to find the outgoing NTE for specified
            // interface, and also make sure that it matches the destination
            // if the destination is one of my addresses.

            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            for (i = 0; i < NET_TABLE_SIZE; i++) {
                NetTableEntry *NetTableList = NewNetTableList[i];
                for (TempNTE = NetTableList;
                     TempNTE != NULL;
                     TempNTE = TempNTE->nte_next) {

                    if ((OutNTE == NULL) &&
                        (TempNTE->nte_flags & NTE_VALID) &&
                        (IRE->ire_index == TempNTE->nte_if->if_index)) {
                        OutNTE = TempNTE;
                    }

                    if (!IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR) &&
                        IP_ADDR_EQUAL(NextHop, TempNTE->nte_addr) &&
                        (TempNTE->nte_flags & NTE_VALID)) {
                        if (IRE->ire_index != TempNTE->nte_if->if_index) {
                            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
                            return TDI_INVALID_PARAMETER;
                        }                        
                        LocalNTE = TempNTE;
                    }

                    // Don't let a route be set through a broadcast address.
                    if (IsBCastOnNTE(NextHop, TempNTE) != DEST_LOCAL) {
                        DEBUGMSG(DBG_ERROR,
                                 (DTEXT("IPSetInfo RTTABLE: Bcast address. Invalid NextHop!\n")));
                        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
                        return TDI_INVALID_PARAMETER;
                    }

                    // Don't let a route to a broadcast address be added or deleted.
                    Dtype = IsBCastOnNTE(Dest, TempNTE);
                    if ((Dtype != DEST_LOCAL) && (Dtype != DEST_MCAST)) {
                        DEBUGMSG(DBG_ERROR,
                            (DTEXT("IPSetInfo RTTABLE: Bcast address. Invalid Dest!\n")));
                        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
                        return TDI_INVALID_PARAMETER;
                    }
                }
            }
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            

            // At this point OutNTE points to the outgoing NTE, and LocalNTE
            // points to the NTE for the local address, if this is a direct route.
            // Make sure they point to the same interface, and that the type is
            // reasonable.
            if (OutNTE == NULL)
                return TDI_INVALID_PARAMETER;

            if (LocalNTE != NULL) {
                // He's routing straight out a local interface. The interface for
                // the local address must match the interface passed in, and the
                // type must be DIRECT (if we're adding) or INVALID (if we're
                // deleting).
                // LocalNTE is valid at this point
                if (IRE->ire_type != IRE_TYPE_DIRECT &&
                    IRE->ire_type != IRE_TYPE_INVALID)
                    return TDI_INVALID_PARAMETER;

                OutNTE = LocalNTE;
            }
            // Figure out what the first hop should be. If he's routing straight
            // through a local interface, or the next hop is equal to the
            // destination, then the first hop is IPADDR_LOCAL. Otherwise it's the
            // address of the gateway.
            if ((LocalNTE != NULL) || IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR))
                FirstHop = IPADDR_LOCAL;
            else if (IP_ADDR_EQUAL(Dest, NextHop))
                FirstHop = IPADDR_LOCAL;
            else
                FirstHop = NextHop;

            MTU = OutNTE->nte_mss;

            // Take RouteTableLock
            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            if ((OutNTE->nte_flags & NTE_VALID) &&
                !(OutNTE->nte_if->if_flags & IF_FLAGS_DELETING)) {
                // ref the IF
                OutIF = OutNTE->nte_if;

                if (IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR)) {

                    if (!(OutIF->if_flags & IF_FLAGS_P2P)) {

                        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

                        return TDI_INVALID_PARAMETER;
                    }
                }

                LOCKED_REFERENCE_IF(OutIF);
                CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            } else {
                CTEFreeLock(&RouteTableLock.Lock, TableHandle);
                return TDI_INVALID_PARAMETER;
            }

        } else {
            OutIF = (Interface *) & DummyInterface;
            MTU = DummyInterface.ri_if.if_mtu - sizeof(IPHeader);
            if (IP_ADDR_EQUAL(Dest, NextHop))
                FirstHop = IPADDR_LOCAL;
            else
                FirstHop = NextHop;
        }

        // We've done the validation. See if he's adding or deleting a route.
        if (IRE->ire_type != IRE_TYPE_INVALID) {
            // He's adding a route.
            uint AType = ATYPE_OVERRIDE;

            DEBUGMSG(DBG_INFO && DBG_SETINFO,
                (DTEXT("IPSetInfo RTTABLE: Calling AddRoute addr %x mask %x\n"),
                 Dest, IRE->ire_mask));

            Status = AddRoute(Dest, IRE->ire_mask, FirstHop, OutIF,
                              MTU, IRE->ire_metric1, IRE->ire_proto,
                              AType, IRE->ire_context, Flags);
            DEBUGMSG(Status != IP_SUCCESS && DBG_ERROR && DBG_SETINFO,
                (DTEXT("IPSetInfo: AddRoute failure %x\n"), Status));

        } else {
            DEBUGMSG(DBG_INFO && DBG_SETINFO,
                (DTEXT("IPSetInfo RTTABLE: Calling DeleteRoute addr %x mask %x\n"),
                 Dest, IRE->ire_mask));

            // He's deleting a route.
            Status = DeleteRoute(Dest, IRE->ire_mask, FirstHop, OutIF, Flags);

            DEBUGMSG(Status != IP_SUCCESS && DBG_ERROR && DBG_SETINFO,
                (DTEXT("IPSetInfo: DeleteRoute failure %x\n"), Status));

        }

        if (IRE->ire_index != INVALID_IF_INDEX) {
            ASSERT(OutIF != (Interface *) & DummyInterface);
            DerefIF(OutIF);
        }
        if (Status == IP_SUCCESS)
            return TDI_SUCCESS;
        else if (Status == IP_NO_RESOURCES)
            return TDI_NO_RESOURCES;
        else
            return TDI_INVALID_PARAMETER;

    } else {
        if (ID->toi_id == IP_MIB_STATS_ID) {
            IPSNMPInfo *Info = (IPSNMPInfo *) Buffer;

            // Setting information about TTL and/or routing.
            if (Info->ipsi_defaultttl > 255 || (!RouterConfigured &&
                                                Info->ipsi_forwarding == IP_FORWARDING)) {
                return TDI_INVALID_PARAMETER;
            }
            DefaultTTL = Info->ipsi_defaultttl;
            ForwardPackets = Info->ipsi_forwarding == IP_FORWARDING ? TRUE :
                FALSE;

            return TDI_SUCCESS;
        }
        return TDI_INVALID_PARAMETER;
    }

}

#pragma BEGIN_INIT

//*     IPGetEList - Get the entity list.
//
//      Called at init time to get an entity list. We fill our stuff in, and
//      then call the interfaces below us to allow them to do the same.
//
//      Input:  EntityList          - Pointer to entity list to be filled in.
//              Count               - Pointer to number of entries in the list.
//
//      Returns Status of attempt to get the info.
//
long
IPGetEList(TDIEntityID * EList, uint * Count)
{
    uint MyIPBase;
    uint MyERBase;
    int Status;
    uint i;
    Interface *LowerIF;
    TDIEntityID *EntityList;
    TDIEntityID *IPEntity, *EREntity;
    CTELockHandle TableHandle;

    EntityList = EList;

    // Walk down the list, looking for existing CL_NL or ER entities, and
    // adjust our base instance accordingly.
    // if we are already on the list then do nothing.
    // if we are going away, mark our entry invalid.

    MyIPBase = 0;
    MyERBase = 0;
    IPEntity = NULL;
    EREntity = NULL;
    for (i = 0; i < *Count; i++, EntityList++) {
        if (EntityList->tei_entity == CL_NL_ENTITY &&
            EntityList->tei_entity != INVALID_ENTITY_INSTANCE) {
            // if we are already on the list remember our entity item
            // o/w find an instance # for us.
            if (EntityList->tei_instance == IPInstance) {
                IPEntity = EntityList;
            } else {
                MyIPBase = MAX(MyIPBase, EntityList->tei_instance + 1);
            }
        } else {
            if (EntityList->tei_entity == ER_ENTITY &&
                EntityList->tei_entity != INVALID_ENTITY_INSTANCE)
                // if we are already on the list remember our entity item
                // o/w find an instance # for us.
                if (EntityList->tei_instance == ICMPInstance) {
                    EREntity = EntityList;
                } else {
                    MyERBase = MAX(MyERBase, EntityList->tei_instance + 1);
                }
        }
        if (IPEntity && EREntity) {
            break;
        }
    }

    if (!IPEntity) {
        // we are not on the list.
        // insert ourself iff we are not going away.
        // make sure we have the room for it.
        if (*Count >= MAX_TDI_ENTITIES) {
            return TDI_REQ_ABORTED;
        }
        IPInstance = MyIPBase;
        IPEntity = &EList[*Count];
        IPEntity->tei_entity = CL_NL_ENTITY;
        IPEntity->tei_instance = MyIPBase;
        (*Count)++;
    }
    if (!EREntity) {
        // we are not on the list.
        // insert ourself iff we are not going away.
        // make sure we have the room for it.
        if (*Count >= MAX_TDI_ENTITIES) {
            return TDI_REQ_ABORTED;
        }
        ICMPInstance = MyERBase;
        EREntity = &EList[*Count];
        EREntity->tei_entity = ER_ENTITY;
        EREntity->tei_instance = MyERBase;
        (*Count)++;
    }

    // Loop through the interfaces, querying each of them.

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

    LowerIF = IFList;

    while (LowerIF) {
        if (LowerIF->if_refcount == 0) {
            LowerIF = LowerIF->if_next;
            continue;
        }
        LOCKED_REFERENCE_IF(LowerIF);
        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

        Status = (*LowerIF->if_getelist) (LowerIF->if_lcontext, EList, Count);
        if (!Status) {
            DerefIF(LowerIF);
            return TDI_BUFFER_TOO_SMALL;
        }
        CTEGetLock(&RouteTableLock.Lock, &TableHandle);
        LockedDerefIF(LowerIF);
        // LowerIF->if_next can't be freed at this point.
        LowerIF = LowerIF->if_next;
    }

    // Finally, cache the entries that are now on the list.
    // Note that our cache is covered by 'RouteTableLock'.
    if (!IPEntityList) {
        IPEntityList = CTEAllocMem(sizeof(TDIEntityID) * MAX_TDI_ENTITIES);
    }
    if (IPEntityList) {
        RtlZeroMemory(IPEntityList, sizeof(IPEntityList));
        IPEntityCount = *Count;
        
        if (IPEntityCount) {
            RtlCopyMemory(IPEntityList, EList, IPEntityCount * sizeof(*EList));
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

    return TDI_SUCCESS;

}

#pragma END_INIT

//* IPWakeupPattern - add or remove IP wakeup pattern.
//
//  Entry:  InterfaceConext   - ip interface context for which the pattern is to be added/removed
//          PtrnDesc        -   Pattern Descriptor
//          AddPattern      -   TRUE - add, FALSE - remove
//  Returns: Nothing.
//

NTSTATUS
IPWakeupPattern(uint InterfaceContext, PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc,
                BOOLEAN AddPattern)
{
    Interface *IF;
    CTELockHandle Handle;
    NTSTATUS status;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (!(IF->if_flags & IF_FLAGS_DELETING) &&
            (IF->if_index == InterfaceContext)) {
            break;
        }
    }

    if (IF == (Interface *) NULL) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return STATUS_INVALID_HANDLE;
    } else {
        LOCKED_REFERENCE_IF(IF);
        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }

    if (NULL == IF->if_dowakeupptrn) {
        DerefIF(IF);
        return STATUS_NOT_SUPPORTED;
    }
    status = (*(IF->if_dowakeupptrn)) (IF->if_lcontext, PtrnDesc, ARP_ETYPE_IP, AddPattern);

    DerefIF(IF);

    return status;
}

NTSTATUS
IPGetCapability(uint InterfaceContext, uchar* pBuf, uint cap)
{
    Interface *IF;
    CTELockHandle Handle;
    NTSTATUS status;

    status = STATUS_SUCCESS;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (!(IF->if_flags & IF_FLAGS_DELETING) &&
            (IF->if_index == InterfaceContext)) {
            break;
        }
    }

    if (IF != (Interface *) NULL) {
        if (cap == IF_WOL_CAP) {
            *(ulong*)pBuf = IF->if_pnpcap;
        } else if (cap == IF_OFFLOAD_CAP) {
            IFOffloadCapability* IFOC = (IFOffloadCapability*)pBuf;
            IFOC->ifoc_OffloadFlags = IF->if_OffloadFlags;
            IFOC->ifoc_IPSecOffloadFlags = IF->if_IPSecOffloadFlags;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return status;
}

//* IPGetInterfaceFriendlyName - get human-readable name for an interface.
//
// Called to retrieve the unique descriptive name for an interface. This name
// is provided by the interface's ARP module, and is used by IP to identify
// the interface in event logs.
//
// Input:   InterfaceContext    - IP interface context identifying the interface
//                                friendly name is required
//          Name                - on output, contains the friendly-name.
//          Size                - contains the length of the buffer at 'Name'.
//
// Returns: TDI_STATUS of query-attempt.

long
IPGetInterfaceFriendlyName(uint InterfaceContext, PWCHAR Name, uint Size)
{
    PNDIS_BUFFER Buffer;
    uint BufferSize;
    CTELockHandle Handle;
    uint i;
    TDIObjectID ID;
    Interface *IF;
    TDI_STATUS Status;

    // Attempt to retrieve the interface whose name is required,
    // and if successful issue a query-info request to get its friendly name.

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (!(IF->if_flags & IF_FLAGS_DELETING) &&
            (IF->if_index == InterfaceContext)) {
            break;
        }
    }

    if (IF != (Interface *) NULL) {

        // Construct a TDI query to obtain the interface's friendly name.
        // Unfortunately, this operation is complicated by the fact that
        // we don't have the exact entity-instance for the lower-layer entity.
        // Therefore, we go through our whole cache of entity-instances,
        // until we find one which is acceptable to the lower-layer entity.

        ID.toi_class = INFO_CLASS_PROTOCOL;
        ID.toi_type = INFO_TYPE_PROVIDER;
        ID.toi_id = IF_FRIENDLY_NAME_ID;
        ID.toi_entity.tei_entity = IF_ENTITY;

        NdisAllocateBuffer( (PNDIS_STATUS) &Status, &Buffer, BufferPool,
                            Name, Size);
        if (Status == NDIS_STATUS_SUCCESS) {
            LOCKED_REFERENCE_IF(IF);
            for (i = 0; i < IPEntityCount; i++) {
                if (IPEntityList[i].tei_entity != IF_ENTITY)
                    continue;
                ID.toi_entity.tei_instance = IPEntityList[i].tei_instance;
                CTEFreeLock(&RouteTableLock.Lock, Handle);
                BufferSize = Size;
                Status = (*IF->if_qinfo)(IF->if_lcontext, &ID, Buffer,
                                         &BufferSize, NULL);
                CTEGetLock(&RouteTableLock.Lock, &Handle);
                if (Status != TDI_INVALID_REQUEST)
                    break;

                // We just released the route-table lock in order to query
                // the lower-layer entity, and that means that the entity-list
                // may have changed. Handle that case by just making sure
                // that the entity we just queried is in the same location;
                // if not, we'll need to find it and continue from there.
                // If it's gone, give up.

                if (i < IPEntityCount &&
                    IPEntityList[i].tei_instance !=
                    ID.toi_entity.tei_instance) {
                    for (i = 0; i < IPEntityCount; i++) {
                        if (IPEntityList[i].tei_instance ==
                            ID.toi_entity.tei_instance) {
                            break;
                        }
                    }
                }
            }
            LockedDerefIF(IF);
            NdisFreeBuffer(Buffer);
        } else
            Status = TDI_NO_RESOURCES;
    } else
        Status = TDI_INVALID_PARAMETER;

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return Status;
}

//* IPQuerySetOffload - update offload capabilities for an interface.
//
// Called to trigger an update of an interface's offload capabilities,
// in the process retrieving the new capabilities flags.
//
// Input:   IF      - the interface to be updated.
//          IFOC    - on output, contains the new offload flags.
//
// Returns: TDI_STATUS of update-attempt.
//
long
IPQuerySetOffload(Interface* IF, IFOffloadCapability* IFOC)
{
    PNDIS_BUFFER Buffer;
    uint BufferSize;
    CTELockHandle Handle;
    uint i;
    TDIObjectID ID;
    TDI_STATUS Status;

    // Build a TDI query to update the interface's offload settings.

    ID.toi_class = INFO_CLASS_PROTOCOL;
    ID.toi_type = INFO_TYPE_PROVIDER;
    ID.toi_id = IF_QUERY_SET_OFFLOAD_ID;
    ID.toi_entity.tei_entity = IF_ENTITY;

    NdisAllocateBuffer( (PNDIS_STATUS) &Status, &Buffer, BufferPool,
                        IFOC, sizeof(*IFOC));
    if (Status == NDIS_STATUS_SUCCESS) {
        CTEGetLock(&RouteTableLock.Lock, &Handle);
        for (i = 0; i < IPEntityCount; i++) {
            if (IPEntityList[i].tei_entity != IF_ENTITY)
                continue;
            ID.toi_entity.tei_instance = IPEntityList[i].tei_instance;
            CTEFreeLock(&RouteTableLock.Lock, Handle);

            BufferSize = sizeof(*IFOC);
            Status = (*IF->if_qinfo)(IF->if_lcontext, &ID, Buffer,
                                     &BufferSize, NULL);

            CTEGetLock(&RouteTableLock.Lock, &Handle);
            if (Status != TDI_INVALID_REQUEST)
                break;

            // We just released the route-table lock in order to query
            // the lower-layer entity, and that means that the entity-list
            // may have changed. Handle that case by just making sure
            // that the entity we just queried is in the same location;
            // if not, we'll need to find it and continue from there.
            // If it's gone, give up.

            if (i < IPEntityCount &&
                IPEntityList[i].tei_instance !=
                ID.toi_entity.tei_instance) {
                for (i = 0; i < IPEntityCount; i++) {
                    if (IPEntityList[i].tei_instance ==
                        ID.toi_entity.tei_instance) {
                        break;
                    }
                }
            }
        }
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        NdisFreeBuffer(Buffer);
    } else
        Status = TDI_NO_RESOURCES;

    return Status;
}

#if MILLEN
//
// Support for VIP!!! For legacy support in VIP, we need to be able to convert
// the index into the if_pnpcontext. This will be exported from tcpip.sys
// to be accessed directly by VIP.
//

//* IPGetPNPCtxt
//
//  Entry:  index   - ip interface index
//          PNPCtxt - pointer to  pnpcontext
//

NTSTATUS
IPGetPNPCtxt(uint index, uint *PNPCtxt)
{
    Interface               *IF;

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF->if_index == index) {
            break;
        }
    }


    if ( IF == (Interface *)NULL ) {
        return STATUS_UNSUCCESSFUL;
    }

    *PNPCtxt  = (uint)IF->if_pnpcontext;

    return STATUS_SUCCESS;
}

//* IPGetPNPCap - add or remove IP wakeup pattern.
//
//  Entry:  InterfaceConext   - ip interface context for which the wol capability needs to be returned
//          flags             - pointer to capability flags
//

NTSTATUS
IPGetPNPCap(uchar *Context, uint *flags)
{
    Interface               *IF;

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF->if_pnpcontext == Context) {
            break;
        }
    }


    if ( IF == (Interface *)NULL ) {
        return STATUS_UNSUCCESSFUL;
    }

    *flags  = IF->if_pnpcap;

    return STATUS_SUCCESS;
}

#endif // MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ipmlock.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcpip\ip\ipmlock.h

Abstract:

    Reader Writer lock primitives for the IP Multicasting

Author:

    Amritansh Raghav

Revision History:

    AmritanR    Created

Notes:

--*/

//
// Need to include "debug.h" before this file is included because
// RT_LOCK is defined there
//

//
// A reader writer lock for kernel mode.
//

typedef struct _RW_LOCK
{
    RT_LOCK rlReadLock;
    RT_LOCK rlWriteLock;
    LONG    lReaderCount;
}RW_LOCK, *PRW_LOCK;

//
// VOID
// InitRwLock(
//  PRW_LOCK    pLock
//  )
//
//  Initializes the spin locks and the reader count
//


#define InitRwLock(l)                                           \
    RtInitializeSpinLock(&((l)->rlReadLock));                   \
    RtInitializeSpinLock(&((l)->rlWriteLock));                  \
    (l)->lReaderCount = 0
        
//
// VOID
// EnterReader(
//  PRW_LOCK    pLock,
//  PKIRQL      pCurrIrql 
//  )
//
// Acquires the Reader Spinlock (now thread is at DPC). 
// InterlockedIncrements the reader count (interlocked because the reader 
// lock is not taken when the count is decremented in ExitReader())
// If the thread is the first reader, also acquires the Writer Spinlock (at
// DPC to be more efficient) to block writers
// Releases the Reader Spinlock from DPC, so that it remains at DPC
// for the duration of the lock being held 
//
// If a writer is in the code, the first reader will wait on the Writer
// Spinlock and all subsequent readers will wait on the Reader Spinlock
// If a reader is in the code and is executing the EnterReader, then a new
// reader will wait for sometime on the Reader Spinlock, and then proceed
// on to the code (at DPC)
//



#define EnterReader(l, q)                                       \
    RtAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))

#define EnterReaderAtDpcLevel(l)                                \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    if(InterlockedIncrement(&((l)->lReaderCount)) == 1)         \
        RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock));       \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))

//
// VOID
// ExitReader(
//  PRW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// InterlockedDec the reader count.
// If this is the last reader, then release the Writer Spinlock to let
// other writers in
// Otherwise, just lower the irql to what was before the lock was
// acquired.  Either way, the irql is down to original irql
//

#define ExitReader(l, q)                                        \
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        RtReleaseSpinLock(&((l)->rlWriteLock), q);              \
    else                                                        \
        KeLowerIrql(q)

#define ExitReaderFromDpcLevel(l)                               \
    if(InterlockedDecrement(&((l)->lReaderCount)) == 0)         \
        RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock))

//
// EnterWriter(
//  PRW_LOCK    pLock,
//  PKIRQL      pCurrIrql
//  )
//
// Acquire the reader and then the writer spin lock
// If there  are readers in the code, the first writer will wait
// on the Writer Spinlock.  All other writers will wait (with readers)
// on the Reader Spinlock
// If there is a writer in the code then a new writer will wait on 
// the Reader Spinlock

#define EnterWriter(l, q)                                       \
    RtAcquireSpinLock(&((l)->rlReadLock), (q));                 \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock))

#define EnterWriterAtDpcLevel(l)                                \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlReadLock));            \
    RtAcquireSpinLockAtDpcLevel(&((l)->rlWriteLock))


//
// ExitWriter(
//  PRW_LOCK    pLock,
//  KIRQL       kiOldIrql
//  )
//
// Release both the locks
//

#define ExitWriter(l, q)                                        \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    RtReleaseSpinLock(&((l)->rlReadLock), q)


#define ExitWriterFromDpcLevel(l)                               \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlWriteLock));         \
    RtReleaseSpinLockFromDpcLevel(&((l)->rlReadLock))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\info.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

#pragma once

extern CACHE_ALIGN IPSNMPInfo  IPSInfo;
extern ICMPStats               ICMPInStats;
extern ICMPStats               ICMPOutStats;

typedef struct CACHE_ALIGN IPInternalPerCpuStats {
    ulong       ics_inreceives;
    ulong       ics_indelivers;
} IPInternalPerCpuStats;

#define IPS_MAX_PROCESSOR_BUCKETS 8
extern IPInternalPerCpuStats IPPerCpuStats[IPS_MAX_PROCESSOR_BUCKETS];

__forceinline
void IPSIncrementInReceiveCount(void)
{
#if !MILLEN
    const ulong Index = KeGetCurrentProcessorNumber() % IPS_MAX_PROCESSOR_BUCKETS;
    IPPerCpuStats[Index].ics_inreceives++;
#else
    IPSInfo.ipsi_inreceives++;
#endif
}

__forceinline
void IPSIncrementInDeliverCount(void)
{
#if !MILLEN
    const ulong Index = KeGetCurrentProcessorNumber() % IPS_MAX_PROCESSOR_BUCKETS;
    IPPerCpuStats[Index].ics_indelivers++;
#else
    IPSInfo.ipsi_indelivers++;
#endif
}

__inline
void IPSGetTotalCounts(IPInternalPerCpuStats* Stats)
{
    ulong Index;
    const ulong MaxIndex = MIN(KeNumberProcessors, IPS_MAX_PROCESSOR_BUCKETS);

    RtlZeroMemory(Stats, sizeof(IPInternalPerCpuStats));

    for (Index = 0; Index < MaxIndex; Index++) {
        Stats->ics_inreceives += IPPerCpuStats[Index].ics_inreceives;
        Stats->ics_indelivers += IPPerCpuStats[Index].ics_indelivers;
    }
}


typedef struct RouteEntryContext {
    uint                   rec_index;
    struct RouteTableEntry *rec_rte;
} RouteEntryContext;

extern long     IPQueryInfo(struct TDIObjectID *ID, PNDIS_BUFFER Buffer,
                            uint *Size, void *Context);
extern long     IPSetInfo(struct TDIObjectID *ID, void *Buffer, uint Size);
extern long     IPGetEList(struct TDIEntityID *Buffer, uint *Count);

extern ulong    IPSetNdisRequest(IPAddr Addr, NDIS_OID OID, uint On,
                                 uint IfIndex);

extern ulong    IPAbsorbRtrAlert(IPAddr Addr, uchar Protocol, uint IfIndex);

extern BOOLEAN  IsRtrAlertPacket(IPHeader UNALIGNED *Header);

extern NTSTATUS IPWakeupPattern(uint InterfaceContext,
                                PNET_PM_WAKEUP_PATTERN_DESC PtrnDesc,
                                BOOLEAN AddPattern);

extern long     IPGetInterfaceFriendlyName(uint InterfaceContext,
                                           PWCHAR Name, uint Size);
extern long     IPQuerySetOffload(Interface* IF, IFOffloadCapability* IFOC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\iploop.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//***   iploop.c - IP loopback routines.
//
//  This file contains all the routines related to loopback

#include "precomp.h"
#include "iprtdef.h"
#include "iproute.h"
#include "tcpipbuf.h"

#define LOOP_LOOKAHEAD      MAX_HDR_SIZE + 8

extern int NumNTE;
extern int NumActiveNTE;

extern Interface *IFList;
extern uint NumIF;

extern BOOLEAN CopyToNdisSafe(PNDIS_BUFFER DestBuf, PNDIS_BUFFER * ppNextBuf,
                              uchar * SrcBuf, uint Size, uint * StartOffset);

CACHE_LINE_KSPIN_LOCK LoopLock;
PNDIS_PACKET LoopXmitHead = (PNDIS_PACKET) NULL;
PNDIS_PACKET LoopXmitTail = (PNDIS_PACKET) NULL;
CTEEvent LoopXmitEvent;
RouteInterface LoopInterface;    // Loopback interface.
uint LoopXmitRtnRunning = 0;

int LoopGetEList(void *Context, TDIEntityID *EntityList, uint *Count);
NetTableEntry *InitLoopback(IPConfigInfo * ConfigInfo);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, LoopGetEList)
#pragma alloc_text(INIT, InitLoopback)
#endif // ALLOC_PRAGMA

uint LoopIndex;                                 // Index of loop I/F.
uint LoopInstance = (uint) INVALID_ENTITY_INSTANCE;    // I/F instance of loopback I/F.
NetTableEntry *LoopNTE;                         // Pointer to loopback NTE.
IFEntry LoopIFE;                                // Loopback IF Entry.
uchar LoopName[] = "MS TCP Loopback interface";
uint LoopEntityType = IF_MIB;



//* LoopSetAffinity - Sets or resets the affinity of a thread.
//
//  This routine is used to affinitize the loopback thread upon entry to the 
//  processor it would be running on at that time and to remove the affinity
//  upon exit. This is done in order to assure that receives and receive-
//  completions happen on the same processor on the loopback interface.
//
//  Entry:  SetAffinity     - Sets the affinity if TRUE, resets otherwise.
//
//  Returns: Nothing.
//
__inline VOID
LoopSetAffinity(BOOLEAN SetAffinity)
{
    KAFFINITY affinityMask;

    if (KeNumberProcessors == 1) {
        return;
    }

    if (SetAffinity) {
        affinityMask = (1 << KeGetCurrentProcessorNumber());
    } else {
        affinityMask = ((1 << KeNumberProcessors) - 1);
    }

    ZwSetInformationThread(NtCurrentThread(), ThreadAffinityMask,
                           &affinityMask, sizeof(affinityMask));
}


//* LoopXmitRtn - Loopback xmit event routine.
//
//  This is the delayed event routine called for a loopback transmit.
//
//  Entry:  Event           - Pointer to event structure.
//          Context         - Pointer to loopback NTE
//
//  Returns: Nothing.
//
void
LoopXmitRtn(CTEEvent *Event, void *Context)
{
    PNDIS_PACKET Packet;        // Pointer to packet being transmitted
    PNDIS_BUFFER Buffer;        // Current NDIS buffer being processed.
    uint TotalLength;           // Total length of send.
    uint LookaheadLength;       // Bytes in lookahead.
    uint Copied;                // Bytes copied so far.
    uchar *CopyPtr;             // Pointer to buffer being copied into.
    uchar *SrcPtr;              // Pointer to buffer being copied from.
    uint SrcLength;             // Length of src buffer.
    uchar LookaheadBuffer[LOOP_LOOKAHEAD];
    uchar Rcvd = FALSE;
    
    
#if !MILLEN
    KIRQL OldIrql;
#endif // !MILLEN

    UNREFERENCED_PARAMETER(Event);
    
    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Raise IRQL so we can acquire locks at DPC level in the receive code.
    // On Windows ME, this is NOT done since receive indications are in the
    // context of a global event rather than DPC (in fact due to TDI client
    // restrictions, TCP/IP can't indicate up at DPC, so care must be taken).
    //



#if !MILLEN
    LoopSetAffinity(TRUE);

    KeEnterCriticalRegion();
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
#endif // !MILLEN

    CTEGetLockAtDPC(&LoopLock.Lock);

    if (LoopXmitRtnRunning) {
        CTEFreeLockFromDPC(&LoopLock.Lock);
#if !MILLEN
        KeLowerIrql(OldIrql);
        KeLeaveCriticalRegion();

        LoopSetAffinity(FALSE);
#endif // !MILLEN
        return;
    }
    LoopXmitRtnRunning = 1;

    for (;;) {
        Packet = LoopXmitHead;    // Get the next packet from the list.

        if (Packet != (PNDIS_PACKET) NULL) {
            LoopXmitHead = *(PNDIS_PACKET *) Packet->MacReserved;
            LoopIFE.if_outqlen--;
            CTEFreeLockFromDPC(&LoopLock.Lock);
        } else {                // Nothing left to do.

            LoopXmitRtnRunning = 0;
            CTEFreeLockFromDPC(&LoopLock.Lock);
            break;
        }

        // See if the interface is up. If it's not, we can't deliver it.
        if (LoopIFE.if_adminstatus == IF_STATUS_UP) {
            
            NdisQueryPacket(Packet, NULL, NULL, &Buffer, &TotalLength);
            
            LoopIFE.if_outoctets += TotalLength;
            LoopIFE.if_inoctets += TotalLength;

            LookaheadLength = MIN(LOOP_LOOKAHEAD, TotalLength);
            Copied = 0;
            CopyPtr = LookaheadBuffer;
            while (Copied < LookaheadLength) {
                uint ThisCopy;    // Bytes to copy this time.

                ASSERT(Buffer);
                TcpipQueryBuffer(Buffer, &SrcPtr, &SrcLength, NormalPagePriority);

                if (SrcPtr == NULL) {
                    IPSendComplete(Context, Packet, NDIS_STATUS_RESOURCES);
                    CTEGetLockAtDPC(&LoopLock.Lock);
                    LoopXmitRtnRunning = 0;
                    LoopIFE.if_indiscards++;
                    CTEFreeLockFromDPC(&LoopLock.Lock);
#if !MILLEN
                    KeLowerIrql(OldIrql);
                    KeLeaveCriticalRegion();

                    LoopSetAffinity(FALSE);
#endif // !MILLEN

                    return;
                }
                ThisCopy = MIN(SrcLength, LookaheadLength - Copied);
                RtlCopyMemory(CopyPtr, SrcPtr, ThisCopy);
                Copied += ThisCopy;
                CopyPtr += ThisCopy;
                NdisGetNextBuffer(Buffer, &Buffer);
            }

            Rcvd = TRUE;
            LoopIFE.if_inucastpkts++;

            // Call the RcvPacket Handler

            IPRcvPacket(Context, LookaheadBuffer, LookaheadLength, TotalLength,
                        (NDIS_HANDLE) Packet, 0, FALSE, 0, NULL, (PUINT) Packet,
                        NULL);
        } else {
            LoopIFE.if_indiscards++;
        }

        IPSendComplete(Context, Packet, NDIS_STATUS_SUCCESS);

#if !MILLEN
        //
        // Give other threads a chance to run.
        // Block special k mode APC delivery
        // so that thread will not be blocked
        // in a completion routine
        //


        KeLowerIrql(OldIrql);

        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);



#endif // !MILLEN

        CTEGetLockAtDPC(&LoopLock.Lock);
    }

    if (Rcvd) {
        IPRcvComplete();
    }
#if !MILLEN
    KeLowerIrql(OldIrql);
    KeLeaveCriticalRegion();

    LoopSetAffinity(FALSE);
#endif // !MILLEN

}

//** LoopXmit - Transmit a loopback packet.
//
//  This is the routine called when we need to transmit a packet to ourselves.
//  We put the packet on our loopback list, and schedule an event to deal
//  with it.
//
//  Entry:  Context         - Pointer to the loopback NTE.
//          Packet          - Pointer to packet to be transmitted.
//          Dest            - Destination addres of packet.
//          RCE             - Pointer to RCE (should be NULL).
//
//  Returns: NDIS_STATUS_PENDING
//
NDIS_STATUS
__stdcall
LoopXmit(void *Context, PNDIS_PACKET *PacketArray, uint NoPackets,
         IPAddr Dest, RouteCacheEntry * RCE, void *LinkCtxt)
{
    PNDIS_PACKET *PacketPtr;
    CTELockHandle Handle;
    PNDIS_PACKET Packet = *PacketArray;

    UNREFERENCED_PARAMETER(Dest);
    UNREFERENCED_PARAMETER(RCE);
    UNREFERENCED_PARAMETER(LinkCtxt);
    

    UNREFERENCED_PARAMETER(NoPackets);
    
    ASSERT(NoPackets == 1);

    LoopIFE.if_outucastpkts++;

    if (LoopIFE.if_adminstatus == IF_STATUS_UP) {
        PacketPtr = (PNDIS_PACKET *) Packet->MacReserved;
        *PacketPtr = (PNDIS_PACKET) NULL;

        CTEGetLock(&LoopLock.Lock, &Handle);
        if (LoopXmitHead == (PNDIS_PACKET) NULL) {    // Xmit. Q is empty

            LoopXmitHead = Packet;
        } else {                // Xmit. Q is not empty

            PacketPtr = (PNDIS_PACKET *) LoopXmitTail->MacReserved;
            *PacketPtr = Packet;
        }
        LoopXmitTail = Packet;
        LoopIFE.if_outqlen++;
        if (!LoopXmitRtnRunning) {
            CTEScheduleDelayedEvent(&LoopXmitEvent, Context);
        }
        CTEFreeLock(&LoopLock.Lock, Handle);
        return NDIS_STATUS_PENDING;
    } else {
        LoopIFE.if_outdiscards++;
        return NDIS_STATUS_SUCCESS;
    }
}

//* LoopXfer - Loopback transfer data routine.
//
//  Called when we need to transfer data for the loopback net. The input
//  TDContext is the original packet.
//
//  Entry:  Context         - Pointer to loopback NTE.
//          TDContext       - Original packet that was sent.
//          Dummy           - Unused
//          Offset          - Offset in frame from which to start copying.
//          BytesToCopy     - Number of bytes to copy.
//          DestPacket      - Packet describing buffer to copy into.
//          BytesCopied     - Place to return bytes copied.
//
//  Returns: NDIS_STATUS_SUCCESS
//
NDIS_STATUS
__stdcall
LoopXfer(void *Context, NDIS_HANDLE TDContext, uint Dummy, uint Offset,
         uint BytesToCopy, PNDIS_PACKET DestPacket, uint *BytesCopied)
{
    PNDIS_BUFFER SrcBuffer;     // Current buffer we're copying from.
    PNDIS_PACKET SrcPacket = (PNDIS_PACKET) TDContext;
    uchar *SrcPtr;              // Where we're copying from.
    uint SrcLength;             // Length of current src buffer.
    PNDIS_BUFFER DestBuffer;    // Buffer we're copying to.
    uchar *DestPtr;             // Where we're copying to.
    uint DestLength;            // Length of current dest. buffer.
    uint Copied;                // Length we've copied so far.
    NDIS_STATUS Status;


    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Dummy);

    
    // First, skip over Offset bytes in the packet.
    NdisQueryPacket(SrcPacket, NULL, NULL, &SrcBuffer, NULL);
    

    ASSERT(SrcBuffer);
    TcpipQueryBuffer(SrcBuffer, &SrcPtr, &SrcLength, NormalPagePriority);

    if (SrcPtr == NULL) {
        return NDIS_STATUS_RESOURCES;
    }
    while (Offset >= SrcLength) {
        Offset -= SrcLength;
        NdisGetNextBuffer(SrcBuffer, &SrcBuffer);
        ASSERT(SrcBuffer);
        TcpipQueryBuffer(SrcBuffer, &SrcPtr, &SrcLength, NormalPagePriority);

        if (SrcPtr == NULL) {
            return NDIS_STATUS_RESOURCES;
        }
    }
    // Update Src pointer and length.
    SrcPtr += Offset;
    SrcLength -= Offset;

    // Set up the destination pointers and lengths.
    NdisQueryPacket(DestPacket, NULL, NULL, &DestBuffer, NULL);
    
    TcpipQueryBuffer(DestBuffer, &DestPtr, &DestLength, NormalPagePriority);

    if (DestPtr == NULL) {
        return NDIS_STATUS_RESOURCES;
    }
    Copied = 0;
    Status = NDIS_STATUS_SUCCESS;

    while (BytesToCopy) {
        uint ThisCopy;            // What we're copying this time.

        ThisCopy = MIN(SrcLength, DestLength);
        RtlCopyMemory(DestPtr, SrcPtr, ThisCopy);
        Copied += ThisCopy;
        DestPtr += ThisCopy;
        SrcPtr += ThisCopy;
        BytesToCopy -= ThisCopy;
        SrcLength -= ThisCopy;
        DestLength -= ThisCopy;
        if (!SrcLength) {        // We've exhausted the source buffer.

            NdisGetNextBuffer(SrcBuffer, &SrcBuffer);
            if (!SrcBuffer) {
                ASSERT(0 == BytesToCopy);
                break;            // Copy is done.
            }

            TcpipQueryBuffer(SrcBuffer, &SrcPtr, &SrcLength,
                             NormalPagePriority);
            if (SrcPtr == NULL && BytesToCopy) {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }
        if (!DestLength) {        // We've exhausted the destination buffer.

            NdisGetNextBuffer(DestBuffer, &DestBuffer);
            if (!DestBuffer) {
                ASSERT(0 == BytesToCopy);
                break;            // Copy is done.
            }

            TcpipQueryBuffer(DestBuffer, &DestPtr, &DestLength,
                             NormalPagePriority);

            if (DestPtr == NULL && BytesToCopy) {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }
    }

    if (Status == NDIS_STATUS_SUCCESS) {
        *BytesCopied = Copied;
    }
    return Status;
}

//* LoopClose - Loopback close routine.
//
//  This is the loopback close routine. It does nothing but return.
//
//  Entry:  Context     - Unused.
//
//  Returns: Nothing.
//
void
__stdcall
LoopClose(void *Context)
{
    UNREFERENCED_PARAMETER(Context);
}

//* LoopInvalidate - Invalidate an RCE.
//
//  The loopback invalidate RCE routine. It also does nothing.
//
//  Entry:  Context     - Unused.
//          RCE         - Pointer to RCE to be invalidated.
//
//  Returns: Nothing.
//
void
__stdcall
LoopInvalidate(void *Context, RouteCacheEntry * RCE)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(RCE);
}

//* LoopQInfo - Loopback query information handler.
//
//  Called when the upper layer wants to query information about the loopback
//  interface.
//
//  Input:  IFContext - Interface context (unused).
//          ID        - TDIObjectID for object.
//          Buffer    - Buffer to put data into.
//          Size      - Pointer to size of buffer. On return, filled with
//                      bytes copied.
//          Context   - Pointer to context block.
//
//  Returns: Status of attempt to query information.
//
int
__stdcall
LoopQInfo(void *IFContext, TDIObjectID * ID, PNDIS_BUFFER Buffer, uint * Size,
          void *Context)
{
    uint Offset = 0;
    uint BufferSize = *Size;
    uint Entity;
    uint Instance;
    BOOLEAN fStatus;

    UNREFERENCED_PARAMETER(IFContext);
    UNREFERENCED_PARAMETER(Context);

    
    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // First, make sure it's possibly an ID we can handle.
    if (Entity != IF_ENTITY || Instance != LoopInstance) {
        return TDI_INVALID_REQUEST;
    }
    *Size = 0;                    // In case of an error.

    if (ID->toi_type != INFO_TYPE_PROVIDER)
        return TDI_INVALID_PARAMETER;

    if (ID->toi_class == INFO_CLASS_GENERIC) {
        if (ID->toi_id == ENTITY_TYPE_ID) {
            // He's trying to see what type we are.
            if (BufferSize >= sizeof(uint)) {
                fStatus = CopyToNdisSafe(Buffer, NULL,
                                         (uchar *) &LoopEntityType,
                                         sizeof(uint), &Offset);

                if (fStatus == FALSE) {
                    return (TDI_NO_RESOURCES);
                }
                return TDI_SUCCESS;
            } else
                return TDI_BUFFER_TOO_SMALL;
        }
        return TDI_INVALID_PARAMETER;
    } else if (ID->toi_class != INFO_CLASS_PROTOCOL)
        return TDI_INVALID_PARAMETER;

    // If he's asking for MIB statistics, then return them, otherwise fail
    // the request.

    if (ID->toi_id == IF_MIB_STATS_ID) {

        // He's asking for statistics. Make sure his buffer is at least big
        // enough to hold the fixed part.

        if (BufferSize < IFE_FIXED_SIZE) {
            return TDI_BUFFER_TOO_SMALL;
        }
        // He's got enough to hold the fixed part. Copy our IFE structure
        // into his buffer.
        fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) & LoopIFE,
                                 IFE_FIXED_SIZE, &Offset);

        if (fStatus == TRUE) {
            // See if he has room for the descriptor string.
            if (BufferSize >= (IFE_FIXED_SIZE + sizeof(LoopName))) {
                // He has room. Copy it.
                fStatus = CopyToNdisSafe(Buffer, NULL, LoopName,
                                         sizeof(LoopName), &Offset);

                if (fStatus == TRUE) {
                    *Size = IFE_FIXED_SIZE + sizeof(LoopName);
                    return TDI_SUCCESS;
                }
            } else {
                // Not enough room to copy the desc. string.
                *Size = IFE_FIXED_SIZE;
                return TDI_BUFFER_OVERFLOW;
            }
        }
        return TDI_NO_RESOURCES;

    }
    return TDI_INVALID_PARAMETER;

}

//* LoopSetInfo - Loopback set information handler.
//
//  The loopback set information handler. We support setting of an I/F admin
//  status.
//
//  Input:  Context - Pointer to I/F to set on.
//          ID      - The object ID
//          Buffer  - Pointer to buffer containing value to set.
//          Size    - Size in bytes of Buffer.
//
//  Returns: Status of attempt to set information.
//
int
__stdcall
LoopSetInfo(void *Context, TDIObjectID *ID, void *Buffer, uint Size)
{
    IFEntry *IFE = (IFEntry *) Buffer;
    uint Entity, Instance, Status;

    UNREFERENCED_PARAMETER(Context);
    
    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    // First, make sure it's possibly an ID we can handle.
    if (Entity != IF_ENTITY || Instance != LoopInstance) {
        return TDI_INVALID_REQUEST;
    }
    if (ID->toi_class != INFO_CLASS_PROTOCOL ||
        ID->toi_type != INFO_TYPE_PROVIDER) {
        return TDI_INVALID_PARAMETER;
    }
    // It's for the I/F level, see if it's for the statistics.
    if (ID->toi_id == IF_MIB_STATS_ID) {
        // It's for the stats. Make sure it's a valid size.
        if (Size >= IFE_FIXED_SIZE) {
            // It's a valid size. See what he wants to do.
            Status = IFE->if_adminstatus;
            if (Status == IF_STATUS_UP || Status == IF_STATUS_DOWN)
                LoopIFE.if_adminstatus = Status;
            else if (Status != IF_STATUS_TESTING)
                return TDI_INVALID_PARAMETER;

            return TDI_SUCCESS;

        } else
            return TDI_INVALID_PARAMETER;
    }
    return TDI_INVALID_PARAMETER;
}

//* LoopAddAddr - Dummy loopback add address routine.
//
//  Called at init time when we need to initialize ourselves.
//
uint
__stdcall
LoopAddAddr(void *Context, uint Type, IPAddr Address, IPMask Mask, void *Context2)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(Address);
    UNREFERENCED_PARAMETER(Mask);
    UNREFERENCED_PARAMETER(Context2);
    
    return TRUE;
}

//* LoopDelAddr - Dummy loopback del address routine.
//
//  Called at init time when we need to initialize ourselves.
//
uint
__stdcall
LoopDelAddr(void *Context, uint Type, IPAddr Address, IPMask Mask)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(Address);
    UNREFERENCED_PARAMETER(Mask);
    
    return TRUE;
}

#pragma BEGIN_INIT

extern int InitNTE(NetTableEntry *);
extern int InitInterface(NetTableEntry *);

//* LoopGetEList - Get the entity list.
//
//  Called at init time to get an entity list. We fill our stuff in and return.
//
//  Input:  Context     - Unused.
//          EntityList  - Pointer to entity list to be filled in.
//          Count       - Pointer to number of entries in the list.
//
//  Returns Status of attempt to get the info.
//
int
__stdcall
LoopGetEList(void *Context, TDIEntityID *EntityList, uint *Count)
{
    uint MyIFBase;
    uint i;
    TDIEntityID *IFEntity;

    UNREFERENCED_PARAMETER(Context);
    
    // Walk down the list, looking for existing IF entities, and
    // adjust our base instance accordingly.

    MyIFBase = 0;
    IFEntity = NULL;
    for (i = 0; i < *Count; i++, EntityList++) {
        if (EntityList->tei_entity == IF_ENTITY)
            // if we are already on the list remember our entity item
            // o/w find an instance # for us.
            if (EntityList->tei_instance == LoopInstance &&
                EntityList->tei_instance != INVALID_ENTITY_INSTANCE) {
                IFEntity = EntityList;
                break;
            } else {
                MyIFBase = MAX(MyIFBase, EntityList->tei_instance + 1);
            }
    }

    if (IFEntity == NULL) {
        // we are not on the list.
        // make sure we have the room for it.
        if (*Count >= MAX_TDI_ENTITIES) {
            return FALSE;
        }
        LoopInstance = MyIFBase;

        // Now fill it in.
        EntityList->tei_entity = IF_ENTITY;
        EntityList->tei_instance = MyIFBase;
        (*Count)++;
    }
    return TRUE;
}

//** InitLoopback - Initialize the loopback NTE.
//
//  This function initialized the loopback NTE. We set up the the MSS and
//  pointer to the various pseudo-link routines, then call InitNTE and return.
//
//  Entry:  ConfigInfo  - Pointer to config. info structure.
//
//  Returns: TRUE if we initialized, FALSE if we didn't.
//
NetTableEntry *
InitLoopback(IPConfigInfo * ConfigInfo)
{
    LLIPBindInfo ARPInfo;

    UNREFERENCED_PARAMETER(ConfigInfo);
    
    LoopNTE = CTEAllocMem(sizeof(NetTableEntry));
    if (LoopNTE == NULL)
        return LoopNTE;

    RtlZeroMemory(LoopNTE, sizeof(NetTableEntry));
    RtlZeroMemory(&LoopInterface, sizeof(RouteInterface));

    LoopNTE->nte_addr = LOOPBACK_ADDR;
    LoopNTE->nte_mask = CLASSA_MASK;
    LoopNTE->nte_icmpseq = 1;
    LoopNTE->nte_flags = NTE_VALID | NTE_ACTIVE | NTE_PRIMARY;

    CTEInitLock(&LoopNTE->nte_lock);
    CTEInitLock(&LoopInterface.ri_if.if_lock);
    LoopNTE->nte_mss = LOOPBACK_MSS;
    LoopNTE->nte_if = (Interface *) & LoopInterface;
    LoopInterface.ri_if.if_lcontext = LoopNTE;
    LoopInterface.ri_if.if_xmit = LoopXmit;
    LoopInterface.ri_if.if_transfer = LoopXfer;
    LoopInterface.ri_if.if_close = LoopClose;
    LoopInterface.ri_if.if_invalidate = LoopInvalidate;
    LoopInterface.ri_if.if_qinfo = LoopQInfo;
    LoopInterface.ri_if.if_setinfo = LoopSetInfo;
    LoopInterface.ri_if.if_getelist = LoopGetEList;
    LoopInterface.ri_if.if_addaddr = LoopAddAddr;
    LoopInterface.ri_if.if_deladdr = LoopDelAddr;
    LoopInterface.ri_if.if_bcast = IP_LOCAL_BCST;
    LoopInterface.ri_if.if_speed = 10000000;
    LoopInterface.ri_if.if_mtu = LOOPBACK_MSS;
    LoopInterface.ri_if.if_llipflags = LIP_COPY_FLAG;
    LOCKED_REFERENCE_IF(&LoopInterface.ri_if);

    LoopInterface.ri_if.if_order = MAXLONG;

    ARPInfo.lip_mss = LOOPBACK_MSS + sizeof(IPHeader);
    ARPInfo.lip_index = LoopIndex;
    ARPInfo.lip_close = LoopClose;
    ARPInfo.lip_addaddr = LoopAddAddr;
    ARPInfo.lip_deladdr = LoopDelAddr;
    ARPInfo.lip_flags = LIP_COPY_FLAG;
    LoopIndex = NumIF + 1;
    LoopInterface.ri_if.if_index = LoopIndex;
    CTEInitEvent(&LoopXmitEvent, LoopXmitRtn);
    CTEInitLock(&LoopLock.Lock);
    LoopIFE.if_index = LoopIndex;
    LoopIFE.if_type = IF_TYPE_SOFTWARE_LOOPBACK;

    LoopIFE.if_mtu = ARPInfo.lip_mss;
    LoopIFE.if_speed = 10000000;
    LoopIFE.if_adminstatus = IF_STATUS_UP;
    LoopIFE.if_operstatus = IF_OPER_STATUS_OPERATIONAL;
    LoopIFE.if_lastchange = GetTimeTicks();
    LoopIFE.if_descrlen = sizeof(LoopName);

    IFList = (Interface *) & LoopInterface;
    NumIF++;

    NumNTE++;

    if (!InitInterface(LoopNTE))
        return NULL;

    if (!InitNTE(LoopNTE))
        return NULL;

    NumActiveNTE++;
    return LoopNTE;
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\init.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  init.c - IP Initialization routines

Abstract:

  All C init routines are located in this file. We get config. information, allocate structures,
  and generally get things going.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "arp.h"
#include "info.h"
#include "iproute.h"
#include "iprtdef.h"
#include "ipxmit.h"
#include "igmp.h"
#include "icmp.h"
#include "mdlpool.h"
#include "tcpipbuf.h"
#include "bitmap.h"

extern ulong TRFunctionalMcast;

#define NUM_IP_NONHDR_BUFFERS   500
#define DEFAULT_RA_TIMEOUT      60
#define DEFAULT_ICMP_BUFFERS    5
#define MAX_NTE_CONTEXT         0xffff
#define INVALID_NTE_CONTEXT     MAX_NTE_CONTEXT
#define WLAN_DEADMAN_TIMEOUT    120000

#define BITS_PER_ULONG  32
RTL_BITMAP g_NTECtxtMap;

ULONG g_NTECtxtMapBuffer[(MAX_NTE_CONTEXT / BITS_PER_ULONG) + 1];

NDIS_HANDLE TDPacketPool = NULL;
NDIS_HANDLE TDBufferPool = NULL;

extern Interface LoopInterface;


// Format of ifindex
//    8b    8b       16bits
// |---------------------------|
// |Unused|Unique|   index     |
// |      |  ID  |             |
// |---------------------------|

#define IF_INDEX_MASK      0xffff0000
#define IF_INDEX_SHIFT     16
uint UniqueIfNumber = 0;

LONG MultihopSets = 0;
uint TotalFreeInterfaces = 0;
uint MaxFreeInterfaces = 100;
Interface *FrontFreeList = NULL;
Interface *RearFreeList = NULL;

#if DBG_MAP_BUFFER
// For testing failure conditions related to TcpipBufferVirtualAddress and
// TcpipQueryBuffer.
ULONG g_cFailSafeMDLQueries = 0;
ULONG g_fPerformMDLFailure = FALSE;
#endif // DBG_MAP_BUFFER

//
// On stack per proc space for eliminating
// allocation inforwarding path.
//
IPRcvBuf    *g_PerCPUIpBuf = NULL;

extern IPConfigInfo *IPGetConfig(void);
extern void IPFreeConfig(IPConfigInfo *);
extern int IsIPBCast(IPAddr, uchar);
extern BOOLEAN IsRunningOnPersonal(void);

extern uint OpenIFConfig(PNDIS_STRING ConfigName, NDIS_HANDLE * Handle);
extern void CloseIFConfig(NDIS_HANDLE Handle);

extern NDIS_STATUS __stdcall IPPnPEvent(void *Context, PNET_PNP_EVENT NetPnPEvent);
extern NTSTATUS IPAddNTEContextList(HANDLE KeyHandle, ushort contextvalue, uint isPrimary);
extern NTSTATUS IPDelNTEContextList(HANDLE KeyHandle, ushort contextValue);
uint InitTimeInterfaces = 1;
uint InitTimeInterfacesDone = FALSE;
extern HANDLE IPProviderHandle;
void IPDelNTE(NetTableEntry * NTE, CTELockHandle * RouteTableHandle);

extern void ICMPInit(uint);
extern uint IGMPInit(void);
extern void ICMPTimer(NetTableEntry *);
extern IP_STATUS SendICMPErr(IPAddr, IPHeader UNALIGNED *, uchar, uchar, ulong, uchar);
extern void TDUserRcv(void *, PNDIS_PACKET, NDIS_STATUS, uint);
extern void FreeRH(ReassemblyHeader *);
extern BOOLEAN AllocIPPacketList(void);
extern UINT PacketPoolSizeMax;

extern ulong GetGMTDelta(void);
extern ulong GetTime(void);
extern ulong GetUnique32BitValue(void);

extern NTSTATUS IPStatusToNTStatus(IP_STATUS ipStatus);
extern void IPCancelPackets(void *IPIF, void * Ctxt);
extern void CheckSetAddrRequestOnInterface( Interface *IF );

extern ushort GetIPID(void);

extern uint LoopIndex;
extern RouteInterface DummyInterface;

Interface *DampingIFList = NULL;

extern void DampCheck(void);

extern uint GetAutoMetric(uint);
uint IPSecStatus = 0;

extern uint BCastMinMTU;

ulong ReEnumerateCount = 0;


void
 ReplumbAddrComplete(
                     void *Context,
                     IP_STATUS Status
                     );

void
 TempDhcpAddrDone(
                  void *Context,
                  IP_STATUS Status
                  );

extern
RouteTableEntry *
 LookupRTE(IPAddr Address, IPAddr Src, uint MaxPri, BOOLEAN UnicastOpt);

extern void NotifyAddrChange(IPAddr Addr, IPMask Mask, void *Context,
                             ushort IPContext, PVOID * Handle, PNDIS_STRING ConfigName, PNDIS_STRING IFName, uint Added);

#if MILLEN
extern void NotifyInterfaceChange(ushort IPContext, uint Added);
#endif // MILLEN

void DecrInitTimeInterfaces(Interface * IF);

extern uint IPMapDeviceNameToIfOrder(PWSTR DeviceName);
extern void IPNotifyClientsIPEvent(Interface *interface, IP_STATUS ipStatus);
uint IPSetNTEAddr(ushort Context, IPAddr Addr, IPMask Mask);
uint IPSetNTEAddrEx(ushort Context, IPAddr Addr, IPMask Mask, SetAddrControl * ControlBlock, SetAddrRtn Rtn, ushort Type);

extern NDIS_HANDLE BufferPool;
EXTERNAL_LOCK(HeaderLock)
extern HANDLE IpHeaderPool;

extern NetTableEntry *LoopNTE;

extern uchar RouterConfigured;

extern BOOLEAN
GetTempDHCPAddr(
                NDIS_HANDLE Handle,
                IPAddr * Tempdhcpaddr,
                IPAddr * TempMask,
                IPAddr * TempGWAddr,
                PNDIS_STRING ConfigName
                );

NetTableEntry **NewNetTableList;// hash table for NTEs
uint NET_TABLE_SIZE;
NetTableEntry *NetTableList;    // List of NTEs.
int NumNTE;                     // Number of NTEs.
int NumActiveNTE;
uchar RATimeout;                // Number of seconds to time out a reassembly.
uint NextNTEContext = 1;        // Next NTE context to use.

//
// A global address used for unnumbered interfaces. It is protected
// by the same lock that protects NTEs. Currently that is the RouteTableLock
//

IPAddr g_ValidAddr = 0;

ProtInfo IPProtInfo[MAX_IP_PROT];    // Protocol information table.
ProtInfo *LastPI;                // Last protinfo structure looked at.
int NextPI;                        // Next PI field to be used.
ProtInfo *RawPI = NULL;            // Raw IP protinfo

ulong TimeStamp;
ulong TSFlag;

uint DefaultTTL;
uint DefaultTOS;
uchar TrRii = TR_RII_ALL;

// Interface       *IFTable[MAX_IP_NETS];
Interface *IFList;                // List of interfaces active.
ulong NumIF;

RTL_BITMAP g_rbIfMap;
ULONG g_rgulMapBuffer[(MAX_TDI_ENTITIES / BITS_PER_ULONG) + 1];

IPInternalPerCpuStats IPPerCpuStats[IPS_MAX_PROCESSOR_BUCKETS];
CACHE_ALIGN IPSNMPInfo IPSInfo;

uint DHCPActivityCount = 0;
uint IGMPLevel;

LIST_ENTRY AddChangeNotifyQueue;

#if MILLEN
LIST_ENTRY IfChangeNotifyQueue;
DEFINE_LOCK_STRUCTURE(IfChangeLock)
#endif // MILLEN

// Firewall-queue management structures
union FirewallQCounter {
    struct {
        uint            fqc_index : 1;
        uint            fqc_entrycount : 31;
    };
    uint                fqc_value;
};
typedef union FirewallQCounter FirewallQCounter;

struct FirewallQBlock {
    Queue               fqb_queue;
    FIREWALL_HOOK       *fqb_array;
    union {
        volatile uint   fqb_exitcount : 31;
        uint            fqb_value;
    };
};
typedef struct FirewallQBlock FirewallQBlock;

FirewallQCounter FQCounter;
FirewallQBlock FQBlock[2];
#if DBG
uint FQSpinCount = 0;
#endif

// IPSec routines
IPSecHandlerRtn IPSecHandlerPtr;
IPSecQStatusRtn IPSecQueryStatusPtr;
IPSecSendCompleteRtn IPSecSendCmpltPtr;
IPSecNdisStatusRtn IPSecNdisStatusPtr;
IPSecRcvFWPacketRtn IPSecRcvFWPacketPtr;

VOID
SetPersistentRoutesForNTE(
                          IPAddr Address,
                          IPMask Mask,
                          ULONG IFIndex
                          );
uint InterfaceSize;                // Size of a net interface.

RefPtr DHCPRefPtr;
NetTableEntry DummyDHCPNTE;

#ifdef ALLOC_PRAGMA
//
// Make init code disposable.
//
void InitTimestamp();
int InitNTE(NetTableEntry * NTE);
int InitInterface(NetTableEntry * NTE);
LLIPRegRtn GetLLRegPtr(PNDIS_STRING Name);
LLIPRegRtn FindRegPtr(PNDIS_STRING Name);
uint IPRegisterDriver(PNDIS_STRING Name, LLIPRegRtn Ptr);
void CleanAdaptTable();
void OpenAdapters();
int IPInit();

#pragma alloc_text(INIT, InitTimestamp)
#pragma alloc_text(INIT, CleanAdaptTable)
#pragma alloc_text(INIT, OpenAdapters)
#pragma alloc_text(INIT, IPRegisterDriver)
#pragma alloc_text(INIT, GetLLRegPtr)
#pragma alloc_text(INIT, FindRegPtr)
#pragma alloc_text(INIT, IPInit)

NTSTATUS
IPReserveIndex(
               IN ULONG ulNumIndices,
               OUT PULONG pulStartIndex,
               OUT PULONG pulLongestRun
               );

VOID
IPDereserveIndex(
                 IN ULONG ulNumIndices,
                 IN ULONG ulStartIndex
                 );

NTSTATUS
IPChangeIfIndexAndName(
                       IN PVOID pvContext,
                       IN ULONG ulNewIndex,
                       IN PUNICODE_STRING pusNewName OPTIONAL
                       );

extern
int
 swprintf(wchar_t * buffer, const wchar_t * format,...);

NTSTATUS
ConvertGuidToString(
                    IN GUID * Guid,
                    OUT PUNICODE_STRING GuidString
                    );

NTSTATUS
ConvertStringToGuid(
                    IN PUNICODE_STRING GuidString,
                    OUT GUID * Guid
                    );

IP_STATUS
IPAddDynamicNTE(ulong InterfaceContext, PUNICODE_STRING InterfaceName,
                int InterfaceNameLen, IPAddr NewAddr, IPMask NewMask,
                ushort * NTEContext, ulong * NTEInstance);

//        #pragma alloc_text(PAGE, IPAddDynamicNTE)

#endif // ALLOC_PRAGMA

extern PDRIVER_OBJECT IPDriverObject;

extern NDIS_HANDLE ARPHandle;    // Our NDIS protocol handle.



NTSTATUS
SetRegDWORDValue(
                 HANDLE KeyHandle,
                 PWCHAR ValueName,
                 PULONG ValueData
                 );



//      SetFilterPtr - A routine to set the filter pointer.
//
//      This routine sets the IP forwarding filter callout.
//
//      Input:  FilterPtr       - Pointer to routine to call when filtering. May
//              be NULL.
//
//      Returns: IP_SUCCESS.
//
IP_STATUS
SetFilterPtr(IPPacketFilterPtr FilterPtr)
{
    CTELockHandle LockHandle;
    IP_STATUS Status;

    // If the pointer is being set to NULL, filtering is being disabled;
    // otherwise filtering is being enabled.

    CTEGetLock(&RouteTableLock.Lock, &LockHandle);
    if (FilterPtr == NULL) {
        Status = ClearRefPtr(&FilterRefPtr, &LockHandle);
    } else {
        Status = SetRefPtr(&FilterRefPtr, FilterPtr);
    }
    CTEFreeLock(&RouteTableLock.Lock, LockHandle);

    return Status;
}


//      SetIPSecPtr - A routine to set the IPSEC callouts
//
//      This routine sets the IP forwarding filter callout.
//
//      Input:  FilterPtr       - Pointer to routine to call when filtering. May
//              be NULL.
//
//      Returns: IP_SUCCESS.
//
IP_STATUS
SetIPSecPtr(PIPSEC_FUNCTIONS IpsecFns)
{
    if (IpsecFns->Version != IP_IPSEC_BIND_VERSION) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                   "!!Mismatched IP and IPSEC!!\n"));
        return IP_SUCCESS;
    }
    IPSecHandlerPtr = IpsecFns->IPSecHandler;
    IPSecQueryStatusPtr = IpsecFns->IPSecQStatus;
    IPSecSendCmpltPtr = IpsecFns->IPSecSendCmplt;
    IPSecNdisStatusPtr = IpsecFns->IPSecNdisStatus;
    IPSecRcvFWPacketPtr = IpsecFns->IPSecRcvFWPacket;
    return IP_SUCCESS;
}

IP_STATUS
UnSetIPSecPtr(PIPSEC_FUNCTIONS IpsecFns)
{
    if (IpsecFns->Version != IP_IPSEC_BIND_VERSION) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                   "!!Mismatched IP and IPSEC!!\n"));
        return IP_SUCCESS;
    }
    IPSecHandlerPtr = IPSecHandlePacketDummy;

    IPSecQueryStatusPtr = IPSecQueryStatusDummy;
    IPSecSendCmpltPtr = IPSecSendCompleteDummy;
    IPSecNdisStatusPtr = IPSecNdisStatusDummy;
    IPSecRcvFWPacketPtr = IPSecRcvFWPacketDummy;
    return IP_SUCCESS;
}

IP_STATUS
UnSetIPSecSendPtr(PIPSEC_FUNCTIONS IpsecFns)
{
    if (IpsecFns->Version != IP_IPSEC_BIND_VERSION) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                   "!!Mismatched IP and IPSEC!!\n"));
        return IP_SUCCESS;
    }
    IPSecHandlerPtr = IPSecHandlePacketDummy;
    IPSecQueryStatusPtr = IPSecQueryStatusDummy;
    IPSecNdisStatusPtr = IPSecNdisStatusDummy;
    IPSecRcvFWPacketPtr = IPSecRcvFWPacketDummy;
    return IP_SUCCESS;
}

//** InitFirewallQ - initializes the queue of firewall-hooks.
//
//  This routine is called during initialization to prepare the firewall-hook
//  elements for operation.
//
//  Input:  nothing.
//
//  Returns: nothing.
//
void
InitFirewallQ(void)
{
    INITQ(&FQBlock[0].fqb_queue);
    FQBlock[0].fqb_array = NULL;
    FQBlock[0].fqb_exitcount = 0;

    INITQ(&FQBlock[1].fqb_queue);
    FQBlock[1].fqb_array = NULL;
    FQBlock[1].fqb_exitcount = 0;

    FQCounter.fqc_index = 0;
    FQCounter.fqc_entrycount = 0;
}

//** FreeFirewallQ - releases resources used by the queue of firewall-hooks.
//
//  This routine is called during shutdown to free the firewall queue's
//  resources. As such, it assumes there are no active invocations to any
//  firewall hook routines, and no registrations/deregistrations are in
//  progress.
//
//  Input:  nothing.
//
//  Returns: nothing.
//
void
FreeFirewallQ(void)
{
    if (FQBlock[FQCounter.fqc_index].fqb_array) {
        CTEFreeMem(FQBlock[FQCounter.fqc_index].fqb_array);
        FQBlock[FQCounter.fqc_index].fqb_array = NULL;
    }
}

//** UpdateFirewallQ - Creates an updated copy of the firewall queue.
//
//  This routine is called to generate a copy of the firewall queue
//  when an entry needs to be inserted or removed. The copy includes
//  (or excludes) the new (or old) entry. If an entry is to be removed
//  and it is not found in the existing list, no changes are made.
//  It assumes the caller holds the route-table lock.
//
//  Input:  FirewallPtr     - Pointer to routine for the entry to be added
//                            or removed.
//          AddEntry        - if TRUE, 'FirewallPtr' is to be added;
//                            otherwise, 'FirewallPtr' is to be removed.
//          Priority        - specifies priority for 'FirewallPtr' if adding.
//
//  Returns: IP_SUCCESS if the queue was updated, error otherwise.
//
IP_STATUS
UpdateFirewallQ(IPPacketFirewallPtr FirewallPtr, BOOLEAN AddEntry,
                uint Priority)
{
    int                 i;
    uint                Count;
    Queue*              CurrQ;
    PFIREWALL_HOOK      CurrHook;
    PFIREWALL_HOOK      EntryHook = NULL;
    FirewallQCounter    FQC;
    FirewallQBlock      *OldFQB = &FQBlock[FQCounter.fqc_index];
    FirewallQBlock      *NewFQB = &FQBlock[1 - FQCounter.fqc_index];

    // Scan the list for the item to be inserted or removed. We must do this
    // in either case, though what we do on finding it depends on whether
    // we're inserting or removing the item. At the same time, count how many
    // entries there are, since we'll allocate one block for them all.

    CurrQ = QHEAD(&OldFQB->fqb_queue);
    Count = 0;
    while (CurrQ != QEND(&OldFQB->fqb_queue)) {
        CurrHook = QSTRUCT(FIREWALL_HOOK, CurrQ, hook_q);
        if (CurrHook->hook_Ptr == FirewallPtr) { EntryHook = CurrHook; }
        CurrQ = QNEXT(CurrQ);
        ++Count;
    }

    if (AddEntry) {
        Queue*  PrevQ;

        // Make sure the entry to be removed isn't already present,
        // then allocate space for the new array.

        if (EntryHook) { return IP_GENERAL_FAILURE; }

        NewFQB->fqb_array =
            CTEAllocMemN(sizeof(FIREWALL_HOOK) * (Count + 1), 'mICT');
        if (!NewFQB->fqb_array) { return IP_NO_RESOURCES; }

        // Transfer the entire old array (if any) to the new space,
        // and relink the queue entries in the new space, using the old linkage
        // as a guide. (I.e. entry 'i' in the old queue goes in location 'i'
        // in the new block.)
        // In the process, find the insertion point for the new entry.

        INITQ(&NewFQB->fqb_queue);
        PrevQ = &NewFQB->fqb_queue;
        CurrQ = QHEAD(&OldFQB->fqb_queue);
        i = 0;
        while (CurrQ != QEND(&OldFQB->fqb_queue)) {
            CurrHook = QSTRUCT(FIREWALL_HOOK, CurrQ, hook_q);
            NewFQB->fqb_array[i].hook_Ptr = CurrHook->hook_Ptr;
            NewFQB->fqb_array[i].hook_priority = CurrHook->hook_priority;
            ENQUEUE(&NewFQB->fqb_queue, &NewFQB->fqb_array[i].hook_q);

            if (PrevQ == &NewFQB->fqb_queue &&
                Priority < CurrHook->hook_priority) {
                PrevQ = &NewFQB->fqb_array[i].hook_q;
            }

            CurrQ = QNEXT(CurrQ);
            ++i;
        }

        // Finally, append the new item to the new array,
        // and link it into the current queue according to the given priority,
        // using the insertion point determined above.

        NewFQB->fqb_array[Count].hook_Ptr = FirewallPtr;
        NewFQB->fqb_array[Count].hook_priority = Priority;
        ENQUEUE(PrevQ, &NewFQB->fqb_array[Count].hook_q);
    } else {

        // Make sure the entry to be removed is present.
        // If it is, figure out how much space the new array will require.
        // If it's zero, we're done.

        if (!EntryHook) { return IP_GENERAL_FAILURE; }
        if (!(Count - 1)) {
            NewFQB->fqb_array = NULL;
            INITQ(&NewFQB->fqb_queue);
        } else {
            NewFQB->fqb_array =
                CTEAllocMemN(sizeof(FIREWALL_HOOK) * (Count - 1), 'mICT');
            if (!NewFQB->fqb_array) { return IP_NO_RESOURCES; }

            // Transfer the old array to the new space minus the item being
            // removed, by traversing the old queue.

            INITQ(&NewFQB->fqb_queue);
            CurrQ = QHEAD(&OldFQB->fqb_queue);
            i = 0;
            while (CurrQ != QEND(&OldFQB->fqb_queue)) {
                CurrHook = QSTRUCT(FIREWALL_HOOK, CurrQ, hook_q);
                if (CurrHook == EntryHook) {
                    CurrQ = QNEXT(CurrQ);
                    continue;
                }

                NewFQB->fqb_array[i].hook_Ptr = CurrHook->hook_Ptr;
                NewFQB->fqb_array[i].hook_priority = CurrHook->hook_priority;
                ENQUEUE(&NewFQB->fqb_queue, &NewFQB->fqb_array[i].hook_q);
                CurrQ = QNEXT(CurrQ);
                ++i;
            }
        }
    }

    // Clear the exit-count for the new location,
    // and change the global active counter to start directing
    // new references to the copy that we've just created.
    // In the process, the number of threads processing the old list
    // is captured in a local counter.

    NewFQB->fqb_exitcount = 0;
    FQC.fqc_value =
        InterlockedExchange( (PLONG) &FQCounter.fqc_value,
                             1 - FQCounter.fqc_index);

    // If there were any references to the old list, wait for them
    // to be released; then free the memory that held the old list.
    //
    // N.B.!!! This assumes that any references to the old list
    // were made by threads running at dispatch IRQL or higher,
    // since we are about to block at dispatch IRQL.

    if (OldFQB->fqb_exitcount != FQC.fqc_entrycount) {
#if DBG
        ++FQSpinCount;
#endif
        do {
            volatile uint Delay = 100;
            while (Delay--) { }
        } while (OldFQB->fqb_exitcount != FQC.fqc_entrycount);
    }
    if (OldFQB->fqb_array) {
        CTEFreeMem(OldFQB->fqb_array);
        OldFQB->fqb_array = NULL;
        INITQ(&OldFQB->fqb_queue);
    }

    return IP_SUCCESS;
}

//** RefFirewallQ - Makes a reference to the active firewall queue.
//
//  This routine is called during data-processing to find and reference
//  the active firewall queue.
//
//  Input:  FirewallQ       - receives the active firewall queue on output
//
//  Returns: a 32-bit handle to be used to release the reference.
//
uint
RefFirewallQ(Queue** FirewallQ)
{
    FirewallQCounter FQC;
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    // Increment the 31-bit entry-count through the 32-bit value that
    // shares its address in the counter structure.
    //
    // N.B. In order to increment fqc_entrycount by 1, we increment fqc_value
    // by 2 since the least-significant bit is occupied by fqc_index,
    // (the current index into FQBlock) which we don't want to modify.

    FQC.fqc_value = InterlockedExchangeAdd( (PLONG) &FQCounter.fqc_value, 2);
    *FirewallQ = &FQBlock[FQC.fqc_index].fqb_queue;
    return FQC.fqc_index;
}

//** DerefFirewallQ - Releases a reference to a firewall queue.
//
//  This routine is called to release a reference made to a firewall queue
//  in a previous call to RefFirewallQ.
//
//  Input:  Handle          - supplies the handle returned by RefFirewallQ
//
//  Returns: nothing.
//
void
DerefFirewallQ(uint Handle)
{
    InterlockedIncrement( (PLONG) &FQBlock[Handle].fqb_value);
}

//** ProcessFirewallQ - Determines whether any firewall hooks are registered.
//
//  This routine is called during data-processing to determine whether
//  there are any registrants in the queue of firewall hooks.
//
//  Input:  nothing.
//
//  Output: TRUE if firewall-hooks might be present, FALSE otherwise.
//
BOOLEAN
ProcessFirewallQ(void)
{
    return !EMPTYQ(&FQBlock[FQCounter.fqc_index].fqb_queue);
}

//      SetFirewallHook - Set the firewall hook information on a particular interface.
//
//      A routine to set the firewall hook & context on a particular interface.
//
//      Input:  pFirewallHookInfo    - Info about the hook to set.
//
//      Returns: Status of attempt.
//
IP_STATUS
SetFirewallHook(PIP_SET_FIREWALL_HOOK_INFO pFirewallHookInfo)
{
    IP_STATUS ipStatus;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    ipStatus = UpdateFirewallQ(pFirewallHookInfo->FirewallPtr,
                               pFirewallHookInfo->Add,
                               pFirewallHookInfo->Priority);

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return IPStatusToNTStatus(ipStatus);
}

//      SetMapRoutePtr - A routine to set the dial on demand callout pointer.
//
//      This routine sets the IP dial on demand callout.
//
//      Input:  MapRoutePtr     - Pointer to routine to call when we need to bring
//                      up a link. May be NULL
//
//      Returns: IP_SUCCESS.
//
IP_STATUS
SetMapRoutePtr(IPMapRouteToInterfacePtr MapRoutePtr)
{
    CTELockHandle LockHandle;
    IP_STATUS Status;

    // If the pointer is being set to NULL, dial-on-demand is being disabled;
    // otherwise it's being enabled.

    CTEGetLock(&RouteTableLock.Lock, &LockHandle);
    if (MapRoutePtr == NULL) {
        Status = ClearRefPtr(&DODRefPtr, &LockHandle);
    } else {
        Status = SetRefPtr(&DODRefPtr, MapRoutePtr);
    }
    CTEFreeLock(&RouteTableLock.Lock, LockHandle);

    return Status;
}

//**    SetDHCPNTE
//
//  Routine to identify which NTE is currently being DHCP'ed. We take as input
//  an nte_context. If the context is less than the max NTE context, we look
//  for a matching NTE and if we find him we save a pointer. If we don't we
//  fail. If the context > max NTE context we're disabling DHCPing, and
//  we NULL out the save pointer.
//
//  In addition to saving a pointer, the nte is marked as "isdhcp".
//  The above change is to have multiple dhcp'able NTE's simultaneously.
//
//  Input:  Context         - NTE context value.
//
//  Returns: TRUE if we succeed, FALSE if we don't.
//
uint
SetDHCPNTE(uint Context)
{
    CTELockHandle Handle;
    NetTableEntry *NTE = NULL;
    ushort NTEContext;
    uint RetCode = FALSE;
    uint i;

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("+SetDHCPNTE(%x)\n"), Context));

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    if (Context < MAX_NTE_CONTEXT) {

        // Look for an NTE that matches the context.
        NTEContext = (ushort) Context;

        for (i = 0; i < NET_TABLE_SIZE; i++) {
            for (NTE = NewNetTableList[i]; NTE != NULL; NTE = NTE->nte_next) {
                if (NTE != LoopNTE && NTE->nte_context == NTEContext) {
                    // Found one. Save it and break out.
                    if (!(NTE->nte_flags & NTE_VALID)) {
                        NTE->nte_flags |= NTE_DHCP;
                    }

                    // Clear the referenced pointer before setting a new one.
                    if (RefPtrValid(&DHCPRefPtr)) {
                        ClearRefPtr(&DHCPRefPtr, &Handle);
                    }

                    RetCode = (SetRefPtr(&DHCPRefPtr, NTE) == IP_SUCCESS);
                    break;
                }
            }
            if (NTE) {
                DEBUGMSG(DBG_INFO && DBG_DHCP,
                    (DTEXT("SetDHCPNTE: DHCPNTE = %x (%x)\n"), NTE, NTE->nte_context));
                break;
            }
        }
    } else {
        // The context is invalid, so we're deleting the DHCP NTE.
        ClearRefPtr(&DHCPRefPtr, &Handle);

        RetCode = TRUE;
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("-SetDHCPNTE [%x]\n"), RetCode));

    return RetCode;
}

//**    IsDHCPInterface
//
//  Routine for upper layers to call to check if the IPContext value passed
//  up to a RcvHandler identifies an interface that is currently being
//  DHCP'd.
//
//      Input:   Context                - Pointer to an NTE
//
//      Returns: TRUE if we succeed, FALSE if we don't.
//
uint
IsDHCPInterface(void *IPContext)
{
//      CTELockHandle           Handle;
    uint RetCode;
    NetTableEntry *NTE = (NetTableEntry *) IPContext;

//      CTEGetLock(&RouteTableLock.Lock, &Handle);

    // just check to see if the dhcp-is-working flag is turned on on the
    // NTE.  This will be turned on by DHCP via SetDHCPNTE, and turned off
    // whenever a valid address is set on the interface.
    RetCode = (NTE->nte_flags & NTE_DHCP) ? TRUE : FALSE;

    if (RetCode) {
        ASSERT(!(NTE->nte_flags & NTE_VALID));
    }
//      CTEFreeLock(&RouteTableLock.Lock, Handle);

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("IsDHCPInterface(%x) -> [%x]\n"), NTE, RetCode));

    return (RetCode);
}

//**    IsWlanInterface
//
//  Routine for upper layers to call to check if the Interface passed in
//  corresponds to a wireless medium.
//
//      Input:  IF      - Pointer to an Interface.
//
//      Returns: TRUE if wireless, FALSE otherwise.
//
uint
IsWlanInterface(Interface* IF)
{
    NDIS_PHYSICAL_MEDIUM NPM;
    NDIS_STATUS Status;

    if (IF->if_dondisreq) {
        Status = (*IF->if_dondisreq)(IF->if_lcontext,
                                     NdisRequestQueryInformation,
                                     OID_GEN_PHYSICAL_MEDIUM, &NPM, sizeof(NPM),
                                     NULL, TRUE);
        if (Status == NDIS_STATUS_SUCCESS &&
            NPM == NdisPhysicalMediumWirelessLan) {
            return TRUE;
        }
    }

    return FALSE;
}

void
DHCPActivityDone(NetTableEntry * NTE, Interface * IF, CTELockHandle * RouteTableHandle, uint Decr)
{
    DHCPActivityCount--;

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("DHCPActivityDone(%x, %x, %x, %x) ActivityCount %d\n"),
         NTE, IF, RouteTableHandle, Decr));

    NTE->nte_flags &= ~NTE_DHCP;
    if (Decr) {
        // This routine takes route table lock inside so release it here
        CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
        DecrInitTimeInterfaces(IF);
        CTEGetLock(&RouteTableLock.Lock, RouteTableHandle);
    }
}

//**    CloseNets - Close active nets.
//
//  Called when we need to close some lower layer interfaces.
//
//  Entry:  Nothing
//
//  Returns: Nothing
//
void
CloseNets(void)
{
    NetTableEntry *nt;
    uint i;

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        for (nt = NewNetTableList[i]; nt != NULL; nt = nt->nte_next) {
            (*nt->nte_if->if_close) (nt->nte_if->if_lcontext);    // Call close routine for this net.

        }
    }
}

void
__stdcall
IPBindComplete(
               IN IP_STATUS BindStatus,
               IN void *BindContext
               )
{
    NdisCompleteBindAdapter(BindContext, BindStatus, 0 /*??*/ );
}

//**    IPDelayedNdisReEnumerateBindings
//
//  This requests NDIS to reenumerate our bindings to adapters that
//  are still unresolved (i.e. unopened). This is to give a chance
//  for external ARP modules to try and bind to such adapters.
//
//  Input:      Event - event that fired us off
//                      Context - ignored
//
//  Returns: Nothing
//
VOID
IPDelayedNdisReEnumerateBindings(
                                 CTEEvent * Event,
                                 PVOID Context
                                 )
{
    UNREFERENCED_PARAMETER(Context);

    InterlockedIncrement( (PLONG) &ReEnumerateCount);
    NdisReEnumerateProtocolBindings(ARPHandle);

    if (Event) {
        CTEFreeMem(Event);
    }
}

PARP_MODULE
IPLookupArpModuleWithLock(
                          UNICODE_STRING ArpName
                          )
{
    PLIST_ENTRY entry;
    PARP_MODULE pModule;

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
        (DTEXT("+IPLookupArpModuleWithLock(%x)\n"), &ArpName));

    entry = ArpModuleList.Flink;
    while (entry != &ArpModuleList) {
        pModule = STRUCT_OF(ARP_MODULE, entry, Linkage);

        if ((pModule->Name.Length == ArpName.Length) &&
            RtlEqualMemory(pModule->Name.Buffer,
                           ArpName.Buffer,
                           ArpName.Length)) {
            DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
                (DTEXT("-IPLookupArpModuleWithLock [%x]\n"), pModule));
            InterlockedIncrement(&pModule->ReferenceCount);
            return pModule;
        }
        entry = entry->Flink;
    }

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
        (DTEXT("-IPLookupArpModuleWithLock [NULL]\n")));
    return NULL;
}

PARP_MODULE
IPLookupArpModule(
                  UNICODE_STRING ArpName
                  )
{
    PARP_MODULE pModule;
    KIRQL OldIrql;

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
        (DTEXT("+IPLookupArpModule(%x)\n"), &ArpName));

    CTEGetLock(&ArpModuleLock, &OldIrql);
    pModule = IPLookupArpModuleWithLock(ArpName);
    CTEFreeLock(&ArpModuleLock, OldIrql);

    DEBUGMSG(DBG_TRACE && DBG_ARP && DBG_INIT,
        (DTEXT("-IPLookupArpModule [NULL]\n")));
    return pModule;
}

VOID
IPDereferenceArpModule(
                       PARP_MODULE pModule
                       )
{
    if (InterlockedDecrement(&pModule->ReferenceCount) == 0) {
        CTESignal(&pModule->Block, IP_SUCCESS);
    }
}


//*     IPRegisterARP - Register an ARP module with us.
//
//      Called by ARP modules to register their bind handlers with IP.
//
//      Input:  ARPName                 -  name of the ARP module
//              Version                 -  Suggested value of 0x50000 for NT 5.0 and memphis
//                              ARPBindHandler          -  handler to call on BindAdapter
//                              IpAddInterfaceHandler   -  handler to Add interfaces
//                              IpDelInterfaceHandler   -  handler to Del interfaces
//              IpBindCompleteHandler   -  handler to complete binds
//              ARPRegisterHandle       -  handle returned on Deregister
//      Returns:    Status of operation
//
NTSTATUS
__stdcall
IPRegisterARP(
              IN PNDIS_STRING ARPName,
              IN uint Version,
              IN ARP_BIND ARPBindHandler,
              OUT IP_ADD_INTERFACE * IpAddInterfaceHandler,
              OUT IP_DEL_INTERFACE * IpDelInterfaceHandler,
              OUT IP_BIND_COMPLETE * IpBindCompleteHandler,
              OUT IP_ADD_LINK * IpAddLinkHandler,
              OUT IP_DELETE_LINK * IpDeleteLinkHandler,
              OUT IP_CHANGE_INDEX * IpChangeIndex,
              OUT IP_RESERVE_INDEX * IpReserveIndex,
              OUT IP_DERESERVE_INDEX * IpDereserveIndex,
              OUT HANDLE * ARPRegisterHandle
              )
{
    PARP_MODULE pArpModule;
    PARP_MODULE pArpModule1;
    CTEEvent *Event;

    pArpModule1 = NULL;

    DEBUGMSG(DBG_TRACE && DBG_ARP,
        (DTEXT("+IPRegisterARP(%x, %x, %x, ...)\n"),
         ARPName, Version, ARPBindHandler));

    *ARPRegisterHandle = NULL;

    if (Version != IP_ARP_BIND_VERSION) {
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Wrong bind version: %lx\n", Version));
        return STATUS_INVALID_PARAMETER;
    }
    //
    // Insert into the Arp module list.
    //
    if ((pArpModule = CTEAllocMemNBoot(sizeof(ARP_MODULE) + ARPName->Length, 'mICT')) == NULL) {
        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Failed to allocate Arpmodule struct\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    pArpModule->ReferenceCount = 1;
    CTEInitBlockStruc(&pArpModule->Block);
    pArpModule->BindHandler = ARPBindHandler;

    pArpModule->Name.Buffer = (PWSTR) (pArpModule + 1);
    pArpModule->Name.MaximumLength = ARPName->Length;
    RtlCopyUnicodeString(&pArpModule->Name, ARPName);

#if DBG
    {
        KIRQL OldIrql;
        CTEGetLock(&ArpModuleLock, &OldIrql);
        if ((pArpModule1 = IPLookupArpModuleWithLock(*ARPName)) != NULL) {
            KdPrint(("Double register from %lx\n", pArpModule));
            DbgBreakPoint();
            CTEFreeLock(&ArpModuleLock, OldIrql);
            IPDereferenceArpModule(pArpModule1);
            return STATUS_INVALID_PARAMETER;
        }
        InsertTailList(&ArpModuleList,
                       &pArpModule->Linkage);

        CTEFreeLock(&ArpModuleLock, OldIrql);
    }
#else
    ExInterlockedInsertTailList(&ArpModuleList,
                                &pArpModule->Linkage,
                                &ArpModuleLock);
#endif

    //
    // Return the other handler pointers
    //
    *IpAddInterfaceHandler = IPAddInterface;
    *IpDelInterfaceHandler = IPDelInterface;
    *IpBindCompleteHandler = IPBindComplete;

    *IpAddLinkHandler = IPAddLink;
    *IpDeleteLinkHandler = IPDeleteLink;

    *IpChangeIndex = IPChangeIfIndexAndName;
    *IpReserveIndex = IPReserveIndex;
    *IpDereserveIndex = IPDereserveIndex;

    //
    // We should request NDIS to reevaluate our adapter bindings, because
    // this new ARP module might handle one or more of our unbound adapters.
    // But we don't do it right here because our caller (ARP module) may not
    // be prepared for a BindAdapter call now. So we queue it to the
    // worker thread.
    //
    Event = CTEAllocMemNBoot(sizeof(CTEEvent), 'oICT');
    if (Event) {
        CTEInitEvent(Event, IPDelayedNdisReEnumerateBindings);
        CTEScheduleDelayedEvent(Event, NULL);
    }
    *ARPRegisterHandle = (PVOID) pArpModule;

    return STATUS_SUCCESS;
}

//*     IPDeregisterARP - Deregister an ARP module from IP.
//
//      Called by ARP modules to deregister their bind handlers with IP.
//
//      Input:  ARPRegisterHandle       -  handle returned on Register
//      Returns:    Status of operation
//
NTSTATUS
__stdcall
IPDeregisterARP(
                IN HANDLE ARPRegisterHandle
                )
{
    PARP_MODULE pArpModule = (PARP_MODULE) ARPRegisterHandle;
    PARP_MODULE pArpModule1;
    KIRQL OldIrql;

    pArpModule1 = NULL;

    CTEGetLock(&ArpModuleLock, &OldIrql);

#if DBG
    if ((pArpModule1 = IPLookupArpModuleWithLock(pArpModule->Name)) == NULL) {
        KdPrint(("Deregister from %lx when none registered!\n", pArpModule));
        DbgBreakPoint();
        CTEFreeLock(&ArpModuleLock, OldIrql);
        return STATUS_INVALID_PARAMETER;
    }
    ASSERT(pArpModule1 == pArpModule);
#endif
    RemoveEntryList(&pArpModule->Linkage);

    CTEFreeLock(&ArpModuleLock, OldIrql);

    //
    // Drop the initial reference so that the entry may be freed.
    //
    CTEClearSignal(&pArpModule->Block);
    IPDereferenceArpModule(pArpModule);
    CTEBlock(&pArpModule->Block);
    CTEFreeMem(pArpModule);

    return STATUS_SUCCESS;
}

#if MILLEN

//
// Helper routine to append a NULL-terminated string to an ANSI_SRING.
//
NTSTATUS
AppendAnsiString (
    IN PANSI_STRING Destination,
    IN PCHAR Source
    )
{
    USHORT n;

    n = (USHORT) strlen(Source);

    if ((n + Destination->Length) > Destination->MaximumLength) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlMoveMemory( &Destination->Buffer[ Destination->Length ], Source, n );
    Destination->Length += n;

    return STATUS_SUCCESS;
}

//*     MillenLoadDriver - Jump into NTKERNs NtKernWin9XLoadDriver.
//
//      Calls into NTKERNs VxD entrypoint for NtKernWin9xLoadDriver.
//
//      Input:
//          FileName - Full filename of driver to load. (no path).
//          RegistryPath - Registry path associated with driver.
//
//      Returns: NULL - Failure.
//               Pointer to driver object - success.
//
PVOID
__cdecl
MillenLoadDriver(
    PCHAR   FileName,
    PCHAR   RegistryPath
    )
{
    PVOID DriverObject;

    //
    // Do an int 20 to jmp into NTKERN service table - 0x000b is
    // NtKernWin9XLoadDriver entry.
    //

    _asm {
        push [RegistryPath]
        push [FileName]
        _emit 0xcd
        _emit 0x20
        _emit 0x0b // NtKernWin9XLoadDriver (Low)
        _emit 0x00 // NtKernWin9XLoadDriver (Hign)
        _emit 0x4b // NTKERN VxD ID (Low)
        _emit 0x00 // NTKERN VxD ID (High)
        add esp,8
        mov [DriverObject], eax
    }

    return DriverObject;
}

//*     MillenLoadArpModule - Loads an ARP module.
//
//      Calls into NTKERN to load the given ARP module. The real reason for this
//      is that the given registry path (under binding config) will contain a
//      key such that the ARP module is loaded into non-preemptable memory.
//      Otherwise, some issues arise with pre-emption when calling between
//      the stack and external ARP modules.
//
//      Input:
//          UnicodeFileName - Filename of the ARP module to open (without extension).
//          UnicodeConfigName - Registry path of TCP/IP binding.
//
//      Returns: NT Status code.
//
NTSTATUS
MillenLoadArpModule(
    PUNICODE_STRING UnicodeFileName,
    PUNICODE_STRING UnicodeConfigName
    )
{
    ANSI_STRING FileName;
    ANSI_STRING ConfigName;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PVOID       DriverObject;

    RtlZeroMemory(&FileName, sizeof(ANSI_STRING));
    RtlZeroMemory(&ConfigName, sizeof(ANSI_STRING));

    //
    // Allocate FileName and convert from unicode. Append ".sys".
    //

    FileName.Length = 0;
    FileName.MaximumLength = UnicodeFileName->Length/2 + sizeof(".sys");

    FileName.Buffer = CTEAllocMem(FileName.MaximumLength);

    if (FileName.Buffer == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    RtlZeroMemory(FileName.Buffer, FileName.MaximumLength);

    NtStatus = RtlUnicodeStringToAnsiString(
        &FileName,
        UnicodeFileName,
        FALSE); // Buffer already allocated.

    if (NT_ERROR(NtStatus)) {
        goto done;
    }

    NtStatus = AppendAnsiString(
        &FileName,
        ".sys");

    if (NT_ERROR(NtStatus)) {
        goto done;
    }

    //
    // Allocate ConfigName and convert from unicode.
    //

    NtStatus = RtlUnicodeStringToAnsiString(
        &ConfigName,
        UnicodeConfigName,
        TRUE); // Allocate config name.

    if (NT_ERROR(NtStatus)) {
        goto done;
    }

    //
    // Now call into NtKern to load the driver.
    //

    DriverObject = MillenLoadDriver(FileName.Buffer, ConfigName.Buffer);

    if (DriverObject == NULL) {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto done;
    }

done:

    if (FileName.Buffer) {
        CTEFreeMem(FileName.Buffer);
    }

    if (ConfigName.Buffer) {
        RtlFreeAnsiString(&ConfigName);
    }

    if (NT_ERROR(NtStatus)) {
        DEBUGMSG(DBG_ERROR, (DTEXT("MillenLoadArpModule failure %x\n"), NtStatus));
    }

    return NtStatus;
}
#endif // MILLEN

//*     IPBindAdapter - Bind and initialize an adapter.
//
//      Called in a PNP environment to initialize and bind an adapter. We determine
//      the appropriate underlying arp layer and call into its BindHandler.
//
//      Input:  RetStatus               - Where to return the status of this call.
//              BindContext             - Handle to use for calling BindAdapterComplete.
//                              AdapterName             - Pointer to name of adapter.
//                              SS1                                             - System specific 1 parameter.
//                              SS2                                             - System specific 2 parameter.
//
//      Returns: Nothing.
//
void
 __stdcall
IPBindAdapter(
              PNDIS_STATUS RetStatus,
              NDIS_HANDLE BindContext,
              PNDIS_STRING AdapterName,
              PVOID SS1,
              PVOID SS2
              )
{
    NDIS_HANDLE Handle;
    UNICODE_STRING valueString;
    PARP_MODULE pArpModule;
    NDIS_STATUS status;
    UNICODE_STRING ServicesKeyName = NDIS_STRING_CONST("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");
    UNICODE_STRING arpDriverName;

    *RetStatus = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("+IPBindAdapter(%x, %x, %x, %x, %x)\n"),
        RetStatus, BindContext, AdapterName, SS1, SS2));

    valueString.MaximumLength = 200;
    if ((valueString.Buffer = CTEAllocMemNBoot(valueString.MaximumLength, 'pICT')) == NULL) {
        *RetStatus = NDIS_STATUS_RESOURCES;
        return;
    }
    *(valueString.Buffer) = UNICODE_NULL;

    //
    // Get the value for LLInterface
    //
    if (!OpenIFConfig(SS1, &Handle)) {
        *RetStatus = NDIS_STATUS_FAILURE;
        CTEFreeMem(valueString.Buffer);
        return;
    }
    //
    // Get the value under LLInterface.
    //
    status = GetLLInterfaceValue(Handle, &valueString);

    // Can close the config handle here.
    CloseIFConfig(Handle);

#if MILLEN
    //
    // Note: On Millenium, the 1394 ARP module may not have plumbed the
    // LLInterface value into the bindings key, instead it may be under the
    // adapter instance key.
#define MILLEN_ADAPTER_INST_PATH L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Class\\Net\\"

    if (!NT_SUCCESS(status)) {
        NDIS_STRING AdapterInstance;
        NDIS_STRING UnicodeAdapterName;
        NTSTATUS    NtStatus;

        UnicodeAdapterName.Buffer = NULL;

        NtStatus = RtlAnsiStringToUnicodeString(
            &UnicodeAdapterName,
            (PANSI_STRING) AdapterName,
            TRUE);

        if (NT_SUCCESS(NtStatus)) {
            // I have seen where the length of AdapterName is incorrect. Ensure
            // that the length is correct since TDI bindings depend on this string
            // value.
            UnicodeAdapterName.Length = wcslen(UnicodeAdapterName.Buffer) * sizeof(WCHAR);

            DEBUGMSG(DBG_INFO && DBG_PNP,
                (DTEXT("IPBindAdapter: Win9X specific: attempting to retrieve LLIF ")
                 TEXT("under adapter instance %ws\n"), UnicodeAdapterName.Buffer));

            // sizeof will allow for null-termination character.
            AdapterInstance.MaximumLength = sizeof(MILLEN_ADAPTER_INST_PATH) +
                    UnicodeAdapterName.Length + sizeof(WCHAR);
            AdapterInstance.Length = 0;

            AdapterInstance.Buffer = CTEAllocMem(AdapterInstance.MaximumLength);


            if (AdapterInstance.Buffer != NULL) {

                RtlZeroMemory(AdapterInstance.Buffer, AdapterInstance.MaximumLength);

                RtlAppendUnicodeToString(&AdapterInstance, MILLEN_ADAPTER_INST_PATH);
                RtlAppendUnicodeStringToString(&AdapterInstance, &UnicodeAdapterName);

                if (OpenIFConfig(&AdapterInstance, &Handle)) {
                    status = GetLLInterfaceValue(Handle, &valueString);
                    CloseIFConfig(Handle);
                } else {
                    DEBUGMSG(DBG_ERROR,
                        (DTEXT("IPBindAdapter: failed to open secondary LLIF reg %ws\n"),
                         AdapterInstance.Buffer));
                }

                CTEFreeMem(AdapterInstance.Buffer);
            }
            RtlFreeUnicodeString(&UnicodeAdapterName);
        }
    }
#endif // MILLEN

    if (NT_SUCCESS(status) && (*(valueString.Buffer) != UNICODE_NULL)) {

        DEBUGMSG(DBG_INFO && DBG_PNP,
            (DTEXT("IPBindAdapter: found LLIF value %x\n"), valueString.Buffer));

        //
        // We found a proper value => non-default ARP
        //
        //
        // Lookup the appropriate BindHandler
        //
        if ((pArpModule = IPLookupArpModule(valueString)) == NULL) {
#if MILLEN
            status = MillenLoadArpModule(&valueString, SS1);

            if (status == STATUS_SUCCESS) {
                pArpModule = IPLookupArpModule(valueString);
            }
#else // MILLEN
            //
            // no entrypoint registered
            //

            //
            // Maybe the ARP driver isn't loaded yet. Try loading it.
            //
            arpDriverName.MaximumLength = ServicesKeyName.MaximumLength +
                valueString.MaximumLength;

            arpDriverName.Buffer = CTEAllocMemNBoot(arpDriverName.MaximumLength, 'qICT');

            if (arpDriverName.Buffer != NULL) {

                //
                // Prepare the complete registry path for the driver service.
                //
                arpDriverName.Length = 0;
                RtlCopyUnicodeString(&arpDriverName, &ServicesKeyName);
                status = RtlAppendUnicodeStringToString(&arpDriverName, &valueString);
                ASSERT(NT_SUCCESS(status));

                //
                // Try to load the driver.
                //
                status = ZwLoadDriver(&arpDriverName);

                CTEFreeMem(arpDriverName.Buffer);

                if (NT_SUCCESS(status)) {
                    pArpModule = IPLookupArpModule(valueString);
                }
            }
#endif // !MILLEN

            if (pArpModule == NULL) {
                *RetStatus = NDIS_STATUS_FAILURE;
                CTEFreeMem(valueString.Buffer);
                return;
            }
        }
        //
        // Bind to ARP
        //
        (*pArpModule->BindHandler) (RetStatus,
                                    BindContext,
                                    AdapterName,
                                    SS1,
                                    SS2);
        IPDereferenceArpModule(pArpModule);
    } else {

        DEBUGMSG(DBG_INFO && DBG_PNP,
            (DTEXT("IPBindAdapter: No LLIF value - Calling ARPBindAdapter...\n")));

        ARPBindAdapter(RetStatus,
                       BindContext,
                       AdapterName,
                       SS1,
                       SS2);
    }

    CTEFreeMem(valueString.Buffer);
}

//**    IPRegisterProtocol - Register a protocol with IP.
//
//  Called by upper layer software to register a protocol. The UL supplies
//  pointers to receive routines and a protocol value to be used on xmits/receives.
//
//  Entry:
//      Protocol - Protocol value to be returned.
//      RcvHandler - Receive handler to be called when frames for Protocol are received.
//      XmitHandler - Xmit. complete handler to be called when frames from Protocol are completed.
//      StatusHandler - Handler to be called when status indication is to be delivered.
//
//  Returns:
//      Pointer to ProtInfo,
//
void *
IPRegisterProtocol(uchar Protocol, void *RcvHandler, void *XmitHandler,
                   void *StatusHandler, void *RcvCmpltHandler, void *PnPHandler, void *ElistHandler)
{
    ProtInfo *PI = (ProtInfo *) NULL;
    int i;
    int Incr = 0;

    // First check to see if it's already registered. If it is just replace it.
    for (i = 0; i < NextPI; i++)
        if (IPProtInfo[i].pi_protocol == Protocol) {
            PI = &IPProtInfo[i];
            Incr = 0;
            break;
        }
    if (PI == (ProtInfo *) NULL) {
        if (NextPI >= MAX_IP_PROT) {
            return NULL;
        }
        PI = &IPProtInfo[NextPI];
        Incr = 1;

        if (Protocol == PROTOCOL_ANY) {
            RawPI = PI;
        }
    }
    PI->pi_protocol = Protocol;
    PI->pi_rcv = RcvHandler;
    PI->pi_xmitdone = XmitHandler;
    PI->pi_status = StatusHandler;
    PI->pi_rcvcmplt = RcvCmpltHandler;
    PI->pi_pnppower = PnPHandler;
    PI->pi_elistchange = ElistHandler;
    PI->pi_valid = PI_ENTRY_VALID;
    NextPI += Incr;

    return PI;
}



//**    IPDeregisterProtocol - DeRegister a protocol with IP.
//
//  Called by upper layer software to de-register a protocol. The UL can not
//  unload itself after deregister is called.
//
//  Entry:
//      Protocol - Protocol value to be returned.
//
//  Returns:
//      None or pointer to ProtInfo
//
void *
IPDeregisterProtocol(uchar Protocol)
{
    ProtInfo *PI = (ProtInfo *) NULL;
    int i;

    // First check to see if it's already registered. If it is just replace it.
    for (i = 0; i < NextPI; i++) {

        if (IPProtInfo[i].pi_protocol == Protocol) {
            PI = &IPProtInfo[i];
            break;
        }
    }

    if (PI == (ProtInfo *) NULL) {
        return NULL;
    }

    if (PI == LastPI) {
        InterlockedExchangePointer(&LastPI, IPProtInfo);
    }
    PI->pi_valid = PI_ENTRY_INVALID;

    return PI;
}


//** GetMcastNTEFromAddr - Get a multicast-capable NTE given an IP address.
//
//      Called when joining/leaving multicast groups on an interface identified
//      IP an address (or ifindex or INADDR_ANY).
//
//      Input:  IF         - IP Address/IfIndex of interface to set/delete on,
//                           in network byte order.
//
//      Returns: NTE to join on.
//
NetTableEntry *
GetMcastNTEFromAddr(IPAddr IF)
{
    NetTableEntry *LocalNTE = NULL;
    uint i;
    CTELockHandle   Handle;

    // To optimize the test below, we convert the address to host-byte
    // order outside the loop, just in case it's an interface index.
    uint IfIndex = net_long(IF);

    // now that we have a hash table we can optimize the search for the case
    // when IF is a non-NULL IP Addr, but then we have to make special cases when
    // IF is NULL / IF is actually an IF index.
    // Right now, lets do it simple way.

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (LocalNTE = NetTableList; LocalNTE != NULL;
             LocalNTE = LocalNTE->nte_next) {
            if (!(LocalNTE->nte_flags & NTE_VALID) ||
                (LocalNTE->nte_if->if_flags & IF_FLAGS_NOLINKBCST))
                continue;

            if (LocalNTE != LoopNTE &&
                (((!IP_ADDR_EQUAL(LocalNTE->nte_addr, NULL_IP_ADDR) &&
                   (IP_ADDR_EQUAL(IF, NULL_IP_ADDR) ||
                    IP_ADDR_EQUAL(IF, LocalNTE->nte_addr))) ||
                  (LocalNTE->nte_if->if_index == IfIndex))))
                break;
        }
        if (LocalNTE != NULL)
            break;
    }

    if (LocalNTE == NULL) {
        // Couldn't find a matching NTE.
        // Search for a valid interface if IF specified was NULL.

        if (IP_ADDR_EQUAL(IF, NULL_IP_ADDR)) {
            for (i = 0; i < NET_TABLE_SIZE; i++) {
                NetTableEntry *NetTableList = NewNetTableList[i];
                for (LocalNTE = NetTableList; LocalNTE != NULL;
                     LocalNTE = LocalNTE->nte_next) {
                    if (!(LocalNTE->nte_flags & NTE_VALID) ||
                        (LocalNTE->nte_if->if_flags & IF_FLAGS_NOLINKBCST))
                        continue;
                    if (LocalNTE != LoopNTE)
                        break;

                }
                if (LocalNTE != NULL)
                    break;
            }
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return LocalNTE;
}

//** IPSetMCastAddr - Set/Delete a multicast address.
//
//      Called by an upper layer protocol or client to set or delete an IP multicast
//      address.
//
//      Input:  Address    - Address to be set/deleted.
//              IF         - IP Address/IfIndex of interface to set/delete on.
//              Action     - TRUE if we're setting, FALSE if we're deleting.
//              FilterMode - MCAST_INCLUDE or MCAST_EXCLUDE
//              NumSources - number of entries in SourceList array
//              SourceList - array of source addresses
//
//      Returns: IP_STATUS of set/delete attempt.
//
IP_STATUS
IPSetMCastAddr(IPAddr Address, IPAddr IF, uint Action,
               uint NumExclSources, IPAddr *ExclSourceList,
               uint NumInclSources, IPAddr *InclSourceList)
{
    NetTableEntry *LocalNTE;

    // Don't let him do this on the loopback address, since we don't have a
    // route table entry for class D address on the loopback interface and
    // we don't want a packet with a loopback source address to show up on
    // the wire.
    //new scheme for bug 250417
    // We will only enable receive on mcast address on loopback interface.
    // To facilitate this, GetLocalNTE on rcv path will return
    // DEST_MCAST and BcastRcv will check if we are rcving on LoopNTE.
    // So, fake IP_SUCCESS if this is a loopback NTE.
    // No need to add/delete igmp addr on this interface though

    if (IP_LOOPBACK_ADDR(IF) || (IF == net_long(LoopIndex))) {
        return IP_SUCCESS;
    }

    LocalNTE = GetMcastNTEFromAddr(IF);

    if (LocalNTE == NULL) {
        // Still can't find matching NTE
        return IP_BAD_REQ;
    }

    return IGMPAddrChange(LocalNTE, Address, Action ? IGMP_ADD : IGMP_DELETE,
                          NumExclSources, ExclSourceList,
                          NumInclSources, InclSourceList);
}

//** IPSetMCastInclude - Add/Delete multicast sources to include.
//
//      Called by an upper layer protocol or client to add or delete IP
//      multicast sources to allow to pass the source filter.
//
//      Input:  GroupAddress      - Group Address to be updated.
//              Interface Address - IP Address/IfIndex of interface.
//              NumAddSources     - Number of entries in AddSourceList
//              AddSourcelist     - Array of sources to add
//              NumDelSources     - Number of entries in DelSourceList
//              DelSourcelist     - Array of sources to delete
//
//      Returns: IP_STATUS of add/delete attempt.
//
IP_STATUS
IPSetMCastInclude(IPAddr GroupAddress, IPAddr InterfaceAddress,
                  uint NumAddSources, IPAddr *AddSourceList,
                  uint NumDelSources, IPAddr *DelSourceList)
{
    NetTableEntry *LocalNTE;

    // Don't let him do this on the loopback address, since we don't have a
    // route table entry for class D address on the loopback interface and
    // we don't want a packet with a loopback source address to show up on
    // the wire.
    //new scheme for bug 250417
    // We will only enable receive on mcast address on loopback interface.
    // To facilitate this, GetLocalNTE on rcv path will return
    // DEST_MCAST and BcastRcv will check if we are rcving on LoopNTE.
    // So, fake IP_SUCCESS if this is a loopback NTE.
    // No need to add/delete igmp addr on this interface though

    if (IP_LOOPBACK_ADDR(InterfaceAddress) ||
        (InterfaceAddress == net_long(LoopIndex))) {
        return IP_SUCCESS;
    }

    LocalNTE = GetMcastNTEFromAddr(InterfaceAddress);

    if (LocalNTE == NULL) {
        // Still can't find matching NTE
        return IP_BAD_REQ;
    }

    return IGMPInclChange(LocalNTE, GroupAddress,
                          NumAddSources, AddSourceList,
                          NumDelSources, DelSourceList);
}

//** IPSetMCastExclude - Add/Delete multicast sources to exclude.
//
//      Called by an upper layer protocol or client to add or delete IP
//      multicast sources to deny in a source filter.
//
//      Input:  GroupAddress      - Group Address to be set/deleted.
//              Interface Address - IP Address/IfIndex of interface.
//              NumAddSources     - Number of entries in AddSourceList
//              AddSourcelist     - Array of sources to add
//              NumDelSources     - Number of entries in DelSourceList
//              DelSourcelist     - Array of sources to delete
//
//      Returns: IP_STATUS of add/delete attempt.
//
IP_STATUS
IPSetMCastExclude(IPAddr GroupAddress, IPAddr InterfaceAddress,
                  uint NumAddSources, IPAddr *AddSourceList,
                  uint NumDelSources, IPAddr *DelSourceList)
{
    NetTableEntry *LocalNTE;

    // Don't let him do this on the loopback address, since we don't have a
    // route table entry for class D address on the loopback interface and
    // we don't want a packet with a loopback source address to show up on
    // the wire.
    //new scheme for bug 250417
    // We will only enable receive on mcast address on loopback interface.
    // To facilitate this, GetLocalNTE on rcv path will return
    // DEST_MCAST and BcastRcv will check if we are rcving on LoopNTE.
    // So, fake IP_SUCCESS if this is a loopback NTE.
    // No need to add/delete igmp addr on this interface though

    if (IP_LOOPBACK_ADDR(InterfaceAddress) ||
        (InterfaceAddress == net_long(LoopIndex))) {
        return IP_SUCCESS;
    }

    LocalNTE = GetMcastNTEFromAddr(InterfaceAddress);

    if (LocalNTE == NULL) {
        // Still can't find matching NTE
        return IP_BAD_REQ;
    }

    return IGMPExclChange(LocalNTE, GroupAddress,
                          NumAddSources, AddSourceList,
                          NumDelSources, DelSourceList);
}

//** IPGetAddrType - Return the type of a address.
//
//  Called by the upper layer to determine the type of a remote address.
//
//  Input:  Address         - The address in question.
//
//  Returns: The DEST type of the address.
//
uchar
IPGetAddrType(IPAddr Address)
{
    return GetAddrType(Address);
}

//** IPGetLocalMTU - Return the MTU for a local address
//
//  Called by the upper layer to get the local MTU for a local address.
//
//  Input:  LocalAddr           - Local address in question.
//          MTU                         - Where to return the local MTU.
//
//  Returns: TRUE if we found the MTU, FALSE otherwise.
//
uchar
IPGetLocalMTU(IPAddr LocalAddr, ushort * MTU)
{
    NetTableEntry *NTE;
    NetTableEntry *NetTableList = NewNetTableList[NET_TABLE_HASH(LocalAddr)];

    for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
        if (IP_ADDR_EQUAL(NTE->nte_addr, LocalAddr) &&
            (NTE->nte_flags & NTE_VALID)) {
            // if NTE is valid, nte->if is valid too
            if (NTE->nte_if->if_flags & IF_FLAGS_P2MP) {
                // P2MP Link
                LinkEntry *tmpLink = NTE->nte_if->if_link;
                uint mtu;
                //Determine the minimum MTU

                // if there are no links on this interface, supply the MTU
                // from the interface itself.
                if (!tmpLink) {
                    *MTU = (ushort)NTE->nte_if->if_mtu;
                    return TRUE ;
                }
                ASSERT(tmpLink);
                mtu = tmpLink->link_mtu;

                while (tmpLink) {

                    if (tmpLink->link_mtu < mtu)
                        mtu = tmpLink->link_mtu;
                    tmpLink = tmpLink->link_next;
                }
                *MTU = (ushort) mtu;
            } else {
                *MTU = NTE->nte_mss;
            }
            return TRUE;
        }
    }

    // Special case in case the local address is a loopback address other than
    // 127.0.0.1.
    if (IP_LOOPBACK_ADDR(LocalAddr)) {
        *MTU = LoopNTE->nte_mss;
        return TRUE;
    }
    return FALSE;

}

//** IPUpdateRcvdOptions - Update options for use in replying.
//
//  A routine to update options for use in a reply. We reverse any source route options,
//  and optionally update the record route option. We also return the index into the
//  options of the record route options (if we find one). The options are assumed to be
//  correct - no validation is performed on them. We fill in the caller provided
//  IPOptInfo with the new option buffer.
//
//  Input:  Options     - Pointer to option info structure with buffer to be reversed.
//          NewOptions  - Pointer to option info structure to be filled in.
//          Src         - Source address of datagram that generated the options.
//          LocalAddr   - Local address responding. If this != NULL_IP_ADDR, then
//                          record route and timestamp options will be updated with this
//                          address.
//
//
//  Returns: Index into options of record route option, if any.
//
IP_STATUS
IPUpdateRcvdOptions(IPOptInfo * OldOptions, IPOptInfo * NewOptions, IPAddr Src, IPAddr LocalAddr)
{
    uchar Length, Ptr;
    uchar i;                    // Index variable
    IPAddr UNALIGNED *LastAddr;    // First address in route.
    IPAddr UNALIGNED *FirstAddr;    // Last address in route.
    IPAddr TempAddr;            // Temp used in exchange.
    uchar *Options, OptLength;
    OptIndex Index;                // Optindex used by UpdateOptions.

    Options = CTEAllocMemN(OptLength = OldOptions->ioi_optlength, 'rICT');

    if (!Options)
        return IP_NO_RESOURCES;

    RtlCopyMemory(Options, OldOptions->ioi_options, OptLength);
    Index.oi_srindex = MAX_OPT_SIZE;
    Index.oi_rrindex = MAX_OPT_SIZE;
    Index.oi_tsindex = MAX_OPT_SIZE;

    NewOptions->ioi_flags &= ~IP_FLAG_SSRR;

    i = 0;
    while (i < OptLength) {
        if (Options[i] == IP_OPT_EOL)
            break;

        if (Options[i] == IP_OPT_NOP) {
            i++;
            continue;
        }
        Length = Options[i + IP_OPT_LENGTH];
        switch (Options[i]) {
        case IP_OPT_SSRR:
            NewOptions->ioi_flags |= IP_FLAG_SSRR;
        case IP_OPT_LSRR:
            // Have a source route. We save the last gateway we came through as
            // the new address, reverse the list, shift the list forward one address,
            // and set the Src address as the last gateway in the list.

            // First, check for an empty source route. If the SR is empty
            // we'll skip most of this.
            if (Length != (MIN_RT_PTR - 1)) {
                // A non empty source route.
                // First reverse the list in place.
                Ptr = Options[i + IP_OPT_PTR] - 1 - sizeof(IPAddr);
                LastAddr = (IPAddr *) (&Options[i + Ptr]);
                FirstAddr = (IPAddr *) (&Options[i + IP_OPT_PTR + 1]);
                NewOptions->ioi_addr = *LastAddr;    // Save Last address as
                // first hop of new route.

                while (LastAddr > FirstAddr) {
                    TempAddr = *LastAddr;
                    *LastAddr-- = *FirstAddr;
                    *FirstAddr++ = TempAddr;
                }

                // Shift the list forward one address. We'll copy all but
                // one IP address.
                RtlMoveMemory(&Options[i + IP_OPT_PTR + 1],
                           &Options[i + IP_OPT_PTR + 1 + sizeof(IPAddr)],
                           Length - (sizeof(IPAddr) + (MIN_RT_PTR - 1)));

                // Set source as last address of route.
                *(IPAddr UNALIGNED *) (&Options[i + Ptr]) = Src;
            }
            Options[i + IP_OPT_PTR] = MIN_RT_PTR;    // Set pointer to min legal value.

            i = i + (uchar) Length;
            break;
        case IP_OPT_RR:
            // Save the index in case LocalAddr is specified. If it isn't specified,
            // reset the pointer and zero the option.
            Index.oi_rrindex = i;
            if (LocalAddr == NULL_IP_ADDR) {
                RtlZeroMemory(&Options[i + MIN_RT_PTR - 1], Length - (MIN_RT_PTR - 1));
                Options[i + IP_OPT_PTR] = MIN_RT_PTR;
            }
            i = i + (uchar) Length;
            break;
        case IP_OPT_TS:
            Index.oi_tsindex = i;

            // We have a timestamp option. If we're not going to update, reinitialize
            // it for next time. For the 'unspecified' options, just zero the buffer.
            // For the 'specified' options, we need to zero the timestamps without
            // zeroing the specified addresses.
            if (LocalAddr == NULL_IP_ADDR) {    // Not going to update, reinitialize.

                uchar Flags;

                Options[i + IP_OPT_PTR] = MIN_TS_PTR;    // Reinitialize pointer.

                Flags = Options[i + IP_TS_OVFLAGS] & IP_TS_FLMASK;    // Get option type.

                Options[i + IP_TS_OVFLAGS] = Flags;        // Clear overflow count.

                switch (Flags) {
                    uchar j;
                    ulong UNALIGNED *TSPtr;

                    // The unspecified types. Just clear the buffer.
                case TS_REC_TS:
                case TS_REC_ADDR:
                    RtlZeroMemory(&Options[i + MIN_TS_PTR - 1], Length - (MIN_TS_PTR - 1));
                    break;

                    // We have a list of addresses specified. Just clear the timestamps.
                case TS_REC_SPEC:
                    // j starts off as the offset in bytes from start of buffer to
                    // first timestamp.
                    j = MIN_TS_PTR - 1 + sizeof(IPAddr);
                    // TSPtr points at timestamp.
                    TSPtr = (ulong UNALIGNED *) & Options[i + j];

                    // Now j is offset of end of timestamp being zeroed.
                    j += sizeof(ulong);
                    while (j <= Length) {
                        *TSPtr++ = 0;
                        j += sizeof(ulong);
                    }
                    break;
                default:
                    break;
                }
            }
            i = i + (uchar) Length;
            break;

        default:
            i = i + (uchar) Length;
            break;
        }

    }

    if (LocalAddr != NULL_IP_ADDR) {
        UpdateOptions(Options, &Index, LocalAddr);
    }
    NewOptions->ioi_optlength = OptLength;
    NewOptions->ioi_options = Options;
    return IP_SUCCESS;

}

//* ValidRouteOption - Validate a source or record route option.
//
//  Called to validate that a user provided source or record route option is good.
//
//  Entry:  Option      - Pointer to option to be checked.
//          NumAddr     - NumAddr that need to fit in option.
//          BufSize     - Maximum size of option.
//
//  Returns: 1 if option is good, 0 if not.
//
uchar
ValidRouteOption(uchar * Option, uint NumAddr, uint BufSize)
{

    //Make sure that bufsize can hold at least 1 address.

    if (BufSize < (3 + (sizeof(IPAddr) * NumAddr))) {
       return 0;
    }

    if (Option[IP_OPT_LENGTH] < (3 + (sizeof(IPAddr) * NumAddr)) ||
        Option[IP_OPT_LENGTH] > BufSize ||
        ((Option[IP_OPT_LENGTH] - 3) % sizeof(IPAddr)))        // Routing options is too small.

        return 0;

    if (Option[IP_OPT_PTR] != MIN_RT_PTR)    // Pointer isn't correct.

        return 0;

    return 1;
}



//      IPIsValidIndex - Find whether the given index is valid ifindex
//
//      Input:  Index           - Interface index to be checked for.
//
//      Returns: Addr of NTE (or g_validaddr for unnumbered) if found / NULL
//
IPAddr
IPIsValidIndex(uint Index)
{
    Interface *IF;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    // Walk the list, looking for a matching index.
    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF->if_index == Index) {
            break;
        }
    }

    // If we found one, return success. Otherwise fail.
    if (IF != NULL) {
        if ((IF->if_flags & IF_FLAGS_NOIPADDR) && IP_ADDR_EQUAL(IF->if_nte->nte_addr, NULL_IP_ADDR)) {
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            return g_ValidAddr;
        } else {
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            return IF->if_nte->nte_addr;
        }
    } else {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return NULL_IP_ADDR;
    }
}

//      GetIfIndexFromNTE       - Find the ifindex given the NTE
//
//      Input:  NTE             - NTE
//
//      Returns: IfIndex of NTE if NTE is valid else return 0
//
uint
GetIfIndexFromNTE(void *IPContext, uint Capabilities)
{
    NetTableEntry *NTE = (NetTableEntry *) IPContext;
    uint IFIndex = 0;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    if (NTE->nte_flags & NTE_VALID) {

        IFIndex = NTE->nte_if->if_index;

        if (Capabilities & IF_CHECK_MCAST) {
            if (NTE->nte_if->if_flags & IF_FLAGS_NOLINKBCST) {
                IFIndex = 0;
            }
        }

        if (Capabilities & IF_CHECK_SEND) {
            if (NTE->nte_if->if_flags & IF_FLAGS_UNI) {
                IFIndex = 0;
            }
        }
    }


    CTEFreeLock(&RouteTableLock.Lock, Handle);


    return IFIndex;
}

//      GetIfIndexFromIndicateContext  - returns ifindex for the receive context.
//
//      Input:  IPContext              - Primary NTE, passed up as context.
//
//      Returns: IfIndex of NTE.
//
uint
GetIfIndexFromIndicateContext(void *IPContext)
{
    return (((NetTableEntry *)IPContext)->nte_if->if_index);
}


//      IPGetMCastIfAddr      - Find a suitable address to use for multicast
//
//      Returns: IP address of NTE else 0
//
IPAddr
IPGetMCastIfAddr()
{
    NetTableEntry *NTE;

    NTE = GetMcastNTEFromAddr(NULL_IP_ADDR);
    if (!NTE) {
        return 0;
    }

    return NTE->nte_addr;
}


//      GetIfIndexFromAddr      - Find the ifindex given the addr
//
//      Input:  Address         - IPAddr or IfIndex in network byte order
//              Capabilities    - Interface capabilities to check against
//
//      Returns:
//                  IfIndex of NTE if NTE->nte_addr equals Addr else 0
//
//
//
ulong
GetIfIndexFromAddr(IPAddr Address, uint Capabilities)
{
    NetTableEntry *NTE;
    uint IFIndex;

    if (IP_LOOPBACK_ADDR(Address) || (Address == net_long(LoopIndex))) {

        // At present, we only check for mcast capabilities and
        // Loopback adapter supports this. So, no need to check
        // for capabilities.

        return LoopIndex;
    }

    NTE = GetMcastNTEFromAddr(Address);
    if (!NTE) {
        return 0;
    }

    IFIndex = GetIfIndexFromNTE(NTE, Capabilities);

    return IFIndex;
}



//** IPInitOptions - Initialize an option buffer.
//
//      Called by an upper layer routine to initialize an option buffer. We fill
//      in the default values for TTL, TOS, and flags, and NULL out the options
//      buffer and size.
//
//      Input:  Options                 - Pointer to IPOptInfo structure.
//
//      Returns: Nothing.
//
void
IPInitOptions(IPOptInfo * Options)
{
    // Initialize all the option fields
    RtlZeroMemory(Options, sizeof(IPOptInfo));

    Options->ioi_addr = NULL_IP_ADDR;
    Options->ioi_ttl = (uchar) DefaultTTL;
    Options->ioi_tos = (uchar) DefaultTOS;
    Options->ioi_limitbcasts = EnableSendOnSource;
}

//** IPCopyOptions - Copy the user's options into IP header format.
//
//  This routine takes an option buffer supplied by an IP client, validates it, and
//  creates an IPOptInfo structure that can be passed to the IP layer for transmission. This
//  includes allocating a buffer for the options, munging any source route
//  information into the real IP format.
//
//  Note that we never lock this structure while we're using it. This may cause transitory
//  incosistencies while the structure is being updated if it is in use during the update.
//  This shouldn't be a problem - a packet or too might get misrouted, but it should
//  straighten itself out quickly. If this is a problem the client should make sure not
//  to call this routine while it's in the IPTransmit routine.
//
//  Entry:  Options     - Pointer to buffer of user supplied options.
//          Size        - Size in bytes of option buffer
//          OptInfoPtr  - Pointer to IPOptInfo structure to be filled in.
//
//  Returns: A status, indicating whether or not the options were valid and copied.
//
IP_STATUS
IPCopyOptions(uchar * Options, uint Size, IPOptInfo * OptInfoPtr)
{
    uchar *TempOptions;            // Buffer of options we'll build
    uint TempSize;                // Size of options.
    IP_STATUS TempStatus;        // Temporary status
    uchar OptSeen = 0;            // Indicates which options we've seen.

    OptInfoPtr->ioi_addr = NULL_IP_ADDR;

    OptInfoPtr->ioi_flags &= ~IP_FLAG_SSRR;

    if (Size == 0) {
        ASSERT(FALSE);
        OptInfoPtr->ioi_options = (uchar *) NULL;
        OptInfoPtr->ioi_optlength = 0;
        return IP_SUCCESS;
    }
    // Option size needs to be rounded to multiple of 4.
    if ((TempOptions = CTEAllocMemN(((Size & 3) ? (Size & ~3) + 4 : Size), 'sICT')) == (uchar *) NULL)
        return IP_NO_RESOURCES;    // Couldn't get a buffer, return error.

    RtlZeroMemory(TempOptions, ((Size & 3) ? (Size & ~3) + 4 : Size));

    // OK, we have a buffer. Loop through the provided buffer, copying options.
    TempSize = 0;
    TempStatus = IP_PENDING;
    while (Size && TempStatus == IP_PENDING) {
        uint SRSize;            // Size of a source route option.

        switch (*Options) {
        case IP_OPT_EOL:
            TempStatus = IP_SUCCESS;
            break;
        case IP_OPT_NOP:
            TempOptions[TempSize++] = *Options++;
            Size--;
            break;
        case IP_OPT_SSRR:
            if (OptSeen & (OPT_LSRR | OPT_SSRR)) {
                TempStatus = IP_BAD_OPTION;        // We've already seen a record route.

                break;
            }
            OptInfoPtr->ioi_flags |= IP_FLAG_SSRR;
            OptSeen |= OPT_SSRR;    // Fall through to LSRR code.

        case IP_OPT_LSRR:
            if ((*Options == IP_OPT_LSRR) &&
                (OptSeen & (OPT_LSRR | OPT_SSRR))
                ) {
                TempStatus = IP_BAD_OPTION;        // We've already seen a record route.

                break;
            }
            if (*Options == IP_OPT_LSRR)
                OptSeen |= OPT_LSRR;
            if (!ValidRouteOption(Options, 2, Size)) {
                TempStatus = IP_BAD_OPTION;
                break;
            }
            // Option is valid. Copy the first hop address to NewAddr, and move all
            // of the other addresses forward.
            TempOptions[TempSize++] = *Options++;    // Copy option type.

            SRSize = *Options++;
            Size -= SRSize;
            SRSize -= sizeof(IPAddr);
            TempOptions[TempSize++] = (UCHAR) SRSize;
            TempOptions[TempSize++] = *Options++;    // Copy pointer.

            OptInfoPtr->ioi_addr = *(IPAddr UNALIGNED *) Options;
            Options += sizeof(IPAddr);    // Point to address beyond first hop.

            RtlCopyMemory(&TempOptions[TempSize], Options, SRSize - 3);
            TempSize += (SRSize - 3);
            Options += (SRSize - 3);
            break;
        case IP_OPT_RR:
            if (OptSeen & OPT_RR) {
                TempStatus = IP_BAD_OPTION;        // We've already seen a record route.

                break;
            }
            OptSeen |= OPT_RR;
            if (!ValidRouteOption(Options, 1, Size)) {
                TempStatus = IP_BAD_OPTION;
                break;
            }
            SRSize = Options[IP_OPT_LENGTH];
            RtlCopyMemory(&TempOptions[TempSize], Options, SRSize);
            TempSize += SRSize;
            Options += SRSize;
            Size -= SRSize;
            break;
        case IP_OPT_TS:
            {
                uchar Overflow, Flags;

                if (OptSeen & OPT_TS) {
                    TempStatus = IP_BAD_OPTION;        // We've already seen a time stamp

                    break;
                } else if (Size <= IP_TS_OVFLAGS) {
                    TempStatus = IP_BAD_OPTION;
                    break;
                }
                OptSeen |= OPT_TS;
                Flags = Options[IP_TS_OVFLAGS] & IP_TS_FLMASK;
                Overflow = (Options[IP_TS_OVFLAGS] & IP_TS_OVMASK) >> 4;

                if (Overflow || (Flags != TS_REC_TS && Flags != TS_REC_ADDR &&
                                 Flags != TS_REC_SPEC)) {
                    TempStatus = IP_BAD_OPTION;        // Bad flags or overflow value.

                    break;
                }
                SRSize = Options[IP_OPT_LENGTH];
                if (SRSize > Size || SRSize < 8 ||
                    Options[IP_OPT_PTR] != MIN_TS_PTR) {
                    TempStatus = IP_BAD_OPTION;        // Option size isn't good.

                    break;
                }
                RtlCopyMemory(&TempOptions[TempSize], Options, SRSize);
                TempSize += SRSize;
                Options += SRSize;
                Size -= SRSize;
            }
            break;

        case IP_OPT_ROUTER_ALERT:

            //
            // this is a four byte option to tell the router to look at this packet
            // RSVP uses this functionality.
            //

            if (OptSeen & OPT_ROUTER_ALERT) {
                TempStatus = IP_BAD_OPTION;
                break;
            }
            if (ROUTER_ALERT_SIZE > Size || *(Options + 1) != ROUTER_ALERT_SIZE) {
                TempStatus = IP_BAD_OPTION;
            } else {

                RtlCopyMemory(&TempOptions[TempSize], Options, ROUTER_ALERT_SIZE);
                OptSeen |= OPT_ROUTER_ALERT;
                TempSize += ROUTER_ALERT_SIZE;
                Options += ROUTER_ALERT_SIZE;
                TempStatus = IP_SUCCESS;
                Size -= ROUTER_ALERT_SIZE;

            }

            break;

        default:
            TempStatus = IP_BAD_OPTION;        // Unknown option, error.

            break;
        }
    }

    if (TempStatus == IP_PENDING)    // We broke because we hit the end of the buffer.

        TempStatus = IP_SUCCESS;    // that's OK.

    if (TempStatus != IP_SUCCESS) {        // We had some sort of an error.

        CTEFreeMem(TempOptions);
        return TempStatus;
    }
    // Check the option size here to see if it's too big. We check it here at the end
    // instead of at the start because the option size may shrink if there are source route
    // options, and we don't want to accidentally error out a valid option.
    TempSize = (TempSize & 3 ? (TempSize & ~3) + 4 : TempSize);
    if (TempSize > MAX_OPT_SIZE) {
        CTEFreeMem(TempOptions);
        return IP_OPTION_TOO_BIG;
    }
    // if this is a call to zero out options (Options = 0)
    // turn off the options in info ptr.

    if ((Size == 4) && (*Options == IP_OPT_EOL)) {
        CTEFreeMem(TempOptions);
        OptInfoPtr->ioi_options = (uchar *) NULL;
        OptInfoPtr->ioi_optlength = 0;

        return IP_SUCCESS;
    }
    OptInfoPtr->ioi_options = TempOptions;
    OptInfoPtr->ioi_optlength = (UCHAR) TempSize;

    return IP_SUCCESS;

}

//**    IPFreeOptions - Free options we're done with.
//
//  Called by the upper layer when we're done with options. All we need to do is free
//  the options.
//
//  Input:  OptInfoPtr      - Pointer to IPOptInfo structure to be freed.
//
//  Returns: Status of attempt to free options.
//
IP_STATUS
IPFreeOptions(IPOptInfo * OptInfoPtr)
{
    if (OptInfoPtr->ioi_options) {
        // We have options to free. Save the pointer and zero the structure field before
        // freeing the memory to try and present race conditions with it's use.
        uchar *TempPtr = OptInfoPtr->ioi_options;

        OptInfoPtr->ioi_options = (uchar *) NULL;
        CTEFreeMem(TempPtr);
        OptInfoPtr->ioi_optlength = 0;
        OptInfoPtr->ioi_addr = NULL_IP_ADDR;
        OptInfoPtr->ioi_flags &= ~IP_FLAG_SSRR;
    }
    return IP_SUCCESS;
}

//**    ipgetinfo - Return pointers to our NetInfo structures.
//
//  Called by upper layer software during init. time. The caller
//  passes a buffer, which we fill in with pointers to NetInfo
//  structures.
//
//  Entry:
//      Buffer - Pointer to buffer to be filled in.
//      Size   - Size in bytes of buffer.
//
//  Returns:
//      Status of command.
//
IP_STATUS
IPGetInfo(IPInfo * Buffer, int Size)
{
    if (Size < sizeof(IPInfo))
        return IP_BUF_TOO_SMALL;    // Not enough buffer space.

    Buffer->ipi_version = IP_DRIVER_VERSION;
    Buffer->ipi_hsize = sizeof(IPHeader);
    Buffer->ipi_xmit = IPTransmit;
    Buffer->ipi_protreg = IPRegisterProtocol;
    Buffer->ipi_openrce = OpenRCE;
    Buffer->ipi_closerce = CloseRCE;
    Buffer->ipi_getaddrtype = IPGetAddrType;
    Buffer->ipi_getlocalmtu = IPGetLocalMTU;
    Buffer->ipi_getpinfo = IPGetPInfo;
    Buffer->ipi_checkroute = IPCheckRoute;
    Buffer->ipi_initopts = IPInitOptions;
    Buffer->ipi_updateopts = IPUpdateRcvdOptions;
    Buffer->ipi_copyopts = IPCopyOptions;
    Buffer->ipi_freeopts = IPFreeOptions;
    Buffer->ipi_qinfo = IPQueryInfo;
    Buffer->ipi_setinfo = IPSetInfo;
    Buffer->ipi_getelist = IPGetEList;
    Buffer->ipi_setmcastaddr = IPSetMCastAddr;
    Buffer->ipi_setmcastinclude = IPSetMCastInclude;
    Buffer->ipi_setmcastexclude = IPSetMCastExclude;
    Buffer->ipi_invalidsrc = InvalidSourceAddress;
    Buffer->ipi_isdhcpinterface = IsDHCPInterface;
    Buffer->ipi_setndisrequest = IPSetNdisRequest;
    Buffer->ipi_largexmit = IPLargeXmit;
    Buffer->ipi_absorbrtralert = IPAbsorbRtrAlert;
    Buffer->ipi_isvalidindex = IPIsValidIndex;
    Buffer->ipi_getifindexfromnte = GetIfIndexFromNTE;
    Buffer->ipi_isrtralertpacket = IsRtrAlertPacket;
    Buffer->ipi_getifindexfromaddr = GetIfIndexFromAddr;
    Buffer->ipi_cancelpackets = IPCancelPackets;
    Buffer->ipi_getmcastifaddr = IPGetMCastIfAddr;
    Buffer->ipi_getipid = GetIPID;
    Buffer->ipi_protdereg = IPDeregisterProtocol;
    Buffer->ipi_getifindexfromindicatecontext = GetIfIndexFromIndicateContext;
    return IP_SUCCESS;
}

//** IPTimeout - IP timeout handler.
//
//  The timeout routine called periodically to time out various things, such as entries
//  being reassembled and ICMP echo requests.
//
//  Entry:  Timer       - Timer being fired.
//          Context     - Pointer to NTE being time out.
//
//  Returns: Nothing.
//
void
IPTimeout(CTEEvent * Timer, void *Context)
{
    NetTableEntry *NTE = STRUCT_OF(NetTableEntry, Timer, nte_timer);
    CTELockHandle NTEHandle;
    ReassemblyHeader *PrevRH, *CurrentRH, *TempList = (ReassemblyHeader *) NULL;

    ICMPTimer(NTE);
    IGMPTimer(NTE);
    if (Context) {
        CTEGetLock(&NTE->nte_lock, &NTEHandle);
        PrevRH = STRUCT_OF(ReassemblyHeader, &NTE->nte_ralist, rh_next);
        CurrentRH = PrevRH->rh_next;
        while (CurrentRH) {
            if (--CurrentRH->rh_ttl == 0) {        // This guy timed out.

                PrevRH->rh_next = CurrentRH->rh_next;    // Take him out.

                CurrentRH->rh_next = TempList;    // And save him for later.

                TempList = CurrentRH;
                IPSInfo.ipsi_reasmfails++;
            } else
                PrevRH = CurrentRH;

            CurrentRH = PrevRH->rh_next;
        }

        // We've run the list. If we need to free anything, do it now. This may
        // include sending an ICMP message.
        CTEFreeLock(&NTE->nte_lock, NTEHandle);
        while (TempList) {
            CurrentRH = TempList;
            TempList = CurrentRH->rh_next;
            // If this wasn't sent to a bcast address and we already have the first fragment,
            // send a time exceeded message.
            if (CurrentRH->rh_headersize != 0)
                SendICMPErr(NTE->nte_addr, (IPHeader *) CurrentRH->rh_header, ICMP_TIME_EXCEED,
                            TTL_IN_REASSEM, 0, 0);
            FreeRH(CurrentRH);
        }

        //
        // If the interface is being deleted, then dont re-start the timer
        //
        if (NTE->nte_deleting) {
            NTE->nte_flags &= ~NTE_TIMER_STARTED;
            CTESignal(&NTE->nte_timerblock, NDIS_STATUS_SUCCESS);
        } else {
            CTEStartTimer(&NTE->nte_timer, IP_TIMEOUT, IPTimeout, NULL);
        }
    } else {
        //
        // If the interface is being deleted, then dont re-start the timer
        //
        if (NTE->nte_deleting) {
            NTE->nte_flags &= ~NTE_TIMER_STARTED;
            CTESignal(&NTE->nte_timerblock, NDIS_STATUS_SUCCESS);
        } else {
            CTEStartTimer(&NTE->nte_timer, IP_TIMEOUT, IPTimeout, NTE);
        }
    }
}

//* IPpSetNTEAddr - Set the IP address of an NTE.
//
//  Called by the DHCP client to set or delete the IP address of an NTE. We
//  make sure he's specifiying a valid NTE, then mark it up or down as needed,
//  notify the upper layers of the change if necessary, and then muck with
//  the routing tables.
//
//  Input:  Context - Context of NTE to alter.
//          Addr    - IP address to set.
//          Mask    - Subnet mask for Addr.
//
//  Returns: TRUE if we changed the address, FALSE otherwise.
//
IP_STATUS
IPpSetNTEAddr(NetTableEntry * NTE, IPAddr Addr, IPMask Mask,
              CTELockHandle * RouteTableHandle,
              SetAddrControl * ControlBlock, SetAddrRtn Rtn)
{
    Interface *IF;
    uint(*CallFunc) (struct RouteTableEntry *, void *, void *);
    CTELockHandle NTEHandle;
    NetTableEntry *NetTableList;
    NetTableEntry *CurrNTE, *PrevNTE;

    if (NTE->nte_deleting == 2) {
        CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    if (NTE->nte_deleting)
        NTE->nte_deleting = 2;

    IF = NTE->nte_if;
    DHCPActivityCount++;

    DEBUGMSG(DBG_TRACE && DBG_DHCP,
        (DTEXT("+IPpSetNTEAddr(%x, %x, %x, %x, %x, %x) DHCPActivityCount %d\n"),
         NTE, Addr, Mask, RouteTableHandle,
         ControlBlock, Rtn, DHCPActivityCount));

    LOCKED_REFERENCE_IF(IF);

    if (IP_ADDR_EQUAL(Addr, NULL_IP_ADDR)) {
        // We're deleting an address.
        if (NTE->nte_flags & NTE_VALID) {
            // The address is currently valid. Fix that.

            NTE->nte_flags &= ~NTE_VALID;

            //
            // If the old address is in the ATCache, flush it out.
            //
            AddrTypeCacheFlush(NTE->nte_addr);


            if (CTEInterlockedDecrementLong(&(IF->if_ntecount)) == 0) {
                // This is the last one, so we'll need to delete relevant
                // routes.
                CallFunc = DeleteRTEOnIF;
            } else
                CallFunc = InvalidateRCEOnIF;

            CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);

            if (IF->if_arpflushate)
                (*(IF->if_arpflushate)) (IF->if_lcontext, NTE->nte_addr);


            StopIGMPForNTE(NTE);

            // Now call the upper layers, and tell them that address is
            // gone. We really need to do something about locking here.
            NotifyAddrChange(NTE->nte_addr, NTE->nte_mask, NTE->nte_pnpcontext,
                             NTE->nte_context, &NTE->nte_addrhandle, NULL, &IF->if_devname, FALSE);

            // Call RTWalk to take the appropriate action on the RTEs.

            RTWalk(CallFunc, IF, NULL);

            // Delete the route to the address itself.
            //DeleteRoute(NTE->nte_addr, HOST_MASK, IPADDR_LOCAL,
            //      LoopNTE->nte_if);

            DelNTERoutes(NTE);
            // Tell the lower interface this address is gone.
            (*IF->if_deladdr) (IF->if_lcontext, LLIP_ADDR_LOCAL, NTE->nte_addr,
                               NULL_IP_ADDR);

            CTEGetLock(&RouteTableLock.Lock, RouteTableHandle);

            if (IP_ADDR_EQUAL(g_ValidAddr, NTE->nte_addr)) {
                NetTableEntry *TempNte;
                uint i;
                //
                // Update the global address
                // First set the global address to 0, so that if there
                // are no valid NTEs left, we will have a global address
                // of 0
                //

                g_ValidAddr = NULL_IP_ADDR;

                for (i = 0; i < NET_TABLE_SIZE; i++) {
                    NetTableList = NewNetTableList[i];
                    for (TempNte = NetTableList;
                         TempNte != NULL;
                         TempNte = TempNte->nte_next) {
                        if (!IP_ADDR_EQUAL(TempNte->nte_addr, NULL_IP_ADDR) &&
                            !IP_LOOPBACK_ADDR(TempNte->nte_addr) &&
                            TempNte->nte_flags & NTE_VALID) {
                            g_ValidAddr = TempNte->nte_addr;
                        }
                    }
                }
            }
        }
        DHCPActivityDone(NTE, IF, RouteTableHandle, TRUE);
        LockedDerefIF(IF);
        CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);

        CTEGetLock(&NTE->nte_lock, &NTEHandle);

        if (NTE->nte_rtrlist) {
            IPRtrEntry *rtrentry, *temprtrentry;

            rtrentry = NTE->nte_rtrlist;
            NTE->nte_rtrlist = NULL;
            while (rtrentry) {
                temprtrentry = rtrentry;
                rtrentry = rtrentry->ire_next;
                CTEFreeMem(temprtrentry);
            }
        }
        CTEFreeLock(&NTE->nte_lock, NTEHandle);

        return IP_SUCCESS;
    } else {
        uint Status;

        // We're not deleting, we're setting the address.
        // In the case of unidirectional adapter, NTE was set to valid
        // when the interface was added. If the address is being added on that NTE,
        // and if the nte_addr is NULL_IP_ADDR, allow this address addition.

        if (!(NTE->nte_flags & NTE_VALID) ||
            ((IF->if_flags & IF_FLAGS_NOIPADDR) &&
            (IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)))) {

            uint index;
            NetTableEntry *tmpNTE = NewNetTableList[NET_TABLE_HASH(Addr)];

            //Check for duplicate address

            while (tmpNTE) {
                if ((tmpNTE != NTE) && IP_ADDR_EQUAL(tmpNTE->nte_addr, Addr) && (tmpNTE->nte_flags & NTE_VALID)) {
                    DHCPActivityDone(NTE, IF, RouteTableHandle, TRUE);
                    LockedDerefIF(IF);
                    CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
                    return IP_DUPLICATE_ADDRESS;
                }
                tmpNTE = tmpNTE->nte_next;
            }

            if ((IF->if_flags & IF_FLAGS_MEDIASENSE) && !IF->if_mediastatus) {

                DHCPActivityDone(NTE, IF, RouteTableHandle, TRUE);
                LockedDerefIF(IF);

                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"setting address %x on if %x with disconnected media\n", Addr, IF));
                CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
                return IP_MEDIA_DISCONNECT;
            }
            // The address is invalid. Save the info, mark him as valid,
            // and add the routes.

            if (NTE->nte_addr != Addr) {
                // Move the NTE to proper hash now that address has changed

                NetTableList = NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)];

                PrevNTE = STRUCT_OF(NetTableEntry, &NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)], nte_next);
                for (CurrNTE = NetTableList; CurrNTE != NULL; PrevNTE = CurrNTE, CurrNTE = CurrNTE->nte_next) {
                    if (CurrNTE == NTE) {
                        // found the matching NTE
                        ASSERT(CurrNTE->nte_context == NTE->nte_context);
                        // remove it from this particular hash
                        PrevNTE->nte_next = CurrNTE->nte_next;
                        break;
                    }
                }

                ASSERT(CurrNTE != NULL);
                ASSERT(CurrNTE == NTE);
                // Add the NTE in the proper hash
                NTE->nte_next = NewNetTableList[NET_TABLE_HASH(Addr)];
                NewNetTableList[NET_TABLE_HASH(Addr)] = NTE;
            }
            NTE->nte_addr = Addr;
            NTE->nte_mask = Mask;
            NTE->nte_flags |= NTE_VALID;
            // Turn DHCP flag off since we release the lock for a small interval
            // when do this at the end
            if (NTE->nte_flags & NTE_DHCP) {
                NTE->nte_flags |= NTE_DYNAMIC;
                NTE->nte_flags &= ~NTE_DHCP;
            } else {
                NTE->nte_flags &= ~NTE_DYNAMIC;
            }

            CTEInterlockedIncrementLong(&(IF->if_ntecount));
            index = IF->if_index;

            if (IP_ADDR_EQUAL(g_ValidAddr, NULL_IP_ADDR) &&
                !IP_LOOPBACK(Addr)) {
                //
                // Update the global address
                //

                g_ValidAddr = Addr;
            }
            //
            // If the new address is in the ATCache, flush it out, otherwise
            // TdiOpenAddress may fail.
            //
            AddrTypeCacheFlush(Addr);

            CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);

            if (IF->if_arpflushate)
                (*(IF->if_arpflushate)) (IF->if_lcontext, NTE->nte_addr);

            if (AddNTERoutes(NTE)) {
                Status = TRUE;
            } else {
                Status = FALSE;

                if (NTE->nte_if->if_flags & IF_FLAGS_P2MP) {
                    //
                    // In the case of P2MP we just return true.
                    //
                    Status = TRUE;
                }

            }


            //
            // Convert any indirect routes plumbed as direct
            // for whatever reason (routes added with firsthop
            // pointing to the address that is being added)
            //

            RTWalk(ConvertRTEType, NTE, NULL);
            // Need to tell the lower layer about it.
            if (Status) {
                Interface *IF = NTE->nte_if;

                //
                // Rtn will be NULL when called from IPSetNTEAddr
                //
                if (Rtn) {
                    ControlBlock->sac_rtn = Rtn;

                    ControlBlock->interface = IF;
                    ControlBlock->nte_context = NTE->nte_context;

                    Status = (*IF->if_addaddr) (IF->if_lcontext, LLIP_ADDR_LOCAL,
                                                Addr, Mask, ControlBlock);
                } else {
                    Status = (*IF->if_addaddr) (IF->if_lcontext, LLIP_ADDR_LOCAL,
                                                Addr, Mask, NULL);
                }
            }
            if (Status == FALSE) {
                // Couldn't add the routes. Recurively mark this NTE as down.
                IPSetNTEAddrEx(NTE->nte_context, NULL_IP_ADDR, 0, NULL, NULL, 0);
                DerefIF(IF);
            } else {
                InitIGMPForNTE(NTE);

                // Now call the upper layers, and tell them that address is
                // is here. We really need to do something about locking here.
                // Modification: We do not notify about address here.We first do the conflict
                // detection and then notify in the completion routine.

                if (!IP_ADDR_EQUAL(Addr, NULL_IP_ADDR)) {
                    SetPersistentRoutesForNTE(
                                              net_long(Addr),
                                              net_long(Mask),
                                              index
                                              );
                }

                if (Status != IP_PENDING) {
                    NotifyAddrChange(NTE->nte_addr, NTE->nte_mask,
                                     NTE->nte_pnpcontext, NTE->nte_context, &NTE->nte_addrhandle,
                                     &(IF->if_configname), &IF->if_devname, TRUE);

                    DerefIF(IF);

                    // notify our clients right here because we rcvd
                    // immediate status from arp.
                    if (Rtn != NULL) {
                        (*Rtn) (ControlBlock, IP_SUCCESS);
                    }
                }
            }

            CTEGetLock(&RouteTableLock.Lock, RouteTableHandle);
            NTE->nte_rtrdisccount = MAX_SOLICITATION_DELAY;
            NTE->nte_rtrdiscstate = NTE_RTRDISC_DELAYING;
        } else {

            //
            // This is needed for remote boot -- when the DHCP client starts
            // we already have an address and NTE_VALID is set, but it will
            // try to set the address again. So if the NTE is already valid
            // and the address is the same, just succeed. In a non-remote boot
            // case we should never hit this since the address will always
            // be set to 0 before being changed to something else.
            //

            if ((NTE->nte_addr == Addr) &&
                (NTE->nte_mask == Mask)) {
                DHCPActivityDone(NTE, IF, RouteTableHandle, TRUE);
                LockedDerefIF(IF);
                CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
                return IP_SUCCESS;
            } else {
                Status = FALSE;
            }

            LockedDerefIF(IF);
        }

        // If this was enabled for DHCP, clear that flag now.
        DHCPActivityDone(NTE, IF, RouteTableHandle, (IP_PENDING == Status ? FALSE : TRUE));

        CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);

        if (Status) {
            return IP_PENDING;
        } else {
            return IP_GENERAL_FAILURE;
        }
    }
}

//* IPSetNTEAddr - Set the IP address of an NTE.
//
//  Wrapper routine for IPpSetNTEAddr
//
//  Input:  Context - Context of NTE to alter.
//          Addr    - IP address to set.
//          Mask    - Subnet mask for Addr.
//
//  Returns: TRUE if we changed the address, FALSE otherwise.
//
uint
IPSetNTEAddr(ushort Context, IPAddr Addr, IPMask Mask)
{
    CTELockHandle Handle;
    uint Status;
    NetTableEntry *NTE = NULL;
    uint i;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        for (NTE = NewNetTableList[i]; NTE != NULL; NTE = NTE->nte_next) {
            if (NTE->nte_context == Context)
                break;
        }
        if (NTE != NULL)
            break;
    }

    if (NTE == NULL || NTE == LoopNTE) {
        // Can't alter the loopback NTE, or one we didn't find.
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    Status = IPpSetNTEAddr(NTE, Addr, Mask, &Handle, NULL, NULL);
    return (Status);
}

//* IPSetNTEAddrEx - Set the IP address of an NTE.
//
//  Wrapper routine for IPpSetNTEAddr - with address conflict callback
//  context/routine
//
//  Input:  Context - Context of NTE to alter.
//          Addr    - IP address to set.
//          Mask    - Subnet mask for Addr.
//          Type    - Address Type
//
//  Returns: TRUE if we changed the address, FALSE otherwise.
//
uint
IPSetNTEAddrEx(ushort Context, IPAddr Addr, IPMask Mask,
               SetAddrControl *ControlBlock, SetAddrRtn Rtn, ushort Type)
{
    CTELockHandle Handle;
    uint Status;
    NetTableEntry *NTE = NULL;
    uint i;

    if (Context == INVALID_NTE_CONTEXT) {
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        for (NTE = NewNetTableList[i]; NTE != NULL; NTE = NTE->nte_next) {
            if (NTE->nte_context == Context)
                break;
        }
        if (NTE != NULL)
            break;
    }

    // TCPTRACE(("IP: IPSetNTEAddrEx - context %lx, NTE %lx, IPAddr %lx\n",Context, NTE, Addr ));

    if (NTE == NULL || NTE == LoopNTE || (NTE->nte_flags & NTE_DISCONNECTED)) {

        //if the nte is in media disconnect state, then it should
        //not show up as valid when media is reconnected
        if(NTE)
          NTE->nte_flags &= ~NTE_DISCONNECTED;
        // Can't alter the loopback NTE, or one we didn't find.

        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    if (Type & IP_ADDRTYPE_TRANSIENT) {
        NTE->nte_flags |= NTE_TRANSIENT_ADDR;
    }


    Status = IPpSetNTEAddr(NTE, Addr, Mask, &Handle, ControlBlock, Rtn);


    return (Status);
}

#pragma BEGIN_INIT

extern NetTableEntry *InitLoopback(IPConfigInfo *);

//** InitTimestamp - Intialize the timestamp for outgoing packets.
//
//  Called at initialization time to setup our first timestamp. The timestamp we use
//  is the in ms since midnite GMT at which the system started.
//
//  Input:  Nothing.
//
//  Returns: Nothing.
//
void
InitTimestamp()
{
    ulong GMTDelta;                // Delta in ms from GMT.
    ulong Now;                    // Milliseconds since midnight.

    TimeStamp = 0;

    if ((GMTDelta = GetGMTDelta()) == 0xffffffff) {        // Had some sort of error.

        TSFlag = 0x80000000;
        return;
    }
    if ((Now = GetTime()) > (24L * 3600L * 1000L)) {    // Couldn't get time since midnight.

        TSFlag = net_long(0x80000000);
        return;
    }
    TimeStamp = Now + GMTDelta - CTESystemUpTime();
    TSFlag = 0;
}

//** InitNTE - Initialize an NTE.
//
//  This routine is called during initialization to initialize an NTE. We
//  allocate memory, NDIS resources, etc.
//
//
//  Entry: NTE      - Pointer to NTE to be initalized.
//
//  Returns: 0 if initialization failed, non-zero if it succeeds.
//
int
InitNTE(NetTableEntry * NTE)
{
    Interface *IF;
    NetTableEntry *PrevNTE;

    NTE->nte_ralist = NULL;
    NTE->nte_echolist = NULL;

    //
    // Taken together, the context and instance numbers uniquely identify
    // a network entry, even across boots of the system. The instance number
    // will have to become dynamic if contexts are ever reused.
    //

    NTE->nte_rtrlist = NULL;
    NTE->nte_instance = GetUnique32BitValue();

    // Now link him on the IF chain, and bump the count.
    IF = NTE->nte_if;
    PrevNTE = STRUCT_OF(NetTableEntry, &IF->if_nte, nte_ifnext);
    while (PrevNTE->nte_ifnext != NULL)
        PrevNTE = PrevNTE->nte_ifnext;

    PrevNTE->nte_ifnext = NTE;
    NTE->nte_ifnext = NULL;

    if ((NTE->nte_flags & NTE_VALID) || (IF->if_flags & IF_FLAGS_NOIPADDR)) {
        CTEInterlockedIncrementLong(&(IF->if_ntecount));
    }
    CTEInitTimer(&NTE->nte_timer);

    NTE->nte_flags |= NTE_TIMER_STARTED;
    CTEStartTimer(&NTE->nte_timer, IP_TIMEOUT, IPTimeout, (void *)NULL);

    return TRUE;
}

//** InitInterface - Initialize with an interface.
//
//  Called when we need to initialize with an interface. We set the appropriate NTE
//  info, then register our local address and any appropriate broadcast addresses
//  with the interface. We assume the NTE being initialized already has an interface
//  pointer set up for it. We also allocate at least one TD buffer for use on the interface.
//
//  Input:  NTE     - NTE to initialize with the interface.
//
//  Returns: TRUE is we succeeded, FALSE if we fail.
//
int
InitInterface(NetTableEntry * NTE)
{
    uchar *TDBuffer;            // Pointer to tdbuffer
    PNDIS_PACKET Packet;
    PNDIS_BUFFER TDBufDesc;        // Buffer descriptor for TDBuffer.
    NDIS_STATUS Status;
    Interface *IF;                // Interface for this NTE.
    CTELockHandle Handle;

    IF = NTE->nte_if;

    ASSERT(NTE->nte_mss > sizeof(IPHeader));
    ASSERT(IF->if_mtu > 0);

    NTE->nte_mss = (ushort) MIN((NTE->nte_mss - sizeof(IPHeader)), IF->if_mtu);

    if (NTE->nte_flags & NTE_VALID) {

        // Add our local IP address.
        if (!(*IF->if_addaddr) (IF->if_lcontext, LLIP_ADDR_LOCAL,
                                NTE->nte_addr, NTE->nte_mask, NULL)) {
            return FALSE;        // Couldn't add local address.

        }
    }
    // Set up the broadcast addresses for this interface, iff we're the
    // 'primary' NTE on the interface.
    if (NTE->nte_flags & NTE_PRIMARY) {

        if (!(*IF->if_addaddr) (IF->if_lcontext, LLIP_ADDR_BCAST,
                                NTE->nte_if->if_bcast, 0, NULL)) {
            return FALSE;        // Couldn't add broadcast address.

        }
    }
    if (IF->if_llipflags & LIP_COPY_FLAG) {
        NTE->nte_flags |= NTE_COPY;
    }


    // Check if we already allocated a TD packet
    // for this interface.
    // Note: IF is referenced.


    if (IF->if_tdpacket) {
        goto exit;
    }


    // Allocate resources needed for xfer data calls. The TD buffer has to be as large
    // as any frame that can be received, even though our MSS may be smaller, because we
    // can't control what might be sent at us.
    TDBuffer = CTEAllocMemNBoot((IF->if_mtu + sizeof(IPHeader)), 'tICT');

    if (TDBuffer == (uchar *) NULL)
        return FALSE;

    NdisAllocatePacket(&Status, &Packet, TDPacketPool);
    if (Status != NDIS_STATUS_SUCCESS) {
        CTEFreeMem(TDBuffer);
        return FALSE;
    }
    RtlZeroMemory(Packet->ProtocolReserved, sizeof(TDContext));

    NdisAllocateBuffer(&Status, &TDBufDesc, TDBufferPool, TDBuffer,
                       (IF->if_mtu + sizeof(IPHeader)));
    if (Status != NDIS_STATUS_SUCCESS) {
        NdisFreePacket(Packet);
        CTEFreeMem(TDBuffer);
        return FALSE;
    }
    NdisChainBufferAtFront(Packet, TDBufDesc);

    ((TDContext *) Packet->ProtocolReserved)->tdc_buffer = TDBuffer;

    CTEGetLock(&IF->if_lock, &Handle);
    ((TDContext *) Packet->ProtocolReserved)->tdc_common.pc_link = IF->if_tdpacket;
    IF->if_tdpacket = Packet;
    CTEFreeLock(&IF->if_lock, Handle);

  exit:
    return TRUE;
}

//* FreeNets - Free nets we have allocated.
//
//  Called during init time if initialization fails. We walk down our list
//  of nets, and free them.
//
//  Input:  Nothing.
//
//  Returns: Nothing.
//
void
FreeNets(void)
{
    NetTableEntry *NTE;
    NetTableEntry *pNextNTE;
    uint i;

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        for (NTE = NewNetTableList[i]; NTE != NULL;) {
            pNextNTE = NTE->nte_next;

            // Make sure we don't free memory that are holding timers that
            // are running.
            //
            if ((NTE->nte_flags & NTE_TIMER_STARTED) &&
                !CTEStopTimer(&NTE->nte_timer)) {
                (VOID) CTEBlock(&NTE->nte_timerblock);
                KeClearEvent(&NTE->nte_timerblock.cbs_event);
            }

            CTEFreeMem(NTE);
            NTE = pNextNTE;
        }
    }
}

extern uint GetGeneralIFConfig(IFGeneralConfig * GConfigInfo,
                               NDIS_HANDLE Handle,
                               PNDIS_STRING ConfigName);
extern IFAddrList *GetIFAddrList(uint * NumAddr, NDIS_HANDLE Handle,
                                 uint * EnableDhcp, BOOLEAN PppIf,
                                 PNDIS_STRING ConfigName);

//* NotifyElistChange
void
NotifyElistChange()
{
    int i;
    ULElistProc ElistProc;

    for (i = 0; i < NextPI; i++) {
        if (IPProtInfo[i].pi_valid == PI_ENTRY_VALID) {
            ElistProc = IPProtInfo[i].pi_elistchange;
            if (ElistProc != NULL)
                (*ElistProc) ();
        }
    }
}

//* NotifyAddrChange - Notify clients of a change in addresses.
//
//  Called when we want to notify registered clients that an address has come
//  or gone. We call TDI to perform this function.
//
//  Input:
//      Addr        - Addr that has changed.
//      Mask        - Mask that has changed.
//      Context     - PNP context for address
//      IPContext   - NTE context for NTE
//      Handle      - Pointer to where to get/set address registration
//                    handle
//      ConfigName  - Registry name to use to retrieve config info.
//      Added       - True if the addr is coming, False if it's going.
//
//  Returns: Nothing.
//
void
NotifyAddrChange(IPAddr Addr, IPMask Mask, void *Context, ushort IPContext,
                 PVOID * Handle, PNDIS_STRING ConfigName, PNDIS_STRING IFName,
                 uint Added)
{
    uchar Address[sizeof(TA_ADDRESS) + sizeof(TDI_ADDRESS_IP)];
    PTA_ADDRESS AddressPtr;
    PTDI_ADDRESS_IP IPAddressPtr;
    NTSTATUS Status;
    IP_STATUS StatusType;
    NDIS_HANDLE ConfigHandle = NULL;
    int i;
    ULStatusProc StatProc;

    DBG_UNREFERENCED_PARAMETER(Mask);
    DBG_UNREFERENCED_PARAMETER(IPContext);

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("+NotifyAddrChange(%x, %x, %x, %x, %x, %X, %X, %x)\n"),
         Addr, Mask, Context, IPContext,
         Handle, ConfigName, IFName, Added));

    // notify UL about possible entity list change.
    NotifyElistChange();

    AddressPtr = (PTA_ADDRESS) Address;

    AddressPtr->AddressLength = sizeof(TDI_ADDRESS_IP);
    AddressPtr->AddressType = TDI_ADDRESS_TYPE_IP;

    IPAddressPtr = (PTDI_ADDRESS_IP) AddressPtr->Address;

    RtlZeroMemory(IPAddressPtr, sizeof(TDI_ADDRESS_IP));

    IPAddressPtr->in_addr = Addr;

    //
    // Call the status entrypoint of the transports so they can
    // adjust their security filters.
    //
    if (Added) {
        StatusType = IP_ADDR_ADDED;

        //
        // Open a configuration key
        //
        if (!OpenIFConfig(ConfigName, &ConfigHandle)) {
            //
            // Not much we can do. The transports will have
            // to handle this.
            //
            ASSERT(ConfigHandle == NULL);
        }
    } else {
        StatusType = IP_ADDR_DELETED;
    }

    for (i = 0; i < NextPI; i++) {
        StatProc = IPProtInfo[i].pi_status;
        if ((StatProc != NULL) && (IPProtInfo[i].pi_valid == PI_ENTRY_VALID))
            (*StatProc) (IP_HW_STATUS, StatusType, Addr, NULL_IP_ADDR,
                         NULL_IP_ADDR, 0, ConfigHandle);
    }

    if (ConfigHandle != NULL) {
        CloseIFConfig(ConfigHandle);
    }

    //
    // Notify any interested parties via TDI. The transports all register
    // for this notification as well.
    //
    if (Added) {
        PTDI_PNP_CONTEXT tdiPnPContext2;

        if (Addr) {
            //ASSERT (*Handle == NULL);
            tdiPnPContext2 = CTEAllocMemNBoot(sizeof(TDI_PNP_CONTEXT) + sizeof(PVOID) - 1, 'uICT');

            if (tdiPnPContext2) {

                PVOID RegHandle;

                tdiPnPContext2->ContextSize = sizeof(PVOID);
                tdiPnPContext2->ContextType = TDI_PNP_CONTEXT_TYPE_PDO;
                *(PVOID UNALIGNED *) tdiPnPContext2->ContextData = Context;

                Status = TdiRegisterNetAddress(AddressPtr, IFName, tdiPnPContext2, &RegHandle);

                *Handle = RegHandle;

                CTEFreeMem(tdiPnPContext2);

                if (Status != STATUS_SUCCESS) {
                    *Handle = NULL;
                }
            }
        }
    } else {
        if (*Handle != NULL) {
            PVOID RegHandle = *Handle;
            *Handle = NULL;
            TdiDeregisterNetAddress(RegHandle);

        }
    }

#if MILLEN
    AddChangeNotify(
        Addr,
        Mask,
        Context,
        IPContext,
        ConfigName,
        IFName,
        Added,
        FALSE); // Not a uni-directional adapter!
#else // MILLEN
    AddChangeNotify(Addr);
#endif // !MILLEN
    DEBUGMSG(DBG_TRACE && DBG_NOTIFY, (DTEXT("-NotifyAddrChange\n")));
}

//* IPAddNTE - Add a new NTE to an interface
//
//  Called to create a new network entry on an interface.
//
//  Input:
//      GConfigInfo   - Configuration information for the interface
//      PNPContext    - The PNP context value associated with the interface
//      RegRtn        - Routine to call to register with ARP.
//      BindInfo      - Pointer to NDIS bind information.
//      IF            - The interface on which to create the NTE.
//      NewAddr       - The address of the new NTE.
//      NewMask       - The subnet mask for the new NTE.
//      IsPrimary     - TRUE if this NTE is the primary one on the interface
//      IsDynamic     - TRUE if this NTE is being created on an
//                      existing interface instead of a new one.
//
//  Returns: A pointer to the new NTE if the operation succeeds.
//       NULL if the operation fails.
//
NetTableEntry *
IPAddNTE(IFGeneralConfig * GConfigInfo, void *PNPContext, LLIPRegRtn RegRtn,
         LLIPBindInfo * BindInfo, Interface * IF, IPAddr NewAddr, IPMask NewMask,
         uint IsPrimary, uint IsDynamic)
{
    NetTableEntry *NTE, *PrevNTE, *tmpNTE = NULL;
    CTELockHandle Handle;
    BOOLEAN Duplicate = FALSE, GotNTE = FALSE, RegRtnCalled = FALSE;
    IP_HANDLERS ipHandlers;
    NetTableEntry *NetTableList;
    uint i;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("+IPAddNTE(%x, %x, %x, %x, %x, %x, %x, %x, %x)\n"),
        GConfigInfo, PNPContext, RegRtn,
        BindInfo, IF, NewAddr, NewMask, IsPrimary, IsDynamic));


    // If the address is invalid we're done. Fail the request.
    if (CLASSD_ADDR(NewAddr) || CLASSE_ADDR(NewAddr)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddNTE: Invalid address\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [NULL]\n")));
        return NULL;
    }
    // See if we have an inactive NTE on the NetTableList. If we do, we'll
    // just recycle that. We will pull him out of the list. This is not
    // strictly MP safe, since other people could be walking the list while
    // we're doing this without holding a lock, but it should be harmless.
    // The removed NTE is marked as invalid, and his next pointer will
    // be nulled, so anyone walking the list might hit the end too soon,
    // but that's all. The memory is never freed, and the next pointer is
    // never pointed at freed memory.

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    NetTableList = NewNetTableList[NET_TABLE_HASH(NewAddr)];
    for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {

        if (IP_ADDR_EQUAL(NTE->nte_addr, NewAddr) &&
            (NTE->nte_flags & NTE_VALID) &&
            !IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            Duplicate = TRUE;
            break;
        }
    }

    if (Duplicate) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddNTE: Duplicate IP address\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [NULL]\n")));
        return (NULL);
    }
    // can do both stuff in 1 loop though

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableList = NewNetTableList[i];
        PrevNTE = STRUCT_OF(NetTableEntry, &NewNetTableList[i], nte_next);
        for (NTE = NetTableList; NTE != NULL; PrevNTE = NTE, NTE = NTE->nte_next) {
            //
            // Reuse an NTE that is neither 'NTE_ACTIVE' nor 'nte_deleting'.
            //
            if (!GotNTE && !(NTE->nte_flags & NTE_ACTIVE) && !(NTE->nte_deleting)) {
                PrevNTE->nte_next = NTE->nte_next;
                NTE->nte_next = NULL;
                NumNTE--;
                GotNTE = TRUE;
                tmpNTE = NTE;
            }
        }
        if (GotNTE)
            break;
    }

    //
    // Update the global address
    //

    if (IP_ADDR_EQUAL(g_ValidAddr, NULL_IP_ADDR) &&
        !IP_LOOPBACK(NewAddr) &&
        !IP_ADDR_EQUAL(NewAddr, NULL_IP_ADDR)) {
        //
        // Update the global address
        //

        g_ValidAddr = NewAddr;
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);

    // See if we got one.
    if (!GotNTE) {
        // Didn't get one. Try to allocate one.
        NTE = CTEAllocMemNBoot(sizeof(NetTableEntry), 'vICT');
        if (NTE == NULL) {
            DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddNTE: Failed to allocate NTE.\n")));
            DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [NULL]\n")));
            return NULL;
        }
    } else {
        NTE = tmpNTE;
    }

    DEBUGMSG(DBG_INFO && DBG_PNP,
        (DTEXT("IPAddNTE: NTE %x allocated/reused. Initializing...\n")));

    // Initialize the address and mask stuff
    CTEInitTimer(&NTE->nte_timer);

    RtlZeroMemory(NTE, sizeof(NetTableEntry));

    NTE->nte_addr = NewAddr;
    NTE->nte_mask = NewMask;
    NTE->nte_mss = (ushort) MAX(GConfigInfo->igc_mtu, 68);
    NTE->nte_rtrdiscaddr = GConfigInfo->igc_rtrdiscaddr;
    NTE->nte_rtrdiscstate = NTE_RTRDISC_UNINIT;
    NTE->nte_rtrdisccount = 0;
    NTE->nte_rtrdiscovery =
        (GConfigInfo->igc_rtrdiscovery == IP_IRDP_ENABLED) ? TRUE : FALSE;
    NTE->nte_rtrlist = NULL;
    NTE->nte_pnpcontext = PNPContext;
    NTE->nte_if = IF;
    NTE->nte_flags = NTE_ACTIVE;

    //
    // If the new address is in the ATCache, flush it out, otherwise
    // TdiOpenAddress may fail.
    //
    AddrTypeCacheFlush(NewAddr);

    if (!IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
        NTE->nte_flags |= NTE_VALID;
        NTE->nte_rtrdisccount = MAX_SOLICITATION_DELAY;
        NTE->nte_rtrdiscstate = NTE_RTRDISC_DELAYING;
    }
    if (IsDynamic) {
        NTE->nte_flags |= NTE_DYNAMIC;
    }
    NTE->nte_ralist = NULL;
    NTE->nte_echolist = NULL;
    NTE->nte_icmpseq = 0;
    NTE->nte_igmplist = NULL;
    NTE->nte_igmpcount = 0;
    CTEInitLock(&NTE->nte_lock);

    if (IsPrimary) {
        //
        // This is the first (primary) NTE on the interface.
        //
        NTE->nte_flags |= NTE_PRIMARY;

        // Pass our information to the underlying code.
        ipHandlers.IpRcvHandler = IPRcv;
        ipHandlers.IpRcvPktHandler = IPRcvPacket;
        ipHandlers.IpRcvCompleteHandler = IPRcvComplete;
        ipHandlers.IpTxCompleteHandler = IPSendComplete;
        ipHandlers.IpTransferCompleteHandler = IPTDComplete;
        ipHandlers.IpStatusHandler = IPStatus;
        ipHandlers.IpAddAddrCompleteRtn = IPAddAddrComplete;

        ipHandlers.IpPnPHandler = IPPnPEvent;    // IPPnPIndication;

        if (!(*RegRtn) (&(IF->if_configname),
                        NTE,
                        &ipHandlers,
                        BindInfo,
                        IF->if_index)) {

            DEBUGMSG(DBG_ERROR && DBG_PNP,
                (DTEXT("IPAddNTE: Failed to register with LLIPRegRtn.\n")));

            // Couldn't register.
            goto failure;
        } else {
            RegRtnCalled = TRUE;
        }
    }                            //primary
    //
    // Link the NTE onto the global NTE list.
    //

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    NTE->nte_next = NewNetTableList[NET_TABLE_HASH(NewAddr)];
    NewNetTableList[NET_TABLE_HASH(NewAddr)] = NTE;
    NumNTE++;
    NumActiveNTE++;

    NTE->nte_context = (ushort) RtlFindClearBitsAndSet(&g_NTECtxtMap,1,0);

    CTEFreeLock(&RouteTableLock.Lock, Handle);


    if (NTE->nte_context == MAX_NTE_CONTEXT) {

        goto failure;
    }

    if (!InitInterface(NTE)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("IPAddNTE: InitInterface failure.\n")));
        //
        // InitNTE would have incremented if_ntecount,
        // which the failure path decrements.
        // In this case we have not inited this NTE yet.
        // Turn off NTE_VALID to prevent incorrect
        // if_ntecount.
        //

        NTE->nte_flags &= ~NTE_VALID;

        goto failure;
    }
    if (!InitNTE(NTE)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("IPAddNTE: InitNTE failure.\n")));


        goto failure;
    }

    if (NTE->nte_if->if_flags & IF_FLAGS_UNI) {
        // No routes required for uni-direction address.
        DEBUGMSG(DBG_TRACE && DBG_PNP,
            (DTEXT("-IPAddNTE [Unidirectional NTE %x]\n"), NTE));
        return (NTE);
    }

    if (!(NTE->nte_if->if_flags & IF_FLAGS_NOIPADDR)) {
        if (!InitNTERouting(NTE, GConfigInfo->igc_numgws, GConfigInfo->igc_gw,
                            GConfigInfo->igc_gwmetric)) {
            // Couldn't add the routes for this NTE. Mark him as not valid.
            // Probably should log an event here.
            if (NTE->nte_flags & NTE_VALID) {
                NTE->nte_flags &= ~NTE_VALID;
                CTEInterlockedDecrementLong(&(NTE->nte_if->if_ntecount));
                goto failure;
            }
        }
    }

    if (!IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
        SetPersistentRoutesForNTE(
                                  net_long(NTE->nte_addr),
                                  net_long(NTE->nte_mask),
                                  NTE->nte_if->if_index
                                  );
    }

    DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [%x]\n"), NTE));

    return (NTE);

  failure:

    //
    // Don't free the NTE, it will be re-used. However, there is still
    // a timing window on failure that can access the invalid NTE since
    // this isn't done under lock and key.
    //

    if (RegRtnCalled) {
        (*(IF->if_close)) (IF->if_lcontext);
    }

    if (NTE->nte_flags & NTE_TIMER_STARTED) {

        CTEStopTimer(&NTE->nte_timer);
        NTE->nte_flags &= ~NTE_TIMER_STARTED;
    }


    if (NTE->nte_flags & NTE_VALID) {
        NTE->nte_flags &= ~NTE_VALID;
    }


    NTE->nte_flags &= ~NTE_ACTIVE;

    // Remove this NTE if it is on IFlist.

    if (IF && NTE->nte_ifnext) {
        NetTableEntry *PrevNTE;
        PrevNTE = STRUCT_OF(NetTableEntry, &IF->if_nte, nte_ifnext);
        CTEGetLock(&RouteTableLock.Lock, &Handle);
            while (PrevNTE->nte_ifnext != NULL) {
                if (PrevNTE->nte_ifnext == NTE) {
                    PrevNTE->nte_ifnext = NTE->nte_ifnext;
                    break;
                }
                PrevNTE = PrevNTE->nte_ifnext;
            }
        CTEFreeLock(&RouteTableLock.Lock, Handle);
    }
    NTE->nte_if = NULL;
    DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddNTE [NULL]\n")));

    return (NULL);
}

//* IPAddDynamicNTE - Add a new "dynamic" NTE to an existing interface
//
//  Called to dynamically create a new network entry on an existing interface.
//  This entry was not configured when the interaface was originally created
//  and will not persist if the interface is unbound.
//
//  Input:  InterfaceContext  - The context value which identifies the
//                                  interface on which to create the NTE.
//          InterfaceName     - The interface name to use when InterfaceContext
//                                is 0xffff
//          InterfaceNameLen  - The actaul length of the interface name contained
//                              in the IO buffer.
//          NewAddr           - The address of the new NTE.
//          NewMask           - The subnet mask for the new NTE.
//
//  Output: NTEContext    - The context identifying the new NTE.
//          NTEInstance   - The instance number which (reasonably) uniquely
//                              identifies this NTE in time.
//
//  Returns: Nonzero if the operation succeeded. Zero if it failed.
//
IP_STATUS
IPAddDynamicNTE(ulong InterfaceContext, PNDIS_STRING InterfaceName,
                int InterfaceNameLen, IPAddr NewAddr, IPMask NewMask,
                ushort * NTEContext, ulong * NTEInstance)
 {
    IFGeneralConfig GConfigInfo;    // General config info structure.
    NDIS_HANDLE ConfigHandle;    // Configuration handle.
    NetTableEntry *NTE;
    Interface *IF, *DuplicateIF = NULL;
    NTSTATUS writeStatus;
    CTELockHandle Handle;
    BOOLEAN Duplicate = FALSE;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    if ((InterfaceContext == INVALID_INTERFACE_CONTEXT) && InterfaceName &&
        InterfaceName->Length <= InterfaceNameLen) {
        for (IF = IFList; IF != NULL; IF = IF->if_next) {
            if (!(IF->if_flags & IF_FLAGS_DELETING) && (IF->if_devname.Length == InterfaceName->Length) &&
                RtlEqualMemory(IF->if_devname.Buffer, InterfaceName->Buffer, IF->if_devname.Length)) {
                break;
            }
        }
    } else {
        for (IF = IFList; IF != NULL; IF = IF->if_next) {
            if ((IF->if_refcount != 0) && (IF->if_index == InterfaceContext) && (IF != &LoopInterface)) {
                break;
            }
        }

    }

    if (IF) {
        LOCKED_REFERENCE_IF(IF);

        //check for duplicate
        //This is required to return duplicate error immdtly.
        //Note that this check is already done in IPAddNTE.
        //But being duplicated here to prevent change in IpAddNTE
        //just for passing this status...

        NetTableList = NewNetTableList[NET_TABLE_HASH(NewAddr)];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {

            if (IP_ADDR_EQUAL(NTE->nte_addr, NewAddr) && !IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
                Duplicate = TRUE;
                DuplicateIF = NTE->nte_if;
                break;
            }
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);

    if (IF == NULL) {
        return IP_DEVICE_DOES_NOT_EXIST;
    }
    if (Duplicate) {
        if (IF == DuplicateIF) {

            DerefIF(IF);
            return IP_DUPLICATE_IPADD;
        } else {
            DerefIF(IF);
            return IP_DUPLICATE_ADDRESS;

        }
    }

    if (!IF->if_mediastatus) {
        DerefIF(IF);
        return IP_MEDIA_DISCONNECT;
    }

    //* Try to get the network configuration information.
    if (!OpenIFConfig(&(IF->if_configname), &ConfigHandle)) {
        DerefIF(IF);
        return IP_GENERAL_FAILURE;
    }
    // Try to get our general config information.
    if (!GetGeneralIFConfig(&GConfigInfo, ConfigHandle, &IF->if_configname)) {
        goto failure;
    }
    NTE = IPAddNTE(&GConfigInfo,
                   NULL,        // PNPContext
                   NULL,        // RegRtn - not needed if not primary
                   NULL,        // BindInfo - not needed if not primary
                   IF,
                   NewAddr,
                   NewMask,
                   FALSE,       // not primary
                   TRUE         // is dynamic
                   );

    if (NTE == NULL) {
        goto failure;
    }

    writeStatus = IPAddNTEContextList(ConfigHandle,
                                      NTE->nte_context,
                                      FALSE        // no primary
                                      );

    if (!NT_SUCCESS(writeStatus)) {
        CTELogEvent(IPDriverObject,
                    EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE,
                    2,
                    1,
                    &IF->if_devname.Buffer,
                    0,
                    NULL
                    );

        TCPTRACE((
                  "IP: Unable to read or write the NTE Context list for adapter %ws\n"
                  "   (status %lx).IP interfaces on this adapter may not be initialized completely \n",
                  IF->if_devname.Buffer,
                  writeStatus
                 ));
    }

    CloseIFConfig(ConfigHandle);

    //
    // Notify upper layers of the new address.
    //
    NotifyAddrChange(NTE->nte_addr, NTE->nte_mask, NTE->nte_pnpcontext,
                     NTE->nte_context, &NTE->nte_addrhandle, &(IF->if_configname), &IF->if_devname, TRUE);
    if (!IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
        InitIGMPForNTE(NTE);
    }
    //
    // Fill in the out parameter value.
    //
    *NTEContext = NTE->nte_context;
    *NTEInstance = NTE->nte_instance;

    DerefIF(IF);

    return (STATUS_SUCCESS);

  failure:

    DerefIF(IF);
    CloseIFConfig(ConfigHandle);
    return (IP_GENERAL_FAILURE);
}

void
IncrInitTimeInterfaces(Interface * IF)
{
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    if (InitTimeInterfacesDone == FALSE) {
        InitTimeInterfaces++;
        IF->if_InitInProgress = TRUE;
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);
    // TCPTRACE(("IP: New init Interface %lx, Total InitTimeInterfaces %lx\n", IF, InitTimeInterfaces));
}

void
DecrInitTimeInterfaces(Interface * IF)
{
    CTELockHandle Handle;
    uint Decr;

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    Decr = FALSE;

    // IF would be NULL if this is called when we receive bindcomplete event from ndis.
    // since ndis may give multiple bind complete events, we need to ignore any subsequent
    // events after InitTimeInterfacesDone is true.
    // similarly we decrement InitTimeInterfaces counter only for those interfaces
    // for which if_InitInProgress is true.
    if (IF) {
        if (IF->if_InitInProgress) {
            IF->if_InitInProgress = FALSE;
            Decr = TRUE;
        }
    } else {

        BOOLEAN CheckForProviderReady = FALSE;

        //
        // ReEnumerateNdisBinding results in
        // NdisBindComplete event that needs
        // to be ignored.
        //

        if (InterlockedDecrement( (PLONG) &ReEnumerateCount) < 0) {
            CheckForProviderReady = TRUE;
        }

        if (CheckForProviderReady &&
            (FALSE == InitTimeInterfacesDone)) {
            InitTimeInterfacesDone = TRUE;
            Decr = TRUE;
        }

    }
    if (Decr) {
        ASSERT(InitTimeInterfaces);

        --InitTimeInterfaces;
        //TCPTRACE(("IP: Decremented init Interface %lx, Total InitTimeInterfaces %lx\n", IF,InitTimeInterfaces));
        if (!InitTimeInterfaces) {

            CTEFreeLock(&RouteTableLock.Lock, Handle);
            // TdiProviderReady();
            TdiProviderReady(IPProviderHandle);
            return;
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);
}

//*     RePlumbStaticAddr - Add static routes o media connect.
//
//
//      Input:  AddAddrEvent
//              Context
//
//      Returns: none.
//

void
RePlumbStaticAddr(CTEEvent * Event, PVOID Context)
{
    AddStaticAddrEvent *AddAddrEvent = (AddStaticAddrEvent *) Context;
    Interface *IF = NULL;
    NDIS_HANDLE Handle;
    CTELockHandle TableHandle;
    IFAddrList *AddrList;
    uint i, j, NumAddr = 0;
    uint EnableDhcp = TRUE;
    IFGeneralConfig GConfigInfo;
    IP_STATUS ipstatus;
    NetTableEntry *NTE;
    uint index;


    UNREFERENCED_PARAMETER(Event);


    //
    //reset the interface metric when it is in auto mode, in case of a speed change
    //
    if (AddAddrEvent->IF) {
        // get lock
        CTEGetLock(&RouteTableLock.Lock, &TableHandle);

        if ((AddAddrEvent->IF->if_auto_metric) && (AddAddrEvent->IF->if_dondisreq)) {
            uint speed;
            LOCKED_REFERENCE_IF(AddAddrEvent->IF);
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            if ((*AddAddrEvent->IF->if_dondisreq)(
                                                  AddAddrEvent->IF->if_lcontext,
                                                  NdisRequestQueryInformation,
                                                  OID_GEN_LINK_SPEED,
                                                  &speed,
                                                  sizeof(speed),
                                                  NULL,
                                                  TRUE) == NDIS_STATUS_SUCCESS) {
                speed *= 100L;
                //actual speed is 100 times what we got from the query
                CTEGetLock(&RouteTableLock.Lock, &TableHandle);
                if (speed != AddAddrEvent->IF->if_speed) {
                    AddAddrEvent->IF->if_speed = speed;
                    AddAddrEvent->IF->if_metric = GetAutoMetric(speed);
                }
                LockedDerefIF(AddAddrEvent->IF);
                CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            } else {
                DerefIF(AddAddrEvent->IF);
            }
        } else {
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
        }
    }

    if (!OpenIFConfig(&AddAddrEvent->ConfigName, &Handle)) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"RePlumbStaticAddr: Failed to Open config info\n"));
        if (AddAddrEvent->ConfigName.Buffer) {
            CTEFreeMem(AddAddrEvent->ConfigName.Buffer);
        }

        // Undo the refcount that was taken when ReplumbStaticAddr
        // was scheduled.
        if (AddAddrEvent->IF) {
            DerefIF(AddAddrEvent->IF);
        }

        CTEFreeMem(AddAddrEvent);
        return;
    }
    if (!GetGeneralIFConfig(&GConfigInfo, Handle, &AddAddrEvent->ConfigName)) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"RePlumbStaticAddr: Failed to get configinfo\n"));
        if (AddAddrEvent->ConfigName.Buffer) {
            CTEFreeMem(AddAddrEvent->ConfigName.Buffer);
        }

        // Undo the refcount that was taken when ReplumbStaticAddr
        // was scheduled.
        if (AddAddrEvent->IF) {
            DerefIF(AddAddrEvent->IF);
        }

        CTEFreeMem(AddAddrEvent);
        CloseIFConfig(Handle);
        return;
    }
    AddrList = GetIFAddrList(&NumAddr, Handle, &EnableDhcp, FALSE,
                             &AddAddrEvent->ConfigName);

    // AddrList is not used, free it here.
    if (AddrList) {
        CTEFreeMem(AddrList);
    }

    if (EnableDhcp || !NumAddr) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"RePlumbStaticAddr: No static routes(or dhcpenabled) on this interface %x\n", AddAddrEvent->IF));
        if (AddAddrEvent->ConfigName.Buffer) {
            CTEFreeMem(AddAddrEvent->ConfigName.Buffer);
        }

        // Undo the refcount that was taken when ReplumbStaticAddr
        // was scheduled.
        if (AddAddrEvent->IF) {
            DerefIF(AddAddrEvent->IF);
        }

        CTEFreeMem(AddAddrEvent);
        CloseIFConfig(Handle);
        return;
    }
    CloseIFConfig(Handle);

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);



    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF == AddAddrEvent->IF)
            break;
    }

    if (IF) {
        index = IF->if_index;
        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

        for (i = 0; i < NET_TABLE_SIZE; i++) {
            NetTableEntry *NetTableList = NewNetTableList[i];

            NTE = NetTableList;
            while (NTE != NULL) {
                NetTableEntry *NextNTE = NTE->nte_next;

                if ((NTE->nte_if == IF) && (NTE->nte_flags & NTE_DISCONNECTED) &&

                    (NTE->nte_flags & NTE_ACTIVE)) {

                    SetAddrControl *controlBlock;

                    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

                    ASSERT(NTE != LoopNTE);
                    ASSERT(NTE->nte_flags & ~NTE_VALID);
                    ASSERT(NTE->nte_flags & ~NTE_DYNAMIC);

                    // disconnected NTEs are still assumed to  have valid addr and mask

                    NTE->nte_flags &= ~NTE_DISCONNECTED;

                    controlBlock = CTEAllocMemN(sizeof(SetAddrControl), 'lICT');
                    if (!controlBlock) {
                        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
                    } else {

                        RtlZeroMemory(controlBlock, sizeof(SetAddrControl));

                        //Indicate to arp that display popup is needed
                        controlBlock->StaticAddr=TRUE;

                        ipstatus = IPpSetNTEAddr(NTE, NTE->nte_addr, NTE->nte_mask, &TableHandle, controlBlock, ReplumbAddrComplete);
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                  "Replumb nte addr on nte %x if %x\n",
                                   NTE, IF, ipstatus));

                        if ((ipstatus == IP_SUCCESS) ||
                            (ipstatus == IP_PENDING)) {

                            for (j = 0; j < GConfigInfo.igc_numgws; j++) {
                                IPAddr GWAddr;

                                GWAddr = net_long(GConfigInfo.igc_gw[j]);

                                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                           "RePlumbStaticAddr: adding route "
                                           "GWAddr %x nteaddr %x\n",
                                           GWAddr, NTE->nte_addr));
                                if (IP_ADDR_EQUAL(GWAddr, NTE->nte_addr)) {

                                    AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                                             IPADDR_LOCAL, NTE->nte_if, NTE->nte_mss,
                                             GConfigInfo.igc_gwmetric[j]
                                             ? GConfigInfo.igc_gwmetric[j] : IF->if_metric,
                                             IRE_PROTO_NETMGMT, ATYPE_OVERRIDE,
                                             0, 0);
                                } else
                                    AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                                             GWAddr, NTE->nte_if, NTE->nte_mss,
                                             GConfigInfo.igc_gwmetric[j]
                                             ? GConfigInfo.igc_gwmetric[j] : IF->if_metric,
                                             IRE_PROTO_NETMGMT, ATYPE_OVERRIDE,
                                             0, 0);

                                //now plumb corresponding persistent route

                                SetPersistentRoutesForNTE(NTE->nte_addr,
                                                          NTE->nte_mask, index);
                            }
                        } else {
                            //
                            // in the failure case, we need to free the context block
                            //
                            CTEFreeMem(controlBlock);
                        }
                    }
                }
                NTE = NextNTE;
            }
        }


    } else {

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
    }

    // Undo the refcount that was taken when ReplumbStaticAddr
    // was scheduled.
    if (AddAddrEvent->IF) {
        DerefIF(AddAddrEvent->IF);
    }

    if (AddAddrEvent->ConfigName.Buffer) {
        CTEFreeMem(AddAddrEvent->ConfigName.Buffer);
    }

    CTEFreeMem(AddAddrEvent);
}

void
ReplumbAddrComplete(
                    void *Context,
                    IP_STATUS Status
                    )
{
    SetAddrControl *controlBlock;

    DBG_UNREFERENCED_PARAMETER(Status);

    controlBlock = (SetAddrControl *) Context;

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
               "Replumb completed %d\n", Status));

    CTEFreeMem(controlBlock);
}

//*     RemoveStaticAddr - Add static routes o media connect.
//
//
//      Input:  AddAddrEvent
//              Context
//
//      Returns: none.
//

void
RemoveStaticAddr(CTEEvent * Event, PVOID Context)
{
    CTELockHandle Handle;
    NetTableEntry *NTE;
    Interface *IF = NULL;
    AddStaticAddrEvent *AddAddrEvent = (AddStaticAddrEvent *) Context;
    uint i;


    UNREFERENCED_PARAMETER(Event);


    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (IF = IFList; IF != NULL; IF = IF->if_next) {
        if (IF == AddAddrEvent->IF)
            break;
    }

    if (IF == NULL) {

        // Undo the refcount that was taken when ReplumbStaticAddr
        // was scheduled.
        if (AddAddrEvent->IF) {
            LockedDerefIF(AddAddrEvent->IF);
        }

        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return;
    }


    CTEFreeLock(&RouteTableLock.Lock, Handle);

    //
    // This function is called on media disconnect. We need to call
    // DecrInitTimeInterfaces in case we have not removed our reference yet
    // (which causes tcpip not to indicate TdiProviderReady). Since
    // IPStatus is called DPC (and DampCheck also runs at timer DPC) we have
    // to wait this event to call DecrInitTimeInterfaces. This call has no
    // effect if we have already released our reference.
    //
    // This can occur if a media disconnect arrives before dhcp address
    // negotiation begins.
    //

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    DecrInitTimeInterfaces(IF);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {

            if ((NTE->nte_flags & NTE_VALID) && (NTE->nte_if == IF) &&
                (NTE->nte_flags & ~NTE_DYNAMIC) &&
                (NTE->nte_flags & NTE_ACTIVE)) {

                CTEGetLock(&RouteTableLock.Lock, &Handle);

                ASSERT(NTE != LoopNTE);

                NTE->nte_flags |= NTE_DISCONNECTED;
                // while setting the ip address to NULL, we just mark the NTE as INVALID
                // we don't actually move the hashes
                if (IPpSetNTEAddr(NTE, NULL_IP_ADDR, NULL_IP_ADDR, &Handle, NULL, NULL) != IP_SUCCESS) {
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                              "Failed to set null address on nte %x if %x\n",
                               NTE, IF));
                }

                //Ippsetnteaddr frees the  routetable lock
            }
        }
    }


    // Undo the interface refcount that was taken when RemoveStaticAddr
    // was scheduled

    DerefIF(IF);


    return;
}

void
TempDhcpAddrDone(
                 void *Context,
                 IP_STATUS Status
                 )
/*++

Routine Description:

    Handles the completion of an IP Set Addr request

    Arguments:

    Context       - Pointer to the SetAddrControl structure for this
    Status        - The IP status of the transmission.

    Return Value:

    None.

--*/
{
    SetAddrControl *SAC;
    Interface *IF;
    SAC = (SetAddrControl *) Context;
    IF = (Interface *) SAC->interface;


    UNREFERENCED_PARAMETER(Status);

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
              "tempdhcpaddrdone: addaddr done, notifying bind\n"));

    IPNotifyClientsIPEvent(IF, IP_BIND_ADAPTER);

    CTEFreeMem(SAC);
}

Interface *
AllocInterface(uint IFSize)
/*++

Routine Description:

    Allocated an Interface, also checks if the freelist size has increased to a threshold
    Called with no locks, so take a routetable lock
    Arguments:

    IFSize : Size of the interface to be allocated

    Return Value:

    IF we are trying to allocate

--*/
{
    Interface *IF, *TmpIF;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    IF = CTEAllocMemNBoot(IFSize, 'wICT');

    if (TotalFreeInterfaces > MaxFreeInterfaces) {
        // free the first interface in the list
        ASSERT(FrontFreeList != NULL);
        TmpIF = FrontFreeList;
        FrontFreeList = FrontFreeList->if_next;
        CTEFreeMem(TmpIF);

        TotalFreeInterfaces--;

        // check whether the list became empty
        if (FrontFreeList == NULL) {
            RearFreeList = NULL;
            ASSERT(TotalFreeInterfaces == 0);
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return IF;
}

void
FreeInterface(Interface * IF)
/*++

Routine Description:

    Free an Interface to the freelist
    Called with routetable lock held
    Arguments:

    IF : Interface to free

    Return Value:

    None

--*/
{

    if (FrontFreeList == NULL) {
        FrontFreeList = IF;
    }
    // link this new interface at the back of the list

    if (RearFreeList) {
        RearFreeList->if_next = IF;
    }
    RearFreeList = IF;
    IF->if_next = NULL;

    TotalFreeInterfaces++;

    return;
}



//*     IPAddInterface - Add an interface.
//
//      Called when someone has an interface they want us to add. We read our
//      configuration information, and see if we have it listed. If we do,
//      we'll try to allocate memory for the structures we need. Then we'll
//      call back to the guy who called us to get things going. Finally, we'll
//      see if we have an address that needs to be DHCP'ed.
//
//      Input:  ConfigName                              - Name of config info we're to read.
//                      Context                                 - Context to pass to i/f on calls.
//                      RegRtn                                  - Routine to call to register.
//                      BindInfo                                - Pointer to bind information.
//
//      Returns: Status of attempt to add the interface.
//
IP_STATUS
__stdcall
IPAddInterface(
               PNDIS_STRING DeviceName,
               PNDIS_STRING IfName, OPTIONAL
               PNDIS_STRING ConfigName,
               void *PNPContext,
               void *Context,
               LLIPRegRtn RegRtn,
               LLIPBindInfo * BindInfo,
               UINT RequestedIndex,
               ULONG MediaType,
               UCHAR AccessType,
               UCHAR ConnectionType
               )
{
    IFGeneralConfig GConfigInfo;
    IFAddrList *AddrList;
    uint NumAddr;
    NetTableEntry *NTE = NULL;
    uint i;
    Interface *IF, *PrevIf, *CurrIf;
    NDIS_HANDLE Handle;
    NetTableEntry *PrimaryNTE = NULL;
    uint IFIndex;
    NetTableEntry *LastNTE;
    NTSTATUS writeStatus;
    uint IFExportNamePrefixLen, IFBindNamePrefixLen;
    uint IFNameLen, IFSize;
    RouteInterface *RtIF;
    uint EnableDhcp;
    PWCHAR IfNameBuf;
    uint MediaStatus;
    NTSTATUS Status;
    CTELockHandle TableHandle;
    IPAddr TempDHCPAddr = NULL_IP_ADDR;
    IPAddr TempMask = NULL_IP_ADDR;
    IPAddr TempGWAddr[MAX_DEFAULT_GWS];
    BOOLEAN TempDHCP = FALSE;
    BOOLEAN UniDirectional = FALSE;
    BOOLEAN PppIf;

#if MILLEN
    // Millennium seems to pass in ANSI name in the buffer for DeviceName
    // rather than Unicode, even though an NDIS_STRING is unicode for
    // WDM drivers. ConfigName is correct, however.
    NDIS_STRING UnicodeDevName;

    UnicodeDevName.Buffer = NULL;

    Status = RtlAnsiStringToUnicodeString(
        &UnicodeDevName,
        (PANSI_STRING) DeviceName,
        TRUE);

    if (!NT_SUCCESS(Status)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: RtlAnsiStringToUnicodeString failure.\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddInterface [NDIS_STATUS_RESOURCES]\n")));
        return NDIS_STATUS_RESOURCES;
    }

    // I have seen where the length of DeviceName is incorrect. Ensure
    // that the length is correct since TDI bindings depend on this string
    // value.
    UnicodeDevName.Length = wcslen(UnicodeDevName.Buffer) * sizeof(WCHAR);
    DeviceName = &UnicodeDevName;

    //
    // Next thing that I have seen is that NDIS has indicated bindings twice.
    // Search the IFList and ensure that we aren't adding a second IF for the
    // same binding.
    //

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

    CurrIf = IFList;

    while (CurrIf) {
        if (DeviceName->Length == CurrIf->if_devname.Length &&
            RtlCompareMemory(DeviceName->Buffer, CurrIf->if_devname.Buffer, DeviceName->Length) == DeviceName->Length) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                      "IPAddInterface -- double bind of same interface!!\n"));
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            return STATUS_INVALID_PARAMETER;
        }

        CurrIf = CurrIf->if_next;
    }

    CTEFreeLock(&RouteTableLock.Lock, TableHandle);
#endif // MILLEN

    DBG_UNREFERENCED_PARAMETER(Context);

    if (RequestedIndex != 0) {

        CTEGetLock(&RouteTableLock.Lock, &TableHandle);

        CurrIf = IFList;

        while (CurrIf != NULL) {

            if (CurrIf->if_index == RequestedIndex ) {

                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPAddInterface: Interface 0x%x already exists\n",
                         RequestedIndex));

                CTEFreeLock(&RouteTableLock.Lock, TableHandle);

                return (IP_STATUS) STATUS_INVALID_PARAMETER;
            }

            CurrIf = CurrIf->if_next;
        }

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);
    }

    AddrList = NULL;
    IF = NULL;
    LastNTE = NULL;
    EnableDhcp = TRUE;

    IfNameBuf = NULL;

    DEBUGMSG(DBG_TRACE && DBG_PNP,
        (DTEXT("+IPAddInterface(%x, %x, %x, %x, %x, %x, %x, %x, %x, %x, %x)\n"),
        DeviceName, IfName, ConfigName, PNPContext, Context, RegRtn,
        BindInfo, RequestedIndex, MediaType,
        (LONG) AccessType, (LONG) ConnectionType));

    //* First, try to get the network configuration information.
    if (!OpenIFConfig(ConfigName, &Handle)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: OpenIFConfig failure.\n")));
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddInterface [GENERAL_FAILURE]\n")));
        return IP_GENERAL_FAILURE;    // Couldn't get IFConfig.
    }

    // Try to get our general config information.
    if (!GetGeneralIFConfig(&GConfigInfo, Handle, ConfigName)) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: GetGeneralIFConfig failure.\n")));
        goto failure;
    }

    // We got the general config info. Now allocate an interface.
#if MILLEN
    // There is not a prefix in millennium.
    IFExportNamePrefixLen = 0;
    IFBindNamePrefixLen = 0;
#else // MILLEN
    IFExportNamePrefixLen = (uint) (wcslen(TCP_EXPORT_STRING_PREFIX) * sizeof(WCHAR));
    IFBindNamePrefixLen = (uint) (wcslen(TCP_BIND_STRING_PREFIX) * sizeof(WCHAR));
#endif // !MILLEN

    IFNameLen = DeviceName->Length +
        IFExportNamePrefixLen -
        IFBindNamePrefixLen;

    IFSize = InterfaceSize +
        ConfigName->Length + sizeof(WCHAR) +
        IFNameLen + sizeof(WCHAR);

    /*    IF = CTEAllocMemNBoot(IFSize,
                              'wICT'); */

    IF = AllocInterface(IFSize);
    if (IF == NULL) {
        DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: failed to allocate IF.\n")));
        goto failure;
    }

    RtlZeroMemory(IF, IFSize);

    if (IfName) {
        IfNameBuf = CTEAllocMemN(IfName->Length + sizeof(WCHAR),
                                 'wICT');

        if (IfNameBuf == NULL) {
            DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: failed to allocate IF name buf.\n")));
            goto failure;
        }
    }

    // increment the init time interface counter if this is indeed inittimeinterface

    IncrInitTimeInterfaces(IF);

    CTEInitLock(&IF->if_lock);

    // Initialize the broadcast we'll use.
    if (GConfigInfo.igc_zerobcast)
        IF->if_bcast = IP_ZERO_BCST;
    else
        IF->if_bcast = IP_LOCAL_BCST;

    RtIF = (RouteInterface *) IF;

    RtIF->ri_q.rsq_qh.fq_next = &RtIF->ri_q.rsq_qh;
    RtIF->ri_q.rsq_qh.fq_prev = &RtIF->ri_q.rsq_qh;
    RtIF->ri_q.rsq_running = FALSE;
    RtIF->ri_q.rsq_pending = 0;
    RtIF->ri_q.rsq_maxpending = GConfigInfo.igc_maxpending;
    RtIF->ri_q.rsq_qlength = 0;
    CTEInitLock(&RtIF->ri_q.rsq_lock);
    IF->if_xmit = BindInfo->lip_transmit;
    IF->if_transfer = BindInfo->lip_transfer;
    IF->if_close = BindInfo->lip_close;
    IF->if_invalidate = BindInfo->lip_invalidate;
    IF->if_lcontext = BindInfo->lip_context;
    IF->if_addaddr = BindInfo->lip_addaddr;
    IF->if_deladdr = BindInfo->lip_deladdr;
    IF->if_qinfo = BindInfo->lip_qinfo;
    IF->if_setinfo = BindInfo->lip_setinfo;
    IF->if_getelist = BindInfo->lip_getelist;
    IF->if_dowakeupptrn = BindInfo->lip_dowakeupptrn;
    IF->if_pnpcomplete = BindInfo->lip_pnpcomplete;
    IF->if_dondisreq = BindInfo->lip_dondisreq;
    IF->if_setndisrequest = BindInfo->lip_setndisrequest;
    IF->if_arpresolveip = BindInfo->lip_arpresolveip;
    IF->if_arpflushate = BindInfo->lip_arpflushate;
    IF->if_arpflushallate = BindInfo->lip_arpflushallate;
#if MILLEN
    IF->if_cancelpackets = NULL;
#else
    IF->if_cancelpackets = BindInfo->lip_cancelpackets;
#endif
    IF->if_tdpacket = NULL;
    ASSERT(BindInfo->lip_mss > sizeof(IPHeader));

    IF->if_mtu = BindInfo->lip_mss - sizeof(IPHeader);
    IF->if_speed = BindInfo->lip_speed;
    IF->if_flags = BindInfo->lip_flags & LIP_P2P_FLAG ? IF_FLAGS_P2P : 0;
    IF->if_pnpcap = BindInfo->lip_pnpcap;    //copy wol capability

    //
    // If ARP reported a uni-directional address, mark the IF.
    //
    if (BindInfo->lip_flags & LIP_UNI_FLAG) {
        IF->if_flags |= IF_FLAGS_UNI;
        UniDirectional = TRUE;
    }

    //Unnumbered interface change
    if (BindInfo->lip_flags & LIP_NOIPADDR_FLAG) {

        IF->if_flags |= IF_FLAGS_NOIPADDR;

        // KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Unnumbered interface %x", IF));

    }

    // Check whether the lower interface is a P2MP interface
    if (BindInfo->lip_flags & LIP_P2MP_FLAG) {

        IF->if_flags |= IF_FLAGS_P2MP;

        DEBUGMSG(DBG_INFO && DBG_PNP,
            (DTEXT("IPAddInterface: %x :: P2MP interface\n"), IF));

        if (BindInfo->lip_flags & LIP_NOLINKBCST_FLAG) {

            IF->if_flags |= IF_FLAGS_NOLINKBCST;

            DEBUGMSG(DBG_INFO && DBG_PNP,
                (DTEXT("IPAddInterface: %x :: NOLINKBCST interface\n"), IF));
        }
    }

    // When the link is deleted, we call lower layers closelink
    IF->if_closelink = BindInfo->lip_closelink;

    IF->if_addrlen = BindInfo->lip_addrlen;
    IF->if_addr = BindInfo->lip_addr;
    IF->if_pnpcontext = PNPContext;
    IF->if_llipflags = BindInfo->lip_flags;

    // Initialize the reference count to 1, for the open.
    LOCKED_REFERENCE_IF(IF);

#if IPMCAST
    IF->if_mcastttl = 1;
    IF->if_mcastflags = 0;
    IF->if_lastupcall = 0;
#endif

    //Propogate checksum and per interface tcp parameters

    IF->if_OffloadFlags = BindInfo->lip_OffloadFlags;
    IF->if_IPSecOffloadFlags = BindInfo->lip_IPSecOffloadFlags;
    IF->if_MaxOffLoadSize = BindInfo->lip_MaxOffLoadSize;
    IF->if_MaxSegments = BindInfo->lip_MaxSegments;

#if FFP_SUPPORT
    IF->if_ffpversion = BindInfo->lip_ffpversion;
    IF->if_ffpdriver = BindInfo->lip_ffpdriver;
#endif

    IF->if_TcpWindowSize = GConfigInfo.igc_TcpWindowSize;
    IF->if_TcpInitialRTT = GConfigInfo.igc_TcpInitialRTT;

    //get the delack time in 100msec ticks
    IF->if_TcpDelAckTicks = GConfigInfo.igc_TcpDelAckTicks;
    IF->if_TcpAckFrequency = GConfigInfo.igc_TcpAckFrequency;
    IF->if_iftype = GConfigInfo.igc_iftype;

#ifdef IGMPV3
    IF->IgmpVersion = IGMPV3;
#else
#ifdef IGMPV2
    IF->IgmpVersion = IGMPV2;
#else
    IF->IgmpVersion = IGMPV1;
#endif
#endif

    //
    // No need to do the following since IF structure is inited to 0 through
    // memset above
    //
    // IF->IgmpVer1Timeout = 0;

    //
    // Copy the config string for use later when DHCP enables an address
    // on this interface or when an NTE is added dynamically.
    //

    IF->if_configname.Buffer = (PVOID) (((uchar *) IF) + InterfaceSize);

    IF->if_configname.Length = 0;
    IF->if_configname.MaximumLength = ConfigName->Length + sizeof(WCHAR);

    CTECopyString(&(IF->if_configname),
                  ConfigName);

    IF->if_devname.Buffer = (PVOID) (((uchar *) IF) +
                                     InterfaceSize +
                                     IF->if_configname.MaximumLength);

    IF->if_devname.Length = (USHORT) IFNameLen;
    IF->if_devname.MaximumLength = (USHORT) (IFNameLen + sizeof(WCHAR));

#if MILLEN
    IF->if_order = MAXLONG;
#else
    CTEGetLock(&RouteTableLock.Lock, &TableHandle);
    IF->if_order =
        IPMapDeviceNameToIfOrder(DeviceName->Buffer +
                                 IFBindNamePrefixLen / sizeof(WCHAR));
    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

    RtlCopyMemory(IF->if_devname.Buffer,
               TCP_EXPORT_STRING_PREFIX,
               IFExportNamePrefixLen);
#endif // !MILLEN

    RtlCopyMemory((uchar *) IF->if_devname.Buffer + IFExportNamePrefixLen,
               (uchar *) DeviceName->Buffer + IFBindNamePrefixLen,
               DeviceName->Length - IFBindNamePrefixLen);

    IF->if_numgws = GConfigInfo.igc_numgws;

    RtlCopyMemory(IF->if_gw,
               GConfigInfo.igc_gw,
               sizeof(IPAddr) * GConfigInfo.igc_numgws);

    RtlCopyMemory(IF->if_gwmetric,
               GConfigInfo.igc_gwmetric,
               sizeof(uint) * GConfigInfo.igc_numgws);

    IF->if_metric = GConfigInfo.igc_metric;

    //if the metric is 0, set the metric according to the interface speed.

    if (!IF->if_metric) {
        IF->if_auto_metric = 1;
        IF->if_metric = GetAutoMetric(IF->if_speed);
    } else {
        IF->if_auto_metric = 0;
    }

    if (IfName) {
        ASSERT(IfNameBuf);
        ASSERT((IfName->Length % sizeof(WCHAR)) == 0);

        IF->if_name.Buffer = IfNameBuf;
        IF->if_name.Length = IfName->Length;

        IF->if_name.MaximumLength = IfName->Length + sizeof(WCHAR);

        RtlCopyMemory(IfNameBuf,
                   IfName->Buffer,
                   IfName->Length);

        IfNameBuf[IfName->Length / sizeof(WCHAR)] = UNICODE_NULL;
    }
    IF->if_dfencap = GConfigInfo.igc_dfencap;
    IF->if_rtrdiscovery =  GConfigInfo.igc_rtrdiscovery;
    IF->if_dhcprtrdiscovery = 0;

    PppIf = IF->if_flags & IF_FLAGS_P2P ? TRUE : FALSE;
    // Find out how many addresses we have, and get the address list.
    AddrList = GetIFAddrList(&NumAddr, Handle, &EnableDhcp, PppIf, ConfigName);

    if (AddrList == NULL) {
        DEBUGMSG(DBG_ERROR && DBG_PNP,
            (DTEXT("IPAddInterface: GetIFAddrList failure.\n")));
        goto failure;
    }

    //
    // Set the types up
    //

    IF->if_mediatype = MediaType;
    IF->if_accesstype = AccessType;
    IF->if_conntype = ConnectionType;
    IF->if_lastproc = KeNumberProcessors;

    //
    // If the user has specified an index, we assume she is doing the
    // right thing and we shall reuse the index
    //

    if (RequestedIndex != 0) {
        IF->if_index = RequestedIndex;
    } else {
        IFIndex = RtlFindClearBitsAndSet(&g_rbIfMap,
                                         1,
                                         0);

        if (IFIndex == -1) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPAddInterface: Too many interfaces\n"));
            goto failure;
        }
        //
        // The indices are +1 of the index into the bit mask
        //

        IFIndex += 1;

        IF->if_index = IFIndex | (UniqueIfNumber << IF_INDEX_SHIFT);
    }

    // Now loop through, initializing each NTE as we go. We don't hold any
    // locks while we do this, since NDIS won't reenter us here and no one
    // else manipulates the NetTableList.

    for (i = 0; i < NumAddr; i++) {
        uint isPrimary;

        if (i == 0) {
            isPrimary = TRUE;
        } else {
            isPrimary = FALSE;
        }

        NTE = IPAddNTE(
                       &GConfigInfo,
                       PNPContext,
                       RegRtn,
                       BindInfo,
                       IF,
                       net_long(AddrList[i].ial_addr),
                       net_long(AddrList[i].ial_mask),
                       isPrimary,
                       FALSE    // not dynamic
                       );

        if (NTE == NULL) {
            DEBUGMSG(DBG_ERROR && DBG_PNP, (DTEXT("IPAddInterface: IPAddNTE failure.\n")));
            goto failure;
        }

        writeStatus = IPAddNTEContextList(
                                          Handle,
                                          NTE->nte_context,
                                          isPrimary);

        if (!NT_SUCCESS(writeStatus)) {
            CTELogEvent(
                        IPDriverObject,
                        EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE,
                        1,
                        1,
                        &IF->if_devname.Buffer,
                        0,
                        NULL
                        );

            DEBUGMSG(DBG_WARN && DBG_PNP,
                (DTEXT("IPAddInterface: IF %x. Unable to read or write the NTE\n")
                 TEXT("context list for adapter %ws. IP interfaces on this\n")
                 TEXT("adapter may not be completely initialized. Status %x\n"),
                 IF, IF->if_devname.Buffer, writeStatus));
        }

        if (isPrimary) {
            PrimaryNTE = NTE;
        }
        LastNTE = NTE;
    }

    CloseIFConfig(Handle);

    //
    // Link this interface onto the global interface list
    // This list is an ordered list
    //

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);

    PrevIf = CONTAINING_RECORD(IFList,
                               Interface,
                               if_next);

    CurrIf = IFList;

    while (CurrIf != NULL) {
        ASSERT(CurrIf->if_index != IF->if_index);

        if (CurrIf->if_index > IF->if_index) {
            break;
        }
        PrevIf = CurrIf;
        CurrIf = CurrIf->if_next;

    }

    IF->if_next = CurrIf;
    PrevIf->if_next = IF;

    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

    NumIF++;

    // register this device object with tdi so that nbt can create its device object
    TdiRegisterDeviceObject(
                            &IF->if_devname,
                            &IF->if_tdibindhandle
                            );
    // We've initialized our NTEs. Now get the adapter open, and go through
    // again, calling DHCP if we need to.

    (*(BindInfo->lip_open)) (BindInfo->lip_context);

    //query media connectivity

    //
    // We need to get route table lock here.
    //
    CTEGetLock(&RouteTableLock.Lock, &TableHandle);
    if (GConfigInfo.igc_disablemediasense == FALSE &&
        !(IF->if_flags & IF_FLAGS_P2P)) {
        // Media sense doesn't make sense on P2P adapters.
        IF->if_flags |= IF_FLAGS_MEDIASENSE;
    }

    IF->if_mediastatus = 1;        //assume connected

    if (IF->if_flags & IF_FLAGS_MEDIASENSE) {

        if (IF->if_dondisreq) {
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            Status = (*IF->if_dondisreq) (IF->if_lcontext,
                                          NdisRequestQueryInformation,
                                          OID_GEN_MEDIA_CONNECT_STATUS,
                                          &MediaStatus,
                                          sizeof(MediaStatus),
                                          NULL,
                                          TRUE);

            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            if (Status == NDIS_STATUS_SUCCESS) {
                if (MediaStatus == NdisMediaStateDisconnected) {
                    IF->if_mediastatus = 0;
                }
            }
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

    DEBUGMSG(DBG_INFO && DBG_PNP,
        (DTEXT("IPAddInterface: IF %x - media status %s\n"),
        IF, IF->if_mediastatus ? TEXT("CONNECTED") : TEXT("DISCONNECTED")));

    //
    // For the uni-directional adapter case, we notify and bail.
    //
    if (UniDirectional) {
        //
        // Now we are going to create an address for the uni-directional
        // adapter. (We will just use the if_index). We will have to change
        // the position in the hash table. Ideally, I would set the address
        // before calling IPAddNTE, but this could have side effects
        // (i.e. setting g_ValidAddr, etc.).
        //

        NetTableEntry *CurrNTE;
        NetTableEntry *PrevNTE;

        CTEGetLock(&RouteTableLock.Lock, &TableHandle);

        //
        // First, remove the NTE from the table.
        //

        PrevNTE = STRUCT_OF(NetTableEntry, &NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)], nte_next);

        for (CurrNTE = NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)];
             CurrNTE != NULL;
             PrevNTE = CurrNTE, CurrNTE = CurrNTE->nte_next) {

            if (CurrNTE == NTE) {
                PrevNTE->nte_next = CurrNTE->nte_next;
                break;
            }
        }

        //
        // Now set the new address and add to new location.
        //

        NTE->nte_addr = net_long(IF->if_index);
        NTE->nte_flags |= NTE_VALID;
        NTE->nte_mask = 0xffffffff;

        NTE->nte_next = NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)];
        NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)] = NTE;

        CTEFreeLock(&RouteTableLock.Lock, TableHandle);

#if MILLEN
        AddChangeNotify(
            NTE->nte_addr,
            NTE->nte_mask,
            NTE->nte_pnpcontext,
            NTE->nte_context,
            &IF->if_configname,
            &IF->if_devname,
            TRUE,
            TRUE);
#else // MILLEN
        AddChangeNotify(NTE->nte_addr);
#endif // !MILLEN

        InitIGMPForNTE(NTE);
        if (IF->if_mediastatus) {
            IPNotifyClientsIPEvent(IF, IP_BIND_ADAPTER);
        } else {
            IPNotifyClientsIPEvent(IF, IP_MEDIA_DISCONNECT);
        }
        NotifyElistChange();
        CTEFreeMem(AddrList);
        DecrInitTimeInterfaces(IF);
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddInterface [SUCCESS]\n")));
        return IP_SUCCESS;
    }

    if (IF->if_flags & IF_FLAGS_NOIPADDR) {

        NTE->nte_flags |= NTE_VALID;
        NTE->nte_mask = 0xFFFFFFFF;
        NTE->nte_if = IF;

        NotifyAddrChange(NTE->nte_addr, NTE->nte_mask, NTE->nte_pnpcontext,
                         NTE->nte_context, &NTE->nte_addrhandle, &(IF->if_configname), &IF->if_devname, TRUE);

        InitIGMPForNTE(NTE);

        if (IF->if_mediastatus) {
            IPNotifyClientsIPEvent(IF, IP_BIND_ADAPTER);
        } else {
            IPNotifyClientsIPEvent(IF, IP_MEDIA_DISCONNECT);
        }
        CTEFreeMem(AddrList);
        // force elist creation for unnumbered if.
        NotifyElistChange();
        DecrInitTimeInterfaces(IF);
        DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddInterface [SUCCESS]\n")));
        return (IP_SUCCESS);
    }

#if MILLEN
    if (PrimaryNTE != NULL) {
        NotifyInterfaceChange(PrimaryNTE->nte_context, TRUE);
    }
#endif // MILLEN

    // Now walk through the NTEs we've added, and get addresses for them (or
    // tell clients about them). This code assumes that no one else has mucked
    // with the list while we're here.

    NTE = IF->if_nte;

    for (i = 0; i < NumAddr; i++, NTE = NTE->nte_ifnext) {

        // Possible that some of the addresses added earlier
        // may already be deleted as we released RouteTableLock.
        // Bail out if no more NTEs on ifnext link.

        if (NTE == NULL) {
            break;
        }

        NotifyAddrChange(NTE->nte_addr, NTE->nte_mask, NTE->nte_pnpcontext,
                         NTE->nte_context, &NTE->nte_addrhandle, &(IF->if_configname), &IF->if_devname, TRUE);

        if (!IP_ADDR_EQUAL(NTE->nte_addr, NULL_IP_ADDR)) {
            InitIGMPForNTE(NTE);
        }
    }

    IF->if_link = NULL;

    CTEFreeMem(AddrList);

    if (PrimaryNTE != NULL) {
        if (IF->if_mediastatus) {
            if (EnableDhcp && TempDHCP) {

                SetAddrControl *controlBlock;
                IP_STATUS ipstatus;
                uint numgws = 0;

                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                          "tcp:tempdhcp address %x %x\n", TempDHCPAddr, TempMask));

                controlBlock = CTEAllocMemN(sizeof(SetAddrControl), 'lICT');

                RtlZeroMemory(controlBlock, sizeof(SetAddrControl));

                if (controlBlock != NULL) {

                    ipstatus = IPSetNTEAddrEx(
                                              IF->if_nte->nte_context,
                                              net_long(TempDHCPAddr),
                                              net_long(TempMask),
                                              controlBlock,
                                              TempDhcpAddrDone,
                                              0
                                              );

                    if (ipstatus != IP_PENDING) {
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                   "tcp:setip for tempdhcp returned success!!\n"));
                        TempDhcpAddrDone(controlBlock, ipstatus);
                    }
                    NTE = IF->if_nte;

                    while ((numgws < MAX_DEFAULT_GWS) && TempGWAddr[numgws]) {
                        TempGWAddr[numgws] = net_long(TempGWAddr[numgws]);

                        if (IP_ADDR_EQUAL(TempGWAddr[numgws], NTE->nte_addr)) {
                            AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                                     IPADDR_LOCAL, NTE->nte_if, NTE->nte_mss,
                                     IF->if_metric,
                                     IRE_PROTO_NETMGMT, ATYPE_OVERRIDE, 0, 0);
                        } else {
                            AddRoute(NULL_IP_ADDR, DEFAULT_MASK,
                                     TempGWAddr[numgws], NTE->nte_if, NTE->nte_mss,
                                     IF->if_metric,
                                     IRE_PROTO_NETMGMT, ATYPE_OVERRIDE, 0, 0);
                        }

                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                   "Plumbed deg gw for %x\n", TempGWAddr[numgws]));
                        numgws++;
                    }

                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                               "tcp:setip for tempdhcp returned pending\n"));
                    return IP_SUCCESS;

                }
            }
            IPNotifyClientsIPEvent(IF, IP_BIND_ADAPTER);

        } else {
            //mark any NTE that is statically added as disconnected
            uint i;
            CTELockHandle Handle;
            for (i = 0; i < NET_TABLE_SIZE; i++) {
                NetTableEntry *NetTableList = NewNetTableList[i];
                for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {

                    if ((NTE->nte_flags & NTE_VALID) && (NTE->nte_if == IF) &&
                        (NTE->nte_flags & ~NTE_DYNAMIC) &&
                        (NTE->nte_flags & NTE_ACTIVE)) {

                        CTEGetLock(&RouteTableLock.Lock, &Handle);

                        ASSERT(NTE != LoopNTE);

                        NTE->nte_flags |= NTE_DISCONNECTED;

                        // while setting the ip address to NULL, we just mark the NTE as INVALID
                        // we don't actually move the hashes
                        if (IPpSetNTEAddr(NTE, NULL_IP_ADDR, NULL_IP_ADDR, &Handle, NULL, NULL) != IP_SUCCESS) {
                            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_ERROR_LEVEL,
                                      "IAI:Failed to set null address on nte %x if %x\n",
                                       NTE, IF));
                        }
                        //Ippsetnteaddr frees the  routetable lock

                    }
                }
            }

        }
    }

    if (!EnableDhcp) {

        // for static address interface we are done with initialization already.

        DecrInitTimeInterfaces(IF);

    } else if (!IF->if_mediastatus) {

        // if media is disconnected, terminate initialization right away,
        // unless this goes to a wireless medium in which case we wait for
        // ZeroConf to tell us whether it can associate with an AP.

        if (!IF->if_InitInProgress || IsRunningOnPersonal() ||
            !IsWlanInterface(IF)) {

            DecrInitTimeInterfaces(IF);

        } else {

            // Start a timer on this interface so we don't wait forever.

#pragma warning(push)
#pragma warning(disable:4305) // truncation from "int" to "ushort"
            IF->if_wlantimer = WLAN_DEADMAN_TIMEOUT / IP_ROUTE_TIMEOUT;
#pragma warning(pop)
        }
    }


    DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddInterface [SUCCESS]\n")));
    return IP_SUCCESS;

  failure:

    // Need to cleanup the NTEs and IF on failure.
    if (PrimaryNTE) {
        (*(IF->if_close)) (IF->if_lcontext);
    }

    if (IF) {
        NetTableEntry *pDelNte, *pNextNte;

        pDelNte = IF->if_nte;
        while (IF->if_ntecount) {
            CTEGetLock(&RouteTableLock.Lock, &TableHandle);
            if (pDelNte == NULL) { // Sanity check!
                ASSERT(IF->if_ntecount == 0);
                CTEFreeLock(&RouteTableLock.Lock, TableHandle);
                break;
            }

            //
            // Grab the next NTE while we still hold the RouteTableLock.
            // NOTE: IPDelNTE frees the RouteTableLock.
            //
            pNextNte = pDelNte->nte_ifnext;

            CTEInitBlockStrucEx(&pDelNte->nte_timerblock);
            pDelNte->nte_deleting = 1;
            IPDelNTE(pDelNte, &TableHandle);
            pDelNte->nte_flags |= NTE_IF_DELETING;
            pDelNte->nte_deleting = 0; // The NTE can now be reused.

            pDelNte = pNextNte;
        }

        // Need to delete the broadcast route if it corresponds to this interface.
        DeleteRoute(IP_LOCAL_BCST, HOST_MASK, IPADDR_LOCAL, IF, 0);
        DeleteRoute(IP_ZERO_BCST, HOST_MASK, IPADDR_LOCAL, IF, 0);
    }
    if (IfNameBuf) {
        CTEFreeMem(IfNameBuf);
    }
    CloseIFConfig(Handle);

    if (AddrList != NULL)
        CTEFreeMem(AddrList);

    DecrInitTimeInterfaces(IF);

    if (IF)
        CTEFreeMem(IF);

    DEBUGMSG(DBG_TRACE && DBG_PNP, (DTEXT("-IPAddInterface [GENERAL_FAILURE]\n")));
    return IP_GENERAL_FAILURE;
}

//*     IPDelNTE - Delete an active NTE
//
//      Called to delete an active NTE from the system. The RouteTableLock
//  must be acquired before calling this routine. It will be freed upon
//  return.
//
//      Input:  NTE               - A pointer to the network entry to delete.
//          RouteTableHandle  - A pointer to the lock handle for the
//                                  route table lock, which the caller has
//                                  acquired.
//
//      Returns: Nothing
//
void
IPDelNTE(NetTableEntry * NTE, CTELockHandle * RouteTableHandle)
{
    Interface *IF = NTE->nte_if;
    ReassemblyHeader *RH, *RHNext;
    EchoControl *EC, *ECNext;
    EchoRtn Rtn;
    CTELockHandle Handle;
    NDIS_HANDLE ConfigHandle;
    ushort savedContext;
    IPAddr newAddr;
    NetTableEntry *PrevNTE;

    savedContext = NTE->nte_context;
    NTE->nte_context = INVALID_NTE_CONTEXT;

    if (NTE->nte_flags & NTE_VALID) {
        (void)IPpSetNTEAddr(NTE, NULL_IP_ADDR, NULL_IP_ADDR, RouteTableHandle, NULL, NULL);

    } else {
        CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);
        NotifyAddrChange(NULL_IP_ADDR, NULL_IP_ADDR,
                         NTE->nte_pnpcontext, savedContext,
                         &NTE->nte_addrhandle, NULL, &IF->if_devname, FALSE);
    }

    //* Try to get the network configuration information.
    if (OpenIFConfig(&(IF->if_configname), &ConfigHandle)) {
        IPDelNTEContextList(ConfigHandle, savedContext);
        CloseIFConfig(ConfigHandle);
    }


    CTEGetLock(&RouteTableLock.Lock, RouteTableHandle);

    RtlClearBits(&g_NTECtxtMap,
                     savedContext,
                     1);

    if (RefPtrValid(&DHCPRefPtr)) {
        if (AcquireRefPtr(&DHCPRefPtr) == NTE) {
            ReleaseRefPtr(&DHCPRefPtr);
            ClearRefPtr(&DHCPRefPtr, RouteTableHandle);
        } else {
            ReleaseRefPtr(&DHCPRefPtr);
        }
    }

    // if dhcp was working on this, get rid of the flag.
    // actually, the following line setting takes care of above...

    if (NTE->nte_addr != NULL_IP_ADDR) {
        NetTableEntry *CurrNTE, *PrevNTE;

        // Move the NTE to proper hash now that address has changed

        NetTableEntry *NetTableList = NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)];

        PrevNTE = STRUCT_OF(NetTableEntry, &NewNetTableList[NET_TABLE_HASH(NTE->nte_addr)], nte_next);
        for (CurrNTE = NetTableList; CurrNTE != NULL; PrevNTE = CurrNTE, CurrNTE = CurrNTE->nte_next) {
            if (CurrNTE == NTE) {
                // found the matching NTE
                ASSERT(CurrNTE->nte_context == NTE->nte_context);
                // remove it from this particular hash
                PrevNTE->nte_next = CurrNTE->nte_next;
                break;
            }
        }

        ASSERT(CurrNTE != NULL);
        // Add the NTE in the proper hash
        newAddr = NULL_IP_ADDR;
        NTE->nte_next = NewNetTableList[NET_TABLE_HASH(newAddr)];
        NewNetTableList[NET_TABLE_HASH(newAddr)] = NTE;
    }
    NumActiveNTE--;

    NTE->nte_addr = NULL_IP_ADDR;

    CTEFreeLock(&RouteTableLock.Lock, *RouteTableHandle);

    if ((NTE->nte_flags & NTE_TIMER_STARTED) &&
        !CTEStopTimer(&NTE->nte_timer)) {
        (VOID) CTEBlock(&NTE->nte_timerblock);
        KeClearEvent(&NTE->nte_timerblock.cbs_event);
    }

    NTE->nte_flags = 0;

    CTEGetLock(&NTE->nte_lock, &Handle);

    if (NTE->nte_igmpcount > 0) {
        // free the igmplist
        CTEFreeMem(NTE->nte_igmplist);
        NTE->nte_igmplist = NULL;
        NTE->nte_igmpcount = 0;
    }

    RH = NTE->nte_ralist;
    NTE->nte_ralist = NULL;
    EC = NTE->nte_echolist;
    NTE->nte_echolist = NULL;

    CTEFreeLock(&NTE->nte_lock, Handle);

    // Free any reassembly resources.
    while (RH != NULL) {
        RHNext = RH->rh_next;
        FreeRH(RH);
        RH = RHNext;
    }

    // Now free any pending echo requests.
    while (EC != NULL) {
        ECNext = EC->ec_next;
        Rtn = (EchoRtn) EC->ec_rtn;
        (*Rtn) (EC, IP_ADDR_DELETED, NULL, 0, NULL);
        EC = ECNext;
    }

    CTEGetLock(&(IF->if_lock), &Handle);


    // Remove this nte from nte_ifnext chain

    PrevNTE = IF->if_nte;

    // Skip checking for nte_ifnext is this is the
    // first NTE.

    if (PrevNTE != NTE) {

        while (PrevNTE->nte_ifnext != NULL) {
            if (PrevNTE->nte_ifnext == NTE) {
                PrevNTE->nte_ifnext = NTE->nte_ifnext;
                break;
            }
            PrevNTE = PrevNTE->nte_ifnext;
        }
    }


    CTEFreeLock(&(IF->if_lock), Handle);

    return;
}

//*     IPDeleteDynamicNTE - Deletes a "dynamic" NTE.
//
//      Called to delete a network entry which was dynamically created on an
//  existing interface.
//
//      Input:  NTEContext   - The context value identifying the NTE to delete.
//
//      Returns: Nonzero if the operation succeeded. Zero if it failed.
//
IP_STATUS
IPDeleteDynamicNTE(ushort NTEContext)
{
    NetTableEntry *NTE;
    CTELockHandle Handle;
    ulong AddToDel;
    uint i;

    // Check context validity.
    if (NTEContext == 0 || NTEContext == INVALID_NTE_CONTEXT) {
        return (IP_DEVICE_DOES_NOT_EXIST);
    }
    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {

            if ((NTE->nte_context == NTEContext) &&
                (NTE->nte_flags & NTE_ACTIVE)
                ) {
                //ASSERT(NTE != LoopNTE);
                //ASSERT(!(NTE->nte_flags & NTE_PRIMARY));
                if ((NTE == LoopNTE) || (NTE->nte_flags & NTE_PRIMARY)) {
                    CTEFreeLock(&RouteTableLock.Lock, Handle);
                    return (IP_GENERAL_FAILURE);
                }
                AddToDel = NTE->nte_addr;

                CTEInitBlockStrucEx(&NTE->nte_timerblock);

                NTE->nte_deleting = 1;
                IPDelNTE(NTE, &Handle);
                NTE->nte_deleting = 0;
                //
                // Route table lock was freed by IPDelNTE
                //

                return (IP_SUCCESS);
            }
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return (IP_DEVICE_DOES_NOT_EXIST);

}

#if MILLEN
void
AddChangeNotify(
    IPAddr Addr,
    IPMask Mask,
    void *Context,
    ushort IPContext,
    PNDIS_STRING ConfigName,
    PNDIS_STRING IFName,
    uint Added,
    uint UniAddr)
{
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp;
    PLIST_ENTRY             pEntry;
    CTELockHandle           Handle;
    PIP_ADDCHANGE_NOTIFY    pNotify;
    LIST_ENTRY              NotifyList;

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("+AddChangeNotify(%x, %x, %x, %x, %x, %x, %x, %x)\n"),
         Addr, Mask, Context, IPContext,
         ConfigName, IFName, Added, UniAddr));

    InitializeListHead(&NotifyList);

    //
    // Remove all items from the list and put on our temporary list with
    // the lock held (ensures that cancel can not occur).
    //

    CTEGetLock(&AddChangeLock, &Handle);

    if (!IsListEmpty(&AddChangeNotifyQueue)) {
        NotifyList.Flink = AddChangeNotifyQueue.Flink;
        AddChangeNotifyQueue.Flink->Blink = &NotifyList;

        NotifyList.Blink = AddChangeNotifyQueue.Blink;
        AddChangeNotifyQueue.Blink->Flink = &NotifyList;

        InitializeListHead(&AddChangeNotifyQueue);
    }

    CTEFreeLock(&AddChangeLock, Handle);

    //
    // Now complete all IRPs on temporary list. Output buffer size was already
    // verified.
    //

    while (IsListEmpty(&NotifyList) == FALSE) {

        pEntry = RemoveHeadList(&NotifyList);
        pIrp   = (PIRP) CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);

        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

        DEBUGMSG(DBG_INFO && DBG_NOTIFY,
            (DTEXT("NotifyInterfaceChange: Completing IRP %x\n"), pIrp));

        if (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(IP_ADDCHANGE_NOTIFY)) {

            pNotify = pIrp->AssociatedIrp.SystemBuffer;

            pNotify->Addr       = Addr;
            pNotify->Mask       = Mask;
            pNotify->pContext   = Context;
            pNotify->IPContext  = IPContext;
            pNotify->AddrAdded  = Added;
            pNotify->UniAddr    = UniAddr;

            // Maximum length verification.
            ASSERT((ULONG)pNotify->ConfigName.MaximumLength + FIELD_OFFSET(IP_ADDCHANGE_NOTIFY, ConfigName) <=
                   pIrpSp->Parameters.DeviceIoControl.OutputBufferLength);

            //
            // Copy Config name if it exists.
            //

            if (ConfigName) {
                // Copy as much as we can.
                RtlCopyUnicodeString(&pNotify->ConfigName, ConfigName);

                pIrp->IoStatus.Information = MAX(FIELD_OFFSET(IP_ADDCHANGE_NOTIFY, NameData) +
                                                          pNotify->ConfigName.Length,
                                                 sizeof(IP_ADDCHANGE_NOTIFY));

                // If we didn't copy it all, return BUFFER_OVERFLOW.
                if (ConfigName->Length > pNotify->ConfigName.MaximumLength) {
                    pIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
                } else {
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                }
            } else {

                pNotify->ConfigName.Length = 0;
                pIrp->IoStatus.Information = sizeof(IP_ADDCHANGE_NOTIFY);
                pIrp->IoStatus.Status = STATUS_SUCCESS;
            }

        } else {
            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status      = STATUS_SUCCESS;
        }

        IoSetCancelRoutine(pIrp, NULL);
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY, (DTEXT("-AddChangeNotify\n")));
}
#else // MILLEN
void
AddChangeNotify(ulong Add)
{
    IPNotifyOutput NotifyOutput = {0};
    NotifyOutput.ino_addr = Add;
    NotifyOutput.ino_mask = HOST_MASK;
    ChangeNotify(&NotifyOutput, &AddChangeNotifyQueue, &AddChangeLock);
}
#endif // !MILLEN

// AddChangeNotifyCancel -
//
//
//  Returns:  cancels pending request
//
void
AddChangeNotifyCancel(PDEVICE_OBJECT DeviceObject, PIRP pIrp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    CancelNotify(pIrp, &AddChangeNotifyQueue, &AddChangeLock);
}

#if MILLEN

typedef struct _IF_CHANGE_NOTIFY_EVENT {
    IP_IFCHANGE_NOTIFY Notify;
    CTEEvent           Event;
} IF_CHANGE_NOTIFY_EVENT, *PIF_CHANGE_NOTIFY_EVENT;

void
NotifyInterfaceChangeAsync(
    CTEEvent *pCteEvent,
    PVOID     pContext
    )
{
    PIRP                pIrp;
    PLIST_ENTRY         pEntry;
    CTELockHandle       Handle;
    PIP_IFCHANGE_NOTIFY pNotify;
    LIST_ENTRY          NotifyList;

    PIF_CHANGE_NOTIFY_EVENT pEvent      = (PIF_CHANGE_NOTIFY_EVENT) pContext;
    USHORT                  IPContext   = pEvent->Notify.Context;
    UINT                    Added       = pEvent->Notify.IfAdded;

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("+NotifyInterfaceChangeAsync(%x, %x) Context %x Added %x\n"),
         pCteEvent, pContext, IPContext, Added));

    InitializeListHead(&NotifyList);

    //
    // Remove all items from the list and put on our temporary list with
    // the lock held (ensures that cancel can not occur).
    //

    CTEGetLock(&IfChangeLock, &Handle);

    if (!IsListEmpty(&IfChangeNotifyQueue)) {
        NotifyList.Flink = IfChangeNotifyQueue.Flink;
        IfChangeNotifyQueue.Flink->Blink = &NotifyList;

        NotifyList.Blink = IfChangeNotifyQueue.Blink;
        IfChangeNotifyQueue.Blink->Flink = &NotifyList;

        InitializeListHead(&IfChangeNotifyQueue);
    }

    CTEFreeLock(&IfChangeLock, Handle);

    //
    // Now complete all IRPs on temporary list. Output buffer size was already
    // verified.
    //

    while (IsListEmpty(&NotifyList) == FALSE) {

        pEntry = RemoveHeadList(&NotifyList);
        pIrp   = (PIRP) CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);

        DEBUGMSG(DBG_INFO && DBG_NOTIFY,
            (DTEXT("NotifyInterfaceChange: Completing IRP %x\n"), pIrp));

        pNotify                     = pIrp->AssociatedIrp.SystemBuffer;
        pNotify->Context            = IPContext;
        pNotify->IfAdded            = Added;
        pIrp->IoStatus.Information  = sizeof(IP_IFCHANGE_NOTIFY);
        pIrp->IoStatus.Status       = STATUS_SUCCESS;

        IoSetCancelRoutine(pIrp, NULL);
        IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
    }

    // Only delete pEvent if pCteEvent is NULL. Otherwise, we were called
    // directly from NotifyInterfaceChange instead of calling via CTE event.
    if (pCteEvent) {
        CTEFreeMem(pEvent);
    }

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY, (DTEXT("-NotifyInterfaceChangeAsync\n")));

    return;
}

void
NotifyInterfaceChange(
    ushort IPContext,
    uint Added
    )
{
    PIF_CHANGE_NOTIFY_EVENT pEvent;
    KIRQL                   Irql;

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY,
        (DTEXT("+NotifyInterfaceChange(%x, %x)\n"), IPContext, Added));

    Irql = KeGetCurrentIrql();

    if (Irql >= DISPATCH_LEVEL) {
        DEBUGMSG(DBG_INFO && DBG_NOTIFY,
            (DTEXT("NotifyInterfaceChange: Scheduling async event. Irql = %d\n"),
             Irql));

        pEvent = CTEAllocMemN(sizeof(IF_CHANGE_NOTIFY_EVENT), 'xiCT');

        if (pEvent != NULL) {
            CTEInitEvent(&pEvent->Event, NotifyInterfaceChangeAsync);
            pEvent->Notify.Context = IPContext;
            pEvent->Notify.IfAdded = Added;

            CTEScheduleDelayedEvent(&pEvent->Event, pEvent);
        }
    } else {
        IF_CHANGE_NOTIFY_EVENT Notify;

        Notify.Notify.Context = IPContext;
        Notify.Notify.IfAdded = Added;

        NotifyInterfaceChangeAsync(NULL, &Notify);
    }

    DEBUGMSG(DBG_TRACE && DBG_NOTIFY, (DTEXT("-NotifyInterfaceChange\n")));

    return;
}

#endif // MILLEN

NTSTATUS
GetInterfaceInfo(
                 IN PIRP Irp,
                 IN PIO_STACK_LOCATION IrpSp
                 )
/*++
Routine Description:

    gets the interface to index mapping info
    for all teh interface

Arguments:

    Irp          - Pointer to I/O request packet to cancel.
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    ulong NumAdapters, InfoBufferLen, i = 0;
    PIP_INTERFACE_INFO InterfaceInfo;
    KIRQL rtlIrql;
    Interface *Interface;

    //Let this be non pageable code.
    //extract the buffer information

    NumAdapters = NumIF - 1;
    InfoBufferLen = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    InterfaceInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Initialize the output buffer.
    //

    RtlZeroMemory(InterfaceInfo, InfoBufferLen);
    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

    if ((NumAdapters * sizeof(IP_ADAPTER_INDEX_MAP) + sizeof(ULONG)) <= InfoBufferLen) {

        InterfaceInfo->NumAdapters = NumAdapters;

        for (Interface = IFList; Interface != NULL; Interface = Interface->if_next) {

            if (Interface != &LoopInterface) {
                RtlCopyMemory(&InterfaceInfo->Adapter[i].Name,
                              Interface->if_devname.Buffer,
                              Interface->if_devname.Length);
                InterfaceInfo->Adapter[i].Name[Interface->if_devname.Length / 2] = 0;
                InterfaceInfo->Adapter[i].Index = Interface->if_index;
                i++;
            }
        }

        Irp->IoStatus.Information = NumAdapters * sizeof(IP_ADAPTER_INDEX_MAP) + sizeof(ULONG);

    } else {
        ntStatus = STATUS_BUFFER_OVERFLOW;
    }

    Irp->IoStatus.Status = ntStatus;

    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return ntStatus;
}

NTSTATUS
GetIgmpList(
            IN PIRP Irp,
            IN PIO_STACK_LOCATION IrpSp
            )
/*++
Routine Description:

    gets the list of groups joined on NTE (given IP address)

Arguments:

    Irp          - Pointer to I/O request packet to cancel.
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG OutputBufferLen, i = 0;
    KIRQL rtlIrql;
    IPAddr *buf, Addr, *IgmpInfoBuf;
    NetTableEntry *NTE;
    NetTableEntry *NetTableList;

    OutputBufferLen = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    buf = Irp->AssociatedIrp.SystemBuffer;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(IPAddr))) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }
    Addr = *buf;

    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

    NetTableList = NewNetTableList[NET_TABLE_HASH(Addr)];
    for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
        if ((NTE->nte_flags & NTE_VALID) && (IP_ADDR_EQUAL(NTE->nte_addr, Addr))) {
            break;
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);


    if (NTE) {

      CTEGetLock(&NTE->nte_lock, &rtlIrql);
      //recheck the validity of NTE.
      //note that nte itself is not freed. So, safe to release routetablelock
      //and to reacquire nte_lock

      if ((NTE->nte_flags & NTE_VALID) && (IP_ADDR_EQUAL(NTE->nte_addr, Addr))) {



          // found NTE with given IP address
          if (OutputBufferLen < sizeof(ULONG)) {
              // Not even enough space to hold bytes needed
              Irp->IoStatus.Information = 0;
              ntStatus = STATUS_BUFFER_TOO_SMALL;
          } else if (OutputBufferLen == sizeof(ULONG)) {
              // Caller is asking for how much space is needed.
              // We'll say we need slightly more than we actually do,
              // for two reasons:
              //    1) this ensures that a subsequent call doesn't
              //       hit this case again, since it'll be > sizeof(ULONG)
              //    2) a group or two could be joined in between calls, so
              //       we'll be nice and make it more probable they'll get
              //       all of them in the next call.
              ULONG *SizePtr = Irp->AssociatedIrp.SystemBuffer;

              *SizePtr = (NTE->nte_igmpcount + 2) * sizeof(IPAddr);
              Irp->IoStatus.Information = sizeof(ULONG);

              ntStatus = STATUS_BUFFER_OVERFLOW;
          } else {
              // Caller is asking for all the groups.
              // We'll fit as many as we can in the space we have.

              IGMPAddr **HashPtr = NTE->nte_igmplist;
              IGMPAddr *AddrPtr;
              uint j = 0;
              uint max = OutputBufferLen / sizeof(IPAddr);

              IgmpInfoBuf = Irp->AssociatedIrp.SystemBuffer;

              if (HashPtr) {
                  for (i = 0; i < IGMP_TABLE_SIZE; i++) {
                      for (AddrPtr = HashPtr[i]; AddrPtr != NULL; AddrPtr = AddrPtr->iga_next) {
                          if (j >= max) {
                              ntStatus = STATUS_BUFFER_OVERFLOW;
                              goto done;
                          }
                          IgmpInfoBuf[j++] = AddrPtr->iga_addr;
                      }
                  }
              }

done:
              ASSERT(j <= NTE->nte_igmpcount);
              Irp->IoStatus.Information = j * sizeof(IPAddr);
          }
          ASSERT(Irp->IoStatus.Information <= OutputBufferLen);
      }
      CTEFreeLock(&NTE->nte_lock, rtlIrql);

    } else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"GetIgmpList exit status %x\n", ntStatus));



    Irp->IoStatus.Status = ntStatus;


    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return ntStatus;

}

NTSTATUS
SetRoute(
         IPRouteEntry * IRE,
         UINT           Flags
         )
/*++
Routine Description:

    sets a route pointed by IRE structure

Arguments:

    IRE           - Pointer to route structure
    Flags         - selects optional semantics for the operation

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{
    NetTableEntry *OutNTE, *LocalNTE, *TempNTE;
    IPAddr FirstHop, Dest, NextHop;
    uint MTU;
    Interface *OutIF;
    uint Status;
    uint i;
    CTELockHandle TableHandle;

    OutNTE = NULL;
    LocalNTE = NULL;

    Dest = IRE->ire_dest;
    NextHop = IRE->ire_nexthop;

    // Make sure that the nexthop is sensible. We don't allow nexthops
    // to be broadcast or invalid or loopback addresses.

    if (IP_LOOPBACK(NextHop) || CLASSD_ADDR(NextHop) || CLASSE_ADDR(NextHop))
        return STATUS_INVALID_PARAMETER;

    // Also make sure that the destination we're routing to is sensible.
    // Don't allow routes to be added to Class D or E or loopback
    // addresses.
    if (IP_LOOPBACK(Dest) || CLASSD_ADDR(Dest) || CLASSE_ADDR(Dest))
        return STATUS_INVALID_PARAMETER;

    if (IRE->ire_index == LoopIndex)
        return STATUS_INVALID_PARAMETER;

    if (IRE->ire_index != INVALID_IF_INDEX) {

        // First thing to do is to find the outgoing NTE for specified
        // interface, and also make sure that it matches the destination
        // if the destination is one of my addresses.

        for (i = 0; i < NET_TABLE_SIZE; i++) {
            NetTableEntry *NetTableList = NewNetTableList[i];
            for (TempNTE = NetTableList; TempNTE != NULL;
                 TempNTE = TempNTE->nte_next) {
                if ((OutNTE == NULL) && (TempNTE->nte_flags & NTE_VALID) && (IRE->ire_index == TempNTE->nte_if->if_index))
                    OutNTE = TempNTE;
                if (!IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR) &&
                    IP_ADDR_EQUAL(NextHop, TempNTE->nte_addr) &&
                    (TempNTE->nte_flags & NTE_VALID))
                    LocalNTE = TempNTE;

                // Don't let a route be set through a broadcast address.
                if (IsBCastOnNTE(NextHop, TempNTE) != DEST_LOCAL)
                    return STATUS_INVALID_PARAMETER;

                // Don't let a route to a broadcast address be added or deleted.
                if (IsBCastOnNTE(Dest, TempNTE) != DEST_LOCAL)
                    return STATUS_INVALID_PARAMETER;
            }
        }

        // At this point OutNTE points to the outgoing NTE, and LocalNTE
        // points to the NTE for the local address, if this is a direct route.
        // Make sure they point to the same interface, and that the type is
        // reasonable.
        if (OutNTE == NULL)
            return STATUS_INVALID_PARAMETER;

        if (LocalNTE != NULL) {
            // He's routing straight out a local interface. The interface for
            // the local address must match the interface passed in, and the
            // type must be DIRECT (if we're adding) or INVALID (if we're
            // deleting).
            if (LocalNTE->nte_if->if_index != IRE->ire_index)
                return STATUS_INVALID_PARAMETER;

            if (IRE->ire_type != IRE_TYPE_DIRECT &&
                IRE->ire_type != IRE_TYPE_INVALID)
                return STATUS_INVALID_PARAMETER;
            OutNTE = LocalNTE;
        }
        // Figure out what the first hop should be. If he's routing straight
        // through a local interface, or the next hop is equal to the
        // destination, then the first hop is IPADDR_LOCAL. Otherwise it's the
        // address of the gateway.
        if ((LocalNTE != NULL) || IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR))
            FirstHop = IPADDR_LOCAL;
        else if (IP_ADDR_EQUAL(Dest, NextHop))
            FirstHop = IPADDR_LOCAL;
        else
            FirstHop = NextHop;

        MTU = OutNTE->nte_mss;

        // Take RouteTableLock
        CTEGetLock(&RouteTableLock.Lock, &TableHandle);
        if ((OutNTE->nte_flags & NTE_VALID) && OutNTE->nte_if->if_refcount) {

            // ref the IF
            OutIF = OutNTE->nte_if;

            if (IP_ADDR_EQUAL(NextHop, NULL_IP_ADDR)) {

                if (!(OutIF->if_flags & IF_FLAGS_P2P)) {

                    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

                    return STATUS_INVALID_PARAMETER;
                }
            }

            LOCKED_REFERENCE_IF(OutIF);
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
        } else {
            CTEFreeLock(&RouteTableLock.Lock, TableHandle);
            return STATUS_INVALID_PARAMETER;
        }


    } else {
        OutIF = (Interface *) & DummyInterface;
        MTU = DummyInterface.ri_if.if_mtu - sizeof(IPHeader);
        if (IP_ADDR_EQUAL(Dest, NextHop))
            FirstHop = IPADDR_LOCAL;
        else
            FirstHop = NextHop;
    }

    // We've done the validation. See if he's adding or deleting a route.
    if (IRE->ire_type != IRE_TYPE_INVALID) {
        // He's adding a route.
        Status = AddRoute(Dest, IRE->ire_mask, FirstHop, OutIF,
                          MTU, IRE->ire_metric1, IRE->ire_proto,
                          ATYPE_OVERRIDE, IRE->ire_context, Flags);

    } else {
        // He's deleting a route.
        Status = DeleteRoute(Dest, IRE->ire_mask, FirstHop, OutIF, Flags);
    }

    if (IRE->ire_index != INVALID_IF_INDEX) {
        ASSERT(OutIF != (Interface *) & DummyInterface);
        DerefIF(OutIF);
    }
    if (Status == IP_SUCCESS)
        return STATUS_SUCCESS;
    else if (Status == IP_NO_RESOURCES)
        return STATUS_INSUFFICIENT_RESOURCES;
    else
        return STATUS_INVALID_PARAMETER;
}

NTSTATUS
DispatchIPSetBlockofRoutes(
                           IN PIRP Irp,
                           IN PIO_STACK_LOCATION IrpSp
                           )
/*++
Routine Description:

    sets a block of routes

Arguments:

    Irp          - Pointer to I/O request packet to cancel.
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{

    IPRouteBlock *buf;
    uint numofroutes;
    uint OutputBufferLen;
    ULONG *statusbuf;
    uint ntstatus, i;

    DEBUGMSG(DBG_TRACE && DBG_IP,
        (DTEXT("+DispatchIPSetBlockofRoutes(%x, %x)\n"), Irp, IrpSp));

    // set at least 1 route
    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(IPRouteBlock))) {
        DEBUGMSG(DBG_ERROR && DBG_IP,
            (DTEXT("DispatchIPsetBlockofRoutes: Invalid input buffer length\n")));
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }
    buf = (IPRouteBlock *) Irp->AssociatedIrp.SystemBuffer;

    numofroutes = buf->numofroutes;

    if ((numofroutes == 0) ||  (numofroutes > MAXLONG / sizeof(IPRouteEntry))) {
        DEBUGMSG(DBG_ERROR && DBG_IP,
            (DTEXT("DispatchIPsetBlockofRoutes: Invalid numofroutes\n")));
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }
    // check whether the input buffer is big enough to contain n routes
    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < (numofroutes * sizeof(IPRouteEntry) + sizeof(ulong)))) {
        DEBUGMSG(DBG_ERROR && DBG_IP,
            (DTEXT("DispatchIPsetBlockofRoutes: Invalid input buffer for numofroutes\n")));
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }
    OutputBufferLen = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (OutputBufferLen < (numofroutes * sizeof(uint))) {
        DEBUGMSG(DBG_ERROR && DBG_IP,
            (DTEXT("DispatchIPsetBlockofRoutes: Invalid output buffer for numofroutes\n")));
        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = numofroutes * sizeof(ulong);
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return STATUS_BUFFER_TOO_SMALL;
    }


    statusbuf = CTEAllocMemN(numofroutes * sizeof(ulong), 'iPCT');

    if (statusbuf == NULL) {
        DEBUGMSG(DBG_ERROR && DBG_IP,
            (DTEXT("DispatchIPsetBlockofRoutes: failed to allocate statusbuf\n")));
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    for (i = 0; i < numofroutes; i++) {
        // set the routes

        ntstatus = SetRoute(&(buf->route[i]), RT_EXCLUDE_LOCAL);

        statusbuf[i] = ntstatus;
    }

    RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, statusbuf, numofroutes * sizeof(uint));

    CTEFreeMem(statusbuf);

    Irp->IoStatus.Information = numofroutes * sizeof(ulong);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    DEBUGMSG(DBG_TRACE && DBG_IP,
        (DTEXT("-DispatchIPSetBlockofRoutes [%x]\n"), STATUS_SUCCESS));

    return STATUS_SUCCESS;
}

NTSTATUS
DispatchIPSetRouteWithRef(
                          IN PIRP Irp,
                          IN PIO_STACK_LOCATION IrpSp
                          )
/*++
Routine Description:

    sets a route with ref-cnt

Arguments:

    Irp          - Pointer to I/O request packet to cancel.
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{

    IPRouteEntry *buf;
    uint ntstatus;

    DEBUGMSG(DBG_TRACE && DBG_IP,
        (DTEXT("+DispatchIPsetRouteWithRef(%x, %x)\n"), Irp, IrpSp));

    // set at least 1 route
    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(IPRouteEntry))) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }
    buf = Irp->AssociatedIrp.SystemBuffer;

    // set the route with ref-cnt

    ntstatus = SetRoute(buf, RT_REFCOUNT|RT_EXCLUDE_LOCAL);

    Irp->IoStatus.Status = ntstatus;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    DEBUGMSG(DBG_TRACE && DBG_IP,
        (DTEXT("-DispatchIPSetRouteWithRef [%x]\n"), ntstatus));

    return ntstatus;
}

NTSTATUS
SetMultihopRoute(IPMultihopRouteEntry * Imre, uint Flags)
{
    ulong numnexthops, i, j;
    ulong oldType;
    ulong nexthop;
    ulong ifIndex;
    ROUTE_CONTEXT context;
    BOOLEAN fAddRoute;
    NTSTATUS ntstatus;

    // Add/Delete route with actual information - using the primary nexthop

    fAddRoute = (BOOLEAN) (Imre->imre_routeinfo.ire_type != IRE_TYPE_INVALID);

    ntstatus = SetRoute(&Imre->imre_routeinfo, Flags);
    if (ntstatus != STATUS_SUCCESS) {
        if (fAddRoute) {
            // We failed the first add - return error
            return ntstatus;
        }
    }
    numnexthops = Imre->imre_numnexthops;

    if (numnexthops > 1) {
        // Copy out some information to be restored later
        oldType = Imre->imre_routeinfo.ire_type;
        nexthop = Imre->imre_routeinfo.ire_nexthop;
        ifIndex = Imre->imre_routeinfo.ire_index;
        context = Imre->imre_routeinfo.ire_context;

        for (i = 0; i < numnexthops - 1; i++) {
            // Update information with this nexthop

            Imre->imre_routeinfo.ire_type = Imre->imre_morenexthops[i].ine_iretype;
            Imre->imre_routeinfo.ire_nexthop = Imre->imre_morenexthops[i].ine_nexthop;
            Imre->imre_routeinfo.ire_index = Imre->imre_morenexthops[i].ine_ifindex;
            Imre->imre_routeinfo.ire_context = Imre->imre_morenexthops[i].ine_context;

            // Add/Delete route with nexthop information

            ntstatus = SetRoute(&(Imre->imre_routeinfo), Flags);
            if (ntstatus != STATUS_SUCCESS) {
                if (fAddRoute) {
                    // One of the route additions failed
                    // Clean up by removing routes added

                    Imre->imre_routeinfo.ire_nexthop = nexthop;
                    Imre->imre_routeinfo.ire_index = ifIndex;
                    Imre->imre_routeinfo.ire_context = context;
                    Imre->imre_routeinfo.ire_type = IRE_TYPE_INVALID;

                    for (j = 0; j < i; j++) {
                        Imre->imre_morenexthops[j].ine_iretype = IRE_TYPE_INVALID;
                    }

                    Imre->imre_numnexthops = i;

                    SetMultihopRoute(Imre, Flags);

                    Imre->imre_numnexthops = numnexthops;

                    break;
                }
            }
        }

        // Restore information copied out little earlier
        Imre->imre_routeinfo.ire_type = oldType;
        Imre->imre_routeinfo.ire_nexthop = nexthop;
        Imre->imre_routeinfo.ire_index = ifIndex;
        Imre->imre_routeinfo.ire_context = context;
    }
    return fAddRoute ? ntstatus : STATUS_SUCCESS;
}

NTSTATUS
DispatchIPSetMultihopRoute(
                           IN PIRP Irp,
                           IN PIO_STACK_LOCATION IrpSp
                           )
/*++
Routine Description:

    Sets (Adds, Updates, or deletes) a multihop route in
    the stack. Each multihop route is added as a set of
    routes - each route with one hop in the list. This is
    due to the inability of the stack to act of multihop
    routes.

Arguments:

    Irp          - Pointer to I/O request packet to cancel.
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{
    IPMultihopRouteEntry    *buf;
    uint                    numnexthops;
    uint                    inputLen;
    NTSTATUS                ntStatus;

    //
    // Increment the count saying we have been here
    //

    InterlockedIncrement(&MultihopSets);

    inputLen = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    ntStatus = STATUS_INVALID_PARAMETER;

    if (inputLen >= sizeof(IPMultihopRouteEntry)) {
        // we have a buffer that holds a route with atleast 1 nexthop

        buf = (IPMultihopRouteEntry *) Irp->AssociatedIrp.SystemBuffer;

        numnexthops = buf->imre_numnexthops;

        if (numnexthops != 0) {
            // check whether input buf is big enough for n nexthops

            if ((numnexthops <= MAXLONG / sizeof(IPMultihopRouteEntry)) &&
                (inputLen >= sizeof(IPRouteEntry) +
                 sizeof(ulong) +
                 sizeof(IPRouteNextHopEntry) * (numnexthops - 1))) {

                // If we are adding a new route, delete old routes
                if (buf->imre_routeinfo.ire_type != IRE_TYPE_INVALID &&
                    (buf->imre_flags & IMRE_FLAG_DELETE_DEST)) {
                    DeleteDest(buf->imre_routeinfo.ire_dest,
                               buf->imre_routeinfo.ire_mask);
                }
                ntStatus = SetMultihopRoute(buf, RT_NO_NOTIFY|RT_EXCLUDE_LOCAL);
            }
        } else {
            if (buf->imre_routeinfo.ire_type == IRE_TYPE_INVALID) {
                IP_STATUS   ipStatus;
                // We need to delete all routes to this destination

                ipStatus = DeleteDest(buf->imre_routeinfo.ire_dest,
                                      buf->imre_routeinfo.ire_mask);

                if (ipStatus == IP_BAD_ROUTE) {
                    ipStatus = IP_SUCCESS;
                }
                ntStatus = IPStatusToNTStatus(ipStatus);
            }
        }
    }
    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    //
    // Decrement the count saying we have been here
    //

    InterlockedDecrement(&MultihopSets);

    return ntStatus;
}

NTSTATUS
GetBestInterfaceId(
                   IN PIRP Irp,
                   IN PIO_STACK_LOCATION IrpSp
                   )
/*++
Routine Description:

    gets the interface which might be chosen for a given dest address

Arguments:

    Irp          - Pointer to I/O request packet to cancel.
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG InfoBufferLen;
    IPAddr Address;

    PULONG buf;

    KIRQL rtlIrql;

    RouteTableEntry *rte;

    //Let this be non pageable code.
    //extract the buffer information

    InfoBufferLen = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    buf = Irp->AssociatedIrp.SystemBuffer;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) || (InfoBufferLen < sizeof(ULONG))) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }

    DEBUGMSG(DBG_INFO && DBG_IP && DBG_INTERFACE,
         (DTEXT("GetBestInterfaceId Buf %x, Len %d\n"), buf, InfoBufferLen));

    Address = *buf;

    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

    rte = LookupRTE(Address, NULL_IP_ADDR, HOST_ROUTE_PRI, FALSE);

    if (rte) {

        *buf = rte->rte_if->if_index;

        Irp->IoStatus.Information = sizeof(ULONG);

        ntStatus = Irp->IoStatus.Status = STATUS_SUCCESS;

    } else {
        ntStatus = Irp->IoStatus.Status = STATUS_NETWORK_UNREACHABLE;
    }

    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return ntStatus;
}

NTSTATUS
IPGetBestInterface(
                   IN IPAddr Address,
                   OUT PVOID * ppIF
                   )
/*++
Routine Description:

    Returns the interface which might be chosen for a given dest address

Arguments:

   Address  - the dest address to look for
   ppIF     - returns the IF ptr.

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL rtlIrql;
    RouteTableEntry *rte;

    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
    rte = LookupRTE(Address, NULL_IP_ADDR, HOST_ROUTE_PRI, FALSE);
    if (rte) {
        *ppIF = rte->rte_if;
        ntStatus = STATUS_SUCCESS;
    } else {
        ntStatus = STATUS_NETWORK_UNREACHABLE;
    }

    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

    return ntStatus;
}

NTSTATUS
IPGetBestInterfaceIndex(
                        IN IPAddr Address,
                        OUT PULONG pIndex,
                        OUT PULONG pMetric
                        )
/*++
Routine Description:

    Returns the interface indexwhich might be chosen for a given dest address

Arguments:

   Address  - the dest address to look for
   pIndex   - Pointer to hold interface index
   pMetric  - metric in RTE that pointe to this if

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL rtlIrql;
    RouteTableEntry *rte;

    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);
    rte = LookupRTE(Address, NULL_IP_ADDR, HOST_ROUTE_PRI, FALSE);
    if (rte && pMetric && pIndex) {
        *pIndex = rte->rte_if->if_index;
        *pMetric = rte->rte_metric;
        ntStatus = STATUS_SUCCESS;
    } else {
        ntStatus = STATUS_NETWORK_UNREACHABLE;
    }

    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);

    return ntStatus;
}

//*     IPGetNTEInfo - Retrieve information about a network entry.
//
//  Called to retrieve context information about a network entry.
//
//      Input:  NTEContext   - The context value which identifies the NTE to query.
//
//  Output: NTEInstance   - The instance number associated with the NTE.
//          Address       - The address assigned to the NTE.
//          SubnetMask    - The subnet mask assigned to the NTE.
//          NTEFlags      - The flag values associated with the NTE.
//
//      Returns: Nonzero if the operation succeeded. Zero if it failed.
//
uint
IPGetNTEInfo(ushort NTEContext, ulong * NTEInstance, IPAddr * Address,
             IPMask * SubnetMask, ushort * NTEFlags)
{
    NetTableEntry *NTE;
    CTELockHandle Handle;
    uint retval = FALSE;
    uint i;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];
        for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next) {
            if ((NTE->nte_context == NTEContext) &&
                (NTE->nte_flags & NTE_ACTIVE)
                ) {
                *NTEInstance = NTE->nte_instance;

                if (NTE->nte_flags & NTE_VALID) {
                    *Address = NTE->nte_addr;
                    *SubnetMask = NTE->nte_mask;
                } else {
                    *Address = NULL_IP_ADDR;
                    *SubnetMask = NULL_IP_ADDR;
                }

                *NTEFlags = NTE->nte_flags;
                retval = TRUE;
            }
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    return (retval);
}

//*     IPDelInterface  - Delete an interface.
//
//      Called when we need to delete an interface that's gone away. We'll walk
//      the NTE list, looking for NTEs that are on the interface that's going
//      away. For each of those, we'll invalidate the NTE, delete routes on it,
//      and notify the upper layers that it's gone. When that's done we'll pull
//      the interface out of the list and free the memory.
//
//      Note that this code probably isn't MP safe. We'll need to fix that for
//      the port to NT.
//
//      Input:  Context                         - Pointer to primary NTE on the interface.
//
//      Returns: Nothing.
//
void
__stdcall
IPDelInterface(void *Context, BOOLEAN DeleteIndex)
{
    NetTableEntry *NTE = (NetTableEntry *) Context;
    NetTableEntry *FoundNTE = NULL;
    Interface *IF, *PrevIF;
    CTELockHandle Handle;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER Buffer;
    uchar *TDBuffer;
    CTEBlockStruc Block;
    CTEBlockTracker Tracker;
    uint i;
    CTELockHandle TableHandle;
#if MILLEN
    ushort NTEContext;
#endif // MILLEN


    IF = NTE->nte_if;

    // inform IPSec that this interface is going away
    if (IPSecNdisStatusPtr) {
        (*IPSecNdisStatusPtr)(IF, (UINT) NDIS_STATUS_NETWORK_UNREACHABLE);
    }

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    //first check if this IF is on damping list and remove.

    IF->if_damptimer = 0;
    PrevIF = STRUCT_OF(Interface, &DampingIFList, if_dampnext);

    while (PrevIF->if_dampnext != IF && PrevIF->if_dampnext != NULL)
        PrevIF = PrevIF->if_dampnext;

    if (PrevIF->if_dampnext != NULL) {
        PrevIF->if_dampnext = IF->if_dampnext;
        IF->if_dampnext = NULL;
    }
    // check whether delete called twice
    if (IF->if_flags & IF_FLAGS_DELETING)
        ASSERT(FALSE);

    IF->if_flags |= IF_FLAGS_DELETING;

    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NetTableEntry *NetTableList = NewNetTableList[i];

        NTE = NetTableList;
        while (NTE != NULL) {
            NetTableEntry *NextNTE = NTE->nte_next;

            if ((NTE->nte_if == IF) &&
                (NTE->nte_context != INVALID_NTE_CONTEXT)) {

                if (FoundNTE == NULL) {
#if MILLEN
                    // Need to remember the NTE context to give for if change notification.
                    // DHCP really needs this.
                    NTEContext = NTE->nte_context;
#endif // MILLEN
                    FoundNTE = NTE;
                }
                CTEInitBlockStrucEx(&NTE->nte_timerblock);

                // This guy is on the interface, and needs to be deleted.
                NTE->nte_deleting = 1;
                IPDelNTE(NTE, &Handle);
                NTE->nte_deleting = 0;
                CTEGetLock(&RouteTableLock.Lock, &Handle);
                NTE->nte_flags |= NTE_IF_DELETING;
            }
            NTE = NextNTE;
        }
    }

    CTEFreeLock(&RouteTableLock.Lock, Handle);

    CheckSetAddrRequestOnInterface(IF);

    IF->if_index = IF->if_index & ~IF_INDEX_MASK;

    if (FoundNTE != NULL) {
#if MILLEN
        NotifyInterfaceChange(NTEContext, FALSE);
#endif // MILLEN
        IPNotifyClientsIPEvent(IF, IP_UNBIND_ADAPTER);
    }
    // Cleanup routes are still pointing to this interface
    // This is a catch all for various timing windows which
    // allows adding a route when the interface is about to
    // be deleted.
    RTWalk(DeleteAllRTEOnIF, IF, NULL);

    // OK, we've cleaned up all the routes through this guy.
    // Get ready to block waiting for all reference to go
    // away, then dereference our reference. After this, go
    // ahead and try to block. Mostly likely our reference was
    // the last one, so we won't block - we'll wake up immediately.
    CTEInitBlockStruc(&Block);
    IF->if_block = &Block;

    DerefIF(IF);

    (void)CTEBlockWithTracker(&Block, &Tracker, IF);

    //
    // Free the TD resources on the IF.
    //

    while ((Packet = IF->if_tdpacket) != NULL) {

        IF->if_tdpacket =
            ((TDContext *) Packet->ProtocolReserved)->tdc_common.pc_link;

        Buffer = Packet->Private.Head;
        TDBuffer = TcpipBufferVirtualAddress(Buffer, HighPagePriority);
        NdisFreePacket(Packet);
        if (TDBuffer) {
            CTEFreeMem(TDBuffer);
        }
    }

    // OK, we've cleaned up all references, so there shouldn't be
    // any more transmits pending through this interface. Close the
    // adapter to force synchronization with any receives in process.

    (*(IF->if_close)) (IF->if_lcontext);



    // notify our tdi clients that this device is going away.
    if (IF->if_tdibindhandle) {
        TdiDeregisterDeviceObject(IF->if_tdibindhandle);
    }

    DecrInitTimeInterfaces(IF);

    CTEGetLock(&RouteTableLock.Lock, &TableHandle);


    // Clear this index from the bit mask if the user says so

    if (DeleteIndex) {
        ASSERT(RtlCheckBit(&g_rbIfMap, (IF->if_index - 1)) == 1);

        RtlClearBits(&g_rbIfMap,
                     IF->if_index - 1,
                     1);
    }


    // Now walk the IFList, looking for this guy. When we find him, free him.
    PrevIF = STRUCT_OF(Interface, &IFList, if_next);
    while (PrevIF->if_next != IF && PrevIF->if_next != NULL)
        PrevIF = PrevIF->if_next;

    if (PrevIF->if_next != NULL) {
        PrevIF->if_next = IF->if_next;
        NumIF--;

        if (IF->if_name.Buffer) {
            CTEFreeMem(IF->if_name.Buffer);
        }
        // CTEFreeMem(IF);
        FreeInterface(IF);
    } else
        ASSERT(FALSE);

    CTEFreeLock(&RouteTableLock.Lock, TableHandle);

    // finally, reenumerate the entitylist since this device is going away.
    NotifyElistChange();

    UniqueIfNumber++;
}

NTSTATUS
IPReserveIndex(
               IN ULONG ulNumIndices,
               OUT PULONG pulStartIndex,
               OUT PULONG pulLongestRun
               )
/*++

Routine Description:

    Reserves a contiguous run of indices in the g_rbIfMap.
    It is used by modules (arp modules) so that they can multiplex many
    interfaces over a single IP interface and yet have different indices
    for each one.

Locks:

    Once IP gets its act in order we will need to lock the g_rbIfMap

Arguments:

    ulNumIndices    Number of indices to reserve
    pulStartIndex   If successful, this holds the first index reserved
    pulLongestRun   If not successful, this holds the size of the longest
                    run currently available. Note that since the lock is not
                    held between invocations of this function, this is only a
                    hint

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/

{
    RTL_BITMAP_RUN Run;
    CTELockHandle Handle;

    CTEGetLock(&RouteTableLock.Lock,
               &Handle);

    *pulStartIndex = RtlFindClearBitsAndSet(&g_rbIfMap,
                                            ulNumIndices,
                                            0);

    if (*pulStartIndex == -1) {
        ULONG ulNumRuns;

        ulNumRuns = RtlFindClearRuns(&g_rbIfMap,
                                     &Run,
                                     1,
                                     TRUE);

        *pulLongestRun = 0;

        if (ulNumRuns == 1) {
            *pulLongestRun = Run.NumberOfBits;
        }
        CTEFreeLock(&RouteTableLock.Lock,
                    Handle);

        return STATUS_INSUFFICIENT_RESOURCES;
    } else {
        //
        // We use a 1 based index
        //

        (*pulStartIndex)++;

        //
        // Reserving an index is also considered a PNP act
        //

        UniqueIfNumber++;

        *pulStartIndex = (*pulStartIndex) | (UniqueIfNumber << IF_INDEX_SHIFT);
    }

    CTEFreeLock(&RouteTableLock.Lock,
                Handle);

    return STATUS_SUCCESS;
}

VOID
IPDereserveIndex(
                 IN ULONG ulNumIndices,
                 IN ULONG ulStartIndex
                 )
/*++

Routine Description:

    Frees a contiguous run of indices

Locks:

    Once IP gets its act in order we will need to lock the g_rbIfMap

Arguments:

    ulNumIndices    Number to free
    ulStartIndex    Starting index

Return Value:

--*/

{
    ULONG ulIndex;
    CTELockHandle Handle;

    ulIndex = ulStartIndex & ~IF_INDEX_MASK;

    CTEGetLock(&RouteTableLock.Lock,
               &Handle);

    if (!RtlAreBitsSet(&g_rbIfMap,
                       ulIndex - 1,
                       ulNumIndices)) {
        //
        // This should not happen.
        //

        ASSERT(FALSE);

        CTEFreeLock(&RouteTableLock.Lock,
                    Handle);
        return;
    }
    RtlClearBits(&g_rbIfMap,
                 ulIndex - 1,
                 ulNumIndices);

    CTEFreeLock(&RouteTableLock.Lock,
                Handle);
}

NTSTATUS
IPChangeIfIndexAndName(
                       IN PVOID pvContext,
                       IN ULONG ulNewIndex,
                       IN PUNICODE_STRING pusNewName OPTIONAL
                       )
/*++

Routine Description:

    Changes the interface index on an interface. Also changes the name, if
    one is given

Locks:

    Takes the interface lock. Fat lot of good it does us, since everyone else
    doesnt take that lock

Arguments:

    pvContext   Context given to the ARP layer (pointer to primary NTE)
    ulNewIndex  New Index to be given. This should have been reserved
    pusNewName  New name

Return Value:

    STATUS_SUCCESS

--*/

{
    Interface *pIf;
    CTELockHandle Handle;

    ASSERT(pvContext);

    CTEGetLock(&RouteTableLock.Lock,
               &Handle);

    ASSERT(RtlCheckBit(&g_rbIfMap, ((ulNewIndex & ~IF_INDEX_MASK) - 1)) == 1);

    pIf = ((NetTableEntry *) pvContext)->nte_if;

    if (!pIf) {
        CTEFreeLock(&RouteTableLock.Lock,
                    Handle);
        return STATUS_UNSUCCESSFUL;
    }
    CTEGetLockAtDPC(&(pIf->if_lock));

    pIf->if_index = ulNewIndex;

    //
    // Also change the names
    //

    if (pusNewName) {
        ASSERT((pusNewName->Length % sizeof(WCHAR)) == 0);

        if (pIf->if_name.Buffer) {
            CTEFreeMem(pIf->if_name.Buffer);

            pIf->if_name.Buffer = NULL;

            pIf->if_name.Buffer =
                CTEAllocMemN(pusNewName->Length + sizeof(WCHAR),
                             'wICT');

            if (pIf->if_name.Buffer) {
                pIf->if_name.Length = pusNewName->Length;
                pIf->if_name.MaximumLength = pusNewName->Length + sizeof(WCHAR);

                RtlCopyMemory(pIf->if_name.Buffer,
                           pusNewName->Buffer,
                           pusNewName->Length);

                pIf->if_name.Buffer[pusNewName->Length / sizeof(WCHAR)] =
                    UNICODE_NULL;
            }
        }
    }
    CTEFreeLockFromDPC(&(pIf->if_lock));

    CTEFreeLock(&RouteTableLock.Lock,
                Handle);

    return STATUS_SUCCESS;
}

NTSTATUS
IPGetIfIndex(
             IN PIRP pIrp,
             IN PIO_STACK_LOCATION pIrpSp
             )
/*++

Routine Description:

    Gets the Interface index given the unique ID (GUID) for the interface

Locks:

    Takes the route table lock and the interface lock.

Arguments:

    pIrp
    pIrpSp

Return Value:

    STATUS_SUCCESS

--*/

{
    ULONG ulInputLen, ulOutputLen, ulMaxLen, i;
    USHORT usNameLen, usPrefixLen, usPrefixCount, usIfNameLen;
    BOOLEAN bTerminated;
    NTSTATUS nStatus;
    CTELockHandle Handle;
    PWCHAR pwszBuffer;

    PIP_GET_IF_INDEX_INFO pRequest;
    Interface *pIf;

    nStatus = STATUS_OBJECT_NAME_NOT_FOUND;

    ulInputLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    ulOutputLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ((ulInputLen < sizeof(IP_GET_IF_INDEX_INFO)) ||
        (ulOutputLen < sizeof(IP_GET_IF_INDEX_INFO))) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    pRequest = (PIP_GET_IF_INDEX_INFO) (pIrp->AssociatedIrp.SystemBuffer);

    //
    // See if the Name is  NULL terminated
    //

    ulMaxLen = ulInputLen - FIELD_OFFSET(IP_GET_IF_INDEX_INFO, Name[0]);

    ulMaxLen /= sizeof(WCHAR);

    bTerminated = FALSE;

    for (i = 0; i < ulMaxLen; i++) {
        if (pRequest->Name[i] == UNICODE_NULL) {
            bTerminated = TRUE;

            break;
        }
    }

    if (!bTerminated) {
        return STATUS_INVALID_PARAMETER;
    }
    usNameLen = (USHORT) (i * sizeof(WCHAR));

#if MILLEN
    // There is no prefix on Millennium.
    usPrefixCount = 0;
    usPrefixLen   = 0;
#else // MILLEN
    usPrefixCount = (USHORT) wcslen(TCP_EXPORT_STRING_PREFIX);
    usPrefixLen = (USHORT) (usPrefixCount * sizeof(WCHAR));
#endif // !MILLEN

    pRequest->Index = INVALID_IF_INDEX;
    pIrp->IoStatus.Information = 0;

    CTEGetLock(&RouteTableLock.Lock,
               &Handle);

    for (pIf = IFList;
         pIf != NULL;
         pIf = pIf->if_next) {

        //
        // See if the names compare
        // (i) The length of our name - the prefix length should be ==
        // the user supplied name and
        // (ii) The names should actually be the same
        //

        CTEGetLockAtDPC(&(pIf->if_lock));

        //
        // The name compared is the if_name, if it exists, otherwise
        // the device name
        //

        if (pIf->if_name.Buffer) {
            pwszBuffer = pIf->if_name.Buffer;

            usIfNameLen = pIf->if_name.Length;
        } else {
            pwszBuffer = &(pIf->if_devname.Buffer[usPrefixCount]);

            usIfNameLen = pIf->if_devname.Length;

#if DBG

            if (pIf != &LoopInterface) {
                ASSERT(usIfNameLen > usPrefixLen);
            }
#endif

            usIfNameLen = usIfNameLen - (ushort) usPrefixLen;
        }

        if (usIfNameLen != usNameLen) {
            CTEFreeLockFromDPC(&(pIf->if_lock));

            continue;
        }
        if (RtlCompareMemory(pwszBuffer,
                             pRequest->Name,
                             usNameLen) != usNameLen) {
            CTEFreeLockFromDPC(&(pIf->if_lock));

            continue;
        }
        pRequest->Index = pIf->if_index;

        CTEFreeLockFromDPC(&(pIf->if_lock));

        nStatus = STATUS_SUCCESS;

        pIrp->IoStatus.Information = sizeof(IP_GET_IF_INDEX_INFO);

        break;
    }

    CTEFreeLock(&RouteTableLock.Lock,
                Handle);

    return nStatus;

}

NTSTATUS
IPGetIfName(
            IN PIRP pIrp,
            IN PIO_STACK_LOCATION pIrpSp
            )
/*++

Routine Description:

    Gets the interface information for the interfaces added to IP
    Badly named, but that is because someone already took the GetInterfaceInfo
    IOCTL without actually providing it in a usable format.

Locks:

    Takes the route table lock and the interface lock.

Arguments:

    pIrp
    pIrpSp

Return Value:

    STATUS_SUCCESS

--*/

{
    ULONG ulInputLen, ulOutputLen, ulNumEntries, i;
    USHORT usPrefixCount, usPrefixLen;
    NTSTATUS nStatus;
    Interface *pIf;


    UNICODE_STRING usTempString;
    CTELockHandle Handle;
    PIP_GET_IF_NAME_INFO pInfo;

    ulInputLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    ulOutputLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    pInfo = (PIP_GET_IF_NAME_INFO) (pIrp->AssociatedIrp.SystemBuffer);

    //
    // See how much space we have
    //

    pIrp->IoStatus.Information = 0;

    if (ulInputLen < FIELD_OFFSET(IP_GET_IF_NAME_INFO, Count)) {
        //
        // Not even a context?
        //

        return STATUS_INVALID_PARAMETER;
    }
    if (ulOutputLen < sizeof(IP_GET_IF_NAME_INFO)) {
        //
        // Should be space for one info block atleast
        //

        return STATUS_BUFFER_TOO_SMALL;
    }
    //
    // Figure how many entries we can fit
    //

    ulNumEntries =
        ((ulOutputLen - FIELD_OFFSET(IP_GET_IF_NAME_INFO, Info)) / sizeof(IP_INTERFACE_NAME_INFO));

    ASSERT(ulNumEntries > 0);

#if MILLEN
    // There is no prefix on Millennium.
    usPrefixCount = 0;
    usPrefixLen   = 0;
#else // MILLEN
    usPrefixCount = (USHORT) wcslen(TCP_EXPORT_STRING_PREFIX);
    usPrefixLen = (USHORT) (usPrefixCount * sizeof(WCHAR));
#endif // !MILLEN

    //
    // The interface list itself is protected by the route table lock
    //

    CTEGetLock(&RouteTableLock.Lock,
               &Handle);

    //
    // See if there is a resume context. If there is, go to that interface
    // The context is nothing but the index of the interface from which to
    // start from
    //

    pIf = IFList;

    while (pIf != NULL) {
        if (pIf != &LoopInterface) {
            //
            // We skip the loopback interface since it doesnt have a GUID (yet)
            //

            if (pIf->if_index >= pInfo->Context) {
                //
                // This interface has an index >= context, so start at this
                //

                break;
            }
        }
        pIf = pIf->if_next;
    }

    //
    // At this point pIf is the interface to start at
    //

    i = 0;

    while ((i < ulNumEntries) &&
           (pIf != NULL)) {
        CTEGetLockAtDPC(&(pIf->if_lock));

        pInfo->Info[i].Index = pIf->if_index;

        //
        // Copy out GUID version of the if name if present
        //

        if (pIf->if_name.Buffer) {
            nStatus = ConvertStringToGuid(&(pIf->if_name),
                                          &(pInfo->Info[i].InterfaceGuid));

            if (nStatus != STATUS_SUCCESS) {
                RtlZeroMemory(&(pInfo->Info[i].InterfaceGuid),
                              sizeof(GUID));
            }
        } else {
            RtlZeroMemory(&(pInfo->Info[i].InterfaceGuid),
                          sizeof(GUID));
        }

        usTempString.MaximumLength =
            usTempString.Length = pIf->if_devname.Length - usPrefixLen;
        usTempString.Buffer = &(pIf->if_devname.Buffer[usPrefixCount]);

        nStatus = ConvertStringToGuid(&usTempString,
                                      &(pInfo->Info[i].DeviceGuid));

        if (nStatus != STATUS_SUCCESS) {
            RtlZeroMemory(&(pInfo->Info[i].DeviceGuid),
                          sizeof(GUID));
        }
        //
        // Copy out the types
        //

        pInfo->Info[i].MediaType = pIf->if_mediatype;
        pInfo->Info[i].ConnectionType = pIf->if_conntype;
        pInfo->Info[i].AccessType = pIf->if_accesstype;

        CTEFreeLockFromDPC(&(pIf->if_lock));

        i++;

        pIf = pIf->if_next;
    }

    if (i == 0) {
        CTEFreeLock(&RouteTableLock.Lock,
                    Handle);

        return STATUS_NO_MORE_ENTRIES;
    }
    pInfo->Count = i;

    if (pIf != NULL) {
        //
        // There are more interfaces left
        //

        pInfo->Context = pIf->if_index;

        nStatus = STATUS_MORE_ENTRIES;
    } else {
        //
        // Done, set the context to 0
        //

        pInfo->Context = 0;

        nStatus = STATUS_SUCCESS;
    }

    CTEFreeLock(&RouteTableLock.Lock,
                Handle);

    pIrp->IoStatus.Information = FIELD_OFFSET(IP_GET_IF_NAME_INFO, Info) +
        i * sizeof(IP_INTERFACE_NAME_INFO);

    return nStatus;
}

NTSTATUS
IPGetMcastCounters(
                   IN PIRP Irp,
                   IN PIO_STACK_LOCATION IrpSp
                   )

/*++
Routine Description:

    Gets multicast counter stats for a given interface

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/

{
    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;
    ULONG BufferLen;
    KIRQL rtlIrql;
    PIP_MCAST_COUNTER_INFO buf;
    ULONG Index;
    Interface *IF;

    buf = (PIP_MCAST_COUNTER_INFO)Irp->AssociatedIrp.SystemBuffer;

    BufferLen = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (BufferLen >= sizeof(ULONG)) {

        BufferLen = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        if (BufferLen >= sizeof(IP_MCAST_COUNTER_INFO)) {

             Index = *(ULONG * )buf;

             CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

             for (IF = IFList; IF != NULL; IF = IF->if_next) {
                 if (IF->if_index == Index) {
                     break;
                 }
             }

             if (IF) {

                 buf->InMcastOctets = IF->if_InMcastOctets;
                 buf->OutMcastOctets = IF->if_OutMcastOctets;
                 buf->InMcastPkts = IF->if_InMcastPkts;
                 buf->OutMcastPkts = IF->if_OutMcastPkts;
                 ntStatus = STATUS_SUCCESS;
                 Irp->IoStatus.Information = sizeof(IP_MCAST_COUNTER_INFO);
             }

             CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
        }
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return ntStatus;
}



#pragma BEGIN_INIT

//** ipinit - Initialize ourselves.
//
//  This routine is called during initialization from the OS-specific
//  init code. We need to check for the presence of the common xport
//  environment first.
//
//
//  Entry: Nothing.
//
//  Returns: 0 if initialization failed, non-zero if it succeeds.
//
int
IPInit()
{
    IPConfigInfo *ci;            // Pointer to our IP configuration info.
    uint i;
    NetTableEntry *nt;            // Pointer to current NTE.
    NDIS_STATUS Status;
    NetTableEntry *NetTableList;
    IPAddr LoopBackAddr;

    DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("+IPInit()\n")));

    if (!CTEInitialize())
        return IP_INIT_FAILURE;

    DEBUGMSG(DBG_INFO && DBG_INIT, (DTEXT("IPInit: CTEInitialize'd\n")));

#if MILLEN
    InitializeListHead(&IfChangeNotifyQueue);
    CTEInitLock(&IfChangeLock);
#endif // MILLEN

    InitializeListHead(&RtChangeNotifyQueue);
    InitializeListHead(&RtChangeNotifyQueueEx);
    InitializeListHead(&AddChangeNotifyQueue);
    CTEInitLock(&AddChangeLock);
    InitFirewallQ();
    RtlZeroMemory(&DummyDHCPNTE, sizeof(DummyDHCPNTE));
    InitRefPtr(&DHCPRefPtr, &RouteTableLock.Lock, &DummyDHCPNTE);

    DEBUGMSG(DBG_INFO && DBG_INIT, (DTEXT("IPInit: calling IPGetConfig\n")));

    if ((ci = IPGetConfig()) == NULL) {
        DEBUGMSG(DBG_ERROR && DBG_INIT, (DTEXT("IPInit: IPGetConfig failure\n")));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPInit [IP_INIT_FAILURE]\n")));
        return IP_INIT_FAILURE;
    }

    // Allocate the NetTableList
    NewNetTableList = CTEAllocMemBoot(NET_TABLE_SIZE * sizeof(PVOID));

    if (NewNetTableList == NULL) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate Nettable \n"));
        return IP_INIT_FAILURE;
    }
    // Initialize our NetTableList hash table
    for (i = 0; i < NET_TABLE_SIZE; i++) {
        NewNetTableList[i] = NULL;
    }

    // Initialize the TransferData packet and buffer pools.
    // N.B. This must be done before loopback initialization.

    TDPacketPool = UlongToPtr(NDIS_PACKET_POOL_TAG_FOR_TCPIP);
    NdisAllocatePacketPoolEx(&Status, &TDPacketPool, PACKET_GROW_COUNT,
                             SMALL_POOL, sizeof(TDContext));
    if (Status == NDIS_STATUS_SUCCESS) {
        NdisAllocateBufferPool(&Status, &TDBufferPool, 1);
        if (Status != NDIS_STATUS_SUCCESS) {
            NdisFreePacketPool(TDPacketPool);
        } else {
            NdisSetPacketPoolProtocolId(TDPacketPool, NDIS_PROTOCOL_ID_TCP_IP);
        }
    }

    if (Status != NDIS_STATUS_SUCCESS) {
        FreeNets();
        CTEFreeMem(NewNetTableList);
        return IP_INIT_FAILURE;
    }

    // Now, initalize our loopback stuff.
    LoopBackAddr = LOOPBACK_ADDR;
    NewNetTableList[NET_TABLE_HASH(LoopBackAddr)] = InitLoopback(ci);
    NetTableList = NewNetTableList[NET_TABLE_HASH(LoopBackAddr)];

    if (NetTableList == NULL) {
        FreeNets();
        CTEFreeMem(NewNetTableList);
        NdisFreeBufferPool(TDBufferPool);
        NdisFreePacketPool(TDPacketPool);
        return IP_INIT_FAILURE;
    }

    if (!InitRouting(ci)) {
        DEBUGMSG(DBG_ERROR && DBG_INIT, (DTEXT("IPInit: InitRouting failure\n")));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPInit [IP_INIT_FAILURE]\n")));

        FreeNets();
        CTEFreeMem(NewNetTableList);
        NdisFreeBufferPool(TDBufferPool);
        NdisFreePacketPool(TDPacketPool);
        return IP_INIT_FAILURE;
    }
    RATimeout = DEFAULT_RA_TIMEOUT;
    LastPI = IPProtInfo;

    InterfaceSize = sizeof(RouteInterface);

    DeadGWDetect = ci->ici_deadgwdetect;
    AddrMaskReply = ci->ici_addrmaskreply;
    PMTUDiscovery = ci->ici_pmtudiscovery;
    IGMPLevel = ci->ici_igmplevel;
    DefaultTTL = MIN(ci->ici_ttl, 255);
    DefaultTOS = ci->ici_tos & 0xfc;
    TRFunctionalMcast = ci->ici_TrFunctionalMcst;

    if (IGMPLevel > 2)
        IGMPLevel = 0;

    InitTimestamp();

    if (NumNTE != 0) {            // We have an NTE, and loopback initialized.




        RtlInitializeBitMap(&g_NTECtxtMap,
                            g_NTECtxtMapBuffer,
                            MAX_NTE_CONTEXT+1);

        RtlClearAllBits(&g_NTECtxtMap);

        //
        // Use the first (index 0) for loopindex
        //

        RtlSetBits(&g_NTECtxtMap,
                   0,
                   1);

        RtlSetBits(&g_NTECtxtMap,
                   1,
                   1);

        RtlSetBits(&g_NTECtxtMap,
                   MAX_NTE_CONTEXT,
                   1);


        // N.B. MAX_TDI_ENTITIES should be < 2^16

        RtlInitializeBitMap(&g_rbIfMap,
                            g_rgulMapBuffer,
                            MAX_TDI_ENTITIES);

        RtlClearAllBits(&g_rbIfMap);

        //
        // Use the first (index 0) for loopindex
        //

        RtlSetBits(&g_rbIfMap,
                   0,
                   1);

        IPSInfo.ipsi_forwarding = (ci->ici_gateway ? IP_FORWARDING :
                                   IP_NOT_FORWARDING);
        IPSInfo.ipsi_defaultttl = DefaultTTL;
        IPSInfo.ipsi_reasmtimeout = DEFAULT_RA_TIMEOUT;

        // Allocate our packet pools.

        IpHeaderPool = MdpCreatePool (sizeof(IPHeader), 'ihCT');
        if (!IpHeaderPool)
        {
            CloseNets();
            FreeNets();
            IPFreeConfig(ci);
            CTEFreeMem(NewNetTableList);
            NdisFreeBufferPool(TDBufferPool);
            NdisFreePacketPool(TDPacketPool);
            return IP_INIT_FAILURE;
        }

        if (!AllocIPPacketList()) {
            CloseNets();
            FreeNets();
            IPFreeConfig(ci);
            CTEFreeMem(NewNetTableList);
            NdisFreeBufferPool(TDBufferPool);
            NdisFreePacketPool(TDPacketPool);
            return IP_INIT_FAILURE;
        }

        NdisAllocateBufferPool(&Status, &BufferPool, NUM_IP_NONHDR_BUFFERS);

        if (Status != NDIS_STATUS_SUCCESS) {
            CloseNets();
            FreeNets();
            IPFreeConfig(ci);
            CTEFreeMem(NewNetTableList);
            NdisFreeBufferPool(TDBufferPool);
            NdisFreePacketPool(TDPacketPool);
            return IP_INIT_FAILURE;
        }

        ICMPInit(DEFAULT_ICMP_BUFFERS);
        if (!IGMPInit())
            IGMPLevel = 1;

        // Should check error code, and log an event here if this fails.
        InitGateway(ci);

        IPFreeConfig(ci);

        // Loop through, initialize IGMP for each NTE.
        for (i = 0; i < NET_TABLE_SIZE; i++) {
            NetTableEntry *NetTableList = NewNetTableList[i];
            for (nt = NetTableList; nt != NULL; nt = nt->nte_next) {
                InitIGMPForNTE(nt);
            }
        }
        //
        // Allocate per-processor RcvBuf memory.
        //

        g_PerCPUIpBuf = (IPRcvBuf *) CTEAllocMemN( KeNumberProcessors * sizeof(IPRcvBuf), 'jiCT');


        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPInit [SUCCESS]\n")));
        return IP_INIT_SUCCESS;
    } else {
        FreeNets();
        IPFreeConfig(ci);
        CTEFreeMem(NewNetTableList);
        NdisFreeBufferPool(TDBufferPool);
        NdisFreePacketPool(TDPacketPool);
        DEBUGMSG(DBG_ERROR && DBG_INIT, (DTEXT("IPInit: No NTEs or loopback\n")));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-IPInit [IP_INIT_FAILURE]\n")));
        return IP_INIT_FAILURE;    // Couldn't initialize anything.

    }
}

#pragma END_INIT

//** IPProxyNdisRequest - Sends out NDIS requests via ARP on behalf of IPSEC.
//
//  Returns: None
//
NDIS_STATUS
IPProxyNdisRequest(
                   IN PVOID Context,
                   IN NDIS_REQUEST_TYPE RT,
                   IN NDIS_OID Oid,
                   IN VOID * Buffer,
                   IN UINT Length,
                   IN UINT * Needed
                   )
{
    Interface *DestIF = (Interface *) Context;
    ASSERT(!(DestIF->if_flags & IF_FLAGS_DELETING));
    ASSERT(DestIF != &LoopInterface);

    if (DestIF->if_dondisreq) {
        return (*DestIF->if_dondisreq) (DestIF->if_lcontext, RT, Oid, Buffer, Length, Needed, TRUE);
    } else {
        return NDIS_STATUS_FAILURE;
    }
}

//** IPEnableSniffer - Enables the sniffer on the adapter passed in
//
//  Returns: None
//
NTSTATUS
IPEnableSniffer(
                IN PUNICODE_STRING AdapterName,
                IN PVOID Context
                )
{
    Interface *NewIF;
    CTELockHandle Handle;
    NDIS_STRING LocalAdapterName;
    UINT IFExportNamePrefixLen, IFBindNamePrefixLen;

    PAGED_CODE();

#if MILLEN
    // No bind or export prefix on Millennium.
    IFExportNamePrefixLen = 0;
    IFBindNamePrefixLen   = 0;
#else // MILLEN
    IFExportNamePrefixLen = (uint) (wcslen(TCP_EXPORT_STRING_PREFIX) * sizeof(WCHAR));
    IFBindNamePrefixLen = (uint) (wcslen(TCP_BIND_STRING_PREFIX) * sizeof(WCHAR));
#endif // !MILLEN
    LocalAdapterName.Length = (ushort) (AdapterName->Length + IFExportNamePrefixLen - IFBindNamePrefixLen);
    LocalAdapterName.MaximumLength = LocalAdapterName.Length + sizeof(WCHAR);
    LocalAdapterName.Buffer = CTEAllocMem(LocalAdapterName.MaximumLength);

    if (LocalAdapterName.Buffer == NULL) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPEnableSniffer: Failed to alloc AdapterName buffer\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(LocalAdapterName.Buffer, LocalAdapterName.MaximumLength);

#if !MILLEN
    RtlCopyMemory(LocalAdapterName.Buffer,
               TCP_EXPORT_STRING_PREFIX,
               IFExportNamePrefixLen);
#endif // !MILLEN

    RtlCopyMemory((UCHAR *) LocalAdapterName.Buffer + IFExportNamePrefixLen,
               (UCHAR *) AdapterName->Buffer + IFBindNamePrefixLen,
               AdapterName->Length - IFBindNamePrefixLen);

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AdapterName: %ws\n", AdapterName->Buffer));
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"LocalAdapterName: %ws\n", LocalAdapterName.Buffer));

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (NewIF = IFList; NewIF != NULL; NewIF = NewIF->if_next) {

        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IFName: %lx\n", &NewIF->if_devname.Buffer));
        if (!RtlCompareUnicodeString(&LocalAdapterName,
                                     &NewIF->if_devname,
                                     TRUE)) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Matched: %lx Ctx: %lx\n", NewIF, Context));
            NewIF->if_ipsecsniffercontext = Context;
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            CTEFreeMem(LocalAdapterName.Buffer);
            return STATUS_SUCCESS;
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);
    CTEFreeMem(LocalAdapterName.Buffer);
    return STATUS_INVALID_PARAMETER;
}

//** IPDisableSniffer - Disables the sniffer on the adapter passed in
//
//  Returns: None
//
NTSTATUS
IPDisableSniffer(
                 IN PUNICODE_STRING AdapterName
                 )
{
    Interface *NewIF;
    CTELockHandle Handle;
    NDIS_STRING LocalAdapterName;
    UINT IFExportNamePrefixLen, IFBindNamePrefixLen;

    PAGED_CODE();

#if MILLEN
    // No bind or export prefix on Millennium.
    IFExportNamePrefixLen = 0;
    IFBindNamePrefixLen   = 0;
#else // MILLEN
    IFExportNamePrefixLen = (uint) (wcslen(TCP_EXPORT_STRING_PREFIX) * sizeof(WCHAR));
    IFBindNamePrefixLen = (uint) (wcslen(TCP_BIND_STRING_PREFIX) * sizeof(WCHAR));
#endif // !MILLEN
    LocalAdapterName.Length = (USHORT) (AdapterName->Length + IFExportNamePrefixLen - IFBindNamePrefixLen);
    LocalAdapterName.MaximumLength = LocalAdapterName.Length + sizeof(WCHAR);
    LocalAdapterName.Buffer = CTEAllocMem(LocalAdapterName.MaximumLength);

    if (LocalAdapterName.Buffer == NULL) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPEnableSniffer: Failed to alloc AdapterName buffer\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(LocalAdapterName.Buffer, LocalAdapterName.MaximumLength);
#if !MILLEN
    RtlCopyMemory(LocalAdapterName.Buffer,
               TCP_EXPORT_STRING_PREFIX,
               IFExportNamePrefixLen);
#endif // !MILLEN
    RtlCopyMemory((UCHAR *) LocalAdapterName.Buffer + IFExportNamePrefixLen,
               (UCHAR *) AdapterName->Buffer + IFBindNamePrefixLen,
               AdapterName->Length - IFBindNamePrefixLen);

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"AdapterName: %ws\n", AdapterName->Buffer));
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"LocalAdapterName: %ws\n", LocalAdapterName.Buffer));

    CTEGetLock(&RouteTableLock.Lock, &Handle);
    for (NewIF = IFList; NewIF != NULL; NewIF = NewIF->if_next) {
        if (!RtlCompareUnicodeString(&LocalAdapterName,
                                     &NewIF->if_devname,
                                     TRUE)) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Matched: %lx\n", NewIF));
            NewIF->if_ipsecsniffercontext = NULL;
            CTEFreeLock(&RouteTableLock.Lock, Handle);
            CTEFreeMem(LocalAdapterName.Buffer);
            return STATUS_SUCCESS;
        }
    }
    CTEFreeLock(&RouteTableLock.Lock, Handle);
    CTEFreeMem(LocalAdapterName.Buffer);
    return STATUS_INVALID_PARAMETER;
}

//** IPSetIPSecStatus - Inform whether IPSec policies are active or not
//
//  Returns: None
//
NTSTATUS
IPSetIPSecStatus(
                 IN BOOLEAN fActivePolicy
                 )
{

    IPSecStatus = fActivePolicy;
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"IPSec policy status change %x\n", IPSecStatus));

    return STATUS_SUCCESS;
}

//** IPAddAddrComplete - Add Address completion notification.
//
//  This routine is called by the arp module to notify about the add address
//  completion. If the address is in conflict, IP resets the ipaddress of
//  the NTE on which this conflict
//  was detected and then in turn notify the client(e.g dhcp) which requested
//  to set this address.
//
//      Entry:  Address - THe address for which we received the notification.
//          Context     - The context value we gave during addaddress call.
//          Status      - The status of the adding the address.

void
 __stdcall
IPAddAddrComplete(IPAddr Address, void *Context, IP_STATUS Status)
{
    CTELockHandle Handle;
    SetAddrControl *SAC;
    SetAddrRtn Rtn;
    Interface *IF = NULL;
    NetTableEntry *NTE = NULL;
    NetTableEntry *NetTableList;

    SAC = (SetAddrControl *) Context;

    // the address is in conflict. reset the ipaddress on our NTE.
    // Find the nte for this address.

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    NetTableList = NewNetTableList[NET_TABLE_HASH(Address)];
    for (NTE = NetTableList; NTE != NULL; NTE = NTE->nte_next)
        if ((NTE->nte_addr == Address) && ((SAC && (SAC->nte_context == NTE->nte_context)) || (!SAC)))
            break;

    if (NTE == NULL || !(NTE->nte_flags & NTE_VALID)) {
        // if can't match the NTE it means that nte_context is invalid and the address is also 0.
        // In this case use the interface embedded in the SAC (if there is any)
        // This hack is done to complete the add request if delete happens before add is completed
        if (SAC) {
            IF = (Interface *) SAC->interface;
            Status = IP_GENERAL_FAILURE;
        }

        CTEFreeLock(&RouteTableLock.Lock, Handle);

    } else {
        IF = NTE->nte_if;

        // If the NTE is invalidated by deleting the address
        // or because of a failure in IPADDNTE routine after initiating
        // address resolution, IF can be NULL. Check for this
        // before processing this completion.

        if (IF) {
            if (STATUS_SUCCESS != Status) {
                IP_STATUS LocalStatus;
                ASSERT(IP_DUPLICATE_ADDRESS == Status);
                // this routine releases the routetablelock.

                // while setting the ip address to NULL, we just mark the NTE as INVALID
                // we don't actually move the hashes
                LocalStatus = IPpSetNTEAddr(
                                            NTE,
                                            NULL_IP_ADDR,
                                            NULL_IP_ADDR,
                                            &Handle,
                                            NULL,
                                            NULL);

                ASSERT(LocalStatus == IP_SUCCESS);
            } else {
                CTEFreeLock(&RouteTableLock.Lock, Handle);
                // the address was added successfully.
                // now, notify our clients about the new address.
                // Don't notify if the add didn't complete and we have called delete
                NotifyAddrChange(NTE->nte_addr, NTE->nte_mask,
                                 NTE->nte_pnpcontext, NTE->nte_context, &NTE->nte_addrhandle,
                                 &(IF->if_configname), &IF->if_devname, TRUE);
            }
        }
    }

    if (IF) {
        DecrInitTimeInterfaces(IF);
    }

    // now call the client routine and notify the client.

    if (SAC) {
        // now remove the refcount on the interface that we had bumped when
        // setnteaddr was called.
        if (IF) {
           DerefIF(IF);
        }
        Rtn = SAC->sac_rtn;
        (*Rtn) (SAC, Status);
    }
}

// Adds a link on to already created P2MP interface
// Entry: IpIfCtxt: Context (NTE) on which to add the link
//        NextHop: NextHop Address of the link
//        ArpLinkCtxt: Arp layer's link context
//        IpLnkCtxt: Our Link context which is returned to arp layer
//        mtu: mtu of the link

IP_STATUS
_stdcall
IPAddLink(void *IpIfCtxt, IPAddr NextHop, void *ArpLinkCtxt, void **IpLnkCtxt, uint mtu)
{
    NetTableEntry *NTE = (NetTableEntry *) IpIfCtxt;
    Interface *IF = NTE->nte_if;
    CTELockHandle Handle;
    LinkEntry *Link;

    // fail the request if NTE is not valid
    if (!(NTE->nte_flags & NTE_VALID)) {
        return IP_GENERAL_FAILURE;
    }
    if (!IF) {
        return IP_GENERAL_FAILURE;
    }
    CTEGetLock(&RouteTableLock.Lock, &Handle);

    ASSERT(IF->if_flags & IF_FLAGS_P2MP);
    Link = IF->if_link;

    // If we have the nexthop in the list of links
    // just return error, can't add the same link twice

    while (Link) {
        if (Link->link_NextHop == NextHop)
            break;
        Link = Link->link_next;
    }

    if (Link) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return IP_DUPLICATE_ADDRESS;
    }
    // Allocate a new link

    Link = CTEAllocMemN(sizeof(LinkEntry), 'xICT');

    if (!Link) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return IP_NO_RESOURCES;
    }
    RtlZeroMemory(Link, sizeof(LinkEntry));

    //link it to the interface link chain

    Link->link_next = IF->if_link;
    IF->if_link = Link;

    // set various parameters in the link

    Link->link_NextHop = NextHop;
    Link->link_arpctxt = (uint *) ArpLinkCtxt;
    Link->link_if = IF;
    Link->link_mtu = mtu - sizeof(IPHeader);
    Link->link_Action = FORWARD;
    Link->link_refcount = 1;

    //Return this link ptr to the arp module

    *IpLnkCtxt = Link;

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return IP_SUCCESS;

}

//Deletes a link from an interface
// Entry: IpIfCtxt: Context (NTE) on which to delete the link
//        LnkCtxt: Our Link context which was returned to arp layer during addlink

IP_STATUS
_stdcall
IPDeleteLink(void *IpIfCtxt, void *LnkCtxt)
{
    NetTableEntry *NTE = (NetTableEntry *) IpIfCtxt;
    Interface *IF = NTE->nte_if;
    CTELockHandle Handle;
    LinkEntry *Link = (LinkEntry *) LnkCtxt;
    LinkEntry *tmpLink, *prvLink;
    RouteTableEntry *rte, *tmprte;

    ASSERT(Link);

    if (Link->link_if != IF)
        return IP_GENERAL_FAILURE;

    CTEGetLock(&RouteTableLock.Lock, &Handle);

    //remove this and mark the rte pointed by this as
    //invalid

    tmpLink = prvLink = IF->if_link;

    while (tmpLink) {
        if (tmpLink == Link)
            break;
        prvLink = tmpLink;
        tmpLink = tmpLink->link_next;
    }

    if (!tmpLink) {
        CTEFreeLock(&RouteTableLock.Lock, Handle);
        return IP_GENERAL_FAILURE;

    }
    if (tmpLink == prvLink) {    // delete the first element

        IF->if_link = Link->link_next;
    } else {
        prvLink->link_next = Link->link_next;
    }

    rte = Link->link_rte;

    while (rte) {

        rte->rte_flags &= ~RTE_VALID;
        InvalidateRCELinks(rte);
        tmprte = rte;
        rte = rte->rte_nextlinkrte;
        tmprte->rte_link = NULL;
    }

    DerefLink(Link);
    /* KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"DeleteLink: removing link %x\n", Link));
        // freed when refcount goes to 0
        CTEFreeMem(Link); */

    CTEFreeLock(&RouteTableLock.Lock, Handle);
    return IP_SUCCESS;

}

NTSTATUS
FlushArpTable(
              IN PIRP Irp,
              IN PIO_STACK_LOCATION IrpSp
              )
/*++
Routine Description:

    Flush the arp table entries by callinh in to arpflushallate

Arguments:

    Irp          - Pointer to I/O request packet to cancel.
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{

    ULONG InfoBufferLen;

    PULONG pInterfaceIndex;

    KIRQL rtlIrql;

    Interface *Interface;

    //Let this be non pageable code.
    //extract the buffer information

    InfoBufferLen = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    pInterfaceIndex = Irp->AssociatedIrp.SystemBuffer;

    if (InfoBufferLen < sizeof(ULONG)) {
        return STATUS_INVALID_PARAMETER;
    }
    CTEGetLock(&RouteTableLock.Lock, &rtlIrql);

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"FlushATETable NumIF %x\n", *pInterfaceIndex));

    Interface = IFList;

    for (Interface = IFList; Interface != NULL; Interface = Interface->if_next) {

        if ((Interface != &LoopInterface) && Interface->if_index == *pInterfaceIndex) {

            // call the arp module



            if (Interface->if_arpflushallate) {

                LOCKED_REFERENCE_IF(Interface);
                CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
                (*(Interface->if_arpflushallate)) (Interface->if_lcontext);

                DerefIF(Interface);
                return STATUS_SUCCESS;
            }
        }
    }

    //Failed to find the interface

    CTEFreeLock(&RouteTableLock.Lock, rtlIrql);
    return STATUS_INVALID_PARAMETER;

}


const WCHAR GuidFormat[] = L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}";

#define GUID_STRING_SIZE 38

NTSTATUS
ConvertGuidToString(
                    IN GUID * Guid,
                    OUT PUNICODE_STRING GuidString
                    )
/*++

Routine Description:

    Constructs the standard string version of a GUID, in the form:
    "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    Guid -
        Contains the GUID to translate.

    GuidString -
        Returns a string that represents the textual format of the GUID.
        Caller must call RtlFreeUnicodeString to free the buffer when done with
        it.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS if the user string was succesfully
    initialized.

--*/
{
    ASSERT(GuidString->MaximumLength >= (GUID_STRING_SIZE + 1) * sizeof(WCHAR));

    GuidString->Length = GUID_STRING_SIZE * sizeof(WCHAR);

    swprintf(GuidString->Buffer,
             GuidFormat,
             Guid->Data1,
             Guid->Data2,
             Guid->Data3,
             Guid->Data4[0],
             Guid->Data4[1],
             Guid->Data4[2],
             Guid->Data4[3],
             Guid->Data4[4],
             Guid->Data4[5],
             Guid->Data4[6],
             Guid->Data4[7]);

    return STATUS_SUCCESS;
}

#if MILLEN
typedef char *va_list;
#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )
#define va_start(ap,v)  ( ap = (va_list)&v + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )
#endif // MILLEN

static
int
__cdecl
ScanHexFormat(
              IN const WCHAR * Buffer,
              IN ULONG MaximumLength,
              IN const WCHAR * Format,
              ...)
/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    Buffer -
        Contains the source buffer which is to be scanned.

    MaximumLength -
        Contains the maximum length in characters for which Buffer is searched.
        This implies that Buffer need not be UNICODE_NULL terminated.

    Format -
        Contains the format string which defines both the acceptable string format
        contained in Buffer, and the variable parameters which follow.

Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/

{
    va_list ArgList;
    int FormatItems;

    va_start(ArgList, Format);
    for (FormatItems = 0;;) {
        switch (*Format) {
        case 0:
            return (*Buffer && MaximumLength) ? -1 : FormatItems;
        case '%':
            Format++;
            if (*Format != '%') {
                ULONG Number;
                int Width;
                int Long;
                PVOID Pointer;

                for (Long = 0, Width = 0;; Format++) {
                    if ((*Format >= '0') && (*Format <= '9')) {
                        Width = Width * 10 + *Format - '0';
                    } else if (*Format == 'l') {
                        Long++;
                    } else if ((*Format == 'X') || (*Format == 'x')) {
                        break;
                    }
                }
                Format++;
                for (Number = 0; Width--; Buffer++, MaximumLength--) {
                    if (!MaximumLength)
                        return -1;
                    Number *= 16;
                    if ((*Buffer >= '0') && (*Buffer <= '9')) {
                        Number += (*Buffer - '0');
                    } else if ((*Buffer >= 'a') && (*Buffer <= 'f')) {
                        Number += (*Buffer - 'a' + 10);
                    } else if ((*Buffer >= 'A') && (*Buffer <= 'F')) {
                        Number += (*Buffer - 'A' + 10);
                    } else {
                        return -1;
                    }
                }
                Pointer = va_arg(ArgList, PVOID);
                if (Long) {
                    *(PULONG) Pointer = Number;
                } else {
                    *(PUSHORT) Pointer = (USHORT) Number;
                }
                FormatItems++;
                break;
            }
            /* no break */
        default:
            if (!MaximumLength || (*Buffer != *Format)) {
                return -1;
            }
            Buffer++;
            MaximumLength--;
            Format++;
            break;
        }
    }
}

NTSTATUS
ConvertStringToGuid(
                    IN PUNICODE_STRING GuidString,
                    OUT GUID * Guid
                    )
/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

Return Value:

    Returns STATUS_SUCCESS if the buffer contained a valid GUID, else
    STATUS_INVALID_PARAMETER if the string was invalid.

--*/

{
    USHORT Data4[8];
    int Count;

    if (ScanHexFormat(GuidString->Buffer,
                      GuidString->Length / sizeof(WCHAR),
                      GuidFormat,
                      &Guid->Data1,
                      &Guid->Data2,
                      &Guid->Data3,
                      &Data4[0],
                      &Data4[1],
                      &Data4[2],
                      &Data4[3],
                      &Data4[4],
                      &Data4[5],
                      &Data4[6],
                      &Data4[7]) == -1) {
        return STATUS_INVALID_PARAMETER;
    }
    for (Count = 0; Count < sizeof(Data4) / sizeof(Data4[0]); Count++) {
        Guid->Data4[Count] = (UCHAR) Data4[Count];
    }

    return STATUS_SUCCESS;
}

//
// IPSec dummy functions
//
IPSEC_ACTION
IPSecHandlePacketDummy(
                       IN PUCHAR pIPHeader,
                       IN PVOID pData,
                       IN PVOID IPContext,
                       IN PNDIS_PACKET Packet,
                       IN OUT PULONG pExtraBytes,
                       IN OUT PULONG pMTU,
                       OUT PVOID * pNewData,
                       IN OUT  PULONG IpsecFlags,
                       IN UCHAR DestType
                       )
{
    UNREFERENCED_PARAMETER(pIPHeader);
    UNREFERENCED_PARAMETER(pData);
    UNREFERENCED_PARAMETER(IPContext);
    UNREFERENCED_PARAMETER(Packet);
    UNREFERENCED_PARAMETER(pNewData);
    UNREFERENCED_PARAMETER(IpsecFlags);
    UNREFERENCED_PARAMETER(DestType);

    *pExtraBytes = 0;
    *pMTU = 0;
    return eFORWARD;
}

BOOLEAN
IPSecQueryStatusDummy(
                      IN  CLASSIFICATION_HANDLE   GpcHandle
                      )
{
    UNREFERENCED_PARAMETER(GpcHandle);

    return FALSE;
}

VOID
IPSecSendCompleteDummy(
                       IN PNDIS_PACKET Packet,
                       IN PVOID pData,
                       IN PIPSEC_SEND_COMPLETE_CONTEXT pContext,
                       IN IP_STATUS Status,
                       OUT PVOID * ppNewData
                       )
{
    UNREFERENCED_PARAMETER(Packet);
    UNREFERENCED_PARAMETER(pData);
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(Status);
    UNREFERENCED_PARAMETER(ppNewData);

    return;
}

NTSTATUS
IPSecNdisStatusDummy(
                   IN PVOID IPContext,
                   IN UINT  Status
                   )
{
    UNREFERENCED_PARAMETER(IPContext);
    UNREFERENCED_PARAMETER(Status);

    return STATUS_SUCCESS;
}

IPSEC_ACTION
IPSecRcvFWPacketDummy(
                      IN PCHAR pIPHeader,
                      IN PVOID pData,
                      IN UINT DataLength,
                      IN UCHAR DestType
                      )
{
    UNREFERENCED_PARAMETER(pIPHeader);
    UNREFERENCED_PARAMETER(pData);
    UNREFERENCED_PARAMETER(DataLength);
    UNREFERENCED_PARAMETER(DestType);

    return eFORWARD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\ipv4\ipdef.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

#pragma once
#ifndef IPDEF_H_INCLUDED
#define IPDEF_H_INCLUDED

#ifndef IF_REFERENCE_DEBUG
#define IF_REFERENCE_DEBUG 0
#endif

//** IPDEF.H - IP private definitions.
//
// This file contains all of the definitions for IP that
// are private to IP, i.e. not visible to outside layers.

// The following macros assume that 'a' is in network byte order.
//
#define VALID_MASK(a)   ((~net_long(a) & (~net_long(a) + 1)) == 0)

#define CLASSA_ADDR(a)  (( (*((uchar *)&(a))) & 0x80) == 0)
#define CLASSB_ADDR(a)  (( (*((uchar *)&(a))) & 0xc0) == 0x80)
#define CLASSC_ADDR(a)  (( (*((uchar *)&(a))) & 0xe0) == 0xc0)
#define CLASSE_ADDR(a)  ((( (*((uchar *)&(a))) & 0xf0) == 0xf0) && \
                                                ((a) != 0xffffffff))

#define CLASSA_MASK             0x000000ff
#define CLASSB_MASK             0x0000ffff
#define CLASSC_MASK             0x00ffffff
#define CLASSD_MASK             0x000000f0
#define CLASSE_MASK             0xffffffff

#define MCAST_DEST              0x000000e0

#define IP_OPT_COPIED           0x80    // Bit indicating options is to be copied.
#define IP_OPT_TYPE             0
#define IP_OPT_LENGTH           1
#define IP_OPT_DATA             2
#define IP_OPT_PTR              2       // Pointer offset, for those options that have it.
#define IP_TS_OVFLAGS           3       // Offset for overflow and flags.
#define IP_TS_FLMASK            0xf     // Mask for flags
#define IP_TS_OVMASK            0xf0    // Mask for overflow field.
#define IP_TS_MAXOV             0xf0    // Maximum value for the overflow field.
#define IP_TS_INC               0x10    // Increment used on overflow field.

#define MIN_RT_PTR              4
#define MIN_TS_PTR              5

#define TS_REC_TS               0       // Record TS option.
#define TS_REC_ADDR             1       // Record TS and address.
#define TS_REC_SPEC             3       // Only specified addresses record.

#define OPT_SSRR                1       // We've seen a SSRR in this option buffer
#define OPT_LSRR                2       // We've seen a LSRR in this option buffer
#define OPT_RR                  4       // We've seen a RR
#define OPT_TS                  8       // We've seen a TS.
#define OPT_ROUTER_ALERT        0x10    // We-ve seen a Router Alert option already
#define ROUTER_ALERT_SIZE       4       // size of router alert option.

#define MAX_OPT_SIZE            40

#define ALL_ROUTER_MCAST        0x020000E0

// Flags for retrieving interface capabilities.
#define IF_WOL_CAP              0
#define IF_OFFLOAD_CAP          1

// Received option index structure.
//
typedef struct OptIndex {
    uchar   oi_srindex;
    uchar   oi_rrindex;
    uchar   oi_tsindex;
    uchar   oi_srtype;
    uchar   oi_rtrindex;    // rtr alert option
} OptIndex;

// This is a local definition of task offload OID to indicate to DoNdisRequest
// to query for offload capability

#define OID_TCP_TASK_OFFLOAD_EX 0x9999

#define MAX_HDR_SIZE            (sizeof(IPHeader) + MAX_OPT_SIZE)
#define MAX_TOTAL_LENGTH        0xffff
#define MAX_DATA_LENGTH         (MAX_TOTAL_LENGTH - sizeof(IPHeader))

#define DEFAULT_VERLEN          0x45            // Default version and length.

#define IP_VERSION              0x40
#define IP_VER_FLAG             0xF0

#define IP_RSVD_FLAG            0x0080          // Reserved.
#define IP_DF_FLAG              0x0040          // 'Don't fragment' flag
#define IP_MF_FLAG              0x0020          // 'More fragments flag'

#define IP_OFFSET_MASK          ~0x00E0         // Mask for extracting offset field.

typedef IP_STATUS (*ULRcvProc)(void *, IPAddr, IPAddr, IPAddr, IPAddr,
                               IPHeader UNALIGNED *, uint, IPRcvBuf *, uint,
                               uchar, uchar, IPOptInfo *);
typedef uint (*ULStatusProc)(uchar, IP_STATUS, IPAddr, IPAddr, IPAddr, ulong,
                             void *);
typedef void (*ULElistProc)();
typedef NTSTATUS (*ULPnPProc)(void *, IPAddr ipAddr, NDIS_HANDLE handle,
                              PNET_PNP_EVENT);



//* Protocol information structure. These is one of there for each protocol
// bound to an NTE.
//
typedef struct ProtInfo {
    void            (*pi_xmitdone)(void *, PNDIS_BUFFER, IP_STATUS); // Pointer
                                            // to xmit done routine.
    ULRcvProc       pi_rcv;                 // Pointer to receive routine.
    ULStatusProc    pi_status;              // Pointer to status handler.
    void            (*pi_rcvcmplt)(void);   // Pointer to recv. cmplt handler.
    ULPnPProc       pi_pnppower;            // pnp power handler
    ULElistProc     pi_elistchange;         // entity list changed notification
    uchar           pi_protocol;            // Protocol type.
    uchar           pi_valid;               // Is this entry valid?
    uchar           pi_pad[2];              // Pad to dword
} ProtInfo;

#define PI_ENTRY_INVALID         0
#define PI_ENTRY_VALID           1

//* Per-net information. We keep a variety of information for
//  each net, including the IP address, subnet mask, and reassembly
//  information.
//
#define MAX_IP_PROT     7                   // ICMP, IGMP, TCP, UDP, AH,
                                            // ESP & Raw

typedef struct IPRtrEntry {
    struct IPRtrEntry *ire_next;
    IPAddr          ire_addr;
    long            ire_preference;
    ushort          ire_lifetime;
    ushort          ire_pad;
} IPRtrEntry;

typedef struct NetTableEntry {
    struct NetTableEntry    *nte_next;      // Next NTE of I/F.
    IPAddr                  nte_addr;       // IP address for this net.
    IPMask                  nte_mask;       // Subnet mask for this net.
    struct Interface        *nte_if;        // Pointer to interface for
                                            // this net.
    struct NetTableEntry    *nte_ifnext;    // Linkage on if chain.
    ushort                  nte_flags;      // Flags for NTE.
    ushort                  nte_context;    // Context passed to upper
                                            // layers.
    ulong                   nte_instance;   // Unique instance ID for this
                                            // net
    void                    *nte_pnpcontext; // PNP context.
    DEFINE_LOCK_STRUCTURE(nte_lock)
    struct ReassemblyHeader *nte_ralist;    // Reassembly list.
    struct EchoControl      *nte_echolist;  // List of pending echo control
                                            // blocks
    CTETimer                nte_timer;      // Timer for this net.
    CTEBlockStruc           nte_timerblock; // used to sync stopping the
                                            // interface timer
    ushort                  nte_mss;
    ushort                  nte_pad;        // for alignment.
    uint                    nte_icmpseq;    // ICMP seq. #. 32 bit to reduce
                                            // collisions from wraparound.
    struct IGMPAddr         **nte_igmplist; // Pointer to hash table
    void                    *nte_addrhandle; // Handle for address
                                            // registration.
    IPAddr                  nte_rtrdiscaddr; // Address used for Router
                                            // Discovery
    uchar                   nte_rtrdiscstate; // state of router solicitations
    uchar                   nte_rtrdisccount; // router solicitation count
    uchar                   nte_rtrdiscovery;
    uchar                   nte_deleting;
    IPRtrEntry              *nte_rtrlist;
    uint                    nte_igmpcount;  // total number of groups joined on this NTE
} NetTableEntry;

// Note - Definition here has dependency on addr type defined in iprtrmib.h

#define NTE_VALID           0x0001          // NTE is valid.
#define NTE_COPY            0x0002          // For NDIS copy lookahead
#define NTE_PRIMARY         0x0004          // This is the 'primary' NTE
                                            // on the I/F.
#define NTE_ACTIVE          0x0008          // NTE is active,
                                            // i.e. interface is valid.
#define NTE_DYNAMIC         0x0010          // NTE was created dynamically
#define NTE_DHCP            0x0020          // Is DHCP working on this
                                            // interface?
#define NTE_DISCONNECTED    0x0040          // Is Media disconnected?
#define NTE_TIMER_STARTED   0x0080          // Is timer started for this?
#define NTE_IF_DELETING     0x0100          // nte->if is soon to be deleted
#define NTE_TRANSIENT_ADDR  0x0200          // Transient addr type




//========================================================================
//  DHCPNTE is used by the sendpath to figure out which NTE to send on.
//  nte_flags & NTE_DHCP is used to decide at the receive path if the
//  NTE is dhcp-mode (is trying to get an address) to push the packet up
//  further to dhcpcsvc.dll.
//  The basic logic used by dhcp is :
//    each interface do : (in parallel)
//        SetDHCPNTE on the interface and send packet out (atomic)
//        process packet and maybe go to above step.
//        Set address and call SetDHCPNTE w/ invalid interface
//  Step one sets the DHCPNTE variable and the nte_flags on this NTE.
//  Step 3 turns off the  DHCPNTE variable making it NULL.
//  Step 2 set the nte_flags & NTE_DHCP to false.. turns off the flag.
//=======================================================================

#define IP_TIMEOUT              500

#define NTE_RTRDISC_UNINIT      0
#define NTE_RTRDISC_DELAYING    1
#define NTE_RTRDISC_SOLICITING  2

#define MAX_SOLICITATION_DELAY  2   // ticks to delay
#define SOLICITATION_INTERVAL   6   // ticks between solicitations
#define MAX_SOLICITATIONS       3   // number of solicitations

//* Buffer reference structure. Used by broadcast and fragmentation code to
// track multiple references to a single user buffer.
typedef struct BufferReference {
    PNDIS_BUFFER        br_buffer;      // Pointer to uses buffer.
    DEFINE_LOCK_STRUCTURE(br_lock)
    int                 br_refcount;    // Count of references to user's buffer.
    PNDIS_BUFFER        br_userbuffer;      // Buffer to be restored, in header incl case.
} BufferReference;

// Definitions of flags in pc_flags field
#define PACKET_FLAG_OPTIONS     0x01    // Set if packet has an options buffer.
#define PACKET_FLAG_IPBUF       0x02    // Set if packet is composed of IP
                                        // buffers.
#define PACKET_FLAG_RA          0x04    // Set if packet is being used for
                                        // reassembly.
#define PACKET_FLAG_FW          0x08    // Set if packet is a forwarding packet.
#define PACKET_FLAG_IPHDR       0x10    // Packet uses an IP hdr buffer.
#define PACKET_FLAG_SNAP        0x20    // Packet uses a SNAP header.

//* Transfer data packet context.
// Used when TD'ing a packet - we store information for the callback here.
//
typedef struct TDContext {
    struct PCCommon     tdc_common;
    void                *tdc_buffer;    // Pointer to buffer containing data.
    NetTableEntry       *tdc_nte;       // NTE to receive this on.
    struct RABufDesc    *tdc_rbd;       // Pointer to RBD, if any.
    uchar               tdc_dtype;      // Destination type of original address.
    uchar               tdc_hlength;    // Length in bytes of header.
    uchar               tdc_pad[2];
    uchar               tdc_header[MAX_HDR_SIZE + 8];
} TDContext;

// IP requests to NDIS miniports through ARP
//
typedef void (*RCCALL) (PVOID pRequestInfo);

// General request block for asynchronous NDIS requests
//
#pragma warning(push)
#pragma warning(disable:4200) // nonstandard extension used: zero size array

typedef struct ReqInfoBlock {
    ulong               RequestType;
    ulong               RequestRefs;    // Reference Count on this block
    RCCALL              ReqCompleteCallback; // Request Complete Callback
    uchar               RequestLength;
    uchar               RequestInfo[0]; // Variable length - see below
} ReqInfoBlock;

#pragma warning(pop)


#if FFP_SUPPORT

// Default FFP startup params
//
#define DEFAULT_FFP_FFWDCACHE_SIZE 0    // 0 => FFP code picks default cachesize
#define DEFAULT_FFP_CONTROL_FLAGS  0x00010001 // Enable Fast Forwarding with
                                        // Filtering
// FFP Cache Params In the Registry
//
extern ulong FFPRegFastForwardingCacheSize;
extern ulong FFPRegControlFlags;

// Some timing parameters in secs
//
#define FFP_IP_FLUSH_INTERVAL       5   // Min time interval between
                                        // consequtive flush requests
#endif // if FFP_SUPPORT


//* Firewall queue entry definition
//
typedef struct FIREWALL_INFO {
    Queue               hook_q;         // Queue linkage for firewall hook in IF
    IPPacketFirewallPtr hook_Ptr;       // Packet firewall callout.
    uint                hook_priority;  // Recv Priority of the hook
} FIREWALL_HOOK, *PFIREWALL_HOOK;

typedef struct LinkEntry {
    struct LinkEntry    *link_next;     // next link in chain
    IPAddr              link_NextHop;   // next hop address of the link
    struct Interface    *link_if;       // back ptr to the interface
    void                *link_arpctxt;  // link layers context
    struct RouteTableEntry *link_rte;   // rte chain associated with this link
    uint                link_Action;    // needed for filter hooks;
                                        // by default FORWARD
    uint                link_mtu;       // mtu of the link
    long                link_refcount;  // refcount for the link
} LinkEntry;

// Some flags for multicast properties
//
#define IPMCAST_IF_ENABLED      (uchar)0x01
#define IPMCAST_IF_WRONG_IF     (uchar)0x02
#define IPMCAST_IF_ACCEPT_ALL   (uchar)0x04

//* Information about net interfaces. There can be multiple nets for each
//  interface, but there is exactly one interface per net.
//


#if IF_REFERENCE_DEBUG

#define MAX_IFREFERENCE_HISTORY  4

typedef struct _IF_REFERENCE_HISTORY {
    uchar *File;
    uint Line;
    void *Caller;
    uint Count;
} IF_REFERENCE_HISTORY;

#endif // IF_REFERENCE_DEBUG

typedef struct Interface {
    struct Interface    *if_next;       // Next interface in chain.
    void                *if_lcontext;   // Link layer context.

    ARP_TRANSMIT        if_xmit;
    ARP_TRANSFER        if_transfer;
    ARP_RETURN_PKT      if_returnpkt;
    ARP_CLOSE           if_close;
    ARP_ADDADDR         if_addaddr;
    ARP_DELADDR         if_deladdr;
    ARP_INVALIDATE      if_invalidate;
    ARP_OPEN            if_open;
    ARP_QINFO           if_qinfo;
    ARP_SETINFO         if_setinfo;
    ARP_GETELIST        if_getelist;
    ARP_DONDISREQ       if_dondisreq;

    NDIS_STATUS         (__stdcall *if_dowakeupptrn)(void *, PNET_PM_WAKEUP_PATTERN_DESC, ushort, BOOLEAN);
    void                (__stdcall *if_pnpcomplete)(void *, NDIS_STATUS, PNET_PNP_EVENT);
    NDIS_STATUS         (__stdcall *if_setndisrequest)(void *, NDIS_OID, uint);
    NDIS_STATUS         (__stdcall *if_arpresolveip)(void *, IPAddr, void *);
    BOOLEAN             (__stdcall *if_arpflushate)(void *, IPAddr);
    void                (__stdcall *if_arpflushallate)(void *);

    uint                if_numgws;              // Number of default gateways
    IPAddr              if_gw[MAX_DEFAULT_GWS]; //IPaddresses for gateways
    uint                if_gwmetric[MAX_DEFAULT_GWS];
    uint                if_metric;
    uchar               if_dfencap;
    uchar               if_rtrdiscovery;        // is router discovery enabled?
    ushort              if_dhcprtrdiscovery;    // is router discovery DHCP-enabled?
    PNDIS_PACKET        if_tdpacket;    // Packet used for transferring data.
    uint                if_index;       // Index of this interface.
    ULONG               if_mediatype;
    uchar               if_accesstype;
    uchar               if_conntype;
    uchar               if_mcastttl;
    uchar               if_mcastflags;
    LONGLONG            if_lastupcall;
    uint                if_ntecount;    // Valid NTEs on this interface.
    NetTableEntry       *if_nte;        // Pointer to list of NTE on interface.
    IPAddr              if_bcast;       // Broadcast address for this interface.
    uint                if_mtu;         // True maximum MTU for the interface.
    uint                if_speed;       // Speed in bits/sec of this interface.
    uint                if_flags;       // Flags for this interface.
    uint                if_addrlen;     // Length of i/f addr.
    uchar               *if_addr;       // Pointer to addr.
    uint                IgmpVersion;     //igmp version active on this interface
    uint                IgmpVer1Timeout; //Version 1 router present timeout
    uint                IgmpVer2Timeout;// Version 2 router present timeout
    uint                IgmpGeneralTimer; //General query response timer
    uint                if_refcount;    // Reference count for this i/f.
    CTEBlockStruc       *if_block;      // Block structure for PnP.
    void                *if_pnpcontext; // Context to pass to upper layers.
    HANDLE              if_tdibindhandle;
    uint                if_llipflags;   // Lower layer flags
    NDIS_STRING         if_configname;  // Name of the i/f config section
    NDIS_STRING         if_name;        // The current name of the interface
    NDIS_STRING         if_devname;     // The name of the device
    PVOID               if_ipsecsniffercontext; // context for IPSEC sniffer
    DEFINE_LOCK_STRUCTURE(if_lock)

#if FFP_SUPPORT
    ulong               if_ffpversion;  // Version of FFP code (or zero)
    ULONG_PTR           if_ffpdriver;   // Driver that does FFP (or zero)
#endif // if FFP_SUPPORT

    uint                if_OffloadFlags;    // IP offload capability flags.
    uint                if_IPSecOffloadFlags; // IPSec offload capability flags.
    uint                if_MaxOffLoadSize;
    uint                if_MaxSegments;
    NDIS_TASK_TCP_LARGE_SEND if_TcpLargeSend;
    uint                if_TcpWindowSize;
    uint                if_TcpInitialRTT;
    uchar               if_TcpDelAckTicks;
    uchar               if_TcpAckFrequency; // holds ack frequency for this Interface
    uchar               if_absorbfwdpkts;
    uchar               if_InitInProgress;
    uchar               if_resetInProgress;
    uchar               if_promiscuousmode;
    uchar               if_auto_metric;     // whether it is in auto mode or not
    uchar               if_iftype;          // type of interface: allow unicast/mcast/both
    LinkEntry           *if_link;           // chain of links for this interface
    void                (__stdcall *if_closelink)(void *, void *);
    uint                if_mediastatus;
    uint                if_pnpcap;          // remeber pnpcapability of the adapter
    struct Interface    *if_dampnext;
    ushort              if_damptimer;
    ushort              if_wlantimer;
    ULONGLONG           if_InMcastPkts;     // Multicast counters for packets rcvd
    ULONGLONG           if_InMcastOctets;   // and bytes rcvd
    ULONGLONG           if_OutMcastPkts;    // Multicast packets sent and
    ULONGLONG           if_OutMcastOctets;  // bytes sent
    ARP_CANCEL          if_cancelpackets;
    uint                if_order;           // holds this interface's position
                                            // in the admin-specified ordering
                                            // of adapters.
    int                 if_lastproc;        // Processor that got the most 
                                            // recent receive indication
